begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** w o r d s . c ** Forth Inspired Command Language ** ANS Forth CORE word-set written in C ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_include
include|#
directive|include
file|"math64.h"
end_include

begin_function_decl
specifier|static
name|void
name|colonParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|literalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interpWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** Control structure building words use these ** strings' addresses as markers on the stack to  ** check for structure completion. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|doTag
index|[]
init|=
literal|"do"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|colonTag
index|[]
init|=
literal|"colon"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|leaveTag
index|[]
init|=
literal|"leave"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|destTag
index|[]
init|=
literal|"target"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|origTag
index|[]
init|=
literal|"origin"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Pointers to various words in the dictionary ** -- initialized by ficlCompileCore, below -- ** for use by compiling words. Colon definitions ** in ficl are lists of pointers to words. A bit ** simple-minded... */
end_comment

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pBranchParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pComma
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pDoParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pDoesParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pExitParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pIfParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pInterpret
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pLitParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pTwoLitParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pLoopParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pPLoopParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pQDoParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pSemiParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pStore
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pStringLit
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pType
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pGetLocalParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pGet2LocalParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pGetLocal0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pGetLocal1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pToLocalParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pTo2LocalParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pToLocal0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pToLocal1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pLinkParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_WORD
modifier|*
name|pUnLinkParen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nLocals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CELL
modifier|*
name|pMarkLocals
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|doLocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do2LocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** C O N T R O L   S T R U C T U R E   B U I L D E R S ** ** Push current dict location for later branch resolution. ** The location may be either a branch target or a patch address... */
end_comment

begin_function
specifier|static
name|void
name|markBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|markControlTag
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|matchControlTag
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error -- unmatched control structure \"%s\""
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Expect a branch target address on the param stack, ** compile a literal offset from the current dict location ** to the target address */
end_comment

begin_function
specifier|static
name|void
name|resolveBackBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|long
name|offset
decl_stmt|;
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|offset
operator|=
name|patchAddr
operator|-
name|dp
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Expect a branch patch address on the param stack, ** compile a literal offset from the patch location ** to the current dict location */
end_comment

begin_function
specifier|static
name|void
name|resolveForwardBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|long
name|offset
decl_stmt|;
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Match the tag to the top of the stack. If success, ** sopy "here" address into the cell whose address is next ** on the stack. Used by do..leave..loop. */
end_comment

begin_function
specifier|static
name|void
name|resolveAbsBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"Warning -- Unmatched control word: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i s N u m b e r ** Attempts to convert the NULL terminated string in the VM's pad to  ** a number using the VM's current base. If successful, pushes the number ** onto the param stack and returns TRUE. Otherwise, returns FALSE. **************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|isNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_INT
name|accum
init|=
literal|0
decl_stmt|;
name|char
name|isNeg
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|base
init|=
name|pVM
operator|->
name|base
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|SI_PTR
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|FICL_COUNT
name|count
init|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|unsigned
name|ch
decl_stmt|;
name|unsigned
name|digit
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|isNeg
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
condition|)
block|{
comment|/* detect 0xNNNN format for hex numbers */
name|cp
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|count
operator|--
operator|&&
operator|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|ch
argument_list|)
operator|||
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|digit
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
name|base
condition|)
return|return
name|FALSE
return|;
name|accum
operator|=
name|accum
operator|*
name|base
operator|+
name|digit
expr_stmt|;
block|}
if|if
condition|(
name|isNeg
condition|)
name|accum
operator|=
operator|-
name|accum
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|accum
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlIsNum
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_INT
name|ret
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|isNumber
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|?
name|FICL_TRUE
else|:
name|FICL_FALSE
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a d d&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|add
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|+=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sub
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
operator|-
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mul
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|*=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|negate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|-
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
operator|/
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** slash-mod        CORE ( n1 n2 -- n3 n4 ) ** Divide n1 by n2, giving the single-cell remainder n3 and the single-cell ** quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 ** differ in sign, the implementation-defined result returned will be the ** same as that returned by either the phrase **>R S>D R> FM/MOD or the phrase>R S>D R> SM/REM .  ** NOTE: Ficl complies with the second phrase (symmetric division) */
end_comment

begin_function
specifier|static
name|void
name|slashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|n1
decl_stmt|;
name|FICL_INT
name|n2
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|n1
operator|.
name|lo
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i64Extend
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|onePlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|oneMinus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoMul
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mulDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|DPINT
name|prod
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|z
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|prod
operator|=
name|m64MulI
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|m64SymmetricDivI
argument_list|(
name|prod
argument_list|,
name|z
argument_list|)
operator|.
name|quot
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mulDivRem
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|DPINT
name|prod
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|z
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|prod
operator|=
name|m64MulI
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|prod
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b y e ** TOOLS ** Signal the system to shut down - this causes ficlExec to return ** VM_USEREXIT. The rest is up to you. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bye
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_USEREXIT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n   d e f i n i t i o n s ** Code to begin compiling a colon definition ** This function sets the state to COMPILE, then creates a ** new word whose name is the next word in the input stream ** and whose code is colonParen. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colon
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictCheckThreshold
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|colonParen
argument_list|,
name|FW_DEFAULT
operator||
name|FW_SMUDGE
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n P a r e n ** This is the code that executes a colon definition. It assumes that the ** virtual machine is running a "next" loop (See the vm.c ** for its implementation of member function vmExecute()). The colon ** code simply copies the address of the first word in the list of words ** to interpret into IP after saving its old value. When we return to the ** "next" loop, the virtual machine will call the code for each word in  ** turn. ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colonParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IPTYPE
name|tempIP
init|=
call|(
name|IPTYPE
call|)
argument_list|(
name|pVM
operator|->
name|runningWord
operator|->
name|param
argument_list|)
decl_stmt|;
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
name|tempIP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e m i c o l o n C o I m **  ** IMMEDIATE code for ";". This function sets the state to INTERPRET and ** terminates a word under compilation by appending code for "(;)" to ** the definition. TO DO: checks for leftover branch target tags on the ** return stack and complains if any are found. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|semiParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|semicolonCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pSemiParen
argument_list|)
expr_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|assert
argument_list|(
name|pUnLinkParen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|()
decl_stmt|;
name|dictEmpty
argument_list|(
name|pLoc
argument_list|,
name|pLoc
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pSemiParen
argument_list|)
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
name|dictUnsmudge
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e x i t ** CORE ** This function simply pops the previous instruction ** pointer and returns to the "next" loop. Used for exiting from within ** a definition. Note that exitParen is identical to semiParen - they ** are in two different functions so that "see" can correctly identify ** the end of a colon definition, even if it uses "exit". **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|exitParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|exitCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pExitParen
argument_list|)
expr_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pExitParen
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o n s t a n t P a r e n ** This is the run-time code for "constant". It simply returns the  ** contents of its word's first data cell. ** **************************************************************************/
end_comment

begin_function
name|void
name|constantParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|twoConstParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* lo */
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* hi */
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o n s t a n t ** IMMEDIATE ** Compiles a constant into the dictionary. Constants return their ** value when invoked. Expects a value on top of the parm stack. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|constant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoConstant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|twoConstParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i s p l a y C e l l ** Drop and print the contents of the cell at the top of the param ** stack **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|displayCell
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ltoa
argument_list|(
operator|(
name|c
operator|)
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|displayCellNoPad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ltoa
argument_list|(
operator|(
name|c
operator|)
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ultoa
argument_list|(
name|u
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hexDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ultoa
argument_list|(
name|u
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i s p l a y S t a c k ** Display the parameter stack (code for ".s") **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|displayStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|d
init|=
name|stackDepth
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CELL
modifier|*
name|pCell
decl_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"(Stack Empty)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|pCell
operator|=
name|pVM
operator|->
name|pStack
operator|->
name|sp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|ltoa
argument_list|(
operator|(
operator|*
operator|--
name|pCell
operator|)
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************                         d u p&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|depth
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackDepth
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDrop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|over
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoOver
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|pick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|c
operator|.
name|i
operator|+
literal|1
argument_list|,
name|c
operator|.
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|questionDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|!=
literal|0
condition|)
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|roll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|minusRoll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoSwap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e m i t&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|emit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|commentLine
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
name|ch
init|=
operator|*
name|cp
decl_stmt|;
while|while
condition|(
operator|(
name|cp
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
block|{
name|ch
operator|=
operator|*
operator|++
name|cp
expr_stmt|;
block|}
comment|/*     ** Cope with DOS or UNIX-style EOLs -     ** Check for /r, /n, /r/n, or /n/r end-of-line sequences,     ** and point cp to next char. If EOL is \0, we're done.     */
if|if
condition|(
name|cp
operator|!=
name|pEnd
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
name|ch
operator|!=
operator|*
name|cp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** paren CORE  ** Compilation: Perform the execution semantics given below. ** Execution: ( "ccc<paren>" -- ) ** Parse ccc delimited by ) (right parenthesis). ( is an immediate word.  ** The number of characters in ccc may be zero to the number of characters ** in the parse area.  **  */
end_comment

begin_function
specifier|static
name|void
name|commentHang
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
literal|')'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         F E T C H&   S T O R E **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** two-fetch    CORE ( a-addr -- x1 x2 ) ** Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and ** x1 at the next consecutive cell. It is equivalent to the sequence ** DUP CELL+ @ SWAP @ .  */
end_comment

begin_function
specifier|static
name|void
name|twoFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
operator|++
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** store        CORE ( x a-addr -- ) ** Store x at a-addr.  */
end_comment

begin_function
specifier|static
name|void
name|store
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** two-store    CORE ( x1 x2 a-addr -- ) ** Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the ** next consecutive cell. It is equivalent to the sequence ** SWAP OVER ! CELL+ ! .  */
end_comment

begin_function
specifier|static
name|void
name|twoStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|++
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|plusStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pCell
operator|->
name|i
operator|+=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS16
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS16
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|FICL_UNS
operator|)
operator|*
name|pw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS16
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS16
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pw
operator|=
call|(
name|UNS16
call|)
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS8
modifier|*
name|pc
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc
operator|=
operator|(
name|UNS8
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|FICL_UNS
operator|)
operator|*
name|pc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS8
modifier|*
name|pc
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc
operator|=
operator|(
name|UNS8
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
call|(
name|UNS8
call|)
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i f C o I m ** IMMEDIATE ** Compiles code for a conditional branch into the dictionary ** and pushes the branch patch address on the stack for later ** patching by ELSE or THEN/ENDIF.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ifCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pIfParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pIfParen
argument_list|)
argument_list|)
expr_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i f P a r e n ** Runtime code to do "if" or "until": pop a flag from the stack, ** fall through if true, branch if false. Probably ought to be  ** called (not?branch) since it does "branch if false". **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ifParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|flag
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flag
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
comment|/* fall through */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take branch (to else/endif/begin) */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e l s e C o I m **  ** IMMEDIATE -- compiles an "else"... ** 1) Compile a branch and a patch address; the address gets patched **    by "endif" to point past the "else" code. ** 2) Pop the the "if" patch address ** 3) Patch the "if" branch to point to the current compile address. ** 4) Push the "else" patch address. ("endif" patches this to jump past  **    the "else" code. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pBranchParen
argument_list|)
expr_stmt|;
comment|/* (1) compile branch runtime */
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* (2) pop "if" patch addr */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
comment|/* (4) push "else" patch addr */
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* (1) compile patch placeholder */
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* (3) Patch "if" */
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b r a n c h P a r e n **  ** Runtime for "(branch)" -- expects a literal offset in the next ** compilation address, and branches to that location. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|branchParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n d i f C o I m **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|endifCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|resolveForwardBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h ** hash ( c-addr u -- code) ** calculates hashcode of specified string and leaves it on the stack **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hash
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|hashHashCode
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i n t e r p r e t  ** This is the "user interface" of a Forth. It does the following: **   while there are words in the VM's Text Input Buffer **     Copy next word into the pad (vmGetWord) **     Attempt to find the word in the dictionary (dictLookup) **     If successful, execute the word. **     Otherwise, attempt to convert the word to a number (isNumber) **     If successful, push the number onto the parameter stack. **     Otherwise, print an error message and exit loop... **   End Loop ** ** From the standard, section 3.4 ** Text interpretation (see 6.1.1360 EVALUATE and 6.1.2050 QUIT) shall ** repeat the following steps until either the parse area is empty or an  ** ambiguous condition exists:  ** a) Skip leading spaces and parse a name (see 3.4.1);  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|interpret
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*     ** Get next word...if out of text, we're done.     */
if|if
condition|(
name|si
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_OUTOFTEXT
argument_list|)
expr_stmt|;
block|}
name|interpWord
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
expr_stmt|;
return|return;
comment|/* back to inner interpreter */
block|}
end_function

begin_comment
comment|/************************************************************************** ** From the standard, section 3.4 ** b) Search the dictionary name space (see 3.4.2). If a definition name ** matching the string is found:  **  1.if interpreting, perform the interpretation semantics of the definition **  (see 3.4.3.2), and continue at a);  **  2.if compiling, perform the compilation semantics of the definition **  (see 3.4.3.3), and continue at a).  ** ** c) If a definition name matching the string is not found, attempt to ** convert the string to a number (see 3.4.1.3). If successful:  **  1.if interpreting, place the number on the data stack, and continue at a);  **  2.if compiling, compile code that when executed will place the number on **  the stack (see 6.1.1780 LITERAL), and continue at a);  ** ** d) If unsuccessful, an ambiguous condition exists (see 3.4.4).  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|interpWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_WORD
modifier|*
name|tempFW
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
name|dictCheck
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
name|tempFW
operator|=
name|dictLookupLoc
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tempFW
operator|=
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
if|if
condition|(
name|tempFW
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wordIsCompileOnly
argument_list|(
name|tempFW
argument_list|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: Compile only!"
argument_list|)
expr_stmt|;
block|}
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|tempFW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isNumber
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* (pVM->state == COMPILE) */
block|{
if|if
condition|(
name|tempFW
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wordIsImmediate
argument_list|(
name|tempFW
argument_list|)
condition|)
block|{
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|tempFW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|tempFW
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isNumber
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|)
block|{
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i t e r a l P a r e n **  ** This is the runtime for (literal). It assumes that it is part of a colon ** definition, and that the next CELL contains a value to be pushed on the ** parameter stack at runtime. This code is compiled by "literal". ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|literalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLitParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
operator|(
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i t e r a l I m **  ** IMMEDIATE code for "literal". This function gets a value from the stack  ** and compiles it into the dictionary preceded by the code for "(literal)". ** IMMEDIATE **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|literalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pLitParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pLitParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLiteralIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pTwoLitParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pTwoLitParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i s t W o r d s **  **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|nCOLWIDTH
value|8
end_define

begin_function
specifier|static
name|void
name|listWords
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|dp
operator|->
name|pSearch
index|[
name|dp
operator|->
name|nLists
operator|-
literal|1
index|]
decl_stmt|;
name|FICL_WORD
modifier|*
name|wp
decl_stmt|;
name|int
name|nChars
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|nWords
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|pPad
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|wp
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
init|;
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|=
name|wp
operator|->
name|link
operator|,
name|nWords
operator|++
control|)
block|{
if|if
condition|(
name|wp
operator|->
name|nName
operator|==
literal|0
condition|)
comment|/* ignore :noname defs */
continue|continue;
name|cp
operator|=
name|wp
operator|->
name|name
expr_stmt|;
name|nChars
operator|+=
name|sprintf
argument_list|(
name|pPad
operator|+
name|nChars
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nChars
operator|>
literal|70
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|23
condition|)
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"--- Press Enter to continue ---"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|nCOLWIDTH
operator|-
name|nChars
operator|%
name|nCOLWIDTH
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|pPad
index|[
name|nChars
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|nChars
operator|>
literal|70
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|23
condition|)
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"--- Press Enter to continue ---"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nChars
operator|>
literal|0
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"Dictionary: %d words, %ld cells used of %lu total"
argument_list|,
name|nWords
argument_list|,
name|dp
operator|->
name|here
operator|-
name|dp
operator|->
name|dict
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|listEnv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetEnv
argument_list|()
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|dp
operator|->
name|pForthWords
decl_stmt|;
name|FICL_WORD
modifier|*
name|wp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|nWords
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|wp
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
init|;
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|=
name|wp
operator|->
name|link
operator|,
name|nWords
operator|++
control|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|wp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"Environment: %d words, %ld cells used of %lu total"
argument_list|,
name|nWords
argument_list|,
name|dp
operator|->
name|here
operator|-
name|dp
operator|->
name|dict
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l o g i c   a n d   c o m p a r i s o n s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|zeroEquals
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isEqual
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|==
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|<
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uIsLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u1
decl_stmt|,
name|u2
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u2
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_BOOL
argument_list|(
name|u1
operator|<
name|u2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|>
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseAnd
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x
operator|.
name|i
operator|&
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseOr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x
operator|.
name|i
operator||
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseXor
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x
operator|.
name|i
operator|^
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseNot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|~
name|x
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                                D o  /  L o o p ** do -- IMMEDIATE COMPILE ONLY **    Compiles code to initialize a loop: compile (do),  **    allot space to hold the "leave" address, push a branch **    target address for the loop. ** (do) -- runtime for "do" **    pops index and limit from the p stack and moves them **    to the r stack, then skips to the loop body. ** loop -- IMMEDIATE COMPILE ONLY ** +loop **    Compiles code for the test part of a loop: **    compile (loop), resolve forward branch from "do", and **    copy "here" address to the "leave" address allotted by "do" ** i,j,k -- COMPILE ONLY **    Runtime: Push loop indices on param stack (i is innermost loop...) **    Note: each loop has three values on the return stack: **    ( R: leave limit index ) **    "leave" is the absolute address of the next cell after the loop **    limit and index are the loop control variables. ** leave -- COMPILE ONLY **    Runtime: pop the loop control variables, then pop the **    "leave" address and jump (absolute) there. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|doCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pDoParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pDoParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Allot space for a pointer to the end     ** of the loop - "leave" uses this...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     ** Mark location of head of loop...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
decl_stmt|,
name|limit
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|limit
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* copy "leave" target addr to stack */
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|qDoCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pQDoParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pQDoParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Allot space for a pointer to the end     ** of the loop - "leave" uses this...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     ** Mark location of head of loop...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|qDoParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
decl_stmt|,
name|limit
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|limit
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* copy "leave" target addr to stack */
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|.
name|u
operator|==
name|index
operator|.
name|u
condition|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Runtime code to break out of a do..loop construct ** Drop the loop control variables; the branch address ** past "loop" is next on the return stack. */
end_comment

begin_function
specifier|static
name|void
name|leaveCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
comment|/* almost unloop */
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* exit */
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|unloopCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pLoopParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pLoopParen
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
name|resolveAbsBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|plusLoopCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pPLoopParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pPLoopParen
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
name|resolveAbsBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|index
init|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|FICL_INT
name|limit
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|1
argument_list|)
operator|.
name|i
decl_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* nuke the loop indices& "leave" addr */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fall through the loop */
block|}
else|else
block|{
comment|/* update index, branch to loop head */
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|plusLoopParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|index
init|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|FICL_INT
name|limit
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|1
argument_list|)
operator|.
name|i
decl_stmt|;
name|FICL_INT
name|increment
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|index
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|increment
operator|<
literal|0
condition|)
name|flag
operator|=
operator|(
name|index
operator|<
name|limit
operator|)
expr_stmt|;
else|else
name|flag
operator|=
operator|(
name|index
operator|>=
name|limit
operator|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* nuke the loop indices& "leave" addr */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fall through the loop */
block|}
else|else
block|{
comment|/* update index, branch to loop head */
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopICo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopJCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopKCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e t u r n   s t a c k **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fromRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fetchRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v a r i a b l e **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|variableParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|fw
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|fw
operator|->
name|param
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|variable
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|variableParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAllotCells
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b a s e&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|base
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pBase
init|=
operator|(
name|CELL
operator|*
operator|)
operator|(
operator|&
name|pVM
operator|->
name|base
operator|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pBase
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|decimal
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|base
operator|=
literal|10
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hex
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|base
operator|=
literal|16
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l l o t&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|allot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_INT
name|i
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
name|dictCheck
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAllot
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|here
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|comma
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|CELL
name|c
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cComma
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|dictAppendChar
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cells
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
operator|*
operator|(
name|FICL_INT
operator|)
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cellPlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|cp
operator|+
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t i c k ** tick         CORE ( "<spaces>name" -- xt ) ** Skip leading space delimiters. Parse name delimited by a space. Find ** name and return xt, the execution token for name. An ambiguous condition ** exists if name is not found.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|tick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|NULL
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|ficlGetDict
argument_list|()
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pFW
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bracketTickCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|tick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p o s t p o n e ** Lookup the next word in the input stream and compile code to  ** insert it into definitions created by the resulting word ** (defers compilation, even of immediate words) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|postponeCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|assert
argument_list|(
name|pComma
argument_list|)
expr_stmt|;
name|tick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|wordIsImmediate
argument_list|(
name|pFW
argument_list|)
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pComma
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e x e c u t e ** Pop an execution token (pointer to a word) off the stack and ** run it **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|execute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i m m e d i a t e ** Make the most recently compiled word IMMEDIATE -- it executes even ** in compile state (most often used for control compiling words ** such as IF, THEN, etc) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|immediate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictSetImmediate
argument_list|(
name|ficlGetDict
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|compileOnly
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictSetFlags
argument_list|(
name|ficlGetDict
argument_list|()
argument_list|,
name|FW_COMPILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d o t Q u o t e ** IMMEDIATE word that compiles a string literal for later display ** Compile stringLit, then copy the bytes of the string from the TIB ** to the dictionary. Backpatch the count byte and align the dictionary. ** ** stringlit: Fetch the count from the dictionary, then push the address ** and count on the stack. Finally, update ip to point to the first ** aligned address after the string text. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stringLit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
decl_stmt|;
name|FICL_COUNT
name|count
init|=
name|sp
operator|->
name|count
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|sp
operator|->
name|text
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|count
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|alignPtr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
operator|(
name|IPTYPE
operator|)
operator|(
name|void
operator|*
operator|)
name|cp
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dotQuoteCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|vmGetString
argument_list|(
name|pVM
argument_list|,
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pType
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dotParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pDest
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
name|char
name|ch
decl_stmt|;
for|for
control|(
name|ch
operator|=
operator|*
name|pSrc
init|;
operator|(
name|pEnd
operator|!=
name|pSrc
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|')'
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|pSrc
control|)
operator|*
name|pDest
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|pDest
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pEnd
operator|!=
name|pSrc
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|')'
operator|)
condition|)
name|pSrc
operator|++
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s l i t e r a l ** STRING  ** Interpretation: Interpretation semantics for this word are undefined. ** Compilation: ( c-addr1 u -- ) ** Append the run-time semantics given below to the current definition. ** Run-time:       ( -- c-addr2 u ) ** Return c-addr2 u describing a string consisting of the characters ** specified by c-addr1 u during compilation. A program shall not alter ** the returned string.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sLiteralCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpDest
decl_stmt|;
name|FICL_UNS
name|u
decl_stmt|;
name|u
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|cpDest
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|here
expr_stmt|;
operator|*
name|cpDest
operator|++
operator|=
operator|(
name|char
operator|)
name|u
expr_stmt|;
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
operator|--
name|u
control|)
block|{
operator|*
name|cpDest
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cpDest
operator|++
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|alignPtr
argument_list|(
name|cpDest
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t a t e ** Return the address of the VM's state member (must be sized the ** same as a CELL for this reason) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|pVM
operator|->
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c r e a t e . . . d o e s> ** Make a new word in the dictionary with the run-time effect of  ** a variable (push my address), but with extra space allotted ** for use by does> . **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|createParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pCell
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|create
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|createParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAllotCells
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doDoes
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
decl_stmt|;
name|IPTYPE
name|tempIP
init|=
call|(
name|IPTYPE
call|)
argument_list|(
operator|(
operator|*
name|pCell
operator|)
operator|.
name|p
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pCell
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
name|tempIP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doesParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|dp
operator|->
name|smudge
operator|->
name|code
operator|=
name|doDoes
expr_stmt|;
name|dp
operator|->
name|smudge
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|ip
argument_list|)
expr_stmt|;
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doesCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|assert
argument_list|(
name|pUnLinkParen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|()
decl_stmt|;
name|dictEmpty
argument_list|(
name|pLoc
argument_list|,
name|pLoc
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pDoesParen
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o   b o d y ** to-body      CORE ( xt -- a-addr ) ** a-addr is the data-field address corresponding to xt. An ambiguous ** condition exists if xt is not for a word defined via CREATE.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toBody
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** from-body       ficl ( a-addr -- xt ) ** Reverse effect of>body */
end_comment

begin_function
specifier|static
name|void
name|fromBody
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|FICL_WORD
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **>name        ficl ( xt -- c-addr u ) ** Push the address and length of a word's name given its address ** xt.  */
end_comment

begin_function
specifier|static
name|void
name|toName
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|nName
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l b r a c k e t   e t c **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lbracketCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rbracket
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p i c t u r e d   n u m e r i c   w o r d s ** ** less-number-sign CORE ( -- ) ** Initialize the pictured numeric output conversion process.  ** (clear the pad) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lessNumberSign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|sp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign      CORE ( ud1 -- ud2 ) ** Divide ud1 by the number in BASE giving the quotient ud2 and the remainder ** n. (n is the least-significant digit of ud1.) Convert n to external form ** and add the resulting character to the beginning of the pictured numeric ** output  string. An ambiguous condition exists if # executes outside of a **<# #> delimited number conversion.  */
end_comment

begin_function
specifier|static
name|void
name|numberSign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|DPUNS
name|u
decl_stmt|;
name|UNS16
name|rem
decl_stmt|;
name|u
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|rem
operator|=
name|m64UMod
argument_list|(
operator|&
name|u
argument_list|,
call|(
name|UNS16
call|)
argument_list|(
name|pVM
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
name|digit_to_char
argument_list|(
name|rem
argument_list|)
expr_stmt|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign-greater CORE ( xd -- c-addr u ) ** Drop xd. Make the pictured numeric output string available as a character ** string. c-addr and u specify the resulting character string. A program ** may replace characters within the string.  */
end_comment

begin_function
specifier|static
name|void
name|numberSignGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strrev
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign-s    CORE ( ud1 -- ud2 ) ** Convert one digit of ud1 according to the rule for #. Continue conversion ** until the quotient is zero. ud2 is zero. An ambiguous condition exists if ** #S executes outside of a<# #> delimited number conversion.  ** TO DO: presently does not use ud1 hi cell - use it! */
end_comment

begin_function
specifier|static
name|void
name|numberSignS
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|DPUNS
name|u
decl_stmt|;
name|UNS16
name|rem
decl_stmt|;
name|u
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
do|do
block|{
name|rem
operator|=
name|m64UMod
argument_list|(
operator|&
name|u
argument_list|,
call|(
name|UNS16
call|)
argument_list|(
name|pVM
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
name|digit_to_char
argument_list|(
name|rem
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|.
name|hi
operator|||
name|u
operator|.
name|lo
condition|)
do|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** HOLD             CORE ( char -- ) ** Add char to the beginning of the pictured numeric output string. An ambiguous ** condition exists if HOLD executes outside of a<# #> delimited number conversion. */
end_comment

begin_function
specifier|static
name|void
name|hold
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|int
name|i
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** SIGN             CORE ( n -- ) ** If n is negative, add a minus sign to the beginning of the pictured ** numeric output string. An ambiguous condition exists if SIGN ** executes outside of a<# #> delimited number conversion.  */
end_comment

begin_function
specifier|static
name|void
name|sign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|int
name|i
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o   N u m b e r ** to-number CORE ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 ) ** ud2 is the unsigned result of converting the characters within the ** string specified by c-addr1 u1 into digits, using the number in BASE, ** and adding each into ud1 after multiplying ud1 by the number in BASE. ** Conversion continues left-to-right until a character that is not ** convertible, including any + or -, is encountered or the string is ** entirely converted. c-addr2 is the location of the first unconverted ** character or the first character past the end of the string if the string ** was entirely converted. u2 is the number of unconverted characters in the ** string. An ambiguous condition exists if ud2 overflows during the ** conversion.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|DPUNS
name|accum
decl_stmt|;
name|FICL_UNS
name|base
init|=
name|pVM
operator|->
name|base
decl_stmt|;
name|FICL_UNS
name|ch
decl_stmt|;
name|FICL_UNS
name|digit
decl_stmt|;
name|accum
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
operator|*
name|cp
init|;
name|count
operator|>
literal|0
condition|;
name|ch
operator|=
operator|*
operator|++
name|cp
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
name|ch
operator|<
literal|'0'
condition|)
break|break;
name|digit
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
comment|/*          ** Note: following test also catches chars between 9 and a         ** because 'digit' is unsigned!          */
if|if
condition|(
name|digit
operator|>=
name|base
condition|)
break|break;
name|accum
operator|=
name|m64Mac
argument_list|(
name|accum
argument_list|,
name|base
argument_list|,
name|digit
argument_list|)
expr_stmt|;
block|}
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|accum
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         q u i t&   a b o r t ** quit CORE   ( -- )  ( R:  i*x -- ) ** Empty the return stack, store zero in SOURCE-ID if it is present, make ** the user input device the input source, and enter interpretation state.  ** Do not display a message. Repeat the following:  ** **   Accept a line from the input source into the input buffer, set>IN to **   zero, and interpret.  **   Display the implementation-defined system prompt if in **   interpretation state, all processing has been completed, and no **   ambiguous condition exists.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_QUIT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlAbort
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_ABORT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a c c e p t ** accept       CORE ( c-addr +n1 -- +n2 ) ** Receive a string of at most +n1 characters. An ambiguous condition ** exists if +n1 is zero or greater than 32,767. Display graphic characters ** as they are received. A program that depends on the presence or absence ** of non-graphic characters in the string has an environmental dependency. ** The editing functions, if any, that the system performs in order to ** construct the string are implementation-defined.  ** ** (Although the standard text doesn't say so, I assume that the intent  ** of 'accept' is to store the string at the address specified on ** the stack.) ** Implementation: if there's more text in the TIB, use it. Otherwise ** throw out for more text. Copy characters up to the max count into the ** address given, and return the number of actual characters copied. **  ** Note (sobral) this may not be the behavior you'd expect if you're ** trying to get user input at load time! **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|accept
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|pBuf
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_INT
name|len
init|=
name|pEnd
operator|-
name|pBuf
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
comment|/*     ** Now we have something in the text buffer - use it      */
name|count
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|count
operator|<
name|len
operator|)
condition|?
name|count
else|:
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pBuf
operator|+=
name|len
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pBuf
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l i g n ** 6.1.0705 ALIGN       CORE ( -- ) ** If the data-space pointer is not aligned, reserve enough space to ** align it.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|align
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l i g n e d **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|aligned
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|addr
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|alignPtr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b e g i n&   f r i e n d s ** Indefinite loop control structures ** A.6.1.0760 BEGIN  ** Typical use:  **      : X ... BEGIN ... test UNTIL ; ** or  **      : X ... BEGIN ... test WHILE ... REPEAT ; **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|beginCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|untilCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pIfParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pIfParen
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|whileCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pIfParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pIfParen
argument_list|)
argument_list|)
expr_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|twoSwap
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|repeatCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pBranchParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expect "begin" branch marker */
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
comment|/* expect "while" branch marker */
name|resolveForwardBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|againCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pBranchParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expect "begin" branch marker */
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r&   f r i e n d s ** 6.1.0895 CHAR    CORE ( "<spaces>name" -- char ) ** Skip leading space delimiters. Parse name delimited by a space. ** Put the value of its first character onto the stack.  ** ** bracket-char     CORE  ** Interpretation: Interpretation semantics for this word are undefined. ** Compilation: ( "<spaces>name" -- ) ** Skip leading space delimiters. Parse name delimited by a space. ** Append the run-time semantics given below to the current definition.  ** Run-time: ( -- char ) ** Place char, the value of the first character of name, on the stack.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlChar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
call|(
name|FICL_UNS
call|)
argument_list|(
name|si
operator|.
name|cp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|charCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|ficlChar
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r P l u s ** char-plus        CORE ( c-addr1 -- c-addr2 ) ** Add the size in address units of a character to c-addr1, giving c-addr2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|charPlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r s ** chars        CORE ( n1 -- n2 ) ** n2 is the size in address units of n1 characters.  ** For most processors, this function can be a no-op. To guarantee ** portability, we'll multiply by sizeof (char). **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ficlChars
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|>
literal|1
condition|)
block|{
name|FICL_INT
name|i
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* otherwise no-op! */
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4127
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         c o u n t ** COUNT    CORE ( c-addr1 -- c-addr2 u ) ** Return the character string specification for the counted string stored ** at c-addr1. c-addr2 is the address of the first character after c-addr1. ** u is the contents of the character at c-addr1, which is the length in ** characters of the string at c-addr2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|count
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n v i r o n m e n t ? ** environment-query CORE ( c-addr u -- false | i*x true ) ** c-addr is the address of a character string and u is the string's ** character count. u may have a value in the range from zero to an ** implementation-defined maximum which shall not be less than 31. The ** character string should contain a keyword from 3.2.6 Environmental ** queries or the optional word sets to be checked for correspondence ** with an attribute of the present environment. If the system treats the ** attribute as unknown, the returned flag is false; otherwise, the flag ** is true and the i*x returned is of the type specified in the table for ** the attribute queried.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|environmentQ
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|envp
init|=
name|ficlGetEnv
argument_list|()
decl_stmt|;
name|FICL_COUNT
name|len
init|=
operator|(
name|FICL_COUNT
operator|)
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
operator|&
name|len
expr_stmt|;
comment|/* silence compiler warning... */
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|!=
name|NULL
condition|)
block|{
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e v a l u a t e ** EVALUATE CORE ( i*x c-addr u -- j*x ) ** Save the current input source specification. Store minus-one (-1) in ** SOURCE-ID if it is present. Make the string described by c-addr and u ** both the input source and input buffer, set>IN to zero, and interpret. ** When the parse area is empty, restore the prior input source ** specification. Other stack effects are due to the words EVALUATEd.  ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|evaluate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|count
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|CELL
name|id
decl_stmt|;
name|int
name|result
decl_stmt|;
name|id
operator|=
name|pVM
operator|->
name|sourceID
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|VM_OUTOFTEXT
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r i n g   q u o t e ** Intrpreting: get string delimited by a quote from the input stream, ** copy to a scratch area, and put its count and address on the stack. ** Compiling: compile code to push the address and count of a string ** literal, compile the string from the input stream, and align the dict ** pointer. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stringQuoteIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
decl_stmt|;
name|vmGetString
argument_list|(
name|pVM
argument_list|,
name|sp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* COMPILE state */
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|vmGetString
argument_list|(
name|pVM
argument_list|,
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t y p e ** Pop count and char address from stack and print the designated string. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|type
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pDest
init|=
operator|(
name|char
operator|*
operator|)
name|ficlMalloc
argument_list|(
name|count
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/*      ** Since we don't have an output primitive for a counted string     ** (oops), make sure the string is null terminated. If not, copy     ** and terminate it.     */
if|if
condition|(
operator|!
name|pDest
condition|)
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of memory"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|pDest
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pDest
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pDest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d ** word CORE ( char "<chars>ccc<char>" -- c-addr ) ** Skip leading delimiters. Parse characters ccc delimited by char. An ** ambiguous condition exists if the length of the parsed string is greater ** than the implementation-defined length of a counted string.  **  ** c-addr is the address of a transient region containing the parsed word ** as a counted string. If the parse area was empty or contained no ** characters other than the delimiter, the resulting string has a zero ** length. A space, not included in the length, follows the string. A ** program may replace characters within the string.  ** NOTE! Ficl also NULL-terminates the dest string. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
name|pVM
operator|->
name|pad
decl_stmt|;
name|char
name|delim
init|=
operator|(
name|char
operator|)
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|si
operator|=
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|nPAD
operator|-
literal|1
condition|)
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|nPAD
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a r s e - w o r d ** ficl   PARSE-WORD  (<spaces>name -- c-addr u ) ** Skip leading spaces and parse name delimited by a space. c-addr is the ** address within the input buffer and u is the length of the selected  ** string. If the parse area is empty, the resulting string has a zero length. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|parseNoCopy
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a r s e ** CORE EXT  ( char "ccc<char>" -- c-addr u ) ** Parse ccc delimited by the delimiter char.  ** c-addr is the address (within the input buffer) and u is the length of  ** the parsed string. If the parse area was empty, the resulting string has ** a zero length.  ** NOTE! PARSE differs from WORD: it does not skip leading delimiters. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|parse
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
name|delim
init|=
operator|(
name|char
operator|)
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|si
operator|=
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i l l ** CORE ( c-addr u char -- ) ** If u is greater than zero, store char in each of u consecutive ** characters of memory beginning at c-addr.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fill
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_UNS
name|u
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
while|while
condition|(
name|u
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|ch
expr_stmt|;
name|u
operator|--
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i n d ** FIND CORE ( c-addr -- c-addr 0  |  xt 1  |  xt -1 ) ** Find the definition named in the counted string at c-addr. If the ** definition is not found, return c-addr and zero. If the definition is ** found, return its execution token xt. If the definition is immediate, ** also return one (1), otherwise also return minus-one (-1). For a given ** string, the values returned by FIND while compiling may differ from ** those returned while not compiling.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|find
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PFS
argument_list|(
name|si
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|ficlGetDict
argument_list|()
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
condition|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|wordIsImmediate
argument_list|(
name|pFW
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f m S l a s h M o d ** f-m-slash-mod CORE ( d1 n1 -- n2 n3 ) ** Divide d1 by n1, giving the floored quotient n3 and the remainder n2. ** Input and output stack arguments are signed. An ambiguous condition ** exists if n1 is zero or if the quotient lies outside the range of a ** single-cell signed integer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fmSlashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
name|n1
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|d1
operator|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64FlooredDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s m S l a s h R e m ** s-m-slash-rem CORE ( d1 n1 -- n2 n3 ) ** Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2. ** Input and output stack arguments are signed. An ambiguous condition ** exists if n1 is zero or if the quotient lies outside the range of a ** single-cell signed integer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|smSlashRem
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
name|n1
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|d1
operator|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
name|n1
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|d1
operator|.
name|lo
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i64Extend
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u m S l a s h M o d ** u-m-slash-mod CORE ( ud u1 -- u2 u3 ) ** Divide ud by u1, giving the quotient u3 and the remainder u2. ** All values and arithmetic are unsigned. An ambiguous condition ** exists if u1 is zero or if the quotient lies outside the range of a ** single-cell unsigned integer.  *************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|umSlashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPUNS
name|ud
decl_stmt|;
name|FICL_UNS
name|u1
decl_stmt|;
name|UNSQR
name|qr
decl_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ud
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
name|u1
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l s h i f t ** l-shift CORE ( x1 u -- x2 ) ** Perform a logical left shift of u bit-places on x1, giving x2. ** Put zeroes into the least significant bits vacated by the shift. ** An ambiguous condition exists if u is greater than or equal to the ** number of bits in a cell.  ** ** r-shift CORE ( x1 u -- x2 ) ** Perform a logical right shift of u bit-places on x1, giving x2. ** Put zeroes into the most significant bits vacated by the shift. An ** ambiguous condition exists if u is greater than or equal to the ** number of bits in a cell.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lshift
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|nBits
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_UNS
name|x1
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x1
operator|<<
name|nBits
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rshift
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|nBits
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_UNS
name|x1
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|x1
operator|>>
name|nBits
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m S t a r ** m-star CORE ( n1 n2 -- d ) ** d is the signed product of n1 times n2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mStar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_INT
name|n1
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|DPINT
name|d
decl_stmt|;
name|d
operator|=
name|m64MulI
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|i64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|umStar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u2
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_UNS
name|u1
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|DPUNS
name|ud
decl_stmt|;
name|ud
operator|=
name|ficlLongMul
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
expr_stmt|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ud
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m a x&   m i n **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlMax
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_INT
name|n1
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|n1
operator|>
name|n2
operator|)
condition|?
name|n1
else|:
name|n2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlMin
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_INT
name|n1
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|n1
operator|<
name|n2
operator|)
condition|?
name|n1
else|:
name|n2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m o v e ** CORE ( addr1 addr2 u -- ) ** If u is greater than zero, copy the contents of u consecutive address ** units at addr1 to the u consecutive address units at addr2. After MOVE ** completes, the u consecutive address units at addr2 contain exactly ** what the u consecutive address units at addr1 contained before the move.  ** NOTE! This implementation assumes that a char is the same size as **       an address unit. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|move
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|addr2
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|addr1
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|0
condition|)
return|return;
comment|/*     ** Do the copy carefully, so as to be     ** correct even if the two ranges overlap     */
if|if
condition|(
name|addr1
operator|>=
name|addr2
condition|)
block|{
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
name|u
operator|--
control|)
operator|*
name|addr2
operator|++
operator|=
operator|*
name|addr1
operator|++
expr_stmt|;
block|}
else|else
block|{
name|addr2
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
name|addr1
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
name|u
operator|--
control|)
operator|*
name|addr2
operator|--
operator|=
operator|*
name|addr1
operator|--
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e c u r s e **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|recurseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pDict
operator|->
name|smudge
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t o d ** s-to-d CORE ( n -- d ) ** Convert the number n to the double-cell number d with the same ** numerical value.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sToD
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|s
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
comment|/* sign extend to 64 bits.. */
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|s
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s o u r c e ** CORE ( -- c-addr u ) ** c-addr is the address of, and u is the number of characters in, the ** input buffer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|source
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|tib
operator|.
name|cp
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|vmGetInBufLen
argument_list|(
name|pVM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v e r s i o n ** non-standard... **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlVersion
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"ficl Version "
name|FICL_VER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o I n ** to-in CORE **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toIn
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|pVM
operator|->
name|tib
operator|.
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d e f i n i t i o n s ** SEARCH ( -- ) ** Make the compilation word list the same as the first word list in the ** search order. Specifies that the names of subsequent definitions will ** be placed in the compilation word list. Subsequent changes in the search ** order will not affect the compilation word list.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|definitions
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDict
operator|->
name|nLists
operator|<
literal|1
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"DEFINITIONS error - empty search order"
argument_list|)
expr_stmt|;
block|}
name|pDict
operator|->
name|pCompile
operator|=
name|pDict
operator|->
name|pSearch
index|[
name|pDict
operator|->
name|nLists
operator|-
literal|1
index|]
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f o r t h - w o r d l i s t ** SEARCH ( -- wid ) ** Return wid, the identifier of the word list that includes all standard ** words provided by the implementation. This word list is initially the ** compilation word list and is part of the initial search order.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|forthWordlist
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_HASH
modifier|*
name|pHash
init|=
name|ficlGetDict
argument_list|()
operator|->
name|pForthWords
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pHash
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         g e t - c u r r e n t ** SEARCH ( -- wid ) ** Return wid, the identifier of the compilation word list.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getCurrent
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ficlGetDict
argument_list|()
operator|->
name|pCompile
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         g e t - o r d e r ** SEARCH ( -- widn ... wid1 n ) ** Returns the number of word lists n in the search order and the word list ** identifiers widn ... wid1 identifying these word lists. wid1 identifies ** the word list that is searched first, and widn the word list that is ** searched last. The search order is unaffected. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getOrder
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|int
name|nLists
init|=
name|pDict
operator|->
name|nLists
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nLists
condition|;
name|i
operator|++
control|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pDict
operator|->
name|pSearch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|nLists
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e a r c h - w o r d l i s t ** SEARCH ( c-addr u wid -- 0 | xt 1 | xt -1 ) ** Find the definition identified by the string c-addr u in the word list ** identified by wid. If the definition is not found, return zero. If the ** definition is found, return its execution token xt and one (1) if the ** definition is immediate, minus-one (-1) otherwise.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|searchWordlist
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|UNS16
name|hashCode
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|si
operator|.
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|si
operator|.
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|hashCode
operator|=
name|hashHashCode
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|hashLookup
argument_list|(
name|pHash
argument_list|,
name|si
argument_list|,
name|hashCode
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
condition|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|wordIsImmediate
argument_list|(
name|pFW
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e t - c u r r e n t ** SEARCH ( wid -- ) ** Set the compilation word list to the word list identified by wid.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|setCurrent
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_HASH
modifier|*
name|pHash
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|pCompile
operator|=
name|pHash
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e t - o r d e r ** SEARCH ( widn ... wid1 n -- ) ** Set the search order to the word lists identified by widn ... wid1. ** Subsequently, word list wid1 will be searched first, and word list ** widn searched last. If n is zero, empty the search order. If n is minus ** one, set the search order to the implementation-defined minimum ** search order. The minimum search order shall include the words ** FORTH-WORDLIST and SET-ORDER. A system shall allow n to ** be at least eight. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|setOrder
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nLists
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
if|if
condition|(
name|nLists
operator|>
name|FICL_DEFAULT_VOCS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"set-order error: list would be too large"
argument_list|)
expr_stmt|;
block|}
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nLists
operator|>=
literal|0
condition|)
block|{
name|dp
operator|->
name|nLists
operator|=
name|nLists
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nLists
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|dp
operator|->
name|pSearch
index|[
name|i
index|]
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dictResetSearchOrder
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d l i s t ** SEARCH ( -- wid ) ** Create a new empty word list, returning its word list identifier wid. ** The new word list may be returned from a pool of preallocated word ** lists or may be dynamically allocated in data space. A system shall ** allow the creation of at least 8 new word lists in addition to any ** provided as part of the system.  ** Notes:  ** 1. ficl creates a new single-list hash in the dictionary and returns **    its address. ** 2. ficl-wordlist takes an arg off the stack indicating the number of **    hash entries in the wordlist. Ficl 2.02 and later define WORDLIST as **    : wordlist 1 ficl-wordlist ; **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|wordlist
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|FICL_UNS
name|nBuckets
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nBuckets
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|pHash
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|dp
operator|->
name|here
expr_stmt|;
name|dictAllot
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_HASH
argument_list|)
operator|+
operator|(
name|nBuckets
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FICL_WORD
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pHash
operator|->
name|size
operator|=
name|nBuckets
expr_stmt|;
name|hashReset
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pHash
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         S E A R C H> ** ficl  ( -- wid ) ** Pop wid off the search order. Error if the search order is empty **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|searchPop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|int
name|nLists
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|nLists
operator|=
name|dp
operator|->
name|nLists
expr_stmt|;
if|if
condition|(
name|nLists
operator|==
literal|0
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"search> error: empty search order"
argument_list|)
expr_stmt|;
block|}
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|dp
operator|->
name|pSearch
index|[
operator|--
name|dp
operator|->
name|nLists
index|]
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************> S E A R C H ** ficl  ( wid -- ) ** Push wid onto the search order. Error if the search order is full. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|searchPush
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|nLists
operator|>
name|FICL_DEFAULT_VOCS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|">search error: search order overflow"
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|pSearch
index|[
name|dp
operator|->
name|nLists
operator|++
index|]
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n N o N a m e ** CORE EXT ( C:  -- colon-sys )  ( S:  -- xt ) ** Create an unnamed colon definition and push its address. ** Change state to compile. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colonNoName
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
name|pFW
operator|=
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|colonParen
argument_list|,
name|FW_DEFAULT
operator||
name|FW_SMUDGE
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u s e r   V a r i a b l e ** user  ( u -- )  "<spaces>name"   ** Get a name from the input stream and create a user variable ** with the name and the index supplied. The run-time effect ** of a user variable is to push the address of the indexed cell ** in the running vm's user array.  ** ** User variables are vm local cells. Each vm has an array of ** FICL_USER_CELLS of them when FICL_WANT_USER is nonzero. ** Ficl's user facility is implemented with two primitives, ** "user" and "(user)", a variable ("nUser") (in softcore.c) that  ** holds the index of the next free user cell, and a redefinition ** (also in softcore) of "user" that defines a user word and increments ** nUser. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_USER
end_if

begin_function
specifier|static
name|void
name|userParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|pVM
operator|->
name|user
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|userVariable
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|CELL
name|c
decl_stmt|;
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|>=
name|FICL_USER_CELLS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error - out of user space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|userParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         t o V a l u e ** CORE EXT  ** Interpretation: ( x "<spaces>name" -- ) ** Skip leading spaces and parse name delimited by a space. Store x in  ** name. An ambiguous condition exists if name was not defined by VALUE.  ** NOTE: In ficl, VALUE is an alias of CONSTANT **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toValue
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
operator|(
name|nLocals
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
operator|)
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|()
decl_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|&&
operator|(
name|pFW
operator|->
name|code
operator|==
name|doLocalIm
operator|)
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pToLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|&&
name|pFW
operator|->
name|code
operator|==
name|do2LocalIm
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pTo2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|pStore
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pFW
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
else|else
comment|/* compile code to store to word's param */
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pStore
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_comment
comment|/**************************************************************************                         l i n k P a r e n ** ( -- ) ** Link a frame on the return stack, reserving nCells of space for ** locals - the value of nCells is the next cell in the instruction ** stream. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|linkParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLink
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
decl_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackLink
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|nLink
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|unlinkParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackUnlink
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d o L o c a l I m ** Immediate - cfa of a local while compiling - when executed, compiles ** code to fetch the value of a local given the local's index in the ** word's pfa **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getLocal0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocal0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|0
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getLocal1
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocal1
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|1
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Each local is recorded in a private locals dictionary as a  ** word that does doLocalIm at runtime. DoLocalIm compiles code ** into the client definition to fetch the value of the  ** corresponding local variable from the return stack. ** The private dictionary gets initialized at the end of each block ** that uses locals (in ; and does> for example). */
end_comment

begin_function
specifier|static
name|void
name|doLocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|int
name|nLocal
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nLocal
operator|==
literal|0
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pGetLocal0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nLocal
operator|==
literal|1
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pGetLocal1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pGetLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l o c a l P a r e n ** paren-local-paren LOCAL  ** Interpretation: Interpretation semantics for this word are undefined. ** Execution: ( c-addr u -- ) ** When executed during compilation, (LOCAL) passes a message to the  ** system that has one of two meanings. If u is non-zero, ** the message identifies a new local whose definition name is given by ** the string of characters identified by c-addr u. If u is zero, ** the message is last local and c-addr has no significance.  ** ** The result of executing (LOCAL) during compilation of a definition is ** to create a set of named local identifiers, each of which is ** a definition name, that only have execution semantics within the scope ** of that definition's source.  ** ** local Execution: ( -- x ) ** ** Push the local's value, x, onto the stack. The local's value is ** initialized as described in 13.3.3 Processing locals and may be ** changed by preceding the local's name with TO. An ambiguous condition ** exists when local is executed while in interpretation state.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|localParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* add a local to the **locals** dict and update nLocals */
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|nLocals
operator|>=
name|FICL_MAX_LOCALS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of local space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|,
name|doLocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pLoc
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nLocals
operator|==
literal|0
condition|)
block|{
comment|/* compile code to create a local stack frame */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pLinkParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save location in dictionary for #locals */
name|pMarkLocals
operator|=
name|pDict
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compile code to initialize first local */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pToLocal0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nLocals
operator|==
literal|1
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pToLocal1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pToLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nLocals
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
comment|/* write nLocals to (link) param area in dictionary */
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
name|pMarkLocals
operator|=
name|nLocals
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|get2LocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do2LocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|int
name|nLocal
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pGet2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|to2LocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* add a local to the **locals** dict and update nLocals */
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|()
decl_stmt|;
if|if
condition|(
name|nLocals
operator|>=
name|FICL_MAX_LOCALS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of local space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|,
name|do2LocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pLoc
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nLocals
operator|==
literal|0
condition|)
block|{
comment|/* compile code to create a local stack frame */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pLinkParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save location in dictionary for #locals */
name|pMarkLocals
operator|=
name|pDict
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pTo2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
name|nLocals
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nLocals
operator|>
literal|0
condition|)
block|{
comment|/* write nLocals to (link) param area in dictionary */
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
name|pMarkLocals
operator|=
name|nLocals
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         setParentWid ** FICL ** setparentwid   ( parent-wid wid -- ) ** Set WID's link field to the parent-wid. search-wordlist will  ** iterate through all the links when finding words in the child wid. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|setParentWid
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_HASH
modifier|*
name|parent
decl_stmt|,
modifier|*
name|child
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|child
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|parent
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|child
operator|->
name|link
operator|=
name|parent
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e e  ** TOOLS ( "<spaces>name" -- ) ** Display a human-readable representation of the named word's definition. ** The source of the representation (object-code decompilation, source ** block, etc.) and the particular form of the display is implementation ** defined.  ** NOTE: these funcs come late in the file because they reference all ** of the word-builder funcs without declaring them again. Call me lazy. **************************************************************************/
end_comment

begin_comment
comment|/* ** isAFiclWord ** Vet a candidate pointer carefully to make sure ** it's not some chunk o' inline data... ** It has to have a name, and it has to look ** like it's in the dictionary address range. ** NOTE: this excludes :noname words! */
end_comment

begin_function
specifier|static
name|int
name|isAFiclWord
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pd
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
name|pFW
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|pFW
operator|->
name|nName
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|name
index|[
name|pFW
operator|->
name|nName
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** seeColon (for proctologists only) ** Walks a colon definition, decompiling ** on the fly. Knows about primitive control structures. */
end_comment

begin_function
specifier|static
name|void
name|seeColon
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|CELL
modifier|*
name|pc
parameter_list|)
block|{
for|for
control|(
init|;
name|pc
operator|->
name|p
operator|!=
name|pSemiParen
condition|;
name|pc
operator|++
control|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|pc
operator|->
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|isAFiclWord
argument_list|(
name|pFW
argument_list|)
condition|)
block|{
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|literalParen
condition|)
block|{
name|CELL
name|v
init|=
operator|*
operator|++
name|pc
decl_stmt|;
if|if
condition|(
name|isAFiclWord
argument_list|(
name|v
operator|.
name|p
argument_list|)
condition|)
block|{
name|FICL_WORD
modifier|*
name|pLit
init|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|v
operator|.
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    literal %.*s (%#lx)"
argument_list|,
name|pLit
operator|->
name|nName
argument_list|,
name|pLit
operator|->
name|name
argument_list|,
name|v
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    literal %ld (%#lx)"
argument_list|,
name|v
operator|.
name|i
argument_list|,
name|v
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|stringLit
condition|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|++
name|pc
decl_stmt|;
name|pc
operator|=
operator|(
name|CELL
operator|*
operator|)
name|alignPtr
argument_list|(
name|sp
operator|->
name|text
operator|+
name|sp
operator|->
name|count
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    s\" %.*s\""
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|ifParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    if / while (branch rel %ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    until (branch rel %ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|branchParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    else (branch rel %ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    repeat (branch rel %ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|qDoParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    ?do (leave abs %#lx)"
argument_list|,
name|c
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|doParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    do (leave abs %#lx)"
argument_list|,
name|c
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|loopParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    loop (branch rel %#ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|plusLoopParen
condition|)
block|{
name|CELL
name|c
init|=
operator|*
operator|++
name|pc
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    +loop (branch rel %#ld)"
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* default: print word's name */
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    %.*s"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* probably not a word - punt and print value */
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"    %ld (%#lx)"
argument_list|,
name|pc
operator|->
name|i
argument_list|,
name|pc
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Here's the outer part of the decompiler. It's  ** just a big nested conditional that checks the ** CFA of the word to decompile for each kind of ** known word-builder code, and tries to do  ** something appropriate. If the CFA is not recognized, ** just indicate that it is a primitive. */
end_comment

begin_function
specifier|static
name|void
name|see
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|tick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pFW
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|colonParen
condition|)
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|": %.*s"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seeColon
argument_list|(
name|pVM
argument_list|,
name|pFW
operator|->
name|param
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|doDoes
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"does>"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seeColon
argument_list|(
name|pVM
argument_list|,
operator|(
name|CELL
operator|*
operator|)
name|pFW
operator|->
name|param
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|createParen
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"create"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|variableParen
condition|)
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"variable = %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|userParen
condition|)
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"user variable %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|constantParen
condition|)
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"constant = %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"primitive"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pFW
operator|->
name|flags
operator|&
name|FW_IMMEDIATE
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"immediate"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o m p a r e  ** STRING ( c-addr1 u1 c-addr2 u2 -- n ) ** Compare the string specified by c-addr1 u1 to the string specified by ** c-addr2 u2. The strings are compared, beginning at the given addresses, ** character by character, up to the length of the shorter string or until a ** difference is found. If the two strings are identical, n is zero. If the two ** strings are identical up to the length of the shorter string, n is minus-one ** (-1) if u1 is less than u2 and one (1) otherwise. If the two strings are not ** identical up to the length of the shorter string, n is minus-one (-1) if the  ** first non-matching character in the string specified by c-addr1 u1 has a ** lesser numeric value than the corresponding character in the string specified ** by c-addr2 u2 and one (1) otherwise.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|compareString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|FICL_UNS
name|u1
decl_stmt|,
name|u2
decl_stmt|,
name|uMin
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp2
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|uMin
operator|=
operator|(
name|u1
operator|<
name|u2
operator|)
condition|?
name|u1
else|:
name|u2
expr_stmt|;
for|for
control|(
init|;
operator|(
name|uMin
operator|>
literal|0
operator|)
operator|&&
operator|(
name|n
operator|==
literal|0
operator|)
condition|;
name|uMin
operator|--
control|)
block|{
name|n
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|cp1
operator|++
operator|-
operator|*
name|cp2
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|u1
operator|-
name|u2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e f i l l ** CORE EXT   ( -- flag ) ** Attempt to fill the input buffer from the input source, returning a true ** flag if successful.  ** When the input source is the user input device, attempt to receive input ** into the terminal input buffer. If successful, make the result the input ** buffer, set>IN to zero, and return true. Receipt of a line containing no ** characters is considered successful. If there is no input available from ** the current input source, return false.  ** When the input source is a string from EVALUATE, return false and ** perform no other action.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|refill
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|ret
init|=
operator|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|==
operator|-
literal|1
operator|)
condition|?
name|FICL_FALSE
else|:
name|FICL_TRUE
decl_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_OUTOFTEXT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f o r g e t ** TOOLS EXT  ( "<spaces>name" -- ) ** Skip leading space delimiters. Parse name delimited by a space. ** Find name, then delete name from the dictionary along with all ** words added to the dictionary after name. An ambiguous ** condition exists if name cannot be found.  **  ** If the Search-Order word set is present, FORGET searches the ** compilation word list. An ambiguous condition exists if the ** compilation word list is deleted.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|forgetWid
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|pHash
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|hashForget
argument_list|(
name|pHash
argument_list|,
name|pDict
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|forget
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|where
decl_stmt|;
name|FICL_DICT
modifier|*
name|pDict
init|=
name|ficlGetDict
argument_list|()
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|pDict
operator|->
name|pCompile
decl_stmt|;
name|tick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|FICL_WORD
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|)
operator|->
name|name
expr_stmt|;
name|hashForget
argument_list|(
name|pHash
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|here
operator|=
name|PTRtoCELL
name|where
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/************************* freebsd added I/O words **************************/
end_comment

begin_comment
comment|/*          fopen - open a file and return new fd on stack.  *  * fopen ( count ptr  -- fd )  */
end_comment

begin_function
specifier|static
name|void
name|pfopen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* don't need count value */
name|p
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*          fclose - close a file who's fd is on stack.  *  * fclose ( fd -- )  */
end_comment

begin_function
specifier|static
name|void
name|pfclose
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* get fd */
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*          fread - read file contents  *  * fread  ( fd buf nbytes  -- nread )  */
end_comment

begin_function
specifier|static
name|void
name|pfread
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* get number of bytes to read */
name|buf
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* get buffer */
name|fd
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* get fd */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|buf
operator|&&
name|fd
operator|!=
operator|-
literal|1
condition|)
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*          fload - interpret file contents  *  * fload  ( fd -- )  */
end_comment

begin_function
specifier|static
name|void
name|pfload
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* get fd */
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|ficlExecFD
argument_list|(
name|pVM
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*           key - get a character from stdin  *  * key ( -- char )  */
end_comment

begin_function
specifier|static
name|void
name|key
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*           key? - check for a character from stdin (FACILITY)  *  * key? ( -- flag )  */
end_comment

begin_function
specifier|static
name|void
name|keyQuestion
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TESTMAIN
comment|/* XXX Since we don't fiddle with termios, let it always succeed... */
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* But here do the right thing. */
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ischar
argument_list|()
condition|?
name|FICL_TRUE
else|:
name|FICL_FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* seconds - gives number of seconds since beginning of time  *  * beginning of time is defined as:  *  *	BTX	- number of seconds since midnight  *	FreeBSD	- number of seconds since Jan 1 1970  *  * seconds ( -- u )  */
end_comment

begin_function
specifier|static
name|void
name|pseconds
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ms - wait at least that many milliseconds (FACILITY)  *  * ms ( u -- )  *  */
end_comment

begin_function
specifier|static
name|void
name|ms
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TESTMAIN
name|usleep
argument_list|(
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|delay
argument_list|(
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*           fkey - get a character from a file  *  * fkey ( file -- char )  */
end_comment

begin_function
specifier|static
name|void
name|fkey
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
operator|>
literal|0
condition|?
name|ch
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         freebsd exception handling words ** Catch, from ANS Forth standard. Installs a safety net, then EXECUTE ** the word in ToS. If an exception happens, restore the state to what ** it was before, and pushes the exception value on the stack. If not, ** push zero. ** ** Notice that Catch implements an inner interpreter. This is ugly, ** but given how ficl works, it cannot be helped. The problem is that ** colon definitions will be executed *after* the function returns, ** while "code" definitions will be executed immediately. I considered ** other solutions to this problem, but all of them shared the same ** basic problem (with added disadvantages): if ficl ever changes it's ** inner thread modus operandi, one would have to fix this word. ** ** More comments can be found throughout catch's code. ** ** Daniel C. Sobral Jan 09/1999 ** sadler may 2000 -- revised to follow ficl.c:ficlExecXT. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlCatch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
specifier|static
name|FICL_WORD
modifier|*
name|pQuit
init|=
name|NULL
decl_stmt|;
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|FICL_VM
name|VM
decl_stmt|;
name|FICL_STACK
name|pStack
decl_stmt|;
name|FICL_STACK
name|rStack
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|if
condition|(
operator|!
name|pQuit
condition|)
name|pQuit
operator|=
name|ficlLookup
argument_list|(
literal|"exit-inner"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pQuit
argument_list|)
expr_stmt|;
comment|/*     ** Get xt.     ** We need this *before* we save the stack pointer, or     ** we'll have to pop one element out of the stack after     ** an exception. I prefer to get done with it up front. :-)     */
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/*      ** Save vm's state -- a catch will not back out environmental     ** changes.     **     ** We are *not* saving dictionary state, since it is     ** global instead of per vm, and we are not saving     ** stack contents, since we are not required to (and,     ** thus, it would be useless). We save pVM, and pVM     ** "stacks" (a structure containing general information     ** about it, including the current stack pointer).     */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|VM
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|pStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|rStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Give pVM a jmp_buf     */
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/*     ** Safety net     */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
comment|/* 		** Setup condition - push poison pill so that the VM throws 		** VM_INNEREXIT if the XT terminates normally, then execute 		** the XT 		*/
case|case
literal|0
case|:
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
name|pQuit
argument_list|)
expr_stmt|;
comment|/* Open mouth, insert emetic */
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
comment|/* 		** Normal exit from XT - lose the poison pill,  		** restore old setjmp vector and push a zero.  		*/
case|case
name|VM_INNEREXIT
case|:
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
comment|/* Gack - hurl poison pill */
name|pVM
operator|->
name|pState
operator|=
name|VM
operator|.
name|pState
expr_stmt|;
comment|/* Restore just the setjmp vector */
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Push 0 -- everything is ok */
break|break;
comment|/* 		** Some other exception got thrown - restore pre-existing VM state 		** and push the exception code 		*/
default|default:
comment|/* Restore vm's state */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|VM
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|except
argument_list|)
expr_stmt|;
comment|/* Push error */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Throw --  From ANS Forth standard.  *  * Throw takes the ToS and, if that's different from zero,  * returns to the last executed catch context. Further throws will  * unstack previously executed "catches", in LIFO mode.  *  * Daniel C. Sobral Jan 09/1999  */
end_comment

begin_function
specifier|static
name|void
name|ficlThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|except
decl_stmt|;
name|except
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|except
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansAllocate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|p
operator|=
name|ficlMalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansFree
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansResize
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|size
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|old
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|new
operator|=
name|ficlRealloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Retrieves free space remaining on the dictionary */
end_comment

begin_function
specifier|static
name|void
name|freeHeap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|dictCellsAvail
argument_list|(
name|ficlGetDict
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** exit-inner  ** Signals execXT that an inner loop has completed */
end_comment

begin_function
specifier|static
name|void
name|ficlExitInner
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_INNEREXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d n e g a t e ** DOUBLE   ( d1 -- d2 ) ** d2 is the negation of d1.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dnegate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|i
init|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|i
operator|=
name|m64Negate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************* Increase dictionary size on-demand ******************/
end_comment

begin_function
specifier|static
name|void
name|ficlDictThreshold
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|dictThreshold
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlDictIncrease
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|dictIncrease
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************* freebsd added trace ***************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FICL_TRACE
end_ifdef

begin_function
specifier|static
name|void
name|ficlTrace
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ficl_trace
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l C o m p i l e C o r e ** Builds the primitive wordset and the environment-query namespace. **************************************************************************/
end_comment

begin_function
name|void
name|ficlCompileCore
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|)
block|{
name|assert
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*     ** CORE word set     ** see softcore.c for definitions of: abs bl space spaces abort"     */
name|pStore
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"!"
argument_list|,
name|store
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#"
argument_list|,
name|numberSign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#>"
argument_list|,
name|numberSignGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#s"
argument_list|,
name|numberSignS
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"\'"
argument_list|,
name|tick
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"("
argument_list|,
name|commentHang
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*"
argument_list|,
name|mul
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*/"
argument_list|,
name|mulDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*/mod"
argument_list|,
name|mulDivRem
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+"
argument_list|,
name|add
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+!"
argument_list|,
name|plusStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+loop"
argument_list|,
name|plusLoopCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|pComma
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|","
argument_list|,
name|comma
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"-"
argument_list|,
name|sub
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"."
argument_list|,
name|displayCell
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".#"
argument_list|,
name|displayCellNoPad
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".\""
argument_list|,
name|dotQuoteCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"/"
argument_list|,
name|ficlDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"/mod"
argument_list|,
name|slashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0<"
argument_list|,
name|zeroLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0="
argument_list|,
name|zeroEquals
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0>"
argument_list|,
name|zeroGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"1+"
argument_list|,
name|onePlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"1-"
argument_list|,
name|oneMinus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2!"
argument_list|,
name|twoStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2*"
argument_list|,
name|twoMul
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2/"
argument_list|,
name|twoDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2@"
argument_list|,
name|twoFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2drop"
argument_list|,
name|twoDrop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2dup"
argument_list|,
name|twoDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2over"
argument_list|,
name|twoOver
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2swap"
argument_list|,
name|twoSwap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|":"
argument_list|,
name|colon
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|";"
argument_list|,
name|semicolonCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"<"
argument_list|,
name|isLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"<#"
argument_list|,
name|lessNumberSign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"="
argument_list|,
name|isEqual
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">"
argument_list|,
name|isGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">body"
argument_list|,
name|toBody
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">in"
argument_list|,
name|toIn
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">number"
argument_list|,
name|toNumber
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">r"
argument_list|,
name|toRStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"?dup"
argument_list|,
name|questionDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"@"
argument_list|,
name|fetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"abort"
argument_list|,
name|ficlAbort
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"accept"
argument_list|,
name|accept
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"align"
argument_list|,
name|align
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"aligned"
argument_list|,
name|aligned
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"allot"
argument_list|,
name|allot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"and"
argument_list|,
name|bitwiseAnd
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"base"
argument_list|,
name|base
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"begin"
argument_list|,
name|beginCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c!"
argument_list|,
name|cStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c,"
argument_list|,
name|cComma
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c@"
argument_list|,
name|cFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cell+"
argument_list|,
name|cellPlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cells"
argument_list|,
name|cells
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"char"
argument_list|,
name|ficlChar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"char+"
argument_list|,
name|charPlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"chars"
argument_list|,
name|ficlChars
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"constant"
argument_list|,
name|constant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"count"
argument_list|,
name|count
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cr"
argument_list|,
name|cr
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"create"
argument_list|,
name|create
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"decimal"
argument_list|,
name|decimal
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"do"
argument_list|,
name|doCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"does>"
argument_list|,
name|doesCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"drop"
argument_list|,
name|drop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dup"
argument_list|,
name|dup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"else"
argument_list|,
name|elseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"emit"
argument_list|,
name|emit
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"environment?"
argument_list|,
name|environmentQ
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"evaluate"
argument_list|,
name|evaluate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"execute"
argument_list|,
name|execute
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"exit"
argument_list|,
name|exitCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fill"
argument_list|,
name|fill
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"find"
argument_list|,
name|find
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fm/mod"
argument_list|,
name|fmSlashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"here"
argument_list|,
name|here
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hex"
argument_list|,
name|hex
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hold"
argument_list|,
name|hold
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"i"
argument_list|,
name|loopICo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"if"
argument_list|,
name|ifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"immediate"
argument_list|,
name|immediate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"invert"
argument_list|,
name|bitwiseNot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"j"
argument_list|,
name|loopJCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"k"
argument_list|,
name|loopKCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"leave"
argument_list|,
name|leaveCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"literal"
argument_list|,
name|literalIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"loop"
argument_list|,
name|loopCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"lshift"
argument_list|,
name|lshift
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"m*"
argument_list|,
name|mStar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"max"
argument_list|,
name|ficlMax
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"min"
argument_list|,
name|ficlMin
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"mod"
argument_list|,
name|ficlMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"move"
argument_list|,
name|move
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"negate"
argument_list|,
name|negate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"or"
argument_list|,
name|bitwiseOr
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"over"
argument_list|,
name|over
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"postpone"
argument_list|,
name|postponeCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"quit"
argument_list|,
name|quit
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"r>"
argument_list|,
name|fromRStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"r@"
argument_list|,
name|fetchRStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"recurse"
argument_list|,
name|recurseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"repeat"
argument_list|,
name|repeatCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"rot"
argument_list|,
name|rot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"rshift"
argument_list|,
name|rshift
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"s\""
argument_list|,
name|stringQuoteIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"s>d"
argument_list|,
name|sToD
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sign"
argument_list|,
name|sign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sm/rem"
argument_list|,
name|smSlashRem
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"source"
argument_list|,
name|source
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"state"
argument_list|,
name|state
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"swap"
argument_list|,
name|swap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"then"
argument_list|,
name|endifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|pType
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"type"
argument_list|,
name|type
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"u."
argument_list|,
name|uDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"u<"
argument_list|,
name|uIsLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"um*"
argument_list|,
name|umStar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"um/mod"
argument_list|,
name|umSlashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"unloop"
argument_list|,
name|unloopCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"until"
argument_list|,
name|untilCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"variable"
argument_list|,
name|variable
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"while"
argument_list|,
name|whileCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"word"
argument_list|,
name|ficlWord
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"xor"
argument_list|,
name|bitwiseXor
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"["
argument_list|,
name|lbracketCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"[\']"
argument_list|,
name|bracketTickCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"[char]"
argument_list|,
name|charCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"]"
argument_list|,
name|rbracket
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*      ** CORE EXT word set...     ** see softcore.c for other definitions     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".("
argument_list|,
name|dotParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|":noname"
argument_list|,
name|colonNoName
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"?do"
argument_list|,
name|qDoCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"again"
argument_list|,
name|againCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"parse"
argument_list|,
name|parse
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"pick"
argument_list|,
name|pick
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"roll"
argument_list|,
name|roll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"refill"
argument_list|,
name|refill
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"to"
argument_list|,
name|toValue
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"value"
argument_list|,
name|constant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"\\"
argument_list|,
name|commentLine
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
comment|/* FreeBSD extension words */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fopen"
argument_list|,
name|pfopen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fclose"
argument_list|,
name|pfclose
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fread"
argument_list|,
name|pfread
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fload"
argument_list|,
name|pfload
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fkey"
argument_list|,
name|fkey
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"key"
argument_list|,
name|key
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"key?"
argument_list|,
name|keyQuestion
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"ms"
argument_list|,
name|ms
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"seconds"
argument_list|,
name|pseconds
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"heap?"
argument_list|,
name|freeHeap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dictthreshold"
argument_list|,
name|ficlDictThreshold
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dictincrease"
argument_list|,
name|ficlDictIncrease
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FICL_TRACE
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"trace!"
argument_list|,
name|ficlTrace
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TESTMAIN
ifdef|#
directive|ifdef
name|__i386__
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"outb"
argument_list|,
name|ficlOutb
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"inb"
argument_list|,
name|ficlInb
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|ficlSetEnv
argument_list|(
literal|"arch-i386"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"arch-alpha"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha__
argument_list|)
name|ficlSetEnv
argument_list|(
literal|"arch-i386"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"arch-alpha"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Set CORE environment query values     */
name|ficlSetEnv
argument_list|(
literal|"/counted-string"
argument_list|,
name|FICL_STRING_MAX
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"/hold"
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"/pad"
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"address-unit-bits"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"core"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"core-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"floored"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"max-char"
argument_list|,
name|UCHAR_MAX
argument_list|)
expr_stmt|;
name|ficlSetEnvD
argument_list|(
literal|"max-d"
argument_list|,
literal|0x7fffffff
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"max-n"
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"max-u"
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnvD
argument_list|(
literal|"max-ud"
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"return-stack-cells"
argument_list|,
name|FICL_DEFAULT_STACK
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"stack-cells"
argument_list|,
name|FICL_DEFAULT_STACK
argument_list|)
expr_stmt|;
comment|/*     ** DOUBLE word set (partial)     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2constant"
argument_list|,
name|twoConstant
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2literal"
argument_list|,
name|twoLiteralIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dnegate"
argument_list|,
name|dnegate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** EXCEPTION word set     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"catch"
argument_list|,
name|ficlCatch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"throw"
argument_list|,
name|ficlThrow
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"exception"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"exception-ext"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
comment|/*     ** LOCAL and LOCAL EXT     ** see softcore.c for implementation of locals|     */
if|#
directive|if
name|FICL_WANT_LOCALS
name|pLinkParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(link)"
argument_list|,
name|linkParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pUnLinkParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(unlink)"
argument_list|,
name|unlinkParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"doLocal"
argument_list|,
name|doLocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|pGetLocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local)"
argument_list|,
name|getLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pToLocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal)"
argument_list|,
name|toLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pGetLocal0
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local0)"
argument_list|,
name|getLocal0
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pToLocal0
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal0)"
argument_list|,
name|toLocal0
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pGetLocal1
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local1)"
argument_list|,
name|getLocal1
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pToLocal1
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal1)"
argument_list|,
name|toLocal1
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(local)"
argument_list|,
name|localParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pGet2LocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@2local)"
argument_list|,
name|get2LocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pTo2LocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(to2Local)"
argument_list|,
name|to2LocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(2local)"
argument_list|,
name|twoLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"locals"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"locals-ext"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"#locals"
argument_list|,
name|FICL_MAX_LOCALS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Optional MEMORY-ALLOC word set     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"allocate"
argument_list|,
name|ansAllocate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"free"
argument_list|,
name|ansFree
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"resize"
argument_list|,
name|ansResize
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"memory-alloc"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"memory-alloc-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
comment|/*     ** optional SEARCH-ORDER word set      */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">search"
argument_list|,
name|searchPush
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"search>"
argument_list|,
name|searchPop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"definitions"
argument_list|,
name|definitions
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"forth-wordlist"
argument_list|,
name|forthWordlist
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"get-current"
argument_list|,
name|getCurrent
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"get-order"
argument_list|,
name|getOrder
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"search-wordlist"
argument_list|,
name|searchWordlist
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"set-current"
argument_list|,
name|setCurrent
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"set-order"
argument_list|,
name|setOrder
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"ficl-wordlist"
argument_list|,
name|wordlist
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** Set SEARCH environment query values     */
name|ficlSetEnv
argument_list|(
literal|"search-order"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"search-order-ext"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"wordlists"
argument_list|,
name|FICL_DEFAULT_VOCS
argument_list|)
expr_stmt|;
comment|/*     ** TOOLS and TOOLS EXT     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".s"
argument_list|,
name|displayStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"bye"
argument_list|,
name|bye
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"forget"
argument_list|,
name|forget
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"see"
argument_list|,
name|see
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"words"
argument_list|,
name|listWords
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** Set TOOLS environment query values     */
name|ficlSetEnv
argument_list|(
literal|"tools"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
literal|"tools-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
comment|/*     ** Ficl extras     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".env"
argument_list|,
name|listEnv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".ver"
argument_list|,
name|ficlVersion
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"-roll"
argument_list|,
name|minusRoll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">name"
argument_list|,
name|toName
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"body>"
argument_list|,
name|fromBody
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"compare"
argument_list|,
name|compareString
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* STRING */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"compile-only"
argument_list|,
name|compileOnly
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"endif"
argument_list|,
name|endifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"forget-wid"
argument_list|,
name|forgetWid
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hash"
argument_list|,
name|hash
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"number?"
argument_list|,
name|ficlIsNum
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"parse-word"
argument_list|,
name|parseNoCopy
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sliteral"
argument_list|,
name|sLiteralCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
comment|/* STRING */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"wid-set-super"
argument_list|,
name|setParentWid
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"w@"
argument_list|,
name|wFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"w!"
argument_list|,
name|wStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"x."
argument_list|,
name|hexDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_USER
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(user)"
argument_list|,
name|userParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"user"
argument_list|,
name|userVariable
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** internal support words     */
name|pExitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(exit)"
argument_list|,
name|exitParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSemiParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(;)"
argument_list|,
name|semiParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pLitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(literal)"
argument_list|,
name|literalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pTwoLitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(2literal)"
argument_list|,
name|twoLitParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pStringLit
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(.\")"
argument_list|,
name|stringLit
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pIfParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(if)"
argument_list|,
name|ifParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pBranchParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(branch)"
argument_list|,
name|branchParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pDoParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(do)"
argument_list|,
name|doParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pDoesParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(does>)"
argument_list|,
name|doesParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pQDoParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(?do)"
argument_list|,
name|qDoParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pLoopParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(loop)"
argument_list|,
name|loopParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pPLoopParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(+loop)"
argument_list|,
name|plusLoopParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pInterpret
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"interpret"
argument_list|,
name|interpret
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(variable)"
argument_list|,
name|variableParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(constant)"
argument_list|,
name|constantParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"exit-inner"
argument_list|,
name|ficlExitInner
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dictCellsAvail
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

