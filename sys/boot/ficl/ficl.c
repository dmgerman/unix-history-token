begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f i c l . c ** Forth Inspired Command Language - external interface ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* ** This is an ANS Forth interpreter written in C. ** Ficl uses Forth syntax for its commands, but turns the Forth  ** model on its head in other respects. ** Ficl provides facilities for interoperating ** with programs written in C: C functions can be exported to Ficl, ** and Ficl commands can be executed via a C calling interface. The ** interpreter is re-entrant, so it can be used in multiple instances ** in a multitasking system. Unlike Forth, Ficl's outer interpreter ** expects a text block as input, and returns to the caller after each ** text block, so the data pump is somewhere in external code. This ** is more like TCL than Forth. ** ** Code is written in ANSI C for portability.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_comment
comment|/* ** Local prototypes */
end_comment

begin_comment
comment|/* ** System statics ** The system builds a global dictionary during its start ** sequence. This is shared by all interpreter instances. ** Therefore only one instance can update the dictionary ** at a time. The system imports a locking function that ** you can override in order to control update access to ** the dictionary. The function is stubbed out by default, ** but you can insert one: #define FICL_MULTITHREAD 1 ** and supply your own version of ficlLockDictionary. */
end_comment

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|envp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|localp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|FICL_VM
modifier|*
name|vmList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultStack
init|=
name|FICL_DEFAULT_STACK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultDict
init|=
name|FICL_DEFAULT_DICT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         f i c l I n i t S y s t e m ** Binds a global dictionary to the interpreter system.  ** You specify the address and size of the allocated area. ** After that, ficl manages it. ** First step is to set up the static pointers to the area. ** Then write the "precompiled" portion of the dictionary in. ** The dictionary needs to be at least large enough to hold the ** precompiled part. Try 1K cells minimum. Use "words" to find ** out how much of the dictionary is used at any time. **************************************************************************/
end_comment

begin_function
name|void
name|ficlInitSystem
parameter_list|(
name|int
name|nDictCells
parameter_list|)
block|{
if|if
condition|(
name|dp
condition|)
name|dictDelete
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|envp
condition|)
name|dictDelete
argument_list|(
name|envp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|localp
condition|)
name|dictDelete
argument_list|(
name|localp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nDictCells
operator|<=
literal|0
condition|)
name|nDictCells
operator|=
name|defaultDict
expr_stmt|;
name|dp
operator|=
name|dictCreateHashed
argument_list|(
operator|(
name|unsigned
operator|)
name|nDictCells
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|envp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_DEFAULT_ENV
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
comment|/*     ** The locals dictionary is only searched while compiling,     ** but this is where speed is most important. On the other     ** hand, the dictionary gets emptied after each use of locals     ** The need to balance search speed with the cost of the empty     ** operation led me to select a single-threaded list...     */
name|localp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_MAX_LOCALS
operator|*
name|CELLS_PER_WORD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ficlCompileCore
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l N e w V M ** Create a new virtual machine and link it into the system list ** of VMs for later cleanup by ficlTermSystem. If this is the first ** VM to be created, use it to compile the words in softcore.c **************************************************************************/
end_comment

begin_function
name|FICL_VM
modifier|*
name|ficlNewVM
parameter_list|(
name|void
parameter_list|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|vmCreate
argument_list|(
name|NULL
argument_list|,
name|defaultStack
argument_list|,
name|defaultStack
argument_list|)
decl_stmt|;
name|pVM
operator|->
name|link
operator|=
name|vmList
expr_stmt|;
comment|/*     ** Borrow the first vm to build the soft words in softcore.c     */
if|if
condition|(
name|vmList
operator|==
name|NULL
condition|)
name|ficlCompileSoftCore
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|vmList
operator|=
name|pVM
expr_stmt|;
return|return
name|pVM
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l B u i l d ** Builds a word into the dictionary. ** Preconditions: system must be initialized, and there must ** be enough space for the new word's header! Operation is ** controlled by ficlLockDictionary, so any initialization ** required by your version of the function (if you overrode ** it) must be complete at this point. ** Parameters: ** name  -- duh, the name of the word ** code  -- code to execute when the word is invoked - must take a single param **          pointer to a FICL_VM ** flags -- 0 or more of F_IMMEDIATE, F_COMPILE, use bitwise OR! **  **************************************************************************/
end_comment

begin_function
name|int
name|ficlBuild
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|code
parameter_list|,
name|char
name|flags
parameter_list|)
block|{
name|int
name|err
init|=
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|code
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c ** Evaluates a block of input text in the context of the ** specified interpreter. Emits any requested output to the ** interpreter's output function. ** ** Contains the "inner interpreter" code in a tight loop ** ** Returns one of the VM_XXXX codes defined in ficl.h: ** VM_OUTOFTEXT is the normal exit condition ** VM_ERREXIT means that the interp encountered a syntax error **      and the vm has been reset to recover (some or all **      of the text block got ignored ** VM_USEREXIT means that the user executed the "bye" command **      to shut down the interpreter. This would be a good **      time to delete the vm, etc -- or you can ignore this **      signal. **************************************************************************/
end_comment

begin_function
name|int
name|ficlExec
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
block|{
name|int
name|except
decl_stmt|;
name|FICL_WORD
modifier|*
name|tempFW
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|jmp_buf
modifier|*
name|oldState
decl_stmt|;
name|TIB
name|saveTib
decl_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|vmPushTib
argument_list|(
name|pVM
argument_list|,
name|pText
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
comment|/*     ** Save and restore VM's jmp_buf to enable nested calls to ficlExec      */
name|oldState
operator|=
name|pVM
operator|->
name|pState
expr_stmt|;
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/* This has to come before the setjmp! */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|pVM
operator|->
name|fRestart
condition|)
block|{
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
comment|/*         ** the mysterious inner interpreter...         ** vmThrow gets you out of this loop with a longjmp()         */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tempFW
operator|=
operator|*
name|pVM
operator|->
name|ip
operator|++
expr_stmt|;
comment|/*             ** inline code for             ** vmExecute(pVM, tempFW);             */
name|pVM
operator|->
name|runningWord
operator|=
name|tempFW
expr_stmt|;
name|tempFW
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VM_RESTART
case|:
name|pVM
operator|->
name|fRestart
operator|=
literal|1
expr_stmt|;
name|except
operator|=
name|VM_OUTOFTEXT
expr_stmt|;
break|break;
case|case
name|VM_OUTOFTEXT
case|:
if|if
condition|(
operator|(
name|pVM
operator|->
name|state
operator|!=
name|COMPILE
operator|)
operator|&&
operator|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|==
literal|0
operator|)
condition|)
name|ficlTextOut
argument_list|(
name|pVM
argument_list|,
name|FICL_PROMPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_USEREXIT
case|:
break|break;
case|case
name|VM_QUIT
case|:
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vmQuit
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ERREXIT
case|:
default|default:
comment|/* user defined exit code?? */
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
block|{
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|dictEmpty
argument_list|(
name|localp
argument_list|,
name|localp
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dictResetSearchOrder
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vmReset
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
block|}
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|vmPopTib
argument_list|(
name|pVM
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
return|return
operator|(
name|except
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l L o o k u p ** Look in the system dictionary for a match to the given name. If ** found, return the address of the corresponding FICL_WORD. Otherwise ** return NULL. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|ficlLookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t D i c t ** Returns the address of the system dictionary **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetDict
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t E n v ** Returns the address of the system environment space **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetEnv
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|envp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l S e t E n v ** Create an environment variable with a one-CELL payload. ficlSetEnvD ** makes one with a two-CELL payload. **************************************************************************/
end_comment

begin_function
name|void
name|ficlSetEnv
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|UNS32
name|value
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ficlSetEnvD
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|UNS32
name|hi
parameter_list|,
name|UNS32
name|lo
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|twoConstParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t L o c ** Returns the address of the system locals dictionary. This dict is ** only used during compilation, and is shared by all VMs. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_function
name|FICL_DICT
modifier|*
name|ficlGetLoc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|localp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l T e r m S y s t e m ** Tear the system down by deleting the dictionaries and all VMs. ** This saves you from having to keep track of all that stuff. **************************************************************************/
end_comment

begin_function
name|void
name|ficlTermSystem
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dp
condition|)
name|dictDelete
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|envp
condition|)
name|dictDelete
argument_list|(
name|envp
argument_list|)
expr_stmt|;
name|envp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|localp
condition|)
name|dictDelete
argument_list|(
name|localp
argument_list|)
expr_stmt|;
name|localp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|vmList
operator|!=
name|NULL
condition|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|vmList
decl_stmt|;
name|vmList
operator|=
name|vmList
operator|->
name|link
expr_stmt|;
name|vmDelete
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

