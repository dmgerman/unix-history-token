begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f i c l . c ** Forth Inspired Command Language - external interface ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* ** This is an ANS Forth interpreter written in C. ** Ficl uses Forth syntax for its commands, but turns the Forth  ** model on its head in other respects. ** Ficl provides facilities for interoperating ** with programs written in C: C functions can be exported to Ficl, ** and Ficl commands can be executed via a C calling interface. The ** interpreter is re-entrant, so it can be used in multiple instances ** in a multitasking system. Unlike Forth, Ficl's outer interpreter ** expects a text block as input, and returns to the caller after each ** text block, so the data pump is somewhere in external code. This ** is more like TCL than Forth. ** ** Code is written in ANSI C for portability.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FICL_TRACE
end_ifdef

begin_decl_stmt
name|int
name|ficl_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Local prototypes */
end_comment

begin_comment
comment|/* ** System statics ** The system builds a global dictionary during its start ** sequence. This is shared by all interpreter instances. ** Therefore only one instance can update the dictionary ** at a time. The system imports a locking function that ** you can override in order to control update access to ** the dictionary. The function is stubbed out by default, ** but you can insert one: #define FICL_MULTITHREAD 1 ** and supply your own version of ficlLockDictionary. */
end_comment

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|envp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_decl_stmt
specifier|static
name|FICL_DICT
modifier|*
name|localp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|FICL_VM
modifier|*
name|vmList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultStack
init|=
name|FICL_DEFAULT_STACK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultDict
init|=
name|FICL_DEFAULT_DICT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         f i c l I n i t S y s t e m ** Binds a global dictionary to the interpreter system.  ** You specify the address and size of the allocated area. ** After that, ficl manages it. ** First step is to set up the static pointers to the area. ** Then write the "precompiled" portion of the dictionary in. ** The dictionary needs to be at least large enough to hold the ** precompiled part. Try 1K cells minimum. Use "words" to find ** out how much of the dictionary is used at any time. **************************************************************************/
end_comment

begin_function
name|void
name|ficlInitSystem
parameter_list|(
name|int
name|nDictCells
parameter_list|)
block|{
if|if
condition|(
name|dp
condition|)
name|dictDelete
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|envp
condition|)
name|dictDelete
argument_list|(
name|envp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|localp
condition|)
name|dictDelete
argument_list|(
name|localp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nDictCells
operator|<=
literal|0
condition|)
name|nDictCells
operator|=
name|defaultDict
expr_stmt|;
name|dp
operator|=
name|dictCreateHashed
argument_list|(
operator|(
name|unsigned
operator|)
name|nDictCells
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|envp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_DEFAULT_ENV
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
comment|/*     ** The locals dictionary is only searched while compiling,     ** but this is where speed is most important. On the other     ** hand, the dictionary gets emptied after each use of locals     ** The need to balance search speed with the cost of the empty     ** operation led me to select a single-threaded list...     */
name|localp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_MAX_LOCALS
operator|*
name|CELLS_PER_WORD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ficlCompileCore
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l N e w V M ** Create a new virtual machine and link it into the system list ** of VMs for later cleanup by ficlTermSystem. If this is the first ** VM to be created, use it to compile the words in softcore.c **************************************************************************/
end_comment

begin_function
name|FICL_VM
modifier|*
name|ficlNewVM
parameter_list|(
name|void
parameter_list|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|vmCreate
argument_list|(
name|NULL
argument_list|,
name|defaultStack
argument_list|,
name|defaultStack
argument_list|)
decl_stmt|;
name|pVM
operator|->
name|link
operator|=
name|vmList
expr_stmt|;
comment|/*     ** Borrow the first vm to build the soft words in softcore.c     */
if|if
condition|(
name|vmList
operator|==
name|NULL
condition|)
name|ficlCompileSoftCore
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|vmList
operator|=
name|pVM
expr_stmt|;
return|return
name|pVM
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l F r e e V M ** Removes the VM in question from the system VM list and deletes the ** memory allocated to it. This is an optional call, since ficlTermSystem ** will do this cleanup for you. This function is handy if you're going to ** do a lot of dynamic creation of VMs. **************************************************************************/
end_comment

begin_function
name|void
name|ficlFreeVM
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_VM
modifier|*
name|pList
init|=
name|vmList
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmList
operator|==
name|pVM
condition|)
block|{
name|vmList
operator|=
name|vmList
operator|->
name|link
expr_stmt|;
block|}
else|else
for|for
control|(
name|pList
init|;
name|pList
operator|!=
literal|0
condition|;
name|pList
operator|=
name|pList
operator|->
name|link
control|)
block|{
if|if
condition|(
name|pList
operator|->
name|link
operator|==
name|pVM
condition|)
block|{
name|pList
operator|->
name|link
operator|=
name|pVM
operator|->
name|link
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pList
condition|)
name|vmDelete
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l B u i l d ** Builds a word into the dictionary. ** Preconditions: system must be initialized, and there must ** be enough space for the new word's header! Operation is ** controlled by ficlLockDictionary, so any initialization ** required by your version of the function (if you overrode ** it) must be complete at this point. ** Parameters: ** name  -- duh, the name of the word ** code  -- code to execute when the word is invoked - must take a single param **          pointer to a FICL_VM ** flags -- 0 or more of F_IMMEDIATE, F_COMPILE, use bitwise OR! **  **************************************************************************/
end_comment

begin_function
name|int
name|ficlBuild
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|code
parameter_list|,
name|char
name|flags
parameter_list|)
block|{
name|int
name|err
init|=
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|assert
argument_list|(
name|dictCellsAvail
argument_list|(
name|dp
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|FICL_WORD
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|code
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c ** Evaluates a block of input text in the context of the ** specified interpreter. Emits any requested output to the ** interpreter's output function. ** ** Contains the "inner interpreter" code in a tight loop ** ** Returns one of the VM_XXXX codes defined in ficl.h: ** VM_OUTOFTEXT is the normal exit condition ** VM_ERREXIT means that the interp encountered a syntax error **      and the vm has been reset to recover (some or all **      of the text block got ignored ** VM_USEREXIT means that the user executed the "bye" command **      to shut down the interpreter. This would be a good **      time to delete the vm, etc -- or you can ignore this **      signal. **************************************************************************/
end_comment

begin_function
name|int
name|ficlExec
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
block|{
return|return
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|pText
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ficlExecC
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|,
name|FICL_INT
name|size
parameter_list|)
block|{
specifier|static
name|FICL_WORD
modifier|*
name|pInterp
init|=
name|NULL
decl_stmt|;
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|jmp_buf
modifier|*
name|oldState
decl_stmt|;
name|TIB
name|saveTib
decl_stmt|;
if|if
condition|(
operator|!
name|pInterp
condition|)
name|pInterp
operator|=
name|ficlLookup
argument_list|(
literal|"interpret"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pInterp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|pText
argument_list|)
expr_stmt|;
name|vmPushTib
argument_list|(
name|pVM
argument_list|,
name|pText
argument_list|,
name|size
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
comment|/*     ** Save and restore VM's jmp_buf to enable nested calls to ficlExec      */
name|oldState
operator|=
name|pVM
operator|->
name|pState
expr_stmt|;
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/* This has to come before the setjmp! */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|pVM
operator|->
name|fRestart
condition|)
block|{
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set VM up to interpret text */
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
name|pInterp
argument_list|)
expr_stmt|;
block|}
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RESTART
case|:
name|pVM
operator|->
name|fRestart
operator|=
literal|1
expr_stmt|;
name|except
operator|=
name|VM_OUTOFTEXT
expr_stmt|;
break|break;
case|case
name|VM_OUTOFTEXT
case|:
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TESTMAIN
if|if
condition|(
operator|(
name|pVM
operator|->
name|state
operator|!=
name|COMPILE
operator|)
operator|&&
operator|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|==
literal|0
operator|)
condition|)
name|ficlTextOut
argument_list|(
name|pVM
argument_list|,
name|FICL_PROMPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VM_USEREXIT
case|:
case|case
name|VM_INNEREXIT
case|:
break|break;
case|case
name|VM_QUIT
case|:
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
block|{
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|dictEmpty
argument_list|(
name|localp
argument_list|,
name|localp
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|vmQuit
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ERREXIT
case|:
case|case
name|VM_ABORT
case|:
case|case
name|VM_ABORTQ
case|:
default|default:
comment|/* user defined exit code?? */
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
block|{
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|dictEmpty
argument_list|(
name|localp
argument_list|,
name|localp
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dictResetSearchOrder
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vmReset
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
block|}
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|vmPopTib
argument_list|(
name|pVM
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
return|return
operator|(
name|except
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c F D ** reads in text from file fd and passes it to ficlExec()  * returns VM_OUTOFTEXT on success or the ficlExec() error code on  * failure.  */
end_comment

begin_define
define|#
directive|define
name|nLINEBUF
value|256
end_define

begin_function
name|int
name|ficlExecFD
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|char
name|cp
index|[
name|nLINEBUF
index|]
decl_stmt|;
name|int
name|nLine
init|=
literal|0
decl_stmt|,
name|rval
init|=
name|VM_OUTOFTEXT
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|CELL
name|id
decl_stmt|;
name|id
operator|=
name|pVM
operator|->
name|sourceID
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
name|fd
expr_stmt|;
comment|/* feed each line to ficlExec */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|status
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|cp
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|nLine
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
if|if
condition|(
name|status
operator|<
literal|1
condition|)
break|break;
continue|continue;
block|}
name|rval
operator|=
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|VM_QUIT
operator|&&
name|rval
operator|!=
name|VM_USEREXIT
operator|&&
name|rval
operator|!=
name|VM_OUTOFTEXT
condition|)
block|{
name|pVM
operator|->
name|sourceID
operator|=
name|id
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/*     ** Pass an empty line with SOURCE-ID == -1 to flush     ** any pending REFILLs (as required by FILE wordset)     */
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|ficlExec
argument_list|(
name|pVM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|=
name|id
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c X T ** Given a pointer to a FICL_WORD, push an inner interpreter and ** execute the word to completion. This is in contrast with vmExecute, ** which does not guarantee that the word will have completed when ** the function returns (ie in the case of colon definitions, which ** need an inner interpreter to finish) ** ** Returns one of the VM_XXXX exception codes listed in ficl.h. Normal ** exit condition is VM_INNEREXIT, ficl's private signal to exit the ** inner loop under normal circumstances. If another code is thrown to ** exit the loop, this function will re-throw it if it's nested under ** itself or ficlExec. ** ** NOTE: this function is intended so that C code can execute ficlWords ** given their address in the dictionary (xt). **************************************************************************/
end_comment

begin_function
name|int
name|ficlExecXT
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
block|{
specifier|static
name|FICL_WORD
modifier|*
name|pQuit
init|=
name|NULL
decl_stmt|;
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|jmp_buf
modifier|*
name|oldState
decl_stmt|;
if|if
condition|(
operator|!
name|pQuit
condition|)
name|pQuit
operator|=
name|ficlLookup
argument_list|(
literal|"exit-inner"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pQuit
argument_list|)
expr_stmt|;
comment|/*     ** Save and restore VM's jmp_buf to enable nested calls     */
name|oldState
operator|=
name|pVM
operator|->
name|pState
expr_stmt|;
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/* This has to come before the setjmp! */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
if|if
condition|(
name|except
condition|)
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
else|else
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
name|pQuit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
case|case
literal|0
case|:
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pWord
argument_list|)
expr_stmt|;
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INNEREXIT
case|:
break|break;
case|case
name|VM_RESTART
case|:
case|case
name|VM_OUTOFTEXT
case|:
case|case
name|VM_USEREXIT
case|:
case|case
name|VM_QUIT
case|:
case|case
name|VM_ERREXIT
case|:
case|case
name|VM_ABORT
case|:
case|case
name|VM_ABORTQ
case|:
default|default:
comment|/* user defined exit code?? */
if|if
condition|(
name|oldState
condition|)
block|{
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
return|return
operator|(
name|except
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l L o o k u p ** Look in the system dictionary for a match to the given name. If ** found, return the address of the corresponding FICL_WORD. Otherwise ** return NULL. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|ficlLookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t D i c t ** Returns the address of the system dictionary **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetDict
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t E n v ** Returns the address of the system environment space **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetEnv
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|envp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l S e t E n v ** Create an environment variable with a one-CELL payload. ficlSetEnvD ** makes one with a two-CELL payload. **************************************************************************/
end_comment

begin_function
name|void
name|ficlSetEnv
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|value
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ficlSetEnvD
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|hi
parameter_list|,
name|FICL_UNS
name|lo
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|twoConstParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t L o c ** Returns the address of the system locals dictionary. This dict is ** only used during compilation, and is shared by all VMs. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_function
name|FICL_DICT
modifier|*
name|ficlGetLoc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|localp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l S e t S t a c k S i z e ** Set the stack sizes (return and parameter) to be used for all ** subsequently created VMs. Returns actual stack size to be used. **************************************************************************/
end_comment

begin_function
name|int
name|ficlSetStackSize
parameter_list|(
name|int
name|nStackCells
parameter_list|)
block|{
if|if
condition|(
name|nStackCells
operator|>=
name|FICL_DEFAULT_STACK
condition|)
name|defaultStack
operator|=
name|nStackCells
expr_stmt|;
else|else
name|defaultStack
operator|=
name|FICL_DEFAULT_STACK
expr_stmt|;
return|return
name|defaultStack
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l T e r m S y s t e m ** Tear the system down by deleting the dictionaries and all VMs. ** This saves you from having to keep track of all that stuff. **************************************************************************/
end_comment

begin_function
name|void
name|ficlTermSystem
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dp
condition|)
name|dictDelete
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|envp
condition|)
name|dictDelete
argument_list|(
name|envp
argument_list|)
expr_stmt|;
name|envp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|localp
condition|)
name|dictDelete
argument_list|(
name|localp
argument_list|)
expr_stmt|;
name|localp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|vmList
operator|!=
name|NULL
condition|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|vmList
decl_stmt|;
name|vmList
operator|=
name|vmList
operator|->
name|link
expr_stmt|;
name|vmDelete
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

