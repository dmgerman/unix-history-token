begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f i c l . c ** Forth Inspired Command Language - external interface ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 ** $Id: ficl.c,v 1.10 2001-04-26 21:41:42-07 jsadler Exp jsadler $ *******************************************************************/
end_comment

begin_comment
comment|/* ** This is an ANS Forth interpreter written in C. ** Ficl uses Forth syntax for its commands, but turns the Forth  ** model on its head in other respects. ** Ficl provides facilities for interoperating ** with programs written in C: C functions can be exported to Ficl, ** and Ficl commands can be executed via a C calling interface. The ** interpreter is re-entrant, so it can be used in multiple instances ** in a multitasking system. Unlike Forth, Ficl's outer interpreter ** expects a text block as input, and returns to the caller after each ** text block, so the data pump is somewhere in external code in the  ** style of TCL. ** ** Code is written in ANSI C for portability.  */
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please send ** contact me by email at the address above. ** ** $Id: ficl.c,v 1.10 2001-04-26 21:41:42-07 jsadler Exp jsadler $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_comment
comment|/* ** System statics ** The system builds a global dictionary during its start ** sequence. This is shared by all interpreter instances. ** Therefore only one instance can update the dictionary ** at a time. The system imports a locking function that ** you can override in order to control update access to ** the dictionary. The function is stubbed out by default, ** but you can insert one: #define FICL_MULTITHREAD 1 ** and supply your own version of ficlLockDictionary. */
end_comment

begin_decl_stmt
specifier|static
name|FICL_SYSTEM
modifier|*
name|pSys
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultStack
init|=
name|FICL_DEFAULT_STACK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|defaultDict
init|=
name|FICL_DEFAULT_DICT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         f i c l I n i t S y s t e m ** Binds a global dictionary to the interpreter system.  ** You specify the address and size of the allocated area. ** After that, ficl manages it. ** First step is to set up the static pointers to the area. ** Then write the "precompiled" portion of the dictionary in. ** The dictionary needs to be at least large enough to hold the ** precompiled part. Try 1K cells minimum. Use "words" to find ** out how much of the dictionary is used at any time. **************************************************************************/
end_comment

begin_function
name|void
name|ficlInitSystem
parameter_list|(
name|int
name|nDictCells
parameter_list|)
block|{
name|pSys
operator|=
name|ficlMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FICL_SYSTEM
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pSys
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_SYSTEM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nDictCells
operator|<=
literal|0
condition|)
name|nDictCells
operator|=
name|defaultDict
expr_stmt|;
name|pSys
operator|->
name|dp
operator|=
name|dictCreateHashed
argument_list|(
operator|(
name|unsigned
operator|)
name|nDictCells
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|dp
operator|->
name|pForthWords
operator|->
name|name
operator|=
literal|"forth-wordlist"
expr_stmt|;
name|pSys
operator|->
name|envp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_DEFAULT_ENV
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|envp
operator|->
name|pForthWords
operator|->
name|name
operator|=
literal|"environment"
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
comment|/*     ** The locals dictionary is only searched while compiling,     ** but this is where speed is most important. On the other     ** hand, the dictionary gets emptied after each use of locals     ** The need to balance search speed with the cost of the empty     ** operation led me to select a single-threaded list...     */
name|pSys
operator|->
name|localp
operator|=
name|dictCreate
argument_list|(
operator|(
name|unsigned
operator|)
name|FICL_MAX_LOCALS
operator|*
name|CELLS_PER_WORD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Establish the parse order. Note that prefixes precede numbers -     ** this allows constructs like "0b101010" which would parse as a     ** valid hex value otherwise.     */
name|ficlCompilePrefix
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
name|ficlAddPrecompiledParseStep
argument_list|(
name|pSys
argument_list|,
literal|"number?"
argument_list|,
name|ficlParseNumber
argument_list|)
expr_stmt|;
comment|/*     ** Build the precompiled dictionary and load softwords. We need a temporary     ** VM to do this - ficlNewVM links one to the head of the system VM list.     ** ficlCompilePlatform (defined in win32.c, for example) adds platform specific words.     */
name|ficlCompileCore
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|ficlCompileFloat
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FICL_PLATFORM_EXTEND
name|ficlCompilePlatform
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Now we can create a VM to compile the softwords. Note that the VM initialization     ** code needs to be able to find "interpret" in the dictionary in order to      ** succeed, so as presently constructed ficlCompileCore has to finish before     ** a VM can be created successfully.     */
name|ficlNewVM
argument_list|()
expr_stmt|;
name|ficlCompileSoftCore
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
name|ficlFreeVM
argument_list|(
name|pSys
operator|->
name|vmList
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l A d d P a r s e S t e p ** Appends a parse step function to the end of the parse list (see  ** FICL_PARSE_STEP notes in ficl.h for details). Returns 0 if successful, ** nonzero if there's no more room in the list. **************************************************************************/
end_comment

begin_function
name|int
name|ficlAddParseStep
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FICL_MAX_PARSE_STEPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pSys
operator|->
name|parseList
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pSys
operator|->
name|parseList
index|[
name|i
index|]
operator|=
name|pFW
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Compile a word into the dictionary that invokes the specified FICL_PARSE_STEP ** function. It is up to the user (as usual in Forth) to make sure the stack  ** preconditions are valid (there needs to be a counted string on top of the stack) ** before using the resulting word. */
end_comment

begin_function
name|void
name|ficlAddPrecompiledParseStep
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_PARSE_STEP
name|pStep
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
init|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|parseStepParen
argument_list|,
name|FW_DEFAULT
argument_list|)
decl_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pStep
argument_list|)
argument_list|)
expr_stmt|;
name|ficlAddParseStep
argument_list|(
name|pSys
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This word lists the parse steps in order */
end_comment

begin_function
name|void
name|ficlListParseSteps
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FICL_SYSTEM
modifier|*
name|pSys
init|=
name|pVM
operator|->
name|pSys
decl_stmt|;
name|assert
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"Parse steps:"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"lookup"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FICL_MAX_PARSE_STEPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pSys
operator|->
name|parseList
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pSys
operator|->
name|parseList
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l N e w V M ** Create a new virtual machine and link it into the system list ** of VMs for later cleanup by ficlTermSystem. **************************************************************************/
end_comment

begin_function
name|FICL_VM
modifier|*
name|ficlNewVM
parameter_list|(
name|void
parameter_list|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|vmCreate
argument_list|(
name|NULL
argument_list|,
name|defaultStack
argument_list|,
name|defaultStack
argument_list|)
decl_stmt|;
name|pVM
operator|->
name|link
operator|=
name|pSys
operator|->
name|vmList
expr_stmt|;
name|pVM
operator|->
name|pSys
operator|=
name|pSys
expr_stmt|;
name|pSys
operator|->
name|vmList
operator|=
name|pVM
expr_stmt|;
return|return
name|pVM
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l F r e e V M ** Removes the VM in question from the system VM list and deletes the ** memory allocated to it. This is an optional call, since ficlTermSystem ** will do this cleanup for you. This function is handy if you're going to ** do a lot of dynamic creation of VMs. **************************************************************************/
end_comment

begin_function
name|void
name|ficlFreeVM
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_VM
modifier|*
name|pList
init|=
name|pSys
operator|->
name|vmList
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSys
operator|->
name|vmList
operator|==
name|pVM
condition|)
block|{
name|pSys
operator|->
name|vmList
operator|=
name|pSys
operator|->
name|vmList
operator|->
name|link
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|pList
operator|!=
name|NULL
condition|;
name|pList
operator|=
name|pList
operator|->
name|link
control|)
block|{
if|if
condition|(
name|pList
operator|->
name|link
operator|==
name|pVM
condition|)
block|{
name|pList
operator|->
name|link
operator|=
name|pVM
operator|->
name|link
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pList
condition|)
name|vmDelete
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l B u i l d ** Builds a word into the dictionary. ** Preconditions: system must be initialized, and there must ** be enough space for the new word's header! Operation is ** controlled by ficlLockDictionary, so any initialization ** required by your version of the function (if you overrode ** it) must be complete at this point. ** Parameters: ** name  -- duh, the name of the word ** code  -- code to execute when the word is invoked - must take a single param **          pointer to a FICL_VM ** flags -- 0 or more of F_IMMEDIATE, F_COMPILE, use bitwise OR! **  **************************************************************************/
end_comment

begin_function
name|int
name|ficlBuild
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|code
parameter_list|,
name|char
name|flags
parameter_list|)
block|{
name|int
name|err
init|=
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|assert
argument_list|(
name|dictCellsAvail
argument_list|(
name|pSys
operator|->
name|dp
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|FICL_WORD
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|pSys
operator|->
name|dp
argument_list|,
name|name
argument_list|,
name|code
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c ** Evaluates a block of input text in the context of the ** specified interpreter. Emits any requested output to the ** interpreter's output function. ** ** Contains the "inner interpreter" code in a tight loop ** ** Returns one of the VM_XXXX codes defined in ficl.h: ** VM_OUTOFTEXT is the normal exit condition ** VM_ERREXIT means that the interp encountered a syntax error **      and the vm has been reset to recover (some or all **      of the text block got ignored ** VM_USEREXIT means that the user executed the "bye" command **      to shut down the interpreter. This would be a good **      time to delete the vm, etc -- or you can ignore this **      signal. **************************************************************************/
end_comment

begin_function
name|int
name|ficlExec
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
block|{
return|return
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|pText
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ficlExecC
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|,
name|FICL_INT
name|size
parameter_list|)
block|{
name|FICL_WORD
modifier|*
modifier|*
name|pInterp
init|=
name|pSys
operator|->
name|pInterp
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|jmp_buf
modifier|*
name|oldState
decl_stmt|;
name|TIB
name|saveTib
decl_stmt|;
if|if
condition|(
operator|!
name|pInterp
index|[
literal|0
index|]
condition|)
block|{
name|pInterp
index|[
literal|0
index|]
operator|=
name|ficlLookup
argument_list|(
literal|"interpret"
argument_list|)
expr_stmt|;
name|pInterp
index|[
literal|1
index|]
operator|=
name|ficlLookup
argument_list|(
literal|"(branch)"
argument_list|)
expr_stmt|;
name|pInterp
index|[
literal|2
index|]
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|-
literal|2
operator|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|pInterp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|pText
argument_list|)
expr_stmt|;
name|vmPushTib
argument_list|(
name|pVM
argument_list|,
name|pText
argument_list|,
name|size
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
comment|/*     ** Save and restore VM's jmp_buf to enable nested calls to ficlExec      */
name|oldState
operator|=
name|pVM
operator|->
name|pState
expr_stmt|;
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/* This has to come before the setjmp! */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|pVM
operator|->
name|fRestart
condition|)
block|{
name|pVM
operator|->
name|runningWord
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* set VM up to interpret text */
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
name|pInterp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RESTART
case|:
name|pVM
operator|->
name|fRestart
operator|=
literal|1
expr_stmt|;
name|except
operator|=
name|VM_OUTOFTEXT
expr_stmt|;
break|break;
case|case
name|VM_OUTOFTEXT
case|:
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TESTMAIN
if|if
condition|(
operator|(
name|pVM
operator|->
name|state
operator|!=
name|COMPILE
operator|)
operator|&&
operator|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|==
literal|0
operator|)
condition|)
name|ficlTextOut
argument_list|(
name|pVM
argument_list|,
name|FICL_PROMPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VM_USEREXIT
case|:
case|case
name|VM_INNEREXIT
case|:
case|case
name|VM_BREAK
case|:
break|break;
case|case
name|VM_QUIT
case|:
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
block|{
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|dictEmpty
argument_list|(
name|pSys
operator|->
name|localp
argument_list|,
name|pSys
operator|->
name|localp
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|vmQuit
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_ERREXIT
case|:
case|case
name|VM_ABORT
case|:
case|case
name|VM_ABORTQ
case|:
default|default:
comment|/* user defined exit code?? */
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
block|{
name|dictAbortDefinition
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|dictEmpty
argument_list|(
name|pSys
operator|->
name|localp
argument_list|,
name|pSys
operator|->
name|localp
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dictResetSearchOrder
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vmReset
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
block|}
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|vmPopTib
argument_list|(
name|pVM
argument_list|,
operator|&
name|saveTib
argument_list|)
expr_stmt|;
return|return
operator|(
name|except
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l E x e c X T ** Given a pointer to a FICL_WORD, push an inner interpreter and ** execute the word to completion. This is in contrast with vmExecute, ** which does not guarantee that the word will have completed when ** the function returns (ie in the case of colon definitions, which ** need an inner interpreter to finish) ** ** Returns one of the VM_XXXX exception codes listed in ficl.h. Normal ** exit condition is VM_INNEREXIT, ficl's private signal to exit the ** inner loop under normal circumstances. If another code is thrown to ** exit the loop, this function will re-throw it if it's nested under ** itself or ficlExec. ** ** NOTE: this function is intended so that C code can execute ficlWords ** given their address in the dictionary (xt). **************************************************************************/
end_comment

begin_function
name|int
name|ficlExecXT
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
block|{
specifier|static
name|FICL_WORD
modifier|*
name|pQuit
init|=
name|NULL
decl_stmt|;
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|jmp_buf
modifier|*
name|oldState
decl_stmt|;
name|FICL_WORD
modifier|*
name|oldRunningWord
decl_stmt|;
if|if
condition|(
operator|!
name|pQuit
condition|)
name|pQuit
operator|=
name|ficlLookup
argument_list|(
literal|"exit-inner"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pQuit
argument_list|)
expr_stmt|;
comment|/*      ** Save the runningword so that RESTART behaves correctly     ** over nested calls.     */
name|oldRunningWord
operator|=
name|pVM
operator|->
name|runningWord
expr_stmt|;
comment|/*     ** Save and restore VM's jmp_buf to enable nested calls     */
name|oldState
operator|=
name|pVM
operator|->
name|pState
expr_stmt|;
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/* This has to come before the setjmp! */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
if|if
condition|(
name|except
condition|)
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
else|else
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
name|pQuit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
case|case
literal|0
case|:
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pWord
argument_list|)
expr_stmt|;
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INNEREXIT
case|:
case|case
name|VM_BREAK
case|:
break|break;
case|case
name|VM_RESTART
case|:
case|case
name|VM_OUTOFTEXT
case|:
case|case
name|VM_USEREXIT
case|:
case|case
name|VM_QUIT
case|:
case|case
name|VM_ERREXIT
case|:
case|case
name|VM_ABORT
case|:
case|case
name|VM_ABORTQ
case|:
default|default:
comment|/* user defined exit code?? */
if|if
condition|(
name|oldState
condition|)
block|{
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pVM
operator|->
name|pState
operator|=
name|oldState
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|=
name|oldRunningWord
expr_stmt|;
return|return
operator|(
name|except
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l L o o k u p ** Look in the system dictionary for a match to the given name. If ** found, return the address of the corresponding FICL_WORD. Otherwise ** return NULL. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|ficlLookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|dictLookup
argument_list|(
name|pSys
operator|->
name|dp
argument_list|,
name|si
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t D i c t ** Returns the address of the system dictionary **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetDict
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pSys
operator|->
name|dp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t E n v ** Returns the address of the system environment space **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|ficlGetEnv
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pSys
operator|->
name|envp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l S e t E n v ** Create an environment variable with a one-CELL payload. ficlSetEnvD ** makes one with a two-CELL payload. **************************************************************************/
end_comment

begin_function
name|void
name|ficlSetEnv
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|value
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|FICL_DICT
modifier|*
name|envp
init|=
name|pSys
operator|->
name|envp
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ficlSetEnvD
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|hi
parameter_list|,
name|FICL_UNS
name|lo
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_DICT
modifier|*
name|envp
init|=
name|pSys
operator|->
name|envp
decl_stmt|;
name|SI_PSZ
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
block|{
name|dictAppendWord
argument_list|(
name|envp
argument_list|,
name|name
argument_list|,
name|twoConstParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|envp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|param
index|[
literal|1
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l G e t L o c ** Returns the address of the system locals dictionary. This dict is ** only used during compilation, and is shared by all VMs. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_function
name|FICL_DICT
modifier|*
name|ficlGetLoc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pSys
operator|->
name|localp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l S e t S t a c k S i z e ** Set the stack sizes (return and parameter) to be used for all ** subsequently created VMs. Returns actual stack size to be used. **************************************************************************/
end_comment

begin_function
name|int
name|ficlSetStackSize
parameter_list|(
name|int
name|nStackCells
parameter_list|)
block|{
if|if
condition|(
name|nStackCells
operator|>=
name|FICL_DEFAULT_STACK
condition|)
name|defaultStack
operator|=
name|nStackCells
expr_stmt|;
else|else
name|defaultStack
operator|=
name|FICL_DEFAULT_STACK
expr_stmt|;
return|return
name|defaultStack
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l T e r m S y s t e m ** Tear the system down by deleting the dictionaries and all VMs. ** This saves you from having to keep track of all that stuff. **************************************************************************/
end_comment

begin_function
name|void
name|ficlTermSystem
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pSys
operator|->
name|dp
condition|)
name|dictDelete
argument_list|(
name|pSys
operator|->
name|dp
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pSys
operator|->
name|envp
condition|)
name|dictDelete
argument_list|(
name|pSys
operator|->
name|envp
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|envp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|pSys
operator|->
name|localp
condition|)
name|dictDelete
argument_list|(
name|pSys
operator|->
name|localp
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|localp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pSys
operator|->
name|vmList
operator|!=
name|NULL
condition|)
block|{
name|FICL_VM
modifier|*
name|pVM
init|=
name|pSys
operator|->
name|vmList
decl_stmt|;
name|pSys
operator|->
name|vmList
operator|=
name|pSys
operator|->
name|vmList
operator|->
name|link
expr_stmt|;
name|vmDelete
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
name|ficlFree
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
name|pSys
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

end_unit

