begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f i c l . h ** Forth Inspired Command Language ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* ** N O T I C E -- DISCLAIMER OF WARRANTY **  ** Ficl is freeware. Use it in any way that you like, with ** the understanding that the code is supported on a "best effort" ** basis only. **  ** Any third party may reproduce, distribute, or modify the ficl ** software code or any derivative  works thereof without any  ** compensation or license, provided that the author information ** and this disclaimer text are retained in the source code files. ** The ficl software code is provided on an "as is"  basis without ** warranty of any kind, including, without limitation, the implied ** warranties of merchantability and fitness for a particular purpose ** and their equivalents under the laws of any jurisdiction.   **  ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release (yay!), please ** send me email at the address above.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FICL_H__
argument_list|)
end_if

begin_define
define|#
directive|define
name|__FICL_H__
end_define

begin_comment
comment|/* ** Ficl (Forth-inspired command language) is an ANS Forth ** interpreter written in C. Unlike traditional Forths, this ** interpreter is designed to be embedded into other systems ** as a command/macro/development prototype language.  ** ** Where Forths usually view themselves as the center of the system ** and expect the rest of the system to be coded in Forth, Ficl ** acts as a component of the system. It is easy to export  ** code written in C or ASM to Ficl in the style of TCL, or to invoke ** Ficl code from a compiled module. This allows you to do incremental ** development in a way that combines the best features of threaded  ** languages (rapid development, quick code/test/debug cycle, ** reasonably fast) with the best features of C (everyone knows it, ** easier to support large blocks of code, efficient, type checking). ** ** Ficl provides facilities for interoperating ** with programs written in C: C functions can be exported to Ficl, ** and Ficl commands can be executed via a C calling interface. The ** interpreter is re-entrant, so it can be used in multiple instances ** in a multitasking system. Unlike Forth, Ficl's outer interpreter ** expects a text block as input, and returns to the caller after each ** text block, so the "data pump" is somewhere in external code. This ** is more like TCL than Forth, which usually expcets to be at the center ** of the system, requesting input at its convenience. Each Ficl virtual  ** machine can be bound to a different I/O channel, and is independent ** of all others in in the same address space except that all virtual ** machines share a common dictionary (a sort or open symbol table that ** defines all of the elements of the language). ** ** Code is written in ANSI C for portability.  ** ** Summary of Ficl features and constraints: ** - Standard: Implements the ANSI Forth CORE word set and part  **   of the CORE EXT word-set, SEARCH and SEARCH EXT, TOOLS and **   TOOLS EXT, LOCAL and LOCAL ext and various extras. ** - Extensible: you can export code written in Forth, C,  **   or asm in a straightforward way. Ficl provides open **   facilities for extending the language in an application **   specific way. You can even add new control structures! ** - Ficl and C can interact in two ways: Ficl can encapsulate **   C code, or C code can invoke Ficl code. ** - Thread-safe, re-entrant: The shared system dictionary  **   uses a locking mechanism that you can either supply **   or stub out to provide exclusive access. Each Ficl **   virtual machine has an otherwise complete state, and **   each can be bound to a separate I/O channel (or none at all). ** - Simple encapsulation into existing systems: a basic implementation **   requires three function calls (see the example program in testmain.c). ** - ROMable: Ficl is designed to work in RAM-based and ROM code / RAM data **   environments. It does require somewhat more memory than a pure **   ROM implementation because it builds its system dictionary in  **   RAM at startup time. ** - Written an ANSI C to be as simple as I can make it to understand, **   support, debug, and port. Compiles without complaint at /Az /W4  **   (require ANSI C, max warnings) under Microsoft VC++ 5. ** - Does full 32 bit math (but you need to implement **   two mixed precision math primitives (see sysdep.c)) ** - Indirect threaded interpreter is not the fastest kind of **   Forth there is (see pForth 68K for a really fast subroutine **   threaded interpreter), but it's the cleanest match to a **   pure C implementation. ** ** P O R T I N G   F i c l ** ** To install Ficl on your target system, you need an ANSI C compiler ** and its runtime library. Inspect the system dependent macros and ** functions in sysdep.h and sysdep.c and edit them to suit your ** system. For example, INT16 is a short on some compilers and an ** int on others. Check the default CELL alignment controlled by ** FICL_ALIGN. If necessary, add new definitions of ficlMalloc, ficlFree, ** ficlLockDictionary, and ficlTextOut to work with your operating system. ** Finally, use testmain.c as a guide to installing the Ficl system and  ** one or more virtual machines into your code. You do not need to include ** testmain.c in your build. ** ** T o   D o   L i s t ** ** 1. Unimplemented system dependent CORE word: key ** 2. Kludged CORE word: ACCEPT  ** 3. Dictionary locking is full of holes - only one vm at a time **    can alter the dict.  ** 4. Ficl uses the pad in CORE words - this violates the standard, **    but it's cleaner for a multithreaded system. I'll have to make a **    second pad for reference by the word PAD to fix this. ** ** F o r   M o r e   I n f o r m a t i o n ** ** Web home of ficl **   http://www.taygeta.com/forth/compilers ** Check this website for Forth literature (including the ANSI standard) **   http://www.taygeta.com/forthlit.html ** and here for software and more links **   http://www.taygeta.com/forth.html ** ** Obvious Performance enhancement opportunities ** Compile speed ** - work on interpret speed ** - turn off locals (FICL_WANT_LOCALS) ** Interpret speed  ** - Change inner interpreter (and everything else) **   so that a definition is a list of pointers to functions **   and inline data rather than pointers to words. This gets **   rid of vm->runningWord and a level of indirection in the **   inner loop. I'll look at it for ficl 3.0 ** - Make the main hash table a bigger prime (HASHSIZE) ** - FORGET about twiddling the hash function - my experience is **   that that is a waste of time. ** - eliminate the need to pass the pVM parameter on the stack **   by dedicating a register to it. Most words need access to the **   vm, but the parameter passing overhead can be reduced. One way **   requires that the host OS have a task switch callout. Create **   a global variable for the running VM and refer to it in words **   that need VM access. Alternative: use thread local storage.  **   For single threaded implementations, you can just use a global. **   The first two solutions create portability problems, so I **   haven't considered doing them. Another possibility is to **   declare the pVm parameter to be "register", and hope the compiler **   pays attention. ** */
end_comment

begin_comment
comment|/* ** Revision History: ** 27 Aug 1998 (sadler) testing and corrections for LOCALS, LOCALS EXT, **  SEARCH / SEARCH EXT, TOOLS / TOOLS EXT.  **  Added .X to display in hex, PARSE and PARSE-WORD to supplement WORD, **  EMPTY to clear stack. ** ** 29 jun 1998 (sadler) added variable sized hash table support **  and ANS Forth optional SEARCH& SEARCH EXT word set. ** 26 May 1998 (sadler)  **  FICL_PROMPT macro ** 14 April 1998 (sadler) V1.04 **  Ficlwin: Windows version, Skip Carter's Linux port ** 5 March 1998 (sadler) V1.03 **  Bug fixes -- passes John Ryan's ANS test suite "core.fr" ** ** 24 February 1998 (sadler) V1.02 ** -Fixed bugs in<# # #> ** -Changed FICL_WORD so that storage for the name characters **  can be allocated from the dictionary as needed rather than  **  reserving 32 bytes in each word whether needed or not -  **  this saved 50% of the dictionary storage requirement. ** -Added words in testmain for Win32 functions system,chdir,cwd, **  also added a word that loads and evaluates a file. ** ** December 1997 (sadler) ** -Added VM_RESTART exception handling in ficlExec -- this lets words **  that require additional text to succeed (like :, create, variable...) **  recover gracefully from an empty input buffer rather than emitting **  an error message. Definitions can span multiple input blocks with **  no restrictions. ** -Changed #include order so that<assert.h> is included in sysdep.h, **  and sysdep is included in all other files. This lets you define **  NDEBUG in sysdep.h to disable assertions if you want to. ** -Make PC specific system dependent code conditional on _M_IX86 **  defined so that ports can coexist in sysdep.h/sysdep.c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"sysdep.h"
include|#
directive|include
file|<limits.h>
comment|/* UCHAR_MAX */
comment|/* ** Forward declarations... read on. */
struct_decl|struct
name|ficl_word
struct_decl|;
struct_decl|struct
name|vm
struct_decl|;
struct_decl|struct
name|ficl_dict
struct_decl|;
comment|/*  ** the Good Stuff starts here... */
define|#
directive|define
name|FICL_VER
value|"2.02"
ifdef|#
directive|ifdef
name|TESTMAIN
define|#
directive|define
name|FICL_PROMPT
value|"ok> "
else|#
directive|else
define|#
directive|define
name|FICL_PROMPT
value|""
endif|#
directive|endif
comment|/* ** ANS Forth requires false to be zero, and true to be the ones ** complement of false... that unifies logical and bitwise operations ** nicely. */
define|#
directive|define
name|FICL_TRUE
value|(0xffffffffL)
define|#
directive|define
name|FICL_FALSE
value|(0)
define|#
directive|define
name|FICL_BOOL
parameter_list|(
name|x
parameter_list|)
value|((x) ? FICL_TRUE : FICL_FALSE)
comment|/* ** A CELL is the main storage type. It must be large enough ** to contain a pointer or a scalar. Let's be picky and make ** a 32 bit cell explicitly... */
typedef|typedef
union|union
name|_cell
block|{
name|INT32
name|i
decl_stmt|;
name|UNS32
name|u
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|}
name|CELL
typedef|;
comment|/* ** LVALUEtoCELL does a little pointer trickery to cast any 32 bit ** lvalue (informal definition: an expression whose result has an ** address) to CELL. Remember that constants and casts are NOT ** themselves lvalues! */
define|#
directive|define
name|LVALUEtoCELL
parameter_list|(
name|v
parameter_list|)
value|(*(CELL *)&v)
comment|/* ** PTRtoCELL is a cast through void * intended to satisfy the ** most outrageously pedantic compiler... (I won't mention  ** its name) */
define|#
directive|define
name|PTRtoCELL
value|(CELL *)(void *)
define|#
directive|define
name|PTRtoSTRING
value|(FICL_STRING *)(void *)
comment|/* ** Strings in FICL are stored in Pascal style - with a count ** preceding the text. We'll also NULL-terminate them so that  ** they work with the usual C lib string functions. (Belt& ** suspenders? You decide.) ** STRINGINFO hides the implementation with a couple of ** macros for use in internal routines. */
typedef|typedef
name|unsigned
name|char
name|FICL_COUNT
typedef|;
define|#
directive|define
name|FICL_STRING_MAX
value|UCHAR_MAX
typedef|typedef
struct|struct
name|_ficl_string
block|{
name|FICL_COUNT
name|count
decl_stmt|;
name|char
name|text
index|[
literal|1
index|]
decl_stmt|;
block|}
name|FICL_STRING
typedef|;
typedef|typedef
struct|struct
block|{
name|UNS32
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|}
name|STRINGINFO
typedef|;
define|#
directive|define
name|SI_COUNT
parameter_list|(
name|si
parameter_list|)
value|(si.count)
define|#
directive|define
name|SI_PTR
parameter_list|(
name|si
parameter_list|)
value|(si.cp)
define|#
directive|define
name|SI_SETLEN
parameter_list|(
name|si
parameter_list|,
name|len
parameter_list|)
value|(si.count = (UNS32)(len))
define|#
directive|define
name|SI_SETPTR
parameter_list|(
name|si
parameter_list|,
name|ptr
parameter_list|)
value|(si.cp = (char *)(ptr))
comment|/*  ** Init a STRINGINFO from a pointer to NULL-terminated string */
define|#
directive|define
name|SI_PSZ
parameter_list|(
name|si
parameter_list|,
name|psz
parameter_list|)
define|\
value|{si.cp = psz; si.count = (FICL_COUNT)strlen(psz);}
comment|/*  ** Init a STRINGINFO from a pointer to FICL_STRING */
define|#
directive|define
name|SI_PFS
parameter_list|(
name|si
parameter_list|,
name|pfs
parameter_list|)
define|\
value|{si.cp = pfs->text; si.count = pfs->count;}
comment|/* ** Ficl uses a this little structure to hold the address of  ** the block of text it's working on and an index to the next ** unconsumed character in the string. Traditionally, this is ** done by a Text Input Buffer, so I've called this struct TIB. */
typedef|typedef
struct|struct
block|{
name|INT32
name|index
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|}
name|TIB
typedef|;
comment|/* ** Stacks get heavy use in Ficl and Forth... ** Each virtual machine implements two of them: ** one holds parameters (data), and the other holds return ** addresses and control flow information for the virtual ** machine. (Note: C's automatic stack is implicitly used, ** but not modeled because it doesn't need to be...) ** Here's an abstract type for a stack */
typedef|typedef
struct|struct
name|_ficlStack
block|{
name|UNS32
name|nCells
decl_stmt|;
comment|/* size of the stack */
name|CELL
modifier|*
name|pFrame
decl_stmt|;
comment|/* link reg for stack frame */
name|CELL
modifier|*
name|sp
decl_stmt|;
comment|/* stack pointer */
name|CELL
name|base
index|[
literal|1
index|]
decl_stmt|;
comment|/* Bottom of the stack */
block|}
name|FICL_STACK
typedef|;
comment|/* ** Stack methods... many map closely to required Forth words. */
name|FICL_STACK
modifier|*
name|stackCreate
parameter_list|(
name|unsigned
name|nCells
parameter_list|)
function_decl|;
name|void
name|stackDelete
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|int
name|stackDepth
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackDrop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackFetch
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackGetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackLink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|nCells
parameter_list|)
function_decl|;
name|void
name|stackPick
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackPop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
modifier|*
name|stackPopPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|UNS32
name|stackPopUNS32
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|INT32
name|stackPopINT32
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackPush
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackPushPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|void
name|stackPushUNS32
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|UNS32
name|u
parameter_list|)
function_decl|;
name|void
name|stackPushINT32
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|INT32
name|i
parameter_list|)
function_decl|;
name|void
name|stackReset
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackRoll
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|void
name|stackSetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackStore
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackUnlink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
comment|/*  ** The virtual machine (VM) contains the state for one interpreter. ** Defined operations include: ** Create& initialize ** Delete ** Execute a block of text ** Parse a word out of the input stream ** Call return, and branch  ** Text output ** Throw an exception */
typedef|typedef
name|struct
name|ficl_word
modifier|*
modifier|*
name|IPTYPE
typedef|;
comment|/* the VM's instruction pointer */
comment|/* ** Each VM has a placeholder for an output function - ** this makes it possible to have each VM do I/O ** through a different device. If you specify no ** OUTFUNC, it defaults to ficlTextOut. */
typedef|typedef
name|void
function_decl|(
modifier|*
name|OUTFUNC
function_decl|)
parameter_list|(
name|struct
name|vm
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
function_decl|;
comment|/* ** Each VM operates in one of two non-error states: interpreting ** or compiling. When interpreting, words are simply executed. ** When compiling, most words in the input stream have their ** addresses inserted into the word under construction. Some words ** (known as IMMEDIATE) are executed in the compile state, too. */
comment|/* values of STATE */
define|#
directive|define
name|INTERPRET
value|0
define|#
directive|define
name|COMPILE
value|1
comment|/* ** The pad is a small scratch area for text manipulation. ANS Forth ** requires it to hold at least 84 characters. */
if|#
directive|if
operator|!
name|defined
name|nPAD
define|#
directive|define
name|nPAD
value|256
endif|#
directive|endif
comment|/*  ** ANS Forth requires that a word's name contain {1..31} characters. */
if|#
directive|if
operator|!
name|defined
name|nFICLNAME
define|#
directive|define
name|nFICLNAME
value|31
endif|#
directive|endif
comment|/* ** OK - now we can really define the VM... */
typedef|typedef
struct|struct
name|vm
block|{
name|struct
name|vm
modifier|*
name|link
decl_stmt|;
comment|/* Ficl keeps a VM list for simple teardown */
name|jmp_buf
modifier|*
name|pState
decl_stmt|;
comment|/* crude exception mechanism...     */
name|OUTFUNC
name|textOut
decl_stmt|;
comment|/* Output callback - see sysdep.c   */
name|void
modifier|*
name|pExtend
decl_stmt|;
comment|/* vm extension pointer             */
name|short
name|fRestart
decl_stmt|;
comment|/* Set TRUE to restart runningWord  */
name|IPTYPE
name|ip
decl_stmt|;
comment|/* instruction pointer              */
name|struct
name|ficl_word
modifier|*
name|runningWord
decl_stmt|;
comment|/* address of currently running word (often just *(ip-1) ) */
name|UNS32
name|state
decl_stmt|;
comment|/* compiling or interpreting        */
name|UNS32
name|base
decl_stmt|;
comment|/* number conversion base           */
name|FICL_STACK
modifier|*
name|pStack
decl_stmt|;
comment|/* param stack                      */
name|FICL_STACK
modifier|*
name|rStack
decl_stmt|;
comment|/* return stack                     */
name|CELL
name|sourceID
decl_stmt|;
comment|/* -1 if string, 0 if normal input  */
name|TIB
name|tib
decl_stmt|;
comment|/* address of incoming text string  */
if|#
directive|if
name|FICL_WANT_USER
name|CELL
name|user
index|[
name|FICL_USER_CELLS
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|pad
index|[
name|nPAD
index|]
decl_stmt|;
comment|/* the scratch area (see above)     */
block|}
name|FICL_VM
typedef|;
comment|/* ** A FICL_CODE points to a function that gets called to help execute ** a word in the dictionary. It always gets passed a pointer to the ** running virtual machine, and from there it can get the address ** of the parameter area of the word it's supposed to operate on. ** For precompiled words, the code is all there is. For user defined ** words, the code assumes that the word's parameter area is a list ** of pointers to the code fields of other words to execute, and ** may also contain inline data. The first parameter is always ** a pointer to a code field. */
typedef|typedef
name|void
function_decl|(
modifier|*
name|FICL_CODE
function_decl|)
parameter_list|(
name|FICL_VM
modifier|*
name|pVm
parameter_list|)
function_decl|;
comment|/*  ** Ficl models memory as a contiguous space divided into ** words in a linked list called the dictionary. ** A FICL_WORD starts each entry in the list. ** Version 1.02: space for the name characters is allotted from ** the dictionary ahead of the word struct - this saves about half  ** the storage on average with very little runtime cost. */
typedef|typedef
struct|struct
name|ficl_word
block|{
name|struct
name|ficl_word
modifier|*
name|link
decl_stmt|;
comment|/* Previous word in the dictionary      */
name|UNS16
name|hash
decl_stmt|;
name|UNS8
name|flags
decl_stmt|;
comment|/* Immediate, Smudge, Compile-only      */
name|FICL_COUNT
name|nName
decl_stmt|;
comment|/* Number of chars in word name         */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* First nFICLNAME chars of word name   */
name|FICL_CODE
name|code
decl_stmt|;
comment|/* Native code to execute the word      */
name|CELL
name|param
index|[
literal|1
index|]
decl_stmt|;
comment|/* First data cell of the word          */
block|}
name|FICL_WORD
typedef|;
comment|/* ** Worst-case size of a word header: nFICLNAME chars in name */
define|#
directive|define
name|CELLS_PER_WORD
define|\
value|( (sizeof (FICL_WORD) + nFICLNAME + sizeof (CELL)) \                           / (sizeof (CELL)) )
name|int
name|wordIsImmediate
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
name|int
name|wordIsCompileOnly
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
comment|/* flag values for word header */
define|#
directive|define
name|FW_IMMEDIATE
value|1
comment|/* execute me even if compiling */
define|#
directive|define
name|FW_COMPILE
value|2
comment|/* error if executed when not compiling */
define|#
directive|define
name|FW_SMUDGE
value|4
comment|/* definition in progress - hide me */
define|#
directive|define
name|FW_CLASS
value|8
comment|/* Word defines a class */
define|#
directive|define
name|FW_COMPIMMED
value|(FW_IMMEDIATE | FW_COMPILE)
define|#
directive|define
name|FW_DEFAULT
value|0
comment|/* ** Exit codes for vmThrow */
define|#
directive|define
name|VM_OUTOFTEXT
value|1
comment|/* hungry - normal exit */
define|#
directive|define
name|VM_RESTART
value|2
comment|/* word needs more text to suxcceed - re-run it */
define|#
directive|define
name|VM_USEREXIT
value|3
comment|/* user wants to quit */
define|#
directive|define
name|VM_ERREXIT
value|4
comment|/* interp found an error */
define|#
directive|define
name|VM_QUIT
value|5
comment|/* like errexit, but leave pStack& base alone */
name|void
name|vmBranchRelative
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
name|FICL_VM
modifier|*
name|vmCreate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|unsigned
name|nPStack
parameter_list|,
name|unsigned
name|nRStack
parameter_list|)
function_decl|;
name|void
name|vmDelete
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmExecute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
function_decl|;
name|char
modifier|*
name|vmGetString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_STRING
modifier|*
name|spDest
parameter_list|,
name|char
name|delimiter
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmGetWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmGetWord0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|int
name|vmGetWordToPad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmParseString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delimiter
parameter_list|)
function_decl|;
name|void
name|vmPopIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmPushIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|IPTYPE
name|newIP
parameter_list|)
function_decl|;
name|void
name|vmQuit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmReset
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmSetTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|OUTFUNC
name|textOut
parameter_list|)
function_decl|;
name|void
name|vmTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
function_decl|;
name|void
name|vmThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|except
parameter_list|)
function_decl|;
name|void
name|vmThrowErr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* ** vmCheckStack needs a vm pointer because it might have to say ** something if it finds a problem. Parms popCells and pushCells ** correspond to the number of parameters on the left and right of  ** a word's stack effect comment. */
name|void
name|vmCheckStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|popCells
parameter_list|,
name|int
name|pushCells
parameter_list|)
function_decl|;
comment|/* ** TIB access routines... ** ANS forth seems to require the input buffer to be represented  ** as a pointer to the start of the buffer, and an index to the ** next character to read. ** PushTib points the VM to a new input string and optionally **  returns a copy of the current state ** PopTib restores the TIB state given a saved TIB from PushTib ** GetInBuf returns a pointer to the next unused char of the TIB */
name|void
name|vmPushTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|TIB
modifier|*
name|pSaveTib
parameter_list|)
function_decl|;
name|void
name|vmPopTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|TIB
modifier|*
name|pTib
parameter_list|)
function_decl|;
define|#
directive|define
name|vmGetInBuf
parameter_list|(
name|pVM
parameter_list|)
value|((pVM)->tib.cp + (pVM)->tib.index)
define|#
directive|define
name|vmSetTibIndex
parameter_list|(
name|pVM
parameter_list|,
name|i
parameter_list|)
value|(pVM)->tib.index = i
define|#
directive|define
name|vmUpdateTib
parameter_list|(
name|pVM
parameter_list|,
name|str
parameter_list|)
value|(pVM)->tib.index = (str) - (pVM)->tib.cp
comment|/* ** Generally useful string manipulators omitted by ANSI C... ** ltoa complements strtol */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|FICL_MAIN
comment|/* #SHEESH ** Why do Microsoft Meatballs insist on contaminating ** my namespace with their string functions??? */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4273
name|)
endif|#
directive|endif
name|char
modifier|*
name|ltoa
parameter_list|(
name|INT32
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|char
modifier|*
name|ultoa
parameter_list|(
name|UNS32
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|char
name|digit_to_char
parameter_list|(
name|int
name|value
parameter_list|)
function_decl|;
name|char
modifier|*
name|strrev
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
name|char
modifier|*
name|skipSpace
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
name|char
modifier|*
name|caseFold
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
name|int
name|strincmp
parameter_list|(
name|char
modifier|*
name|cp1
parameter_list|,
name|char
modifier|*
name|cp2
parameter_list|,
name|FICL_COUNT
name|count
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|FICL_MAIN
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4273
name|)
endif|#
directive|endif
comment|/* ** Ficl hash table - variable size. ** assert(size> 0) ** If size is 1, the table degenerates into a linked list. ** A WORDLIST (see the search order word set in DPANS) is ** just a pointer to a FICL_HASH in this implementation. */
if|#
directive|if
operator|!
name|defined
name|HASHSIZE
comment|/* Default size of hash table. For best */
define|#
directive|define
name|HASHSIZE
value|127
comment|/*   performance, use a prime number!   */
endif|#
directive|endif
typedef|typedef
struct|struct
name|ficl_hash
block|{
name|struct
name|ficl_hash
modifier|*
name|link
decl_stmt|;
comment|/* eventual inheritance support */
name|unsigned
name|size
decl_stmt|;
name|FICL_WORD
modifier|*
name|table
index|[
literal|1
index|]
decl_stmt|;
block|}
name|FICL_HASH
typedef|;
name|void
name|hashForget
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
function_decl|;
name|UNS16
name|hashHashCode
parameter_list|(
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
name|void
name|hashInsertWord
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|hashLookup
parameter_list|(
name|struct
name|ficl_hash
modifier|*
name|pHash
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|UNS16
name|hashCode
parameter_list|)
function_decl|;
name|void
name|hashReset
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|)
function_decl|;
comment|/* ** A Dictionary is a linked list of FICL_WORDs. It is also Ficl's ** memory model. Description of fields: ** ** here -- points to the next free byte in the dictionary. This **      pointer is forced to be CELL-aligned before a definition is added. **      Do not assume any specific alignment otherwise - Use dictAlign(). ** ** smudge -- pointer to word currently being defined (or last defined word) **      If the definition completes successfully, the word will be **      linked into the hash table. If unsuccessful, dictUnsmudge **      uses this pointer to restore the previous state of the dictionary. **      Smudge prevents unintentional recursion as a side-effect: the **      dictionary search algo examines only completed definitions, so a  **      word cannot invoke itself by name. See the ficl word "recurse". **      NOTE: smudge always points to the last word defined. IMMEDIATE **      makes use of this fact. Smudge is initially NULL. ** ** pForthWords -- pointer to the default wordlist (FICL_HASH). **      This is the initial compilation list, and contains all **      ficl's precompiled words. ** ** pCompile -- compilation wordlist - initially equal to pForthWords ** pSearch  -- array of pointers to wordlists. Managed as a stack. **      Highest index is the first list in the search order. ** nLists   -- number of lists in pSearch. nLists-1 is the highest  **      filled slot in pSearch, and points to the first wordlist **      in the search order ** size -- number of cells in the dictionary (total) ** dict -- start of data area. Must be at the end of the struct. */
typedef|typedef
struct|struct
name|ficl_dict
block|{
name|CELL
modifier|*
name|here
decl_stmt|;
name|FICL_WORD
modifier|*
name|smudge
decl_stmt|;
name|FICL_HASH
modifier|*
name|pForthWords
decl_stmt|;
name|FICL_HASH
modifier|*
name|pCompile
decl_stmt|;
name|FICL_HASH
modifier|*
name|pSearch
index|[
name|FICL_DEFAULT_VOCS
index|]
decl_stmt|;
name|int
name|nLists
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
comment|/* Number of cells in dict (total)*/
name|CELL
name|dict
index|[
literal|1
index|]
decl_stmt|;
comment|/* Base of dictionary memory      */
block|}
name|FICL_DICT
typedef|;
name|void
modifier|*
name|alignPtr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|void
name|dictAbortDefinition
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictAlign
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|int
name|dictAllot
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|dictAllotCells
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|nCells
parameter_list|)
function_decl|;
name|void
name|dictAppendCell
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|dictAppendChar
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictAppendWord
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictAppendWord2
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
function_decl|;
name|void
name|dictAppendUNS32
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|UNS32
name|u
parameter_list|)
function_decl|;
name|int
name|dictCellsAvail
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|int
name|dictCellsUsed
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictCheck
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|nCells
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|dictCreate
parameter_list|(
name|unsigned
name|nCELLS
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|dictCreateHashed
parameter_list|(
name|unsigned
name|nCells
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
function_decl|;
name|void
name|dictDelete
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictEmpty
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
function_decl|;
name|void
name|dictHashSummary
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|int
name|dictIncludes
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictLookup
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|FICL_WORD
modifier|*
name|dictLookupLoc
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|dictResetSearchOrder
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictSetFlags
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|UNS8
name|set
parameter_list|,
name|UNS8
name|clr
parameter_list|)
function_decl|;
name|void
name|dictSetImmediate
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictUnsmudge
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|CELL
modifier|*
name|dictWhere
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
comment|/* ** External interface to FICL... */
comment|/*  ** f i c l I n i t S y s t e m ** Binds a global dictionary to the interpreter system and initializes ** the dict to contain the ANSI CORE wordset.  ** You specify the address and size of the allocated area. ** After that, ficl manages it. ** First step is to set up the static pointers to the area. ** Then write the "precompiled" portion of the dictionary in. ** The dictionary needs to be at least large enough to hold the ** precompiled part. Try 1K cells minimum. Use "words" to find ** out how much of the dictionary is used at any time. */
name|void
name|ficlInitSystem
parameter_list|(
name|int
name|nDictCells
parameter_list|)
function_decl|;
comment|/* ** f i c l T e r m S y s t e m ** Deletes the system dictionary and all virtual machines that ** were created with ficlNewVM (see below). Call this function to ** reclaim all memory used by the dictionary and VMs. */
name|void
name|ficlTermSystem
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* ** f i c l E x e c ** Evaluates a block of input text in the context of the ** specified interpreter. Emits any requested output to the ** interpreter's output function ** Execution returns when the text block has been executed, ** or an error occurs. ** Returns one of the VM_XXXX codes defined in ficl.h: ** VM_OUTOFTEXT is the normal exit condition ** VM_ERREXIT means that the interp encountered a syntax error **      and the vm has been reset to recover (some or all **      of the text block got ignored ** VM_USEREXIT means that the user executed the "bye" command **      to shut down the interpreter. This would be a good **      time to delete the vm, etc -- or you can ignore this **      signal. ** Preconditions: successful execution of ficlInitSystem, **      Successful creation and init of the VM by ficlNewVM (or equiv) */
name|int
name|ficlExec
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
function_decl|;
comment|/* ** Create a new VM from the heap, and link it into the system VM list. ** Initializes the VM and binds default sized stacks to it. Returns the ** address of the VM, or NULL if an error occurs. ** Precondition: successful execution of ficlInitSystem */
name|FICL_VM
modifier|*
name|ficlNewVM
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* ** Returns the address of the most recently defined word in the system ** dictionary with the given name, or NULL if no match. ** Precondition: successful execution of ficlInitSystem */
name|FICL_WORD
modifier|*
name|ficlLookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* ** f i c l G e t D i c t ** Utility function - returns the address of the system dictionary. ** Precondition: successful execution of ficlInitSystem */
name|FICL_DICT
modifier|*
name|ficlGetDict
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|ficlGetEnv
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|ficlSetEnv
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|UNS32
name|value
parameter_list|)
function_decl|;
name|void
name|ficlSetEnvD
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|UNS32
name|hi
parameter_list|,
name|UNS32
name|lo
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|FICL_DICT
modifier|*
name|ficlGetLoc
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  ** f i c l B u i l d ** Builds a word into the system default dictionary in a thread-safe way. ** Preconditions: system must be initialized, and there must ** be enough space for the new word's header! Operation is ** controlled by ficlLockDictionary, so any initialization ** required by your version of the function (if you "overrode" ** it) must be complete at this point. ** Parameters: ** name  -- the name of the word to be built ** code  -- code to execute when the word is invoked - must take a single param **          pointer to a FICL_VM ** flags -- 0 or more of FW_IMMEDIATE, FW_COMPILE, use bitwise OR!  **          Most words can use FW_DEFAULT. ** nAllot - number of extra cells to allocate in the parameter area (usually zero) */
name|int
name|ficlBuild
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|code
parameter_list|,
name|char
name|flags
parameter_list|)
function_decl|;
comment|/*  ** f i c l C o m p i l e C o r e ** Builds the ANS CORE wordset into the dictionary - called by ** ficlInitSystem - no need to waste dict space by doing it again. */
name|void
name|ficlCompileCore
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|)
function_decl|;
name|void
name|ficlCompileSoftCore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
comment|/* ** from words.c... */
name|void
name|constantParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|twoConstParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FICL_H__ */
end_comment

end_unit

