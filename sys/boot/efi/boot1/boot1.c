begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Robert Nordier  * All rights reserved.  * Copyright (c) 2001 Robert Drehmel  * All rights reserved.  * Copyright (c) 2014 Nathan Whitehorn  * All rights reserved.  * Copyright (c) 2015 Eric McCorkle  * All rights reserved.  *  * Redistribution and use in source and binary forms are freely  * permitted provided that the above copyright notice and this  * paragraph and the following disclaimer are duplicated in all  * such forms.  *  * This software is provided "AS IS" and without any express or  * implied warranties, including, without limitation, the implied  * warranties of merchantability and fitness for a particular  * purpose.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<disk.h>
end_include

begin_include
include|#
directive|include
file|<efi.h>
end_include

begin_include
include|#
directive|include
file|<efilib.h>
end_include

begin_include
include|#
directive|include
file|<efiprot.h>
end_include

begin_include
include|#
directive|include
file|<eficonsctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
end_ifdef

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|CHAR16
name|efi_char
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<efichar.h>
end_include

begin_include
include|#
directive|include
file|<bootstrap.h>
end_include

begin_include
include|#
directive|include
file|"efi_drivers.h"
end_include

begin_include
include|#
directive|include
file|"efizfs.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|efi_panic
argument_list|(
name|EFI_STATUS
name|s
argument_list|,
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|__dead2
name|__printflike
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EFI_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt, ##args)
end_define

begin_define
define|#
directive|define
name|DSTALL
parameter_list|(
name|d
parameter_list|)
value|BS->Stall(d)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|{}
end_define

begin_define
define|#
directive|define
name|DSTALL
parameter_list|(
name|d
parameter_list|)
value|{}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|arch_switch
name|archsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MI/MD interface boundary */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|efi_driver_t
modifier|*
name|efi_drivers
index|[]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|efi_console
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|console
name|comconsole
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|nullconsole
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
end_ifdef

begin_decl_stmt
name|uint64_t
name|pool_guid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|fs_ops
modifier|*
name|file_system
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
operator|&
name|zfs_fsops
block|,
endif|#
directive|endif
operator|&
name|dosfs_fsops
block|,
ifdef|#
directive|ifdef
name|EFI_UFS_BOOT
operator|&
name|ufs_fsops
block|,
endif|#
directive|endif
operator|&
name|cd9660_fsops
block|,
operator|&
name|nfs_fsops
block|,
operator|&
name|gzipfs_fsops
block|,
operator|&
name|bzipfs_fsops
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|devsw
modifier|*
name|devsw
index|[]
init|=
block|{
operator|&
name|efipart_hddev
block|,
operator|&
name|efipart_fddev
block|,
operator|&
name|efipart_cddev
block|,
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
operator|&
name|zfs_dev
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|console
modifier|*
name|consoles
index|[]
init|=
block|{
operator|&
name|efi_console
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EFI_LOADED_IMAGE
modifier|*
name|boot_image
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EFI_DEVICE_PATH
modifier|*
name|imgpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EFI_DEVICE_PATH
modifier|*
name|imgprefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definitions we don't actually need for boot, but we need to define  * to make the linker happy.  */
end_comment

begin_decl_stmt
name|struct
name|file_format
modifier|*
name|file_formats
index|[]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netif_driver
modifier|*
name|netif_drivers
index|[]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|efi_autoload
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"******** Boot block should not call autoload\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|efi_copyin
parameter_list|(
specifier|const
name|void
modifier|*
name|src
name|__unused
parameter_list|,
name|vm_offset_t
name|dest
name|__unused
parameter_list|,
specifier|const
name|size_t
name|len
name|__unused
parameter_list|)
block|{
name|printf
argument_list|(
literal|"******** Boot block should not call copyin\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|efi_copyout
parameter_list|(
name|vm_offset_t
name|src
name|__unused
parameter_list|,
name|void
modifier|*
name|dest
name|__unused
parameter_list|,
specifier|const
name|size_t
name|len
name|__unused
parameter_list|)
block|{
name|printf
argument_list|(
literal|"******** Boot block should not call copyout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|efi_readin
parameter_list|(
name|int
name|fd
name|__unused
parameter_list|,
name|vm_offset_t
name|dest
name|__unused
parameter_list|,
specifier|const
name|size_t
name|len
name|__unused
parameter_list|)
block|{
name|printf
argument_list|(
literal|"******** Boot block should not call readin\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The initial number of handles used to query EFI for partitions. */
end_comment

begin_define
define|#
directive|define
name|NUM_HANDLES_INIT
value|24
end_define

begin_decl_stmt
specifier|static
name|EFI_GUID
name|DevicePathGUID
init|=
name|DEVICE_PATH_PROTOCOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EFI_GUID
name|LoadedImageGUID
init|=
name|LOADED_IMAGE_PROTOCOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EFI_GUID
name|FreeBSDBootVarGUID
init|=
name|FREEBSD_BOOT_VAR_GUID
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|EFI_STATUS
name|do_load
parameter_list|(
specifier|const
name|char
modifier|*
name|filepath
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|bufsize
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|size_t
name|fsize
decl_stmt|,
name|remaining
decl_stmt|;
name|ssize_t
name|readsize
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filepath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|close_file
goto|;
block|}
name|fsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|fsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|close_file
goto|;
block|}
name|remaining
operator|=
name|fsize
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|readsize
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|fsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
operator|(
operator|-
name|readsize
operator|)
expr_stmt|;
goto|goto
name|free_buf
goto|;
block|}
name|remaining
operator|-=
name|readsize
expr_stmt|;
block|}
do|while
condition|(
name|remaining
operator|!=
literal|0
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|bufsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
name|close_file
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|errno_to_efi_status
argument_list|(
name|err
argument_list|)
return|;
name|free_buf
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|close_file
goto|;
block|}
end_function

begin_function
specifier|static
name|EFI_STATUS
name|efi_setenv_freebsd_wcs
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|,
name|CHAR16
modifier|*
name|valstr
parameter_list|)
block|{
name|CHAR16
modifier|*
name|var
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|EFI_STATUS
name|rv
decl_stmt|;
name|utf8_to_ucs2
argument_list|(
name|varname
argument_list|,
operator|&
name|var
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFI_OUT_OF_RESOURCES
operator|)
return|;
name|rv
operator|=
name|RS
operator|->
name|SetVariable
argument_list|(
name|var
argument_list|,
operator|&
name|FreeBSDBootVarGUID
argument_list|,
name|EFI_VARIABLE_BOOTSERVICE_ACCESS
operator||
name|EFI_VARIABLE_RUNTIME_ACCESS
argument_list|,
operator|(
name|ucs2len
argument_list|(
name|valstr
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|efi_char
argument_list|)
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|probe_fs
parameter_list|(
specifier|const
name|char
modifier|*
name|filepath
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filepath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|probe_dev
parameter_list|(
name|struct
name|devsw
modifier|*
name|dev
parameter_list|,
name|int
name|unit
parameter_list|,
specifier|const
name|char
modifier|*
name|filepath
parameter_list|)
block|{
name|struct
name|devdesc
name|currdev
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|;
name|int
name|err
decl_stmt|;
name|currdev
operator|.
name|d_dev
operator|=
name|dev
expr_stmt|;
name|currdev
operator|.
name|d_type
operator|=
name|currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
name|currdev
operator|.
name|d_unit
operator|=
name|unit
expr_stmt|;
name|currdev
operator|.
name|d_opendata
operator|=
name|NULL
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|err
operator|=
name|probe_fs
argument_list|(
name|filepath
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|check_preferred
parameter_list|(
name|EFI_HANDLE
modifier|*
name|h
parameter_list|)
block|{
name|EFI_DEVICE_PATH
modifier|*
name|path
init|=
name|efi_lookup_devpath
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|bool
name|out
decl_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|efi_lookup_devpath
argument_list|(
name|h
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|out
operator|=
name|efi_devpath_is_prefix
argument_list|(
name|imgpath
argument_list|,
name|path
argument_list|)
operator|||
name|efi_devpath_is_prefix
argument_list|(
name|imgprefix
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|efi_zfs_is_preferred
parameter_list|(
name|EFI_HANDLE
modifier|*
name|h
parameter_list|)
block|{
return|return
operator|(
name|check_preferred
argument_list|(
name|h
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_preferred
parameter_list|(
name|EFI_LOADED_IMAGE
modifier|*
name|img
parameter_list|,
specifier|const
name|char
modifier|*
name|filepath
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|bufsize
parameter_list|,
name|EFI_HANDLE
modifier|*
name|handlep
parameter_list|)
block|{
name|pdinfo_list_t
modifier|*
name|pdi_list
decl_stmt|;
name|pdinfo_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|;
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
comment|/* Did efi_zfs_probe() detect the boot pool? */
if|if
condition|(
name|pool_guid
operator|!=
literal|0
condition|)
block|{
name|struct
name|zfs_devdesc
name|currdev
decl_stmt|;
name|currdev
operator|.
name|d_dev
operator|=
operator|&
name|zfs_dev
expr_stmt|;
name|currdev
operator|.
name|d_unit
operator|=
literal|0
expr_stmt|;
name|currdev
operator|.
name|d_type
operator|=
name|currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
name|currdev
operator|.
name|d_opendata
operator|=
name|NULL
expr_stmt|;
name|currdev
operator|.
name|pool_guid
operator|=
name|pool_guid
expr_stmt|;
name|currdev
operator|.
name|root_guid
operator|=
literal|0
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|efizfs_get_handle_by_guid
argument_list|(
name|pool_guid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* EFI_ZFS_BOOT */
comment|/* We have device lists for hd, cd, fd, walk them all. */
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_hddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
name|struct
name|disk_devdesc
name|currdev
decl_stmt|;
name|currdev
operator|.
name|d_dev
operator|=
operator|&
name|efipart_hddev
expr_stmt|;
name|currdev
operator|.
name|d_type
operator|=
name|currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
name|currdev
operator|.
name|d_unit
operator|=
name|dp
operator|->
name|pd_unit
expr_stmt|;
name|currdev
operator|.
name|d_opendata
operator|=
name|NULL
expr_stmt|;
name|currdev
operator|.
name|d_slice
operator|=
operator|-
literal|1
expr_stmt|;
name|currdev
operator|.
name|d_partition
operator|=
operator|-
literal|1
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_preferred
argument_list|(
name|dp
operator|->
name|pd_handle
argument_list|)
operator|&&
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Assuming GPT partitioning. */
name|STAILQ_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&dp->pd_part
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|check_preferred
argument_list|(
name|pp
operator|->
name|pd_handle
argument_list|)
condition|)
block|{
name|currdev
operator|.
name|d_slice
operator|=
name|pp
operator|->
name|pd_unit
expr_stmt|;
name|currdev
operator|.
name|d_partition
operator|=
literal|255
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|pp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_cddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|pd_handle
operator|==
name|img
operator|->
name|DeviceHandle
operator|||
name|dp
operator|->
name|pd_alias
operator|==
name|img
operator|->
name|DeviceHandle
operator|||
name|check_preferred
argument_list|(
name|dp
operator|->
name|pd_handle
argument_list|)
operator|)
operator|&&
name|probe_dev
argument_list|(
operator|&
name|efipart_cddev
argument_list|,
name|dp
operator|->
name|pd_unit
argument_list|,
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_fddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|pd_handle
operator|==
name|img
operator|->
name|DeviceHandle
operator|||
name|check_preferred
argument_list|(
name|dp
operator|->
name|pd_handle
argument_list|)
operator|)
operator|&&
name|probe_dev
argument_list|(
operator|&
name|efipart_cddev
argument_list|,
name|dp
operator|->
name|pd_unit
argument_list|,
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_all
parameter_list|(
specifier|const
name|char
modifier|*
name|filepath
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|bufsize
parameter_list|,
name|EFI_HANDLE
modifier|*
name|handlep
parameter_list|)
block|{
name|pdinfo_list_t
modifier|*
name|pdi_list
decl_stmt|;
name|pdinfo_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|zfsinfo_list_t
modifier|*
name|zfsi_list
decl_stmt|;
name|zfsinfo_t
modifier|*
name|zi
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|;
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
name|zfsi_list
operator|=
name|efizfs_get_zfsinfo_list
argument_list|()
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|zi
argument_list|,
argument|zfsi_list
argument_list|,
argument|zi_link
argument_list|)
block|{
name|struct
name|zfs_devdesc
name|currdev
decl_stmt|;
name|currdev
operator|.
name|d_dev
operator|=
operator|&
name|zfs_dev
expr_stmt|;
name|currdev
operator|.
name|d_unit
operator|=
literal|0
expr_stmt|;
name|currdev
operator|.
name|d_type
operator|=
name|currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
name|currdev
operator|.
name|d_opendata
operator|=
name|NULL
expr_stmt|;
name|currdev
operator|.
name|pool_guid
operator|=
name|zi
operator|->
name|zi_pool_guid
expr_stmt|;
name|currdev
operator|.
name|root_guid
operator|=
literal|0
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|zi
operator|->
name|zi_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* EFI_ZFS_BOOT */
comment|/* We have device lists for hd, cd, fd, walk them all. */
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_hddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
name|struct
name|disk_devdesc
name|currdev
decl_stmt|;
name|currdev
operator|.
name|d_dev
operator|=
operator|&
name|efipart_hddev
expr_stmt|;
name|currdev
operator|.
name|d_type
operator|=
name|currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
name|currdev
operator|.
name|d_unit
operator|=
name|dp
operator|->
name|pd_unit
expr_stmt|;
name|currdev
operator|.
name|d_opendata
operator|=
name|NULL
expr_stmt|;
name|currdev
operator|.
name|d_slice
operator|=
operator|-
literal|1
expr_stmt|;
name|currdev
operator|.
name|d_partition
operator|=
operator|-
literal|1
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Assuming GPT partitioning. */
name|STAILQ_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&dp->pd_part
argument_list|,
argument|pd_link
argument_list|)
block|{
name|currdev
operator|.
name|d_slice
operator|=
name|pp
operator|->
name|pd_unit
expr_stmt|;
name|currdev
operator|.
name|d_partition
operator|=
literal|255
expr_stmt|;
name|devname
operator|=
name|efi_fmtdev
argument_list|(
operator|&
name|currdev
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|devname
argument_list|,
name|efi_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_fs
argument_list|(
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|pp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_cddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|probe_dev
argument_list|(
operator|&
name|efipart_cddev
argument_list|,
name|dp
operator|->
name|pd_unit
argument_list|,
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|pdi_list
operator|=
name|efiblk_get_pdinfo_list
argument_list|(
operator|&
name|efipart_fddev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|pdi_list
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|probe_dev
argument_list|(
operator|&
name|efipart_fddev
argument_list|,
name|dp
operator|->
name|pd_unit
argument_list|,
name|filepath
argument_list|)
operator|==
literal|0
operator|&&
name|do_load
argument_list|(
name|filepath
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|)
operator|==
name|EFI_SUCCESS
condition|)
block|{
operator|*
name|handlep
operator|=
name|dp
operator|->
name|pd_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|EFI_STATUS
name|load_loader
parameter_list|(
name|EFI_HANDLE
modifier|*
name|handlep
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|bufsize
parameter_list|)
block|{
comment|/* Try the preferred handles first, then all the handles */
if|if
condition|(
name|load_preferred
argument_list|(
name|boot_image
argument_list|,
name|PATH_LOADER_EFI
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|,
name|handlep
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|load_all
argument_list|(
name|PATH_LOADER_EFI
argument_list|,
name|bufp
argument_list|,
name|bufsize
argument_list|,
name|handlep
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EFI_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * try_boot only returns if it fails to load the loader. If it succeeds  * it simply boots, otherwise it returns the status of last EFI call.  */
end_comment

begin_function
specifier|static
name|EFI_STATUS
name|try_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|bufsize
decl_stmt|,
name|loadersize
decl_stmt|,
name|cmdsize
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|,
modifier|*
name|loaderbuf
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|EFI_HANDLE
name|fshandle
decl_stmt|;
name|EFI_HANDLE
name|loaderhandle
decl_stmt|;
name|EFI_LOADED_IMAGE
modifier|*
name|loaded_image
decl_stmt|;
name|EFI_STATUS
name|status
decl_stmt|;
name|EFI_DEVICE_PATH
modifier|*
name|fspath
decl_stmt|;
name|status
operator|=
name|load_loader
argument_list|(
operator|&
name|fshandle
argument_list|,
operator|&
name|loaderbuf
argument_list|,
operator|&
name|loadersize
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EFI_SUCCESS
condition|)
block|{
return|return
operator|(
name|status
operator|)
return|;
block|}
name|fspath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EFI_SUCCESS
condition|)
block|{
name|status
operator|=
name|BS
operator|->
name|OpenProtocol
argument_list|(
name|fshandle
argument_list|,
operator|&
name|DevicePathGUID
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fspath
argument_list|,
name|IH
argument_list|,
name|NULL
argument_list|,
name|EFI_OPEN_PROTOCOL_GET_PROTOCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Failed to get image DevicePath (%lu)\n"
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"filesystem device path: %s\n"
argument_list|,
name|devpath_str
argument_list|(
name|fspath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read in and parse the command line from /boot.config or /boot/config, 	 * if present. We'll pass it the next stage via a simple ASCII 	 * string. loader.efi has a hack for ASCII strings, so we'll use that to 	 * keep the size down here. We only try to read the alternate file if 	 * we get EFI_NOT_FOUND because all other errors mean that the boot_module 	 * had troubles with the filesystem. We could return early, but we'll let 	 * loading the actual kernel sort all that out. Since these files are 	 * optional, we don't report errors in trying to read them. 	 */
name|cmd
operator|=
name|NULL
expr_stmt|;
name|cmdsize
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|do_load
argument_list|(
name|PATH_DOTCONFIG
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EFI_NOT_FOUND
condition|)
name|status
operator|=
name|do_load
argument_list|(
name|PATH_CONFIG
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EFI_SUCCESS
condition|)
block|{
name|cmdsize
operator|=
name|bufsize
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|malloc
argument_list|(
name|cmdsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
goto|goto
name|errout
goto|;
name|memcpy
argument_list|(
name|cmd
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|cmd
index|[
name|bufsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|BS
operator|->
name|LoadImage
argument_list|(
name|TRUE
argument_list|,
name|IH
argument_list|,
name|efi_devpath_last_node
argument_list|(
name|fspath
argument_list|)
argument_list|,
name|loaderbuf
argument_list|,
name|loadersize
argument_list|,
operator|&
name|loaderhandle
argument_list|)
operator|)
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to load image, size: %zu, (%lu)\n"
argument_list|,
name|loadersize
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|BS
operator|->
name|OpenProtocol
argument_list|(
name|loaderhandle
argument_list|,
operator|&
name|LoadedImageGUID
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|loaded_image
argument_list|,
name|IH
argument_list|,
name|NULL
argument_list|,
name|EFI_OPEN_PROTOCOL_GET_PROTOCOL
argument_list|)
operator|)
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to query LoadedImage (%lu)\n"
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"    command args: %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|loaded_image
operator|->
name|DeviceHandle
operator|=
name|fshandle
expr_stmt|;
name|loaded_image
operator|->
name|LoadOptionsSize
operator|=
name|cmdsize
expr_stmt|;
name|loaded_image
operator|->
name|LoadOptions
operator|=
name|cmd
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Starting '%s' in 5 seconds..."
argument_list|,
name|PATH_LOADER_EFI
argument_list|)
expr_stmt|;
name|DSTALL
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|DSTALL
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|DSTALL
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|DSTALL
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|DSTALL
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|BS
operator|->
name|StartImage
argument_list|(
name|loaderhandle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to start image (%lu)\n"
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|loaded_image
operator|->
name|LoadOptionsSize
operator|=
literal|0
expr_stmt|;
name|loaded_image
operator|->
name|LoadOptions
operator|=
name|NULL
expr_stmt|;
block|}
name|errout
label|:
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|loaderbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|loaderbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|EFI_STATUS
name|main
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|CHAR16
modifier|*
name|argv
index|[]
name|__unused
parameter_list|)
block|{
name|EFI_STATUS
name|status
decl_stmt|;
name|SIMPLE_TEXT_OUTPUT_INTERFACE
modifier|*
name|conout
init|=
name|NULL
decl_stmt|;
name|UINTN
name|i
decl_stmt|,
name|max_dim
decl_stmt|,
name|best_mode
decl_stmt|,
name|cols
decl_stmt|,
name|rows
decl_stmt|;
name|CHAR16
modifier|*
name|text
decl_stmt|;
name|archsw
operator|.
name|arch_autoload
operator|=
name|efi_autoload
expr_stmt|;
name|archsw
operator|.
name|arch_getdev
operator|=
name|efi_getdev
expr_stmt|;
name|archsw
operator|.
name|arch_copyin
operator|=
name|efi_copyin
expr_stmt|;
name|archsw
operator|.
name|arch_copyout
operator|=
name|efi_copyout
expr_stmt|;
name|archsw
operator|.
name|arch_readin
operator|=
name|efi_readin
expr_stmt|;
ifdef|#
directive|ifdef
name|EFI_ZFS_BOOT
comment|/* Note this needs to be set before ZFS init. */
name|archsw
operator|.
name|arch_zfs_probe
operator|=
name|efi_zfs_probe
expr_stmt|;
endif|#
directive|endif
comment|/* Init the time source */
name|efi_time_init
argument_list|()
expr_stmt|;
name|cons_probe
argument_list|()
expr_stmt|;
comment|/* 	 * Reset the console and find the best text mode. 	 */
name|conout
operator|=
name|ST
operator|->
name|ConOut
expr_stmt|;
name|conout
operator|->
name|Reset
argument_list|(
name|conout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|max_dim
operator|=
name|best_mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|conout
operator|->
name|QueryMode
argument_list|(
name|conout
argument_list|,
name|i
argument_list|,
operator|&
name|cols
argument_list|,
operator|&
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cols
operator|*
name|rows
operator|>
name|max_dim
condition|)
block|{
name|max_dim
operator|=
name|cols
operator|*
name|rows
expr_stmt|;
name|best_mode
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max_dim
operator|>
literal|0
condition|)
name|conout
operator|->
name|SetMode
argument_list|(
name|conout
argument_list|,
name|best_mode
argument_list|)
expr_stmt|;
name|conout
operator|->
name|EnableCursor
argument_list|(
name|conout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|conout
operator|->
name|ClearScreen
argument_list|(
name|conout
argument_list|)
expr_stmt|;
comment|/* Print this here, so people know it's at least starting. */
name|printf
argument_list|(
literal|"\n>> FreeBSD EFI boot block\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Loader path: %s\n\n"
argument_list|,
name|PATH_LOADER_EFI
argument_list|)
expr_stmt|;
comment|/* Get the image path and trim it to get the disk on which we          * found this loader.          */
if|if
condition|(
operator|(
name|status
operator|=
name|BS
operator|->
name|OpenProtocol
argument_list|(
name|IH
argument_list|,
operator|&
name|LoadedImageGUID
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|boot_image
argument_list|,
name|IH
argument_list|,
name|NULL
argument_list|,
name|EFI_OPEN_PROTOCOL_GET_PROTOCOL
argument_list|)
operator|)
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|panic
argument_list|(
literal|"Failed to query LoadedImage (%lu)\n"
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the devpath of our image so we can prefer it. */
name|status
operator|=
name|BS
operator|->
name|HandleProtocol
argument_list|(
name|IH
argument_list|,
operator|&
name|LoadedImageGUID
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|boot_image
argument_list|)
expr_stmt|;
name|imgpath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EFI_SUCCESS
condition|)
block|{
name|text
operator|=
name|efi_devpath_name
argument_list|(
name|boot_image
operator|->
name|FilePath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Load Path: %S\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|efi_setenv_freebsd_wcs
argument_list|(
literal|"Boot1Path"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|efi_free_devpath_name
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|status
operator|=
name|BS
operator|->
name|HandleProtocol
argument_list|(
name|boot_image
operator|->
name|DeviceHandle
argument_list|,
operator|&
name|DevicePathGUID
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|imgpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EFI_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Failed to get image DevicePath (%lu)\n"
argument_list|,
name|EFI_ERROR_CODE
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|text
operator|=
name|efi_devpath_name
argument_list|(
name|imgpath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Load Device: %S\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|efi_setenv_freebsd_wcs
argument_list|(
literal|"Boot1Dev"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|efi_free_devpath_name
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The loaded image device path ends with a partition, then a          * file path.  Trim them both to get the actual disk.          */
if|if
condition|(
operator|(
name|imgprefix
operator|=
name|efi_devpath_trim
argument_list|(
name|imgpath
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|imgprefix
operator|=
name|efi_devpath_trim
argument_list|(
name|imgprefix
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Couldn't trim device path"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the block cache. Set the upper limit. 	 */
name|bcache_init
argument_list|(
literal|32768
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n   Initializing modules:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|efi_drivers
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|efi_drivers
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|efi_drivers
index|[
name|i
index|]
operator|->
name|init
operator|!=
name|NULL
condition|)
name|efi_drivers
index|[
name|i
index|]
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_init
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|devsw
index|[
name|i
index|]
operator|->
name|dv_name
argument_list|)
expr_stmt|;
operator|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_init
operator|)
operator|(
operator|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|try_boot
argument_list|()
expr_stmt|;
comment|/* If we get here, we're out of luck... */
name|efi_panic
argument_list|(
name|EFI_LOAD_ERROR
argument_list|,
literal|"No bootable partitions found!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * OK. We totally give up. Exit back to EFI with a sensible status so  * it can try the next option on the list.  */
end_comment

begin_function
specifier|static
name|void
name|efi_panic
parameter_list|(
name|EFI_STATUS
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|printf
argument_list|(
literal|"panic: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|BS
operator|->
name|Exit
argument_list|(
name|IH
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

