begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Allan Jude<allanjude@FreeBSD.org>  * Copyright (c) 2005-2011 Pawel Jakub Dawidek<pawel@dawidek.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"geliboot_internal.h"
end_include

begin_include
include|#
directive|include
file|"geliboot.h"
end_include

begin_macro
name|SLIST_HEAD
argument_list|(
argument|geli_list
argument_list|,
argument|geli_entry
argument_list|)
end_macro

begin_expr_stmt
name|geli_head
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|geli_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|geli_list
modifier|*
name|geli_headp
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|u_char
name|geli_ukey
index|[
name|G_ELI_USERKEYLEN
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|geli_ukey
name|saved_keys
index|[
name|GELI_MAX_KEYS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nsaved_keys
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copy keys from local storage to the keybuf struct.  * Destroy the local storage when finished.  */
end_comment

begin_function
name|void
name|geli_fill_keybuf
parameter_list|(
name|struct
name|keybuf
modifier|*
name|fkeybuf
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsaved_keys
condition|;
name|i
operator|++
control|)
block|{
name|fkeybuf
operator|->
name|kb_ents
index|[
name|i
index|]
operator|.
name|ke_type
operator|=
name|KEYBUF_TYPE_GELI
expr_stmt|;
name|memcpy
argument_list|(
name|fkeybuf
operator|->
name|kb_ents
index|[
name|i
index|]
operator|.
name|ke_data
argument_list|,
name|saved_keys
index|[
name|i
index|]
argument_list|,
name|G_ELI_USERKEYLEN
argument_list|)
expr_stmt|;
block|}
name|fkeybuf
operator|->
name|kb_nents
operator|=
name|nsaved_keys
expr_stmt|;
name|explicit_bzero
argument_list|(
name|saved_keys
argument_list|,
sizeof|sizeof
argument_list|(
name|saved_keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy keys from a keybuf struct into local storage.  * Zero out the keybuf.  */
end_comment

begin_function
name|void
name|geli_save_keybuf
parameter_list|(
name|struct
name|keybuf
modifier|*
name|skeybuf
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skeybuf
operator|->
name|kb_nents
operator|&&
name|i
operator|<
name|GELI_MAX_KEYS
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|saved_keys
index|[
name|i
index|]
argument_list|,
name|skeybuf
operator|->
name|kb_ents
index|[
name|i
index|]
operator|.
name|ke_data
argument_list|,
name|G_ELI_USERKEYLEN
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|skeybuf
operator|->
name|kb_ents
index|[
name|i
index|]
operator|.
name|ke_data
argument_list|,
name|G_ELI_USERKEYLEN
argument_list|)
expr_stmt|;
name|skeybuf
operator|->
name|kb_ents
index|[
name|i
index|]
operator|.
name|ke_type
operator|=
name|KEYBUF_TYPE_NONE
expr_stmt|;
block|}
name|nsaved_keys
operator|=
name|skeybuf
operator|->
name|kb_nents
expr_stmt|;
name|skeybuf
operator|->
name|kb_nents
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_key
parameter_list|(
name|geli_ukey
name|key
parameter_list|)
block|{
comment|/* 	 * If we run out of key space, the worst that will happen is 	 * it will ask the user for the password again. 	 */
if|if
condition|(
name|nsaved_keys
operator|<
name|GELI_MAX_KEYS
condition|)
block|{
name|memcpy
argument_list|(
name|saved_keys
index|[
name|nsaved_keys
index|]
argument_list|,
name|key
argument_list|,
name|G_ELI_USERKEYLEN
argument_list|)
expr_stmt|;
name|nsaved_keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|geli_same_device
parameter_list|(
name|struct
name|geli_entry
modifier|*
name|ge
parameter_list|,
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|)
block|{
if|if
condition|(
name|ge
operator|->
name|dsk
operator|->
name|drive
operator|==
name|dskp
operator|->
name|drive
operator|&&
name|dskp
operator|->
name|part
operator|==
literal|255
operator|&&
name|ge
operator|->
name|dsk
operator|->
name|part
operator|==
name|dskp
operator|->
name|slice
condition|)
block|{
comment|/* 		 * Sometimes slice = slice, and sometimes part = slice 		 * If the incoming struct dsk has part=255, it means look at 		 * the slice instead of the part number 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Is this the same device? */
if|if
condition|(
name|ge
operator|->
name|dsk
operator|->
name|drive
operator|!=
name|dskp
operator|->
name|drive
operator|||
name|ge
operator|->
name|dsk
operator|->
name|slice
operator|!=
name|dskp
operator|->
name|slice
operator|||
name|ge
operator|->
name|dsk
operator|->
name|part
operator|!=
name|dskp
operator|->
name|part
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|geli_findkey
parameter_list|(
name|struct
name|geli_entry
modifier|*
name|ge
parameter_list|,
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|,
name|u_char
modifier|*
name|mkey
parameter_list|)
block|{
name|u_int
name|keynum
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ge
operator|->
name|keybuf_slot
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|g_eli_mkey_decrypt
argument_list|(
operator|&
name|ge
operator|->
name|md
argument_list|,
name|saved_keys
index|[
name|ge
operator|->
name|keybuf_slot
index|]
argument_list|,
name|mkey
argument_list|,
operator|&
name|keynum
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsaved_keys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|g_eli_mkey_decrypt
argument_list|(
operator|&
name|ge
operator|->
name|md
argument_list|,
name|saved_keys
index|[
name|i
index|]
argument_list|,
name|mkey
argument_list|,
operator|&
name|keynum
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ge
operator|->
name|keybuf_slot
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|geli_init
parameter_list|(
name|void
parameter_list|)
block|{
name|geli_count
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|geli_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the last sector of the drive or partition pointed to by dsk and see  * if it is GELI encrypted  */
end_comment

begin_function
name|int
name|geli_taste
parameter_list|(
name|int
name|read_func
parameter_list|(
name|void
modifier|*
name|vdev
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|off_t
name|off
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|bytes
parameter_list|)
parameter_list|,
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|,
name|daddr_t
name|lastsector
parameter_list|)
block|{
name|struct
name|g_eli_metadata
name|md
decl_stmt|;
name|u_char
name|buf
index|[
name|DEV_GELIBOOT_BSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|alignsector
decl_stmt|;
name|alignsector
operator|=
name|rounddown2
argument_list|(
name|lastsector
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_GELIBOOT_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignsector
operator|+
name|DEV_GELIBOOT_BSIZE
operator|>
operator|(
operator|(
name|lastsector
operator|+
literal|1
operator|)
operator|*
name|DEV_BSIZE
operator|)
condition|)
block|{
comment|/* Don't read past the end of the disk */
name|alignsector
operator|=
operator|(
name|lastsector
operator|*
name|DEV_BSIZE
operator|)
operator|+
name|DEV_BSIZE
operator|-
name|DEV_GELIBOOT_BSIZE
expr_stmt|;
block|}
name|error
operator|=
name|read_func
argument_list|(
name|NULL
argument_list|,
name|dskp
argument_list|,
name|alignsector
argument_list|,
operator|&
name|buf
argument_list|,
name|DEV_GELIBOOT_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Extract the last 4k sector of the disk. */
name|error
operator|=
name|eli_metadata_decode
argument_list|(
name|buf
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Try the last 512 byte sector instead. */
name|error
operator|=
name|eli_metadata_decode
argument_list|(
name|buf
operator|+
operator|(
name|DEV_GELIBOOT_BSIZE
operator|-
name|DEV_BSIZE
operator|)
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|md
operator|.
name|md_flags
operator|&
name|G_ELI_FLAG_GELIBOOT
operator|)
condition|)
block|{
comment|/* The GELIBOOT feature is not activated */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|.
name|md_flags
operator|&
name|G_ELI_FLAG_ONETIME
operator|)
condition|)
block|{
comment|/* Swap device, skip it. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|.
name|md_iterations
operator|<
literal|0
condition|)
block|{
comment|/* XXX TODO: Support loading key files. */
comment|/* Disk does not have a passphrase, skip it. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|geli_e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|geli_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|geli_e
operator|==
name|NULL
condition|)
return|return
operator|(
literal|2
operator|)
return|;
name|geli_e
operator|->
name|dsk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|geli_e
operator|->
name|dsk
operator|==
name|NULL
condition|)
return|return
operator|(
literal|2
operator|)
return|;
name|memcpy
argument_list|(
name|geli_e
operator|->
name|dsk
argument_list|,
name|dskp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsk
argument_list|)
argument_list|)
expr_stmt|;
name|geli_e
operator|->
name|part_end
operator|=
name|lastsector
expr_stmt|;
if|if
condition|(
name|dskp
operator|->
name|part
operator|==
literal|255
condition|)
block|{
name|geli_e
operator|->
name|dsk
operator|->
name|part
operator|=
name|dskp
operator|->
name|slice
expr_stmt|;
block|}
name|geli_e
operator|->
name|keybuf_slot
operator|=
operator|-
literal|1
expr_stmt|;
name|geli_e
operator|->
name|md
operator|=
name|md
expr_stmt|;
name|eli_metadata_softc
argument_list|(
operator|&
name|geli_e
operator|->
name|sc
argument_list|,
operator|&
name|md
argument_list|,
name|DEV_BSIZE
argument_list|,
operator|(
name|lastsector
operator|+
name|DEV_BSIZE
operator|)
operator|*
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|geli_head
argument_list|,
name|geli_e
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|geli_count
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to decrypt the device  */
end_comment

begin_function
name|int
name|geli_attach
parameter_list|(
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
specifier|const
name|u_char
modifier|*
name|mkeyp
parameter_list|)
block|{
name|u_char
name|key
index|[
name|G_ELI_USERKEYLEN
index|]
decl_stmt|,
name|mkey
index|[
name|G_ELI_DATAIVKEYLEN
index|]
decl_stmt|,
modifier|*
name|mkp
decl_stmt|;
name|u_int
name|keynum
decl_stmt|;
name|struct
name|hmac_ctx
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mkeyp
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mkey
argument_list|,
name|mkeyp
argument_list|,
name|G_ELI_DATAIVKEYLEN
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|mkeyp
argument_list|,
name|G_ELI_DATAIVKEYLEN
argument_list|)
expr_stmt|;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|geli_e
argument_list|,
argument|&geli_head
argument_list|,
argument|entries
argument_list|,
argument|geli_e_tmp
argument_list|)
block|{
if|if
condition|(
name|geli_same_device
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|mkeyp
operator|!=
name|NULL
operator|||
name|geli_findkey
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|,
name|mkey
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|found_key
goto|;
block|}
name|g_eli_crypto_hmac_init
argument_list|(
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Prepare Derived-Key from the user passphrase. 		 */
if|if
condition|(
name|geli_e
operator|->
name|md
operator|.
name|md_iterations
operator|<
literal|0
condition|)
block|{
comment|/* XXX TODO: Support loading key files. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|geli_e
operator|->
name|md
operator|.
name|md_iterations
operator|==
literal|0
condition|)
block|{
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|geli_e
operator|->
name|md
operator|.
name|md_salt
argument_list|,
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|md
operator|.
name|md_salt
argument_list|)
argument_list|)
expr_stmt|;
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|geli_e
operator|->
name|md
operator|.
name|md_iterations
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Calculating GELI Decryption Key disk%dp%d @ %d"
literal|" iterations...\n"
argument_list|,
name|dskp
operator|->
name|unit
argument_list|,
operator|(
name|dskp
operator|->
name|slice
operator|>
literal|0
condition|?
name|dskp
operator|->
name|slice
else|:
name|dskp
operator|->
name|part
operator|)
argument_list|,
name|geli_e
operator|->
name|md
operator|.
name|md_iterations
argument_list|)
expr_stmt|;
name|u_char
name|dkey
index|[
name|G_ELI_USERKEYLEN
index|]
decl_stmt|;
name|pkcs5v2_genkey
argument_list|(
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|,
name|geli_e
operator|->
name|md
operator|.
name|md_salt
argument_list|,
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|md
operator|.
name|md_salt
argument_list|)
argument_list|,
name|passphrase
argument_list|,
name|geli_e
operator|->
name|md
operator|.
name|md_iterations
argument_list|)
expr_stmt|;
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_eli_crypto_hmac_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_eli_mkey_decrypt
argument_list|(
operator|&
name|geli_e
operator|->
name|md
argument_list|,
name|key
argument_list|,
name|mkey
argument_list|,
operator|&
name|keynum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|explicit_bzero
argument_list|(
name|mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|mkey
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bad GELI key: bad password?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|explicit_bzero
argument_list|(
name|mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|mkey
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failed to decrypt GELI master key: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* Add key to keychain */
name|save_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|found_key
label|:
comment|/* Store the keys */
name|bcopy
argument_list|(
name|mkey
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_mkey
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mkey
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivkey
argument_list|,
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivkey
argument_list|)
argument_list|)
expr_stmt|;
name|mkp
operator|=
name|mkey
operator|+
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mkp
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_ekey
argument_list|,
name|G_ELI_DATAKEYLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The encryption key is: ekey = HMAC_SHA512(Data-Key, 0x10) 			 */
name|g_eli_crypto_hmac
argument_list|(
name|mkp
argument_list|,
name|G_ELI_MAXKEYLEN
argument_list|,
literal|"\x10"
argument_list|,
literal|1
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_ekey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|explicit_bzero
argument_list|(
name|mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|mkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the per-sector IV. */
switch|switch
condition|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_ealgo
condition|)
block|{
case|case
name|CRYPTO_AES_XTS
case|:
break|break;
default|default:
name|SHA256_Init
argument_list|(
operator|&
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivctx
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivkey
argument_list|,
sizeof|sizeof
argument_list|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_ivkey
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Disk not found. */
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_geli
parameter_list|(
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|)
block|{
name|SLIST_FOREACH_SAFE
argument_list|(
argument|geli_e
argument_list|,
argument|&geli_head
argument_list|,
argument|entries
argument_list|,
argument|geli_e_tmp
argument_list|)
block|{
if|if
condition|(
name|geli_same_device
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|geli_read
parameter_list|(
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|u_char
name|iv
index|[
name|G_ELI_IVKEYLEN
index|]
decl_stmt|;
name|u_char
modifier|*
name|pbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|dstoff
decl_stmt|;
name|uint64_t
name|keyno
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|nsec
decl_stmt|,
name|secsize
decl_stmt|;
name|struct
name|g_eli_key
name|gkey
decl_stmt|;
name|pbuf
operator|=
name|buf
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|geli_e
argument_list|,
argument|&geli_head
argument_list|,
argument|entries
argument_list|,
argument|geli_e_tmp
argument_list|)
block|{
if|if
condition|(
name|geli_same_device
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|secsize
operator|=
name|geli_e
operator|->
name|sc
operator|.
name|sc_sectorsize
expr_stmt|;
name|nsec
operator|=
name|bytes
operator|/
name|secsize
expr_stmt|;
if|if
condition|(
name|nsec
operator|==
literal|0
condition|)
block|{
comment|/* 			 * A read of less than the GELI sector size has been 			 * requested. The caller provided destination buffer may 			 * not be big enough to boost the read to a full sector, 			 * so just attempt to decrypt the truncated sector. 			 */
name|secsize
operator|=
name|bytes
expr_stmt|;
name|nsec
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|dstoff
operator|=
name|offset
init|;
name|n
operator|<
name|nsec
condition|;
name|n
operator|++
operator|,
name|dstoff
operator|+=
name|secsize
control|)
block|{
name|g_eli_crypto_ivgen
argument_list|(
operator|&
name|geli_e
operator|->
name|sc
argument_list|,
name|dstoff
argument_list|,
name|iv
argument_list|,
name|G_ELI_IVKEYLEN
argument_list|)
expr_stmt|;
comment|/* Get the key that corresponds to this offset. */
name|keyno
operator|=
operator|(
name|dstoff
operator|>>
name|G_ELI_KEY_SHIFT
operator|)
operator|/
name|secsize
expr_stmt|;
name|g_eli_key_fill
argument_list|(
operator|&
name|geli_e
operator|->
name|sc
argument_list|,
operator|&
name|gkey
argument_list|,
name|keyno
argument_list|)
expr_stmt|;
name|error
operator|=
name|geliboot_crypt
argument_list|(
name|geli_e
operator|->
name|sc
operator|.
name|sc_ealgo
argument_list|,
literal|0
argument_list|,
name|pbuf
argument_list|,
name|secsize
argument_list|,
name|gkey
operator|.
name|gek_key
argument_list|,
name|geli_e
operator|->
name|sc
operator|.
name|sc_ekeylen
argument_list|,
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|explicit_bzero
argument_list|(
operator|&
name|gkey
argument_list|,
sizeof|sizeof
argument_list|(
name|gkey
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failed to decrypt in geli_read()!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pbuf
operator|+=
name|secsize
expr_stmt|;
block|}
name|explicit_bzero
argument_list|(
operator|&
name|gkey
argument_list|,
sizeof|sizeof
argument_list|(
name|gkey
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"GELI provider not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|geli_havekey
parameter_list|(
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|)
block|{
name|u_char
name|mkey
index|[
name|G_ELI_DATAIVKEYLEN
index|]
decl_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|geli_e
argument_list|,
argument|&geli_head
argument_list|,
argument|entries
argument_list|,
argument|geli_e_tmp
argument_list|)
block|{
if|if
condition|(
name|geli_same_device
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|geli_findkey
argument_list|(
name|geli_e
argument_list|,
name|dskp
argument_list|,
name|mkey
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|geli_attach
argument_list|(
name|dskp
argument_list|,
name|NULL
argument_list|,
name|mkey
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|explicit_bzero
argument_list|(
name|mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|mkey
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|geli_passphrase
parameter_list|(
name|char
modifier|*
name|pw
parameter_list|,
name|int
name|disk
parameter_list|,
name|int
name|parttype
parameter_list|,
name|int
name|part
parameter_list|,
name|struct
name|dsk
modifier|*
name|dskp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* TODO: Implement GELI keyfile(s) support */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
comment|/* Try cached passphrase */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|pw
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|geli_attach
argument_list|(
name|dskp
argument_list|,
name|pw
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|printf
argument_list|(
literal|"GELI Passphrase for disk%d%c%d: "
argument_list|,
name|disk
argument_list|,
name|parttype
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|pwgets
argument_list|(
name|pw
argument_list|,
name|GELI_PW_MAXLEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|geli_attach
argument_list|(
name|dskp
argument_list|,
name|pw
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

