begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Michael Smith<msmith@freebsd.org>  * Copyright 2015 Toomas Soome<tsoome@me.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Simple hashed block cache  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_comment
comment|/* #define BCACHE_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BCACHE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf("%s: " fmt "\n" , __func__ , ## args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|bcachectl
block|{
name|daddr_t
name|bc_blkno
decl_stmt|;
name|int
name|bc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * bcache per device node. cache is allocated on device first open and freed  * on last close, to save memory. The issue there is the size; biosdisk  * supports up to 31 (0x1f) devices. Classic setup would use single disk  * to boot from, but this has changed with zfs.  */
end_comment

begin_struct
struct|struct
name|bcache
block|{
name|struct
name|bcachectl
modifier|*
name|bcache_ctl
decl_stmt|;
name|caddr_t
name|bcache_data
decl_stmt|;
name|size_t
name|bcache_nblks
decl_stmt|;
name|size_t
name|ra
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int
name|bcache_total_nblks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set by bcache_init */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bcache_blksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set by bcache_init */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bcache_numdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set by bcache_add_dev */
end_comment

begin_comment
comment|/* statistics */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bcache_units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of devices with cache */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bcache_unit_nblks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nblocks per unit */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bcache_hits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bcache_misses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bcache_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bcache_bypasses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bcache_bcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bcache_rablks
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BHASH
parameter_list|(
name|bc
parameter_list|,
name|blkno
parameter_list|)
value|((blkno)& ((bc)->bcache_nblks - 1))
end_define

begin_define
define|#
directive|define
name|BCACHE_LOOKUP
parameter_list|(
name|bc
parameter_list|,
name|blkno
parameter_list|)
define|\
value|((bc)->bcache_ctl[BHASH((bc), (blkno))].bc_blkno != (blkno))
end_define

begin_define
define|#
directive|define
name|BCACHE_READAHEAD
value|256
end_define

begin_define
define|#
directive|define
name|BCACHE_MINREADAHEAD
value|32
end_define

begin_define
define|#
directive|define
name|BCACHE_MARKER
value|0xdeadbeef
end_define

begin_function_decl
specifier|static
name|void
name|bcache_invalidate
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcache_insert
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcache_free_instance
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialise the cache for (nblks) of (bsize).  */
end_comment

begin_function
name|void
name|bcache_init
parameter_list|(
name|size_t
name|nblks
parameter_list|,
name|size_t
name|bsize
parameter_list|)
block|{
comment|/* set up control data */
name|bcache_total_nblks
operator|=
name|nblks
expr_stmt|;
name|bcache_blksize
operator|=
name|bsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add number of devices to bcache. we have to divide cache space  * between the devices, so bcache_add_dev() can be used to set up the  * number. The issue is, we need to get the number before actual allocations.  * bcache_add_dev() is supposed to be called from device init() call, so the  * assumption is, devsw dv_init is called for plain devices first, and  * for zfs, last.  */
end_comment

begin_function
name|void
name|bcache_add_dev
parameter_list|(
name|int
name|devices
parameter_list|)
block|{
name|bcache_numdev
operator|+=
name|devices
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|bcache_allocate
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|bcache
modifier|*
name|bc
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bcache
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|disks
init|=
name|bcache_numdev
decl_stmt|;
name|uint32_t
modifier|*
name|marker
decl_stmt|;
if|if
condition|(
name|disks
operator|==
literal|0
condition|)
name|disks
operator|=
literal|1
expr_stmt|;
comment|/* safe guard */
if|if
condition|(
name|bc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|bc
operator|)
return|;
block|}
comment|/*      * the bcache block count must be power of 2 for hash function      */
name|i
operator|=
name|fls
argument_list|(
name|disks
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* highbit - 1 */
if|if
condition|(
name|disks
operator|>
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
comment|/* next power of 2 */
name|i
operator|++
expr_stmt|;
name|bc
operator|->
name|bcache_nblks
operator|=
name|bcache_total_nblks
operator|>>
name|i
expr_stmt|;
name|bcache_unit_nblks
operator|=
name|bc
operator|->
name|bcache_nblks
expr_stmt|;
name|bc
operator|->
name|bcache_data
operator|=
name|malloc
argument_list|(
name|bc
operator|->
name|bcache_nblks
operator|*
name|bcache_blksize
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|bcache_data
operator|==
name|NULL
condition|)
block|{
comment|/* dont error out yet. fall back to 32 blocks and try again */
name|bc
operator|->
name|bcache_nblks
operator|=
literal|32
expr_stmt|;
name|bc
operator|->
name|bcache_data
operator|=
name|malloc
argument_list|(
name|bc
operator|->
name|bcache_nblks
operator|*
name|bcache_blksize
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bc
operator|->
name|bcache_ctl
operator|=
name|malloc
argument_list|(
name|bc
operator|->
name|bcache_nblks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bcachectl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bc
operator|->
name|bcache_data
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bc
operator|->
name|bcache_ctl
operator|==
name|NULL
operator|)
condition|)
block|{
name|bcache_free_instance
argument_list|(
name|bc
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Insert cache end marker. */
name|marker
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|bc
operator|->
name|bcache_data
operator|+
name|bc
operator|->
name|bcache_nblks
operator|*
name|bcache_blksize
operator|)
expr_stmt|;
operator|*
name|marker
operator|=
name|BCACHE_MARKER
expr_stmt|;
comment|/* Flush the cache */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bc
operator|->
name|bcache_nblks
condition|;
name|i
operator|++
control|)
block|{
name|bc
operator|->
name|bcache_ctl
index|[
name|i
index|]
operator|.
name|bc_count
operator|=
operator|-
literal|1
expr_stmt|;
name|bc
operator|->
name|bcache_ctl
index|[
name|i
index|]
operator|.
name|bc_blkno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|bcache_units
operator|++
expr_stmt|;
name|bc
operator|->
name|ra
operator|=
name|BCACHE_READAHEAD
expr_stmt|;
comment|/* optimistic read ahead */
return|return
operator|(
name|bc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bcache_free
parameter_list|(
name|void
modifier|*
name|cache
parameter_list|)
block|{
name|struct
name|bcache
modifier|*
name|bc
init|=
name|cache
decl_stmt|;
if|if
condition|(
name|bc
operator|==
name|NULL
condition|)
return|return;
name|bcache_free_instance
argument_list|(
name|bc
argument_list|)
expr_stmt|;
name|bcache_units
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a write request; write directly to the disk, and populate the  * cache with the new values.  */
end_comment

begin_function
specifier|static
name|int
name|write_strategy
parameter_list|(
name|void
modifier|*
name|devdata
parameter_list|,
name|int
name|rw
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|)
block|{
name|struct
name|bcache_devdata
modifier|*
name|dd
init|=
operator|(
expr|struct
name|bcache_devdata
operator|*
operator|)
name|devdata
decl_stmt|;
name|struct
name|bcache
modifier|*
name|bc
init|=
name|dd
operator|->
name|dv_cache
decl_stmt|;
name|daddr_t
name|i
decl_stmt|,
name|nblk
decl_stmt|;
name|nblk
operator|=
name|size
operator|/
name|bcache_blksize
expr_stmt|;
comment|/* Invalidate the blocks being written */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblk
condition|;
name|i
operator|++
control|)
block|{
name|bcache_invalidate
argument_list|(
name|bc
argument_list|,
name|blk
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Write the blocks */
return|return
operator|(
name|dd
operator|->
name|dv_strategy
argument_list|(
name|dd
operator|->
name|dv_devdata
argument_list|,
name|rw
argument_list|,
name|blk
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|rsize
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a read request; fill in parts of the request that can  * be satisfied by the cache, use the supplied strategy routine to do  * device I/O and then use the I/O results to populate the cache.   */
end_comment

begin_function
specifier|static
name|int
name|read_strategy
parameter_list|(
name|void
modifier|*
name|devdata
parameter_list|,
name|int
name|rw
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|)
block|{
name|struct
name|bcache_devdata
modifier|*
name|dd
init|=
operator|(
expr|struct
name|bcache_devdata
operator|*
operator|)
name|devdata
decl_stmt|;
name|struct
name|bcache
modifier|*
name|bc
init|=
name|dd
operator|->
name|dv_cache
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|nblk
decl_stmt|,
name|p_size
decl_stmt|,
name|r_size
decl_stmt|,
name|complete
decl_stmt|,
name|ra
decl_stmt|;
name|int
name|result
decl_stmt|;
name|daddr_t
name|p_blk
decl_stmt|;
name|caddr_t
name|p_buf
decl_stmt|;
name|uint32_t
modifier|*
name|marker
decl_stmt|;
if|if
condition|(
name|bc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENODEV
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|marker
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|bc
operator|->
name|bcache_data
operator|+
name|bc
operator|->
name|bcache_nblks
operator|*
name|bcache_blksize
operator|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
name|nblk
operator|=
name|size
operator|/
name|bcache_blksize
expr_stmt|;
if|if
condition|(
name|nblk
operator|==
literal|0
operator|&&
name|size
operator|!=
literal|0
condition|)
name|nblk
operator|++
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|complete
operator|=
literal|1
expr_stmt|;
comment|/* Satisfy any cache hits up front, break on first miss */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BCACHE_LOOKUP
argument_list|(
name|bc
argument_list|,
call|(
name|daddr_t
call|)
argument_list|(
name|blk
operator|+
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|bcache_misses
operator|+=
operator|(
name|nblk
operator|-
name|i
operator|)
expr_stmt|;
name|complete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nblk
operator|-
name|i
operator|>
name|BCACHE_MINREADAHEAD
operator|&&
name|bc
operator|->
name|ra
operator|>
name|BCACHE_MINREADAHEAD
condition|)
name|bc
operator|->
name|ra
operator|>>=
literal|1
expr_stmt|;
comment|/* reduce read ahead */
break|break;
block|}
else|else
block|{
name|bcache_hits
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|complete
condition|)
block|{
comment|/* whole set was in cache, return it */
if|if
condition|(
name|bc
operator|->
name|ra
operator|<
name|BCACHE_READAHEAD
condition|)
name|bc
operator|->
name|ra
operator|<<=
literal|1
expr_stmt|;
comment|/* increase read ahead */
name|bcopy
argument_list|(
name|bc
operator|->
name|bcache_data
operator|+
operator|(
name|bcache_blksize
operator|*
name|BHASH
argument_list|(
name|bc
argument_list|,
name|blk
argument_list|)
operator|)
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*      * Fill in any misses. From check we have i pointing to first missing      * block, read in all remaining blocks + readahead.      * We have space at least for nblk - i before bcache wraps.      */
name|p_blk
operator|=
name|blk
operator|+
name|i
expr_stmt|;
name|p_buf
operator|=
name|bc
operator|->
name|bcache_data
operator|+
operator|(
name|bcache_blksize
operator|*
name|BHASH
argument_list|(
name|bc
argument_list|,
name|p_blk
argument_list|)
operator|)
expr_stmt|;
name|r_size
operator|=
name|bc
operator|->
name|bcache_nblks
operator|-
name|BHASH
argument_list|(
name|bc
argument_list|,
name|p_blk
argument_list|)
expr_stmt|;
comment|/* remaining blocks */
name|p_size
operator|=
name|MIN
argument_list|(
name|r_size
argument_list|,
name|nblk
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* read at least those blocks */
comment|/*      * The read ahead size setup.      * While the read ahead can save us IO, it also can complicate things:      * 1. We do not want to read ahead by wrapping around the      * bcache end - this would complicate the cache management.      * 2. We are using bc->ra as dynamic hint for read ahead size,      * detected cache hits will increase the read-ahead block count, and      * misses will decrease, see the code above.      * 3. The bcache is sized by 512B blocks, however, the underlying device      * may have a larger sector size, and we should perform the IO by      * taking into account these larger sector sizes. We could solve this by      * passing the sector size to bcache_allocate(), or by using ioctl(), but      * in this version we are using the constant, 16 blocks, and are rounding      * read ahead block count down to multiple of 16.      * Using the constant has two reasons, we are not entirely sure if the      * BIOS disk interface is providing the correct value for sector size.      * And secondly, this way we get the most conservative setup for the ra.      *      * The selection of multiple of 16 blocks (8KB) is quite arbitrary, however,      * we want to cover CDs (2K) and 4K disks.      * bcache_allocate() will always fall back to a minimum of 32 blocks.      * Our choice of 16 read ahead blocks will always fit inside the bcache.      */
name|ra
operator|=
name|bc
operator|->
name|bcache_nblks
operator|-
name|BHASH
argument_list|(
name|bc
argument_list|,
name|p_blk
operator|+
name|p_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|!=
literal|0
operator|&&
name|ra
operator|!=
name|bc
operator|->
name|bcache_nblks
condition|)
block|{
comment|/* do we have RA space? */
name|ra
operator|=
name|MIN
argument_list|(
name|bc
operator|->
name|ra
argument_list|,
name|ra
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ra
operator|=
name|rounddown
argument_list|(
name|ra
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* multiple of 16 blocks */
name|p_size
operator|+=
name|ra
expr_stmt|;
block|}
comment|/* invalidate bcache */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_size
condition|;
name|i
operator|++
control|)
block|{
name|bcache_invalidate
argument_list|(
name|bc
argument_list|,
name|p_blk
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|r_size
operator|=
literal|0
expr_stmt|;
comment|/*      * with read-ahead, it may happen we are attempting to read past      * disk end, as bcache has no information about disk size.      * in such case we should get partial read if some blocks can be      * read or error, if no blocks can be read.      * in either case we should return the data in bcache and only      * return error if there is no data.      */
name|result
operator|=
name|dd
operator|->
name|dv_strategy
argument_list|(
name|dd
operator|->
name|dv_devdata
argument_list|,
name|rw
argument_list|,
name|p_blk
argument_list|,
name|p_size
operator|*
name|bcache_blksize
argument_list|,
name|p_buf
argument_list|,
operator|&
name|r_size
argument_list|)
expr_stmt|;
name|r_size
operator|/=
name|bcache_blksize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r_size
condition|;
name|i
operator|++
control|)
name|bcache_insert
argument_list|(
name|bc
argument_list|,
name|p_blk
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* update ra statistics */
if|if
condition|(
name|r_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r_size
operator|<
name|p_size
condition|)
name|bcache_rablks
operator|+=
operator|(
name|p_size
operator|-
name|r_size
operator|)
expr_stmt|;
else|else
name|bcache_rablks
operator|+=
name|ra
expr_stmt|;
block|}
comment|/* check how much data can we copy */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BCACHE_LOOKUP
argument_list|(
name|bc
argument_list|,
call|(
name|daddr_t
call|)
argument_list|(
name|blk
operator|+
name|i
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|size
operator|>
name|i
operator|*
name|bcache_blksize
condition|)
name|size
operator|=
name|i
operator|*
name|bcache_blksize
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|bc
operator|->
name|bcache_data
operator|+
operator|(
name|bcache_blksize
operator|*
name|BHASH
argument_list|(
name|bc
argument_list|,
name|blk
argument_list|)
operator|)
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|marker
operator|!=
name|BCACHE_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"BUG: bcache corruption detected: nblks: %zu p_blk: %lu, "
literal|"p_size: %zu, ra: %zu\n"
argument_list|,
name|bc
operator|->
name|bcache_nblks
argument_list|,
operator|(
name|long
name|unsigned
operator|)
name|BHASH
argument_list|(
name|bc
argument_list|,
name|p_blk
argument_list|)
argument_list|,
name|p_size
argument_list|,
name|ra
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|result
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rsize
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|rsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Requests larger than 1/2 cache size will be bypassed and go  * directly to the disk.  XXX tune this.  */
end_comment

begin_function
name|int
name|bcache_strategy
parameter_list|(
name|void
modifier|*
name|devdata
parameter_list|,
name|int
name|rw
parameter_list|,
name|daddr_t
name|blk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|)
block|{
name|struct
name|bcache_devdata
modifier|*
name|dd
init|=
operator|(
expr|struct
name|bcache_devdata
operator|*
operator|)
name|devdata
decl_stmt|;
name|struct
name|bcache
modifier|*
name|bc
init|=
name|dd
operator|->
name|dv_cache
decl_stmt|;
name|u_int
name|bcache_nblks
init|=
literal|0
decl_stmt|;
name|int
name|nblk
decl_stmt|,
name|cblk
decl_stmt|,
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|,
name|isize
decl_stmt|,
name|total
decl_stmt|;
name|bcache_ops
operator|++
expr_stmt|;
if|if
condition|(
name|bc
operator|!=
name|NULL
condition|)
name|bcache_nblks
operator|=
name|bc
operator|->
name|bcache_nblks
expr_stmt|;
comment|/* bypass large requests, or when the cache is inactive */
if|if
condition|(
name|bc
operator|==
name|NULL
operator|||
operator|(
operator|(
name|size
operator|*
literal|2
operator|/
name|bcache_blksize
operator|)
operator|>
name|bcache_nblks
operator|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|"bypass %zu from %qu"
argument_list|,
name|size
operator|/
name|bcache_blksize
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|bcache_bypasses
operator|++
expr_stmt|;
return|return
operator|(
name|dd
operator|->
name|dv_strategy
argument_list|(
name|dd
operator|->
name|dv_devdata
argument_list|,
name|rw
argument_list|,
name|blk
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|rsize
argument_list|)
operator|)
return|;
block|}
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|F_READ
case|:
name|nblk
operator|=
name|size
operator|/
name|bcache_blksize
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|nblk
operator|==
literal|0
condition|)
name|nblk
operator|++
expr_stmt|;
comment|/* read at least one block */
name|ret
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|cblk
operator|=
name|bcache_nblks
operator|-
name|BHASH
argument_list|(
name|bc
argument_list|,
name|blk
argument_list|)
expr_stmt|;
comment|/* # of blocks left */
name|cblk
operator|=
name|MIN
argument_list|(
name|cblk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bcache_blksize
condition|)
name|csize
operator|=
name|size
expr_stmt|;
else|else
name|csize
operator|=
name|cblk
operator|*
name|bcache_blksize
expr_stmt|;
name|ret
operator|=
name|read_strategy
argument_list|(
name|devdata
argument_list|,
name|rw
argument_list|,
name|blk
argument_list|,
name|csize
argument_list|,
name|buf
operator|+
name|total
argument_list|,
operator|&
name|isize
argument_list|)
expr_stmt|;
comment|/* 	     * we may have error from read ahead, if we have read some data 	     * return partial read. 	     */
if|if
condition|(
name|ret
operator|!=
literal|0
operator|||
name|isize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|total
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|blk
operator|+=
name|isize
operator|/
name|bcache_blksize
expr_stmt|;
name|total
operator|+=
name|isize
expr_stmt|;
name|size
operator|-=
name|isize
expr_stmt|;
name|nblk
operator|=
name|size
operator|/
name|bcache_blksize
expr_stmt|;
block|}
if|if
condition|(
name|rsize
condition|)
operator|*
name|rsize
operator|=
name|total
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
case|case
name|F_WRITE
case|:
return|return
name|write_strategy
argument_list|(
name|devdata
argument_list|,
name|rw
argument_list|,
name|blk
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|rsize
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Free allocated bcache instance  */
end_comment

begin_function
specifier|static
name|void
name|bcache_free_instance
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|)
block|{
if|if
condition|(
name|bc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bc
operator|->
name|bcache_ctl
condition|)
name|free
argument_list|(
name|bc
operator|->
name|bcache_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|bcache_data
condition|)
name|free
argument_list|(
name|bc
operator|->
name|bcache_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Insert a block into the cache.  */
end_comment

begin_function
specifier|static
name|void
name|bcache_insert
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|u_int
name|cand
decl_stmt|;
name|cand
operator|=
name|BHASH
argument_list|(
name|bc
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"insert blk %llu -> %u # %d"
argument_list|,
name|blkno
argument_list|,
name|cand
argument_list|,
name|bcache_bcount
argument_list|)
expr_stmt|;
name|bc
operator|->
name|bcache_ctl
index|[
name|cand
index|]
operator|.
name|bc_blkno
operator|=
name|blkno
expr_stmt|;
name|bc
operator|->
name|bcache_ctl
index|[
name|cand
index|]
operator|.
name|bc_count
operator|=
name|bcache_bcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invalidate a block from the cache.  */
end_comment

begin_function
specifier|static
name|void
name|bcache_invalidate
parameter_list|(
name|struct
name|bcache
modifier|*
name|bc
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|i
operator|=
name|BHASH
argument_list|(
name|bc
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|bcache_ctl
index|[
name|i
index|]
operator|.
name|bc_blkno
operator|==
name|blkno
condition|)
block|{
name|bc
operator|->
name|bcache_ctl
index|[
name|i
index|]
operator|.
name|bc_count
operator|=
operator|-
literal|1
expr_stmt|;
name|bc
operator|->
name|bcache_ctl
index|[
name|i
index|]
operator|.
name|bc_blkno
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
literal|"invalidate blk %llu"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BOOT2
end_ifndef

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|bcachestat
argument_list|,
literal|"bcachestat"
argument_list|,
literal|"get disk block cache stats"
argument_list|,
name|command_bcache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|command_bcache
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|command_errmsg
operator|=
literal|"wrong number of arguments"
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\ncache blocks: %d\n"
argument_list|,
name|bcache_total_nblks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cache blocksz: %d\n"
argument_list|,
name|bcache_blksize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cache readahead: %d\n"
argument_list|,
name|bcache_rablks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unit cache blocks: %d\n"
argument_list|,
name|bcache_unit_nblks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cached units: %d\n"
argument_list|,
name|bcache_units
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d ops  %d bypasses  %d hits  %d misses\n"
argument_list|,
name|bcache_ops
argument_list|,
name|bcache_bypasses
argument_list|,
name|bcache_hits
argument_list|,
name|bcache_misses
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

