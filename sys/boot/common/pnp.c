begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * mjs copyright  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * "Plug and Play" functionality.  *  * We use the PnP enumerators to obtain identifiers for installed hardware,  * and the contents of a database to determine modules to be loaded to support  * such hardware.  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<bootstrap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BOOT_FORTH
end_ifdef

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|pnpinfo_stql
name|pnp_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pnp_devices_initted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pnp_discard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Perform complete enumeration sweep  */
end_comment

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|pnpscan
argument_list|,
literal|"pnpscan"
argument_list|,
literal|"scan for PnP devices"
argument_list|,
name|pnp_scan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pnp_scan
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|pnpinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|hdlr
decl_stmt|;
name|int
name|verbose
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|pnp_devices_initted
operator|==
literal|0
condition|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|pnp_devices
argument_list|)
expr_stmt|;
name|pnp_devices_initted
operator|=
literal|1
expr_stmt|;
block|}
name|verbose
operator|=
literal|0
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
comment|/* getopt has already reported an error */
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
block|}
comment|/* forget anything we think we knew */
name|pnp_discard
argument_list|()
expr_stmt|;
comment|/* iterate over all of the handlers */
for|for
control|(
name|hdlr
operator|=
literal|0
init|;
name|pnphandlers
index|[
name|hdlr
index|]
operator|!=
name|NULL
condition|;
name|hdlr
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Probing %s...\n"
argument_list|,
name|pnphandlers
index|[
name|hdlr
index|]
operator|->
name|pp_name
argument_list|)
expr_stmt|;
name|pnphandlers
index|[
name|hdlr
index|]
operator|->
name|pp_enumerate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|pager_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|pager_output
argument_list|(
literal|"PNP scan summary:\n"
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|STAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&pnp_devices
argument_list|,
argument|pi_link
argument_list|)
block|{
name|pager_output
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|)
operator|->
name|id_ident
argument_list|)
expr_stmt|;
comment|/* first ident should be canonical */
if|if
condition|(
name|pi
operator|->
name|pi_desc
operator|!=
name|NULL
condition|)
block|{
name|pager_output
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|pi
operator|->
name|pi_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pager_output
argument_list|(
literal|"\n"
argument_list|)
condition|)
break|break;
block|}
name|out
label|:
name|pager_close
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Throw away anything we think we know about PnP devices.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_discard
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pnpinfo
modifier|*
name|pi
decl_stmt|;
while|while
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|pnp_devices
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|pi
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|pnp_devices
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|pnp_devices
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
name|pnp_freeinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a unique identifier to (pi)  */
end_comment

begin_function
name|void
name|pnp_addident
parameter_list|(
name|struct
name|pnpinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|ident
parameter_list|)
block|{
name|struct
name|pnpident
modifier|*
name|id
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|id
argument_list|,
argument|&pi->pi_ident
argument_list|,
argument|id_link
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|id
operator|->
name|id_ident
argument_list|,
name|ident
argument_list|)
condition|)
return|return;
comment|/* already have this one */
name|id
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pnpident
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|id_ident
operator|=
name|strdup
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|,
name|id
argument_list|,
name|id_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new pnpinfo struct  */
end_comment

begin_function
name|struct
name|pnpinfo
modifier|*
name|pnp_allocinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pnpinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pnpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pnpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|pi
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release storage held by a pnpinfo struct  */
end_comment

begin_function
name|void
name|pnp_freeinfo
parameter_list|(
name|struct
name|pnpinfo
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|pnpident
modifier|*
name|id
decl_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|)
condition|)
block|{
name|id
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|pi
operator|->
name|pi_ident
argument_list|,
name|id_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id
operator|->
name|id_ident
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|pi_desc
condition|)
name|free
argument_list|(
name|pi
operator|->
name|pi_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_module
condition|)
name|free
argument_list|(
name|pi
operator|->
name|pi_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_argv
condition|)
name|free
argument_list|(
name|pi
operator|->
name|pi_argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a new pnpinfo struct to the list.  */
end_comment

begin_function
name|void
name|pnp_addinfo
parameter_list|(
name|struct
name|pnpinfo
modifier|*
name|pi
parameter_list|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pnp_devices
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Format an EISA id as a string in standard ISA PnP format, AAAIIRR  * where 'AAA' is the EISA vendor ID, II is the product ID and RR the revision ID.  */
end_comment

begin_function
name|char
modifier|*
name|pnp_eisaformat
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|char
name|idbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|char
name|hextoascii
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|idbuf
index|[
literal|0
index|]
operator|=
literal|'@'
operator|+
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|idbuf
index|[
literal|1
index|]
operator|=
literal|'@'
operator|+
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|idbuf
index|[
literal|2
index|]
operator|=
literal|'@'
operator|+
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|idbuf
index|[
literal|3
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|4
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|5
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|6
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|idbuf
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BOOT_FORTH
end_ifdef

begin_function
name|void
name|ficlPnpdevices
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
specifier|static
name|int
name|pnp_devices_initted
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pnp_devices_initted
condition|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|pnp_devices
argument_list|)
expr_stmt|;
name|pnp_devices_initted
operator|=
literal|1
expr_stmt|;
block|}
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|&
name|pnp_devices
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ficlPnphandlers
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pnphandlers
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Glue function to add the appropriate forth words to access pnp BIOS  * functionality.  */
end_comment

begin_function
specifier|static
name|void
name|ficlCompilePnp
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|assert
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"pnpdevices"
argument_list|,
name|ficlPnpdevices
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"pnphandlers"
argument_list|,
name|ficlPnphandlers
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|FICL_COMPILE_SET
argument_list|(
name|ficlCompilePnp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

