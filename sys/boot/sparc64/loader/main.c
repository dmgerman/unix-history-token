begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Initial implementation:  * Copyright (c) 2001 Robert Drehmel  * All rights reserved.  *  * As long as the above copyright statement and this notice remain  * unchanged, you can do what ever you want with this file.   *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * FreeBSD/sparc64 kernel loader - machine dependent part  *  *  - implements copyin and readin functions that map kernel  *    pages on demand.  The machine independent code does not  *    know the size of the kernel early enough to pre-enter  *    TTEs and install just one 4MB mapping seemed to limiting  *    to me.  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/asi.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_include
include|#
directive|include
file|"libofw.h"
end_include

begin_include
include|#
directive|include
file|"dev_net.h"
end_include

begin_enum
enum|enum
block|{
name|HEAPVA
init|=
literal|0x800000
block|,
name|HEAPSZ
init|=
literal|0x1000000
block|,
name|LOADSZ
init|=
literal|0x1000000
comment|/* for kernel and modules */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|memory_slice
block|{
name|vm_offset_t
name|pstart
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
name|kernel_entry_t
parameter_list|(
name|vm_offset_t
name|mdp
parameter_list|,
name|u_long
name|o1
parameter_list|,
name|u_long
name|o2
parameter_list|,
name|u_long
name|o3
parameter_list|,
name|void
modifier|*
name|openfirmware
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|void
name|itlb_enter
parameter_list|(
name|int
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dtlb_enter
parameter_list|(
name|int
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|itlb_va_to_pa
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|dtlb_va_to_pa
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|md_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|elf_exec
parameter_list|(
name|struct
name|preloaded_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_mapin
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|__progname
index|[]
init|=
literal|"FreeBSD/sparc64 loader"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernelpa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin of kernel and mod memory. */
end_comment

begin_decl_stmt
name|vm_offset_t
name|curkpg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (PA) used for on-demand map-in. */
end_comment

begin_decl_stmt
name|vm_offset_t
name|curkva
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|heapva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tlbslot
init|=
literal|63
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert first entry at this TLB slot. XXX */
end_comment

begin_decl_stmt
name|phandle_t
name|pmemh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OFW memory handle */
end_comment

begin_decl_stmt
name|struct
name|memory_slice
name|memslices
index|[
literal|18
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ofw_devdesc
name|bootdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Machine dependent structures that the machine independent  * loader part uses.  */
end_comment

begin_decl_stmt
name|struct
name|devsw
modifier|*
name|devsw
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_DISK_SUPPORT
operator|&
name|ofwdisk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|netdev
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arch_switch
name|archsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
name|sparc64_elf
init|=
block|{
name|elf_loadfile
block|,
name|elf_exec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
modifier|*
name|file_formats
index|[]
init|=
block|{
operator|&
name|sparc64_elf
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
modifier|*
name|file_system
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOAD_DISK_SUPPORT
operator|&
name|ufs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|nfs_fsops
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netif_driver
modifier|*
name|netif_drivers
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|ofwnet
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|ofwconsole
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|console
modifier|*
name|consoles
index|[]
init|=
block|{
operator|&
name|ofwconsole
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * archsw functions  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"nothing to autoload yet.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
name|fd
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|)
block|{
name|mmu_mapin
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|vm_offset_t
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|mmu_mapin
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * other MD functions  */
end_comment

begin_function
specifier|static
name|int
name|elf_exec
parameter_list|(
name|struct
name|preloaded_file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|file_metadata
modifier|*
name|fmp
decl_stmt|;
name|vm_offset_t
name|entry
decl_stmt|;
name|vm_offset_t
name|mdp
decl_stmt|;
name|Elf_Ehdr
modifier|*
name|Ehdr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|fmp
operator|=
name|file_findmetadata
argument_list|(
name|fp
argument_list|,
name|MODINFOMD_ELFHDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|EFTYPE
return|;
block|}
name|Ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|&
name|fmp
operator|->
name|md_data
expr_stmt|;
name|entry
operator|=
name|Ehdr
operator|->
name|e_entry
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_load
argument_list|(
name|fp
operator|->
name|f_args
argument_list|,
operator|&
name|mdp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|printf
argument_list|(
literal|"jumping to kernel entry at 0x%lx.\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pmap_print_tlb('i'); 	pmap_print_tlb('d');
endif|#
directive|endif
operator|(
operator|(
name|kernel_entry_t
operator|*
operator|)
name|entry
operator|)
operator|(
name|mdp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
name|openfirmware
operator|)
expr_stmt|;
name|panic
argument_list|(
literal|"exec returned"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_mapin
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|va
operator|+
name|len
operator|>
name|curkva
condition|)
name|curkva
operator|=
name|va
operator|+
name|len
expr_stmt|;
name|len
operator|+=
name|va
operator|&
name|PAGE_MASK_4M
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK_4M
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|dtlb_va_to_pa
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|||
name|itlb_va_to_pa
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
name|dtlb_enter
argument_list|(
name|tlbslot
argument_list|,
name|curkpg
argument_list|,
name|va
argument_list|,
name|TD_V
operator||
name|TD_4M
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
argument_list|)
expr_stmt|;
name|itlb_enter
argument_list|(
name|tlbslot
argument_list|,
name|curkpg
argument_list|,
name|va
argument_list|,
name|TD_V
operator||
name|TD_4M
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
argument_list|)
expr_stmt|;
name|tlbslot
operator|--
expr_stmt|;
name|curkpg
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
name|len
operator|-=
name|len
operator|>
name|PAGE_SIZE_4M
condition|?
name|PAGE_SIZE_4M
else|:
name|len
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pmemh
operator|=
name|OF_finddevice
argument_list|(
literal|"/memory"
argument_list|)
operator|)
operator|==
operator|(
name|phandle_t
operator|)
operator|-
literal|1
condition|)
name|OF_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmemh
argument_list|,
literal|"available"
argument_list|,
name|memslices
argument_list|,
sizeof|sizeof
argument_list|(
name|memslices
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|OF_exit
argument_list|()
expr_stmt|;
comment|/* Reserve 16 MB continuous for kernel and modules. */
name|kernelpa
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_alloc_phys
argument_list|(
name|LOADSZ
argument_list|,
literal|0x400000
argument_list|)
expr_stmt|;
name|curkpg
operator|=
name|kernelpa
expr_stmt|;
comment|/* There is no need for continuous physical heap memory. */
name|heapva
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_claim
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HEAPVA
argument_list|,
name|HEAPSZ
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|heapva
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
function_decl|(
modifier|*
name|openfirm
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|bootpath
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|devsw
modifier|*
modifier|*
name|dp
decl_stmt|;
name|phandle_t
name|chosenh
decl_stmt|;
comment|/* 	 * Tell the OpenFirmware functions where they find the ofw gate. 	 */
name|OF_init
argument_list|(
name|openfirm
argument_list|)
expr_stmt|;
name|archsw
operator|.
name|arch_getdev
operator|=
name|ofw_getdev
expr_stmt|;
name|archsw
operator|.
name|arch_copyin
operator|=
name|sparc64_copyin
expr_stmt|;
name|archsw
operator|.
name|arch_copyout
operator|=
name|ofw_copyout
expr_stmt|;
name|archsw
operator|.
name|arch_readin
operator|=
name|sparc64_readin
expr_stmt|;
name|archsw
operator|.
name|arch_autoload
operator|=
name|sparc64_autoload
expr_stmt|;
name|init_heap
argument_list|()
expr_stmt|;
name|setheap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|heapva
operator|+
name|HEAPSZ
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Probe for a console. 	 */
name|cons_probe
argument_list|()
expr_stmt|;
name|bcache_init
argument_list|(
literal|32
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize devices. 	 */
for|for
control|(
name|dp
operator|=
name|devsw
init|;
operator|*
name|dp
operator|!=
literal|0
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
operator|!=
literal|0
condition|)
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Set up the current device. 	 */
name|chosenh
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|chosenh
argument_list|,
literal|"bootpath"
argument_list|,
name|bootpath
argument_list|,
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
argument_list|)
expr_stmt|;
name|bootdev
operator|.
name|d_type
operator|=
name|ofw_devicetype
argument_list|(
name|bootpath
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bootdev
operator|.
name|d_type
condition|)
block|{
case|case
name|DEVT_DISK
case|:
name|bootdev
operator|.
name|d_dev
operator|=
operator|&
name|ofwdisk
expr_stmt|;
name|strncpy
argument_list|(
name|bootdev
operator|.
name|d_kind
operator|.
name|ofwdisk
operator|.
name|path
argument_list|,
name|bootpath
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ofw_parseofwdev
argument_list|(
operator|&
name|bootdev
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVT_NET
case|:
name|bootdev
operator|.
name|d_dev
operator|=
operator|&
name|netdev
expr_stmt|;
name|strncpy
argument_list|(
name|bootdev
operator|.
name|d_kind
operator|.
name|netif
operator|.
name|path
argument_list|,
name|bootpath
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|bootdev
operator|.
name|d_kind
operator|.
name|netif
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|ofw_fmtdev
argument_list|(
operator|&
name|bootdev
argument_list|)
argument_list|,
name|ofw_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"loaddev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|ofw_fmtdev
argument_list|(
operator|&
name|bootdev
argument_list|)
argument_list|,
name|env_noset
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bootpath=\"%s\"\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"loaddev=%s\n"
argument_list|,
name|getenv
argument_list|(
literal|"loaddev"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"kernelpa=0x%lx\n"
argument_list|,
name|curkpg
argument_list|)
expr_stmt|;
comment|/* Give control to the machine independent loader code. */
name|interact
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|u_int64_t
name|tte_t
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|page_sizes
index|[]
init|=
block|{
literal|"  8k"
block|,
literal|" 64k"
block|,
literal|"512k"
block|,
literal|"  4m"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmap_print_tte
parameter_list|(
name|tte_t
name|tag
parameter_list|,
name|tte_t
name|tte
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s "
argument_list|,
name|page_sizes
index|[
operator|(
name|tte
operator|&
name|TD_SIZE_MASK
operator|)
operator|>>
name|TD_SIZE_SHIFT
index|]
argument_list|,
name|tag
operator|&
name|TD_G
condition|?
literal|"G"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_W
condition|?
literal|"W "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_P
condition|?
literal|"\e[33mP\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_E
condition|?
literal|"E "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CV
condition|?
literal|"CV "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CP
condition|?
literal|"CP "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_L
condition|?
literal|"\e[32mL\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_IE
condition|?
literal|"IE "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_NFO
condition|?
literal|"NFO "
else|:
literal|"    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tag=0x%lx pa=0x%lx va=0x%lx ctx=%ld\n"
argument_list|,
name|tag
argument_list|,
name|TD_PA
argument_list|(
name|tte
argument_list|)
argument_list|,
name|TT_VA
argument_list|(
name|tag
argument_list|)
argument_list|,
name|TT_CTX
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_print_tlb
parameter_list|(
name|char
name|which
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tte_t
name|tte
decl_stmt|,
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|*
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|which
operator|==
literal|'i'
condition|)
block|{
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tag) : "r" (i), 			    "i" (ASI_ITLB_TAG_READ_REG));
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tte) : "r" (i), 			    "i" (ASI_ITLB_DATA_ACCESS_REG));
block|}
else|else
block|{
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tag) : "r" (i), 			    "i" (ASI_DTLB_TAG_READ_REG));
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tte) : "r" (i), 			    "i" (ASI_DTLB_DATA_ACCESS_REG));
block|}
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%cTLB-%2u: "
argument_list|,
name|which
argument_list|,
name|i
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|pmap_print_tte
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

