begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Initial implementation:  * Copyright (c) 2001 Robert Drehmel  * All rights reserved.  *  * As long as the above copyright statement and this notice remain  * unchanged, you can do what ever you want with this file.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 - 2012 Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * FreeBSD/sparc64 kernel loader - machine dependent part  *  *  - implements copyin and readin functions that map kernel  *    pages on demand.  The machine independent code does not  *    know the size of the kernel early enough to pre-enter  *    TTEs and install just one 4MB mapping seemed to limiting  *    to me.  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|<sys/vtoc.h>
end_include

begin_include
include|#
directive|include
file|"../zfs/libzfs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/asi.h>
end_include

begin_include
include|#
directive|include
file|<machine/cmt.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/fireplane.h>
end_include

begin_include
include|#
directive|include
file|<machine/jbus.h>
end_include

begin_include
include|#
directive|include
file|<machine/lsu.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/upa.h>
end_include

begin_include
include|#
directive|include
file|<machine/ver.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_include
include|#
directive|include
file|"libofw.h"
end_include

begin_include
include|#
directive|include
file|"dev_net.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|bootprog_info
index|[]
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|HEAPVA
init|=
literal|0x800000
block|,
name|HEAPSZ
init|=
literal|0x1000000
block|,
name|LOADSZ
init|=
literal|0x1000000
comment|/* for kernel and modules */
block|}
enum|;
end_enum

begin_comment
comment|/* At least Sun Fire V1280 require page sized allocations to be claimed. */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|HEAPSZ
operator|%
name|PAGE_SIZE
operator|==
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
name|mmu_ops
block|{
name|void
function_decl|(
modifier|*
name|tlb_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|mmu_mapin
function_decl|)
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
function_decl|;
block|}
modifier|*
name|mmu_ops
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
name|kernel_entry_t
parameter_list|(
name|vm_offset_t
name|mdp
parameter_list|,
name|u_long
name|o1
parameter_list|,
name|u_long
name|o2
parameter_list|,
name|u_long
name|o3
parameter_list|,
name|void
modifier|*
name|openfirmware
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data_sun4u
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtlb_enter_sun4u
parameter_list|(
name|u_int
parameter_list|,
name|u_long
name|data
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|dtlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_long
name|itlb_get_data_sun4u
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|itlb_enter_sun4u
parameter_list|(
name|u_int
parameter_list|,
name|u_long
name|data
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|itlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itlb_relocate_locked0_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|md_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
parameter_list|,
name|vm_offset_t
parameter_list|,
specifier|const
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|claim_virt
parameter_list|(
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|alloc_phys
parameter_list|(
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_phys
parameter_list|(
name|int
parameter_list|,
name|size_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_phys
parameter_list|(
name|vm_offset_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|exec
function_decl|)
parameter_list|(
name|struct
name|preloaded_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_mapin_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|phandle_t
name|find_bsp_sun4u
parameter_list|(
name|phandle_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|cpu_cpuid_prop_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|cpu_get_mid_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb_init_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_typedef
typedef|typedef
name|u_int64_t
name|tte_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|pmap_print_tlb_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_print_tte_sun4u
parameter_list|(
name|tte_t
parameter_list|,
name|tte_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mmu_ops
name|mmu_ops_sun4u
init|=
block|{
name|tlb_init_sun4u
block|,
name|mmu_mapin_sun4u
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sun4u */
end_comment

begin_decl_stmt
name|struct
name|tlb_entry
modifier|*
name|dtlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tlb_entry
modifier|*
name|itlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|dtlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|itlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_impl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|dtlb_slot_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|itlb_slot_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|tlb_locked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|curkva
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|heapva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bootpath
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|phandle_t
name|root
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|zfs_devdesc
name|zfs_currdev
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Machine dependent structures that the machine independent  * loader part uses.  */
end_comment

begin_decl_stmt
name|struct
name|devsw
modifier|*
name|devsw
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_DISK_SUPPORT
operator|&
name|ofwdisk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|netdev
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
operator|&
name|zfs_dev
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arch_switch
name|archsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_format
name|sparc64_elf
init|=
block|{
name|__elfN
argument_list|(
name|loadfile
argument_list|)
block|,
name|__elfN
argument_list|(
argument|exec
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
modifier|*
name|file_formats
index|[]
init|=
block|{
operator|&
name|sparc64_elf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
modifier|*
name|file_system
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
operator|&
name|zfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_UFS_SUPPORT
operator|&
name|ufs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_CD9660_SUPPORT
operator|&
name|cd9660_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_ZIP_SUPPORT
operator|&
name|zipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_GZIP_SUPPORT
operator|&
name|gzipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_BZIP2_SUPPORT
operator|&
name|bzipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NFS_SUPPORT
operator|&
name|nfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_TFTP_SUPPORT
operator|&
name|tftp_fsops
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netif_driver
modifier|*
name|netif_drivers
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|ofwnet
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|ofwconsole
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|console
modifier|*
name|consoles
index|[]
init|=
block|{
operator|&
name|ofwconsole
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|watch_phys_set_mask
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_PWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|pa
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|38
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_PW
operator|)
operator|&
operator|~
name|LSU_PM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_PM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_phys_set
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|pa
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_phys_set_mask
argument_list|(
name|pa
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set_mask
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_VWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|va
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|41
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_VW
operator|)
operator|&
operator|~
name|LSU_VM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_VM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|va
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_virt_set_mask
argument_list|(
name|va
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * archsw functions  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
name|fd
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|)
block|{
name|mmu_ops
operator|->
name|mmu_mapin
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|vm_offset_t
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|mmu_ops
operator|->
name|mmu_mapin
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * other MD functions  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|claim_virt
parameter_list|(
name|vm_offset_t
name|virt
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|vm_offset_t
name|mva
decl_stmt|;
if|if
condition|(
name|OF_call_method
argument_list|(
literal|"claim"
argument_list|,
name|mmu
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|virt
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|mva
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|mva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|alloc_phys
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|cell_t
name|phys_hi
decl_stmt|,
name|phys_low
decl_stmt|;
if|if
condition|(
name|OF_call_method
argument_list|(
literal|"claim"
argument_list|,
name|memory
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|phys_low
argument_list|,
operator|&
name|phys_hi
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|phys_hi
operator|<<
literal|32
operator||
name|phys_low
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_phys
parameter_list|(
name|int
name|mode
parameter_list|,
name|size_t
name|size
parameter_list|,
name|vm_offset_t
name|virt
parameter_list|,
name|vm_offset_t
name|phys
parameter_list|)
block|{
return|return
operator|(
name|OF_call_method
argument_list|(
literal|"map"
argument_list|,
name|mmu
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|phys
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|phys
operator|>>
literal|32
argument_list|)
argument_list|,
name|virt
argument_list|,
name|size
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_phys
parameter_list|(
name|vm_offset_t
name|phys
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|OF_call_method
argument_list|(
literal|"release"
argument_list|,
name|memory
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|phys
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|phys
operator|>>
literal|32
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|exec
function|)
parameter_list|(
name|struct
name|preloaded_file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|file_metadata
modifier|*
name|fmp
decl_stmt|;
name|vm_offset_t
name|mdp
decl_stmt|,
name|dtbp
decl_stmt|;
name|Elf_Addr
name|entry
decl_stmt|;
name|Elf_Ehdr
modifier|*
name|e
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|fmp
operator|=
name|file_findmetadata
argument_list|(
name|fp
argument_list|,
name|MODINFOMD_ELFHDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
name|e
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|&
name|fmp
operator|->
name|md_data
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_load
argument_list|(
name|fp
operator|->
name|f_args
argument_list|,
operator|&
name|mdp
argument_list|,
operator|&
name|dtbp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"jumping to kernel entry at %#lx.\n"
argument_list|,
name|e
operator|->
name|e_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dev_cleanup
argument_list|()
expr_stmt|;
name|entry
operator|=
name|e
operator|->
name|e_entry
expr_stmt|;
name|OF_release
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
name|HEAPSZ
argument_list|)
expr_stmt|;
operator|(
operator|(
name|kernel_entry_t
operator|*
operator|)
name|entry
operator|)
operator|(
name|mdp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
name|openfirmware
operator|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: exec returned"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data_sun4u
parameter_list|(
name|u_int
name|tlb
parameter_list|,
name|u_int
name|slot
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|,
name|pstate
decl_stmt|;
name|slot
operator|=
name|TLB_DAR_SLOT
argument_list|(
name|tlb
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* 	 * We read ASI_DTLB_DATA_ACCESS_REG twice back-to-back in order to 	 * work around errata of USIII and beyond. 	 */
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_long
name|itlb_get_data_sun4u
parameter_list|(
name|u_int
name|tlb
parameter_list|,
name|u_int
name|slot
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|,
name|pstate
decl_stmt|;
name|slot
operator|=
name|TLB_DAR_SLOT
argument_list|(
name|tlb
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* 	 * We read ASI_DTLB_DATA_ACCESS_REG twice back-to-back in order to 	 * work around errata of USIII and beyond. 	 */
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|dtlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_long
name|pstate
decl_stmt|,
name|reg
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|tlb
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_TAG_READ_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLB_TAR_VA
argument_list|(
name|reg
argument_list|)
operator|!=
name|va
condition|)
continue|continue;
name|reg
operator|=
name|dtlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|>>=
name|TD_PA_SHIFT
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_SPARC64V
operator|||
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCIII
condition|)
return|return
operator|(
name|reg
operator|&
name|TD_PA_CH_MASK
operator|)
return|;
return|return
operator|(
name|reg
operator|&
name|TD_PA_SF_MASK
operator|)
return|;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|itlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_long
name|pstate
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLB_TAR_VA
argument_list|(
name|reg
argument_list|)
operator|!=
name|va
condition|)
continue|continue;
name|reg
operator|=
name|itlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|>>=
name|TD_PA_SHIFT
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_SPARC64V
operator|||
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCIII
condition|)
return|return
operator|(
name|reg
operator|&
name|TD_PA_CH_MASK
operator|)
return|;
return|return
operator|(
name|reg
operator|&
name|TD_PA_SF_MASK
operator|)
return|;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtlb_enter_sun4u
parameter_list|(
name|u_int
name|index
parameter_list|,
name|u_long
name|data
parameter_list|,
name|vm_offset_t
name|virt
parameter_list|)
block|{
return|return
operator|(
name|OF_call_method
argument_list|(
literal|"SUNW,dtlb-load"
argument_list|,
name|mmu
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|virt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|itlb_enter_sun4u
parameter_list|(
name|u_int
name|index
parameter_list|,
name|u_long
name|data
parameter_list|,
name|vm_offset_t
name|virt
parameter_list|)
block|{
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_ULTRASPARCIIIp
operator|&&
name|index
operator|==
literal|0
operator|&&
operator|(
name|data
operator|&
name|TD_L
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: won't enter locked TLB entry at index 0 on USIII+"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|OF_call_method
argument_list|(
literal|"SUNW,itlb-load"
argument_list|,
name|mmu
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|virt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|itlb_relocate_locked0_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|,
name|pstate
decl_stmt|,
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpu_impl
operator|!=
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
return|return;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|=
name|itlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|TD_V
operator||
name|TD_L
operator|)
operator|)
operator|!=
operator|(
name|TD_V
operator||
name|TD_L
operator|)
condition|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Flush the mapping of slot 0. */
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DEMAP_VA
argument_list|(
name|TLB_TAR_VA
argument_list|(
name|tag
argument_list|)
argument_list|)
operator||
name|TLB_DEMAP_PRIMARY
operator||
name|TLB_DEMAP_PAGE
argument_list|,
name|ASI_IMMU_DEMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The USIII-family ignores the address. */
comment|/* 	 * Search a replacement slot != 0 and enter the data and tag 	 * that formerly were in slot 0. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|itlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|stxa
argument_list|(
name|AA_IMMU_TAR
argument_list|,
name|ASI_IMMU
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The USIII-family ignores the address. */
break|break;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: could not find a replacement slot"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_mapin_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|,
name|mva
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|u_int
name|index
decl_stmt|;
if|if
condition|(
name|va
operator|+
name|len
operator|>
name|curkva
condition|)
name|curkva
operator|=
name|va
operator|+
name|len
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
name|len
operator|+=
name|va
operator|&
name|PAGE_MASK_4M
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK_4M
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|dtlb_va_to_pa_sun4u
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|||
name|itlb_va_to_pa_sun4u
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a physical page, claim the virtual area. */
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
name|pa
operator|=
name|alloc_phys
argument_list|(
name|PAGE_SIZE_4M
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mva
operator|=
name|claim_virt
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mva
operator|!=
name|va
condition|)
name|panic
argument_list|(
literal|"%s: can't claim virtual page "
literal|"(wanted %#lx, got %#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|mva
argument_list|)
expr_stmt|;
comment|/* 				 * The mappings may have changed, be paranoid. 				 */
continue|continue;
block|}
comment|/* 			 * Actually, we can only allocate two pages less at 			 * most (depending on the kernel TSB size). 			 */
if|if
condition|(
name|dtlb_slot
operator|>=
name|dtlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: out of dtlb_slots"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|itlb_slot
operator|>=
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: out of itlb_slots"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|data
operator|=
name|TD_V
operator||
name|TD_4M
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|dtlb_store
index|[
name|dtlb_slot
index|]
operator|.
name|te_pa
operator|=
name|pa
expr_stmt|;
name|dtlb_store
index|[
name|dtlb_slot
index|]
operator|.
name|te_va
operator|=
name|va
expr_stmt|;
name|index
operator|=
name|dtlb_slot_max
operator|-
name|dtlb_slot
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dtlb_enter_sun4u
argument_list|(
name|index
argument_list|,
name|data
argument_list|,
name|va
argument_list|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: can't enter dTLB slot %d data "
literal|"%#lx va %#lx"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|dtlb_slot
operator|++
expr_stmt|;
name|itlb_store
index|[
name|itlb_slot
index|]
operator|.
name|te_pa
operator|=
name|pa
expr_stmt|;
name|itlb_store
index|[
name|itlb_slot
index|]
operator|.
name|te_va
operator|=
name|va
expr_stmt|;
name|index
operator|=
name|itlb_slot_max
operator|-
name|itlb_slot
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|itlb_enter_sun4u
argument_list|(
name|index
argument_list|,
name|data
argument_list|,
name|va
argument_list|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: can't enter iTLB slot %d data "
literal|"%#lx va %#lxd"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|itlb_slot
operator|++
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|len
operator|>
name|PAGE_SIZE_4M
condition|?
name|PAGE_SIZE_4M
else|:
name|len
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|!=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|release_phys
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There is no need for continuous physical heap memory. */
name|heapva
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_claim
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HEAPVA
argument_list|,
name|HEAPSZ
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
name|heapva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|phandle_t
name|find_bsp_sun4u
parameter_list|(
name|phandle_t
name|node
parameter_list|,
name|uint32_t
name|bspid
parameter_list|)
block|{
name|char
name|type
index|[
sizeof|sizeof
argument_list|(
literal|"cpu"
argument_list|)
index|]
decl_stmt|;
name|phandle_t
name|child
decl_stmt|;
name|uint32_t
name|cpuid
decl_stmt|;
for|for
control|(
init|;
name|node
operator|>
literal|0
condition|;
name|node
operator|=
name|OF_peer
argument_list|(
name|node
argument_list|)
control|)
block|{
name|child
operator|=
name|OF_child
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|>
literal|0
condition|)
block|{
name|child
operator|=
name|find_bsp_sun4u
argument_list|(
name|child
argument_list|,
name|bspid
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|>
literal|0
condition|)
return|return
operator|(
name|child
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"device_type"
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"cpu"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
name|cpu_cpuid_prop_sun4u
argument_list|()
argument_list|,
operator|&
name|cpuid
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuid
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cpuid
operator|==
name|bspid
condition|)
return|return
operator|(
name|node
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|cpu_cpuid_prop_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cpu_impl
condition|)
block|{
case|case
name|CPU_IMPL_SPARC64
case|:
case|case
name|CPU_IMPL_SPARC64V
case|:
case|case
name|CPU_IMPL_ULTRASPARCI
case|:
case|case
name|CPU_IMPL_ULTRASPARCII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIe
case|:
return|return
operator|(
literal|"upa-portid"
operator|)
return|;
case|case
name|CPU_IMPL_ULTRASPARCIII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIp
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIip
case|:
return|return
operator|(
literal|"portid"
operator|)
return|;
case|case
name|CPU_IMPL_ULTRASPARCIV
case|:
case|case
name|CPU_IMPL_ULTRASPARCIVp
case|:
return|return
operator|(
literal|"cpuid"
operator|)
return|;
default|default:
return|return
operator|(
literal|""
operator|)
return|;
block|}
block|}
end_function

begin_function
name|uint32_t
name|cpu_get_mid_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cpu_impl
condition|)
block|{
case|case
name|CPU_IMPL_SPARC64
case|:
case|case
name|CPU_IMPL_SPARC64V
case|:
case|case
name|CPU_IMPL_ULTRASPARCI
case|:
case|case
name|CPU_IMPL_ULTRASPARCII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIe
case|:
return|return
operator|(
name|UPA_CR_GET_MID
argument_list|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_UPA_CONFIG_REG
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CPU_IMPL_ULTRASPARCIII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIp
case|:
return|return
operator|(
name|FIREPLANE_CR_GET_AID
argument_list|(
name|ldxa
argument_list|(
name|AA_FIREPLANE_CONFIG
argument_list|,
name|ASI_FIREPLANE_CONFIG_REG
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CPU_IMPL_ULTRASPARCIIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIip
case|:
return|return
operator|(
name|JBUS_CR_GET_JID
argument_list|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_JBUS_CONFIG_REG
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CPU_IMPL_ULTRASPARCIV
case|:
case|case
name|CPU_IMPL_ULTRASPARCIVp
case|:
return|return
operator|(
name|INTR_ID_GET_ID
argument_list|(
name|ldxa
argument_list|(
name|AA_INTR_ID
argument_list|,
name|ASI_INTR_ID
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tlb_init_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|phandle_t
name|bsp
decl_stmt|;
name|cpu_impl
operator|=
name|VER_IMPL
argument_list|(
name|rdpr
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpu_impl
condition|)
block|{
case|case
name|CPU_IMPL_SPARC64
case|:
case|case
name|CPU_IMPL_ULTRASPARCI
case|:
case|case
name|CPU_IMPL_ULTRASPARCII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIe
case|:
name|tlb_locked
operator|=
name|TLB_DAR_T32
expr_stmt|;
break|break;
case|case
name|CPU_IMPL_ULTRASPARCIII
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIp
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIi
case|:
case|case
name|CPU_IMPL_ULTRASPARCIIIip
case|:
case|case
name|CPU_IMPL_ULTRASPARCIV
case|:
case|case
name|CPU_IMPL_ULTRASPARCIVp
case|:
name|tlb_locked
operator|=
name|TLB_DAR_T16
expr_stmt|;
break|break;
case|case
name|CPU_IMPL_SPARC64V
case|:
name|tlb_locked
operator|=
name|TLB_DAR_FTLB
expr_stmt|;
break|break;
block|}
name|bsp
operator|=
name|find_bsp_sun4u
argument_list|(
name|OF_child
argument_list|(
name|root
argument_list|)
argument_list|,
name|cpu_get_mid_sun4u
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: no node for bootcpu?!?!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|bsp
argument_list|,
literal|"#dtlb-entries"
argument_list|,
operator|&
name|dtlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|dtlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_getprop
argument_list|(
name|bsp
argument_list|,
literal|"#itlb-entries"
argument_list|,
operator|&
name|itlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|itlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: can't get TLB slot max."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
block|{
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|printf
argument_list|(
literal|"pre fixup:\n"
argument_list|)
expr_stmt|;
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Relocate the locked entry in it16 slot 0 (if existent) 		 * as part of working around Cheetah+ erratum 34. 		 */
name|itlb_relocate_locked0_sun4u
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|printf
argument_list|(
literal|"post fixup:\n"
argument_list|)
expr_stmt|;
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|dtlb_store
operator|=
name|malloc
argument_list|(
name|dtlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dtlb_store
argument_list|)
argument_list|)
expr_stmt|;
name|itlb_store
operator|=
name|malloc
argument_list|(
name|itlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|itlb_store
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtlb_store
operator|==
name|NULL
operator|||
name|itlb_store
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: can't allocate TLB store"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|sparc64_zfs_probe
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vtoc8
name|vtoc
decl_stmt|;
name|char
name|alias
index|[
literal|64
index|]
decl_stmt|,
name|devname
index|[
sizeof|sizeof
argument_list|(
name|alias
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|":x"
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
name|char
name|type
index|[
sizeof|sizeof
argument_list|(
literal|"device_type"
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|bdev
decl_stmt|,
modifier|*
name|dev
decl_stmt|,
modifier|*
name|odev
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|part
decl_stmt|;
name|phandle_t
name|aliases
decl_stmt|,
name|options
decl_stmt|;
comment|/* Get the GUID of the ZFS pool on the boot device. */
name|guid
operator|=
literal|0
expr_stmt|;
name|zfs_probe_dev
argument_list|(
name|bootpath
argument_list|,
operator|&
name|guid
argument_list|)
expr_stmt|;
comment|/* 	 * Get the GUIDs of the ZFS pools on any additional disks listed in 	 * the boot-device environment variable. 	 */
if|if
condition|(
operator|(
name|aliases
operator|=
name|OF_finddevice
argument_list|(
literal|"/aliases"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
name|options
operator|=
name|OF_finddevice
argument_list|(
literal|"/options"
argument_list|)
expr_stmt|;
name|len
operator|=
name|OF_getproplen
argument_list|(
name|options
argument_list|,
literal|"boot-device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bdev
operator|=
name|odev
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdev
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|options
argument_list|,
literal|"boot-device"
argument_list|,
name|bdev
argument_list|,
name|len
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bdev
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|dev
operator|=
name|strsep
argument_list|(
operator|&
name|bdev
argument_list|,
literal|" "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|dev
operator|==
literal|'\0'
condition|)
continue|continue;
name|strcpy
argument_list|(
name|alias
argument_list|,
name|dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OF_getprop
argument_list|(
name|aliases
argument_list|,
name|dev
argument_list|,
name|alias
argument_list|,
sizeof|sizeof
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Don't probe the boot disk twice.  Note that bootpath 		 * includes the partition specifier. 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|alias
argument_list|,
name|bootpath
argument_list|,
name|strlen
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|OF_getprop
argument_list|(
name|OF_finddevice
argument_list|(
name|alias
argument_list|)
argument_list|,
literal|"device_type"
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"block"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Find freebsd-zfs slices in the VTOC. */
name|fd
operator|=
name|open
argument_list|(
name|alias
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|vtoc
argument_list|,
sizeof|sizeof
argument_list|(
name|vtoc
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|vtoc
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
literal|8
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|part
operator|==
literal|2
operator|||
name|vtoc
operator|.
name|part
index|[
name|part
index|]
operator|.
name|tag
operator|!=
name|VTOC_TAG_FREEBSD_ZFS
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|devname
argument_list|,
literal|"%s:%c"
argument_list|,
name|alias
argument_list|,
name|part
operator|+
literal|'a'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_probe_dev
argument_list|(
name|devname
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENXIO
condition|)
break|break;
block|}
block|}
name|free
argument_list|(
name|odev
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|guid
operator|!=
literal|0
condition|)
block|{
name|zfs_currdev
operator|.
name|pool_guid
operator|=
name|guid
expr_stmt|;
name|zfs_currdev
operator|.
name|root_guid
operator|=
literal|0
expr_stmt|;
name|zfs_currdev
operator|.
name|d_dev
operator|=
operator|&
name|zfs_dev
expr_stmt|;
name|zfs_currdev
operator|.
name|d_type
operator|=
name|zfs_currdev
operator|.
name|d_dev
operator|->
name|dv_type
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOADER_ZFS_SUPPORT */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
function_decl|(
modifier|*
name|openfirm
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|compatible
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|devsw
modifier|*
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * Tell the Open Firmware functions where they find the OFW gate. 	 */
name|OF_init
argument_list|(
name|openfirm
argument_list|)
expr_stmt|;
name|archsw
operator|.
name|arch_getdev
operator|=
name|ofw_getdev
expr_stmt|;
name|archsw
operator|.
name|arch_copyin
operator|=
name|sparc64_copyin
expr_stmt|;
name|archsw
operator|.
name|arch_copyout
operator|=
name|ofw_copyout
expr_stmt|;
name|archsw
operator|.
name|arch_readin
operator|=
name|sparc64_readin
expr_stmt|;
name|archsw
operator|.
name|arch_autoload
operator|=
name|sparc64_autoload
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
name|archsw
operator|.
name|arch_zfs_probe
operator|=
name|sparc64_zfs_probe
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|init_heap
argument_list|()
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|OF_exit
argument_list|()
expr_stmt|;
name|setheap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|heapva
operator|+
name|HEAPSZ
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Probe for a console. 	 */
name|cons_probe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|OF_peer
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: can't get root phandle"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|root
argument_list|,
literal|"compatible"
argument_list|,
name|compatible
argument_list|,
sizeof|sizeof
argument_list|(
name|compatible
argument_list|)
argument_list|)
expr_stmt|;
name|mmu_ops
operator|=
operator|&
name|mmu_ops_sun4u
expr_stmt|;
name|mmu_ops
operator|->
name|tlb_init
argument_list|()
expr_stmt|;
comment|/* 	 * Set up the current device. 	 */
name|OF_getprop
argument_list|(
name|chosen
argument_list|,
literal|"bootpath"
argument_list|,
name|bootpath
argument_list|,
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize devices. 	 */
for|for
control|(
name|dp
operator|=
name|devsw
init|;
operator|*
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
operator|!=
literal|0
condition|)
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_ZFS_SUPPORT
if|if
condition|(
name|zfs_currdev
operator|.
name|pool_guid
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|bootpath
argument_list|,
name|zfs_fmtdev
argument_list|(
operator|&
name|zfs_currdev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bootpath
index|[
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* 	 * Sun compatible bootable CD-ROMs have a disk label placed before 	 * the ISO 9660 data, with the actual file system being in the first 	 * partition, while the other partitions contain pseudo disk labels 	 * with embedded boot blocks for different architectures, which may 	 * be followed by UFS file systems. 	 * The firmware will set the boot path to the partition it boots from 	 * ('f' in the sun4u/sun4v case), but we want the kernel to be loaded 	 * from the ISO 9660 file system ('a'), so the boot path needs to be 	 * altered. 	 */
if|if
condition|(
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'f'
condition|)
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|bootpath
argument_list|,
name|ofw_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"loaddev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|bootpath
argument_list|,
name|env_noset
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|bootprog_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bootpath=\"%s\"\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
comment|/* Give control to the machine independent loader code. */
name|interact
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|heap
argument_list|,
literal|"heap"
argument_list|,
literal|"show heap usage"
argument_list|,
name|command_heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|command_heap
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|mallocstats
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"heap base at %p, top at %p, upper limit at %p\n"
argument_list|,
name|heapva
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
name|heapva
operator|+
name|HEAPSZ
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|reboot
argument_list|,
literal|"reboot"
argument_list|,
literal|"reboot the system"
argument_list|,
name|command_reboot
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|command_reboot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|!=
name|NULL
condition|)
operator|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|)
operator|(
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rebooting...\n"
argument_list|)
expr_stmt|;
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* provide this for panic, as it's not in the startup code */
end_comment

begin_function
name|void
name|exit
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|page_sizes
index|[]
init|=
block|{
literal|"  8k"
block|,
literal|" 64k"
block|,
literal|"512k"
block|,
literal|"  4m"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmap_print_tte_sun4u
parameter_list|(
name|tte_t
name|tag
parameter_list|,
name|tte_t
name|tte
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s "
argument_list|,
name|page_sizes
index|[
operator|(
name|tte
operator|>>
name|TD_SIZE_SHIFT
operator|)
operator|&
name|TD_SIZE_MASK
index|]
argument_list|,
name|tag
operator|&
name|TD_G
condition|?
literal|"G"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_W
condition|?
literal|"W "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_P
condition|?
literal|"\e[33mP\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_E
condition|?
literal|"E "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CV
condition|?
literal|"CV "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CP
condition|?
literal|"CP "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_L
condition|?
literal|"\e[32mL\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_IE
condition|?
literal|"IE "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_NFO
condition|?
literal|"NFO "
else|:
literal|"    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pa=0x%lx va=0x%lx ctx=%ld\n"
argument_list|,
name|TD_PA
argument_list|(
name|tte
argument_list|)
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|tag
argument_list|)
argument_list|,
name|TLB_TAR_CTX
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_print_tlb_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|tte_t
name|tag
decl_stmt|,
name|tte
decl_stmt|;
name|u_long
name|pstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tte
operator|=
name|itlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iTLB-%2u: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmap_print_tte_sun4u
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tte
operator|=
name|dtlb_get_data_sun4u
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|tlb_locked
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dTLB-%2u: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmap_print_tte_sun4u
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

