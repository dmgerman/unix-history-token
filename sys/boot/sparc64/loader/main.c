begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Initial implementation:  * Copyright (c) 2001 Robert Drehmel  * All rights reserved.  *  * As long as the above copyright statement and this notice remain  * unchanged, you can do what ever you want with this file.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * FreeBSD/sparc64 kernel loader - machine dependent part  *  *  - implements copyin and readin functions that map kernel  *    pages on demand.  The machine independent code does not  *    know the size of the kernel early enough to pre-enter  *    TTEs and install just one 4MB mapping seemed to limiting  *    to me.  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/asi.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/lsu.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/upa.h>
end_include

begin_include
include|#
directive|include
file|<machine/ver.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_include
include|#
directive|include
file|"libofw.h"
end_include

begin_include
include|#
directive|include
file|"dev_net.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|bootprog_name
index|[]
decl_stmt|,
name|bootprog_rev
index|[]
decl_stmt|,
name|bootprog_date
index|[]
decl_stmt|,
name|bootprog_maker
index|[]
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|HEAPVA
init|=
literal|0x800000
block|,
name|HEAPSZ
init|=
literal|0x1000000
block|,
name|LOADSZ
init|=
literal|0x1000000
comment|/* for kernel and modules */
block|}
enum|;
end_enum

begin_struct
specifier|static
struct|struct
name|mmu_ops
block|{
name|void
function_decl|(
modifier|*
name|tlb_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|mmu_mapin
function_decl|)
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
function_decl|;
block|}
modifier|*
name|mmu_ops
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
name|kernel_entry_t
parameter_list|(
name|vm_offset_t
name|mdp
parameter_list|,
name|u_long
name|o1
parameter_list|,
name|u_long
name|o2
parameter_list|,
name|u_long
name|o3
parameter_list|,
name|void
modifier|*
name|openfirmware
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data_sun4u
parameter_list|(
name|int
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtlb_enter_sun4u
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|dtlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|u_long
name|itlb_get_data_sun4u
parameter_list|(
name|int
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itlb_enter_sun4u
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|itlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|itlb_relocate_locked0_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|md_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
parameter_list|,
name|vm_offset_t
parameter_list|,
specifier|const
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc64_maphint
parameter_list|(
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|claim_virt
parameter_list|(
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|alloc_phys
parameter_list|(
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_phys
parameter_list|(
name|int
parameter_list|,
name|size_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_phys
parameter_list|(
name|vm_offset_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|exec
function_decl|)
parameter_list|(
name|struct
name|preloaded_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_mapin_sun4u
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_mapin_sun4v
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb_init_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlb_init_sun4v
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_typedef
typedef|typedef
name|u_int64_t
name|tte_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|pmap_print_tlb_sun4u
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_print_tte_sun4u
parameter_list|(
name|tte_t
parameter_list|,
name|tte_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mmu_ops
name|mmu_ops_sun4u
init|=
block|{
name|tlb_init_sun4u
block|,
name|mmu_mapin_sun4u
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mmu_ops
name|mmu_ops_sun4v
init|=
block|{
name|tlb_init_sun4v
block|,
name|mmu_mapin_sun4v
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sun4u */
end_comment

begin_decl_stmt
name|struct
name|tlb_entry
modifier|*
name|dtlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tlb_entry
modifier|*
name|itlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|itlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpu_impl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dtlb_slot_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itlb_slot_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sun4v */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlb_entry
modifier|*
name|tlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_sun4v
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * no direct TLB access on sun4v  * we somewhat arbitrarily declare enough  * slots to cover a 4GB AS with 4MB pages  */
end_comment

begin_define
define|#
directive|define
name|SUN4V_TLB_SLOT_MAX
value|(1<< 10)
end_define

begin_decl_stmt
specifier|static
name|vm_offset_t
name|curkva
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|heapva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|phandle_t
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Machine dependent structures that the machine independent  * loader part uses.  */
end_comment

begin_decl_stmt
name|struct
name|devsw
modifier|*
name|devsw
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_DISK_SUPPORT
operator|&
name|ofwdisk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|netdev
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arch_switch
name|archsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_format
name|sparc64_elf
init|=
block|{
name|__elfN
argument_list|(
name|loadfile
argument_list|)
block|,
name|__elfN
argument_list|(
argument|exec
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
modifier|*
name|file_formats
index|[]
init|=
block|{
operator|&
name|sparc64_elf
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
modifier|*
name|file_system
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_UFS_SUPPORT
operator|&
name|ufs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_CD9660_SUPPORT
operator|&
name|cd9660_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_ZIP_SUPPORT
operator|&
name|zipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_GZIP_SUPPORT
operator|&
name|gzipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_BZIP2_SUPPORT
operator|&
name|bzipfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NFS_SUPPORT
operator|&
name|nfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_TFTP_SUPPORT
operator|&
name|tftp_fsops
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netif_driver
modifier|*
name|netif_drivers
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|ofwnet
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|ofwconsole
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|console
modifier|*
name|consoles
index|[]
init|=
block|{
operator|&
name|ofwconsole
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|watch_phys_set_mask
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_PWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|pa
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|38
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_PW
operator|)
operator|&
operator|~
name|LSU_PM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_PM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_phys_set
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|pa
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_phys_set_mask
argument_list|(
name|pa
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set_mask
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_VWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|va
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|41
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_VW
operator|)
operator|&
operator|~
name|LSU_VM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_VM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|va
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_virt_set_mask
argument_list|(
name|va
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * archsw functions  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
block|{
name|setenv
argument_list|(
literal|"hw.ata.atapi_dma"
argument_list|,
literal|"0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
name|fd
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|)
block|{
name|mmu_ops
operator|->
name|mmu_mapin
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|vm_offset_t
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|mmu_ops
operator|->
name|mmu_mapin
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_maphint
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|mva
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|free_excess
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|is_sun4v
condition|)
return|return;
if|if
condition|(
name|tlb_store
index|[
name|va
operator|>>
literal|22
index|]
operator|.
name|te_pa
operator|!=
operator|-
literal|1
condition|)
return|return;
comment|/* round up to nearest 4MB page */
name|size
operator|=
operator|(
name|len
operator|+
name|PAGE_MASK_4M
operator|)
operator|&
operator|~
name|PAGE_MASK_4M
expr_stmt|;
if|#
directive|if
literal|0
block|pa = alloc_phys(PAGE_SIZE_256M, PAGE_SIZE_256M);  	if (pa != -1) 		free_excess = 1; 	else
endif|#
directive|endif
name|pa
operator|=
name|alloc_phys
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE_256M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|-
literal|1
condition|)
name|pa
operator|=
name|alloc_phys
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|PAGE_SIZE_4M
control|)
block|{
name|mva
operator|=
name|claim_virt
argument_list|(
name|va
operator|+
name|i
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mva
operator|!=
operator|(
name|va
operator|+
name|i
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: can't claim virtual page "
literal|"(wanted %#lx, got %#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|mva
argument_list|)
expr_stmt|;
name|tlb_store
index|[
name|mva
operator|>>
literal|22
index|]
operator|.
name|te_pa
operator|=
name|pa
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|map_phys
argument_list|(
operator|-
literal|1
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
name|mva
argument_list|,
name|pa
operator|+
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: can't map physical page\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free_excess
condition|)
name|release_phys
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE_256M
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * other MD functions  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|claim_virt
parameter_list|(
name|vm_offset_t
name|virt
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|vm_offset_t
name|mva
decl_stmt|;
if|if
condition|(
name|OF_call_method
argument_list|(
literal|"claim"
argument_list|,
name|mmu
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|virt
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|mva
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|mva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|alloc_phys
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|cell_t
name|phys_hi
decl_stmt|,
name|phys_low
decl_stmt|;
if|if
condition|(
name|OF_call_method
argument_list|(
literal|"claim"
argument_list|,
name|memory
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|phys_low
argument_list|,
operator|&
name|phys_hi
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|phys_hi
operator|<<
literal|32
operator||
name|phys_low
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_phys
parameter_list|(
name|int
name|mode
parameter_list|,
name|size_t
name|size
parameter_list|,
name|vm_offset_t
name|virt
parameter_list|,
name|vm_offset_t
name|phys
parameter_list|)
block|{
return|return
operator|(
name|OF_call_method
argument_list|(
literal|"map"
argument_list|,
name|mmu
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|phys
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|phys
operator|>>
literal|32
argument_list|)
argument_list|,
name|virt
argument_list|,
name|size
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_phys
parameter_list|(
name|vm_offset_t
name|phys
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|OF_call_method
argument_list|(
literal|"release"
argument_list|,
name|memory
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|phys
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|phys
operator|>>
literal|32
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|exec
function|)
parameter_list|(
name|struct
name|preloaded_file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|file_metadata
modifier|*
name|fmp
decl_stmt|;
name|vm_offset_t
name|mdp
decl_stmt|;
name|Elf_Addr
name|entry
decl_stmt|;
name|Elf_Ehdr
modifier|*
name|e
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|fmp
operator|=
name|file_findmetadata
argument_list|(
name|fp
argument_list|,
name|MODINFOMD_ELFHDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EFTYPE
operator|)
return|;
name|e
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|&
name|fmp
operator|->
name|md_data
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_load
argument_list|(
name|fp
operator|->
name|f_args
argument_list|,
operator|&
name|mdp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"jumping to kernel entry at %#lx.\n"
argument_list|,
name|e
operator|->
name|e_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dev_cleanup
argument_list|()
expr_stmt|;
name|entry
operator|=
name|e
operator|->
name|e_entry
expr_stmt|;
name|OF_release
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
name|HEAPSZ
argument_list|)
expr_stmt|;
operator|(
operator|(
name|kernel_entry_t
operator|*
operator|)
name|entry
operator|)
operator|(
name|mdp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
name|openfirmware
operator|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: exec returned"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data_sun4u
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
comment|/* 	 * We read ASI_DTLB_DATA_ACCESS_REG twice in order to work 	 * around errata of USIII and beyond. 	 */
operator|(
name|void
operator|)
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_long
name|itlb_get_data_sun4u
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
comment|/* 	 * We read ASI_ITLB_DATA_ACCESS_REG twice in order to work 	 * around errata of USIII and beyond. 	 */
operator|(
name|void
operator|)
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|slot
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|dtlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_long
name|pstate
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_TAG_READ_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLB_TAR_VA
argument_list|(
name|reg
argument_list|)
operator|!=
name|va
condition|)
continue|continue;
name|reg
operator|=
name|dtlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|>>=
name|TD_PA_SHIFT
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCIII
condition|)
return|return
operator|(
name|reg
operator|&
name|TD_PA_CH_MASK
operator|)
return|;
return|return
operator|(
name|reg
operator|&
name|TD_PA_SF_MASK
operator|)
return|;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|itlb_va_to_pa_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_long
name|pstate
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLB_TAR_VA
argument_list|(
name|reg
argument_list|)
operator|!=
name|va
condition|)
continue|continue;
name|reg
operator|=
name|itlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|>>=
name|TD_PA_SHIFT
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCIII
condition|)
return|return
operator|(
name|reg
operator|&
name|TD_PA_CH_MASK
operator|)
return|;
return|return
operator|(
name|reg
operator|&
name|TD_PA_SF_MASK
operator|)
return|;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtlb_enter_sun4u
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|u_long
name|reg
decl_stmt|;
name|reg
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|reg
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_TAR
argument_list|,
name|ASI_DMMU
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|vpn
argument_list|)
operator||
name|TLB_TAR_CTX
argument_list|(
name|TLB_CTX_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_DTLB_DATA_IN_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itlb_enter_sun4u
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
name|u_long
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|reg
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
block|{
comment|/* 		 * Search an unused slot != 0 and explicitly enter the data 		 * and tag there in order to avoid Cheetah+ erratum 34. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|itlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|stxa
argument_list|(
name|AA_IMMU_TAR
argument_list|,
name|ASI_IMMU
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|vpn
argument_list|)
operator||
name|TLB_TAR_CTX
argument_list|(
name|TLB_CTX_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|PROMBASE
argument_list|)
expr_stmt|;
break|break;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: could not find an unused slot"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|stxa
argument_list|(
name|AA_IMMU_TAR
argument_list|,
name|ASI_IMMU
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|vpn
argument_list|)
operator||
name|TLB_TAR_CTX
argument_list|(
name|TLB_CTX_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_ITLB_DATA_IN_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|PROMBASE
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|itlb_relocate_locked0_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|,
name|pstate
decl_stmt|,
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpu_impl
operator|!=
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
return|return;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|=
name|itlb_get_data_sun4u
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|TD_V
operator||
name|TD_L
operator|)
operator|)
operator|!=
operator|(
name|TD_V
operator||
name|TD_L
operator|)
condition|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Flush the mapping of slot 0. */
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DEMAP_VA
argument_list|(
name|TLB_TAR_VA
argument_list|(
name|tag
argument_list|)
argument_list|)
operator||
name|TLB_DEMAP_PRIMARY
operator||
name|TLB_DEMAP_PAGE
argument_list|,
name|ASI_IMMU_DEMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The USIII-family ignores the address. */
comment|/* 	 * Search a replacement slot != 0 and enter the data and tag 	 * that formerly were in slot 0. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|itlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|stxa
argument_list|(
name|AA_IMMU_TAR
argument_list|,
name|ASI_IMMU
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|flush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The USIII-family ignores the address. */
break|break;
block|}
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: could not find a replacement slot"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_mapin_sun4u
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|,
name|mva
decl_stmt|;
name|u_long
name|data
decl_stmt|;
if|if
condition|(
name|va
operator|+
name|len
operator|>
name|curkva
condition|)
name|curkva
operator|=
name|va
operator|+
name|len
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
name|len
operator|+=
name|va
operator|&
name|PAGE_MASK_4M
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK_4M
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|dtlb_va_to_pa_sun4u
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|||
name|itlb_va_to_pa_sun4u
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a physical page, claim the virtual area. */
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
name|pa
operator|=
name|alloc_phys
argument_list|(
name|PAGE_SIZE_4M
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mva
operator|=
name|claim_virt
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mva
operator|!=
name|va
condition|)
name|panic
argument_list|(
literal|"%s: can't claim virtual page "
literal|"(wanted %#lx, got %#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|mva
argument_list|)
expr_stmt|;
comment|/* 				 * The mappings may have changed, be paranoid. 				 */
continue|continue;
block|}
comment|/* 			 * Actually, we can only allocate two pages less at 			 * most (depending on the kernel TSB size). 			 */
if|if
condition|(
name|dtlb_slot
operator|>=
name|dtlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: out of dtlb_slots"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|itlb_slot
operator|>=
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"%s: out of itlb_slots"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|data
operator|=
name|TD_V
operator||
name|TD_4M
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|dtlb_store
index|[
name|dtlb_slot
index|]
operator|.
name|te_pa
operator|=
name|pa
expr_stmt|;
name|dtlb_store
index|[
name|dtlb_slot
index|]
operator|.
name|te_va
operator|=
name|va
expr_stmt|;
name|itlb_store
index|[
name|itlb_slot
index|]
operator|.
name|te_pa
operator|=
name|pa
expr_stmt|;
name|itlb_store
index|[
name|itlb_slot
index|]
operator|.
name|te_va
operator|=
name|va
expr_stmt|;
name|dtlb_slot
operator|++
expr_stmt|;
name|itlb_slot
operator|++
expr_stmt|;
name|dtlb_enter_sun4u
argument_list|(
name|va
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|itlb_enter_sun4u
argument_list|(
name|va
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|len
operator|>
name|PAGE_SIZE_4M
condition|?
name|PAGE_SIZE_4M
else|:
name|len
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|!=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|release_phys
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_mapin_sun4v
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|,
name|mva
decl_stmt|;
if|if
condition|(
name|va
operator|+
name|len
operator|>
name|curkva
condition|)
name|curkva
operator|=
name|va
operator|+
name|len
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
name|len
operator|+=
name|va
operator|&
name|PAGE_MASK_4M
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK_4M
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
operator|(
name|va
operator|>>
literal|22
operator|)
operator|>
name|SUN4V_TLB_SLOT_MAX
condition|)
name|panic
argument_list|(
literal|"%s: trying to map more than 4GB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlb_store
index|[
name|va
operator|>>
literal|22
index|]
operator|.
name|te_pa
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a physical page, claim the virtual area */
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
name|pa
operator|=
name|alloc_phys
argument_list|(
name|PAGE_SIZE_4M
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mva
operator|=
name|claim_virt
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mva
operator|!=
name|va
condition|)
name|panic
argument_list|(
literal|"%s: can't claim virtual page "
literal|"(wanted %#lx, got %#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|mva
argument_list|)
expr_stmt|;
block|}
name|tlb_store
index|[
name|va
operator|>>
literal|22
index|]
operator|.
name|te_pa
operator|=
name|pa
expr_stmt|;
if|if
condition|(
name|map_phys
argument_list|(
operator|-
literal|1
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%s: can't map physical page\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|len
operator|>
name|PAGE_SIZE_4M
condition|?
name|PAGE_SIZE_4M
else|:
name|len
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|!=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|release_phys
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There is no need for continuous physical heap memory. */
name|heapva
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_claim
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HEAPVA
argument_list|,
name|HEAPSZ
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
name|heapva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlb_init_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|phandle_t
name|child
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|u_int
name|bootcpu
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|cpu_impl
operator|=
name|VER_IMPL
argument_list|(
name|rdpr
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|bootcpu
operator|=
name|UPA_CR_GET_MID
argument_list|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_UPA_CONFIG_REG
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|OF_child
argument_list|(
name|root
argument_list|)
init|;
name|child
operator|!=
literal|0
condition|;
name|child
operator|=
name|OF_peer
argument_list|(
name|child
argument_list|)
control|)
block|{
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"device_type"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"cpu"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
name|cpu_impl
operator|<
name|CPU_IMPL_ULTRASPARCIII
condition|?
literal|"upa-portid"
else|:
literal|"portid"
argument_list|,
operator|&
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cpu
operator|==
name|bootcpu
condition|)
break|break;
block|}
if|if
condition|(
name|cpu
operator|!=
name|bootcpu
condition|)
name|panic
argument_list|(
literal|"%s: no node for bootcpu?!?!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"#dtlb-entries"
argument_list|,
operator|&
name|dtlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|dtlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"#itlb-entries"
argument_list|,
operator|&
name|itlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|itlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: can't get TLB slot max."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
block|{
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|printf
argument_list|(
literal|"pre fixup:\n"
argument_list|)
expr_stmt|;
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Relocate the locked entry in it16 slot 0 (if existent) 		 * as part of working around Cheetah+ erratum 34. 		 */
name|itlb_relocate_locked0_sun4u
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADER_DEBUG
name|printf
argument_list|(
literal|"post fixup:\n"
argument_list|)
expr_stmt|;
name|pmap_print_tlb_sun4u
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|dtlb_store
operator|=
name|malloc
argument_list|(
name|dtlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dtlb_store
argument_list|)
argument_list|)
expr_stmt|;
name|itlb_store
operator|=
name|malloc
argument_list|(
name|itlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|itlb_store
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtlb_store
operator|==
name|NULL
operator|||
name|itlb_store
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: can't allocate TLB store"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlb_init_sun4v
parameter_list|(
name|void
parameter_list|)
block|{
name|tlb_store
operator|=
name|malloc
argument_list|(
name|SUN4V_TLB_SLOT_MAX
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tlb_store
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tlb_store
argument_list|,
literal|0xFF
argument_list|,
name|SUN4V_TLB_SLOT_MAX
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tlb_store
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
function_decl|(
modifier|*
name|openfirm
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|bootpath
index|[
literal|64
index|]
decl_stmt|;
name|char
name|compatible
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|devsw
modifier|*
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * Tell the Open Firmware functions where they find the OFW gate. 	 */
name|OF_init
argument_list|(
name|openfirm
argument_list|)
expr_stmt|;
name|archsw
operator|.
name|arch_getdev
operator|=
name|ofw_getdev
expr_stmt|;
name|archsw
operator|.
name|arch_copyin
operator|=
name|sparc64_copyin
expr_stmt|;
name|archsw
operator|.
name|arch_copyout
operator|=
name|ofw_copyout
expr_stmt|;
name|archsw
operator|.
name|arch_readin
operator|=
name|sparc64_readin
expr_stmt|;
name|archsw
operator|.
name|arch_autoload
operator|=
name|sparc64_autoload
expr_stmt|;
name|archsw
operator|.
name|arch_maphint
operator|=
name|sparc64_maphint
expr_stmt|;
name|init_heap
argument_list|()
expr_stmt|;
name|setheap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|heapva
operator|+
name|HEAPSZ
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Probe for a console. 	 */
name|cons_probe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|OF_peer
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: can't get root phandle"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|root
argument_list|,
literal|"compatible"
argument_list|,
name|compatible
argument_list|,
sizeof|sizeof
argument_list|(
name|compatible
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|compatible
argument_list|,
literal|"sun4v"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nBooting with sun4v support.\n"
argument_list|)
expr_stmt|;
name|mmu_ops
operator|=
operator|&
name|mmu_ops_sun4v
expr_stmt|;
name|is_sun4v
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nBooting with sun4u support.\n"
argument_list|)
expr_stmt|;
name|mmu_ops
operator|=
operator|&
name|mmu_ops_sun4u
expr_stmt|;
block|}
name|mmu_ops
operator|->
name|tlb_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize devices. 	 */
for|for
control|(
name|dp
operator|=
name|devsw
init|;
operator|*
name|dp
operator|!=
literal|0
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
operator|!=
literal|0
condition|)
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Set up the current device. 	 */
name|OF_getprop
argument_list|(
name|chosen
argument_list|,
literal|"bootpath"
argument_list|,
name|bootpath
argument_list|,
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Sun compatible bootable CD-ROMs have a disk label placed 	 * before the cd9660 data, with the actual filesystem being 	 * in the first partition, while the other partitions contain 	 * pseudo disk labels with embedded boot blocks for different 	 * architectures, which may be followed by UFS filesystems. 	 * The firmware will set the boot path to the partition it 	 * boots from ('f' in the sun4u case), but we want the kernel 	 * to be loaded from the cd9660 fs ('a'), so the boot path 	 * needs to be altered. 	 */
if|if
condition|(
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
name|printf
argument_list|(
literal|"Boot path set to %s\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
block|}
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|bootpath
argument_list|,
name|ofw_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"loaddev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|bootpath
argument_list|,
name|env_noset
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, Revision %s\n"
argument_list|,
name|bootprog_name
argument_list|,
name|bootprog_rev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s, %s)\n"
argument_list|,
name|bootprog_maker
argument_list|,
name|bootprog_date
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bootpath=\"%s\"\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
comment|/* Give control to the machine independent loader code. */
name|interact
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|reboot
argument_list|,
literal|"reboot"
argument_list|,
literal|"reboot the system"
argument_list|,
name|command_reboot
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|command_reboot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|!=
name|NULL
condition|)
operator|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|)
operator|(
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rebooting...\n"
argument_list|)
expr_stmt|;
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* provide this for panic, as it's not in the startup code */
end_comment

begin_function
name|void
name|exit
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|page_sizes
index|[]
init|=
block|{
literal|"  8k"
block|,
literal|" 64k"
block|,
literal|"512k"
block|,
literal|"  4m"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmap_print_tte_sun4u
parameter_list|(
name|tte_t
name|tag
parameter_list|,
name|tte_t
name|tte
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s "
argument_list|,
name|page_sizes
index|[
operator|(
name|tte
operator|>>
name|TD_SIZE_SHIFT
operator|)
operator|&
name|TD_SIZE_MASK
index|]
argument_list|,
name|tag
operator|&
name|TD_G
condition|?
literal|"G"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_W
condition|?
literal|"W "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_P
condition|?
literal|"\e[33mP\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_E
condition|?
literal|"E "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CV
condition|?
literal|"CV "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CP
condition|?
literal|"CP "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_L
condition|?
literal|"\e[32mL\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_IE
condition|?
literal|"IE "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_NFO
condition|?
literal|"NFO "
else|:
literal|"    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pa=0x%lx va=0x%lx ctx=%ld\n"
argument_list|,
name|TD_PA
argument_list|(
name|tte
argument_list|)
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|tag
argument_list|)
argument_list|,
name|TLB_TAR_CTX
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_print_tlb_sun4u
parameter_list|(
name|void
parameter_list|)
block|{
name|tte_t
name|tag
decl_stmt|,
name|tte
decl_stmt|;
name|u_long
name|pstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pstate
operator|=
name|rdpr
argument_list|(
name|pstate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tte
operator|=
name|itlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iTLB-%2u: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmap_print_tte_sun4u
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtlb_slot_max
condition|;
name|i
operator|++
control|)
block|{
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
operator|&
operator|~
name|PSTATE_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tte
operator|=
name|dtlb_get_data_sun4u
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
name|pstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|tag
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_TAG_READ_REG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dTLB-%2u: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmap_print_tte_sun4u
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

