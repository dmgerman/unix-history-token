begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Initial implementation:  * Copyright (c) 2001 Robert Drehmel  * All rights reserved.  *  * As long as the above copyright statement and this notice remain  * unchanged, you can do what ever you want with this file.   *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * FreeBSD/sparc64 kernel loader - machine dependent part  *  *  - implements copyin and readin functions that map kernel  *    pages on demand.  The machine independent code does not  *    know the size of the kernel early enough to pre-enter  *    TTEs and install just one 4MB mapping seemed to limiting  *    to me.  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/asi.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/lsu.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/upa.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_include
include|#
directive|include
file|"libofw.h"
end_include

begin_include
include|#
directive|include
file|"dev_net.h"
end_include

begin_enum
enum|enum
block|{
name|HEAPVA
init|=
literal|0x800000
block|,
name|HEAPSZ
init|=
literal|0x1000000
block|,
name|LOADSZ
init|=
literal|0x1000000
comment|/* for kernel and modules */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|memory_slice
block|{
name|vm_offset_t
name|pstart
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
name|kernel_entry_t
parameter_list|(
name|vm_offset_t
name|mdp
parameter_list|,
name|u_long
name|o1
parameter_list|,
name|u_long
name|o2
parameter_list|,
name|u_long
name|o3
parameter_list|,
name|void
modifier|*
name|openfirmware
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|void
name|itlb_enter
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dtlb_enter
parameter_list|(
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|itlb_va_to_pa
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|dtlb_va_to_pa
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_offset_t
name|md_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|vm_offset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|elf_exec
parameter_list|(
name|struct
name|preloaded_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mmu_mapin
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|__progname
index|[]
init|=
literal|"FreeBSD/sparc64 loader"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tte
modifier|*
name|dtlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tte
modifier|*
name|itlb_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|itlb_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtlb_slot_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|itlb_slot_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|curkva
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|heapva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|phandle_t
name|pmemh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OFW memory handle */
end_comment

begin_decl_stmt
name|struct
name|memory_slice
name|memslices
index|[
literal|18
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ofw_devdesc
name|bootdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Machine dependent structures that the machine independent  * loader part uses.  */
end_comment

begin_decl_stmt
name|struct
name|devsw
modifier|*
name|devsw
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_DISK_SUPPORT
operator|&
name|ofwdisk
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|netdev
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arch_switch
name|archsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
name|sparc64_elf
init|=
block|{
name|elf_loadfile
block|,
name|elf_exec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_format
modifier|*
name|file_formats
index|[]
init|=
block|{
operator|&
name|sparc64_elf
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
modifier|*
name|file_system
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_UFS_SUPPORT
operator|&
name|ufs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_CD9660_SUPPORT
operator|&
name|cd9660_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|nfs_fsops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADER_TFTP_SUPPORT
operator|&
name|tftp_fsops
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netif_driver
modifier|*
name|netif_drivers
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LOADER_NET_SUPPORT
operator|&
name|ofwnet
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|console
name|ofwconsole
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|console
modifier|*
name|consoles
index|[]
init|=
block|{
operator|&
name|ofwconsole
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|watch_phys_set_mask
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_PWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|pa
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|38
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_PW
operator|)
operator|&
operator|~
name|LSU_PM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_PM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_phys_set
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|pa
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_phys_set_mask
argument_list|(
name|pa
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set_mask
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_VWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|va
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|41
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_VW
operator|)
operator|&
operator|~
name|LSU_VM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_VM_SHIFT
operator|)
expr_stmt|;
name|stxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_virt_set
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|va
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_virt_set_mask
argument_list|(
name|va
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * archsw functions  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_autoload
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"nothing to autoload yet.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_readin
parameter_list|(
specifier|const
name|int
name|fd
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|)
block|{
name|mmu_mapin
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sparc64_copyin
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|vm_offset_t
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|mmu_mapin
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * other MD functions  */
end_comment

begin_function
specifier|static
name|int
name|elf_exec
parameter_list|(
name|struct
name|preloaded_file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|file_metadata
modifier|*
name|fmp
decl_stmt|;
name|vm_offset_t
name|mdp
decl_stmt|;
name|Elf_Ehdr
modifier|*
name|e
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|fmp
operator|=
name|file_findmetadata
argument_list|(
name|fp
argument_list|,
name|MODINFOMD_ELFHDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|EFTYPE
return|;
block|}
name|e
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|&
name|fmp
operator|->
name|md_data
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_load
argument_list|(
name|fp
operator|->
name|f_args
argument_list|,
operator|&
name|mdp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|printf
argument_list|(
literal|"jumping to kernel entry at %#lx.\n"
argument_list|,
name|e
operator|->
name|e_entry
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pmap_print_tlb('i'); 	pmap_print_tlb('d');
endif|#
directive|endif
operator|(
operator|(
name|kernel_entry_t
operator|*
operator|)
name|e
operator|->
name|e_entry
operator|)
operator|(
name|mdp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
name|openfirmware
operator|)
expr_stmt|;
name|panic
argument_list|(
literal|"exec returned"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mmu_mapin
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|,
name|mva
decl_stmt|;
name|struct
name|tte
name|tte
decl_stmt|;
if|if
condition|(
name|va
operator|+
name|len
operator|>
name|curkva
condition|)
name|curkva
operator|=
name|va
operator|+
name|len
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
name|len
operator|+=
name|va
operator|&
name|PAGE_MASK_4M
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK_4M
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|dtlb_va_to_pa
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
operator|||
name|itlb_va_to_pa
argument_list|(
name|va
argument_list|)
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Allocate a physical page, claim the virtual area */
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
block|{
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_alloc_phys
argument_list|(
name|PAGE_SIZE_4M
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|mva
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_claim_virt
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE_4M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mva
operator|!=
name|va
condition|)
block|{
name|panic
argument_list|(
literal|"can't claim virtual page "
literal|"(wanted %#lx, got %#lx)"
argument_list|,
name|va
argument_list|,
name|mva
argument_list|)
expr_stmt|;
block|}
comment|/* The mappings may have changed, be paranoid. */
continue|continue;
block|}
comment|/* 			 * Actually, we can only allocate two pages less at 			 * most (depending on the kernel TSB size). 			 */
if|if
condition|(
name|dtlb_slot
operator|>=
name|dtlb_slot_max
condition|)
name|panic
argument_list|(
literal|"mmu_mapin: out of dtlb_slots"
argument_list|)
expr_stmt|;
if|if
condition|(
name|itlb_slot
operator|>=
name|itlb_slot_max
condition|)
name|panic
argument_list|(
literal|"mmu_mapin: out of itlb_slots"
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|TD_V
operator||
name|TD_4M
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|dtlb_store
index|[
name|dtlb_slot
operator|++
index|]
operator|=
name|tte
expr_stmt|;
name|itlb_store
index|[
name|itlb_slot
operator|++
index|]
operator|=
name|tte
expr_stmt|;
name|dtlb_enter
argument_list|(
name|tte
operator|.
name|tte_vpn
argument_list|,
name|tte
operator|.
name|tte_data
argument_list|)
expr_stmt|;
name|itlb_enter
argument_list|(
name|tte
operator|.
name|tte_vpn
argument_list|,
name|tte
operator|.
name|tte_data
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|len
operator|>
name|PAGE_SIZE_4M
condition|?
name|PAGE_SIZE_4M
else|:
name|len
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|!=
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
condition|)
name|OF_release_phys
argument_list|(
name|pa
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|init_heap
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pmemh
operator|=
name|OF_finddevice
argument_list|(
literal|"/memory"
argument_list|)
operator|)
operator|==
operator|(
name|phandle_t
operator|)
operator|-
literal|1
condition|)
name|OF_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmemh
argument_list|,
literal|"available"
argument_list|,
name|memslices
argument_list|,
sizeof|sizeof
argument_list|(
name|memslices
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|OF_exit
argument_list|()
expr_stmt|;
comment|/* There is no need for continuous physical heap memory. */
name|heapva
operator|=
operator|(
name|vm_offset_t
operator|)
name|OF_claim
argument_list|(
operator|(
name|void
operator|*
operator|)
name|HEAPVA
argument_list|,
name|HEAPSZ
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|heapva
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlb_init
parameter_list|(
name|void
parameter_list|)
block|{
name|phandle_t
name|child
decl_stmt|;
name|phandle_t
name|root
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|u_int
name|bootcpu
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|bootcpu
operator|=
name|UPA_CR_GET_MID
argument_list|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_UPA_CONFIG_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|OF_peer
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"main: OF_peer"
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|OF_child
argument_list|(
name|root
argument_list|)
init|;
name|child
operator|!=
literal|0
condition|;
name|child
operator|=
name|OF_peer
argument_list|(
name|child
argument_list|)
control|)
block|{
if|if
condition|(
name|child
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"main: OF_child"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"device_type"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"cpu"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"upa-portid"
argument_list|,
operator|&
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"main: OF_getprop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|bootcpu
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|cpu
operator|!=
name|bootcpu
condition|)
name|panic
argument_list|(
literal|"init_tlb: no node for bootcpu?!?!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"#dtlb-entries"
argument_list|,
operator|&
name|dtlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|dtlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"#itlb-entries"
argument_list|,
operator|&
name|itlb_slot_max
argument_list|,
sizeof|sizeof
argument_list|(
name|itlb_slot_max
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"init_tlb: OF_getprop"
argument_list|)
expr_stmt|;
name|dtlb_store
operator|=
name|malloc
argument_list|(
name|dtlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dtlb_store
argument_list|)
argument_list|)
expr_stmt|;
name|itlb_store
operator|=
name|malloc
argument_list|(
name|itlb_slot_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|itlb_store
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtlb_store
operator|==
name|NULL
operator|||
name|itlb_store
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"init_tlb: malloc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
function_decl|(
modifier|*
name|openfirm
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|bootpath
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|devsw
modifier|*
modifier|*
name|dp
decl_stmt|;
name|phandle_t
name|chosenh
decl_stmt|;
comment|/* 	 * Tell the OpenFirmware functions where they find the ofw gate. 	 */
name|OF_init
argument_list|(
name|openfirm
argument_list|)
expr_stmt|;
name|archsw
operator|.
name|arch_getdev
operator|=
name|ofw_getdev
expr_stmt|;
name|archsw
operator|.
name|arch_copyin
operator|=
name|sparc64_copyin
expr_stmt|;
name|archsw
operator|.
name|arch_copyout
operator|=
name|ofw_copyout
expr_stmt|;
name|archsw
operator|.
name|arch_readin
operator|=
name|sparc64_readin
expr_stmt|;
name|archsw
operator|.
name|arch_autoload
operator|=
name|sparc64_autoload
expr_stmt|;
ifdef|#
directive|ifdef
name|ELF_CRC32
name|archsw
operator|.
name|arch_crc32
operator|=
name|sparc64_crc32
expr_stmt|;
endif|#
directive|endif
name|init_heap
argument_list|()
expr_stmt|;
name|setheap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|heapva
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|heapva
operator|+
name|HEAPSZ
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Probe for a console. 	 */
name|cons_probe
argument_list|()
expr_stmt|;
name|tlb_init
argument_list|()
expr_stmt|;
name|bcache_init
argument_list|(
literal|32
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize devices. 	 */
for|for
control|(
name|dp
operator|=
name|devsw
init|;
operator|*
name|dp
operator|!=
literal|0
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
operator|!=
literal|0
condition|)
operator|(
operator|*
name|dp
operator|)
operator|->
name|dv_init
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Set up the current device. 	 */
name|chosenh
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|chosenh
argument_list|,
literal|"bootpath"
argument_list|,
name|bootpath
argument_list|,
sizeof|sizeof
argument_list|(
name|bootpath
argument_list|)
argument_list|)
expr_stmt|;
name|bootdev
operator|.
name|d_type
operator|=
name|ofw_devicetype
argument_list|(
name|bootpath
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bootdev
operator|.
name|d_type
condition|)
block|{
case|case
name|DEVT_DISK
case|:
name|bootdev
operator|.
name|d_dev
operator|=
operator|&
name|ofwdisk
expr_stmt|;
comment|/* 		 * Sun compatible bootable CD-ROMs have a disk label placed 		 * before the cd9660 data, with the actual file system being 		 * in the first partition, while the other partitions contain 		 * pseudo disk labels with embedded boot blocks for different 		 * architectures, which may be followed by UFS file systems. 		 * The firmware will set the boot path to the partition it 		 * boots from ('f' in the sun4u case), but we want the kernel 		 * to be loaded from the cd9660 fs ('a'), so the boot path 		 * needs to be altered. 		 */
if|if
condition|(
name|strstr
argument_list|(
name|bootpath
argument_list|,
literal|"cdrom"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|bootpath
index|[
name|strlen
argument_list|(
name|bootpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
name|printf
argument_list|(
literal|"Boot path set to %s\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|bootdev
operator|.
name|d_kind
operator|.
name|ofwdisk
operator|.
name|path
argument_list|,
name|bootpath
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ofw_parseofwdev
argument_list|(
operator|&
name|bootdev
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVT_NET
case|:
name|bootdev
operator|.
name|d_dev
operator|=
operator|&
name|netdev
expr_stmt|;
name|strncpy
argument_list|(
name|bootdev
operator|.
name|d_kind
operator|.
name|netif
operator|.
name|path
argument_list|,
name|bootpath
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|bootdev
operator|.
name|d_kind
operator|.
name|netif
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|env_setenv
argument_list|(
literal|"currdev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|ofw_fmtdev
argument_list|(
operator|&
name|bootdev
argument_list|)
argument_list|,
name|ofw_setcurrdev
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|env_setenv
argument_list|(
literal|"loaddev"
argument_list|,
name|EV_VOLATILE
argument_list|,
name|ofw_fmtdev
argument_list|(
operator|&
name|bootdev
argument_list|)
argument_list|,
name|env_noset
argument_list|,
name|env_nounset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bootpath=\"%s\"\n"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"loaddev=%s\n"
argument_list|,
name|getenv
argument_list|(
literal|"loaddev"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Give control to the machine independent loader code. */
name|interact
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|COMMAND_SET
argument_list|(
name|reboot
argument_list|,
literal|"reboot"
argument_list|,
literal|"reboot the system"
argument_list|,
name|command_reboot
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|command_reboot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|!=
name|NULL
condition|)
operator|(
name|devsw
index|[
name|i
index|]
operator|->
name|dv_cleanup
operator|)
operator|(
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rebooting...\n"
argument_list|)
expr_stmt|;
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* provide this for panic, as it's not in the startup code */
end_comment

begin_function
name|void
name|exit
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|OF_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOADER_DEBUG
end_ifdef

begin_typedef
typedef|typedef
name|u_int64_t
name|tte_t
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|page_sizes
index|[]
init|=
block|{
literal|"  8k"
block|,
literal|" 64k"
block|,
literal|"512k"
block|,
literal|"  4m"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmap_print_tte
parameter_list|(
name|tte_t
name|tag
parameter_list|,
name|tte_t
name|tte
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s "
argument_list|,
name|page_sizes
index|[
operator|(
name|tte
operator|&
name|TD_SIZE_MASK
operator|)
operator|>>
name|TD_SIZE_SHIFT
index|]
argument_list|,
name|tag
operator|&
name|TD_G
condition|?
literal|"G"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_W
condition|?
literal|"W "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_P
condition|?
literal|"\e[33mP\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_E
condition|?
literal|"E "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CV
condition|?
literal|"CV "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_CP
condition|?
literal|"CP "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_L
condition|?
literal|"\e[32mL\e[0m "
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_IE
condition|?
literal|"IE "
else|:
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tte
operator|&
name|TD_NFO
condition|?
literal|"NFO "
else|:
literal|"    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tag=0x%lx pa=0x%lx va=0x%lx ctx=%ld\n"
argument_list|,
name|tag
argument_list|,
name|TD_PA
argument_list|(
name|tte
argument_list|)
argument_list|,
name|TT_VA
argument_list|(
name|tag
argument_list|)
argument_list|,
name|TT_CTX
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_print_tlb
parameter_list|(
name|char
name|which
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tte_t
name|tte
decl_stmt|,
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|*
literal|8
condition|;
name|i
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|which
operator|==
literal|'i'
condition|)
block|{
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tag) : "r" (i), 			    "i" (ASI_ITLB_TAG_READ_REG));
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tte) : "r" (i), 			    "i" (ASI_ITLB_DATA_ACCESS_REG));
block|}
else|else
block|{
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tag) : "r" (i), 			    "i" (ASI_DTLB_TAG_READ_REG));
asm|__asm__
specifier|__volatile__
asm|("ldxa	[%1] %2, %0\n" : 			    "=r" (tte) : "r" (i), 			    "i" (ASI_DTLB_DATA_ACCESS_REG));
block|}
if|if
condition|(
operator|!
operator|(
name|tte
operator|&
name|TD_V
operator|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%cTLB-%2u: "
argument_list|,
name|which
argument_list|,
name|i
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|pmap_print_tte
argument_list|(
name|tag
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

