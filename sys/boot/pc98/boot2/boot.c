begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, [92/04/03  16:51:14  rvb]  */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989, 1990, 1991, 1992    by Intel Corporation, Santa Clara, California.                  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_define
define|#
directive|define
name|ouraddr
value|(BOOTSEG<< 4)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|BOOT_CONFIG_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|BOOT_HELP_SIZE
value|2048
end_define

begin_define
define|#
directive|define
name|KERNEL_CONFIG_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|NAMEBUF_LEN
value|1024
end_define

begin_comment
comment|/* oversized to defend against gets() */
end_comment

begin_decl_stmt
specifier|static
name|char
name|boot_config
index|[
name|BOOT_CONFIG_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|boot_help
index|[
name|BOOT_HELP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|kernel_config
index|[
name|KERNEL_CONFIG_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|char
name|kernel_config_namebuf
index|[
name|NAMEBUF_LEN
operator|+
sizeof|sizeof
expr|"config"]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|linebuf
index|[
name|NAMEBUF_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|namebuf
index|[
name|NAMEBUF_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loadflags
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|getbootdev
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loadprog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readfile
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NORETURN */
end_comment

begin_function
name|void
name|boot
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|char
name|disk_equips
decl_stmt|;
comment|/* Pick up the story from the Bios on geometry of disks */
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
literal|2
condition|;
name|ret
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|V
argument_list|(
literal|0xA155d
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|ret
operator|)
condition|)
block|{
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|ret
index|]
operator|=
name|get_diskinfo
argument_list|(
name|ret
operator|+
literal|0x80
argument_list|)
expr_stmt|;
block|}
block|}
name|bootinfo
operator|.
name|bi_basemem
operator|=
name|memsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_extmem
operator|=
name|memsize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_memsizes_valid
operator|=
literal|1
expr_stmt|;
name|gateA20
argument_list|()
expr_stmt|;
comment|/* set machine type to PC98_SYSTEM_PARAMETER */
name|machine_check
argument_list|()
expr_stmt|;
comment|/* 	 * The default boot device is the first partition in the 	 * compatibility slice on the boot drive. 	 */
name|dosdev
operator|=
name|drive
expr_stmt|;
name|maj
operator|=
operator|(
name|drive
operator|&
literal|0x70
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* a good first bet */
if|if
condition|(
name|maj
operator|==
literal|4
condition|)
block|{
comment|/* da */
name|disk_equips
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|V
argument_list|(
literal|0xA1482
argument_list|)
expr_stmt|;
name|unit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|drive
operator|&
literal|0x0f
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|media
init|=
operator|(
operator|(
name|unsigned
operator|*
operator|)
name|V
argument_list|(
literal|0xA1460
argument_list|)
operator|)
index|[
name|i
index|]
operator|&
literal|0x1F
decl_stmt|;
if|if
condition|(
operator|(
name|disk_equips
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
comment|/* HD */
name|unit
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|media
operator|==
literal|7
condition|)
comment|/* MO */
name|unit
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|unit
operator|=
name|drive
operator|&
literal|0x0f
expr_stmt|;
block|}
name|readfile
argument_list|(
literal|"boot.config"
argument_list|,
name|boot_config
argument_list|,
name|BOOT_CONFIG_SIZE
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"/boot/loader"
expr_stmt|;
if|if
condition|(
name|boot_config
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|getbootdev
argument_list|(
name|boot_config
argument_list|,
operator|&
name|loadflags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"boot.config: %s"
argument_list|,
name|boot_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|openrd
argument_list|()
operator|!=
literal|0
condition|)
name|name
operator|=
literal|"kernel"
expr_stmt|;
block|}
name|loadstart
label|:
comment|/* print this all each time.. (saves space to do so) */
comment|/* If we have looped, use the previous entries as defaults */
name|printf
argument_list|(
literal|"\r \n>> FreeBSD BOOT @ 0x%x: %d/%d k of memory, %s%s console\n"
literal|"Boot default: %d:%s(%d,%c)%s\n"
literal|"%s\n"
literal|"boot: "
argument_list|,
name|ouraddr
argument_list|,
name|bootinfo
operator|.
name|bi_basemem
argument_list|,
name|bootinfo
operator|.
name|bi_extmem
argument_list|,
operator|(
name|loadflags
operator|&
name|RB_SERIAL
operator|)
condition|?
literal|"serial"
else|:
literal|"internal"
argument_list|,
operator|(
name|loadflags
operator|&
name|RB_DUAL
operator|)
condition|?
literal|"/dual"
else|:
literal|""
argument_list|,
name|dosdev
operator|&
literal|0x0f
argument_list|,
name|devs
index|[
name|maj
index|]
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|part
argument_list|,
name|name
condition|?
name|name
else|:
literal|"*specify_a_kernel_name*"
argument_list|,
name|boot_help
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore flags from previous attempted boot, if any. 	 * XXX this is now too strict.  Settings given in boot.config should 	 * not be changed. 	 */
name|loadflags
operator|&=
operator|(
name|RB_DUAL
operator||
name|RB_SERIAL
operator|)
expr_stmt|;
comment|/* 	 * Be paranoid and make doubly sure that the input buffer is empty. 	 */
if|if
condition|(
name|loadflags
operator|&
operator|(
name|RB_DUAL
operator||
name|RB_SERIAL
operator|)
condition|)
name|init_serial
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gets
argument_list|(
name|linebuf
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|getbootdev
argument_list|(
name|linebuf
argument_list|,
operator|&
name|loadflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|loadstart
goto|;
name|ret
operator|=
name|openrd
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Can't find %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
comment|/*	if (inode.i_mode&IEXEC) 		loadflags |= RB_KDB; */
name|loadprog
argument_list|()
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|loadprog
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|exec
name|head
decl_stmt|;
name|int
name|startaddr
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* physical address.. not directly useable */
name|int
name|bootdev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|pad
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|poff
operator|=
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/*if(poff==0) 		poff = 32;*/
comment|/* 	 * We assume that the entry address is the same as the lowest text 	 * address and that the kernel startup code handles relocation by 	 * this address rounded down to a multiple of 16M. 	 */
name|startaddr
operator|=
name|head
operator|.
name|a_entry
operator|&
literal|0x00FFFFFF
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|printf
argument_list|(
literal|"Booting %d:%s(%d,%c)%s @ 0x%x\n"
argument_list|,
name|dosdev
operator|&
literal|0x0f
argument_list|,
name|devs
index|[
name|maj
index|]
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|part
argument_list|,
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0x00100000
condition|)
block|{
comment|/* 		 * Bail out, instead of risking to damage the BIOS 		 * variables, the loader, or the adapter memory area. 		 * We don't support loading below 1 MB any more. 		 */
name|printf
argument_list|(
literal|"Start address too low\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"text=0x%x "
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* LOAD THE TEXT SEGMENT				*/
comment|/********************************************************/
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
expr_stmt|;
comment|/********************************************************/
comment|/* Load the Initialised data after the text		*/
comment|/********************************************************/
while|while
condition|(
name|addr
operator|&
name|PAGE_MASK
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|addr
operator|++
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"data=0x%x "
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/********************************************************/
comment|/* Skip over the uninitialised data			*/
comment|/* (but clear it)					*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"bss=0x%x "
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
comment|/*  * XXX however, we should be checking that we don't load ... into  * nonexistent memory.  A full symbol table is unlikely to fit on 4MB  * machines.  */
comment|/* kzip& kernel will zero their own bss */
name|addr
operator|+=
name|head
operator|.
name|a_bss
expr_stmt|;
comment|/* Pad to a page boundary. */
name|pad
operator|=
operator|(
name|unsigned
operator|)
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|PAGE_SIZE
operator|-
name|pad
expr_stmt|;
name|addr
operator|+=
name|pad
expr_stmt|;
block|}
name|bootinfo
operator|.
name|bi_symtab
operator|=
name|addr
expr_stmt|;
comment|/********************************************************/
comment|/* Copy the symbol table size				*/
comment|/********************************************************/
name|pcpy
argument_list|(
operator|&
name|head
operator|.
name|a_syms
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the symbol table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"symbols=[+0x%x+0x%x+0x%x"
argument_list|,
name|pad
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_syms
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table size				*/
comment|/********************************************************/
name|read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"+0x%x+0x%x]\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
name|bootinfo
operator|.
name|bi_esymtab
operator|=
name|addr
expr_stmt|;
comment|/* 	 * For backwards compatibility, use the previously-unused adaptor 	 * and controller bitfields to hold the slice number. 	 */
name|bootdev
operator|=
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
operator|(
name|slice
operator|>>
literal|4
operator|)
argument_list|,
name|slice
operator|&
literal|0xf
argument_list|,
name|unit
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_version
operator|=
name|BOOTINFO_VERSION
expr_stmt|;
name|bootinfo
operator|.
name|bi_kernelname
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|name
operator|+
name|ouraddr
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_nfs_diskless
operator|=
literal|0
expr_stmt|;
name|bootinfo
operator|.
name|bi_size
operator|=
sizeof|sizeof
argument_list|(
name|bootinfo
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_bios_dev
operator|=
name|dosdev
expr_stmt|;
comment|/* 	 * Load the kernel config file (if any).  Its name is given by 	 * appending ".config" to the kernel name.  Build the name inline 	 * because no str*() functions are available.  The file has to be 	 * copied to&disklabel for userconfig.  It can't be loaded there 	 * directly because the label is used late in readfile() in some 	 * unusual cases. 	 */
name|s
operator|=
name|name
expr_stmt|;
name|t
operator|=
name|kernel_config_namebuf
expr_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
do|;
name|s
operator|=
literal|".config"
expr_stmt|;
operator|--
name|t
expr_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
do|;
name|readfile
argument_list|(
name|kernel_config_namebuf
argument_list|,
name|kernel_config
argument_list|,
name|KERNEL_CONFIG_SIZE
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
name|kernel_config
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|disklabel
operator|+
name|ouraddr
argument_list|,
name|KERNEL_CONFIG_SIZE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total=0x%x entry point=0x%x\n"
argument_list|,
name|addr
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
name|startaddr
argument_list|,
name|loadflags
operator||
name|RB_BOOTINFO
argument_list|,
name|bootdev
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|bootinfo
operator|+
name|ouraddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readfile
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|int
name|openstatus
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|path
expr_stmt|;
name|openstatus
operator|=
name|openrd
argument_list|()
expr_stmt|;
if|if
condition|(
name|openstatus
operator|==
literal|0
condition|)
block|{
comment|/* XXX no way to determine file size. */
name|read
argument_list|(
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getbootdev
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|howto
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the flags to save some bytes. */
name|f
operator|=
operator|*
name|howto
expr_stmt|;
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextarg
label|:
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|nextarg
goto|;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
name|f
operator||=
name|RB_ASKNAME
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'C'
condition|)
name|f
operator||=
name|RB_CDROM
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
name|f
operator|^=
name|RB_DUAL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
name|f
operator||=
name|RB_KDB
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
name|f
operator||=
name|RB_GDB
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'h'
condition|)
name|f
operator|^=
name|RB_SERIAL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'P'
condition|)
name|f
operator||=
name|RB_PROBEKBD
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|f
operator||=
name|RB_DFLTROOT
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
name|f
operator||=
name|RB_SINGLE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
name|f
operator||=
name|RB_VERBOSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|=
name|name
operator|=
name|namebuf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|ptr
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|&
name|RB_PROBEKBD
condition|)
block|{
if|if
condition|(
name|probe_keyboard
argument_list|()
condition|)
block|{
name|f
operator||=
name|RB_DUAL
operator||
name|RB_SERIAL
expr_stmt|;
name|printf
argument_list|(
literal|"No keyboard found\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Keyboard found\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|&
operator|(
name|RB_DUAL
operator||
name|RB_SERIAL
operator|)
condition|)
name|init_serial
argument_list|()
expr_stmt|;
operator|*
name|howto
operator|=
name|f
expr_stmt|;
block|}
end_function

end_unit

