begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, Revision 2.2  92/04/04  11:35:49  rpd  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Ported to PC-9801 by Yoshio Kimura  */
end_comment

begin_comment
comment|/*  * 93/10/08  bde  *	If there is no 386BSD partition, initialize the label sector with  *	LABELSECTOR instead of with garbage.  *  * 93/08/22  bde  *	Fixed reading of bad sector table.  It is at the end of the 'c'  *	partition, which is not always at the end of the disk.  */
end_comment

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_define
define|#
directive|define
name|BIOS_DEV_FLOPPY
value|0x0
end_define

begin_define
define|#
directive|define
name|BIOS_DEV_WIN
value|0x80
end_define

begin_define
define|#
directive|define
name|BPS
value|512
end_define

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|(((di)>>8)&0xff)
end_define

begin_decl_stmt
specifier|static
name|int
name|spt
decl_stmt|,
name|spc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dosdev
decl_stmt|,
name|unit
decl_stmt|,
name|slice
decl_stmt|,
name|part
decl_stmt|,
name|maj
decl_stmt|,
name|boff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*#define EMBEDDED_DISKLABEL 1*/
end_comment

begin_comment
comment|/* Read ahead buffer large enough for one track on a 1440K floppy.  For  * reading from floppies, the bootstrap has to be loaded on a 64K boundary  * to ensure that this buffer doesn't cross a 64K DMA boundary.  */
end_comment

begin_define
define|#
directive|define
name|RA_SECTORS
value|18
end_define

begin_decl_stmt
specifier|static
name|char
name|ra_buf
index|[
name|RA_SECTORS
operator|*
name|BPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_first
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|int
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|devopen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dos_partition
modifier|*
name|dptr
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sector
init|=
literal|0
decl_stmt|,
name|di
decl_stmt|,
name|dosdev_copy
decl_stmt|;
name|dosdev_copy
operator|=
name|dosdev
expr_stmt|;
name|di
operator|=
name|get_diskinfo
argument_list|(
name|dosdev_copy
argument_list|)
expr_stmt|;
name|spc
operator|=
operator|(
name|spt
operator|=
name|SPT
argument_list|(
name|di
argument_list|)
operator|)
operator|*
name|HEADS
argument_list|(
name|di
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RAWBOOT
if|if
condition|(
operator|(
name|dosdev_copy
operator|&
literal|0xf0
operator|)
operator|==
literal|0x90
condition|)
block|{
name|boff
operator|=
literal|0
expr_stmt|;
name|part
operator|=
operator|(
name|spt
operator|==
literal|15
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EMBEDDED_DISKLABEL
name|dl
operator|=
operator|&
name|disklabel
expr_stmt|;
else|#
directive|else
else|EMBEDDED_DISKLABEL
ifdef|#
directive|ifdef
name|PC98
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
name|p
expr_stmt|;
name|slice
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|dptr
operator|++
control|)
if|if
condition|(
name|dptr
operator|->
name|dp_mid
operator|==
name|DOSPTYP_386BSD
condition|)
block|{
name|slice
operator|=
name|BASE_SLICE
operator|+
name|i
expr_stmt|;
name|sector
operator|=
name|dptr
operator|->
name|dp_scyl
operator|*
name|spc
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|Bread
argument_list|(
name|dosdev
argument_list|,
name|sector
operator|+
name|LABELSECTOR
argument_list|)
expr_stmt|;
name|dl
operator|=
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|disklabel
operator|=
operator|*
name|dl
expr_stmt|;
comment|/* structure copy (maybe useful later)*/
else|#
directive|else
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dptr
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
operator|(
name|p
operator|+
name|DOSPARTOFF
operator|)
expr_stmt|;
name|slice
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|dptr
operator|++
control|)
if|if
condition|(
name|dptr
operator|->
name|dp_typ
operator|==
name|DOSPTYP_386BSD
condition|)
block|{
name|slice
operator|=
name|BASE_SLICE
operator|+
name|i
expr_stmt|;
name|sector
operator|=
name|dptr
operator|->
name|dp_start
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
name|sector
operator|+
name|LABELSECTOR
argument_list|)
expr_stmt|;
name|dl
operator|=
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|disklabel
operator|=
operator|*
name|dl
expr_stmt|;
comment|/* structure copy (maybe useful later)*/
endif|#
directive|endif
comment|/* PC98 */
endif|#
directive|endif
endif|EMBEDDED_DISKLABEL
if|if
condition|(
name|dl
operator|->
name|d_magic
operator|!=
name|DISKMAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"bad disklabel\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|maj
operator|==
literal|4
operator|)
operator|||
operator|(
name|maj
operator|==
literal|0
operator|)
operator|||
operator|(
name|maj
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|d_type
operator|==
name|DTYPE_SCSI
condition|)
block|{
name|maj
operator|=
literal|4
expr_stmt|;
comment|/* use scsi as boot dev */
block|}
else|else
block|{
name|maj
operator|=
literal|0
expr_stmt|;
comment|/* must be ESDI/IDE */
block|}
block|}
comment|/* This little trick is for OnTrack DiskManager disks */
name|boff
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|-
name|dl
operator|->
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_offset
operator|+
name|sector
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|bsize
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"empty partition\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* RAWBOOT */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Be aware that cnt is rounded up to N*BPS  */
end_comment

begin_function
name|void
name|devread
parameter_list|(
name|char
modifier|*
name|iodest
parameter_list|,
name|int
name|sector
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dosdev_copy
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|cnt
condition|;
name|offset
operator|+=
name|BPS
control|)
block|{
name|dosdev_copy
operator|=
name|dosdev
expr_stmt|;
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
name|sector
operator|++
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|iodest
operator|+
name|offset
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|int
name|sector
parameter_list|)
block|{
if|if
condition|(
name|dosdev
operator|!=
name|ra_dev
operator|||
name|sector
operator|<
name|ra_first
operator|||
name|sector
operator|>=
name|ra_end
condition|)
block|{
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|cyl
operator|=
name|sector
operator|/
name|spc
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
name|cyl
operator|>
literal|1023
condition|)
block|{
name|printf
argument_list|(
literal|"Error: C:%d> 1023 (BIOS limit)\n"
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
comment|/* loop forever */
block|}
endif|#
directive|endif
name|head
operator|=
operator|(
name|sector
operator|%
name|spc
operator|)
operator|/
name|spt
expr_stmt|;
name|sec
operator|=
name|sector
operator|%
name|spt
expr_stmt|;
name|nsec
operator|=
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|RA_SECTORS
condition|)
name|nsec
operator|=
name|RA_SECTORS
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
if|if
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nsec
operator|=
literal|1
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
while|while
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: D:0x%x C:%d H:%d S:%d\n"
argument_list|,
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
block|}
block|}
name|ra_dev
operator|=
name|dosdev
expr_stmt|;
name|ra_first
operator|=
name|sector
expr_stmt|;
name|ra_end
operator|=
name|sector
operator|+
name|nsec
expr_stmt|;
block|}
return|return
operator|(
name|ra_buf
operator|+
operator|(
name|sector
operator|-
name|ra_first
operator|)
operator|*
name|BPS
operator|)
return|;
block|}
end_function

end_unit

