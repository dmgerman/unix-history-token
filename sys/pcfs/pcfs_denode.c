begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Written by Paul Popelka (paulp@uts.amdahl.com)  *  *  You can do anything you want with this software,  *    just don't say you wrote it,  *    and don't reoove this notice.  *  *  This software is provided "as is".  *  *  The authop supplies this software to be publicly  *  redistributed on the understanding that the author  *  is not responsible for the correct functioning of  *  this software in any circumstances and is not liable  *  for any damages caused by this software.  *  *  October 1992  *  *	$Id: pcfs_denode.c,v 1.2 1993/10/16 19:29:32 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_comment
comment|/* defines "time"			*/
end_comment

begin_include
include|#
directive|include
file|"bpb.h"
end_include

begin_include
include|#
directive|include
file|"pcfsmount.h"
end_include

begin_include
include|#
directive|include
file|"direntry.h"
end_include

begin_include
include|#
directive|include
file|"denode.h"
end_include

begin_include
include|#
directive|include
file|"fat.h"
end_include

begin_define
define|#
directive|define
name|DEHSZ
value|512
end_define

begin_if
if|#
directive|if
operator|(
operator|(
name|DEHSZ
operator|&
operator|(
name|DEHSZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
end_if

begin_define
define|#
directive|define
name|DEHASH
parameter_list|(
name|dev
parameter_list|,
name|deno
parameter_list|)
value|(((dev)+(deno)+((deno)>>16))&(DEHSZ-1))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEHASH
parameter_list|(
name|dev
parameter_list|,
name|deno
parameter_list|)
value|(((dev)+(deno)+((deno)>>16))%DEHSZ)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ((DEHSZ& (DEHSZ-1)) == 0) */
end_comment

begin_union
union|union
name|dehead
block|{
name|union
name|dehead
modifier|*
name|deh_head
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|denode
modifier|*
name|deh_chain
index|[
literal|2
index|]
decl_stmt|;
block|}
name|dehead
index|[
name|DEHSZ
index|]
union|;
end_union

begin_macro
name|pcfs_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
if|if
condition|(
name|VN_MAXPRIVATE
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|denode
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pcfs_init: vnode too small"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DEHSZ
operator|,
name|deh
operator|=
name|dehead
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|deh
operator|++
control|)
block|{
name|deh
operator|->
name|deh_head
index|[
literal|0
index|]
operator|=
name|deh
expr_stmt|;
name|deh
operator|->
name|deh_head
index|[
literal|1
index|]
operator|=
name|deh
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  If deget() succeeds it returns with the gotten denode  *  locked().  *  pmp - address of pcfsmount structure of the filesystem  *    containing the denode of interest.  The pm_dev field  *    and the address of the pcfsmount structure are used.   *  dirclust - which cluster bp contains, if dirclust is 0  *    (root directory) diroffset is relative to the beginning  *    of the root directory, otherwise it is cluster relative.  *  diroffset - offset past begin of cluster of denode we  *    want  *  direntptr - address of the direntry structure of interest.  *    direntptr is NULL, the block is read if necessary.  *  depp - returns the address of the gotten denode.  */
end_comment

begin_function
name|int
name|deget
parameter_list|(
name|pmp
parameter_list|,
name|dirclust
parameter_list|,
name|diroffset
parameter_list|,
name|direntptr
parameter_list|,
name|depp
parameter_list|)
name|struct
name|pcfsmount
modifier|*
name|pmp
decl_stmt|;
comment|/* so we know the maj/min number	*/
name|u_long
name|dirclust
decl_stmt|;
comment|/* cluster this dir entry came from	*/
name|u_long
name|diroffset
decl_stmt|;
comment|/* index of entry within the cluster	*/
name|struct
name|direntry
modifier|*
name|direntptr
decl_stmt|;
name|struct
name|denode
modifier|*
modifier|*
name|depp
decl_stmt|;
comment|/* returns the addr of the gotten denode*/
block|{
name|int
name|error
decl_stmt|;
name|dev_t
name|dev
init|=
name|pmp
operator|->
name|pm_dev
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
init|=
name|pmp
operator|->
name|pm_mountp
decl_stmt|;
specifier|extern
name|struct
name|vnodeops
name|pcfs_vnodeops
decl_stmt|;
name|struct
name|denode
modifier|*
name|ldep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"deget(pmp %08x, dirclust %d, diroffset %x, direntptr %x, depp %08x)\n"
argument_list|,
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
name|direntptr
argument_list|,
name|depp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
comment|/* If dir entry is given and refers to a directory, convert to  	 * canonical form 	 */
if|if
condition|(
name|direntptr
operator|&&
operator|(
name|direntptr
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
operator|)
condition|)
block|{
name|dirclust
operator|=
name|direntptr
operator|->
name|deStartCluster
expr_stmt|;
if|if
condition|(
name|dirclust
operator|==
name|PCFSROOT
condition|)
name|diroffset
operator|=
name|PCFSROOT_OFS
expr_stmt|;
else|else
name|diroffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  *  See if the denode is in the denode cache. Use the location of  *  the directory entry to compute the hash value.  *  For subdir use address of "." entry.  *  for root dir use cluster PCFSROOT, offset PCFSROOT_OFS  *    *  NOTE: The check for de_refcnt> 0 below insures the denode  *  being examined does not represent an unlinked but  *  still open file.  These files are not to be accessible  *  even when the directory entry that represented the  *  file happens to be reused while the deleted file is still  *  open.  */
name|deh
operator|=
operator|&
name|dehead
index|[
name|DEHASH
argument_list|(
name|dev
argument_list|,
name|dirclust
operator|+
name|diroffset
argument_list|)
index|]
expr_stmt|;
name|loop
label|:
for|for
control|(
name|ldep
operator|=
name|deh
operator|->
name|deh_chain
index|[
literal|0
index|]
init|;
name|ldep
operator|!=
operator|(
expr|struct
name|denode
operator|*
operator|)
name|deh
condition|;
name|ldep
operator|=
name|ldep
operator|->
name|de_forw
control|)
block|{
if|if
condition|(
name|dev
operator|!=
name|ldep
operator|->
name|de_dev
operator|||
name|ldep
operator|->
name|de_refcnt
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dirclust
operator|!=
name|ldep
operator|->
name|de_dirclust
operator|||
name|diroffset
operator|!=
name|ldep
operator|->
name|de_diroffset
condition|)
continue|continue;
if|if
condition|(
name|ldep
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|)
block|{
comment|/* should we brelse() the passed buf hdr to 			 *  avoid some potential deadlock? */
name|ldep
operator|->
name|de_flag
operator||=
name|DEWANT
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ldep
argument_list|,
name|PINOD
argument_list|,
literal|"deget"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|vget
argument_list|(
name|DETOV
argument_list|(
name|ldep
argument_list|)
argument_list|)
condition|)
goto|goto
name|loop
goto|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Directory entry was not in cache, have to create  *  a vnode and copy it from the passed disk buffer.  */
comment|/* getnewvnode() does a VREF() on the vnode */
if|if
condition|(
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_PCFS
argument_list|,
name|mntp
argument_list|,
operator|&
name|pcfs_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
condition|)
block|{
operator|*
name|depp
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
name|ldep
operator|=
name|VTODE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|nvp
expr_stmt|;
name|ldep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_lockf
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_dev
operator|=
name|dev
expr_stmt|;
name|fc_purge
argument_list|(
name|ldep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* init the fat cache for this denode */
comment|/*  *  Insert the denode into the hash queue and lock the  *  denode so it can't be accessed until we've read it  *  in and have done what we need to it.  */
name|insque
argument_list|(
name|ldep
argument_list|,
name|deh
argument_list|)
expr_stmt|;
name|DELOCK
argument_list|(
name|ldep
argument_list|)
expr_stmt|;
comment|/* 	 *  Copy the directory entry into the denode area of the 	 *  vnode. 	 */
if|if
condition|(
name|dirclust
operator|==
name|PCFSROOT
operator|&&
name|diroffset
operator|==
name|PCFSROOT_OFS
condition|)
block|{
comment|/*  Directory entry for the root directory. 		 *  There isn't one, so we manufacture one. 		 *  We should probably rummage through the root directory and 		 *  find a label entry (if it exists), and then use the time 		 *  and date from that entry as the time and date for the 		 *  root denode. 		 */
name|ldep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ldep
operator|->
name|de_StartCluster
operator|=
name|PCFSROOT
expr_stmt|;
name|ldep
operator|->
name|de_FileSize
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|*
literal|512
expr_stmt|;
comment|/* Jim Jegers*/
comment|/* fill in time and date so that dos2unixtime() doesn't 		 * spit up when called from pcfs_getattr() with root denode */
name|ldep
operator|->
name|de_Time
operator|=
literal|0x0000
expr_stmt|;
comment|/* 00:00:00	*/
name|ldep
operator|->
name|de_Date
operator|=
operator|(
literal|0
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* Jan 1, 1980	*/
comment|/* leave the other fields as garbage */
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|direntptr
condition|)
block|{
name|error
operator|=
name|readep
argument_list|(
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|ldep
operator|->
name|de_de
operator|=
operator|*
name|direntptr
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Fill in a few fields of the vnode and finish filling  *  in the denode.  Then return the address of the found  *  denode.  */
name|ldep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
name|ldep
operator|->
name|de_refcnt
operator|=
literal|1
expr_stmt|;
name|ldep
operator|->
name|de_dirclust
operator|=
name|dirclust
expr_stmt|;
name|ldep
operator|->
name|de_diroffset
operator|=
name|diroffset
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 *  Since DOS directory entries that describe directories 		 *  have 0 in the filesize field, we take this opportunity 		 *  to find out the length of the directory and plug it 		 *  into the denode structure. 		 */
name|u_long
name|size
decl_stmt|;
name|nvp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_StartCluster
operator|==
name|PCFSROOT
condition|)
name|nvp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|ldep
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|ldep
operator|->
name|de_FileSize
operator|=
name|size
operator|<<
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"deget(): pcbmap returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nvp
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
name|VREF
argument_list|(
name|ldep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|deput
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"deput: denode not locked"
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|deupdat
parameter_list|(
name|dep
parameter_list|,
name|tp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|diro
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dirp
decl_stmt|;
name|struct
name|pcfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|DETOV
argument_list|(
name|dep
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"deupdat(): dep %08x\n"
argument_list|,
name|dep
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
comment|/*  *  If the update bit is off, or this denode is from  *  a readonly filesystem, or this denode is for a  *  directory, or the denode represents an open but  *  unlinked file then don't do anything.  DOS directory  *  entries that describe a directory do not ever  *  get updated.  This is the way dos treats them.  */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DEUPD
operator|)
operator|==
literal|0
operator|||
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|||
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|||
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/*  *  Read in the cluster containing the directory entry  *  we want to update.  */
if|if
condition|(
name|error
operator|=
name|readde
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|dirp
argument_list|)
condition|)
return|return
name|error
return|;
comment|/*  *  Put the passed in time into the directory entry.  */
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Date
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Time
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DEUPD
expr_stmt|;
comment|/*  *  Copy the directory entry out of the denode into  *  the cluster it came from.  */
operator|*
name|dirp
operator|=
name|dep
operator|->
name|de_de
expr_stmt|;
comment|/* structure copy */
comment|/*  *  Write the cluster back to disk.  If they asked  *  for us to wait for the write to complete, then  *  use bwrite() otherwise use bdwrite().  */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* note that error is 0 from above, but ... */
if|if
condition|(
name|waitfor
condition|)
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  *  Truncate the file described by dep to the length  *  specified by length.  */
end_comment

begin_function
name|int
name|detrunc
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|allerror
decl_stmt|;
name|u_long
name|eofentry
decl_stmt|;
name|u_long
name|chaintofree
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|isadir
init|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|pcfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): file %s, length %d, flags %d\n"
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
comment|/*  *  Disallow attempts to truncate the root directory  *  since it is of fixed size.  That's just the way  *  dos filesystems are.  We use the VROOT bit in the  *  vnode because checking for the directory bit and  *  a startcluster of 0 in the denode is not adequate  *  to recognize the root directory at this point in  *  a file or directory's life.  */
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
name|printf
argument_list|(
literal|"detrunc(): can't truncate root directory, clust %d, offset %d\n"
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|vnode_pager_setsize
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|<=
name|length
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): file is shorter return point, errno %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
return|return
name|error
return|;
block|}
comment|/*  *  If the desired length is 0 then remember the starting  *  cluster of the file and set the StartCluster field in  *  the directory entry to 0.  If the desired length is  *  not zero, then get the number of the last cluster in  *  the shortened file.  Then get the number of the first  *  cluster in the part of the file that is to be freed.  *  Then set the next cluster pointer in the last cluster  *  of the file to CLUST_EOFE.  */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chaintofree
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
name|dep
operator|->
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|eofentry
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|,
literal|0
argument_list|,
operator|&
name|eofentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): pcbmap fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
return|return
name|error
return|;
block|}
block|}
name|fc_purge
argument_list|(
name|dep
argument_list|,
operator|(
name|length
operator|+
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|)
expr_stmt|;
comment|/*  *  If the new length is not a multiple of the cluster size  *  then we must zero the tail end of the new last cluster in case  *  it becomes part of the file again because of a seek.  */
if|if
condition|(
operator|(
name|boff
operator|=
name|length
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* should read from file vnode or 		 * filesystem vnode depending on if file or dir */
if|if
condition|(
name|isadir
condition|)
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): bread fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
return|return
name|error
return|;
block|}
name|vnode_pager_uncache
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* what's this for? */
comment|/* is this the right 							 *  place for it? */
name|bzero
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|boff
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Write out the updated directory entry.  Even  *  if the update fails we free the trailing clusters.  */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|vinvalbuf
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|allerror
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): allerror %d, eofentry %d\n"
argument_list|,
name|allerror
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
comment|/*  *  If we need to break the cluster chain for the file  *  then do it now.  */
if|if
condition|(
name|eofentry
operator|!=
operator|~
literal|0
condition|)
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|eofentry
argument_list|,
operator|&
name|chaintofree
argument_list|,
name|CLUST_EOFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): fatentry errors %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
return|return
name|error
return|;
block|}
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Now free the clusters removed from the file because  *  of the truncation.  */
if|if
condition|(
name|chaintofree
operator|!=
literal|0
operator|&&
operator|!
name|PCFSEOF
argument_list|(
name|chaintofree
argument_list|)
condition|)
name|freeclusterchain
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
expr_stmt|;
return|return
name|allerror
return|;
block|}
end_function

begin_comment
comment|/*  *  Move a denode to its correct hash queue after  *  the file it represents has been moved to a new  *  directory.  */
end_comment

begin_macro
name|reinsert
argument_list|(
argument|dep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pcfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
comment|/*  *  Fix up the denode cache.  If the denode is  *  for a directory, there is nothing to do since the  *  hash is based on the starting cluster of the directory  *  file and that hasn't changed.  If for a file the hash  *  is based on the location  *  of the directory entry, so we must remove it from the  *  cache and re-enter it with the hash based on the new  *  location of the directory entry.  */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
block|{
name|remque
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|deh
operator|=
operator|&
name|dehead
index|[
name|DEHASH
argument_list|(
name|pmp
operator|->
name|pm_dev
argument_list|,
name|dep
operator|->
name|de_dirclust
operator|+
name|dep
operator|->
name|de_diroffset
argument_list|)
index|]
expr_stmt|;
name|insque
argument_list|(
name|dep
argument_list|,
name|deh
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|pcfs_prtactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print reclaims of active vnodes */
end_comment

begin_function
name|int
name|pcfs_reclaim
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"pcfs_reclaim(): dep %08x, file %s, refcnt %d\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
if|if
condition|(
name|pcfs_prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"pcfs_reclaim(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/*  *  Remove the denode from the denode hash chain we  *  are in.  */
name|remque
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_forw
operator|=
name|dep
expr_stmt|;
name|dep
operator|->
name|de_back
operator|=
name|dep
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/*  *  Indicate that one less file on the filesystem is open.  */
if|if
condition|(
name|dep
operator|->
name|de_devvp
condition|)
block|{
name|vrele
argument_list|(
name|dep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
block|}
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcfs_inactive
parameter_list|(
name|vp
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"pcfs_inactive(): dep %08x, de_Name[0] %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
if|if
condition|(
name|pcfs_prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"pcfs_inactive(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/*  *  Get rid of denodes related to stale file handles.  *  Hmmm, what does this really do?  */
if|if
condition|(
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
operator|)
operator|==
literal|0
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  If the file has been deleted and it is on a read/write  *  filesystem, then truncate the file, and mark the directory  *  slot as empty.  (This may not be necessary for the dos  *  filesystem.  */
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"pcfs_inactive(): dep %08x, refcnt %d, mntflag %x, MNT_RDONLY %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
argument_list|,
name|MNT_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
name|DELOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
block|}
name|DEUPDAT
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
comment|/*  *  If we are done with the denode, then reclaim  *  it so that it can be reused now.  */
if|#
directive|if
name|defined
argument_list|(
name|PCFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"pcfs_inactive(): v_usecount %d, de_Name[0] %x\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PCFSDEBUG) */
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|delock
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
while|while
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DEWANT
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_spare0
operator|==
name|curproc
operator|->
name|p_pid
condition|)
name|panic
argument_list|(
literal|"delock: locking against myself"
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_spare1
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dep
argument_list|,
name|PINOD
argument_list|,
literal|"delock"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dep
operator|->
name|de_spare1
operator|=
literal|0
expr_stmt|;
name|dep
operator|->
name|de_spare0
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DELOCKED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|deunlock
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
operator|==
literal|0
condition|)
name|vprint
argument_list|(
literal|"deunlock: found unlocked denode"
argument_list|,
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_spare0
operator|=
literal|0
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DELOCKED
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DEWANT
condition|)
block|{
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DEWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

