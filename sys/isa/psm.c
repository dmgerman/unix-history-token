begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * Copyright (c) 1996, 1997 Kazutaka YOKOTA.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  *  *  Hardware access routines and probe logic rewritten by  *  Kazutaka Yokota<yokota@zodiac.mech.utsunomiya-u.ac.jp>  *  - 3, 14, 22 October 1996.  *  - 12 November 1996. IOCTLs and rearranging `psmread', `psmioctl'...  *  - 14, 30 November 1996. Uses `kbdio.c'.  *  - 13 December 1996. Uses queuing version of `kbdio.c'.  *  - January/February 1997. Tweaked probe logic for   *    HiNote UltraII/Latitude/Armada laptops.  *  - 30 July 1997. Added APM support.  *  - 5 March 1997. Defined driver configuration flags (PSM_CONFIG_XXX).   *    Improved sync check logic.  *    Vendor specific support routines.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_psm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/atkbdcreg.h>
end_include

begin_comment
comment|/*  * Driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* debugging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|PSM_DEBUG
value|0
end_define

begin_comment
comment|/* logging: 0: none, 1: brief, 2: verbose */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_SYNCERR_THRESHOLD1
end_ifndef

begin_define
define|#
directive|define
name|PSM_SYNCERR_THRESHOLD1
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_INPUT_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|PSM_INPUT_TIMEOUT
value|2000000
end_define

begin_comment
comment|/* 2 sec */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of driver specific options */
end_comment

begin_define
define|#
directive|define
name|PSM_DRIVER_NAME
value|"psm"
end_define

begin_define
define|#
directive|define
name|PSMCPNP_DRIVER_NAME
value|"psmcpnp"
end_define

begin_comment
comment|/* input queue */
end_comment

begin_define
define|#
directive|define
name|PSM_BUFSIZE
value|960
end_define

begin_define
define|#
directive|define
name|PSM_SMALLBUFSIZE
value|240
end_define

begin_comment
comment|/* operation levels */
end_comment

begin_define
define|#
directive|define
name|PSM_LEVEL_BASE
value|0
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_STANDARD
value|1
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_NATIVE
value|2
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MIN
value|PSM_LEVEL_BASE
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MAX
value|PSM_LEVEL_NATIVE
end_define

begin_comment
comment|/* Logitech PS2++ protocol */
end_comment

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_CHECKBITS
parameter_list|(
name|b
parameter_list|)
define|\
value|((((b[2]& 0x03)<< 2) | 0x02) == (b[1]& 0x0f))
end_define

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_PACKET_TYPE
parameter_list|(
name|b
parameter_list|)
define|\
value|(((b[0]& 0x30)>> 2) | ((b[1]& 0x30)>> 4))
end_define

begin_comment
comment|/* some macros */
end_comment

begin_define
define|#
directive|define
name|PSM_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|PSM_NBLOCKIO
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 1)
end_define

begin_define
define|#
directive|define
name|PSM_MKMINOR
parameter_list|(
name|unit
parameter_list|,
name|block
parameter_list|)
value|(((unit)<< 1) | ((block) ? 0:1))
end_define

begin_comment
comment|/* ring buffer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|;
comment|/* # of valid elements in the buffer */
name|int
name|head
decl_stmt|;
comment|/* head pointer */
name|int
name|tail
decl_stmt|;
comment|/* tail poiner */
name|unsigned
name|char
name|buf
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
block|}
name|ringbuf_t
typedef|;
end_typedef

begin_comment
comment|/* data buffer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packetbuf
block|{
name|unsigned
name|char
name|ipacket
index|[
literal|16
index|]
decl_stmt|;
comment|/* interim input buffer */
name|int
name|inputbytes
decl_stmt|;
comment|/* # of bytes in the input buffer */
block|}
name|packetbuf_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_PACKETQUEUE
end_ifndef

begin_define
define|#
directive|define
name|PSM_PACKETQUEUE
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* driver control block */
end_comment

begin_struct
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|int
name|unit
decl_stmt|;
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|int
name|config
decl_stmt|;
comment|/* driver configuration flags */
name|int
name|flags
decl_stmt|;
comment|/* other flags */
name|KBDC
name|kbdc
decl_stmt|;
comment|/* handle to access the keyboard controller */
name|struct
name|resource
modifier|*
name|intr
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* interrupt handle */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|synapticshw_t
name|synhw
decl_stmt|;
comment|/* Synaptics-specific hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* operation mode */
name|mousemode_t
name|dflt_mode
decl_stmt|;
comment|/* default operation mode */
name|mousestatus_t
name|status
decl_stmt|;
comment|/* accumulated mouse movement */
name|ringbuf_t
name|queue
decl_stmt|;
comment|/* mouse status queue */
name|packetbuf_t
name|pqueue
index|[
name|PSM_PACKETQUEUE
index|]
decl_stmt|;
comment|/* mouse data queue */
name|int
name|pqueue_start
decl_stmt|;
comment|/* start of data in queue */
name|int
name|pqueue_end
decl_stmt|;
comment|/* end of data in queue */
name|int
name|button
decl_stmt|;
comment|/* the latest button state */
name|int
name|xold
decl_stmt|;
comment|/* previous absolute X position */
name|int
name|yold
decl_stmt|;
comment|/* previous absolute Y position */
name|int
name|syncerrors
decl_stmt|;
comment|/* XXX: KILL ME! */
name|struct
name|timeval
name|inputtimeout
decl_stmt|;
name|struct
name|timeval
name|lastsoftintr
decl_stmt|;
comment|/* time of last soft interrupt */
name|struct
name|timeval
name|lastinputerr
decl_stmt|;
comment|/* time last sync error happened */
name|int
name|watchdog
decl_stmt|;
comment|/* watchdog timer flag */
name|struct
name|callout_handle
name|callout
decl_stmt|;
comment|/* watchdog timer call out */
name|struct
name|callout_handle
name|softcallout
decl_stmt|;
comment|/* buffer timer call out */
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdev
modifier|*
name|bdev
decl_stmt|;
name|int
name|lasterr
decl_stmt|;
name|int
name|cmdcount
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|devclass_t
name|psm_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PSM_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|((struct psm_softc*)devclass_get_softc(psm_devclass, unit))
end_define

begin_comment
comment|/* driver state flags (state) */
end_comment

begin_define
define|#
directive|define
name|PSM_VALID
value|0x80
end_define

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_define
define|#
directive|define
name|PSM_SOFTARMED
value|4
end_define

begin_comment
comment|/* Software interrupt armed */
end_comment

begin_comment
comment|/* driver configuration flags (config) */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_RESOLUTION
value|0x000f
end_define

begin_comment
comment|/* resolution */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_ACCEL
value|0x00f0
end_define

begin_comment
comment|/* acceleration factor */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NOCHECKSYNC
value|0x0100
end_define

begin_comment
comment|/* disable sync. test */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NOIDPROBE
value|0x0200
end_define

begin_comment
comment|/* disable mouse model probe */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NORESET
value|0x0400
end_define

begin_comment
comment|/* don't reset the mouse */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_FORCETAP
value|0x0800
end_define

begin_comment
comment|/* assume `tap' action exists */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_IGNPORTERROR
value|0x1000
end_define

begin_comment
comment|/* ignore error in aux port test */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_HOOKRESUME
value|0x2000
end_define

begin_comment
comment|/* hook the system resume event */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_INITAFTERSUSPEND
value|0x4000
end_define

begin_comment
comment|/* init the device at the resume event */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_SYNCHACK
value|0x8000
end_define

begin_comment
comment|/* enable `out-of-sync' hack */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_FLAGS
value|(PSM_CONFIG_RESOLUTION 		\ 				    | PSM_CONFIG_ACCEL		\ 				    | PSM_CONFIG_NOCHECKSYNC	\ 				    | PSM_CONFIG_SYNCHACK	\ 				    | PSM_CONFIG_NOIDPROBE	\ 				    | PSM_CONFIG_NORESET	\ 				    | PSM_CONFIG_FORCETAP	\ 				    | PSM_CONFIG_IGNPORTERROR	\ 				    | PSM_CONFIG_HOOKRESUME	\ 				    | PSM_CONFIG_INITAFTERSUSPEND)
end_define

begin_comment
comment|/* other flags (flags) */
end_comment

begin_define
define|#
directive|define
name|PSM_FLAGS_FINGERDOWN
value|0x0001
end_define

begin_comment
comment|/* VersaPad finger down */
end_comment

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_MOUSE_GETHWINFO
value|_IOR('M', 1, old_mousehw_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_GETMODE
value|_IOR('M', 2, old_mousemode_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_SETMODE
value|_IOW('M', 3, old_mousemode_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mousehw
block|{
name|int
name|buttons
decl_stmt|;
name|int
name|iftype
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|hwid
decl_stmt|;
block|}
name|old_mousehw_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mousemode
block|{
name|int
name|protocol
decl_stmt|;
name|int
name|rate
decl_stmt|;
name|int
name|resolution
decl_stmt|;
name|int
name|accelfactor
decl_stmt|;
block|}
name|old_mousemode_t
typedef|;
end_typedef

begin_comment
comment|/* packet formatting function */
end_comment

begin_typedef
typedef|typedef
name|int
name|packetfunc_t
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|psmidentify
parameter_list|(
name|driver_t
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmprobe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmattach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmdetach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmresume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|psmpoll
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|mousemode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doopen
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmsoftintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psmtimeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timeelapsed
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dropqueue
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushpackets
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vendor specific features */
end_comment

begin_typedef
typedef|typedef
name|int
name|probefunc_t
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|int
name|mouse_id_proc1
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mouse_ext_command
parameter_list|(
name|KBDC
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_groller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_gmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_aglide
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_kmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_msexplorer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_msintelli
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_4dmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_4dplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_mmanplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_synaptics
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_versapad
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|tame_mouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
parameter_list|,
name|packetbuf_t
modifier|*
parameter_list|,
name|mousestatus_t
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
block|{
name|int
name|model
decl_stmt|;
name|unsigned
name|char
name|syncmask
decl_stmt|;
name|int
name|packetsize
decl_stmt|;
name|probefunc_t
modifier|*
name|probefunc
decl_stmt|;
block|}
name|vendortype
index|[]
init|=
block|{
comment|/*      * WARNING: the order of probe is very important.  Don't mess it      * unless you know what you are doing.      */
block|{
name|MOUSE_MODEL_NET
block|,
comment|/* Genius NetMouse */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_gmouse
block|, }
block|,
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
comment|/* Genius NetScroll */
literal|0xc8
block|,
literal|6
block|,
name|enable_groller
block|, }
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
comment|/* Logitech MouseMan+ */
literal|0x08
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_mmanplus
block|, }
block|,
block|{
name|MOUSE_MODEL_EXPLORER
block|,
comment|/* Microsoft IntelliMouse Explorer */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_msexplorer
block|, }
block|,
block|{
name|MOUSE_MODEL_4D
block|,
comment|/* A4 Tech 4D Mouse */
literal|0x08
block|,
name|MOUSE_4D_PACKETSIZE
block|,
name|enable_4dmouse
block|, }
block|,
block|{
name|MOUSE_MODEL_4DPLUS
block|,
comment|/* A4 Tech 4D+ Mouse */
literal|0xc8
block|,
name|MOUSE_4DPLUS_PACKETSIZE
block|,
name|enable_4dplus
block|, }
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
comment|/* Microsoft IntelliMouse */
literal|0x08
block|,
name|MOUSE_PS2INTELLI_PACKETSIZE
block|,
name|enable_msintelli
block|, }
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
comment|/* ALPS GlidePoint */
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_aglide
block|, }
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
comment|/* Kensignton ThinkingMouse */
literal|0x80
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_kmouse
block|, }
block|,
block|{
name|MOUSE_MODEL_VERSAPAD
block|,
comment|/* Interlink electronics VersaPad */
literal|0xe8
block|,
name|MOUSE_PS2VERSA_PACKETSIZE
block|,
name|enable_versapad
block|, }
block|,
block|{
name|MOUSE_MODEL_SYNAPTICS
block|,
comment|/* Synaptics Touchpad */
literal|0xc0
block|,
name|MOUSE_SYNAPTICS_PACKETSIZE
block|,
name|enable_synaptics
block|, }
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|NULL
block|, }
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|GENERIC_MOUSE_ENTRY
value|((sizeof(vendortype) / sizeof(*vendortype)) - 1)
end_define

begin_comment
comment|/* device driver declarateion */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|psm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|psmidentify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|psmprobe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|psmattach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|psmdetach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|psmresume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|psm_driver
init|=
block|{
name|PSM_DRIVER_NAME
block|,
name|psm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|psm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|psmopen
block|,
operator|.
name|d_close
operator|=
name|psmclose
block|,
operator|.
name|d_read
operator|=
name|psmread
block|,
operator|.
name|d_ioctl
operator|=
name|psmioctl
block|,
operator|.
name|d_poll
operator|=
name|psmpoll
block|,
operator|.
name|d_name
operator|=
name|PSM_DRIVER_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug message level */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|PSM_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device I/O routines */
end_comment

begin_function
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_ENABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: ENABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_DISABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: DISABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
default|default:
name|cmd
operator|=
name|PSMC_SEND_DEV_STATUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cmd
operator|=
name|PSMC_SEND_DEV_DATA
expr_stmt|;
break|break;
block|}
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_AUX_DEV_%s return code:%04x\n"
argument_list|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"DATA"
else|:
literal|"STATUS"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
index|[
name|i
index|]
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: %s %02x %02x %02x\n"
argument_list|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"data"
else|:
literal|"status"
argument_list|,
name|status
index|[
literal|0
index|]
argument_list|,
name|status
index|[
literal|1
index|]
argument_list|,
name|status
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|id
decl_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SEND_DEV_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_DEV_ID return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: device ID: %04x\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_SAMPLING_RATE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SAMPLING_RATE (%d) %04x\n"
argument_list|,
name|rate
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|rate
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
switch|switch
condition|(
name|scale
condition|)
block|{
case|case
literal|1
case|:
default|default:
name|scale
operator|=
name|PSMC_SET_SCALING11
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scale
operator|=
name|PSMC_SET_SCALING21
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SCALING%s return code:%04x\n"
argument_list|,
operator|(
name|scale
operator|==
name|PSMC_SET_SCALING21
operator|)
condition|?
literal|"21"
else|:
literal|"11"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* `val' must be 0 through PSMD_MAX_RESOLUTION */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_RESOLUTION
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_RESOLUTION (%d) %04x\n"
argument_list|,
name|val
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|val
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: once `set_mouse_mode()' is called, the mouse device must be  * re-enabled by calling `enable_aux_dev()'  */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_STREAM_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_STREAM_MODE return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|c
init|=
literal|2
decl_stmt|;
comment|/* assume two buttons by default */
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * NOTE: a special sequence to obtain Logitech Mouse specific      * information: set resolution to 25 ppi, set scaling to 1:1, set      * scaling to 1:1, set scaling to 1:1. Then the second byte of the      * mouse status bytes is the number of available buttons.      * Some manufactures also support this sequence.      */
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
name|c
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|status
index|[
literal|1
index|]
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* misc subroutines */
end_comment

begin_comment
comment|/*  * Someday, I will get the complete list of valid pointing devices and  * their IDs... XXX  */
end_comment

begin_function
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
name|id
parameter_list|)
block|{
if|#
directive|if
literal|0
block|static int valid_ids[] = {         PSM_MOUSE_ID,
comment|/* mouse */
block|PSM_BALLPOINT_ID,
comment|/* ballpoint device */
block|PSM_INTELLI_ID,
comment|/* Intellimouse */
block|PSM_EXPLORER_ID,
comment|/* Intellimouse Explorer */
block|-1
comment|/* end of table */
block|};     int i;      for (i = 0; valid_ids[i]>= 0; ++i)         if (valid_ids[i] == id)             return TRUE;     return FALSE;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
name|model
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|model_code
decl_stmt|;
name|char
modifier|*
name|model_name
decl_stmt|;
block|}
name|models
index|[]
init|=
block|{
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
literal|"NetScroll"
block|}
block|,
block|{
name|MOUSE_MODEL_NET
block|,
literal|"NetMouse/NetScroll Optical"
block|}
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
literal|"GlidePoint"
block|}
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
literal|"ThinkingMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
literal|"IntelliMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
literal|"MouseMan+"
block|}
block|,
block|{
name|MOUSE_MODEL_VERSAPAD
block|,
literal|"VersaPad"
block|}
block|,
block|{
name|MOUSE_MODEL_EXPLORER
block|,
literal|"IntelliMouse Explorer"
block|}
block|,
block|{
name|MOUSE_MODEL_4D
block|,
literal|"4D Mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_4DPLUS
block|,
literal|"4D+ Mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_SYNAPTICS
block|,
literal|"Synaptics Touchpad"
block|}
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|"Generic PS/2 mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_UNKNOWN
block|,
name|NULL
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|!=
name|MOUSE_MODEL_UNKNOWN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|==
name|model
condition|)
return|return
name|models
index|[
name|i
index|]
operator|.
name|model_name
return|;
block|}
return|return
literal|"Unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
comment|/* discard anything left in the output buffer */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * NOTE: KBDC_RESET_KBD may not restore the communication between the      * keyboard and the controller.      */
block|reset_kbd(kbdc);
else|#
directive|else
comment|/*      * NOTE: somehow diagnostic and keyboard port test commands bring the      * keyboard back.      */
if|if
condition|(
operator|!
name|test_controller
argument_list|(
name|kbdc
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard controller failed.\n"
argument_list|)
expr_stmt|;
comment|/* if there isn't a keyboard in the system, the following error is OK */
if|if
condition|(
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard port failed.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|command_byte
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: failed to restore the keyboard controller "
literal|"command byte.\n"
argument_list|)
expr_stmt|;
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * Re-initialize the aux port and device. The aux port must be enabled  * and its interrupt must be disabled before calling this routine.   * The aux device will be disabled before returning.  * The keyboard controller must be locked via `kbdc_lock()' before  * calling this routine.  */
end_comment

begin_function
specifier|static
name|int
name|doinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|mousemode_t
modifier|*
name|mode
parameter_list|)
block|{
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore these errors */
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
name|PSM_ACK
case|:
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_IGNPORTERROR
condition|)
break|break;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NORESET
condition|)
block|{
comment|/*  	 * Don't try to reset the pointing device.  It may possibly be 	 * left in the unknown state, though... 	 */
block|}
else|else
block|{
comment|/*  	 * NOTE: some controllers appears to hang the `keyboard' when 	 * the aux port doesn't exist and `PSMC_RESET_DEV' is issued.  	 */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/*       * both the aux port and the aux device is functioning, see      * if the device can be enabled.       */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* remove stray data if any */
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOIDPROBE
condition|)
block|{
name|i
operator|=
name|GENERIC_MOUSE_ENTRY
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: hardware ID, mouse buttons? */
comment|/* other parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: found %s\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|model_name
argument_list|(
name|vendortype
index|[
name|i
index|]
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|model
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|packetsize
expr_stmt|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|!=
operator|(
name|mousemode_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|rate
operator|>
literal|0
condition|)
name|mode
operator|->
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|->
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mouse_mode
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
comment|/* request a data packet and extract sync. bits */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get data (doinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|stat
index|[
literal|0
index|]
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* syncbits */
comment|/* the NetScroll Mouse will send three more bytes... Ignore them */
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* just check the status of the mouse */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (doinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doopen
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
comment|/* enable the mouse device */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR: failed to enable the mouse because: 	 * 1) the mouse is faulty, 	 * 2) the mouse has been removed(!?) 	 * In the latter case, the keyboard may have hung, and need  	 * recovery procedure... 	 */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: we could reset the mouse here and try to enable 	 * it again. But it will take long time and it's not a good 	 * idea to disable the keyboard that long... 	 */
block|if (!doinitialize(sc,&sc->mode) || !enable_aux_dev(sc->kbdc)) { 	    recover_from_error(sc->kbdc);
else|#
directive|else
block|{
endif|#
directive|endif
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* mark this device is no longer available */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* enable the aux port and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux interrupt (doopen).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* start the watchdog timer */
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|psmtimeout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reinitialize
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|doinit
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let anybody mess with the aux device */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block our watchdog timer */
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
name|untimeout
argument_list|(
name|psmtimeout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* save the current controller command byte */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: current command byte: %04x (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* enable the aux port but disable the aux interrupt and the keyboard */
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* flush any data */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* this may fail; but never mind... */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
comment|/* try to detect the aux device; are you still there? */
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doinit
condition|)
block|{
if|if
condition|(
name|doinitialize
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* yes */
name|sc
operator|->
name|state
operator||=
name|PSM_VALID
expr_stmt|;
block|}
else|else
block|{
comment|/* the device has gone! */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux device has gone! (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* restore the driver state */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|&&
operator|(
name|err
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* enable the aux device and the port again */
name|err
operator|=
name|doopen
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* restore the keyboard port and disable the aux port */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|c
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (reinitialize).\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
block|}
block|}
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* psm driver entry points */
end_comment

begin_function
specifier|static
name|void
name|psmidentify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|psmc
decl_stmt|;
name|device_t
name|psm
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* always add at least one child */
name|psm
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|driver
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|psm
operator|==
name|NULL
condition|)
return|return;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|>
literal|0
condition|)
return|return;
comment|/*      * If the PS/2 mouse device has already been reported by ACPI or      * PnP BIOS, obtain the IRQ resource from it.      * (See psmcpnp_attach() below.)      */
name|psmc
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|parent
argument_list|)
argument_list|,
name|PSMCPNP_DRIVER_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|psmc
operator|==
name|NULL
condition|)
return|return;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|psmc
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
literal|0
condition|)
return|return;
name|bus_set_resource
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|endprobe
parameter_list|(
name|v
parameter_list|)
value|do {   if (bootverbose)				\ 				--verbose;   				\                             kbdc_set_device_mask(sc->kbdc, mask);	\ 			    kbdc_lock(sc->kbdc, FALSE);			\ 			    return (v);	     				\ 			} while (0)
end_define

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|kbdc_debug(TRUE);
endif|#
directive|endif
comment|/* see if IRQ is available */
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|sc
operator|->
name|intr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|kbdc
operator|=
name|atkbdc_open
argument_list|(
name|device_get_unit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|PSM_CONFIG_FLAGS
expr_stmt|;
comment|/* XXX: for backward compatibility */
if|#
directive|if
name|defined
argument_list|(
name|PSM_HOOKRESUME
argument_list|)
operator|||
name|defined
argument_list|(
name|PSM_HOOKAPM
argument_list|)
name|sc
operator|->
name|config
operator||=
ifdef|#
directive|ifdef
name|PSM_RESETAFTERSUSPEND
name|PSM_CONFIG_HOOKRESUME
operator||
name|PSM_CONFIG_INITAFTERSUSPEND
expr_stmt|;
else|#
directive|else
name|PSM_CONFIG_HOOKRESUME
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PSM_HOOKRESUME | PSM_HOOKAPM */
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|++
name|verbose
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PS/2 Mouse"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * NOTE: two bits in the command byte controls the operation of the      * aux port (mouse port): the aux port disable bit (bit 5) and the aux      * port interrupt (IRQ 12) enable bit (bit 2).      */
comment|/* discard anything left after the keyboard initialization */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current command byte; it will be used later */
name|mask
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_AUX_CONTROL_BITS
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: current command byte:%04x\n"
argument_list|,
name|unit
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"psm%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/*      * disable the keyboard port while probing the aux port, which must be      * enabled during this routine      */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know how to recover           * from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|write_controller_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBDC_ENABLE_AUX_PORT
argument_list|)
expr_stmt|;
comment|/*      * NOTE: `test_aux_port()' is designed to return with zero if the aux      * port exists and is functioning. However, some controllers appears      * to respond with zero even when the aux port doesn't exist. (It may      * be that this is only the case when the controller DOES have the aux      * port but the port is not wired on the motherboard.) The keyboard      * controllers without the port, such as the original AT, are      * supporsed to return with an error code or simply time out. In any      * case, we have to continue probing the port even when the controller      * passes this test.      *      * XXX: some controllers erroneously return the error code 1, 2 or 3      * when it has the perfectly functional aux port. We have to ignore      * this error code. Even if the controller HAS error with the aux      * port, it will be detected later...      * XXX: another incompatible controller returns PSM_ACK (0xfa)...      */
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore these errors */
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
name|PSM_ACK
case|:
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_IGNPORTERROR
condition|)
break|break;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NORESET
condition|)
block|{
comment|/*  	 * Don't try to reset the pointing device.  It may possibly be 	 * left in the unknown state, though... 	 */
block|}
else|else
block|{
comment|/* 	 * NOTE: some controllers appears to hang the `keyboard' when the aux 	 * port doesn't exist and `PSMC_RESET_DEV' is issued. 	 * 	 * Attempt to reset the controller twice -- this helps 	 * pierce through some KVM switches. The second reset 	 * is non-fatal. 	 */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device (2).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * both the aux port and the aux device is functioning, see if the      * device can be enabled. NOTE: when enabled, the device will start      * sending data; we shall immediately disable the device once we know      * the device can be enabled.      */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* save the default values after reset */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* hardware information */
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
comment|/* verify the device is a mouse */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_a_mouse
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: unknown device type (%d).\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|hwid
condition|)
block|{
case|case
name|PSM_BALLPOINT_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_TRACKBALL
expr_stmt|;
break|break;
case|case
name|PSM_MOUSE_ID
case|:
case|case
name|PSM_INTELLI_ID
case|:
case|case
name|PSM_EXPLORER_ID
case|:
case|case
name|PSM_4DMOUSE_ID
case|:
case|case
name|PSM_4DPLUS_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOIDPROBE
condition|)
block|{
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|2
expr_stmt|;
name|i
operator|=
name|GENERIC_MOUSE_ENTRY
expr_stmt|;
block|}
else|else
block|{
comment|/* # of buttons */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* other parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vendortype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: found %s\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|vendortype
index|[
name|i
index|]
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|model
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|level
operator|=
name|PSM_LEVEL_BASE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|accelfactor
operator|=
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_ACCEL
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOCHECKSYNC
condition|)
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|syncmask
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_FORCETAP
condition|)
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|&=
operator|~
name|MOUSE_PS2_TAP
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* syncbits */
name|sc
operator|->
name|mode
operator|=
name|sc
operator|->
name|dflt_mode
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|vendortype
index|[
name|i
index|]
operator|.
name|packetsize
expr_stmt|;
comment|/* set mouse parameters */
if|#
directive|if
literal|0
comment|/*       * A version of Logitech FirstMouse+ won't report wheel movement,      * if SET_DEFAULTS is sent...  Don't use this command.      * This fix was found by Takashi Nishida.      */
block|i = send_aux_command(sc->kbdc, PSMC_SET_DEFAULTS);     if (verbose>= 2) 	printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
condition|)
block|{
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
block|{
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
argument_list|)
expr_stmt|;
block|}
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* request a data packet and extract sync. bits */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: failed to get data.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|stat
index|[
literal|0
index|]
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* syncbits */
comment|/* the NetScroll Mouse will send three more bytes... Ignore them */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* just check the status of the mouse */
comment|/*       * NOTE: XXX there are some arcane controller/mouse combinations out       * there, which hung the controller unless there is data transmission       * after ACK from the mouse.      */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: failed to get status.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  	 * When in its native mode, some mice operate with different  	 * default parameters than in the PS/2 compatible mode. 	 */
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* disable the aux port for now... */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know the proper way to           * recover from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* done */
name|kbdc_set_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mask
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
name|PSM_VALID
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* Setup our interrupt handler */
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|sc
operator|->
name|intr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|psmintr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Done */
name|sc
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bdev
operator|=
name|make_dev
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"bpsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d-%02x, %d buttons\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|buttons
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: config:%08x, flags:%08x, packet size:%d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|config
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|packetsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: syncmask:%02x, syncbits:%02x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmdetach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
name|EBUSY
return|;
name|rid
operator|=
name|KBDC_RID_AUX
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|intr
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|bdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Get device data */
name|sc
operator|=
name|PSM_SOFTC
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|device_busy
argument_list|(
name|devclass_get_device
argument_list|(
name|psm_devclass
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize state */
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|level
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|protocol
expr_stmt|;
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
comment|/* flush the event queue */
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pqueue_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pqueue_end
operator|=
literal|0
expr_stmt|;
comment|/* empty input buffer */
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* enable the aux port and temporalily disable the keyboard */
if|if
condition|(
operator|(
name|command_byte
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; do you know how to get out of this? */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but timeout routines will be blocked by the poll flag set       * via `kbdc_lock()'      */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable the mouse device */
name|err
operator|=
name|doopen
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* done */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|PSM_SOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* disable the aux interrupt and temporalily disable the keyboard */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux int (psmclose).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* CONTROLLER ERROR; 	 * NOTE: we shall force our way through. Because the only 	 * ill effect we shall see is that we may not be able 	 * to read ACK from the mouse, and it doesn't matter much  	 * so long as the mouse will accept the DISABLE command. 	 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* stop the watchdog timer */
name|untimeout
argument_list|(
name|psmtimeout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* disable the aux device, port and interrupt */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
if|if
condition|(
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR;  	     * NOTE: we don't return error and continue, pretending  	     * we have successfully disabled the device. It's OK because  	     * the interrupt routine will discard any data from the mouse 	     * hereafter.  	     */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the device (psmclose).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (psmclose).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR;  	 * we shall ignore this error; see the above comment. 	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (psmclose).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* close is almost always successful */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|device_unbusy
argument_list|(
name|devclass_get_device
argument_list|(
name|psm_devclass
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tame_mouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|packetbuf_t
modifier|*
name|pb
parameter_list|,
name|mousestatus_t
modifier|*
name|status
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|butmapps2
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,     }
decl_stmt|;
specifier|static
name|unsigned
name|char
name|butmapmsc
index|[
literal|8
index|]
init|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|,     }
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
block|{
name|mapped
operator|=
name|status
operator|->
name|button
operator|&
operator|~
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|&
name|MOUSE_BUTTON4DOWN
condition|)
name|mapped
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
name|status
operator|->
name|button
operator|=
name|mapped
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_PS2_SYNC
operator||
name|butmapps2
index|[
name|mapped
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_XNEG
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_YNEG
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
expr_stmt|;
return|return
name|MOUSE_PS2_PACKETSIZE
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_STANDARD
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmapmsc
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|status
operator|->
name|dz
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|i
operator|-
operator|(
name|i
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|status
operator|->
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
return|return
name|MOUSE_SYS_PACKETSIZE
return|;
block|}
return|return
name|pb
operator|->
name|inputbytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|PSM_SOFTC
argument_list|(
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|PSM_SMALLBUFSIZE
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
comment|/* block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PSM_NBLOCKIO
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* the device disappeared! */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy data to the user land */
while|while
condition|(
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|l
operator|=
name|imin
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
name|l
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|queue
operator|.
name|count
operator|-=
name|l
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|head
operator|+
name|l
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|block_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|EIO
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* this is CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/*       * The device may be in the middle of status data transmission.      * The transmission will be interrupted, thus, incomplete status       * data must be discarded. Although the aux interrupt is disabled       * at the keyboard controller level, at most one aux interrupt       * may have already been pending and a data byte is in the       * output buffer; throw it away. Note that the second argument       * to `empty_aux_buffer()' is zero, so that the call will just       * flush the internal queue.      * `psmintr()' will be invoked after `splx()' if an interrupt is      * pending; it will see no data and returns immediately.      */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush the queue */
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* throw away data if any */
name|flushpackets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dropqueue
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|untimeout
argument_list|(
name|psmsoftintr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|softcallout
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|pqueue_start
operator|=
name|sc
operator|->
name|pqueue_end
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flushpackets
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|dropqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|pqueue
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|pqueue
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unblock_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/*       * We may have seen a part of status data during `set_mouse_XXX()'.      * they have been queued; flush it.      */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* restore ports and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|c
operator|&
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; this is serious, we may have          * been left with the inaccessible keyboard and          * the disabled mouse interrupt.           */
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|PSM_SOFTC
argument_list|(
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
name|mousevar_t
modifier|*
name|var
decl_stmt|;
endif|#
directive|endif
name|mousedata_t
modifier|*
name|data
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|OLD_MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|buttons
operator|=
name|sc
operator|->
name|hw
operator|.
name|buttons
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|iftype
operator|=
name|sc
operator|->
name|hw
operator|.
name|iftype
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|type
operator|=
name|sc
operator|->
name|hw
operator|.
name|type
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|hwid
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
operator|(
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_SYN_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
operator|==
name|MOUSE_MODEL_SYNAPTICS
condition|)
operator|*
operator|(
name|synapticshw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|synhw
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
comment|/* FIXME: this isn't quite correct... XXX */
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_SETMODE
case|:
case|case
name|MOUSE_SETMODE
case|:
if|if
condition|(
name|cmd
operator|==
name|OLD_MOUSE_SETMODE
condition|)
block|{
name|mode
operator|.
name|rate
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
expr_stmt|;
comment|/* 	     * resolution  old I/F   new I/F 	     * default        0         0 	     * low            1        -2 	     * medium low     2        -3 	     * medium high    3        -4 	     * high           4        -5 	     */
if|if
condition|(
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
operator|-
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|-
literal|1
expr_stmt|;
name|mode
operator|.
name|accelfactor
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
expr_stmt|;
name|mode
operator|.
name|level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
block|}
comment|/* adjust and validate parameters. */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* don't allow anybody to poll the keyboard controller */
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|mode
operator|.
name|rate
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|mode
operator|.
name|resolution
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
operator|=
name|status
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
case|case
name|MOUSE_GETVARS
case|:
name|var
operator|=
operator|(
name|mousevar_t
operator|*
operator|)
name|addr
expr_stmt|;
name|bzero
argument_list|(
name|var
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|0
index|]
operator|=
name|MOUSE_VARS_PS2_SIG
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|config
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_SETVARS
case|:
return|return
name|ENODEV
return|;
endif|#
directive|endif
comment|/* MOUSE_GETVARS */
case|case
name|MOUSE_READSTATE
case|:
case|case
name|MOUSE_READDATA
case|:
name|data
operator|=
operator|(
name|mousedata_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|data
operator|->
name|len
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|data
operator|->
name|buf
argument_list|,
operator|(
name|cmd
operator|==
name|MOUSE_READDATA
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|data
operator|->
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRESOLUTION
argument_list|)
operator|)
case|case
name|MOUSE_SETRESOLUTION
case|:
name|mode
operator|.
name|resolution
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|!=
name|mode
operator|.
name|resolution
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRESOLUTION */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRATE
argument_list|)
operator|)
case|case
name|MOUSE_SETRATE
case|:
name|mode
operator|.
name|rate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|rate
operator|!=
name|mode
operator|.
name|rate
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRATE */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETSCALING
argument_list|)
operator|)
case|case
name|MOUSE_SETSCALING
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|2
operator|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETSCALING */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETHWID
argument_list|)
operator|)
case|case
name|MOUSE_GETHWID
case|:
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&=
operator|~
literal|0x00ff
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator||=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&
literal|0x00ff
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_GETHWID */
default|default:
return|return
name|ENOTTY
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|psmtimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|psm_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|watchdog
operator|&&
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|4
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: lost interrupt?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|psmintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|watchdog
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|psmtimeout
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|psmhz
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psmhz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmhz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psm_soft_timeout
init|=
literal|500000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0.5 sec */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psm_soft_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psm_soft_timeout
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmerrsecs
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psmerrsecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmerrsecs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmerrusecs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psmerrusecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmerrusecs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmsecs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psmsecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmsecs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|psmusecs
init|=
literal|500000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|psmusecs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|psmusecs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|psmintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|c
decl_stmt|;
name|packetbuf_t
modifier|*
name|pb
decl_stmt|;
name|int
name|haderror
init|=
literal|0
decl_stmt|;
comment|/* read until there is nothing to read */
while|while
condition|(
operator|(
name|c
operator|=
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pb
operator|=
operator|&
name|sc
operator|->
name|pqueue
index|[
name|sc
operator|->
name|pqueue_end
index|]
expr_stmt|;
comment|/* discard the byte if the device is not open */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|inputbytes
operator|>
literal|0
operator|)
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|sc
operator|->
name|inputtimeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: delay too long; resetting byte count\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|syncerrors
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|inputtimeout
operator|.
name|tv_sec
operator|=
name|PSM_INPUT_TIMEOUT
operator|/
literal|1000000
expr_stmt|;
name|sc
operator|->
name|inputtimeout
operator|.
name|tv_usec
operator|=
name|PSM_INPUT_TIMEOUT
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sc
operator|->
name|inputtimeout
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|pb
operator|->
name|ipacket
index|[
name|pb
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|inputbytes
operator|<
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
continue|continue;
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: %02x %02x %02x %02x %02x %02x\n"
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|)
operator|!=
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: out of sync (%04x != %04x) %d"
literal|" cmds since last error.\n"
argument_list|,
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|cmdcount
operator|-
name|sc
operator|->
name|lasterr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|haderror
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|lasterr
operator|=
name|sc
operator|->
name|cmdcount
expr_stmt|;
name|dropqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|syncerrors
expr_stmt|;
name|sc
operator|->
name|lastinputerr
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|<
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: discard a byte (%d).\n"
argument_list|,
name|sc
operator|->
name|syncerrors
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|pb
operator|->
name|inputbytes
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
argument_list|,
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|inputbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|==
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: re-enable the mouse.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|<
name|PSM_SYNCERR_THRESHOLD1
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: discard a byte (%d).\n"
argument_list|,
name|sc
operator|->
name|syncerrors
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|pb
operator|->
name|inputbytes
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
argument_list|,
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|inputbytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|syncerrors
operator|>=
name|PSM_SYNCERR_THRESHOLD1
condition|)
block|{
if|#
directive|if
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: reset the mouse.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reinitialize
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* if this packet is at all bogus then drop the packet. */
if|if
condition|(
name|haderror
operator|||
operator|!
name|timeelapsed
argument_list|(
operator|&
name|sc
operator|->
name|lastinputerr
argument_list|,
name|psmerrsecs
argument_list|,
name|psmerrusecs
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|haderror
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|cmdcount
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|pqueue_end
operator|>=
name|PSM_PACKETQUEUE
condition|)
name|sc
operator|->
name|pqueue_end
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we've filled the queue then call the softintr ourselves, 	 * otherwise schedule the interrupt for later. 	 */
if|if
condition|(
operator|!
name|timeelapsed
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|,
name|psmsecs
argument_list|,
name|psmusecs
argument_list|,
operator|&
name|now
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|pqueue_end
operator|==
name|sc
operator|->
name|pqueue_start
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|untimeout
argument_list|(
name|psmsoftintr
argument_list|,
name|arg
argument_list|,
name|sc
operator|->
name|softcallout
argument_list|)
expr_stmt|;
block|}
name|psmsoftintr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_SOFTARMED
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator||=
name|PSM_SOFTARMED
expr_stmt|;
name|sc
operator|->
name|softcallout
operator|=
name|timeout
argument_list|(
name|psmsoftintr
argument_list|,
name|arg
argument_list|,
name|psmhz
operator|<
literal|1
condition|?
literal|1
else|:
operator|(
name|hz
operator|/
name|psmhz
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|psmsoftintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/*      * the table to turn PS/2 mouse button bits (MOUSE_PS2_BUTTON?DOWN)      * into `mousestatus' button bits (MOUSE_BUTTON?DOWN).      */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
specifier|static
name|int
name|butmap_versapad
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mousestatus_t
name|ms
decl_stmt|;
name|int
name|w
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|packetbuf_t
modifier|*
name|pb
decl_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|sc
operator|->
name|lastsoftintr
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
do|do
block|{
name|pb
operator|=
operator|&
name|sc
operator|->
name|pqueue
index|[
name|sc
operator|->
name|pqueue_start
index|]
expr_stmt|;
name|c
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
comment|/*  	 * A kludge for Kensington device!  	 * The MSB of the horizontal count appears to be stored in  	 * a strange place. 	 */
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
operator|==
name|MOUSE_MODEL_THINK
condition|)
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_XOVERFLOW
operator|)
condition|?
literal|0x80
else|:
literal|0
expr_stmt|;
comment|/* ignore the overflow bits... */
name|x
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
name|ms
operator|.
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
comment|/* previous button state */
name|ms
operator|.
name|button
operator|=
name|butmap
index|[
name|c
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
comment|/* `tapping' action */
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_FORCETAP
condition|)
name|ms
operator|.
name|button
operator||=
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_EXPLORER
case|:
comment|/* 	     *          b7 b6 b5 b4 b3 b2 b1 b0 	     * byte 1:  oy ox sy sx 1  M  R  L 	     * byte 2:  x  x  x  x  x  x  x  x 	     * byte 3:  y  y  y  y  y  y  y  y 	     * byte 4:  *  *  S2 S1 s  d2 d1 d0 	     * 	     * L, M, R, S1, S2: left, middle, right and side buttons 	     * s: wheel data sign bit 	     * d2-d0: wheel data 	     */
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_ZNEG
operator|)
condition|?
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_INTELLI
case|:
case|case
name|MOUSE_MODEL_NET
case|:
comment|/* wheel data is in the fourth byte */
name|z
operator|=
operator|(
name|char
operator|)
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
expr_stmt|;
comment|/* some mice may send 7 when there is no Z movement?! XXX */
if|if
condition|(
operator|(
name|z
operator|>=
literal|7
operator|)
operator|||
operator|(
name|z
operator|<=
operator|-
literal|7
operator|)
condition|)
name|z
operator|=
literal|0
expr_stmt|;
comment|/* some compatible mice have additional buttons */
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2INTELLI_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2INTELLI_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_MOUSEMANPLUS
case|:
comment|/* 	     * PS2++ protocl packet 	     * 	     *          b7 b6 b5 b4 b3 b2 b1 b0 	     * byte 1:  *  1  p3 p2 1  *  *  * 	     * byte 2:  c1 c2 p1 p0 d1 d0 1  0 	     * 	     * p3-p0: packet type 	     * c1, c2: c1& c2 == 1, if p2 == 0 	     *         c1& c2 == 0, if p2 == 1 	     * 	     * packet type: 0 (device type) 	     * See comments in enable_mmanplus() below. 	     *  	     * packet type: 1 (wheel data) 	     * 	     *          b7 b6 b5 b4 b3 b2 b1 b0 	     * byte 3:  h  *  B5 B4 s  d2 d1 d0 	     * 	     * h: 1, if horizontal roller data 	     *    0, if vertical roller data 	     * B4, B5: button 4 and 5 	     * s: sign bit 	     * d2-d0: roller data 	     * 	     * packet type: 2 (reserved) 	     */
if|if
condition|(
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2PLUS_SYNCMASK
operator|)
operator|==
name|MOUSE_PS2PLUS_SYNC
operator|)
operator|&&
operator|(
name|abs
argument_list|(
name|x
argument_list|)
operator|>
literal|191
operator|)
operator|&&
name|MOUSE_PS2PLUS_CHECKBITS
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
condition|)
block|{
comment|/* the extended data packet encodes button and wheel events */
switch|switch
condition|(
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* wheel data packet */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x80
condition|)
block|{
comment|/* horizontal roller count - ignore it XXX*/
block|}
else|else
block|{
comment|/* vertical roller count */
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_ZNEG
operator|)
condition|?
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* this packet type is reserved by Logitech... */
comment|/* 		     * IBM ScrollPoint Mouse uses this packet type to 		     * encode both vertical and horizontal scroll movement. 		     */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
comment|/* horizontal count */
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
condition|)
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_WNEG
operator|)
condition|?
operator|-
literal|2
else|:
literal|2
expr_stmt|;
comment|/* vertical count */
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0xf0
condition|)
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_ZNEG
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* vertical count */
block|z = (pb->ipacket[2]& MOUSE_SPOINT_ZNEG) 			? ((pb->ipacket[2]>> 4)& 0x0f) - 16 			: ((pb->ipacket[2]>> 4)& 0x0f);
comment|/* horizontal count */
block|w = (pb->ipacket[2]& MOUSE_SPOINT_WNEG) 			? (pb->ipacket[2]& 0x0f) - 16 			: (pb->ipacket[2]& 0x0f);
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
comment|/* device type packet - shouldn't happen */
comment|/* FALLTHROUGH */
default|default:
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator|=
name|ms
operator|.
name|obutton
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: unknown PS2++ packet type %d: "
literal|"0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pb
operator|->
name|ipacket
argument_list|)
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
argument_list|,
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* preserve button states */
name|ms
operator|.
name|button
operator||=
name|ms
operator|.
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
comment|/* `tapping' action */
name|ms
operator|.
name|button
operator||=
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_NETSCROLL
case|:
comment|/* three addtional bytes encode buttons and wheel events */
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON3DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON1DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_THINK
case|:
comment|/* the fourth button state in the first byte */
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_VERSAPAD
case|:
comment|/* VersaPad PS/2 absolute mode message format 	     * 	     * [packet1]     7   6   5   4   3   2   1   0(LSB) 	     *  ipacket[0]:  1   1   0   A   1   L   T   R 	     *  ipacket[1]: H7  H6  H5  H4  H3  H2  H1  H0 	     *  ipacket[2]: V7  V6  V5  V4  V3  V2  V1  V0 	     *  ipacket[3]:  1   1   1   A   1   L   T   R 	     *  ipacket[4]:V11 V10  V9  V8 H11 H10  H9  H8 	     *  ipacket[5]:  0  P6  P5  P4  P3  P2  P1  P0 	     * 	     * [note] 	     *  R: right physical mouse button (1=on) 	     *  T: touch pad virtual button (1=tapping) 	     *  L: left physical mouse button (1=on) 	     *  A: position data is valid (1=valid) 	     *  H: horizontal data (12bit signed integer. H11 is sign bit.) 	     *  V: vertical data (12bit signed integer. V11 is sign bit.) 	     *  P: pressure data 	     * 	     * Tapping is mapped to MOUSE_BUTTON4. 	     */
name|ms
operator|.
name|button
operator|=
name|butmap_versapad
index|[
name|c
operator|&
name|MOUSE_PS2VERSA_BUTTONS
index|]
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2VERSA_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2VERSA_IN_USE
condition|)
block|{
name|x0
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator||
operator|(
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|y0
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator||
operator|(
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
operator|)
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|x0
operator|&
literal|0x800
condition|)
name|x0
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|y0
operator|&
literal|0x800
condition|)
name|y0
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
condition|)
block|{
name|x
operator|=
name|sc
operator|->
name|xold
operator|-
name|x0
expr_stmt|;
name|y
operator|=
name|y0
operator|-
name|sc
operator|->
name|yold
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
comment|/* XXX */
name|x
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|x
condition|)
name|x
operator|--
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|y
condition|)
name|y
operator|--
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
name|sc
operator|->
name|xold
operator|=
name|x0
expr_stmt|;
name|sc
operator|->
name|yold
operator|=
name|y0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
name|c
operator|=
operator|(
operator|(
name|x
operator|<
literal|0
operator|)
condition|?
name|MOUSE_PS2_XNEG
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|y
operator|<
literal|0
operator|)
condition|?
name|MOUSE_PS2_YNEG
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_4D
case|:
comment|/* 	     *          b7 b6 b5 b4 b3 b2 b1 b0 	     * byte 1:  s2 d2 s1 d1 1  M  R  L 	     * byte 2:  sx x  x  x  x  x  x  x 	     * byte 3:  sy y  y  y  y  y  y  y 	     * 	     * s1: wheel 1 direction 	     * d1: wheel 1 data 	     * s2: wheel 2 direction 	     * d2: wheel 2 data 	     */
name|x
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
condition|?
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
name|MOUSE_4D_WHEELBITS
condition|)
block|{
case|case
literal|0x10
case|:
name|z
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|z
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* 2nd wheel turning right XXX */
name|z
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
comment|/* 2nd wheel turning left XXX */
name|z
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_MODEL_4DPLUS
case|:
if|if
condition|(
operator|(
name|x
operator|<
literal|16
operator|-
literal|256
operator|)
operator|&&
operator|(
name|y
operator|<
literal|16
operator|-
literal|256
operator|)
condition|)
block|{
comment|/* 		 *          b7 b6 b5 b4 b3 b2 b1 b0 		 * byte 1:  0  0  1  1  1  M  R  L 		 * byte 2:  0  0  0  0  1  0  0  0 		 * byte 3:  0  0  0  0  S  s  d1 d0 		 * 		 * L, M, R, S: left, middle, right and side buttons 		 * s: wheel data sign bit 		 * d1-d0: wheel data 		 */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_BUTTON4DOWN
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
name|z
operator|=
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_ZNEG
operator|)
condition|?
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|8
operator|)
else|:
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* preserve previous button states */
name|ms
operator|.
name|button
operator||=
name|ms
operator|.
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_SYNAPTICS
case|:
comment|/* TouchPad PS/2 absolute mode message format 	     * 	     *  Bits:        7   6   5   4   3   2   1   0 (LSB) 	     *  ------------------------------------------------ 	     *  ipacket[0]:  1   0  W3  W2   0  W1   R   L 	     *  ipacket[1]: Yb  Ya  Y9  Y8  Xb  Xa  X9  X8 	     *  ipacket[2]: Z7  Z6  Z5  Z4  Z3  Z2  Z1  Z0 	     *  ipacket[3]:  1   1  Yc  Xc   0  W0   D   U 	     *  ipacket[4]: X7  X6  X5  X4  X3  X2  X1  X0 	     *  ipacket[5]: Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0 	     * 	     * Legend: 	     *  L: left physical mouse button 	     *  R: right physical mouse button 	     *  D: down button 	     *  U: up button 	     *  W: "wrist" value 	     *  X: x position 	     *  Y: x position 	     *  Z: pressure 	     * 	     * Absolute reportable limits:    0 - 6143. 	     * Typical bezel limits:       1472 - 5472. 	     * Typical edge marings:       1632 - 5312. 	     * 	     * w = 3 Passthrough Packet 	     * 	     * Byte 2,5,6 == Byte 1,2,3 of "Guest" 	     */
comment|/* Sanity check for out of sync packets. */
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0xc8
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0xc8
operator|)
operator|!=
literal|0xc0
condition|)
continue|continue;
name|x
operator|=
name|y
operator|=
name|x0
operator|=
name|y0
operator|=
literal|0
expr_stmt|;
comment|/* Pressure value. */
name|z
operator|=
name|pb
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
name|w
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ms
operator|.
name|button
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x02
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON3DOWN
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x01
operator|)
operator|&&
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x02
operator|)
operator|&&
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|==
literal|0
condition|)
name|ms
operator|.
name|button
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
comment|/* There is a finger on the pad. */
if|if
condition|(
operator|(
name|w
operator|>=
literal|4
operator|&&
name|w
operator|<=
literal|7
operator|)
operator|&&
operator|(
name|z
operator|>=
literal|16
operator|&&
name|z
operator|<
literal|200
operator|)
condition|)
block|{
name|x0
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x10
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
operator|)
operator||
name|pb
operator|->
name|ipacket
index|[
literal|4
index|]
expr_stmt|;
name|y0
operator|=
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|pb
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
operator||
name|pb
operator|->
name|ipacket
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PSM_FLAGS_FINGERDOWN
condition|)
block|{
name|x0
operator|=
operator|(
name|x0
operator|+
name|sc
operator|->
name|xold
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|y0
operator|=
operator|(
name|y0
operator|+
name|sc
operator|->
name|yold
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|x
operator|=
operator|(
name|x0
operator|-
name|sc
operator|->
name|xold
operator|)
operator|/
literal|4
expr_stmt|;
name|y
operator|=
operator|(
name|y0
operator|-
name|sc
operator|->
name|yold
operator|)
operator|/
literal|4
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
name|sc
operator|->
name|xold
operator|=
name|x0
expr_stmt|;
name|sc
operator|->
name|yold
operator|=
name|y0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PSM_FLAGS_FINGERDOWN
expr_stmt|;
block|}
name|z
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_GENERIC
case|:
default|default:
break|break;
block|}
comment|/* scale values */
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_XNEG
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|y
operator|*
name|y
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_YNEG
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
name|ms
operator|.
name|dx
operator|=
name|x
expr_stmt|;
name|ms
operator|.
name|dy
operator|=
name|y
expr_stmt|;
name|ms
operator|.
name|dz
operator|=
name|z
expr_stmt|;
name|ms
operator|.
name|flags
operator|=
operator|(
operator|(
name|x
operator|||
name|y
operator|||
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|ms
operator|.
name|obutton
operator|^
name|ms
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_NATIVE
condition|)
name|pb
operator|->
name|inputbytes
operator|=
name|tame_mouse
argument_list|(
name|sc
argument_list|,
name|pb
argument_list|,
operator|&
name|ms
argument_list|,
name|pb
operator|->
name|ipacket
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator||=
name|ms
operator|.
name|flags
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|+=
name|ms
operator|.
name|dx
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|+=
name|ms
operator|.
name|dy
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|+=
name|ms
operator|.
name|dz
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|watchdog
operator|=
name|FALSE
expr_stmt|;
comment|/* queue data */
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|+
name|pb
operator|->
name|inputbytes
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
condition|)
block|{
name|l
operator|=
name|imin
argument_list|(
name|pb
operator|->
name|inputbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|tail
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|inputbytes
operator|>
name|l
condition|)
name|bcopy
argument_list|(
operator|&
name|pb
operator|->
name|ipacket
index|[
name|l
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
name|pb
operator|->
name|inputbytes
operator|-
name|l
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|tail
operator|+
name|pb
operator|->
name|inputbytes
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|+=
name|pb
operator|->
name|inputbytes
expr_stmt|;
block|}
name|pb
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|pqueue_start
operator|>=
name|PSM_PACKETQUEUE
condition|)
name|sc
operator|->
name|pqueue_start
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|pqueue_start
operator|!=
name|sc
operator|->
name|pqueue_end
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_SOFTARMED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|PSM_SOFTC
argument_list|(
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vendor/model specific routines */
end_comment

begin_function
specifier|static
name|int
name|mouse_id_proc1
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|res
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|res
argument_list|)
operator|!=
name|res
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
operator|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mouse_ext_command
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|6
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
name|FALSE
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|4
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
name|FALSE
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|2
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
name|FALSE
return|;
name|c
operator|=
operator|(
name|command
operator|>>
literal|0
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|c
argument_list|)
operator|!=
name|c
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|notyet
end_if

begin_comment
comment|/* Logitech MouseMan Cordless II */
end_comment

begin_function
specifier|static
name|int
name|enable_lcordless
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_HIGH
condition|)
return|return
name|FALSE
return|;
name|ch
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* channel # */
if|if
condition|(
operator|(
name|ch
operator|<=
literal|0
operator|)
operator|||
operator|(
name|ch
operator|>
literal|4
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/*       * status[1]: always one?      * status[2]: battery status? (0-100)      */
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/* Genius NetScroll Mouse, MouseSystems SmartScroll Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_groller
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to enable the fourth button and the      * roller. Immediately after this sequence check status bytes.      * if the mouse is NetScroll, the second and the third bytes are       * '3' and 'D'.      */
comment|/*      * If the mouse is an ordinary PS/2 mouse, the status bytes should      * look like the following.      *       * byte 1 bit 7 always 0      *        bit 6 stream mode (0)      *        bit 5 disabled (0)      *        bit 4 1:1 scaling (0)      *        bit 3 always 0      *        bit 0-2 button status      * byte 2 resolution (PSMD_RES_HIGH)      * byte 3 report rate (?)      */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'D'
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* FIXME: SmartScroll Mouse has 5 buttons! XXX */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Genius NetMouse/NetMouse Pro, ASCII Mie Mouse, NetScroll Optical */
end_comment

begin_function
specifier|static
name|int
name|enable_gmouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to enable the middle, "rubber" button.       * Immediately after this sequence check status bytes.      * if the mouse is NetMouse, NetMouse Pro, or ASCII MIE Mouse,       * the second and the third bytes are '3' and 'U'.      * NOTE: NetMouse reports that it has three buttons although it has      * two buttons and a rubber button. NetMouse Pro and MIE Mouse      * say they have three buttons too and they do have a button on the      * side...      */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'U'
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ALPS GlidePoint */
end_comment

begin_function
specifier|static
name|int
name|enable_aglide
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to obtain ALPS GlidePoint specific      * information. Immediately after this sequence, status bytes will       * contain something interesting.      * NOTE: ALPS produces several models of GlidePoint. Some of those      * do not respond to this sequence, thus, cannot be detected this way.      */
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|100
argument_list|)
operator|!=
literal|100
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|==
literal|100
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Kensington ThinkingMouse/Trackball */
end_comment

begin_function
specifier|static
name|int
name|enable_kmouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|rate
index|[]
init|=
block|{
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|}
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|id1
decl_stmt|;
name|int
name|id2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id1
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
operator|!=
literal|10
condition|)
return|return
name|FALSE
return|;
comment|/*       * The device is now in the native mode? It returns a different      * ID value...      */
name|id2
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|==
name|id2
operator|)
operator|||
operator|(
name|id2
operator|!=
literal|2
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|PSM_DEBUG
operator|>=
literal|2
comment|/* at this point, resolution is LOW, sampling rate is 10/sec */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/*      * The special sequence to enable the third and fourth buttons.      * Otherwise they behave like the first and second buttons.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
comment|/*       * At this point, the device is using default resolution and      * sampling rate for the native mode.       */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|==
name|rate
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* the device appears be enabled by this sequence, diable it for now */
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Logitech MouseMan+/FirstMouse+, IBM ScrollPoint Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_mmanplus
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|data
index|[
literal|3
index|]
decl_stmt|;
comment|/* the special sequence to enable the fourth button and the roller. */
comment|/*      * NOTE: for ScrollPoint to respond correctly, the SET_RESOLUTION      * must be called exactly three times since the last RESET command      * before this sequence. XXX      */
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0x39
argument_list|)
operator|||
operator|!
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0xdb
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
comment|/*      * PS2++ protocl, packet type 0      *      *          b7 b6 b5 b4 b3 b2 b1 b0      * byte 1:  *  1  p3 p2 1  *  *  *      * byte 2:  1  1  p1 p0 m1 m0 1  0      * byte 3:  m7 m6 m5 m4 m3 m2 m1 m0      *      * p3-p0: packet type: 0      * m7-m0: model ID: MouseMan+:0x50, FirstMouse+:0x51, ScrollPoint:0x58...      */
comment|/* check constant bits */
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2PLUS_SYNCMASK
operator|)
operator|!=
name|MOUSE_PS2PLUS_SYNC
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xc3
operator|)
operator|!=
literal|0xc2
condition|)
return|return
name|FALSE
return|;
comment|/* check d3-d0 in byte 2 */
if|if
condition|(
operator|!
name|MOUSE_PS2PLUS_CHECKBITS
argument_list|(
name|data
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* check p3-p0 */
if|if
condition|(
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|data
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|&=
literal|0x00ff
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator||=
name|data
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
comment|/* save model ID */
comment|/*      * MouseMan+ (or FirstMouse+) is now in its native mode, in which      * the wheel and the fourth button events are encoded in the      * special data packet. The mouse may be put in the IntelliMouse mode      * if it is initialized by the IntelliMouse's method.      */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* MS IntelliMouse Explorer */
end_comment

begin_function
specifier|static
name|int
name|enable_msexplorer
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|rate0
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|, }
decl_stmt|;
specifier|static
name|unsigned
name|char
name|rate1
index|[]
init|=
block|{
literal|200
block|,
literal|200
block|,
literal|80
block|, }
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the special sequence to enable the extra buttons and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate1
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate1
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate1
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* the device will give the genuine ID only after the above sequence */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PSM_EXPLORER_ID
condition|)
return|return
name|FALSE
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|5
expr_stmt|;
comment|/* IntelliMouse Explorer XXX */
comment|/*      * XXX: this is a kludge to fool some KVM switch products      * which think they are clever enough to know the 4-byte IntelliMouse      * protocol, and assume any other protocols use 3-byte packets.      * They don't convey 4-byte data packets from the IntelliMouse Explorer       * correctly to the host computer because of this!      * The following sequence is actually IntelliMouse's "wake up"      * sequence; it will make the KVM think the mouse is IntelliMouse      * when it is in fact IntelliMouse Explorer.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate0
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate0
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate0
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate0
index|[
name|i
index|]
condition|)
break|break;
block|}
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* MS IntelliMouse */
end_comment

begin_function
specifier|static
name|int
name|enable_msintelli
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Logitech MouseMan+ and FirstMouse+ will also respond to this      * probe routine and act like IntelliMouse.      */
specifier|static
name|unsigned
name|char
name|rate
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|, }
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the special sequence to enable the third button and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* the device will give the genuine ID only after the above sequence */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PSM_INTELLI_ID
condition|)
return|return
name|FALSE
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A4 Tech 4D Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_4dmouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Newer wheel mice from A4 Tech may use the 4D+ protocol.      */
specifier|static
name|unsigned
name|char
name|rate
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|}
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/*      * WinEasy 4D, 4 Way Scroll 4D: 6      * Cable-Free 4D: 8 (4DPLUS)      * WinBest 4D+, 4 Way Scroll 4D+: 8 (4DPLUS)      */
if|if
condition|(
name|id
operator|!=
name|PSM_4DMOUSE_ID
condition|)
return|return
name|FALSE
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
comment|/* XXX some 4D mice have 4? */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A4 Tech 4D+ Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_4dplus
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Newer wheel mice from A4 Tech seem to use this protocol.      * Older models are recognized as either 4D Mouse or IntelliMouse.      */
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|id
decl_stmt|;
comment|/*      * enable_4dmouse() already issued the following ID sequence...     static unsigned char rate[] = { 200, 100, 80, 60, 40, 20 };     int i;      for (i = 0; i< sizeof(rate)/sizeof(rate[0]); ++i) {         if (set_mouse_sampling_rate(kbdc, rate[i]) != rate[i]) 	    return FALSE;     }     */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PSM_4DPLUS_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|PSM_4DPLUS_RFSW35_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Synaptics Touchpad */
end_comment

begin_function
specifier|static
name|int
name|enable_synaptics
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|KBDC
name|kbdc
decl_stmt|;
name|kbdc
operator|=
name|sc
operator|->
name|kbdc
expr_stmt|;
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/* Just to be on the safe side */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Identify the Touchpad version */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|sc
operator|->
name|synhw
operator|.
name|infoMinor
operator|=
name|status
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoMajor
operator|=
name|status
index|[
literal|2
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Synaptics Touchpad v%d.%d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoMajor
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoMinor
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|infoMajor
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"  Unsupported (pre-v4) Touchpad detected\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Get the Touchpad model information */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read model information\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|sc
operator|->
name|synhw
operator|.
name|infoRot180
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoPortrait
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x40
operator|)
operator|>>
literal|6
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoSensor
operator|=
name|status
index|[
literal|0
index|]
operator|&
literal|0x3f
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoHardware
operator|=
operator|(
name|status
index|[
literal|1
index|]
operator|&
literal|0xfe
operator|)
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoNewAbs
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capPen
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x40
operator|)
operator|>>
literal|6
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoSimplC
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x20
operator|)
operator|>>
literal|5
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|infoGeometry
operator|=
name|status
index|[
literal|2
index|]
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"  Model information:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoRot180: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoRot180
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoPortrait: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoPortrait
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoSensor: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoSensor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoHardware: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoHardware
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoNewAbs: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoNewAbs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPen: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capPen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoSimplC: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoSimplC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   infoGeometry: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|infoGeometry
argument_list|)
expr_stmt|;
block|}
comment|/* Read the extended capability bits */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read extended capability bits\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Set the different capabilities when they exist */
if|if
condition|(
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
condition|)
block|{
name|sc
operator|->
name|synhw
operator|.
name|capExtended
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capPassthrough
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
operator|>>
literal|7
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capSleep
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x10
operator|)
operator|>>
literal|4
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capFourButtons
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x08
operator|)
operator|>>
literal|3
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capMultiFinger
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x02
operator|)
operator|>>
literal|1
expr_stmt|;
name|sc
operator|->
name|synhw
operator|.
name|capPalmDetect
operator|=
operator|(
name|status
index|[
literal|2
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"  Extended capabilities:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capExtended: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capExtended
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPassthrough: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capPassthrough
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capSleep: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capSleep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capFourButtons: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capFourButtons
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capMultiFinger: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capMultiFinger
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   capPalmDetect: %d\n"
argument_list|,
name|sc
operator|->
name|synhw
operator|.
name|capPalmDetect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|synhw
operator|.
name|capExtended
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"  No extended capabilities\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Read the mode byte      *      * XXX: Note the Synaptics documentation also defines the first      * byte of the response to this query to be a constant 0x3b, this      * does not appear to be true for Touchpads with guest devices.      */
if|if
condition|(
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0x47
condition|)
block|{
name|printf
argument_list|(
literal|"  Failed to read mode byte\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Set the mode byte -- request wmode where available */
if|if
condition|(
name|sc
operator|->
name|synhw
operator|.
name|capExtended
condition|)
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
else|else
name|mouse_ext_command
argument_list|(
name|kbdc
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* Reset the sampling rate */
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Interlink electronics VersaPad */
end_comment

begin_function
specifier|static
name|int
name|enable_versapad
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|data
index|[
literal|3
index|]
decl_stmt|;
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_MEDIUM_HIGH
argument_list|)
expr_stmt|;
comment|/* set res. 2 */
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* set rate 100 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
comment|/* get status */
return|return
name|FALSE
return|;
if|if
condition|(
name|data
index|[
literal|2
index|]
operator|!=
literal|0xa
operator|||
name|data
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
comment|/* rate == 0xa&& res. == 0 */
return|return
name|FALSE
return|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set scale 1:1 */
name|sc
operator|->
name|config
operator||=
name|PSM_CONFIG_HOOKRESUME
operator||
name|PSM_CONFIG_INITAFTERSUSPEND
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* PS/2 absolute mode */
block|}
end_function

begin_function
specifier|static
name|int
name|psmresume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"psm%d: system resume hook called.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_HOOKRESUME
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|reinitialize
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_INITAFTERSUSPEND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
condition|)
block|{
comment|/*  	 * Release the blocked process; it must be notified that the device 	 * cannot be accessed anymore. 	 */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: system resume hook exiting.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psm
argument_list|,
name|atkbdc
argument_list|,
name|psm_driver
argument_list|,
name|psm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This sucks up assignments from PNPBIOS and ACPI.  */
end_comment

begin_comment
comment|/*  * When the PS/2 mouse device is reported by ACPI or PnP BIOS, it may  * appear BEFORE the AT keyboard controller.  As the PS/2 mouse device  * can be probed and attached only after the AT keyboard controller is  * attached, we shall quietly reserve the IRQ resource for later use.  * If the PS/2 mouse device is reported to us AFTER the keyboard controller,  * copy the IRQ resource to the PS/2 mouse device instance hanging  * under the keyboard controller, then probe and attach it.  */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|psmcpnp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|psmcpnp_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|psmcpnp_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|psmcpnp_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|psmcpnp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|psmcpnp_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|psmcpnp_driver
init|=
block|{
name|PSMCPNP_DRIVER_NAME
block|,
name|psmcpnp_methods
block|,
literal|1
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|psmcpnp_ids
index|[]
init|=
block|{
block|{
literal|0x030fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F03 */
block|{
literal|0x130fd041
block|,
literal|"PS/2 mouse port"
block|}
block|,
comment|/* PNP0F13 */
block|{
literal|0x1303d041
block|,
literal|"PS/2 port"
block|}
block|,
comment|/* PNP0313, XXX */
block|{
literal|0x02002e4f
block|,
literal|"Dell PS/2 mouse port"
block|}
block|,
comment|/* Lat. X200, Dell */
block|{
literal|0x80374d24
block|,
literal|"IBM PS/2 mouse port"
block|}
block|,
comment|/* IBM3780, ThinkPad */
block|{
literal|0x81374d24
block|,
literal|"IBM PS/2 mouse port"
block|}
block|,
comment|/* IBM3781, ThinkPad */
block|{
literal|0x0190d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9001, Vaio */
block|{
literal|0x0290d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9002, Vaio */
block|{
literal|0x0390d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9003, Vaio */
block|{
literal|0x0490d94d
block|,
literal|"SONY VAIO PS/2 mouse port"
block|}
block|,
comment|/* SNY9004, Vaio */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|create_a_copy
parameter_list|(
name|device_t
name|atkbdc
parameter_list|,
name|device_t
name|me
parameter_list|)
block|{
name|device_t
name|psm
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
comment|/* find the PS/2 mouse device instance under the keyboard controller */
name|psm
operator|=
name|device_find_child
argument_list|(
name|atkbdc
argument_list|,
name|PSM_DRIVER_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|atkbdc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psm
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|device_get_state
argument_list|(
name|psm
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
return|return
literal|0
return|;
comment|/* move our resource to the found device */
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|me
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|psm
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|KBDC_RID_AUX
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ...then probe and attach it */
return|return
name|device_probe_and_attach
argument_list|(
name|psm
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmcpnp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|u_long
name|irq
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|psmcpnp_ids
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * The PnP BIOS and ACPI are supposed to assign an IRQ (12) 	 * to the PS/2 mouse device node. But, some buggy PnP BIOS 	 * declares the PS/2 mouse device node without an IRQ resource! 	 * If this happens, we shall refer to device hints. 	 * If we still don't find it there, use a hardcoded value... XXX 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|resource_long_value
argument_list|(
name|PSM_DRIVER_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"irq"
argument_list|,
operator|&
name|irq
argument_list|)
operator|!=
literal|0
condition|)
name|irq
operator|=
literal|12
expr_stmt|;
comment|/* XXX */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"irq resource info is missing; "
literal|"assuming irq %ld\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
comment|/* keep quiet */
if|if
condition|(
operator|!
name|bootverbose
condition|)
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|NULL
operator|)
condition|?
name|ENXIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmcpnp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|atkbdc
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* find the keyboard controller, which may be on acpi* or isa* bus */
name|atkbdc
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
name|ATKBDC_DRIVER_NAME
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|atkbdc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|device_get_state
argument_list|(
name|atkbdc
argument_list|)
operator|==
name|DS_ATTACHED
operator|)
condition|)
block|{
name|create_a_copy
argument_list|(
name|atkbdc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we don't have the AT keyboard controller yet, 		 * just reserve the IRQ for later use... 		 * (See psmidentify() above.) 		 */
name|rid
operator|=
literal|0
expr_stmt|;
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if 'now' is earlier than (start + (secs.usecs)).  * Now may be NULL and the function will fetch the current time from  * getmicrouptime(), or a cached 'now' can be passed in.  * All values should be numbers derived from getmicrouptime().  */
end_comment

begin_function
specifier|static
name|int
name|timeelapsed
parameter_list|(
name|start
parameter_list|,
name|secs
parameter_list|,
name|usecs
parameter_list|,
name|now
parameter_list|)
specifier|const
name|struct
name|timeval
modifier|*
name|start
decl_stmt|,
decl|*
name|now
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|,
name|usecs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|snow
decl_stmt|,
name|tv
decl_stmt|;
comment|/* if there is no 'now' passed in, the get it as a convience. */
if|if
condition|(
name|now
operator|==
name|NULL
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|snow
argument_list|)
expr_stmt|;
name|now
operator|=
operator|&
name|snow
expr_stmt|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|usecs
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tv
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|timevalcmp
argument_list|(
operator|&
name|tv
argument_list|,
name|now
argument_list|,
operator|<
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psmcpnp
argument_list|,
name|isa
argument_list|,
name|psmcpnp_driver
argument_list|,
name|psmcpnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|psmcpnp
argument_list|,
name|acpi
argument_list|,
name|psmcpnp_driver
argument_list|,
name|psmcpnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

