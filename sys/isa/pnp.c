begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Sujal M. Patel  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      from: pnp.c,v 1.11 1999/05/06 22:11:19 peter Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpreg.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|_pnp_id
block|{
name|uint32_t
name|vendor_id
decl_stmt|;
name|uint32_t
name|serial
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
block|}
name|pnp_id
typedef|;
end_typedef

begin_struct
struct|struct
name|pnp_set_config_arg
block|{
name|int
name|csn
decl_stmt|;
comment|/* Card number to configure */
name|int
name|ldn
decl_stmt|;
comment|/* Logical device on card */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pnp_quirk
block|{
name|uint32_t
name|vendor_id
decl_stmt|;
comment|/* Vendor of the card */
name|uint32_t
name|logical_id
decl_stmt|;
comment|/* ID of the device with quirk */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PNP_QUIRK_WRITE_REG
value|1
comment|/* Need to write a pnp register  */
define|#
directive|define
name|PNP_QUIRK_EXTRA_IO
value|2
comment|/* Has extra io ports  */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pnp_quirk
name|pnp_quirks
index|[]
init|=
block|{
comment|/* 	 * The Gravis UltraSound needs register 0xf2 to be set to 0xff 	 * to enable power. 	 * XXX need to know the logical device id. 	 */
block|{
literal|0x0100561e
comment|/* GRV0001 */
block|,
literal|0
block|,
name|PNP_QUIRK_WRITE_REG
block|,
literal|0xf2
block|,
literal|0xff
block|}
block|,
comment|/* 	 * An emu8000 does not give us other than the first 	 * port. 	 */
block|{
literal|0x26008c0e
comment|/* SB16 */
block|,
literal|0x21008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0x42008c0e
comment|/* SB32(CTL0042) */
block|,
literal|0x21008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0x44008c0e
comment|/* SB32(CTL0044) */
block|,
literal|0x21008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0x49008c0e
comment|/* SB32(CTL0049) */
block|,
literal|0x21008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0xf1008c0e
comment|/* SB32(CTL00f1) */
block|,
literal|0x21008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0xc1008c0e
comment|/* SB64(CTL00c1) */
block|,
literal|0x22008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0xc5008c0e
comment|/* SB64(CTL00c5) */
block|,
literal|0x22008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0xe4008c0e
comment|/* SB64(CTL00e4) */
block|,
literal|0x22008c0e
block|,
name|PNP_QUIRK_EXTRA_IO
block|,
literal|0x400
block|,
literal|0x800
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_comment
comment|/* Some NEC PnP cards have 9 bytes serial code. */
end_comment

begin_decl_stmt
specifier|static
name|pnp_id
name|necids
index|[]
init|=
block|{
block|{
literal|0x4180a3b8
block|,
literal|0xffffffff
block|,
literal|0x00
block|}
block|,
comment|/* PC-9801CB-B04 (NEC8041) */
block|{
literal|0x5181a3b8
block|,
literal|0xffffffff
block|,
literal|0x46
block|}
block|,
comment|/* PC-9821CB2-B04(NEC8151) */
block|{
literal|0x5182a3b8
block|,
literal|0xffffffff
block|,
literal|0xb8
block|}
block|,
comment|/* PC-9801-XX    (NEC8251) */
block|{
literal|0x9181a3b8
block|,
literal|0xffffffff
block|,
literal|0x00
block|}
block|,
comment|/* PC-9801-120   (NEC8191) */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The READ_DATA port that we are using currently */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pnp_rd_port
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pnp_send_initiation_key
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnp_isolation_protocol
parameter_list|(
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|pnp_eisaformat
parameter_list|(
name|uint32_t
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|data
decl_stmt|;
specifier|static
name|char
name|idbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|char
name|hextoascii
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|id
operator|=
name|htole32
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|id
expr_stmt|;
name|idbuf
index|[
literal|0
index|]
operator|=
literal|'@'
operator|+
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|idbuf
index|[
literal|1
index|]
operator|=
literal|'@'
operator|+
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|idbuf
index|[
literal|2
index|]
operator|=
literal|'@'
operator|+
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|idbuf
index|[
literal|3
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|4
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|5
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|6
index|]
operator|=
name|hextoascii
index|[
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|idbuf
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|idbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pnp_write
parameter_list|(
name|int
name|d
parameter_list|,
name|u_char
name|r
parameter_list|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_WRITE_DATA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send Initiation LFSR as described in "Plug and Play ISA Specification",  * Intel May 94.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_send_initiation_key
parameter_list|()
block|{
name|int
name|cur
decl_stmt|,
name|i
decl_stmt|;
comment|/* Reset the LSFR */
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* yes, we do need it twice! */
name|cur
operator|=
literal|0x6a
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|=
operator|(
name|cur
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|cur
operator|^
operator|(
name|cur
operator|>>
literal|1
operator|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the device's serial number.  Returns 1 if the serial is valid.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|valid
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0x6a
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|p
decl_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_SERIAL_ISOLATION
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|++
control|)
block|{
name|bit
operator|=
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0x55
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
comment|/* Can't Short Circuit the next evaluation, so 'and' is last */
name|bit
operator|=
operator|(
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0xaa
operator|)
operator|&&
name|bit
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
name|valid
operator|=
name|valid
operator|||
name|bit
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|sum
operator|^
operator|(
name|sum
operator|>>
literal|1
operator|)
operator|^
name|bit
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|=
operator|(
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|>>
literal|1
operator|)
operator||
operator|(
name|bit
condition|?
literal|0x80
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|valid
operator|=
name|valid
operator|&&
operator|(
name|data
index|[
literal|8
index|]
operator|==
name|sum
operator|)
expr_stmt|;
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill's the buffer with resource info from the device.  * Returns the number of characters read.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_get_resource_info
parameter_list|(
name|u_char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|;
name|u_char
name|temp
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_STATUS
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|)
operator|&
literal|0x1
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|100
condition|)
block|{
name|printf
argument_list|(
literal|"PnP device failed to report resource data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_RESOURCE_DATA
argument_list|)
expr_stmt|;
name|temp
operator|=
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the bus has assigned resource  * locations for a logical device.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_set_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|isa_config
modifier|*
name|config
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|csn
init|=
operator|(
operator|(
expr|struct
name|pnp_set_config_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|csn
decl_stmt|;
name|int
name|ldn
init|=
operator|(
operator|(
expr|struct
name|pnp_set_config_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|ldn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First put all cards into Sleep state with the initiation 	 * key, then put our card into Config state. 	 */
name|pnp_send_initiation_key
argument_list|()
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* 	 * Select our logical device so that we can program it. 	 */
name|pnp_write
argument_list|(
name|PNP_SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
comment|/* 	 * Constrain the number of resources we will try to program 	 */
if|if
condition|(
name|config
operator|->
name|ic_nmem
operator|>
name|ISA_PNP_NMEM
condition|)
block|{
name|printf
argument_list|(
literal|"too many ISA memory ranges (%d> %d)\n"
argument_list|,
name|config
operator|->
name|ic_nmem
argument_list|,
name|ISA_PNP_NMEM
argument_list|)
expr_stmt|;
name|config
operator|->
name|ic_nmem
operator|=
name|ISA_PNP_NMEM
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|->
name|ic_nport
operator|>
name|ISA_PNP_NPORT
condition|)
block|{
name|printf
argument_list|(
literal|"too many ISA I/O ranges (%d> %d)\n"
argument_list|,
name|config
operator|->
name|ic_nport
argument_list|,
name|ISA_PNP_NPORT
argument_list|)
expr_stmt|;
name|config
operator|->
name|ic_nport
operator|=
name|ISA_PNP_NPORT
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|->
name|ic_nirq
operator|>
name|ISA_PNP_NIRQ
condition|)
block|{
name|printf
argument_list|(
literal|"too many ISA IRQs (%d> %d)\n"
argument_list|,
name|config
operator|->
name|ic_nirq
argument_list|,
name|ISA_PNP_NIRQ
argument_list|)
expr_stmt|;
name|config
operator|->
name|ic_nirq
operator|=
name|ISA_PNP_NIRQ
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|->
name|ic_ndrq
operator|>
name|ISA_PNP_NDRQ
condition|)
block|{
name|printf
argument_list|(
literal|"too many ISA DRQs (%d> %d)\n"
argument_list|,
name|config
operator|->
name|ic_ndrq
argument_list|,
name|ISA_PNP_NDRQ
argument_list|)
expr_stmt|;
name|config
operator|->
name|ic_ndrq
operator|=
name|ISA_PNP_NDRQ
expr_stmt|;
block|}
comment|/* 	 * Now program the resources. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nmem
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|start
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
comment|/* XXX: should handle memory control register, 32 bit memory */
if|if
condition|(
name|config
operator|->
name|ic_mem
index|[
name|i
index|]
operator|.
name|ir_size
operator|==
literal|0
condition|)
block|{
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|config
operator|->
name|ic_mem
index|[
name|i
index|]
operator|.
name|ir_start
expr_stmt|;
name|size
operator|=
name|config
operator|->
name|ic_mem
index|[
name|i
index|]
operator|.
name|ir_size
expr_stmt|;
if|if
condition|(
name|start
operator|&
literal|0xff
condition|)
name|panic
argument_list|(
literal|"pnp_set_config: bogus memory assignment"
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|size
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|size
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_PNP_NMEM
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nport
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|start
decl_stmt|;
if|if
condition|(
name|config
operator|->
name|ic_port
index|[
name|i
index|]
operator|.
name|ir_size
operator|==
literal|0
condition|)
block|{
name|pnp_write
argument_list|(
name|PNP_IO_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|config
operator|->
name|ic_port
index|[
name|i
index|]
operator|.
name|ir_start
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|0
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_PNP_NPORT
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|PNP_IO_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nirq
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq
decl_stmt|;
comment|/* XXX: interrupt type */
if|if
condition|(
name|config
operator|->
name|ic_irqmask
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|pnp_write
argument_list|(
name|PNP_IRQ_LEVEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|irq
operator|=
name|ffs
argument_list|(
name|config
operator|->
name|ic_irqmask
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_LEVEL
argument_list|(
name|i
argument_list|)
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_PNP_NIRQ
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * IRQ 0 is not a valid interrupt selection and 		 * represents no interrupt selection. 		 */
name|pnp_write
argument_list|(
name|PNP_IRQ_LEVEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_ndrq
condition|;
name|i
operator|++
control|)
block|{
name|int
name|drq
decl_stmt|;
if|if
condition|(
name|config
operator|->
name|ic_drqmask
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|pnp_write
argument_list|(
name|PNP_DMA_CHANNEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drq
operator|=
name|ffs
argument_list|(
name|config
operator|->
name|ic_drqmask
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_DMA_CHANNEL
argument_list|(
name|i
argument_list|)
argument_list|,
name|drq
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_PNP_NDRQ
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * DMA channel 4, the cascade channel is used to 		 * indicate no DMA channel is active. 		 */
name|pnp_write
argument_list|(
name|PNP_DMA_CHANNEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|pnp_write
argument_list|(
name|PNP_ACTIVATE
argument_list|,
name|enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Wake everyone up again, we are finished. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_WAIT_FOR_KEY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process quirks for a logical device.. The card must be in Config state.  */
end_comment

begin_function
name|void
name|pnp_check_quirks
parameter_list|(
name|uint32_t
name|vendor_id
parameter_list|,
name|uint32_t
name|logical_id
parameter_list|,
name|int
name|ldn
parameter_list|,
name|struct
name|isa_config
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|pnp_quirk
modifier|*
name|qp
decl_stmt|;
for|for
control|(
name|qp
operator|=
operator|&
name|pnp_quirks
index|[
literal|0
index|]
init|;
name|qp
operator|->
name|vendor_id
condition|;
name|qp
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|vendor_id
operator|==
name|vendor_id
operator|&&
operator|(
name|qp
operator|->
name|logical_id
operator|==
literal|0
operator|||
name|qp
operator|->
name|logical_id
operator|==
name|logical_id
operator|)
condition|)
block|{
switch|switch
condition|(
name|qp
operator|->
name|type
condition|)
block|{
case|case
name|PNP_QUIRK_WRITE_REG
case|:
name|pnp_write
argument_list|(
name|PNP_SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|qp
operator|->
name|arg1
argument_list|,
name|qp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNP_QUIRK_EXTRA_IO
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|qp
operator|->
name|arg1
operator|!=
literal|0
condition|)
block|{
name|config
operator|->
name|ic_nport
operator|++
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|=
name|config
operator|->
name|ic_port
index|[
literal|0
index|]
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|.
name|ir_start
operator|+=
name|qp
operator|->
name|arg1
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|.
name|ir_end
operator|+=
name|qp
operator|->
name|arg1
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|arg2
operator|!=
literal|0
condition|)
block|{
name|config
operator|->
name|ic_nport
operator|++
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|=
name|config
operator|->
name|ic_port
index|[
literal|0
index|]
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|.
name|ir_start
operator|+=
name|qp
operator|->
name|arg2
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
operator|-
literal|1
index|]
operator|.
name|ir_end
operator|+=
name|qp
operator|->
name|arg2
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Scan Resource Data for Logical Devices.  *  * This function exits as soon as it gets an error reading *ANY*  * Resource Data or it reaches the end of Resource Data.  In the first  * case the return value will be TRUE, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_create_devices
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|pnp_id
modifier|*
name|p
parameter_list|,
name|int
name|csn
parameter_list|,
name|u_char
modifier|*
name|resources
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
name|tag
decl_stmt|,
modifier|*
name|resp
decl_stmt|,
modifier|*
name|resinfo
decl_stmt|,
modifier|*
name|startres
init|=
name|NULL
decl_stmt|;
name|int
name|large_len
decl_stmt|,
name|scanning
init|=
name|len
decl_stmt|,
name|retval
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|logical_id
decl_stmt|;
name|device_t
name|dev
init|=
literal|0
decl_stmt|;
name|int
name|ldn
init|=
literal|0
decl_stmt|;
name|struct
name|pnp_set_config_arg
modifier|*
name|csnldn
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
name|resp
operator|=
name|resources
expr_stmt|;
while|while
condition|(
name|scanning
operator|>
literal|0
condition|)
block|{
name|tag
operator|=
operator|*
name|resp
operator|++
expr_stmt|;
name|scanning
operator|--
expr_stmt|;
if|if
condition|(
name|PNP_RES_TYPE
argument_list|(
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Large resource */
if|if
condition|(
name|scanning
operator|<
literal|2
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|large_len
operator|=
name|resp
index|[
literal|0
index|]
operator|+
operator|(
name|resp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|resp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|scanning
operator|<
name|large_len
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|resinfo
operator|=
name|resp
expr_stmt|;
name|resp
operator|+=
name|large_len
expr_stmt|;
name|scanning
operator|-=
name|large_len
expr_stmt|;
if|if
condition|(
name|PNP_LRES_NUM
argument_list|(
name|tag
argument_list|)
operator|==
name|PNP_TAG_ID_ANSI
condition|)
block|{
if|if
condition|(
name|dev
condition|)
block|{
comment|/* 					 * This is an optional device 					 * identifier string. Skip it 					 * for now. 					 */
continue|continue;
block|}
comment|/* else mandately card identifier string */
if|if
condition|(
name|large_len
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|large_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|resinfo
argument_list|,
name|buf
argument_list|,
name|large_len
argument_list|)
expr_stmt|;
comment|/* 				 * Trim trailing spaces. 				 */
while|while
condition|(
name|buf
index|[
name|large_len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|large_len
operator|--
expr_stmt|;
name|buf
index|[
name|large_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|=
name|buf
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
comment|/* Small resource */
if|if
condition|(
name|scanning
operator|<
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|resinfo
operator|=
name|resp
expr_stmt|;
name|resp
operator|+=
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|scanning
operator|-=
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PNP_SRES_NUM
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|PNP_TAG_LOGICAL_DEVICE
case|:
comment|/* 			 * Parse the resources for the previous 			 * logical device (if any). 			 */
if|if
condition|(
name|startres
condition|)
block|{
name|pnp_parse_resources
argument_list|(
name|dev
argument_list|,
name|startres
argument_list|,
name|resinfo
operator|-
name|startres
operator|-
literal|1
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|dev
operator|=
literal|0
expr_stmt|;
name|startres
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  			 * A new logical device. Scan for end of 			 * resources. 			 */
name|bcopy
argument_list|(
name|resinfo
argument_list|,
operator|&
name|logical_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pnp_check_quirks
argument_list|(
name|p
operator|->
name|vendor_id
argument_list|,
name|logical_id
argument_list|,
name|ldn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|ISA_ORDER_PNP
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
else|else
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|pnp_eisaformat
argument_list|(
name|logical_id
argument_list|)
argument_list|)
expr_stmt|;
name|isa_set_vendorid
argument_list|(
name|dev
argument_list|,
name|p
operator|->
name|vendor_id
argument_list|)
expr_stmt|;
name|isa_set_serial
argument_list|(
name|dev
argument_list|,
name|p
operator|->
name|serial
argument_list|)
expr_stmt|;
name|isa_set_logicalid
argument_list|(
name|dev
argument_list|,
name|logical_id
argument_list|)
expr_stmt|;
name|isa_set_configattr
argument_list|(
name|dev
argument_list|,
name|ISACFGATTR_CANDISABLE
operator||
name|ISACFGATTR_DYNAMIC
argument_list|)
expr_stmt|;
name|csnldn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|csnldn
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csnldn
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|csnldn
operator|->
name|csn
operator|=
name|csn
expr_stmt|;
name|csnldn
operator|->
name|ldn
operator|=
name|ldn
expr_stmt|;
name|ISA_SET_CONFIG_CALLBACK
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|pnp_set_config
argument_list|,
name|csnldn
argument_list|)
expr_stmt|;
name|isa_set_pnp_csn
argument_list|(
name|dev
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|isa_set_pnp_ldn
argument_list|(
name|dev
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|ldn
operator|++
expr_stmt|;
name|startres
operator|=
name|resp
expr_stmt|;
break|break;
case|case
name|PNP_TAG_END
case|:
if|if
condition|(
operator|!
name|startres
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"malformed resources\n"
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pnp_parse_resources
argument_list|(
name|dev
argument_list|,
name|startres
argument_list|,
name|resinfo
operator|-
name|startres
operator|-
literal|1
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|dev
operator|=
literal|0
expr_stmt|;
name|startres
operator|=
name|NULL
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Skip this resource */
break|break;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read 'amount' bytes of resources from the card, allocating memory  * as needed. If a buffer is already available, it should be passed in  * '*resourcesp' and its length in '*spacep'. The number of resource  * bytes already in the buffer should be passed in '*lenp'. The memory  * allocated will be returned in '*resourcesp' with its size and the  * number of bytes of resources in '*spacep' and '*lenp' respectively.  *  * XXX: Multiple problems here, we forget to free() stuff in one  * XXX: error return, and in another case we free (*resourcesp) but  * XXX: don't tell the caller.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_read_bytes
parameter_list|(
name|int
name|amount
parameter_list|,
name|u_char
modifier|*
modifier|*
name|resourcesp
parameter_list|,
name|int
modifier|*
name|spacep
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|u_char
modifier|*
name|resources
init|=
operator|*
name|resourcesp
decl_stmt|;
name|u_char
modifier|*
name|newres
decl_stmt|;
name|int
name|space
init|=
operator|*
name|spacep
decl_stmt|;
name|int
name|len
init|=
operator|*
name|lenp
decl_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|space
operator|=
literal|1024
expr_stmt|;
name|resources
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resources
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|+
name|amount
operator|>
name|space
condition|)
block|{
name|int
name|extra
init|=
literal|1024
decl_stmt|;
while|while
condition|(
name|len
operator|+
name|amount
operator|>
name|space
operator|+
name|extra
condition|)
name|extra
operator|+=
literal|1024
expr_stmt|;
name|newres
operator|=
name|malloc
argument_list|(
name|space
operator|+
name|extra
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newres
condition|)
block|{
comment|/* XXX: free resources */
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|resources
argument_list|,
name|newres
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resources
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|resources
operator|=
name|newres
expr_stmt|;
name|space
operator|+=
name|extra
expr_stmt|;
block|}
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|resources
operator|+
name|len
argument_list|,
name|amount
argument_list|)
operator|!=
name|amount
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|+=
name|amount
expr_stmt|;
operator|*
name|resourcesp
operator|=
name|resources
expr_stmt|;
operator|*
name|spacep
operator|=
name|space
expr_stmt|;
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read all resources from the card, allocating memory as needed. If a  * buffer is already available, it should be passed in '*resourcesp'  * and its length in '*spacep'. The memory allocated will be returned  * in '*resourcesp' with its size and the number of bytes of resources  * in '*spacep' and '*lenp' respectively.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_read_resources
parameter_list|(
name|u_char
modifier|*
modifier|*
name|resourcesp
parameter_list|,
name|int
modifier|*
name|spacep
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|u_char
modifier|*
name|resources
init|=
operator|*
name|resourcesp
decl_stmt|;
name|int
name|space
init|=
operator|*
name|spacep
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|done
decl_stmt|;
name|u_char
name|tag
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|error
operator|=
name|pnp_read_bytes
argument_list|(
literal|1
argument_list|,
operator|&
name|resources
argument_list|,
operator|&
name|space
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|tag
operator|=
name|resources
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|PNP_RES_TYPE
argument_list|(
name|tag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Small resource, read contents. 			 */
name|error
operator|=
name|pnp_read_bytes
argument_list|(
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
argument_list|,
operator|&
name|resources
argument_list|,
operator|&
name|space
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|PNP_SRES_NUM
argument_list|(
name|tag
argument_list|)
operator|==
name|PNP_TAG_END
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Large resource, read length and contents. 			 */
name|error
operator|=
name|pnp_read_bytes
argument_list|(
literal|2
argument_list|,
operator|&
name|resources
argument_list|,
operator|&
name|space
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|pnp_read_bytes
argument_list|(
name|resources
index|[
name|len
operator|-
literal|2
index|]
operator|+
operator|(
name|resources
index|[
name|len
operator|-
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|,
operator|&
name|resources
argument_list|,
operator|&
name|space
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
operator|*
name|resourcesp
operator|=
name|resources
expr_stmt|;
operator|*
name|spacep
operator|=
name|space
expr_stmt|;
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the isolation protocol. Use pnp_rd_port as the READ_DATA port  * value (caller should try multiple READ_DATA locations before giving  * up). Upon exiting, all cards are aware that they should use  * pnp_rd_port as the READ_DATA port.  *  * In the first pass, a csn is assigned to each board and pnp_id's  * are saved to an array, pnp_devices. In the second pass, each  * card is woken up and the device configuration is called.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_isolation_protocol
parameter_list|(
name|device_t
name|parent
parameter_list|)
block|{
name|int
name|csn
decl_stmt|;
name|pnp_id
name|id
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|u_char
modifier|*
name|resources
init|=
name|NULL
decl_stmt|;
name|int
name|space
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
name|n
decl_stmt|,
name|necpnp
decl_stmt|;
name|u_char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Put all cards into the Sleep state so that we can clear 	 * their CSNs. 	 */
name|pnp_send_initiation_key
argument_list|()
expr_stmt|;
comment|/* 	 * Clear the CSN for all cards. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_RESET_CSN
argument_list|)
expr_stmt|;
comment|/* 	 * Move all cards to the Isolation state. 	 */
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell them where the read point is going to be this time. 	 */
name|pnp_write
argument_list|(
name|PNP_SET_RD_DATA
argument_list|,
name|pnp_rd_port
argument_list|)
expr_stmt|;
for|for
control|(
name|csn
operator|=
literal|1
init|;
name|csn
operator|<
name|PNP_MAX_CARDS
condition|;
name|csn
operator|++
control|)
block|{
comment|/* 		 * Start the serial isolation protocol. 		 */
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_SERIAL_ISOLATION
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Delay 1 msec */
if|if
condition|(
name|pnp_get_serial
argument_list|(
operator|&
name|id
argument_list|)
condition|)
block|{
comment|/* 			 * We have read the id from a card 			 * successfully. The card which won the 			 * isolation protocol will be in Isolation 			 * mode and all others will be in Sleep. 			 * Program the CSN of the isolated card 			 * (taking it to Config state) and read its 			 * resources, creating devices as we find 			 * logical devices on the card. 			 */
name|pnp_write
argument_list|(
name|PNP_SET_CSN
argument_list|,
name|csn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PnP Vendor ID = %x\n"
argument_list|,
name|id
operator|.
name|vendor_id
argument_list|)
expr_stmt|;
comment|/* Check for NEC PnP (9 bytes serial). */
for|for
control|(
name|n
operator|=
name|necpnp
operator|=
literal|0
init|;
name|necids
index|[
name|n
index|]
operator|.
name|vendor_id
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|.
name|vendor_id
operator|==
name|necids
index|[
name|n
index|]
operator|.
name|vendor_id
condition|)
block|{
name|necpnp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|necpnp
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"An NEC-PnP card (%s).\n"
argument_list|,
name|pnp_eisaformat
argument_list|(
name|id
operator|.
name|vendor_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Read dummy 9 bytes serial area. */
name|pnp_get_resource_info
argument_list|(
name|buffer
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"A Normal-ISA-PnP card (%s).\n"
argument_list|,
name|pnp_eisaformat
argument_list|(
name|id
operator|.
name|vendor_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Reading PnP configuration for %s.\n"
argument_list|,
name|pnp_eisaformat
argument_list|(
name|id
operator|.
name|vendor_id
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|pnp_read_resources
argument_list|(
operator|&
name|resources
argument_list|,
operator|&
name|space
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|pnp_create_devices
argument_list|(
name|parent
argument_list|,
operator|&
name|id
argument_list|,
name|csn
argument_list|,
name|resources
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
break|break;
comment|/* 		 * Put this card back to the Sleep state and 		 * simultaneously move all cards which don't have a 		 * CSN yet to Isolation state. 		 */
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unless we have chosen the wrong read port, all cards will 	 * be in Sleep state. Put them back into WaitForKey for 	 * now. Their resources will be programmed later. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_WAIT_FOR_KEY
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup. 	 */
if|if
condition|(
name|resources
condition|)
name|free
argument_list|(
name|resources
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pnp_identify()  *  * autoconfiguration of pnp devices. This routine just runs the  * isolation protocol over several ports, until one is successful.  *  * may be called more than once ?  *  */
end_comment

begin_function
specifier|static
name|void
name|pnp_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|int
name|num_pnp_devs
decl_stmt|;
comment|/* Try various READ_DATA ports from 0x203-0x3ff */
for|for
control|(
name|pnp_rd_port
operator|=
literal|0x80
init|;
operator|(
name|pnp_rd_port
operator|<
literal|0xff
operator|)
condition|;
name|pnp_rd_port
operator|+=
literal|0x10
control|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"pnp_identify: Trying Read_Port at %x\n"
argument_list|,
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|num_pnp_devs
operator|=
name|pnp_isolation_protocol
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_pnp_devs
condition|)
break|break;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PNP Identify complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pnp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|pnp_identify
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pnp_driver
init|=
block|{
literal|"pnp"
block|,
name|pnp_methods
block|,
literal|1
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pnp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pnp
argument_list|,
name|isa
argument_list|,
name|pnp_driver
argument_list|,
name|pnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

