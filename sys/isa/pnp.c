begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Sujal M. Patel  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  *      from: pnp.c,v 1.11 1999/05/06 22:11:19 peter Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpreg.h>
end_include

begin_include
include|#
directive|include
file|<isa/pnpvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|_pnp_id
block|{
name|u_int32_t
name|vendor_id
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
block|}
name|pnp_id
typedef|;
end_typedef

begin_struct
struct|struct
name|pnp_set_config_arg
block|{
name|int
name|csn
decl_stmt|;
comment|/* Card number to configure */
name|int
name|ldn
decl_stmt|;
comment|/* Logical device on card */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pnp_quirk
block|{
name|u_int32_t
name|vendor_id
decl_stmt|;
comment|/* Vendor of the card */
name|u_int32_t
name|logical_id
decl_stmt|;
comment|/* ID of the device with quirk */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PNP_QUIRK_WRITE_REG
value|1
comment|/* Need to write a pnp register  */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pnp_quirk
name|pnp_quirks
index|[]
init|=
block|{
comment|/* 	 * The Gravis UltraSound needs register 0xf2 to be set to 0xff 	 * to enable power. 	 * XXX need to know the logical device id. 	 */
block|{
literal|0x0100561e
comment|/* GRV0001 */
block|,
literal|0
block|,
name|PNP_QUIRK_WRITE_REG
block|,
literal|0xf2
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * these entries are initialized using the autoconfig menu  * The struct is invalid (and must be initialized) if the first  * CSN is zero. The init code fills invalid entries with CSN 255  * which is not a supported value.  */
end_comment

begin_endif
unit|struct pnp_cinfo pnp_ldn_overrides[MAX_PNP_LDN] = {     { 0 } };
endif|#
directive|endif
end_endif

begin_comment
comment|/* The READ_DATA port that we are using currently */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pnp_rd_port
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pnp_send_initiation_key
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnp_isolation_protocol
parameter_list|(
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pnp_write
parameter_list|(
name|int
name|d
parameter_list|,
name|u_char
name|r
parameter_list|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_WRITE_DATA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_char pnp_read(int d) { 	outb (_PNP_ADDRESS, d); 	return (inb(3 | (pnp_rd_port<<2))); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Send Initiation LFSR as described in "Plug and Play ISA Specification",  * Intel May 94.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_send_initiation_key
parameter_list|()
block|{
name|int
name|cur
decl_stmt|,
name|i
decl_stmt|;
comment|/* Reset the LSFR */
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* yes, we do need it twice! */
name|cur
operator|=
literal|0x6a
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|=
operator|(
name|cur
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|cur
operator|^
operator|(
name|cur
operator|>>
literal|1
operator|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the device's serial number.  Returns 1 if the serial is valid.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|valid
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0x6a
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|p
decl_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_SERIAL_ISOLATION
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|++
control|)
block|{
name|bit
operator|=
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0x55
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
comment|/* Can't Short Circuit the next evaluation, so 'and' is last */
name|bit
operator|=
operator|(
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0xaa
operator|)
operator|&&
name|bit
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
name|valid
operator|=
name|valid
operator|||
name|bit
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|sum
operator|^
operator|(
name|sum
operator|>>
literal|1
operator|)
operator|^
name|bit
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|=
operator|(
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|>>
literal|1
operator|)
operator||
operator|(
name|bit
condition|?
literal|0x80
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|valid
operator|=
name|valid
operator|&&
operator|(
name|data
index|[
literal|8
index|]
operator|==
name|sum
operator|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/*  * Fill's the buffer with resource info from the device.  * Returns 0 if the device fails to report  */
end_comment

begin_function
specifier|static
name|int
name|pnp_get_resource_info
parameter_list|(
name|u_char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_STATUS
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|)
operator|&
literal|0x1
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|100
condition|)
block|{
name|printf
argument_list|(
literal|"PnP device failed to report resource data\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_RESOURCE_DATA
argument_list|)
expr_stmt|;
name|temp
operator|=
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * write_pnp_parms initializes a logical device with the parms  * in d, and then activates the board if the last parameter is 1.  */
end_comment

begin_comment
unit|static int write_pnp_parms(struct pnp_cinfo *d, pnp_id *p, int ldn) {     int i, empty = -1 ;      pnp_write (SET_LDN, ldn );     i = pnp_read(SET_LDN) ;     if (i != ldn) { 	printf("Warning: LDN %d does not exist\n", ldn);     }     for (i = 0; i< 8; i++) { 	pnp_write(IO_CONFIG_BASE + i * 2, d->ic_port[i]>> 8 ); 	pnp_write(IO_CONFIG_BASE + i * 2 + 1, d->ic_port[i]& 0xff );     }     for (i = 0; i< 4; i++) { 	pnp_write(MEM_CONFIG + i*8, (d->ic_mem[i].base>> 16)& 0xff ); 	pnp_write(MEM_CONFIG + i*8+1, (d->ic_mem[i].base>> 8)& 0xff ); 	pnp_write(MEM_CONFIG + i*8+2, d->ic_mem[i].control& 0xff ); 	pnp_write(MEM_CONFIG + i*8+3, (d->ic_mem[i].range>> 16)& 0xff ); 	pnp_write(MEM_CONFIG + i*8+4, (d->ic_mem[i].range>> 8)& 0xff );     }     for (i = 0; i< 2; i++) { 	pnp_write(IRQ_CONFIG + i*2    , d->irq[i] ); 	pnp_write(IRQ_CONFIG + i*2 + 1, d->irq_type[i] ); 	pnp_write(DRQ_CONFIG + i, d->drq[i] );     }
comment|/*      * store parameters read into the current kernel      * so manual editing next time is easier      */
end_comment

begin_comment
unit|for (i = 0 ; i< MAX_PNP_LDN; i++) { 	if (pnp_ldn_overrides[i].csn == d->csn&& 		pnp_ldn_overrides[i].ldn == ldn) { 	    d->flags = pnp_ldn_overrides[i].flags ; 	    pnp_ldn_overrides[i] = *d ; 	    break ; 	} else if (pnp_ldn_overrides[i].csn< 1 || 		pnp_ldn_overrides[i].csn == 255) 	    empty = i ;     }     if (i== MAX_PNP_LDN&& empty != -1) 	pnp_ldn_overrides[empty] = *d;
comment|/*      * Here should really perform the range check, and      * return a failure if not successful.      */
end_comment

begin_comment
unit|pnp_write (IO_RANGE_CHECK, 0);     DELAY(1000);
comment|/* XXX is it really necessary ? */
end_comment

begin_comment
unit|pnp_write (ACTIVATE, d->enable ? 1 : 0);     DELAY(1000);
comment|/* XXX is it really necessary ? */
end_comment

begin_endif
unit|return 1 ; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This function is called after the bus has assigned resource  * locations for a logical device.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_set_config
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|isa_config
modifier|*
name|config
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|csn
init|=
operator|(
operator|(
expr|struct
name|pnp_set_config_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|csn
decl_stmt|;
name|int
name|ldn
init|=
operator|(
operator|(
expr|struct
name|pnp_set_config_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|ldn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * First put all cards into Sleep state with the initiation 	 * key, then put our card into Config state. 	 */
name|pnp_send_initiation_key
argument_list|()
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* 	 * Select our logical device so that we can program it. 	 */
name|pnp_write
argument_list|(
name|PNP_SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
comment|/* 	 * Now program the resources. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nmem
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|start
init|=
name|config
operator|->
name|ic_mem
index|[
name|i
index|]
operator|.
name|ir_start
decl_stmt|;
name|u_int32_t
name|size
init|=
name|config
operator|->
name|ic_mem
index|[
name|i
index|]
operator|.
name|ir_size
decl_stmt|;
if|if
condition|(
name|start
operator|&
literal|0xff
condition|)
name|panic
argument_list|(
literal|"pnp_set_config: bogus memory assignment"
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|size
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|size
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_NMEM
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_MEM_RANGE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nport
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|start
init|=
name|config
operator|->
name|ic_port
index|[
name|i
index|]
operator|.
name|ir_start
decl_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|start
operator|>>
literal|0
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_NPORT
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|PNP_IO_BASE_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IO_BASE_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_nirq
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq
init|=
name|ffs
argument_list|(
name|config
operator|->
name|ic_irqmask
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
decl_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_LEVEL
argument_list|(
name|i
argument_list|)
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|PNP_IRQ_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_NIRQ
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * IRQ 0 is not a valid interrupt selection and 		 * represents no interrupt selection. 		 */
name|pnp_write
argument_list|(
name|PNP_IRQ_LEVEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|ic_ndrq
condition|;
name|i
operator|++
control|)
block|{
name|int
name|drq
init|=
name|ffs
argument_list|(
name|config
operator|->
name|ic_drqmask
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
decl_stmt|;
name|pnp_write
argument_list|(
name|PNP_DMA_CHANNEL
argument_list|(
name|i
argument_list|)
argument_list|,
name|drq
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|ISA_NDRQ
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * DMA channel 4, the cascade channel is used to 		 * indicate no DMA channel is active. 		 */
name|pnp_write
argument_list|(
name|PNP_DMA_CHANNEL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|pnp_write
argument_list|(
name|PNP_ACTIVATE
argument_list|,
name|enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Wake everyone up again, we are finished. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_WAIT_FOR_KEY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process quirks for a logical device.. The card must be in Config state.  */
end_comment

begin_function
specifier|static
name|void
name|pnp_check_quirks
parameter_list|(
name|u_int32_t
name|vendor_id
parameter_list|,
name|u_int32_t
name|logical_id
parameter_list|,
name|int
name|ldn
parameter_list|)
block|{
name|struct
name|pnp_quirk
modifier|*
name|qp
decl_stmt|;
for|for
control|(
name|qp
operator|=
operator|&
name|pnp_quirks
index|[
literal|0
index|]
init|;
name|qp
operator|->
name|vendor_id
condition|;
name|qp
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|vendor_id
operator|==
name|vendor_id
operator|&&
operator|(
name|qp
operator|->
name|logical_id
operator|==
literal|0
operator|||
name|qp
operator|->
name|logical_id
operator|==
name|logical_id
operator|)
condition|)
block|{
switch|switch
condition|(
name|qp
operator|->
name|type
condition|)
block|{
case|case
name|PNP_QUIRK_WRITE_REG
case|:
name|pnp_write
argument_list|(
name|PNP_SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|qp
operator|->
name|arg1
argument_list|,
name|qp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Scan Resource Data for Logical Devices.  *  * This function exits as soon as it gets an error reading *ANY*  * Resource Data or ir reaches the end of Resource Data.  In the first  * case the return value will be TRUE, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_scan_resdata
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|pnp_id
modifier|*
name|p
parameter_list|,
name|int
name|csn
parameter_list|)
block|{
name|u_char
name|tag
decl_stmt|,
name|resinfo
index|[
literal|16
index|]
decl_stmt|;
name|int
name|large_len
decl_stmt|,
name|scanning
init|=
literal|1024
decl_stmt|,
name|retval
init|=
name|FALSE
decl_stmt|;
name|u_int32_t
name|logical_id
decl_stmt|;
name|u_int32_t
name|compat_id
decl_stmt|;
name|device_t
name|dev
init|=
literal|0
decl_stmt|;
name|int
name|ldn
init|=
literal|0
decl_stmt|;
name|struct
name|isa_config
name|card
decl_stmt|,
name|logdev
decl_stmt|,
name|alt
decl_stmt|;
name|struct
name|isa_config
modifier|*
name|config
decl_stmt|;
name|struct
name|pnp_set_config_arg
modifier|*
name|csnldn
decl_stmt|;
name|int
name|priority
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|desc
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|card
argument_list|,
sizeof|sizeof
name|card
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|logdev
argument_list|,
sizeof|sizeof
name|logdev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|alt
argument_list|,
sizeof|sizeof
name|alt
argument_list|)
expr_stmt|;
name|config
operator|=
operator|&
name|card
expr_stmt|;
while|while
condition|(
name|scanning
operator|--
operator|>
literal|0
operator|&&
name|pnp_get_resource_info
argument_list|(
operator|&
name|tag
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|PNP_RES_TYPE
argument_list|(
name|tag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Small resource */
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|resinfo
argument_list|,
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|PNP_SRES_NUM
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|PNP_TAG_LOGIGAL_DEVICE
case|:
comment|/*  				 * A new logical device. Scan 				 * resourcea and add device. 				 */
name|bcopy
argument_list|(
name|resinfo
argument_list|,
operator|&
name|logical_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pnp_check_quirks
argument_list|(
name|p
operator|->
name|vendor_id
argument_list|,
name|logical_id
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|compat_id
operator|=
literal|0
expr_stmt|;
name|logdev
operator|=
name|card
expr_stmt|;
name|config
operator|=
operator|&
name|logdev
expr_stmt|;
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|ISA_ORDER_PNP
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|isa_set_vendorid
argument_list|(
name|dev
argument_list|,
name|p
operator|->
name|vendor_id
argument_list|)
expr_stmt|;
name|isa_set_serial
argument_list|(
name|dev
argument_list|,
name|p
operator|->
name|serial
argument_list|)
expr_stmt|;
name|isa_set_logicalid
argument_list|(
name|dev
argument_list|,
name|logical_id
argument_list|)
expr_stmt|;
name|csnldn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|csnldn
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csnldn
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|csnldn
operator|->
name|csn
operator|=
name|csn
expr_stmt|;
name|csnldn
operator|->
name|ldn
operator|=
name|ldn
expr_stmt|;
name|ISA_SET_CONFIG_CALLBACK
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|pnp_set_config
argument_list|,
name|csnldn
argument_list|)
expr_stmt|;
name|ldn
operator|++
expr_stmt|;
break|break;
case|case
name|PNP_TAG_COMPAT_DEVICE
case|:
comment|/* 				 * Got a compatible device id 				 * resource. Should keep a list of 				 * compat ids in the device. 				 */
name|bcopy
argument_list|(
name|resinfo
argument_list|,
operator|&
name|compat_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
name|isa_set_compatid
argument_list|(
name|dev
argument_list|,
name|compat_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNP_TAG_IRQ_FORMAT
case|:
if|if
condition|(
name|config
operator|->
name|ic_nirq
operator|==
name|ISA_NIRQ
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d too many irqs"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|ic_irqmask
index|[
name|config
operator|->
name|ic_nirq
index|]
operator|=
name|resinfo
index|[
literal|0
index|]
operator|+
operator|(
name|resinfo
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|config
operator|->
name|ic_nirq
operator|++
expr_stmt|;
break|break;
case|case
name|PNP_TAG_DMA_FORMAT
case|:
if|if
condition|(
name|config
operator|->
name|ic_ndrq
operator|==
name|ISA_NDRQ
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d too many drqs"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|ic_drqmask
index|[
name|config
operator|->
name|ic_ndrq
index|]
operator|=
name|resinfo
index|[
literal|0
index|]
expr_stmt|;
name|config
operator|->
name|ic_ndrq
operator|++
expr_stmt|;
break|break;
case|case
name|PNP_TAG_START_DEPENDANT
case|:
if|if
condition|(
name|config
operator|==
operator|&
name|alt
condition|)
block|{
name|ISA_ADD_CONFIG
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|priority
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|!=
operator|&
name|logdev
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d malformed\n"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 				 * If the priority is not specified, 				 * then use the default of 				 * 'acceptable' 				 */
if|if
condition|(
name|PNP_SRES_LEN
argument_list|(
name|tag
argument_list|)
operator|>
literal|0
condition|)
name|priority
operator|=
name|resinfo
index|[
literal|0
index|]
expr_stmt|;
else|else
name|priority
operator|=
literal|1
expr_stmt|;
name|alt
operator|=
name|logdev
expr_stmt|;
name|config
operator|=
operator|&
name|alt
expr_stmt|;
break|break;
case|case
name|PNP_TAG_END_DEPENDANT
case|:
name|ISA_ADD_CONFIG
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|priority
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
operator|&
name|logdev
expr_stmt|;
break|break;
case|case
name|PNP_TAG_IO_RANGE
case|:
if|if
condition|(
name|config
operator|->
name|ic_nport
operator|==
name|ISA_NPORT
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d too many ports"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_start
operator|=
name|resinfo
index|[
literal|1
index|]
operator|+
operator|(
name|resinfo
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_end
operator|=
name|resinfo
index|[
literal|3
index|]
operator|+
operator|(
name|resinfo
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|resinfo
index|[
literal|6
index|]
operator|-
literal|1
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_size
operator|=
name|resinfo
index|[
literal|6
index|]
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_align
operator|=
name|resinfo
index|[
literal|5
index|]
expr_stmt|;
name|config
operator|->
name|ic_nport
operator|++
expr_stmt|;
break|break;
case|case
name|PNP_TAG_IO_FIXED
case|:
if|if
condition|(
name|config
operator|->
name|ic_nport
operator|==
name|ISA_NPORT
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d too many ports"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_start
operator|=
name|resinfo
index|[
literal|0
index|]
operator|+
operator|(
name|resinfo
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_end
operator|=
name|resinfo
index|[
literal|0
index|]
operator|+
operator|(
name|resinfo
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|resinfo
index|[
literal|2
index|]
operator|-
literal|1
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_size
operator|=
name|resinfo
index|[
literal|2
index|]
expr_stmt|;
name|config
operator|->
name|ic_port
index|[
name|config
operator|->
name|ic_nport
index|]
operator|.
name|ir_align
operator|=
literal|1
expr_stmt|;
name|config
operator|->
name|ic_nport
operator|++
expr_stmt|;
break|break;
case|case
name|PNP_TAG_END
case|:
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Skip this resource */
break|break;
block|}
block|}
else|else
block|{
comment|/* Large resource */
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|resinfo
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|large_len
operator|=
name|resinfo
index|[
literal|0
index|]
operator|+
operator|(
name|resinfo
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|PNP_LRES_NUM
argument_list|(
name|tag
argument_list|)
operator|==
name|PNP_TAG_ID_ANSI
condition|)
block|{
if|if
condition|(
name|desc
condition|)
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|desc
operator|=
name|malloc
argument_list|(
name|large_len
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* 				 * Note: if malloc fails, this will 				 * skip the resource instead of 				 * reading it into desc. 				 */
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|desc
argument_list|,
name|large_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|desc
condition|)
block|{
comment|/* 					 * Trim trailing spaces. 					 */
while|while
condition|(
name|desc
index|[
name|large_len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|large_len
operator|--
expr_stmt|;
name|desc
index|[
name|large_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dev
condition|)
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|PNP_LRES_NUM
argument_list|(
name|tag
argument_list|)
operator|!=
name|PNP_TAG_MEMORY_RANGE
condition|)
block|{
comment|/* skip */
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|NULL
argument_list|,
name|large_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|pnp_get_resource_info
argument_list|(
name|resinfo
argument_list|,
name|large_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scanning
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|config
operator|->
name|ic_nmem
operator|==
name|ISA_NMEM
condition|)
block|{
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"CSN %d too many memory ranges"
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|scanning
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_start
operator|=
operator|(
name|resinfo
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|resinfo
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_end
operator|=
operator|(
name|resinfo
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|resinfo
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_size
operator|=
operator|(
name|resinfo
index|[
literal|10
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|resinfo
index|[
literal|11
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_align
operator|=
name|resinfo
index|[
literal|8
index|]
operator|+
operator|(
name|resinfo
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_align
condition|)
name|config
operator|->
name|ic_mem
index|[
name|config
operator|->
name|ic_nmem
index|]
operator|.
name|ir_align
operator|=
literal|0x10000
expr_stmt|;
name|config
operator|->
name|ic_nmem
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|desc
condition|)
name|free
argument_list|(
name|desc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Run the isolation protocol. Use pnp_rd_port as the READ_DATA port  * value (caller should try multiple READ_DATA locations before giving  * up). Upon exiting, all cards are aware that they should use  * pnp_rd_port as the READ_DATA port.  *  * In the first pass, a csn is assigned to each board and pnp_id's  * are saved to an array, pnp_devices. In the second pass, each  * card is woken up and the device configuration is called.  */
end_comment

begin_function
specifier|static
name|int
name|pnp_isolation_protocol
parameter_list|(
name|device_t
name|parent
parameter_list|)
block|{
name|int
name|csn
decl_stmt|;
name|pnp_id
name|id
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* 	 * Put all cards into the Sleep state so that we can clear 	 * their CSNs. 	 */
name|pnp_send_initiation_key
argument_list|()
expr_stmt|;
comment|/* 	 * Clear the CSN for all cards. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_RESET_CSN
argument_list|)
expr_stmt|;
comment|/* 	 * Move all cards to the Isolation state. 	 */
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell them where the read point is going to be this time. 	 */
name|pnp_write
argument_list|(
name|PNP_SET_RD_DATA
argument_list|,
name|pnp_rd_port
argument_list|)
expr_stmt|;
for|for
control|(
name|csn
operator|=
literal|1
init|;
name|csn
operator|<
name|PNP_MAX_CARDS
condition|;
name|csn
operator|++
control|)
block|{
comment|/* 		 * Start the serial isolation protocol. 		 */
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|PNP_SERIAL_ISOLATION
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Delay 1 msec */
if|if
condition|(
name|pnp_get_serial
argument_list|(
operator|&
name|id
argument_list|)
condition|)
block|{
comment|/* 			 * We have read the id from a card 			 * successfully. The card which won the 			 * isolation protocol will be in Isolation 			 * mode and all others will be in Sleep.  * 			 * Program the CSN of the isolated card 			 * (taking it to Config state) and read its 			 * resources, creating devices as we find 			 * logical devices on the card. 			 */
name|pnp_write
argument_list|(
name|PNP_SET_CSN
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|pnp_scan_resdata
argument_list|(
name|parent
argument_list|,
operator|&
name|id
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
break|break;
comment|/* 		 * Put this card back to the Sleep state and 		 * simultaneously move all cards which don't have a 		 * CSN yet to Isolation state. 		 */
name|pnp_write
argument_list|(
name|PNP_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unless we have chosen the wrong read port, all cards will 	 * be in Sleep state. Put them back into WaitForKey for 	 * now. Their resources will be programmed later. 	 */
name|pnp_write
argument_list|(
name|PNP_CONFIG_CONTROL
argument_list|,
name|PNP_CONFIG_CONTROL_WAIT_FOR_KEY
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * pnp_identify()  *  * autoconfiguration of pnp devices. This routine just runs the  * isolation protocol over several ports, until one is successful.  *  * may be called more than once ?  *  */
end_comment

begin_function
specifier|static
name|void
name|pnp_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|int
name|num_pnp_devs
decl_stmt|;
if|#
directive|if
literal|0
block|if (pnp_ldn_overrides[0].csn == 0) { 		if (bootverbose) 			printf("Initializing PnP override table\n"); 		bzero (pnp_ldn_overrides, sizeof(pnp_ldn_overrides)); 		pnp_ldn_overrides[0].csn = 255 ; 	}
endif|#
directive|endif
comment|/* Try various READ_DATA ports from 0x203-0x3ff */
for|for
control|(
name|pnp_rd_port
operator|=
literal|0x80
init|;
operator|(
name|pnp_rd_port
operator|<
literal|0xff
operator|)
condition|;
name|pnp_rd_port
operator|+=
literal|0x10
control|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Trying Read_Port at %x\n"
argument_list|,
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|num_pnp_devs
operator|=
name|pnp_isolation_protocol
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_pnp_devs
condition|)
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pnp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|pnp_identify
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pnp_driver
init|=
block|{
literal|"pnp"
block|,
name|pnp_methods
block|,
literal|1
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pnp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pnp
argument_list|,
name|isa
argument_list|,
name|pnp_driver
argument_list|,
name|pnp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

