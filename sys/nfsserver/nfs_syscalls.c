begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_syscalls.c	8.5 (Berkeley) 3/30/95  * $Id: nfs_syscalls.c,v 1.43 1998/09/01 02:31:52 luoqi Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsrvcache.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nqnfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsrtt.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NFSSVC
argument_list|,
literal|"NFS srvsock"
argument_list|,
literal|"Nfs server structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global defs. */
end_comment

begin_extern
extern|extern int32_t (*nfsrv3_procs[NFS_NPROCS]
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|nfsrv_descript
operator|*
name|nd
operator|,
expr|struct
name|nfssvc_sock
operator|*
name|slp
operator|,
expr|struct
name|proc
operator|*
name|procp
operator|,
expr|struct
name|mbuf
operator|*
operator|*
name|mreqp
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_numasync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|nqnfsstarttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nqsrv_writeslack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrtton
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|nfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrvw_procrastinate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrvw_procrastinate_v3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfssvc_sock
modifier|*
name|nfs_udpsock
decl_stmt|,
modifier|*
name|nfs_cltpsock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nuidhash_max
init|=
name|NFS_MAXUIDHASH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nfsrv_zapsock
name|__P
argument_list|(
operator|(
expr|struct
name|nfssvc_sock
operator|*
name|slp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfssvc_iod
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_asyncdaemon
index|[
name|NFS_MAXASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_decl_stmt
name|int
name|nfsd_waiting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsdrt
name|nfsdrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_numnfsd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|notstarted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modify_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nfsd_rt
name|__P
argument_list|(
operator|(
name|int
name|sotype
operator|,
expr|struct
name|nfsrv_descript
operator|*
name|nd
operator|,
name|int
name|cacherep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfssvc_addsock
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfssvc_nfsd
name|__P
argument_list|(
operator|(
expr|struct
name|nfsd_srvargs
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_privport
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|NFS_NFSPRIVPORT
argument_list|,
name|nfs_privport
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_privport
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|gatherdelay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrvw_procrastinate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|gatherdelay_v3
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrvw_procrastinate_v3
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * NFS server system calls  * getfh() lives here too, but maybe should move to kern/vfs_syscalls.c  */
end_comment

begin_comment
comment|/*  * Get file handle system call  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getfh_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getfh
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|getfh_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|fhandle_t
name|fh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
comment|/* 	 * Must be super user 	 */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
name|fh
operator|.
name|fh_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|error
operator|=
name|VFS_VPTOFH
argument_list|(
name|vp
argument_list|,
operator|&
name|fh
operator|.
name|fh_fid
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Nfs server psuedo system call for the nfsd's  * Based on the flag value it either:  * - adds a socket to the selection list  * - remains in the kernel as an nfsd  * - remains in the kernel as an nfsiod  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|nfssvc_args
block|{
name|int
name|flag
decl_stmt|;
name|caddr_t
name|argp
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nfssvc
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|nfssvc_args
modifier|*
name|uap
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NFS_NOSERVER
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|nfsd_args
name|nfsdarg
decl_stmt|;
name|struct
name|nfsd_srvargs
name|nfsd_srvargs
decl_stmt|,
modifier|*
name|nsd
init|=
operator|&
name|nfsd_srvargs
decl_stmt|;
name|struct
name|nfsd_cargs
name|ncd
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nfsd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
endif|#
directive|endif
comment|/* NFS_NOSERVER */
name|int
name|error
decl_stmt|;
comment|/* 	 * Must be super user 	 */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
name|nfssvc_sockhead_flag
operator|&
name|SLP_INIT
condition|)
block|{
name|nfssvc_sockhead_flag
operator||=
name|SLP_WANTINIT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfssvc_sockhead
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsd init"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_BIOD
condition|)
name|error
operator|=
name|nfssvc_iod
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NFS_NOSERVER
else|else
name|error
operator|=
name|ENXIO
expr_stmt|;
else|#
directive|else
comment|/* !NFS_NOSERVER */
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_MNTD
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ncd
argument_list|,
sizeof|sizeof
argument_list|(
name|ncd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|ncd
operator|.
name|ncd_dirp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_MNTD
operator|)
operator|&&
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_GOTAUTH
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_MNTD
expr_stmt|;
name|error
operator|=
name|nqnfs_clientd
argument_list|(
name|nmp
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|ncd
argument_list|,
name|uap
operator|->
name|flag
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_ADDSOCK
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfsdarg
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsdarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|getsock
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|nfsdarg
operator|.
name|sock
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Get the client address for connected sockets. 		 */
if|if
condition|(
name|nfsdarg
operator|.
name|name
operator|==
name|NULL
operator|||
name|nfsdarg
operator|.
name|namelen
operator|==
literal|0
condition|)
name|nam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
else|else
block|{
name|error
operator|=
name|getsockaddr
argument_list|(
operator|&
name|nam
argument_list|,
name|nfsdarg
operator|.
name|name
argument_list|,
name|nfsdarg
operator|.
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|nfssvc_addsock
argument_list|(
name|fp
argument_list|,
name|nam
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
name|nsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_AUTHIN
operator|)
operator|&&
operator|(
operator|(
name|nfsd
operator|=
name|nsd
operator|->
name|nsd_nfsd
operator|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|nfsd
operator|->
name|nfsd_slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
condition|)
block|{
name|slp
operator|=
name|nfsd
operator|->
name|nfsd_slp
expr_stmt|;
comment|/* 			 * First check to see if another nfsd has already 			 * added this credential. 			 */
for|for
control|(
name|nuidp
operator|=
name|NUIDHASH
argument_list|(
name|slp
argument_list|,
name|nsd
operator|->
name|nsd_cr
operator|.
name|cr_uid
argument_list|)
operator|->
name|lh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_hash
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
operator|==
name|nsd
operator|->
name|nsd_cr
operator|.
name|cr_uid
operator|&&
operator|(
operator|!
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_nam2
operator|||
name|netaddr_match
argument_list|(
name|NU_NETFAM
argument_list|(
name|nuidp
argument_list|)
argument_list|,
operator|&
name|nuidp
operator|->
name|nu_haddr
argument_list|,
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_nam2
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|nuidp
condition|)
block|{
name|nfsrv_setcred
argument_list|(
operator|&
name|nuidp
operator|->
name|nu_cr
argument_list|,
operator|&
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_cr
argument_list|)
expr_stmt|;
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_flag
operator||=
name|ND_KERBFULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * Nope, so we will. 			     */
if|if
condition|(
name|slp
operator|->
name|ns_numuids
operator|<
name|nuidhash_max
condition|)
block|{
name|slp
operator|->
name|ns_numuids
operator|++
expr_stmt|;
name|nuidp
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsuid
argument_list|)
argument_list|,
name|M_NFSUID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
name|nuidp
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nuidp
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nuidp
argument_list|,
name|M_NFSUID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nuidp
operator|==
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
literal|0
condition|)
block|{
name|nuidp
operator|=
name|slp
operator|->
name|ns_uidlruhead
operator|.
name|tqh_first
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|slp
operator|->
name|ns_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_flag
operator|&
name|NU_NAM
condition|)
name|FREE
argument_list|(
name|nuidp
operator|->
name|nu_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
block|}
name|nuidp
operator|->
name|nu_flag
operator|=
literal|0
expr_stmt|;
name|nuidp
operator|->
name|nu_cr
operator|=
name|nsd
operator|->
name|nsd_cr
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ngroups
operator|>
name|NGROUPS
condition|)
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ngroups
operator|=
name|NGROUPS
expr_stmt|;
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|nuidp
operator|->
name|nu_timestamp
operator|=
name|nsd
operator|->
name|nsd_timestamp
expr_stmt|;
name|nuidp
operator|->
name|nu_expire
operator|=
name|time_second
operator|+
name|nsd
operator|->
name|nsd_ttl
expr_stmt|;
comment|/* 				 * and save the session key in nu_key. 				 */
name|bcopy
argument_list|(
name|nsd
operator|->
name|nsd_key
argument_list|,
name|nuidp
operator|->
name|nu_key
argument_list|,
sizeof|sizeof
argument_list|(
name|nsd
operator|->
name|nsd_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_nam2
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|saddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_nam2
expr_stmt|;
switch|switch
condition|(
name|saddr
operator|->
name|sin_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|nuidp
operator|->
name|nu_flag
operator||=
name|NU_INETADDR
expr_stmt|;
name|nuidp
operator|->
name|nu_inetaddr
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
break|break;
case|case
name|AF_ISO
case|:
default|default:
name|nuidp
operator|->
name|nu_flag
operator||=
name|NU_NAM
expr_stmt|;
name|nuidp
operator|->
name|nu_nam
operator|=
name|dup_sockaddr
argument_list|(
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_nam2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|slp
operator|->
name|ns_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NUIDHASH
argument_list|(
name|slp
argument_list|,
name|nsd
operator|->
name|nsd_uid
argument_list|)
argument_list|,
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
name|nfsrv_setcred
argument_list|(
operator|&
name|nuidp
operator|->
name|nu_cr
argument_list|,
operator|&
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_cr
argument_list|)
expr_stmt|;
name|nfsd
operator|->
name|nfsd_nd
operator|->
name|nd_flag
operator||=
name|ND_KERBFULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_AUTHINFAIL
operator|)
operator|&&
operator|(
name|nfsd
operator|=
name|nsd
operator|->
name|nsd_nfsd
operator|)
condition|)
name|nfsd
operator|->
name|nfsd_flag
operator||=
name|NFSD_AUTHFAIL
expr_stmt|;
name|error
operator|=
name|nfssvc_nfsd
argument_list|(
name|nsd
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NFS_NOSERVER */
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Adds a socket to the list for servicing by nfsds.  */
end_comment

begin_function
specifier|static
name|int
name|nfssvc_addsock
parameter_list|(
name|fp
parameter_list|,
name|mynam
parameter_list|,
name|p
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|mynam
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|siz
decl_stmt|;
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|tslp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|tslp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Add it to the list, as required. 	 */
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|tslp
operator|=
name|nfs_udpsock
expr_stmt|;
if|if
condition|(
name|tslp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
name|FREE
argument_list|(
name|mynam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ISO
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|ISOPROTO_CLTP
condition|)
block|{
name|tslp
operator|=
name|nfs_cltpsock
expr_stmt|;
if|if
condition|(
name|tslp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
name|FREE
argument_list|(
name|mynam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISO */
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|siz
operator|=
name|NFS_MAXPACKET
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
else|else
name|siz
operator|=
name|NFS_MAXPACKET
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|siz
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|mynam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set protocol specific options { for now TCP only } and 	 * reserve some space. For datagram sockets, this can get called 	 * repeatedly for the same socket, but that isn't harmful. 	 */
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_KEEPALIVE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|AF_INET
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tslp
condition|)
name|slp
operator|=
name|tslp
expr_stmt|;
else|else
block|{
name|slp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|slp
operator|->
name|ns_uidlruhead
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|,
name|slp
argument_list|,
name|ns_chain
argument_list|)
expr_stmt|;
block|}
name|slp
operator|->
name|ns_so
operator|=
name|so
expr_stmt|;
name|slp
operator|->
name|ns_nam
operator|=
name|mynam
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|slp
operator|->
name|ns_fp
operator|=
name|fp
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_upcallarg
operator|=
operator|(
name|caddr_t
operator|)
name|slp
expr_stmt|;
name|so
operator|->
name|so_upcall
operator|=
name|nfsrv_rcv
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_UPCALL
expr_stmt|;
name|slp
operator|->
name|ns_flag
operator|=
operator|(
name|SLP_VALID
operator||
name|SLP_NEEDQ
operator|)
expr_stmt|;
name|nfsrv_wakenfsd
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by nfssvc() for nfsds. Just loops around servicing rpc requests  * until it is killed by a signal.  */
end_comment

begin_function
specifier|static
name|int
name|nfssvc_nfsd
parameter_list|(
name|nsd
parameter_list|,
name|argp
parameter_list|,
name|p
parameter_list|)
name|struct
name|nfsd_srvargs
modifier|*
name|nsd
decl_stmt|;
name|caddr_t
name|argp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|;
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|int
modifier|*
name|solockp
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nfsd
init|=
name|nsd
operator|->
name|nsd_nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|cacherep
decl_stmt|,
name|s
decl_stmt|,
name|sotype
decl_stmt|,
name|writes_todo
decl_stmt|;
name|int
name|procrastinate
decl_stmt|;
name|u_quad_t
name|cur_usec
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
name|writes_todo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nfsd
operator|==
operator|(
expr|struct
name|nfsd
operator|*
operator|)
literal|0
condition|)
block|{
name|nsd
operator|->
name|nsd_nfsd
operator|=
name|nfsd
operator|=
operator|(
expr|struct
name|nfsd
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd
argument_list|)
argument_list|,
name|M_NFSD
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfsd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|nfsd
operator|->
name|nfsd_procp
operator|=
name|p
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfsd_head
argument_list|,
name|nfsd
argument_list|,
name|nfsd_chain
argument_list|)
expr_stmt|;
name|nfs_numnfsd
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Loop getting rpc requests until SIGKILL. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|nfsd
operator|->
name|nfsd_flag
operator|&
name|NFSD_REQINPROG
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|nfsd
operator|->
name|nfsd_slp
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
operator|&&
operator|(
name|nfsd_head_flag
operator|&
name|NFSD_CHECKSLP
operator|)
operator|==
literal|0
condition|)
block|{
name|nfsd
operator|->
name|nfsd_flag
operator||=
name|NFSD_WAITING
expr_stmt|;
name|nfsd_waiting
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfsd
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"nfsd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfsd_waiting
operator|--
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nfsd
operator|->
name|nfsd_slp
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
operator|&&
operator|(
name|nfsd_head_flag
operator|&
name|NFSD_CHECKSLP
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|slp
operator|=
name|nfssvc_sockhead
operator|.
name|tqh_first
init|;
name|slp
operator|!=
literal|0
condition|;
name|slp
operator|=
name|slp
operator|->
name|ns_chain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
operator|(
name|SLP_VALID
operator||
name|SLP_DOREC
operator|)
operator|)
operator|==
operator|(
name|SLP_VALID
operator||
name|SLP_DOREC
operator|)
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_DOREC
expr_stmt|;
name|slp
operator|->
name|ns_sref
operator|++
expr_stmt|;
name|nfsd
operator|->
name|nfsd_slp
operator|=
name|slp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|slp
operator|==
literal|0
condition|)
name|nfsd_head_flag
operator|&=
operator|~
name|NFSD_CHECKSLP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|slp
operator|=
name|nfsd
operator|->
name|nfsd_slp
operator|)
operator|==
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
condition|)
continue|continue;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_DISCONN
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_NEEDQ
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_NEEDQ
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_sndlock
argument_list|(
operator|&
name|slp
operator|->
name|ns_solock
argument_list|,
operator|&
name|slp
operator|->
name|ns_solock
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nfsrv_rcv
argument_list|(
name|slp
operator|->
name|ns_so
argument_list|,
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|nfs_sndunlock
argument_list|(
operator|&
name|slp
operator|->
name|ns_solock
argument_list|,
operator|&
name|slp
operator|->
name|ns_solock
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsrv_dorec
argument_list|(
name|slp
argument_list|,
name|nfsd
argument_list|,
operator|&
name|nd
argument_list|)
expr_stmt|;
name|cur_usec
operator|=
name|nfs_curusec
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|&&
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|->
name|nd_time
operator|<=
name|cur_usec
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
name|writes_todo
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|writes_todo
operator|=
literal|0
expr_stmt|;
name|nfsd
operator|->
name|nfsd_flag
operator||=
name|NFSD_REQINPROG
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|slp
operator|=
name|nfsd
operator|->
name|nfsd_slp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nd
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
name|nd
operator|=
name|NULL
expr_stmt|;
block|}
name|nfsd
operator|->
name|nfsd_slp
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
literal|0
expr_stmt|;
name|nfsd
operator|->
name|nfsd_flag
operator|&=
operator|~
name|NFSD_REQINPROG
expr_stmt|;
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|so
operator|=
name|slp
operator|->
name|ns_so
expr_stmt|;
name|sotype
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|solockp
operator|=
operator|&
name|slp
operator|->
name|ns_solock
expr_stmt|;
else|else
name|solockp
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|nd
condition|)
block|{
name|getmicrotime
argument_list|(
operator|&
name|nd
operator|->
name|nd_starttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
condition|)
name|nd
operator|->
name|nd_nam
operator|=
name|nd
operator|->
name|nd_nam2
expr_stmt|;
else|else
name|nd
operator|->
name|nd_nam
operator|=
name|slp
operator|->
name|ns_nam
expr_stmt|;
comment|/* 		     * Check to see if authorization is needed. 		     */
if|if
condition|(
name|nfsd
operator|->
name|nfsd_flag
operator|&
name|NFSD_NEEDAUTH
condition|)
block|{
name|nfsd
operator|->
name|nfsd_flag
operator|&=
operator|~
name|NFSD_NEEDAUTH
expr_stmt|;
name|nsd
operator|->
name|nsd_haddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nd
operator|->
name|nd_nam
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|nsd
operator|->
name|nsd_authlen
operator|=
name|nfsd
operator|->
name|nfsd_authlen
expr_stmt|;
name|nsd
operator|->
name|nsd_verflen
operator|=
name|nfsd
operator|->
name|nfsd_verflen
expr_stmt|;
if|if
condition|(
operator|!
name|copyout
argument_list|(
name|nfsd
operator|->
name|nfsd_authstr
argument_list|,
name|nsd
operator|->
name|nsd_authstr
argument_list|,
name|nfsd
operator|->
name|nfsd_authlen
argument_list|)
operator|&&
operator|!
name|copyout
argument_list|(
name|nfsd
operator|->
name|nfsd_verfstr
argument_list|,
name|nsd
operator|->
name|nsd_verfstr
argument_list|,
name|nfsd
operator|->
name|nfsd_verflen
argument_list|)
operator|&&
operator|!
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|nsd
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nsd
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENEEDAUTH
operator|)
return|;
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
block|}
else|else
name|cacherep
operator|=
name|nfsrv_getcache
argument_list|(
name|nd
argument_list|,
name|slp
argument_list|,
operator|&
name|mreq
argument_list|)
expr_stmt|;
comment|/* 		     * Check for just starting up for NQNFS and send 		     * fake "try again later" replies to the NQNFS clients. 		     */
if|if
condition|(
name|notstarted
operator|&&
name|nqnfsstarttime
operator|<=
name|time_second
condition|)
block|{
if|if
condition|(
name|modify_flag
condition|)
block|{
name|nqnfsstarttime
operator|=
name|time_second
operator|+
name|nqsrv_writeslack
expr_stmt|;
name|modify_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|notstarted
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|notstarted
condition|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NQNFS
operator|)
operator|==
literal|0
condition|)
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_WRITE
condition|)
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|NQNFS_TRYLATER
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
block|}
else|else
name|modify_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsd
operator|->
name|nfsd_flag
operator|&
name|NFSD_AUTHFAIL
condition|)
block|{
name|nfsd
operator|->
name|nfsd_flag
operator|&=
operator|~
name|NFSD_AUTHFAIL
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_TOOWEAK
operator|)
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfs_privport
condition|)
block|{
comment|/* Check if source port is privileged */
name|u_short
name|port
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
init|=
name|nd
operator|->
name|nd_nam
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>=
name|IPPORT_RESERVED
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_TOOWEAK
operator|)
expr_stmt|;
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
name|printf
argument_list|(
literal|"NFS request from unprivileged port (%s:%d)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Loop to get all the write rpc relies that have been 		 * gathered together. 		 */
do|do
block|{
switch|switch
condition|(
name|cacherep
condition|)
block|{
case|case
name|RC_DOIT
case|:
if|if
condition|(
name|nd
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
condition|)
name|procrastinate
operator|=
name|nfsrvw_procrastinate_v3
expr_stmt|;
else|else
name|procrastinate
operator|=
name|nfsrvw_procrastinate
expr_stmt|;
if|if
condition|(
name|writes_todo
operator|||
operator|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_WRITE
operator|&&
name|procrastinate
operator|>
literal|0
operator|&&
operator|!
name|notstarted
operator|)
condition|)
name|error
operator|=
name|nfsrv_writegather
argument_list|(
operator|&
name|nd
argument_list|,
name|slp
argument_list|,
name|nfsd
operator|->
name|nfsd_procp
argument_list|,
operator|&
name|mreq
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
operator|(
operator|*
operator|(
name|nfsrv3_procs
index|[
name|nd
operator|->
name|nd_procnum
index|]
operator|)
operator|)
operator|(
name|nd
operator|,
name|slp
operator|,
name|nfsd
operator|->
name|nfsd_procp
operator|,
operator|&
name|mreq
operator|)
expr_stmt|;
if|if
condition|(
name|mreq
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NQNFSPROC_VACATED
condition|)
name|nfsstats
operator|.
name|srv_errs
operator|++
expr_stmt|;
name|nfsrv_updatecache
argument_list|(
name|nd
argument_list|,
name|FALSE
argument_list|,
name|mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
condition|)
name|FREE
argument_list|(
name|nd
operator|->
name|nd_nam2
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfsstats
operator|.
name|srvrpccnt
index|[
name|nd
operator|->
name|nd_procnum
index|]
operator|++
expr_stmt|;
name|nfsrv_updatecache
argument_list|(
name|nd
argument_list|,
name|TRUE
argument_list|,
name|mreq
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
case|case
name|RC_REPLY
case|:
name|m
operator|=
name|mreq
expr_stmt|;
name|siz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|siz
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|siz
operator|<=
literal|0
operator|||
name|siz
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf siz=%d\n"
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Bad nfs svc reply"
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|mreq
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|siz
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 			 * For stream protocols, prepend a Sun RPC 			 * Record Mark. 			 */
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
name|siz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|solockp
condition|)
operator|(
name|void
operator|)
name|nfs_sndlock
argument_list|(
name|solockp
argument_list|,
name|solockp
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nd
operator|->
name|nd_nam2
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfsrtton
condition|)
name|nfsd_rt
argument_list|(
name|sotype
argument_list|,
name|nd
argument_list|,
name|cacherep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
condition|)
name|FREE
argument_list|(
name|nd
operator|->
name|nd_nam2
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_mrep
condition|)
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
if|if
condition|(
name|solockp
condition|)
name|nfs_sndunlock
argument_list|(
name|solockp
argument_list|,
name|solockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|RC_DROPIT
case|:
if|if
condition|(
name|nfsrtton
condition|)
name|nfsd_rt
argument_list|(
name|sotype
argument_list|,
name|nd
argument_list|,
name|cacherep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
condition|)
name|FREE
argument_list|(
name|nd
operator|->
name|nd_nam2
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|nd
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
name|nd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		     * Check to see if there are outstanding writes that 		     * need to be serviced. 		     */
name|cur_usec
operator|=
name|nfs_curusec
argument_list|()
expr_stmt|;
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|&&
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|->
name|nd_time
operator|<=
name|cur_usec
condition|)
block|{
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
name|writes_todo
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|writes_todo
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|writes_todo
condition|)
do|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_dorec
argument_list|(
name|slp
argument_list|,
name|nfsd
argument_list|,
operator|&
name|nd
argument_list|)
condition|)
block|{
name|nfsd
operator|->
name|nfsd_flag
operator|&=
operator|~
name|NFSD_REQINPROG
expr_stmt|;
name|nfsd
operator|->
name|nfsd_slp
operator|=
name|NULL
expr_stmt|;
name|nfsrv_slpderef
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfsd_head
argument_list|,
name|nfsd
argument_list|,
name|nfsd_chain
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfsd
argument_list|,
name|M_NFSD
argument_list|)
expr_stmt|;
name|nsd
operator|->
name|nsd_nfsd
operator|=
operator|(
expr|struct
name|nfsd
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|nfs_numnfsd
operator|==
literal|0
condition|)
name|nfsrv_init
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Reinitialize everything */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shut down a socket associated with an nfssvc_sock structure.  * Should be called with the send lock set, if required.  * The trick here is to increment the sref at the start, so that the nfsds  * will stop using it and clear ns_flag at the end so that it will not be  * reassigned during cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_zapsock
parameter_list|(
name|slp
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|,
modifier|*
name|nnuidp
decl_stmt|;
specifier|register
name|struct
name|nfsrv_descript
modifier|*
name|nwp
decl_stmt|,
modifier|*
name|nnwp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|nfsrv_rec
modifier|*
name|rec
decl_stmt|;
name|int
name|s
decl_stmt|;
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_ALLFLAGS
expr_stmt|;
name|fp
operator|=
name|slp
operator|->
name|ns_fp
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|slp
operator|->
name|ns_fp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
literal|0
expr_stmt|;
name|so
operator|=
name|slp
operator|->
name|ns_so
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_UPCALL
expr_stmt|;
name|so
operator|->
name|so_upcall
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_upcallarg
operator|=
name|NULL
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_nam
condition|)
name|FREE
argument_list|(
name|slp
operator|->
name|ns_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|slp
operator|->
name|ns_raw
argument_list|)
expr_stmt|;
while|while
condition|(
name|rec
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|,
name|nr_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|nr_address
condition|)
name|FREE
argument_list|(
name|rec
operator|->
name|nr_address
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rec
operator|->
name|nr_packet
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rec
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|nuidp
operator|=
name|slp
operator|->
name|ns_uidlruhead
operator|.
name|tqh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nnuidp
control|)
block|{
name|nnuidp
operator|=
name|nuidp
operator|->
name|nu_lru
operator|.
name|tqe_next
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|slp
operator|->
name|ns_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_flag
operator|&
name|NU_NAM
condition|)
name|FREE
argument_list|(
name|nuidp
operator|->
name|nu_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nuidp
argument_list|,
name|M_NFSUID
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
for|for
control|(
name|nwp
operator|=
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
init|;
name|nwp
condition|;
name|nwp
operator|=
name|nnwp
control|)
block|{
name|nnwp
operator|=
name|nwp
operator|->
name|nd_tq
operator|.
name|le_next
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nwp
argument_list|,
name|nd_tq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nwp
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|slp
operator|->
name|ns_tq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Derefence a server socket structure. If it has no more references and  * is no longer valid, you can throw it away.  */
end_comment

begin_function
name|void
name|nfsrv_slpderef
parameter_list|(
name|slp
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
block|{
if|if
condition|(
operator|--
operator|(
name|slp
operator|->
name|ns_sref
operator|)
operator|==
literal|0
operator|&&
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|,
name|slp
argument_list|,
name|ns_chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
name|M_NFSSVC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the data structures for the server.  * Handshake with any new nfsds starting up to avoid any chance of  * corruption.  */
end_comment

begin_function
name|void
name|nfsrv_init
parameter_list|(
name|terminating
parameter_list|)
name|int
name|terminating
decl_stmt|;
block|{
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|,
modifier|*
name|nslp
decl_stmt|;
if|if
condition|(
name|nfssvc_sockhead_flag
operator|&
name|SLP_INIT
condition|)
name|panic
argument_list|(
literal|"nfsd init"
argument_list|)
expr_stmt|;
name|nfssvc_sockhead_flag
operator||=
name|SLP_INIT
expr_stmt|;
if|if
condition|(
name|terminating
condition|)
block|{
for|for
control|(
name|slp
operator|=
name|nfssvc_sockhead
operator|.
name|tqh_first
init|;
name|slp
operator|!=
literal|0
condition|;
name|slp
operator|=
name|nslp
control|)
block|{
name|nslp
operator|=
name|slp
operator|->
name|ns_chain
operator|.
name|tqe_next
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
name|nfsrv_zapsock
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|,
name|slp
argument_list|,
name|ns_chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|slp
argument_list|,
name|M_NFSSVC
argument_list|)
expr_stmt|;
block|}
name|nfsrv_cleancache
argument_list|()
expr_stmt|;
comment|/* And clear out server cache */
block|}
else|else
name|nfs_pub
operator|.
name|np_valid
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|)
expr_stmt|;
name|nfssvc_sockhead_flag
operator|&=
operator|~
name|SLP_INIT
expr_stmt|;
if|if
condition|(
name|nfssvc_sockhead_flag
operator|&
name|SLP_WANTINIT
condition|)
block|{
name|nfssvc_sockhead_flag
operator|&=
operator|~
name|SLP_WANTINIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfssvc_sockhead
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsd_head
argument_list|)
expr_stmt|;
name|nfsd_head_flag
operator|&=
operator|~
name|NFSD_CHECKSLP
expr_stmt|;
name|nfs_udpsock
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfs_udpsock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|nfs_udpsock
operator|->
name|ns_rec
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfs_udpsock
operator|->
name|ns_uidlruhead
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|,
name|nfs_udpsock
argument_list|,
name|ns_chain
argument_list|)
expr_stmt|;
name|nfs_cltpsock
operator|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|,
name|M_NFSSVC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfs_cltpsock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfssvc_sock
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|nfs_cltpsock
operator|->
name|ns_rec
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfs_cltpsock
operator|->
name|ns_uidlruhead
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfssvc_sockhead
argument_list|,
name|nfs_cltpsock
argument_list|,
name|ns_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add entries to the server monitor log.  */
end_comment

begin_function
specifier|static
name|void
name|nfsd_rt
parameter_list|(
name|sotype
parameter_list|,
name|nd
parameter_list|,
name|cacherep
parameter_list|)
name|int
name|sotype
decl_stmt|;
specifier|register
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|int
name|cacherep
decl_stmt|;
block|{
specifier|register
name|struct
name|drt
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
operator|&
name|nfsdrt
operator|.
name|drt
index|[
name|nfsdrt
operator|.
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|cacherep
operator|==
name|RC_DOIT
condition|)
name|rt
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cacherep
operator|==
name|RC_REPLY
condition|)
name|rt
operator|->
name|flag
operator|=
name|DRT_CACHEREPLY
expr_stmt|;
else|else
name|rt
operator|->
name|flag
operator|=
name|DRT_CACHEDROP
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
name|rt
operator|->
name|flag
operator||=
name|DRT_TCP
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NQNFS
condition|)
name|rt
operator|->
name|flag
operator||=
name|DRT_NQNFS
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|rt
operator|->
name|flag
operator||=
name|DRT_NFSV3
expr_stmt|;
name|rt
operator|->
name|proc
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|rt
operator|->
name|ipadr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nd
operator|->
name|nd_nam
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|rt
operator|->
name|ipadr
operator|=
name|INADDR_ANY
expr_stmt|;
name|rt
operator|->
name|resptime
operator|=
name|nfs_curusec
argument_list|()
operator|-
operator|(
name|nd
operator|->
name|nd_starttime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|nd
operator|->
name|nd_starttime
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|rt
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|nfsdrt
operator|.
name|pos
operator|=
operator|(
name|nfsdrt
operator|.
name|pos
operator|+
literal|1
operator|)
operator|%
name|NFSRTTLOGSIZ
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfs_defect
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|defect
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_defect
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Asynchronous I/O daemons for client nfs.  * They do read-ahead and write-behind operations on the block I/O cache.  * Never returns unless it fails or gets killed.  */
end_comment

begin_function
specifier|static
name|int
name|nfssvc_iod
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|myiod
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Assign my position or return error if too many already running 	 */
name|myiod
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_MAXASYNCDAEMON
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nfs_asyncdaemon
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|nfs_asyncdaemon
index|[
name|i
index|]
operator|++
expr_stmt|;
name|myiod
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|myiod
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|nfs_numasync
operator|++
expr_stmt|;
comment|/* 	 * Just loop around doin our stuff until SIGKILL 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|(
name|nmp
operator|=
name|nfs_iodmount
index|[
name|myiod
index|]
operator|)
operator|==
name|NULL
operator|||
name|nmp
operator|->
name|nm_bufq
operator|.
name|tqh_first
operator|==
name|NULL
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nmp
condition|)
name|nmp
operator|->
name|nm_bufqiods
operator|--
expr_stmt|;
name|nfs_iodwant
index|[
name|myiod
index|]
operator|=
name|p
expr_stmt|;
name|nfs_iodmount
index|[
name|myiod
index|]
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_iodwant
index|[
name|myiod
index|]
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"nfsidl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|nfs_asyncdaemon
index|[
name|myiod
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmp
condition|)
name|nmp
operator|->
name|nm_bufqiods
operator|--
expr_stmt|;
name|nfs_iodwant
index|[
name|myiod
index|]
operator|=
name|NULL
expr_stmt|;
name|nfs_iodmount
index|[
name|myiod
index|]
operator|=
name|NULL
expr_stmt|;
name|nfs_numasync
operator|--
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|bp
operator|=
name|nmp
operator|->
name|nm_bufq
operator|.
name|tqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Take one off the front of the list */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_bufq
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_bufqlen
operator|--
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_bufqwant
operator|&&
name|nmp
operator|->
name|nm_bufqlen
operator|<
literal|2
operator|*
name|nfs_numasync
condition|)
block|{
name|nmp
operator|->
name|nm_bufqwant
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nmp
operator|->
name|nm_bufq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
operator|(
name|void
operator|)
name|nfs_doio
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_rcred
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|nfs_doio
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If there are more than one iod on this mount, then defect 		 * so that the iods can be shared out fairly between the mounts 		 */
if|if
condition|(
name|nfs_defect
operator|&&
name|nmp
operator|->
name|nm_bufqiods
operator|>
literal|1
condition|)
block|{
name|NFS_DPF
argument_list|(
name|ASYNCIO
argument_list|,
operator|(
literal|"nfssvc_iod: iod %d defecting from mount %p\n"
operator|,
name|myiod
operator|,
name|nmp
operator|)
argument_list|)
expr_stmt|;
name|nfs_iodmount
index|[
name|myiod
index|]
operator|=
name|NULL
expr_stmt|;
name|nmp
operator|->
name|nm_bufqiods
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get an authorization string for the uid by having the mount_nfs sitting  * on this mount point porpous out of the kernel and do it.  */
end_comment

begin_function
name|int
name|nfs_getauth
parameter_list|(
name|nmp
parameter_list|,
name|rep
parameter_list|,
name|cred
parameter_list|,
name|auth_str
parameter_list|,
name|auth_len
parameter_list|,
name|verf_str
parameter_list|,
name|verf_len
parameter_list|,
name|key
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|char
modifier|*
modifier|*
name|auth_str
decl_stmt|;
name|int
modifier|*
name|auth_len
decl_stmt|;
name|char
modifier|*
name|verf_str
decl_stmt|;
name|int
modifier|*
name|verf_len
decl_stmt|;
name|NFSKERBKEY_T
name|key
decl_stmt|;
comment|/* return session key */
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_WAITAUTH
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_WANTAUTH
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authtype
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsauth1"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_WANTAUTH
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
operator|(
name|NFSSTA_WAITAUTH
operator||
name|NFSSTA_WANTAUTH
operator|)
expr_stmt|;
name|nmp
operator|->
name|nm_authstr
operator|=
operator|*
name|auth_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|RPCAUTH_MAXSIZ
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_authlen
operator|=
name|RPCAUTH_MAXSIZ
expr_stmt|;
name|nmp
operator|->
name|nm_verfstr
operator|=
name|verf_str
expr_stmt|;
name|nmp
operator|->
name|nm_verflen
operator|=
operator|*
name|verf_len
expr_stmt|;
name|nmp
operator|->
name|nm_authuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authstr
argument_list|)
expr_stmt|;
comment|/* 	 * And wait for mount_nfs to do its stuff. 	 */
while|while
condition|(
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_HASAUTH
operator|)
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authlen
argument_list|,
name|PSOCK
argument_list|,
literal|"nfsauth2"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_AUTHERR
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_AUTHERR
expr_stmt|;
name|error
operator|=
name|EAUTH
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
operator|*
name|auth_str
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|auth_len
operator|=
name|nmp
operator|->
name|nm_authlen
expr_stmt|;
operator|*
name|verf_len
operator|=
name|nmp
operator|->
name|nm_verflen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_key
argument_list|,
operator|(
name|caddr_t
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_HASAUTH
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_WAITAUTH
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_WANTAUTH
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_WANTAUTH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authtype
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a nickname authenticator and verifier.  */
end_comment

begin_function
name|int
name|nfs_getnickauth
parameter_list|(
name|nmp
parameter_list|,
name|cred
parameter_list|,
name|auth_str
parameter_list|,
name|auth_len
parameter_list|,
name|verf_str
parameter_list|,
name|verf_len
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|char
modifier|*
modifier|*
name|auth_str
decl_stmt|;
name|int
modifier|*
name|auth_len
decl_stmt|;
name|char
modifier|*
name|verf_str
decl_stmt|;
name|int
name|verf_len
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|nickp
decl_stmt|,
modifier|*
name|verfp
decl_stmt|;
name|struct
name|timeval
name|ktvin
decl_stmt|,
name|ktvout
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|verf_len
operator|<
operator|(
literal|4
operator|*
name|NFSX_UNSIGNED
operator|)
condition|)
name|panic
argument_list|(
literal|"nfs_getnickauth verf too small"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|nuidp
operator|=
name|NMUIDHASH
argument_list|(
name|nmp
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|)
operator|->
name|lh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_hash
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
operator|==
name|cred
operator|->
name|cr_uid
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|nuidp
operator|||
name|nuidp
operator|->
name|nu_expire
operator|<
name|time_second
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* 	 * Move to the end of the lru list (end of lru == most recently used). 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nmp
operator|->
name|nm_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
name|nickp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|nickp
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|RPCAKN_NICKNAME
argument_list|)
expr_stmt|;
operator|*
name|nickp
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_nickname
argument_list|)
expr_stmt|;
operator|*
name|auth_str
operator|=
operator|(
name|char
operator|*
operator|)
name|nickp
expr_stmt|;
operator|*
name|auth_len
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
comment|/* 	 * Now we must encrypt the verifier and package it up. 	 */
name|verfp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|verf_str
expr_stmt|;
operator|*
name|verfp
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|RPCAKN_NICKNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_second
operator|>
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
operator|||
operator|(
name|time_second
operator|==
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
operator|&&
name|time_second
operator|>
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_usec
operator|)
condition|)
name|getmicrotime
argument_list|(
operator|&
name|nuidp
operator|->
name|nu_timestamp
argument_list|)
expr_stmt|;
else|else
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_usec
operator|++
expr_stmt|;
name|ktvin
operator|.
name|tv_sec
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ktvin
operator|.
name|tv_usec
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* 	 * Now encrypt the timestamp verifier in ecb mode using the session 	 * key. 	 */
ifdef|#
directive|ifdef
name|NFSKERB
name|XXX
endif|#
directive|endif
operator|*
name|verfp
operator|++
operator|=
name|ktvout
operator|.
name|tv_sec
expr_stmt|;
operator|*
name|verfp
operator|++
operator|=
name|ktvout
operator|.
name|tv_usec
expr_stmt|;
operator|*
name|verfp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save the current nickname in a hash list entry on the mount point.  */
end_comment

begin_function
name|int
name|nfs_savenickauth
parameter_list|(
name|nmp
parameter_list|,
name|cred
parameter_list|,
name|len
parameter_list|,
name|key
parameter_list|,
name|mdp
parameter_list|,
name|dposp
parameter_list|,
name|mrep
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|len
decl_stmt|;
name|NFSKERBKEY_T
name|key
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
name|char
modifier|*
modifier|*
name|dposp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int32_t
name|t1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
init|=
operator|*
name|mdp
decl_stmt|;
name|struct
name|timeval
name|ktvin
decl_stmt|,
name|ktvout
decl_stmt|;
name|u_int32_t
name|nick
decl_stmt|;
name|char
modifier|*
name|dpos
init|=
operator|*
name|dposp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|deltasec
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|==
operator|(
literal|3
operator|*
name|NFSX_UNSIGNED
operator|)
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ktvin
operator|.
name|tv_sec
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ktvin
operator|.
name|tv_usec
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|nick
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 		 * Decrypt the timestamp in ecb mode. 		 */
ifdef|#
directive|ifdef
name|NFSKERB
name|XXX
endif|#
directive|endif
name|ktvout
operator|.
name|tv_sec
init|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|ktvout
operator|.
name|tv_sec
argument_list|)
decl_stmt|;
name|ktvout
operator|.
name|tv_usec
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|ktvout
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|deltasec
operator|=
name|time_second
operator|-
name|ktvout
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|deltasec
operator|<
literal|0
condition|)
name|deltasec
operator|=
operator|-
name|deltasec
expr_stmt|;
comment|/* 		 * If ok, add it to the hash list for the mount point. 		 */
if|if
condition|(
name|deltasec
operator|<=
name|NFS_KERBCLOCKSKEW
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_numuids
operator|<
name|nuidhash_max
condition|)
block|{
name|nmp
operator|->
name|nm_numuids
operator|++
expr_stmt|;
name|nuidp
operator|=
operator|(
expr|struct
name|nfsuid
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsuid
argument_list|)
argument_list|,
name|M_NFSUID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nuidp
operator|=
name|nmp
operator|->
name|nm_uidlruhead
operator|.
name|tqh_first
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
block|}
name|nuidp
operator|->
name|nu_flag
operator|=
literal|0
expr_stmt|;
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|nuidp
operator|->
name|nu_expire
operator|=
name|time_second
operator|+
name|NFS_KERBTTL
expr_stmt|;
name|nuidp
operator|->
name|nu_timestamp
operator|=
name|ktvout
expr_stmt|;
name|nuidp
operator|->
name|nu_nickname
operator|=
name|nick
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|nuidp
operator|->
name|nu_key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nmp
operator|->
name|nm_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NMUIDHASH
argument_list|(
name|nmp
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|)
argument_list|,
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsmout
label|:
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

