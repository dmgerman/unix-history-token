begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsserver/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfsserver/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsserver/nfs_fha.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NFS_FHA
argument_list|,
literal|"NFS FHA"
argument_list|,
literal|"NFS FHA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Sysctl defaults. */
end_comment

begin_define
define|#
directive|define
name|DEF_BIN_SHIFT
value|18
end_define

begin_comment
comment|/* 256k */
end_comment

begin_define
define|#
directive|define
name|DEF_MAX_NFSDS_PER_FH
value|8
end_define

begin_define
define|#
directive|define
name|DEF_MAX_REQS_PER_NFSD
value|4
end_define

begin_struct
struct|struct
name|fha_ctls
block|{
name|u_int32_t
name|bin_shift
decl_stmt|;
name|u_int32_t
name|max_nfsds_per_fh
decl_stmt|;
name|u_int32_t
name|max_reqs_per_nfsd
decl_stmt|;
block|}
name|fha_ctls
struct|;
end_struct

begin_decl_stmt
name|struct
name|sysctl_ctx_list
name|fha_clist
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfsrv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfsrv_fha
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Static sysctl node for the fha from the top-level vfs_nfsrv node. */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_nfsrv
argument_list|,
name|OID_AUTO
argument_list|,
name|fha
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"fha node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is the global structure that represents the state of the fha system. */
end_comment

begin_struct
specifier|static
struct|struct
name|fha_global
block|{
name|struct
name|fha_hash_entry_list
modifier|*
name|hashtable
decl_stmt|;
name|u_long
name|hashmask
decl_stmt|;
block|}
name|g_fha
struct|;
end_struct

begin_comment
comment|/*  * These are the entries in the filehandle hash.  They talk about a specific  * file, requests against which are being handled by one or more nfsds.  We  * keep a chain of nfsds against the file. We only have more than one if reads  * are ongoing, and then only if the reads affect disparate regions of the  * file.  *  * In general, we want to assign a new request to an existing nfsd if it is  * going to contend with work happening already on that nfsd, or if the  * operation is a read and the nfsd is already handling a proximate read.  We  * do this to avoid jumping around in the read stream unnecessarily, and to  * avoid contention between threads over single files.  */
end_comment

begin_struct
struct|struct
name|fha_hash_entry
block|{
name|LIST_ENTRY
argument_list|(
argument|fha_hash_entry
argument_list|)
name|link
expr_stmt|;
name|u_int64_t
name|fh
decl_stmt|;
name|u_int16_t
name|num_reads
decl_stmt|;
name|u_int16_t
name|num_writes
decl_stmt|;
name|u_int8_t
name|num_threads
decl_stmt|;
name|struct
name|svcthread_list
name|threads
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|fha_hash_entry_list
argument_list|,
name|fha_hash_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A structure used for passing around data internally. */
end_comment

begin_struct
struct|struct
name|fha_info
block|{
name|u_int64_t
name|fh
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|locktype
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|fhe_stats_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|nfs_fha_init
parameter_list|(
name|void
modifier|*
name|foo
parameter_list|)
block|{
comment|/* 	 * A small hash table to map filehandles to fha_hash_entry 	 * structures. 	 */
name|g_fha
operator|.
name|hashtable
operator|=
name|hashinit
argument_list|(
literal|256
argument_list|,
name|M_NFS_FHA
argument_list|,
operator|&
name|g_fha
operator|.
name|hashmask
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the sysctl context list for the fha module. 	 */
name|sysctl_ctx_init
argument_list|(
operator|&
name|fha_clist
argument_list|)
expr_stmt|;
name|fha_ctls
operator|.
name|bin_shift
operator|=
name|DEF_BIN_SHIFT
expr_stmt|;
name|fha_ctls
operator|.
name|max_nfsds_per_fh
operator|=
name|DEF_MAX_NFSDS_PER_FH
expr_stmt|;
name|fha_ctls
operator|.
name|max_reqs_per_nfsd
operator|=
name|DEF_MAX_REQS_PER_NFSD
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|fha_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nfsrv_fha
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bin_shift"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fha_ctls
operator|.
name|bin_shift
argument_list|,
literal|0
argument_list|,
literal|"For FHA reads, no two requests will "
literal|"contend if they're 2^(bin_shift) bytes apart"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|fha_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nfsrv_fha
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_nfsds_per_fh"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fha_ctls
operator|.
name|max_nfsds_per_fh
argument_list|,
literal|0
argument_list|,
literal|"Maximum nfsd threads that "
literal|"should be working on requests for the same file handle"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|fha_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nfsrv_fha
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_reqs_per_nfsd"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fha_ctls
operator|.
name|max_reqs_per_nfsd
argument_list|,
literal|0
argument_list|,
literal|"Maximum requests that "
literal|"single nfsd thread should be working on at any time"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_OID
argument_list|(
operator|&
name|fha_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nfsrv_fha
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fhe_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fhe_stats_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_fha_uninit
parameter_list|(
name|void
modifier|*
name|foo
parameter_list|)
block|{
name|hashdestroy
argument_list|(
name|g_fha
operator|.
name|hashtable
argument_list|,
name|M_NFS_FHA
argument_list|,
name|g_fha
operator|.
name|hashmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|nfs_fha
argument_list|,
name|SI_SUB_ROOT_CONF
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|nfs_fha_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|nfs_fha
argument_list|,
name|SI_SUB_ROOT_CONF
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|nfs_fha_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This just specifies that offsets should obey affinity when within  * the same 1Mbyte (1<<20) chunk for the file (reads only for now).  */
end_comment

begin_function
specifier|static
name|void
name|fha_extract_info
parameter_list|(
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|struct
name|fha_info
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|nfsfh_t
name|fh
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
specifier|static
name|u_int64_t
name|random_fh
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|v3
init|=
operator|(
name|req
operator|->
name|rq_vers
operator|==
literal|3
operator|)
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|rpcproc_t
name|procnum
decl_stmt|;
comment|/* 	 * We start off with a random fh.  If we get a reasonable 	 * procnum, we set the fh.  If there's a concept of offset 	 * that we're interested in, we set that. 	 */
name|i
operator|->
name|fh
operator|=
operator|++
name|random_fh
expr_stmt|;
name|i
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|locktype
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
comment|/* 	 * Extract the procnum and convert to v3 form if necessary, 	 * taking care to deal with out-of-range procnums.  Caller will 	 * ensure that rq_vers is either 2 or 3. 	 */
name|procnum
operator|=
name|req
operator|->
name|rq_proc
expr_stmt|;
if|if
condition|(
operator|!
name|v3
condition|)
block|{
if|if
condition|(
name|procnum
operator|>
name|NFSV2PROC_STATFS
condition|)
goto|goto
name|out
goto|;
name|procnum
operator|=
name|nfsrv_nfsv3_procid
index|[
name|procnum
index|]
expr_stmt|;
block|}
comment|/* 	 * We do affinity for most.  However, we divide a realm of affinity 	 * by file offset so as to allow for concurrent random access.  We 	 * only do this for reads today, but this may change when IFS supports 	 * efficient concurrent writes. 	 */
if|if
condition|(
name|procnum
operator|==
name|NFSPROC_FSSTAT
operator|||
name|procnum
operator|==
name|NFSPROC_FSINFO
operator|||
name|procnum
operator|==
name|NFSPROC_PATHCONF
operator|||
name|procnum
operator|==
name|NFSPROC_NOOP
operator|||
name|procnum
operator|==
name|NFSPROC_NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|nfs_realign
argument_list|(
operator|&
name|req
operator|->
name|rq_args
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|md
operator|=
name|req
operator|->
name|rq_args
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Grab the filehandle. */
name|error
operator|=
name|nfsm_srvmtofh_xx
argument_list|(
operator|&
name|fh
operator|.
name|fh_generic
argument_list|,
name|v3
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bcopy
argument_list|(
name|fh
operator|.
name|fh_generic
operator|.
name|fh_fid
operator|.
name|fid_data
argument_list|,
operator|&
name|i
operator|->
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|i
operator|->
name|fh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Content ourselves with zero offset for all but reads. */
if|if
condition|(
name|procnum
operator|!=
name|NFSPROC_READ
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|v3
condition|)
block|{
name|tl
operator|=
name|nfsm_dissect_xx_nonblock
argument_list|(
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|i
operator|->
name|offset
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tl
operator|=
name|nfsm_dissect_xx_nonblock
argument_list|(
name|NFSX_UNSIGNED
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|i
operator|->
name|offset
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|out
label|:
switch|switch
condition|(
name|procnum
condition|)
block|{
case|case
name|NFSPROC_NULL
case|:
case|case
name|NFSPROC_GETATTR
case|:
case|case
name|NFSPROC_LOOKUP
case|:
case|case
name|NFSPROC_ACCESS
case|:
case|case
name|NFSPROC_READLINK
case|:
case|case
name|NFSPROC_READ
case|:
case|case
name|NFSPROC_READDIR
case|:
case|case
name|NFSPROC_READDIRPLUS
case|:
name|i
operator|->
name|locktype
operator|=
name|LK_SHARED
expr_stmt|;
break|break;
case|case
name|NFSPROC_SETATTR
case|:
case|case
name|NFSPROC_WRITE
case|:
case|case
name|NFSPROC_CREATE
case|:
case|case
name|NFSPROC_MKDIR
case|:
case|case
name|NFSPROC_SYMLINK
case|:
case|case
name|NFSPROC_MKNOD
case|:
case|case
name|NFSPROC_REMOVE
case|:
case|case
name|NFSPROC_RMDIR
case|:
case|case
name|NFSPROC_RENAME
case|:
case|case
name|NFSPROC_LINK
case|:
case|case
name|NFSPROC_FSSTAT
case|:
case|case
name|NFSPROC_FSINFO
case|:
case|case
name|NFSPROC_PATHCONF
case|:
case|case
name|NFSPROC_COMMIT
case|:
case|case
name|NFSPROC_NOOP
case|:
name|i
operator|->
name|locktype
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|fha_hash_entry
modifier|*
name|fha_hash_entry_new
parameter_list|(
name|u_int64_t
name|fh
parameter_list|)
block|{
name|struct
name|fha_hash_entry
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|,
name|M_NFS_FHA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|e
operator|->
name|fh
operator|=
name|fh
expr_stmt|;
name|e
operator|->
name|num_reads
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|num_writes
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|num_threads
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|e
operator|->
name|threads
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_destroy
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|num_reads
operator|+
name|e
operator|->
name|num_writes
condition|)
name|panic
argument_list|(
literal|"nonempty fhe"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|,
name|M_NFS_FHA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_remove
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|e
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fha_hash_entry_destroy
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fha_hash_entry
modifier|*
name|fha_hash_entry_lookup
parameter_list|(
name|SVCPOOL
modifier|*
name|pool
parameter_list|,
name|u_int64_t
name|fh
parameter_list|)
block|{
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|,
modifier|*
name|new_fhe
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fhe
argument_list|,
argument|&g_fha.hashtable[fh % g_fha.hashmask]
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|fhe
operator|->
name|fh
operator|==
name|fh
condition|)
break|break;
if|if
condition|(
operator|!
name|fhe
condition|)
block|{
comment|/* Allocate a new entry. */
name|mtx_unlock
argument_list|(
operator|&
name|pool
operator|->
name|sp_lock
argument_list|)
expr_stmt|;
name|new_fhe
operator|=
name|fha_hash_entry_new
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pool
operator|->
name|sp_lock
argument_list|)
expr_stmt|;
comment|/* Double-check to make sure we still need the new entry. */
name|LIST_FOREACH
argument_list|(
argument|fhe
argument_list|,
argument|&g_fha.hashtable[fh % g_fha.hashmask]
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|fhe
operator|->
name|fh
operator|==
name|fh
condition|)
break|break;
if|if
condition|(
operator|!
name|fhe
condition|)
block|{
name|fhe
operator|=
name|new_fhe
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_fha
operator|.
name|hashtable
index|[
name|fh
operator|%
name|g_fha
operator|.
name|hashmask
index|]
argument_list|,
name|fhe
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|fha_hash_entry_destroy
argument_list|(
name|new_fhe
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fhe
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_add_thread
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|SVCTHREAD
modifier|*
name|thread
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fhe
operator|->
name|threads
argument_list|,
name|thread
argument_list|,
name|st_alink
argument_list|)
expr_stmt|;
name|fhe
operator|->
name|num_threads
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_remove_thread
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|SVCTHREAD
modifier|*
name|thread
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|thread
argument_list|,
name|st_alink
argument_list|)
expr_stmt|;
name|fhe
operator|->
name|num_threads
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Account for an ongoing operation associated with this file.  */
end_comment

begin_function
specifier|static
name|void
name|fha_hash_entry_add_op
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|int
name|locktype
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|LK_EXCLUSIVE
operator|==
name|locktype
condition|)
name|fhe
operator|->
name|num_writes
operator|+=
name|count
expr_stmt|;
else|else
name|fhe
operator|->
name|num_reads
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SVCTHREAD
modifier|*
name|get_idle_thread
parameter_list|(
name|SVCPOOL
modifier|*
name|pool
parameter_list|)
block|{
name|SVCTHREAD
modifier|*
name|st
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|st
argument_list|,
argument|&pool->sp_idlethreads
argument_list|,
argument|st_ilink
argument_list|)
block|{
if|if
condition|(
name|st
operator|->
name|st_xprt
operator|==
name|NULL
operator|&&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|st_reqs
argument_list|)
condition|)
return|return
operator|(
name|st
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the service thread currently associated with the fhe that is  * appropriate to handle this operation.  */
end_comment

begin_function_decl
name|SVCTHREAD
modifier|*
name|fha_hash_entry_choose_thread
parameter_list|(
name|SVCPOOL
modifier|*
name|pool
parameter_list|,
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|struct
name|fha_info
modifier|*
name|i
parameter_list|,
name|SVCTHREAD
modifier|*
name|this_thread
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|SVCTHREAD
modifier|*
name|fha_hash_entry_choose_thread
parameter_list|(
name|SVCPOOL
modifier|*
name|pool
parameter_list|,
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|struct
name|fha_info
modifier|*
name|i
parameter_list|,
name|SVCTHREAD
modifier|*
name|this_thread
parameter_list|)
block|{
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|,
modifier|*
name|min_thread
init|=
name|NULL
decl_stmt|;
name|int
name|req_count
decl_stmt|,
name|min_count
init|=
literal|0
decl_stmt|;
name|off_t
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&fhe->threads
argument_list|,
argument|st_alink
argument_list|)
block|{
name|req_count
operator|=
name|thread
operator|->
name|st_reqcount
expr_stmt|;
comment|/* If there are any writes in progress, use the first thread. */
if|if
condition|(
name|fhe
operator|->
name|num_writes
condition|)
block|{
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 			    "fha: %p(%d)w", thread, req_count);
endif|#
directive|endif
return|return
operator|(
name|thread
operator|)
return|;
block|}
comment|/* 		 * Check for read locality, making sure that we won't 		 * exceed our per-thread load limit in the process. 		 */
name|offset1
operator|=
name|i
operator|->
name|offset
operator|>>
name|fha_ctls
operator|.
name|bin_shift
expr_stmt|;
name|offset2
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|thread
operator|->
name|st_reqs
argument_list|)
operator|->
name|rq_p3
operator|>>
name|fha_ctls
operator|.
name|bin_shift
expr_stmt|;
if|if
condition|(
name|offset1
operator|==
name|offset2
condition|)
block|{
if|if
condition|(
operator|(
name|fha_ctls
operator|.
name|max_reqs_per_nfsd
operator|==
literal|0
operator|)
operator|||
operator|(
name|req_count
operator|<
name|fha_ctls
operator|.
name|max_reqs_per_nfsd
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 				    "fha: %p(%d)r", thread, req_count);
endif|#
directive|endif
return|return
operator|(
name|thread
operator|)
return|;
block|}
block|}
comment|/* 		 * We don't have a locality match, so skip this thread, 		 * but keep track of the most attractive thread in case 		 * we need to come back to it later. 		 */
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 		    "fha: %p(%d)s off1 %llu off2 %llu", thread, 		    req_count, offset1, offset2);
endif|#
directive|endif
if|if
condition|(
operator|(
name|min_thread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|req_count
operator|<
name|min_count
operator|)
condition|)
block|{
name|min_count
operator|=
name|req_count
expr_stmt|;
name|min_thread
operator|=
name|thread
expr_stmt|;
block|}
block|}
comment|/* 	 * We didn't find a good match yet.  See if we can add 	 * a new thread to this file handle entry's thread list. 	 */
if|if
condition|(
operator|(
name|fha_ctls
operator|.
name|max_nfsds_per_fh
operator|==
literal|0
operator|)
operator|||
operator|(
name|fhe
operator|->
name|num_threads
operator|<
name|fha_ctls
operator|.
name|max_nfsds_per_fh
operator|)
condition|)
block|{
comment|/* 		 * We can add a new thread, so try for an idle thread 		 * first, and fall back to this_thread if none are idle. 		 */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|this_thread
operator|->
name|st_reqs
argument_list|)
condition|)
block|{
name|thread
operator|=
name|this_thread
expr_stmt|;
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 			    "fha: %p(%d)t", thread, thread->st_reqcount);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|thread
operator|=
name|get_idle_thread
argument_list|(
name|pool
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 			    "fha: %p(%d)i", thread, thread->st_reqcount);
endif|#
directive|endif
block|}
else|else
block|{
name|thread
operator|=
name|this_thread
expr_stmt|;
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 			    "fha: %p(%d)b", thread, thread->st_reqcount);
endif|#
directive|endif
block|}
name|fha_hash_entry_add_thread
argument_list|(
name|fhe
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't want to use any more threads for this file, so 		 * go back to the most attractive nfsd we're already using. 		 */
name|thread
operator|=
name|min_thread
expr_stmt|;
block|}
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After getting a request, try to assign it to some thread.  Usually we  * handle it ourselves.  */
end_comment

begin_function
name|SVCTHREAD
modifier|*
name|fha_assign
parameter_list|(
name|SVCTHREAD
modifier|*
name|this_thread
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
name|SVCPOOL
modifier|*
name|pool
decl_stmt|;
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|;
name|struct
name|fha_info
name|i
decl_stmt|;
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|;
comment|/* 	 * Only do placement if this is an NFS request. 	 */
if|if
condition|(
name|req
operator|->
name|rq_prog
operator|!=
name|NFS_PROG
condition|)
return|return
operator|(
name|this_thread
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|rq_vers
operator|!=
literal|2
operator|&&
name|req
operator|->
name|rq_vers
operator|!=
literal|3
condition|)
return|return
operator|(
name|this_thread
operator|)
return|;
name|pool
operator|=
name|req
operator|->
name|rq_xprt
operator|->
name|xp_pool
expr_stmt|;
name|fha_extract_info
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * We save the offset associated with this request for later 	 * nfsd matching. 	 */
name|fhe
operator|=
name|fha_hash_entry_lookup
argument_list|(
name|pool
argument_list|,
name|i
operator|.
name|fh
argument_list|)
expr_stmt|;
name|req
operator|->
name|rq_p1
operator|=
name|fhe
expr_stmt|;
name|req
operator|->
name|rq_p2
operator|=
name|i
operator|.
name|locktype
expr_stmt|;
name|req
operator|->
name|rq_p3
operator|=
name|i
operator|.
name|offset
expr_stmt|;
comment|/* 	 * Choose a thread, taking into consideration locality, thread load, 	 * and the number of threads already working on this file. 	 */
name|thread
operator|=
name|fha_hash_entry_choose_thread
argument_list|(
name|pool
argument_list|,
name|fhe
argument_list|,
operator|&
name|i
argument_list|,
name|this_thread
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|thread
argument_list|,
operator|(
literal|"fha_assign: NULL thread!"
operator|)
argument_list|)
expr_stmt|;
name|fha_hash_entry_add_op
argument_list|(
name|fhe
argument_list|,
name|i
operator|.
name|locktype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we're done with an operation.  The request has already  * been de-queued.  */
end_comment

begin_function
name|void
name|fha_nd_complete
parameter_list|(
name|SVCTHREAD
modifier|*
name|thread
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|fha_hash_entry
modifier|*
name|fhe
init|=
name|req
operator|->
name|rq_p1
decl_stmt|;
comment|/* 	 * This may be called for reqs that didn't go through 	 * fha_assign (e.g. extra NULL ops used for RPCSEC_GSS. 	 */
if|if
condition|(
operator|!
name|fhe
condition|)
return|return;
name|fha_hash_entry_add_op
argument_list|(
name|fhe
argument_list|,
name|req
operator|->
name|rq_p2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|st_reqcount
operator|==
literal|0
condition|)
block|{
name|fha_hash_entry_remove_thread
argument_list|(
name|fhe
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|fhe
operator|->
name|num_reads
operator|+
name|fhe
operator|->
name|num_writes
condition|)
name|fha_hash_entry_remove
argument_list|(
name|fhe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|SVCPOOL
modifier|*
name|nfsrv_pool
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fhe_stats_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|;
name|bool_t
name|first
init|=
name|TRUE
decl_stmt|;
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nfsrv_pool
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"NFSD not running\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nfsrv_pool
operator|->
name|sp_lock
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|g_fha
operator|.
name|hashmask
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|g_fha
operator|.
name|hashtable
index|[
name|i
index|]
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"No file handle entries.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|g_fha
operator|.
name|hashmask
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|fhe
argument_list|,
argument|&g_fha.hashtable[i]
argument_list|,
argument|link
argument_list|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%sfhe %p: {\n"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|fhe
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    fh: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fhe
operator|->
name|fh
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    num_reads: %d\n"
argument_list|,
name|fhe
operator|->
name|num_reads
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    num_writes: %d\n"
argument_list|,
name|fhe
operator|->
name|num_writes
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    num_threads: %d\n"
argument_list|,
name|fhe
operator|->
name|num_threads
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&fhe->threads
argument_list|,
argument|st_alink
argument_list|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    thread %p (count %d)\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|st_reqcount
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
comment|/* Limit the output. */
if|if
condition|(
operator|++
name|count
operator|>
literal|128
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|nfsrv_pool
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsrv_pool
operator|->
name|sp_lock
argument_list|)
expr_stmt|;
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

