begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: ipsec_input.c,v 1.63 2003/02/20 18:35:43 deraadt Exp $	*/
end_comment

begin_comment
comment|/*-  * The authors of this code are John Ioannidis (ji@tla.org),  * Angelos D. Keromytis (kermit@csd.uch.gr) and  * Niels Provos (provos@physnet.uni-hamburg.de).  *  * This code was written by John Ioannidis for BSD/OS in Athens, Greece,  * in November 1995.  *  * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,  * by Angelos D. Keromytis.  *  * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis  * and Niels Provos.  *  * Additional features in 1999 by Angelos D. Keromytis.  *  * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,  * Angelos D. Keromytis and Niels Provos.  * Copyright (c) 2001, Angelos D. Keromytis.  *  * Permission to use, copy, and modify this software with or without fee  * is hereby granted, provided that this entire notice is included in  * all copies of any software which is or includes a copy or  * modification of this software.  * You may use this code under the GNU public license if you so wish. Please  * contribute changes back to the authors under this freer than GPL license  * so that we may further the use of strong encryption without limitations to  * all.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE  * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR  * PURPOSE.  */
end_comment

begin_comment
comment|/*  * IPsec input processing.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_enc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ah_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/esp.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/esp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipcomp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ENC
end_ifdef

begin_include
include|#
directive|include
file|<net/if_enc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IPSEC_ISTAT
parameter_list|(
name|proto
parameter_list|,
name|name
parameter_list|)
value|do {	\ 	if ((proto) == IPPROTO_ESP)		\ 		ESPSTAT_INC(esps_##name);	\ 	else if ((proto) == IPPROTO_AH)		\ 		AHSTAT_INC(ahs_##name);		\ 	else					\ 		IPCOMPSTAT_INC(ipcomps_##name);	\ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|void
name|ipsec4_common_ctlinput
parameter_list|(
name|int
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ipsec_common_input gets called when an IPsec-protected packet  * is received by IPv4 or IPv6.  Its job is to find the right SA  * and call the appropriate transform.  The transform callback  * takes care of further processing (like ingress filtering).  */
end_comment

begin_function
specifier|static
name|int
name|ipsec_common_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|sproto
parameter_list|)
block|{
name|union
name|sockaddr_union
name|dst_address
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
name|struct
name|m_tag
modifier|*
name|tag
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null packet"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|&&
operator|!
name|V_esp_enable
operator|)
operator|||
operator|(
name|sproto
operator|==
name|IPPROTO_AH
operator|&&
operator|!
name|V_ah_enable
operator|)
operator|||
operator|(
name|sproto
operator|==
name|IPPROTO_IPCOMP
operator|&&
operator|!
name|V_ipcomp_enable
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: packet too small\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Retrieve the SPI from the relevant IPsec header */
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_ESP
condition|)
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_AH
condition|)
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
name|u_int16_t
name|cpi
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|spi
operator|=
name|ntohl
argument_list|(
name|htons
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the SA and (indirectly) call the appropriate 	 * kernel crypto routine. The resulting mbuf chain is a valid 	 * IP packet ready to go through input processing. 	 */
name|bzero
argument_list|(
operator|&
name|dst_address
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_address
argument_list|)
argument_list|)
expr_stmt|;
name|dst_address
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|af
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|dst_address
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_dst
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dst_address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* Find the source port for NAT-T; see udp*_espdecap. */
name|tag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPSEC_NAT_T_PORTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|dst_address
operator|.
name|sin
operator|.
name|sin_port
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|tag
operator|+
literal|1
operator|)
operator|)
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_NAT_T */
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_dst
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unsupported protocol family %u\n"
operator|,
name|__func__
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|nopf
argument_list|)
expr_stmt|;
return|return
name|EPFNOSUPPORT
return|;
block|}
comment|/* NB: only pass dst since key_allocsa follows RFC2401 */
name|sav
operator|=
name|KEY_ALLOCSA
argument_list|(
operator|&
name|dst_address
argument_list|,
name|sproto
argument_list|,
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: no key association found for SA %s/%08lx/%u\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|dst_address
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|notdb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|tdb_xform
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: attempted to use uninitialized SA %s/%08lx/%u\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|dst_address
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|noxform
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	 * Call appropriate transform and return -- callback takes care of 	 * everything else. 	 */
name|error
operator|=
call|(
modifier|*
name|sav
operator|->
name|tdb_xform
operator|->
name|xf_input
call|)
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_comment
comment|/*  * Common input handler for IPv4 AH, ESP, and IPCOMP.  */
end_comment

begin_function
name|int
name|ipsec4_common_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|off
decl_stmt|,
name|nxt
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|off
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|nxt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ipsec_common_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_p
argument_list|)
argument_list|,
name|AF_INET
argument_list|,
name|nxt
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ah4_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|ipsec4_common_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|IPPROTO_AH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ah4_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
name|sa
operator|->
name|sa_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
name|ipsec4_common_ctlinput
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
name|v
argument_list|,
name|IPPROTO_AH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|esp4_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|ipsec4_common_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|IPPROTO_ESP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|esp4_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
name|sa
operator|->
name|sa_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
name|ipsec4_common_ctlinput
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
name|v
argument_list|,
name|IPPROTO_ESP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipcomp4_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|ipsec4_common_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|IPPROTO_IPCOMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IPsec input callback for INET protocols.  * This routine is called as the transform callback.  * Takes care of filtering and other sanity checks on  * the processed packet.  */
end_comment

begin_function
name|int
name|ipsec4_common_input_cb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|,
name|struct
name|m_tag
modifier|*
name|mt
parameter_list|)
block|{
name|int
name|prot
decl_stmt|,
name|af
decl_stmt|,
name|sproto
decl_stmt|,
name|isr_prot
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|tdb_ident
modifier|*
name|tdbi
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
ifdef|#
directive|ifdef
name|notyet
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SAH"
operator|)
argument_list|)
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|af
operator|=
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|af
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"unexpected af %u"
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|sproto
operator|=
name|saidx
operator|->
name|proto
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: null mbuf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|badkcr
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Fix IPv4 header 		 * XXXGL: do we need this entire block? 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|skip
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|skip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: processing failed for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|prot
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ENC
name|encif
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|encif
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Pass the mbuf to enc0 for bpf and pfil. We will filter the IPIP 	 * packet later after it has been decapsulated. 	 */
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET
argument_list|,
name|ENC_IN
operator||
name|ENC_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|!=
name|IPPROTO_IPIP
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_filter
argument_list|(
operator|&
name|m
argument_list|,
name|PFIL_IN
argument_list|,
name|ENC_IN
operator||
name|ENC_BEFORE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* DEV_ENC */
comment|/* IP-in-IP encapsulation */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* enc0: strip outer IPv4 header */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX PROXY address isn't recorded in SAH */
comment|/* 		 * Check that the inner source address is the same as 		 * the proxy address, if available. 		 */
if|if
condition|(
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|ipn
operator|.
name|ip_src
operator|.
name|s_addr
operator|!=
name|saidx
operator|->
name|proxy
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: inner source address %s doesn't "
literal|"correspond to expected proxy source %s, "
literal|"SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|inet_ntoa4
argument_list|(
name|ipn
operator|.
name|ip_src
argument_list|)
operator|,
name|ipsp_address
argument_list|(
name|saidx
operator|->
name|proxy
argument_list|)
operator|,
name|ipsp_address
argument_list|(
name|saidx
operator|->
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* notyet */
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* IPv6-in-IP encapsulation. */
elseif|else
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* enc0: strip IPv4 header, keep IPv6 header only */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Check that the inner source address is the same as 		 * the proxy address, if available. 		 */
if|if
condition|(
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|saidx
operator|->
name|proxy
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6n
operator|.
name|ip6_src
argument_list|,
operator|&
name|saidx
operator|->
name|proxy
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|)
operator|||
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET6
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: inner source address %s doesn't "
literal|"correspond to expected proxy source %s, "
literal|"SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|ip6n
operator|.
name|ip6_src
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|proxy
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* notyet */
block|}
endif|#
directive|endif
comment|/* INET6 */
elseif|else
if|if
condition|(
name|prot
operator|!=
name|IPPROTO_IPV6
operator|&&
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_ANY
condition|)
block|{
comment|/* 		 * When mode is wildcard, inner protocol is IPv6 and 		 * we have no INET6 support - drop this packet a bit later. 		 * In other cases we assume transport mode and outer 		 * header was already stripped in xform_xxx_cb. 		 */
name|prot
operator|=
name|IPPROTO_IPIP
expr_stmt|;
block|}
comment|/* 	 * Record what we've done to the packet (under what SA it was 	 * processed). If we've been passed an mtag, it means the packet 	 * was already processed by an ethernet/crypto combo card and 	 * thus has a tag attached with all the right information, but 	 * with a PACKET_TAG_IPSEC_IN_CRYPTO_DONE as opposed to 	 * PACKET_TAG_IPSEC_IN_DONE type; in that case, just change the type. 	 */
if|if
condition|(
name|mt
operator|==
name|NULL
operator|&&
name|sproto
operator|!=
name|IPPROTO_IPCOMP
condition|)
block|{
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tdb_ident
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to get tag\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tdbi
operator|=
operator|(
expr|struct
name|tdb_ident
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
operator|&
name|tdbi
operator|->
name|dst
argument_list|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|tdbi
operator|->
name|proto
operator|=
name|sproto
expr_stmt|;
name|tdbi
operator|->
name|spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
comment|/* Cache those two for enc(4) in xform_ipip. */
name|tdbi
operator|->
name|alg_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|tdbi
operator|->
name|alg_enc
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mt
operator|!=
name|NULL
condition|)
block|{
name|mt
operator|->
name|m_tag_id
operator|=
name|PACKET_TAG_IPSEC_IN_DONE
expr_stmt|;
comment|/* XXX do we need to mark m_flags??? */
block|}
name|key_sa_recordxfer
argument_list|(
name|sav
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* record data transfer */
comment|/* 	 * In transport mode requeue decrypted mbuf back to IPv4 protocol 	 * handler. This is necessary to correctly expose rcvif. 	 */
if|if
condition|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TRANSPORT
condition|)
name|prot
operator|=
name|IPPROTO_IPIP
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ENC
comment|/* 	 * Pass the mbuf to enc0 for bpf and pfil. 	 */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
condition|)
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
condition|)
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET6
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_filter
argument_list|(
operator|&
name|m
argument_list|,
name|PFIL_IN
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* DEV_ENC */
comment|/* 	 * Re-dispatch via software interrupt. 	 */
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|IPPROTO_IPIP
case|:
name|isr_prot
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_IPV6
case|:
name|isr_prot
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot handle inner ip proto %d\n"
operator|,
name|__func__
operator|,
name|prot
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|nopf
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|netisr_queue_src
argument_list|(
name|isr_prot
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sav
operator|->
name|spi
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|qfull
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: queue full; proto %u packet dropped\n"
operator|,
name|__func__
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|ipsec4_common_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
comment|/* XXX nothing just yet */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/* IPv6 AH wrapper. */
end_comment

begin_function
name|int
name|ipsec6_common_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|protoff
decl_stmt|;
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
if|if
condition|(
operator|*
name|offp
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bad offset %u\n"
operator|,
name|__func__
operator|,
operator|*
name|offp
operator|)
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|offp
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|protoff
operator|=
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_nxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Chase down the header chain... */
name|protoff
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
do|do
block|{
name|protoff
operator|+=
name|l
expr_stmt|;
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
name|protoff
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6e
operator|.
name|ip6e_nxt
operator|==
name|IPPROTO_AH
condition|)
name|l
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
else|else
name|l
operator|=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|l
operator|>
literal|0
argument_list|,
operator|(
literal|"l went zero or negative"
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|protoff
operator|+
name|l
operator|<
operator|*
name|offp
condition|)
do|;
comment|/* Malformed packet check */
if|if
condition|(
name|protoff
operator|+
name|l
operator|!=
operator|*
name|offp
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bad packet header chain, protoff %u, "
literal|"l %u, off %u\n"
operator|,
name|__func__
operator|,
name|protoff
operator|,
name|l
operator|,
operator|*
name|offp
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|proto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
name|protoff
operator|+=
name|offsetof
argument_list|(
expr|struct
name|ip6_ext
argument_list|,
name|ip6e_nxt
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ipsec_common_input
argument_list|(
operator|*
name|mp
argument_list|,
operator|*
name|offp
argument_list|,
name|protoff
argument_list|,
name|AF_INET6
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
end_function

begin_comment
comment|/*  * IPsec input callback, called by the transform callback. Takes care of  * filtering and other sanity checks on the processed packet.  */
end_comment

begin_function
name|int
name|ipsec6_common_input_cb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|,
name|struct
name|m_tag
modifier|*
name|mt
parameter_list|)
block|{
name|int
name|prot
decl_stmt|,
name|af
decl_stmt|,
name|sproto
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|tdb_ident
modifier|*
name|tdbi
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|int
name|nxt
decl_stmt|;
name|u_int8_t
name|nxt8
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nest
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SAH"
operator|)
argument_list|)
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|af
operator|=
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|af
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"unexpected af %u"
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|sproto
operator|=
name|saidx
operator|->
name|proto
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: null mbuf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|badkcr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Fix IPv6 header */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: processing failed for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save protocol */
name|prot
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|prot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ENC
name|encif
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|encif
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Pass the mbuf to enc0 for bpf and pfil. We will filter the IPIP 	 * packet later after it has been decapsulated. 	 */
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET6
argument_list|,
name|ENC_IN
operator||
name|ENC_BEFORE
argument_list|)
expr_stmt|;
comment|/* XXX-BZ does not make sense. */
if|if
condition|(
name|prot
operator|!=
name|IPPROTO_IPIP
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_filter
argument_list|(
operator|&
name|m
argument_list|,
name|PFIL_IN
argument_list|,
name|ENC_IN
operator||
name|ENC_BEFORE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* DEV_ENC */
ifdef|#
directive|ifdef
name|INET
comment|/* IP-in-IP encapsulation */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* ipn will now contain the inner IPv4 header */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Check that the inner source address is the same as 		 * the proxy address, if available. 		 */
if|if
condition|(
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|ipn
operator|.
name|ip_src
operator|.
name|s_addr
operator|!=
name|saidx
operator|->
name|proxy
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: inner source address %s doesn't "
literal|"correspond to expected proxy source %s, "
literal|"SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|inet_ntoa4
argument_list|(
name|ipn
operator|.
name|ip_src
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|proxy
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* notyet */
block|}
endif|#
directive|endif
comment|/* INET */
comment|/* IPv6-in-IP encapsulation */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* ip6n will now contain the inner IPv6 header. */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Check that the inner source address is the same as 		 * the proxy address, if available. 		 */
if|if
condition|(
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|saidx
operator|->
name|proxy
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6n
operator|.
name|ip6_src
argument_list|,
operator|&
name|saidx
operator|->
name|proxy
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|)
operator|||
operator|(
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET6
operator|&&
name|saidx
operator|->
name|proxy
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: inner source address %s doesn't "
literal|"correspond to expected proxy source %s, "
literal|"SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|ip6n
operator|.
name|ip6_src
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|proxy
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* notyet */
block|}
comment|/* 	 * Record what we've done to the packet (under what SA it was 	 * processed). If we've been passed an mtag, it means the packet 	 * was already processed by an ethernet/crypto combo card and 	 * thus has a tag attached with all the right information, but 	 * with a PACKET_TAG_IPSEC_IN_CRYPTO_DONE as opposed to 	 * PACKET_TAG_IPSEC_IN_DONE type; in that case, just change the type. 	 */
if|if
condition|(
name|mt
operator|==
name|NULL
operator|&&
name|sproto
operator|!=
name|IPPROTO_IPCOMP
condition|)
block|{
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tdb_ident
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to get tag\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tdbi
operator|=
operator|(
expr|struct
name|tdb_ident
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
operator|&
name|tdbi
operator|->
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|sockaddr_union
argument_list|)
argument_list|)
expr_stmt|;
name|tdbi
operator|->
name|proto
operator|=
name|sproto
expr_stmt|;
name|tdbi
operator|->
name|spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
comment|/* Cache those two for enc(4) in xform_ipip. */
name|tdbi
operator|->
name|alg_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|tdbi
operator|->
name|alg_enc
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mt
operator|!=
name|NULL
condition|)
name|mt
operator|->
name|m_tag_id
operator|=
name|PACKET_TAG_IPSEC_IN_DONE
expr_stmt|;
comment|/* XXX do we need to mark m_flags??? */
block|}
name|key_sa_recordxfer
argument_list|(
name|sav
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ENC
comment|/* 	 * Pass the mbuf to enc0 for bpf and pfil. 	 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
condition|)
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
condition|)
name|ipsec_bpf
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET6
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_filter
argument_list|(
operator|&
name|m
argument_list|,
name|PFIL_IN
argument_list|,
name|ENC_IN
operator||
name|ENC_AFTER
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* DEV_ENC */
comment|/* Retrieve new protocol */
comment|/* We have stripped the IP6 header from the mbuf, we have to use the backuped proto value instead */
name|nxt8
operator|=
name|prot
expr_stmt|;
comment|/* 	 * See the end of ip6_input for this logic. 	 * IPPROTO_IPV[46] case will be processed just like other ones 	 */
name|nest
operator|=
literal|0
expr_stmt|;
name|nxt
operator|=
name|nxt8
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|IPPROTO_DONE
condition|)
block|{
if|if
condition|(
name|V_ip6_hdrnestlimit
operator|&&
operator|(
operator|++
name|nest
operator|>
name|V_ip6_hdrnestlimit
operator|)
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_toomanyhdr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Protection against faulty packet - there should be 		 * more sanity checks in header chain processing. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|skip
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_tooshort
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Enforce IPsec policy checking if we are seeing last header. 		 * note that we do not visit this with protocols with pcb layer 		 * code - like udp/tcp/raw ip. 		 */
if|if
condition|(
operator|(
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|!=
literal|0
operator|&&
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|nxt
operator|=
operator|(
operator|*
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|skip
operator|,
name|nxt
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|esp6_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|ip6ctlparam
modifier|*
name|ip6cp
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
condition|)
return|return;
comment|/* if the parameter is from icmp6, decode it. */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|d
expr_stmt|;
name|m
operator|=
name|ip6cp
operator|->
name|ip6c_m
expr_stmt|;
name|ip6
operator|=
name|ip6cp
operator|->
name|ip6c_ip6
expr_stmt|;
name|off
operator|=
name|ip6cp
operator|->
name|ip6c_off
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
name|ip6
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
comment|/* calm gcc */
block|}
if|if
condition|(
name|ip6
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ip6ctlparam
name|ip6cp1
decl_stmt|;
comment|/* 		 * Notify the error to all possible sockets via pfctlinput2. 		 * Since the upper layer information (such as protocol type, 		 * source and destination ports) is embedded in the encrypted 		 * data and might have been cut, we can't directly call 		 * an upper layer ctlinput function. However, the pcbnotify 		 * function will consider source and destination addresses 		 * as well as the flow info value, and may be able to find 		 * some PCB that should be notified. 		 * Although pfctlinput2 will call esp6_ctlinput(), there is 		 * no possibility of an infinite loop of function calls, 		 * because we don't pass the inner IPv6 header. 		 */
name|bzero
argument_list|(
operator|&
name|ip6cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6cp1
argument_list|)
argument_list|)
expr_stmt|;
name|ip6cp1
operator|.
name|ip6c_src
operator|=
name|ip6cp
operator|->
name|ip6c_src
expr_stmt|;
name|pfctlinput2
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ip6cp1
argument_list|)
expr_stmt|;
comment|/* 		 * Then go to special cases that need ESP header information. 		 * XXX: We assume that when ip6 is non NULL, 		 * M and OFF are valid. 		 */
if|if
condition|(
name|cmd
operator|==
name|PRC_MSGSIZE
condition|)
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
name|int
name|valid
decl_stmt|;
comment|/* check header length before using m_copydata */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|esp
argument_list|)
condition|)
return|return;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
operator|+
name|offsetof
argument_list|(
expr|struct
name|esp
argument_list|,
name|esp_spi
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spi
argument_list|)
expr_stmt|;
comment|/* 			 * Check to see if we have a valid SA corresponding to 			 * the address in the ICMP message payload. 			 */
name|sav
operator|=
name|KEY_ALLOCSA
argument_list|(
operator|(
expr|union
name|sockaddr_union
operator|*
operator|)
name|sa
argument_list|,
name|IPPROTO_ESP
argument_list|,
name|spi
argument_list|)
expr_stmt|;
name|valid
operator|=
operator|(
name|sav
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|sav
condition|)
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* XXX Further validation? */
comment|/* 			 * Depending on whether the SA is "valid" and 			 * routing table size (mtudisc_{hi,lo}wat), we will: 			 * - recalcurate the new MTU and create the 			 *   corresponding routing entry, or 			 * - ignore the MTU change notification. 			 */
name|icmp6_mtudisc_update
argument_list|(
name|ip6cp
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* we normally notify any pcb here */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

end_unit

