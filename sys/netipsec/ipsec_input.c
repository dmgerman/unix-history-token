begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: ipsec_input.c,v 1.63 2003/02/20 18:35:43 deraadt Exp $	*/
end_comment

begin_comment
comment|/*-  * The authors of this code are John Ioannidis (ji@tla.org),  * Angelos D. Keromytis (kermit@csd.uch.gr) and  * Niels Provos (provos@physnet.uni-hamburg.de).  *  * This code was written by John Ioannidis for BSD/OS in Athens, Greece,  * in November 1995.  *  * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,  * by Angelos D. Keromytis.  *  * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis  * and Niels Provos.  *  * Additional features in 1999 by Angelos D. Keromytis.  *  * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,  * Angelos D. Keromytis and Niels Provos.  * Copyright (c) 2001, Angelos D. Keromytis.  * Copyright (c) 2016 Andrey V. Elsukov<ae@FreeBSD.org>  *  * Permission to use, copy, and modify this software with or without fee  * is hereby granted, provided that this entire notice is included in  * all copies of any software which is or includes a copy or  * modification of this software.  * You may use this code under the GNU public license if you so wish. Please  * contribute changes back to the authors under this freer than GPL license  * so that we may further the use of strong encryption without limitations to  * all.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE  * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR  * PURPOSE.  */
end_comment

begin_comment
comment|/*  * IPsec input processing.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/hhook.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_enc.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ah_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/esp.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/esp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipcomp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_define
define|#
directive|define
name|IPSEC_ISTAT
parameter_list|(
name|proto
parameter_list|,
name|name
parameter_list|)
value|do {	\ 	if ((proto) == IPPROTO_ESP)		\ 		ESPSTAT_INC(esps_##name);	\ 	else if ((proto) == IPPROTO_AH)		\ 		AHSTAT_INC(ahs_##name);		\ 	else					\ 		IPCOMPSTAT_INC(ipcomps_##name);	\ } while (0)
end_define

begin_comment
comment|/*  * ipsec_common_input gets called when an IPsec-protected packet  * is received by IPv4 or IPv6.  Its job is to find the right SA  * and call the appropriate transform.  The transform callback  * takes care of further processing (like ingress filtering).  */
end_comment

begin_function
specifier|static
name|int
name|ipsec_common_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|sproto
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|union
name|sockaddr_union
name|dst_address
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint32_t
name|spi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null packet"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|&&
operator|!
name|V_esp_enable
operator|)
operator|||
operator|(
name|sproto
operator|==
name|IPPROTO_AH
operator|&&
operator|!
name|V_ah_enable
operator|)
operator|||
operator|(
name|sproto
operator|==
name|IPPROTO_IPCOMP
operator|&&
operator|!
name|V_ipcomp_enable
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|pdrops
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: packet too small\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Retrieve the SPI from the relevant IPsec header */
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_ESP
condition|)
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_AH
condition|)
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sproto
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
name|u_int16_t
name|cpi
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpi
argument_list|)
expr_stmt|;
name|spi
operator|=
name|ntohl
argument_list|(
name|htons
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the SA and (indirectly) call the appropriate 	 * kernel crypto routine. The resulting mbuf chain is a valid 	 * IP packet ready to go through input processing. 	 */
name|bzero
argument_list|(
operator|&
name|dst_address
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_address
argument_list|)
argument_list|)
expr_stmt|;
name|dst_address
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|af
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|dst_address
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_dst
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dst_address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_dst
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
comment|/* We keep addresses in SADB without embedded scope id */
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* XXX: sa6_recoverscope() */
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|ntohs
argument_list|(
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dst_address
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unsupported protocol family %u\n"
operator|,
name|__func__
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|nopf
argument_list|)
expr_stmt|;
return|return
name|EPFNOSUPPORT
return|;
block|}
comment|/* NB: only pass dst since key_allocsa follows RFC2401 */
name|sav
operator|=
name|key_allocsa
argument_list|(
operator|&
name|dst_address
argument_list|,
name|sproto
argument_list|,
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: no key association found for SA %s/%08lx/%u\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|dst_address
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|notdb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|tdb_xform
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: attempted to use uninitialized SA %s/%08lx/%u\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|dst_address
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|noxform
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	 * Call appropriate transform and return -- callback takes care of 	 * everything else. 	 */
name|error
operator|=
call|(
modifier|*
name|sav
operator|->
name|tdb_xform
operator|->
name|xf_input
call|)
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IPSEC_INPUT() method implementation for IPv4.  *  0 - Permitted by inbound security policy for further processing.  *  EACCES - Forbidden by inbound security policy.  *  EINPROGRESS - consumed by IPsec.  */
end_comment

begin_function
name|int
name|ipsec4_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_IPCOMP
case|:
comment|/* Do inbound IPsec processing for AH/ESP/IPCOMP */
name|ipsec_common_input
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_p
argument_list|)
argument_list|,
name|AF_INET
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
comment|/* mbuf consumed by IPsec */
default|default:
comment|/* 		 * Protocols with further headers get their IPsec treatment 		 * within the protocol specific processing. 		 */
if|if
condition|(
operator|(
name|inetsw
index|[
name|ip_protox
index|[
name|proto
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
block|}
empty_stmt|;
comment|/* 	 * Enforce IPsec policy checking if we are seeing last header. 	 */
if|if
condition|(
name|ipsec4_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Forbidden by inbound security policy */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPsec input callback for INET protocols.  * This routine is called as the transform callback.  * Takes care of filtering and other sanity checks on  * the processed packet.  */
end_comment

begin_function
name|int
name|ipsec4_common_input_cb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|ipsec_ctx_data
name|ctx
decl_stmt|;
name|struct
name|xform_history
modifier|*
name|xh
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|,
name|prot
decl_stmt|,
name|af
decl_stmt|,
name|sproto
decl_stmt|,
name|isr_prot
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SAH"
operator|)
argument_list|)
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|af
operator|=
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|af
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"unexpected af %u"
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|sproto
operator|=
name|saidx
operator|->
name|proto
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Fix IPv4 header 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|skip
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|skip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: processing failed for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|prot
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
comment|/* 	 * Check that we have NAT-T enabled and apply transport mode 	 * decapsulation NAT procedure (RFC3948). 	 * Do this before invoking into the PFIL. 	 */
if|if
condition|(
name|sav
operator|->
name|natt
operator|!=
name|NULL
operator|&&
operator|(
name|prot
operator|==
name|IPPROTO_UDP
operator|||
name|prot
operator|==
name|IPPROTO_TCP
operator|)
condition|)
name|udp_ipsec_adjust_cksum
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|prot
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|IPSEC_INIT_CTX
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|m
argument_list|,
name|sav
argument_list|,
name|AF_INET
argument_list|,
name|IPSEC_ENC_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_run_hhooks
argument_list|(
operator|&
name|ctx
argument_list|,
name|HHOOK_TYPE_IPSEC_IN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* update pointer */
comment|/* IP-in-IP encapsulation */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* enc0: strip outer IPv4 header */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* IPv6-in-IP encapsulation. */
elseif|else
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* enc0: strip IPv4 header, keep IPv6 header only */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
elseif|else
if|if
condition|(
name|prot
operator|!=
name|IPPROTO_IPV6
operator|&&
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_ANY
condition|)
block|{
comment|/* 		 * When mode is wildcard, inner protocol is IPv6 and 		 * we have no INET6 support - drop this packet a bit later. 		 * In other cases we assume transport mode. Set prot to 		 * correctly choose netisr. 		 */
name|prot
operator|=
name|IPPROTO_IPIP
expr_stmt|;
block|}
comment|/* 	 * Record what we've done to the packet (under what SA it was 	 * processed). 	 */
if|if
condition|(
name|sproto
operator|!=
name|IPPROTO_IPCOMP
condition|)
block|{
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xform_history
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to get tag\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|xh
operator|=
operator|(
expr|struct
name|xform_history
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
operator|&
name|xh
operator|->
name|dst
argument_list|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|xh
operator|->
name|spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|xh
operator|->
name|proto
operator|=
name|sproto
expr_stmt|;
name|xh
operator|->
name|mode
operator|=
name|saidx
operator|->
name|mode
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
name|key_sa_recordxfer
argument_list|(
name|sav
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* record data transfer */
comment|/* 	 * In transport mode requeue decrypted mbuf back to IPv4 protocol 	 * handler. This is necessary to correctly expose rcvif. 	 */
if|if
condition|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TRANSPORT
condition|)
name|prot
operator|=
name|IPPROTO_IPIP
expr_stmt|;
comment|/* 	 * Re-dispatch via software interrupt. 	 */
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|IPPROTO_IPIP
case|:
name|isr_prot
operator|=
name|NETISR_IP
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_IPV6
case|:
name|isr_prot
operator|=
name|NETISR_IPV6
expr_stmt|;
name|af
operator|=
name|AF_INET6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot handle inner ip proto %d\n"
operator|,
name|__func__
operator|,
name|prot
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|nopf
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IPSEC_INIT_CTX
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|m
argument_list|,
name|sav
argument_list|,
name|af
argument_list|,
name|IPSEC_ENC_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_run_hhooks
argument_list|(
operator|&
name|ctx
argument_list|,
name|HHOOK_TYPE_IPSEC_IN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* Handle virtual tunneling interfaces */
if|if
condition|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
name|error
operator|=
name|ipsec_if_input
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|netisr_queue_src
argument_list|(
name|isr_prot
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sav
operator|->
name|spi
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|qfull
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: queue full; proto %u packet dropped\n"
operator|,
name|__func__
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * IPSEC_INPUT() method implementation for IPv6.  *  0 - Permitted by inbound security policy for further processing.  *  EACCES - Forbidden by inbound security policy.  *  EINPROGRESS - consumed by IPsec.  */
end_comment

begin_function
name|int
name|ipsec6_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_IPCOMP
case|:
comment|/* Do inbound IPsec processing for AH/ESP/IPCOMP */
name|ipsec_common_input
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_nxt
argument_list|)
argument_list|,
name|AF_INET6
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
comment|/* mbuf consumed by IPsec */
default|default:
comment|/* 		 * Protocols with further headers get their IPsec treatment 		 * within the protocol specific processing. 		 */
if|if
condition|(
operator|(
name|inet6sw
index|[
name|ip6_protox
index|[
name|proto
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
block|}
empty_stmt|;
comment|/* 	 * Enforce IPsec policy checking if we are seeing last header. 	 */
if|if
condition|(
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Forbidden by inbound security policy */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPsec input callback, called by the transform callback. Takes care of  * filtering and other sanity checks on the processed packet.  */
end_comment

begin_function
name|int
name|ipsec6_common_input_cb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|ipsec_ctx_data
name|ctx
decl_stmt|;
name|struct
name|xform_history
modifier|*
name|xh
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|int
name|prot
decl_stmt|,
name|af
decl_stmt|,
name|sproto
decl_stmt|;
name|int
name|nxt
decl_stmt|,
name|isr_prot
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nest
decl_stmt|;
name|uint8_t
name|nxt8
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SAH"
operator|)
argument_list|)
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|af
operator|=
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|af
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"unexpected af %u"
operator|,
name|af
operator|)
argument_list|)
expr_stmt|;
name|sproto
operator|=
name|saidx
operator|->
name|proto
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sproto
operator|==
name|IPPROTO_ESP
operator|||
name|sproto
operator|==
name|IPPROTO_AH
operator|||
name|sproto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
comment|/* Fix IPv6 header */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: processing failed for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IPSEC_INIT_CTX
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|m
argument_list|,
name|sav
argument_list|,
name|af
argument_list|,
name|IPSEC_ENC_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_run_hhooks
argument_list|(
operator|&
name|ctx
argument_list|,
name|HHOOK_TYPE_IPSEC_IN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save protocol */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
literal|1
argument_list|,
operator|&
name|nxt8
argument_list|)
expr_stmt|;
name|prot
operator|=
name|nxt8
expr_stmt|;
comment|/* IPv6-in-IP encapsulation */
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPV6
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* ip6n will now contain the inner IPv6 header. */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
comment|/* IP-in-IP encapsulation */
elseif|else
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
operator|&&
name|saidx
operator|->
name|mode
operator|!=
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* ipn will now contain the inner IPv4 header */
name|m_striphdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET */
else|else
block|{
name|prot
operator|=
name|IPPROTO_IPV6
expr_stmt|;
comment|/* for correct BPF processing */
block|}
comment|/* 	 * Record what we've done to the packet (under what SA it was 	 * processed). 	 */
if|if
condition|(
name|sproto
operator|!=
name|IPPROTO_IPCOMP
condition|)
block|{
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xform_history
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to get tag\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|xh
operator|=
operator|(
expr|struct
name|xform_history
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
operator|&
name|xh
operator|->
name|dst
argument_list|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|xh
operator|->
name|spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|xh
operator|->
name|proto
operator|=
name|sproto
expr_stmt|;
name|xh
operator|->
name|mode
operator|=
name|saidx
operator|->
name|mode
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
name|key_sa_recordxfer
argument_list|(
name|sav
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|prot
operator|==
name|IPPROTO_IPIP
condition|)
name|af
operator|=
name|AF_INET
expr_stmt|;
else|else
endif|#
directive|endif
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|IPSEC_INIT_CTX
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|m
argument_list|,
name|sav
argument_list|,
name|af
argument_list|,
name|IPSEC_ENC_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipsec_run_hhooks
argument_list|(
operator|&
name|ctx
argument_list|,
name|HHOOK_TYPE_IPSEC_IN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|skip
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We stripped outer IPv6 header. 		 * Now we should requeue decrypted packet via netisr. 		 */
switch|switch
condition|(
name|prot
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_IPIP
case|:
name|isr_prot
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_IPV6
case|:
name|isr_prot
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot handle inner ip proto %d\n"
operator|,
name|__func__
operator|,
name|prot
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|nopf
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Handle virtual tunneling interfaces */
if|if
condition|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
name|error
operator|=
name|ipsec_if_input
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|netisr_queue_src
argument_list|(
name|isr_prot
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sav
operator|->
name|spi
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPSEC_ISTAT
argument_list|(
name|sproto
argument_list|,
name|qfull
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: queue full; proto %u packet"
literal|" dropped\n"
operator|,
name|__func__
operator|,
name|sproto
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * See the end of ip6_input for this logic. 	 * IPPROTO_IPV[46] case will be processed just like other ones 	 */
name|nest
operator|=
literal|0
expr_stmt|;
name|nxt
operator|=
name|nxt8
expr_stmt|;
while|while
condition|(
name|nxt
operator|!=
name|IPPROTO_DONE
condition|)
block|{
if|if
condition|(
name|V_ip6_hdrnestlimit
operator|&&
operator|(
operator|++
name|nest
operator|>
name|V_ip6_hdrnestlimit
operator|)
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_toomanyhdr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Protection against faulty packet - there should be 		 * more sanity checks in header chain processing. 		 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|skip
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_tooshort
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_truncated
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Enforce IPsec policy checking if we are seeing last header. 		 * note that we do not visit this with protocols with pcb layer 		 * code - like udp/tcp/raw ip. 		 */
if|if
condition|(
operator|(
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|!=
literal|0
operator|&&
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|nxt
operator|=
operator|(
operator|*
name|inet6sw
index|[
name|ip6_protox
index|[
name|nxt
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|skip
operator|,
name|nxt
operator|)
expr_stmt|;
block|}
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

end_unit

