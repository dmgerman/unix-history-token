begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * IPsec-specific mbuf routines.  */
end_comment

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vimage.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_comment
comment|/*  * Make space for a new header of length hlen at skip bytes  * into the packet.  When doing this we allocate new mbufs only  * when absolutely necessary.  The mbuf where the new header  * is to go is returned together with an offset into the mbuf.  * If NULL is returned then the mbuf chain may have been modified;  * the caller is assumed to always free the chain.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_makespace
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|int
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|remain
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|hlen
operator|<
name|MHLEN
argument_list|,
operator|(
literal|"hlen too big: %u"
operator|,
name|hlen
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|skip
operator|>
name|m
operator|->
name|m_len
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|skip
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * At this point skip is the offset into the mbuf m 	 * where the new header should be placed.  Figure out 	 * if there's space to insert the new header.  If so, 	 * and copying the remainder makese sense then do so. 	 * Otherwise insert a new mbuf in the chain, splitting 	 * the contents of m as needed. 	 */
name|remain
operator|=
name|m
operator|->
name|m_len
operator|-
name|skip
expr_stmt|;
comment|/* data to move */
if|if
condition|(
name|hlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* XXX code doesn't handle clusters XXX */
name|IPSEC_ASSERT
argument_list|(
name|remain
operator|<
name|MLEN
argument_list|,
operator|(
literal|"remainder too big: %u"
operator|,
name|remain
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Not enough space in m, split the contents 		 * of m, inserting new mbufs as required. 		 * 		 * NB: this ignores mbuf types. 		 */
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|n
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* splice new mbuf */
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|V_ipsec4stat
operator|.
name|ips_mbinserted
operator|++
expr_stmt|;
if|if
condition|(
name|hlen
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|+
name|remain
condition|)
block|{
comment|/* 			 * New header fits in the old mbuf if we copy 			 * the remainder; just do the copy to the new 			 * mbuf and we're good to go. 			 */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|remain
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|skip
operator|+
name|hlen
expr_stmt|;
operator|*
name|off
operator|=
name|skip
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No space in the old mbuf for the new header. 			 * Make space in the new mbuf and check the 			 * remainder'd data fits too.  If not then we 			 * must allocate an additional mbuf (yech). 			 */
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remain
operator|+
name|hlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n2
decl_stmt|;
name|MGET
argument_list|(
name|n2
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* NB: new mbuf is on chain, let caller free */
if|if
condition|(
name|n2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|n2
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n2
operator|->
name|m_len
operator|=
name|remain
expr_stmt|;
comment|/* splice in second mbuf */
name|n2
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|n2
expr_stmt|;
name|V_ipsec4stat
operator|.
name|ips_mbinserted
operator|++
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|hlen
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|+=
name|remain
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|-=
name|remain
expr_stmt|;
name|n
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
comment|/* header is at front ... */
operator|*
name|off
operator|=
literal|0
expr_stmt|;
comment|/* ... of new mbuf */
block|}
block|}
else|else
block|{
comment|/* 		 * Copy the remainder to the back of the mbuf 		 * so there's space to write the new header. 		 */
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
operator|+
name|hlen
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
operator|*
name|off
operator|=
name|skip
expr_stmt|;
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|hlen
expr_stmt|;
comment|/* adjust packet length */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * m_pad(m, n) pads<m> with<n> bytes at the end. The packet header  * length is updated, and a pointer to the first byte of the padding  * (which is guaranteed to be all in one mbuf) is returned.  */
end_comment

begin_function
name|caddr_t
name|m_pad
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|caddr_t
name|retval
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
comment|/* No stupid arguments. */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: pad length invalid (%d)\n"
operator|,
name|__func__
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pad
operator|=
name|n
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m0
operator|->
name|m_len
operator|<
name|len
condition|)
block|{
name|len
operator|-=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_len
operator|!=
name|len
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: length mismatch (should be %d instead of %d)\n"
operator|,
name|__func__
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|m0
operator|->
name|m_len
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check for zero-length trailing mbufs, and find the last one. */
for|for
control|(
name|m1
operator|=
name|m0
init|;
name|m1
operator|->
name|m_next
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m1
operator|->
name|m_next
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: length mismatch (should be %d instead "
literal|"of %d)\n"
operator|,
name|__func__
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|m1
operator|->
name|m_next
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m0
operator|=
name|m1
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|pad
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m0
argument_list|)
condition|)
block|{
comment|/* Add an mbuf to the chain. */
name|MGET
argument_list|(
name|m1
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unable to get extra mbuf\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m0
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
name|m0
operator|=
name|m1
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
name|m0
operator|->
name|m_data
operator|+
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Remove hlen data at offset skip in the packet.  This is used by  * the protocols strip protocol headers and associated data (e.g. IV,  * authenticator) on input.  */
end_comment

begin_function
name|int
name|m_striphdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|hlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|int
name|roff
decl_stmt|;
comment|/* Find beginning of header */
name|m1
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
operator|&
name|roff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Remove the header and associated data from the mbuf. */
if|if
condition|(
name|roff
operator|==
literal|0
condition|)
block|{
comment|/* The header was at the beginning of the mbuf */
name|V_ipsec4stat
operator|.
name|ips_input_front
operator|++
expr_stmt|;
name|m_adj
argument_list|(
name|m1
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roff
operator|+
name|hlen
operator|>=
name|m1
operator|->
name|m_len
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mo
decl_stmt|;
comment|/* 		 * Part or all of the header is at the end of this mbuf, 		 * so first let's remove the remainder of the header from 		 * the beginning of the remainder of the mbuf chain, if any. 		 */
name|V_ipsec4stat
operator|.
name|ips_input_end
operator|++
expr_stmt|;
if|if
condition|(
name|roff
operator|+
name|hlen
operator|>
name|m1
operator|->
name|m_len
condition|)
block|{
comment|/* Adjust the next mbuf by the remainder */
name|m_adj
argument_list|(
name|m1
operator|->
name|m_next
argument_list|,
name|roff
operator|+
name|hlen
operator|-
name|m1
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* The second mbuf is guaranteed not to have a pkthdr... */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
name|roff
operator|+
name|hlen
operator|-
name|m1
operator|->
name|m_len
operator|)
expr_stmt|;
block|}
comment|/* Now, let's unlink the mbuf chain for a second...*/
name|mo
operator|=
name|m1
operator|->
name|m_next
expr_stmt|;
name|m1
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* ...and trim the end of the first part of the chain...sick */
name|m_adj
argument_list|(
name|m1
argument_list|,
operator|-
operator|(
name|m1
operator|->
name|m_len
operator|-
name|roff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
name|m1
operator|->
name|m_len
operator|-
name|roff
operator|)
expr_stmt|;
comment|/* Finally, let's relink */
name|m1
operator|->
name|m_next
operator|=
name|mo
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The header lies in the "middle" of the mbuf; copy 		 * the remainder of the mbuf down over the header. 		 */
name|V_ipsec4stat
operator|.
name|ips_input_middle
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|roff
operator|+
name|hlen
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|roff
argument_list|,
name|m1
operator|->
name|m_len
operator|-
operator|(
name|roff
operator|+
name|hlen
operator|)
argument_list|)
expr_stmt|;
name|m1
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Diagnostic routine to check mbuf alignment as required by the  * crypto device drivers (that use DMA).  */
end_comment

begin_function
name|void
name|m_checkalignment
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|roff
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_getptr
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
operator|&
name|roff
argument_list|)
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"%s (off %u len %u): "
argument_list|,
name|where
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|roff
expr_stmt|;
do|do
block|{
name|int
name|mlen
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"addr misaligned %p,"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
name|mlen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
name|len
condition|)
name|mlen
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|mlen
expr_stmt|;
if|if
condition|(
name|len
operator|&&
operator|(
name|mlen
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"len mismatch %u,"
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|addr
operator|=
name|m
condition|?
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|&&
name|len
operator|>
literal|0
condition|)
do|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|printf
argument_list|(
literal|" [%p:%u]"
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

