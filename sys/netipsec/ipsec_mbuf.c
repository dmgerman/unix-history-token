begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * IPsec-specific mbuf routines.  */
end_comment

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_function_decl
specifier|extern
name|struct
name|mbuf
modifier|*
name|m_getptr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Create a writable copy of the mbuf chain.  While doing this  * we compact the chain with a goal of producing a chain with  * at most two mbufs.  The second mbuf in this chain is likely  * to be a cluster.  The primary purpose of this work is to create  * a writable packet for encryption, compression, etc.  The  * secondary goal is to linearize the data so the data can be  * passed to crypto hardware in the most efficient manner possible.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_clone
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mprev
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mfirst
decl_stmt|,
modifier|*
name|mlast
decl_stmt|;
name|int
name|len
decl_stmt|,
name|off
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"m_clone: null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|mprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|mprev
operator|->
name|m_next
control|)
block|{
comment|/* 		 * Regular mbufs are ignored unless there's a cluster 		 * in front of it that we can use to coalesce.  We do 		 * the latter mainly so later clusters can be coalesced 		 * also w/o having to handle them specially (i.e. convert 		 * mbuf+cluster -> cluster).  This optimization is heavily 		 * influenced by the assumption that we're running over 		 * Ethernet where MCLBYTES is large enough that the max 		 * packet size will permit lots of coalescing into a 		 * single cluster.  This in turn permits efficient 		 * crypto operations, especially when using hardware. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mprev
operator|&&
operator|(
name|mprev
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
name|m
operator|->
name|m_len
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|mprev
argument_list|)
condition|)
block|{
comment|/* XXX: this ignores mbuf types */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|mprev
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mprev
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mprev
operator|->
name|m_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mprev
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* unlink from chain */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* reclaim mbuf */
name|newipsecstat
operator|.
name|ips_mbcoalesced
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mprev
operator|=
name|m
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * Writable mbufs are left alone (for now). 		 */
if|if
condition|(
operator|!
name|MEXT_IS_REF
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Not writable, replace with a copy or coalesce with 		 * the previous mbuf if possible (since we have to copy 		 * it anyway, we try to reduce the number of mbufs and 		 * clusters so that future work is easier). 		 */
name|KASSERT
argument_list|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
argument_list|,
operator|(
literal|"m_clone: m_flags 0x%x"
operator|,
name|m
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
comment|/* NB: we only coalesce into a cluster or larger */
if|if
condition|(
name|mprev
operator|!=
name|NULL
operator|&&
operator|(
name|mprev
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
name|m
operator|->
name|m_len
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|mprev
argument_list|)
condition|)
block|{
comment|/* XXX: this ignores mbuf types */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|mprev
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mprev
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mprev
operator|->
name|m_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mprev
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* unlink from chain */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* reclaim mbuf */
name|newipsecstat
operator|.
name|ips_clcoalesced
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Allocate new space to hold the copy... 		 */
comment|/* XXX why can M_PKTHDR be set past the first mbuf? */
if|if
condition|(
name|mprev
operator|==
name|NULL
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
condition|)
block|{
comment|/* 			 * NB: if a packet header is present we must 			 * allocate the mbuf separately from any cluster 			 * because M_MOVE_PKTHDR will smash the data 			 * pointer and drop the M_EXT marker. 			 */
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|M_MOVE_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|n
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 		 * ... and copy the data.  We deal with jumbo mbufs 		 * (i.e. m_len> MCLBYTES) by splitting them into 		 * clusters.  We could just malloc a buffer and make 		 * it external but too many device drivers don't know 		 * how to break up the non-contiguous memory when 		 * doing DMA. 		 */
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|mfirst
operator|=
name|n
expr_stmt|;
name|mlast
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|cc
init|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|mlast
operator|!=
name|NULL
condition|)
name|mlast
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|mlast
operator|=
name|n
expr_stmt|;
name|newipsecstat
operator|.
name|ips_clcopied
operator|++
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
name|off
operator|+=
name|cc
expr_stmt|;
name|n
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mfirst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|n
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mprev
operator|==
name|NULL
condition|)
name|m0
operator|=
name|mfirst
expr_stmt|;
comment|/* new head of chain */
else|else
name|mprev
operator|->
name|m_next
operator|=
name|mfirst
expr_stmt|;
comment|/* replace old mbuf */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* release old mbuf */
name|mprev
operator|=
name|mfirst
expr_stmt|;
block|}
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make space for a new header of length hlen at skip bytes  * into the packet.  When doing this we allocate new mbufs only  * when absolutely necessary.  The mbuf where the new header  * is to go is returned together with an offset into the mbuf.  * If NULL is returned then the mbuf chain may have been modified;  * the caller is assumed to always free the chain.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_makespace
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|int
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|remain
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"m_dmakespace: null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|hlen
operator|<
name|MHLEN
argument_list|,
operator|(
literal|"m_makespace: hlen too big: %u"
operator|,
name|hlen
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|skip
operator|>
name|m
operator|->
name|m_len
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|skip
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * At this point skip is the offset into the mbuf m 	 * where the new header should be placed.  Figure out 	 * if there's space to insert the new header.  If so, 	 * and copying the remainder makese sense then do so. 	 * Otherwise insert a new mbuf in the chain, splitting 	 * the contents of m as needed. 	 */
name|remain
operator|=
name|m
operator|->
name|m_len
operator|-
name|skip
expr_stmt|;
comment|/* data to move */
if|if
condition|(
name|hlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* XXX code doesn't handle clusters XXX */
name|KASSERT
argument_list|(
name|remain
operator|<
name|MLEN
argument_list|,
operator|(
literal|"m_makespace: remainder too big: %u"
operator|,
name|remain
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Not enough space in m, split the contents 		 * of m, inserting new mbufs as required. 		 * 		 * NB: this ignores mbuf types. 		 */
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|n
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* splice new mbuf */
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
name|newipsecstat
operator|.
name|ips_mbinserted
operator|++
expr_stmt|;
if|if
condition|(
name|hlen
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|+
name|remain
condition|)
block|{
comment|/* 			 * New header fits in the old mbuf if we copy 			 * the remainder; just do the copy to the new 			 * mbuf and we're good to go. 			 */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|remain
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|skip
operator|+
name|hlen
expr_stmt|;
operator|*
name|off
operator|=
name|skip
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No space in the old mbuf for the new header. 			 * Make space in the new mbuf and check the 			 * remainder'd data fits too.  If not then we 			 * must allocate an additional mbuf (yech). 			 */
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remain
operator|+
name|hlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n2
decl_stmt|;
name|MGET
argument_list|(
name|n2
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* NB: new mbuf is on chain, let caller free */
if|if
condition|(
name|n2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|n2
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n2
operator|->
name|m_len
operator|=
name|remain
expr_stmt|;
comment|/* splice in second mbuf */
name|n2
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|n2
expr_stmt|;
name|newipsecstat
operator|.
name|ips_mbinserted
operator|++
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|hlen
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|+=
name|remain
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|-=
name|remain
expr_stmt|;
name|n
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
comment|/* header is at front ... */
operator|*
name|off
operator|=
literal|0
expr_stmt|;
comment|/* ... of new mbuf */
block|}
block|}
else|else
block|{
comment|/* 		 * Copy the remainder to the back of the mbuf 		 * so there's space to write the new header. 		 */
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|skip
operator|+
name|hlen
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
operator|*
name|off
operator|=
name|skip
expr_stmt|;
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|hlen
expr_stmt|;
comment|/* adjust packet length */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * m_pad(m, n) pads<m> with<n> bytes at the end. The packet header  * length is updated, and a pointer to the first byte of the padding  * (which is guaranteed to be all in one mbuf) is returned.  */
end_comment

begin_function
name|caddr_t
name|m_pad
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|caddr_t
name|retval
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
comment|/* No stupid arguments. */
name|DPRINTF
argument_list|(
operator|(
literal|"m_pad: pad length invalid (%d)\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pad
operator|=
name|n
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m0
operator|->
name|m_len
operator|<
name|len
condition|)
block|{
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_next
operator|!=
name|NULL
argument_list|,
operator|(
literal|"m_pad: m0 null, len %u m_len %u"
operator|,
name|len
operator|,
name|m0
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|len
operator|-=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_len
operator|!=
name|len
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"m_pad: length mismatch (should be %d instead of %d)\n"
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|m0
operator|->
name|m_len
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check for zero-length trailing mbufs, and find the last one. */
for|for
control|(
name|m1
operator|=
name|m0
init|;
name|m1
operator|->
name|m_next
condition|;
name|m1
operator|=
name|m1
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m1
operator|->
name|m_next
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"m_pad: length mismatch (should be %d "
literal|"instead of %d)\n"
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|m1
operator|->
name|m_next
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m0
operator|=
name|m1
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|pad
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m0
argument_list|)
condition|)
block|{
comment|/* Add an mbuf to the chain. */
name|MGET
argument_list|(
name|m1
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"m_pad: unable to get extra mbuf\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m0
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
name|m0
operator|=
name|m1
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
name|m0
operator|->
name|m_data
operator|+
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Remove hlen data at offset skip in the packet.  This is used by  * the protocols strip protocol headers and associated data (e.g. IV,  * authenticator) on input.  */
end_comment

begin_function
name|int
name|m_striphdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|hlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|int
name|roff
decl_stmt|;
comment|/* Find beginning of header */
name|m1
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
operator|&
name|roff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Remove the header and associated data from the mbuf. */
if|if
condition|(
name|roff
operator|==
literal|0
condition|)
block|{
comment|/* The header was at the beginning of the mbuf */
name|newipsecstat
operator|.
name|ips_input_front
operator|++
expr_stmt|;
name|m_adj
argument_list|(
name|m1
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roff
operator|+
name|hlen
operator|>=
name|m1
operator|->
name|m_len
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mo
decl_stmt|;
comment|/* 		 * Part or all of the header is at the end of this mbuf, 		 * so first let's remove the remainder of the header from 		 * the beginning of the remainder of the mbuf chain, if any. 		 */
name|newipsecstat
operator|.
name|ips_input_end
operator|++
expr_stmt|;
if|if
condition|(
name|roff
operator|+
name|hlen
operator|>
name|m1
operator|->
name|m_len
condition|)
block|{
comment|/* Adjust the next mbuf by the remainder */
name|m_adj
argument_list|(
name|m1
operator|->
name|m_next
argument_list|,
name|roff
operator|+
name|hlen
operator|-
name|m1
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* The second mbuf is guaranteed not to have a pkthdr... */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
name|roff
operator|+
name|hlen
operator|-
name|m1
operator|->
name|m_len
operator|)
expr_stmt|;
block|}
comment|/* Now, let's unlink the mbuf chain for a second...*/
name|mo
operator|=
name|m1
operator|->
name|m_next
expr_stmt|;
name|m1
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
comment|/* ...and trim the end of the first part of the chain...sick */
name|m_adj
argument_list|(
name|m1
argument_list|,
operator|-
operator|(
name|m1
operator|->
name|m_len
operator|-
name|roff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
name|m1
operator|->
name|m_len
operator|-
name|roff
operator|)
expr_stmt|;
comment|/* Finally, let's relink */
name|m1
operator|->
name|m_next
operator|=
name|mo
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The header lies in the "middle" of the mbuf; copy 		 * the remainder of the mbuf down over the header. 		 */
name|newipsecstat
operator|.
name|ips_input_middle
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|roff
operator|+
name|hlen
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|roff
argument_list|,
name|m1
operator|->
name|m_len
operator|-
operator|(
name|roff
operator|+
name|hlen
operator|)
argument_list|)
expr_stmt|;
name|m1
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Diagnostic routine to check mbuf alignment as required by the  * crypto device drivers (that use DMA).  */
end_comment

begin_function
name|void
name|m_checkalignment
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|roff
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_getptr
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
operator|&
name|roff
argument_list|)
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"%s (off %u len %u): "
argument_list|,
name|where
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|roff
expr_stmt|;
do|do
block|{
name|int
name|mlen
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"addr misaligned %p,"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
name|mlen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
name|len
condition|)
name|mlen
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|mlen
expr_stmt|;
if|if
condition|(
name|len
operator|&&
operator|(
name|mlen
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"len mismatch %u,"
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|addr
operator|=
name|m
condition|?
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|&&
name|len
operator|>
literal|0
condition|)
do|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|printf
argument_list|(
literal|" [%p:%u]"
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

