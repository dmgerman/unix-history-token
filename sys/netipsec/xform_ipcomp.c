begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/* $OpenBSD: ip_ipcomp.c,v 1.1 2001/07/05 12:08:52 jjbg Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001 Jean-Jacques Bernard-Gundol (jj@wabbitt.org)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *   notice, this list of conditions and the following disclaimer in the  *   documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *   derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* IP payload compression protocol (IPComp), see RFC 2393 */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_encap.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ipcomp.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipcomp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/deflate.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/xform.h>
end_include

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipcomp_enable
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|ipcompstat
argument_list|,
name|ipcompstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ipcompstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ipcompstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ipcomp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipcomp
argument_list|,
name|OID_AUTO
argument_list|,
name|ipcomp_enable
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipcomp_enable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_ipcomp
argument_list|,
name|IPSECCTL_STATS
argument_list|,
name|stats
argument_list|,
expr|struct
name|ipcompstat
argument_list|,
name|ipcompstat
argument_list|,
literal|"IPCOMP statistics (struct ipcompstat, netipsec/ipcomp_var.h"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ipcomp_input_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipcomp_output_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * RFC 3173 p 2.2. Non-Expansion Policy:  * If the total size of a compressed payload and the IPComp header, as  * defined in section 3, is not smaller than the size of the original  * payload, the IP datagram MUST be sent in the original non-compressed  * form.  *  * When we use IPComp in tunnel mode, for small packets we will receive  * encapsulated IP-IP datagrams without any compression and without IPComp  * header.  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_encapcheck
parameter_list|(
name|union
name|sockaddr_union
modifier|*
name|src
parameter_list|,
name|union
name|sockaddr_union
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|sav
operator|=
name|key_allocsa_tunnel
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IPPROTO_IPCOMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|4
operator|)
return|;
else|else
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipcomp_nonexp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|int
name|isr
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPPROTO_IPV4
case|:
name|isr
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPPROTO_IPV6
case|:
name|isr
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_nopf
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
name|IPCOMPSTAT_ADD
argument_list|(
name|ipcomps_ibytes
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_input
argument_list|)
expr_stmt|;
name|netisr_dispatch
argument_list|(
name|isr
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipcomp_init() is called when an CPI is being set up.  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_init
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|struct
name|xformsw
modifier|*
name|xsp
parameter_list|)
block|{
specifier|const
name|struct
name|comp_algo
modifier|*
name|tcomp
decl_stmt|;
name|struct
name|cryptoini
name|cric
decl_stmt|;
comment|/* NB: algorithm really comes in alg_enc and not alg_comp! */
name|tcomp
operator|=
name|comp_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcomp
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unsupported compression algorithm %d\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|alg_comp
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sav
operator|->
name|alg_comp
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
comment|/* set for doing histogram */
name|sav
operator|->
name|tdb_xform
operator|=
name|xsp
expr_stmt|;
name|sav
operator|->
name|tdb_compalgxform
operator|=
name|tcomp
expr_stmt|;
comment|/* Initialize crypto session */
name|bzero
argument_list|(
operator|&
name|cric
argument_list|,
sizeof|sizeof
argument_list|(
name|cric
argument_list|)
argument_list|)
expr_stmt|;
name|cric
operator|.
name|cri_alg
operator|=
name|sav
operator|->
name|tdb_compalgxform
operator|->
name|type
expr_stmt|;
return|return
name|crypto_newsession
argument_list|(
operator|&
name|sav
operator|->
name|tdb_cryptoid
argument_list|,
operator|&
name|cric
argument_list|,
name|V_crypto_support
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipcomp_zeroize() used when IPCA is deleted  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_zeroize
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|crypto_freesession
argument_list|(
name|sav
operator|->
name|tdb_cryptoid
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tdb_cryptoid
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * ipcomp_input() gets called to uncompress an input packet  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crdc
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|ipcomp
modifier|*
name|ipcomp
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|hlen
init|=
name|IPCOMP_HLENGTH
decl_stmt|;
comment|/* 	 * Check that the next header of the IPComp is not IPComp again, before 	 * doing any real work.  Given it is not possible to do double 	 * compression it means someone is playing tricks on us. 	 */
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|skip
operator|+
name|hlen
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hdrops
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|DPRINTF
argument_list|(
operator|(
literal|"%s: m_pullup failed\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|+
name|skip
expr_stmt|;
name|ipcomp
operator|=
operator|(
expr|struct
name|ipcomp
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|ipcomp
operator|->
name|comp_nxt
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_pdrops
argument_list|)
expr_stmt|;
comment|/* XXX have our own stats? */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: recursive compression detected\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Get crypto descriptors */
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: no crypto descriptors\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Get IPsec-specific opaque pointer */
name|xd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xd
argument_list|)
argument_list|,
name|M_XDATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot allocate xform_data\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|crdc
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|crdc
operator|->
name|crd_skip
operator|=
name|skip
operator|+
name|hlen
expr_stmt|;
name|crdc
operator|->
name|crd_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|skip
operator|+
name|hlen
operator|)
expr_stmt|;
name|crdc
operator|->
name|crd_inject
operator|=
name|skip
expr_stmt|;
comment|/* Decompression operation */
name|crdc
operator|->
name|crd_alg
operator|=
name|sav
operator|->
name|tdb_compalgxform
operator|->
name|type
expr_stmt|;
comment|/* Crypto operation descriptor */
name|crp
operator|->
name|crp_ilen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|skip
operator|+
name|hlen
operator|)
expr_stmt|;
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|ipcomp_input_cb
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|caddr_t
operator|)
name|xd
expr_stmt|;
comment|/* These are passed as-is to the callback */
name|xd
operator|->
name|sav
operator|=
name|sav
expr_stmt|;
name|xd
operator|->
name|protoff
operator|=
name|protoff
expr_stmt|;
name|xd
operator|->
name|skip
operator|=
name|skip
expr_stmt|;
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|xd
operator|->
name|cryptoid
operator|=
name|sav
operator|->
name|tdb_cryptoid
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPComp input callback from the crypto driver.  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_input_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|int
name|hlen
init|=
name|IPCOMP_HLENGTH
decl_stmt|,
name|error
decl_stmt|,
name|clen
decl_stmt|;
name|int
name|skip
decl_stmt|,
name|protoff
decl_stmt|;
name|uint8_t
name|nproto
decl_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|xd
operator|=
operator|(
expr|struct
name|xform_data
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|sav
operator|=
name|xd
operator|->
name|sav
expr_stmt|;
name|skip
operator|=
name|xd
operator|->
name|skip
expr_stmt|;
name|protoff
operator|=
name|xd
operator|->
name|protoff
expr_stmt|;
name|cryptoid
operator|=
name|xd
operator|->
name|cryptoid
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|||
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"unexpected protocol family %u"
operator|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|)
argument_list|)
expr_stmt|;
comment|/* Check for crypto errors */
if|if
condition|(
name|crp
operator|->
name|crp_etype
condition|)
block|{
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
comment|/* Reset the session ID */
if|if
condition|(
name|ipsec_updateid
argument_list|(
name|sav
argument_list|,
operator|&
name|crp
operator|->
name|crp_sid
argument_list|,
operator|&
name|cryptoid
argument_list|)
operator|!=
literal|0
condition|)
name|crypto_freesession
argument_list|(
name|cryptoid
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|crp
operator|->
name|crp_sid
expr_stmt|;
return|return
operator|(
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
operator|)
return|;
block|}
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_noxform
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: crypto error %d\n"
operator|,
name|__func__
operator|,
name|crp
operator|->
name|crp_etype
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Shouldn't happen... */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: null mbuf returned from crypto\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hist
index|[
name|sav
operator|->
name|alg_comp
index|]
argument_list|)
expr_stmt|;
name|clen
operator|=
name|crp
operator|->
name|crp_olen
expr_stmt|;
comment|/* Length of data after processing */
comment|/* Release the crypto descriptors */
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
operator|,
name|xd
operator|=
name|NULL
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
operator|,
name|crp
operator|=
name|NULL
expr_stmt|;
comment|/* In case it's not done already, adjust the size of the mbuf chain */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|clen
operator|+
name|hlen
operator|+
name|skip
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|skip
operator|+
name|hlen
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hdrops
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|DPRINTF
argument_list|(
operator|(
literal|"%s: m_pullup failed\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/*XXX*/
goto|goto
name|bad
goto|;
block|}
comment|/* Keep the next protocol field */
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|+
name|skip
expr_stmt|;
name|nproto
operator|=
operator|(
operator|(
expr|struct
name|ipcomp
operator|*
operator|)
name|addr
operator|)
operator|->
name|comp_nxt
expr_stmt|;
comment|/* Remove the IPCOMP header */
name|error
operator|=
name|m_striphdr
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hdrops
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bad mbuf chain, IPCA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Restore the Next Protocol field */
name|m_copyback
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|nproto
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|error
operator|=
name|ipsec6_common_input_cb
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|error
operator|=
name|ipsec4_common_input_cb
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: Unexpected address family: %d saidx=%p"
argument_list|,
name|__func__
argument_list|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|saidx
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|bad
label|:
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|!=
name|NULL
condition|)
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * IPComp output routine, called by ipsec[46]_perform_request()  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_output
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
specifier|const
name|struct
name|comp_algo
modifier|*
name|ipcompx
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crdc
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ralen
decl_stmt|,
name|maxpacketsize
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|ipcompx
operator|=
name|sav
operator|->
name|tdb_compalgxform
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|ipcompx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null compression xform"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Do not touch the packet in case our payload to compress 	 * is lower than the minimal threshold of the compression 	 * alogrithm.  We will just send out the data uncompressed. 	 * See RFC 3173, 2.2. Non-Expansion Policy. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|ipcompx
operator|->
name|minlen
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_threshold
argument_list|)
expr_stmt|;
return|return
name|ipsec_process_done
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|sav
argument_list|,
name|idx
argument_list|)
return|;
block|}
name|ralen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
expr_stmt|;
comment|/* Raw payload length before comp. */
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_output
argument_list|)
expr_stmt|;
comment|/* Check for maximum packet size violations. */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|maxpacketsize
operator|=
name|IP_MAXPACKET
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|maxpacketsize
operator|=
name|IPV6_MAXPACKET
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_nopf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unknown/unsupported protocol family %d, "
literal|"IPCA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ralen
operator|+
name|skip
operator|+
name|IPCOMP_HLENGTH
operator|>
name|maxpacketsize
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_toobig
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: packet in IPCA %s/%08lx got too big "
literal|"(len %u, max len %u)\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|,
name|ralen
operator|+
name|skip
operator|+
name|IPCOMP_HLENGTH
operator|,
name|maxpacketsize
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Update the counters */
name|IPCOMPSTAT_ADD
argument_list|(
name|ipcomps_obytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_unshare
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hdrops
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot clone mbuf chain, IPCA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Ok now, we can pass to the crypto processing. */
comment|/* Get crypto descriptors */
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to acquire crypto descriptor\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|crdc
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
comment|/* Compression descriptor */
name|crdc
operator|->
name|crd_skip
operator|=
name|skip
expr_stmt|;
name|crdc
operator|->
name|crd_len
operator|=
name|ralen
expr_stmt|;
name|crdc
operator|->
name|crd_flags
operator|=
name|CRD_F_COMP
expr_stmt|;
name|crdc
operator|->
name|crd_inject
operator|=
name|skip
expr_stmt|;
comment|/* Compression operation */
name|crdc
operator|->
name|crd_alg
operator|=
name|ipcompx
operator|->
name|type
expr_stmt|;
comment|/* IPsec-specific opaque crypto info */
name|xd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xform_data
argument_list|)
argument_list|,
name|M_XDATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to allocate xform_data\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|xd
operator|->
name|sp
operator|=
name|sp
expr_stmt|;
name|xd
operator|->
name|sav
operator|=
name|sav
expr_stmt|;
name|xd
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
name|xd
operator|->
name|skip
operator|=
name|skip
expr_stmt|;
name|xd
operator|->
name|protoff
operator|=
name|protoff
expr_stmt|;
comment|/* Crypto operation descriptor */
name|crp
operator|->
name|crp_ilen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Total input length */
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|ipcomp_output_cb
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|caddr_t
operator|)
name|xd
expr_stmt|;
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|xd
operator|->
name|cryptoid
operator|=
name|sav
operator|->
name|tdb_cryptoid
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPComp output callback from the crypto driver.  */
end_comment

begin_function
specifier|static
name|int
name|ipcomp_output_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|skip
decl_stmt|,
name|protoff
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|xd
operator|=
operator|(
expr|struct
name|xform_data
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|idx
operator|=
name|xd
operator|->
name|idx
expr_stmt|;
name|sp
operator|=
name|xd
operator|->
name|sp
expr_stmt|;
name|sav
operator|=
name|xd
operator|->
name|sav
expr_stmt|;
name|skip
operator|=
name|xd
operator|->
name|skip
expr_stmt|;
name|protoff
operator|=
name|xd
operator|->
name|protoff
expr_stmt|;
name|cryptoid
operator|=
name|xd
operator|->
name|cryptoid
expr_stmt|;
comment|/* Check for crypto errors */
if|if
condition|(
name|crp
operator|->
name|crp_etype
condition|)
block|{
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
comment|/* Reset the session ID */
if|if
condition|(
name|ipsec_updateid
argument_list|(
name|sav
argument_list|,
operator|&
name|crp
operator|->
name|crp_sid
argument_list|,
operator|&
name|cryptoid
argument_list|)
operator|!=
literal|0
condition|)
name|crypto_freesession
argument_list|(
name|cryptoid
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|crp
operator|->
name|crp_sid
expr_stmt|;
return|return
operator|(
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
operator|)
return|;
block|}
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_noxform
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: crypto error %d\n"
operator|,
name|__func__
operator|,
name|crp
operator|->
name|crp_etype
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Shouldn't happen... */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bogus return buffer from crypto\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_hist
index|[
name|sav
operator|->
name|alg_comp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_ilen
operator|-
name|skip
operator|>
name|crp
operator|->
name|crp_olen
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mo
decl_stmt|;
name|struct
name|ipcomp
modifier|*
name|ipcomp
decl_stmt|;
name|int
name|roff
decl_stmt|;
name|uint8_t
name|prot
decl_stmt|;
comment|/* Compression helped, inject IPCOMP header. */
name|mo
operator|=
name|m_makespace
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
name|IPCOMP_HLENGTH
argument_list|,
operator|&
name|roff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
operator|==
name|NULL
condition|)
block|{
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_wrap
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: IPCOMP header inject failed "
literal|"for IPCA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ipcomp
operator|=
operator|(
expr|struct
name|ipcomp
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mo
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|roff
operator|)
expr_stmt|;
comment|/* Initialize the IPCOMP header */
comment|/* XXX alignment always correct? */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ipcomp
operator|->
name|comp_nxt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_p
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ipcomp
operator|->
name|comp_nxt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
operator|->
name|ip6_nxt
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|ipcomp
operator|->
name|comp_flags
operator|=
literal|0
expr_stmt|;
name|ipcomp
operator|->
name|comp_cpi
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix Next Protocol in IPv4/IPv6 header */
name|prot
operator|=
name|IPPROTO_IPCOMP
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|prot
argument_list|)
expr_stmt|;
comment|/* Adjust the length in the IP header */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_nopf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unknown/unsupported protocol "
literal|"family %d, IPCA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* Compression was useless, we have lost time. */
name|IPCOMPSTAT_INC
argument_list|(
name|ipcomps_uncompr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: compressions was useless %d - %d<= %d\n"
operator|,
name|__func__
operator|,
name|crp
operator|->
name|crp_ilen
operator|,
name|skip
operator|,
name|crp
operator|->
name|crp_olen
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX remember state to not compress the next couple 		 *     of packets, RFC 3173, 2.2. Non-Expansion Policy */
block|}
comment|/* Release the crypto descriptor */
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
comment|/* NB: m is reclaimed by ipsec_process_done. */
name|error
operator|=
name|ipsec_process_done
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|sav
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|encaptab
modifier|*
name|ipe4_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inetdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ipcomp4_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inetdomain
block|,
operator|.
name|pr_protocol
operator|=
literal|0
comment|/* IPPROTO_IPV[46] */
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_LASTHDR
block|,
operator|.
name|pr_input
operator|=
name|ipcomp_nonexp_input
block|,
operator|.
name|pr_output
operator|=
name|rip_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ipcomp4_nonexp_encapcheck
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|proto
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|union
name|sockaddr_union
name|src
decl_stmt|,
name|dst
decl_stmt|;
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|V_ipcomp_enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_IPV4
operator|&&
name|proto
operator|!=
name|IPPROTO_IPV6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin
operator|.
name|sin_len
operator|=
name|dst
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|dst
operator|.
name|sin
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
return|return
operator|(
name|ipcomp_encapcheck
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|encaptab
modifier|*
name|ipe6_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ipcomp6_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inet6domain
block|,
operator|.
name|pr_protocol
operator|=
literal|0
comment|/* IPPROTO_IPV[46] */
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_LASTHDR
block|,
operator|.
name|pr_input
operator|=
name|ipcomp_nonexp_input
block|,
operator|.
name|pr_output
operator|=
name|rip6_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip6_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip6_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ipcomp6_nonexp_encapcheck
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|proto
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|union
name|sockaddr_union
name|src
decl_stmt|,
name|dst
decl_stmt|;
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
if|if
condition|(
name|V_ipcomp_enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_IPV4
operator|&&
name|proto
operator|!=
name|IPPROTO_IPV6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
name|dst
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* XXX: sa6_recoverscope() */
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|ntohs
argument_list|(
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* XXX: sa6_recoverscope() */
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|ntohs
argument_list|(
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ipcomp_encapcheck
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|xformsw
name|ipcomp_xformsw
init|=
block|{
operator|.
name|xf_type
operator|=
name|XF_IPCOMP
block|,
operator|.
name|xf_name
operator|=
literal|"IPcomp"
block|,
operator|.
name|xf_init
operator|=
name|ipcomp_init
block|,
operator|.
name|xf_zeroize
operator|=
name|ipcomp_zeroize
block|,
operator|.
name|xf_input
operator|=
name|ipcomp_input
block|,
operator|.
name|xf_output
operator|=
name|ipcomp_output
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ipcomp_attach
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|ipe4_cookie
operator|=
name|encap_attach_func
argument_list|(
name|AF_INET
argument_list|,
operator|-
literal|1
argument_list|,
name|ipcomp4_nonexp_encapcheck
argument_list|,
operator|&
name|ipcomp4_protosw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|ipe6_cookie
operator|=
name|encap_attach_func
argument_list|(
name|AF_INET6
argument_list|,
operator|-
literal|1
argument_list|,
name|ipcomp6_nonexp_encapcheck
argument_list|,
operator|&
name|ipcomp6_protosw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xform_attach
argument_list|(
operator|&
name|ipcomp_xformsw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipcomp_detach
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|encap_detach
argument_list|(
name|ipe4_cookie
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|encap_detach
argument_list|(
name|ipe6_cookie
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xform_detach
argument_list|(
operator|&
name|ipcomp_xformsw
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|ipcomp_xform_init
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|ipcomp_attach
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|ipcomp_xform_uninit
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|ipcomp_detach
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

