begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: ip_ah.c,v 1.63 2001/06/26 06:18:58 angelos Exp $ */
end_comment

begin_comment
comment|/*-  * The authors of this code are John Ioannidis (ji@tla.org),  * Angelos D. Keromytis (kermit@csd.uch.gr) and  * Niels Provos (provos@physnet.uni-hamburg.de).  *  * The original version of this code was written by John Ioannidis  * for BSD/OS in Athens, Greece, in November 1995.  *  * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,  * by Angelos D. Keromytis.  *  * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis  * and Niels Provos.  *  * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.  *  * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,  * Angelos D. Keromytis and Niels Provos.  * Copyright (c) 1999 Niklas Hallqvist.  * Copyright (c) 2001 Angelos D. Keromytis.  *  * Permission to use, copy, and modify this software with or without fee  * is hereby granted, provided that this entire notice is included in  * all copies of any software which is or includes a copy or  * modification of this software.  * You may use this code under the GNU public license if you so wish. Please  * contribute changes back to the authors under this freer than GPL license  * so that we may further the use of strong encryption without limitations to  * all.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE  * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR  * PURPOSE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_ecn.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ah.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ah_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_ecn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_comment
comment|/*  * Return header size in bytes.  The old protocol did not support  * the replay counter; the new protocol always includes the counter.  */
end_comment

begin_define
define|#
directive|define
name|HDRSIZE
parameter_list|(
name|sav
parameter_list|)
define|\
value|(((sav)->flags& SADB_X_EXT_OLD) ? \ 		sizeof (struct ah) : sizeof (struct ah) + sizeof (u_int32_t))
end_define

begin_comment
comment|/*   * Return authenticator size in bytes, based on a field in the  * algorithm descriptor.  */
end_comment

begin_define
define|#
directive|define
name|AUTHSIZE
parameter_list|(
name|sav
parameter_list|)
value|((sav->flags& SADB_X_EXT_OLD) ? 16 :	\ 			 xform_ah_authsize((sav)->tdb_authalgxform))
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ah_enable
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* control flow of packets with AH */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ah_cleartos
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear ip_tos when doing AH calc */
end_comment

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|ahstat
argument_list|,
name|ahstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ahstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ahstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ah
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ah
argument_list|,
name|OID_AUTO
argument_list|,
name|ah_enable
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ah_enable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ah
argument_list|,
name|OID_AUTO
argument_list|,
name|ah_cleartos
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ah_cleartos
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_ah
argument_list|,
name|IPSECCTL_STATS
argument_list|,
name|stats
argument_list|,
expr|struct
name|ahstat
argument_list|,
name|ahstat
argument_list|,
literal|"AH statistics (struct ahstat, netipsec/ah_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ipseczeroes
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* larger than an ip6 extension hdr */
end_comment

begin_function_decl
specifier|static
name|int
name|ah_input_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ah_output_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|xform_ah_authsize
parameter_list|(
specifier|const
name|struct
name|auth_hash
modifier|*
name|esph
parameter_list|)
block|{
name|int
name|alen
decl_stmt|;
if|if
condition|(
name|esph
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|esph
operator|->
name|type
condition|)
block|{
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
case|case
name|CRYPTO_SHA2_384_HMAC
case|:
case|case
name|CRYPTO_SHA2_512_HMAC
case|:
name|alen
operator|=
name|esph
operator|->
name|hashsize
operator|/
literal|2
expr_stmt|;
comment|/* RFC4868 2.3 */
break|break;
case|case
name|CRYPTO_AES_128_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_192_NIST_GMAC
case|:
case|case
name|CRYPTO_AES_256_NIST_GMAC
case|:
name|alen
operator|=
name|esph
operator|->
name|hashsize
expr_stmt|;
break|break;
default|default:
name|alen
operator|=
name|AH_HMAC_HASHLEN
expr_stmt|;
break|break;
block|}
return|return
name|alen
return|;
block|}
end_function

begin_function
name|size_t
name|ah_hdrsiz
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|int
name|authsize
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|tdb_authalgxform
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null xform"
operator|)
argument_list|)
expr_stmt|;
comment|/*XXX not right for null algorithm--does it matter??*/
name|authsize
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|authsize
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|+
name|HDRSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default guess */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ah
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|+
literal|16
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*  * NB: public for use by esp_init.  */
end_comment

begin_function
name|int
name|ah_init0
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|struct
name|xformsw
modifier|*
name|xsp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cria
parameter_list|)
block|{
specifier|const
name|struct
name|auth_hash
modifier|*
name|thash
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|thash
operator|=
name|auth_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|thash
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unsupported authentication algorithm %u\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|alg_auth
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Verify the replay state block allocation is consistent with 	 * the protocol type.  We check here so we can make assumptions 	 * later during protocol processing. 	 */
comment|/* NB: replay state is setup elsewhere (sigh) */
if|if
condition|(
operator|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|==
literal|0
operator|)
operator|^
operator|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: replay state block inconsistency, "
literal|"%s algorithm %s replay state\n"
operator|,
name|__func__
operator|,
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_OLD
operator|)
condition|?
literal|"old"
else|:
literal|"new"
operator|,
name|sav
operator|->
name|replay
operator|==
name|NULL
condition|?
literal|"without"
else|:
literal|"with"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: no authentication key for %s algorithm\n"
operator|,
name|__func__
operator|,
name|thash
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|keylen
operator|=
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|!=
name|thash
operator|->
name|keysize
operator|&&
name|thash
operator|->
name|keysize
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: invalid keylength %d, algorithm %s requires "
literal|"keysize %d\n"
operator|,
name|__func__
operator|,
name|keylen
operator|,
name|thash
operator|->
name|name
operator|,
name|thash
operator|->
name|keysize
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sav
operator|->
name|tdb_xform
operator|=
name|xsp
expr_stmt|;
name|sav
operator|->
name|tdb_authalgxform
operator|=
name|thash
expr_stmt|;
comment|/* Initialize crypto session. */
name|bzero
argument_list|(
name|cria
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cria
argument_list|)
argument_list|)
expr_stmt|;
name|cria
operator|->
name|cri_alg
operator|=
name|sav
operator|->
name|tdb_authalgxform
operator|->
name|type
expr_stmt|;
name|cria
operator|->
name|cri_klen
operator|=
name|_KEYBITS
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
name|cria
operator|->
name|cri_key
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|key_data
expr_stmt|;
name|cria
operator|->
name|cri_mlen
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ah_init() is called when an SPI is being set up.  */
end_comment

begin_function
specifier|static
name|int
name|ah_init
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|struct
name|xformsw
modifier|*
name|xsp
parameter_list|)
block|{
name|struct
name|cryptoini
name|cria
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ah_init0
argument_list|(
name|sav
argument_list|,
name|xsp
argument_list|,
operator|&
name|cria
argument_list|)
expr_stmt|;
return|return
name|error
condition|?
name|error
else|:
name|crypto_newsession
argument_list|(
operator|&
name|sav
operator|->
name|tdb_cryptoid
argument_list|,
operator|&
name|cria
argument_list|,
name|V_crypto_support
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Paranoia.  *  * NB: public for use by esp_zeroize (XXX).  */
end_comment

begin_function
name|int
name|ah_zeroize
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
condition|)
name|bzero
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|crypto_freesession
argument_list|(
name|sav
operator|->
name|tdb_cryptoid
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tdb_cryptoid
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|tdb_authalgxform
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|tdb_xform
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Massage IPv4/IPv6 headers for AH processing.  */
end_comment

begin_function
specifier|static
name|int
name|ah_massage_headers
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|alg
parameter_list|,
name|int
name|out
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|off
decl_stmt|,
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_ext
modifier|*
name|ip6e
decl_stmt|;
name|struct
name|ip6_hdr
name|ip6
decl_stmt|;
name|int
name|alloc
decl_stmt|,
name|len
decl_stmt|,
name|ad
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
switch|switch
condition|(
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* 		 * This is the least painful way of dealing with IPv4 header 		 * and option processing -- just make sure they're in 		 * contiguous memory. 		 */
operator|*
name|m0
operator|=
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: m_pullup failed\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Fix the IP header */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_ah_cleartos
condition|)
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alg
operator|==
name|CRYPTO_MD5_KPDK
operator|||
name|alg
operator|==
name|CRYPTO_SHA1_KPDK
condition|)
name|ip
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
comment|/* IPv4 option processing */
for|for
control|(
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
init|;
name|off
operator|<
name|skip
condition|;
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|off
index|]
operator|==
name|IPOPT_EOL
operator|||
name|ptr
index|[
name|off
index|]
operator|==
name|IPOPT_NOP
operator|||
name|off
operator|+
literal|1
operator|<
name|skip
condition|)
empty_stmt|;
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: illegal IPv4 option length for "
literal|"option %d\n"
operator|,
name|__func__
operator|,
name|ptr
index|[
name|off
index|]
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|ptr
index|[
name|off
index|]
condition|)
block|{
case|case
name|IPOPT_EOL
case|:
name|off
operator|=
name|skip
expr_stmt|;
comment|/* End the loop. */
break|break;
case|case
name|IPOPT_NOP
case|:
name|off
operator|++
expr_stmt|;
break|break;
case|case
name|IPOPT_SECURITY
case|:
comment|/* 0x82 */
case|case
literal|0x85
case|:
comment|/* Extended security. */
case|case
literal|0x86
case|:
comment|/* Commercial security. */
case|case
literal|0x94
case|:
comment|/* Router alert */
case|case
literal|0x95
case|:
comment|/* RFC1770 */
comment|/* Sanity check for option length. */
if|if
condition|(
name|ptr
index|[
name|off
operator|+
literal|1
index|]
operator|<
literal|2
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: illegal IPv4 option "
literal|"length for option %d\n"
operator|,
name|__func__
operator|,
name|ptr
index|[
name|off
index|]
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|off
operator|+=
name|ptr
index|[
name|off
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|IPOPT_LSRR
case|:
case|case
name|IPOPT_SSRR
case|:
comment|/* Sanity check for option length. */
if|if
condition|(
name|ptr
index|[
name|off
operator|+
literal|1
index|]
operator|<
literal|2
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: illegal IPv4 option "
literal|"length for option %d\n"
operator|,
name|__func__
operator|,
name|ptr
index|[
name|off
index|]
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 				 * On output, if we have either of the 				 * source routing options, we should 				 * swap the destination address of the 				 * IP header with the last address 				 * specified in the option, as that is 				 * what the destination's IP header 				 * will look like. 				 */
if|if
condition|(
name|out
condition|)
name|bcopy
argument_list|(
name|ptr
operator|+
name|off
operator|+
name|ptr
index|[
name|off
operator|+
literal|1
index|]
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|&
operator|(
name|ip
operator|->
name|ip_dst
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through */
default|default:
comment|/* Sanity check for option length. */
if|if
condition|(
name|ptr
index|[
name|off
operator|+
literal|1
index|]
operator|<
literal|2
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: illegal IPv4 option "
literal|"length for option %d\n"
operator|,
name|__func__
operator|,
name|ptr
index|[
name|off
index|]
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Zeroize all other options. */
name|count
operator|=
name|ptr
index|[
name|off
operator|+
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|ipseczeroes
argument_list|,
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|off
operator|+=
name|count
expr_stmt|;
break|break;
block|}
comment|/* Sanity check. */
if|if
condition|(
name|off
operator|>
name|skip
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: malformed IPv4 options header\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* Ugly... */
comment|/* Copy and "cook" the IPv6 header. */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
argument_list|)
expr_stmt|;
comment|/* We don't do IPv6 Jumbograms. */
if|if
condition|(
name|ip6
operator|.
name|ip6_plen
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unsupported IPv6 jumbogram\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EMSGSIZE
return|;
block|}
name|ip6
operator|.
name|ip6_flow
operator|=
literal|0
expr_stmt|;
name|ip6
operator|.
name|ip6_hlim
operator|=
literal|0
expr_stmt|;
name|ip6
operator|.
name|ip6_vfc
operator|&=
operator|~
name|IPV6_VERSION_MASK
expr_stmt|;
name|ip6
operator|.
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
comment|/* Scoped address handling. */
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|.
name|ip6_src
argument_list|)
condition|)
name|ip6
operator|.
name|ip6_src
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|ip6
operator|.
name|ip6_dst
argument_list|)
condition|)
name|ip6
operator|.
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Done with IPv6 header. */
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6
argument_list|)
expr_stmt|;
comment|/* Let's deal with the remaining headers (if any). */
if|if
condition|(
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|skip
condition|)
block|{
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|M_XDATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to allocate memory"
literal|"for IPv6 headers\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* 				 * Copy all the protocol headers after 				 * the IPv6 header. 				 */
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|alloc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* No need to allocate memory. */
name|ptr
operator|=
name|mtod
argument_list|(
argument|m
argument_list|,
argument|unsigned char *
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|alloc
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
break|break;
name|off
operator|=
name|ip6
operator|.
name|ip6_nxt
operator|&
literal|0xff
expr_stmt|;
comment|/* Next header type. */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|;
control|)
switch|switch
condition|(
name|off
condition|)
block|{
case|case
name|IPPROTO_HOPOPTS
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|ptr
operator|+
name|len
operator|)
expr_stmt|;
comment|/* 				 * Process the mutable/immutable 				 * options -- borrows heavily from the 				 * KAME code. 				 */
for|for
control|(
name|count
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_ext
argument_list|)
init|;
name|count
operator|<
name|len
operator|+
operator|(
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|count
index|]
operator|==
name|IP6OPT_PAD1
condition|)
block|{
name|count
operator|++
expr_stmt|;
continue|continue;
comment|/* Skip padding. */
block|}
comment|/* Sanity check. */
if|if
condition|(
name|count
operator|>
name|len
operator|+
operator|(
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Free, if we allocated. */
if|if
condition|(
name|alloc
condition|)
name|free
argument_list|(
name|ptr
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ad
operator|=
name|ptr
index|[
name|count
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If mutable option, zeroize. */
if|if
condition|(
name|ptr
index|[
name|count
index|]
operator|&
name|IP6OPT_MUTABLE
condition|)
name|bcopy
argument_list|(
name|ipseczeroes
argument_list|,
name|ptr
operator|+
name|count
argument_list|,
name|ptr
index|[
name|count
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|count
operator|+=
name|ad
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|count
operator|>
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Free, if we allocated. */
if|if
condition|(
name|alloc
condition|)
name|free
argument_list|(
name|ptr
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* Advance. */
name|len
operator|+=
operator|(
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|off
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
comment|/* 				 * Always include routing headers in 				 * computation. 				 */
name|ip6e
operator|=
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
operator|(
name|ptr
operator|+
name|len
operator|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|ip6e
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|off
operator|=
name|ip6e
operator|->
name|ip6e_nxt
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unexpected IPv6 header type %d"
operator|,
name|__func__
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc
condition|)
name|free
argument_list|(
name|ptr
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Copyback and free, if we allocated. */
if|if
condition|(
name|alloc
condition|)
block|{
name|m_copyback
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|skip
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ah_input() gets called to verify that an input packet  * passes authentication.  */
end_comment

begin_function
specifier|static
name|int
name|ah_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|struct
name|auth_hash
modifier|*
name|ahx
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crda
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|newah
modifier|*
name|ah
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|int
name|hl
decl_stmt|,
name|rplen
decl_stmt|,
name|authsize
decl_stmt|,
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null authentication key"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|tdb_authalgxform
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null authentication xform"
operator|)
argument_list|)
expr_stmt|;
comment|/* Figure out header size. */
name|rplen
operator|=
name|HDRSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* XXX don't pullup, just copy header */
name|IP6_EXTHDR_GET
argument_list|(
name|ah
argument_list|,
expr|struct
name|newah
operator|*
argument_list|,
name|m
argument_list|,
name|skip
argument_list|,
name|rplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ah_input: cannot pullup header\n"
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_hdrops
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Check replay window, if applicable. */
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
operator|&&
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|!=
literal|0
operator|&&
name|ipsec_chkreplay
argument_list|(
name|ntohl
argument_list|(
name|ah
operator|->
name|ah_seq
argument_list|)
argument_list|,
name|sav
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_replay
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: packet replay failure: %s\n"
operator|,
name|__func__
operator|,
name|ipsec_sa2str
argument_list|(
name|sav
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cryptoid
operator|=
name|sav
operator|->
name|tdb_cryptoid
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* Verify AH header length. */
name|hl
operator|=
name|ah
operator|->
name|ah_len
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|ahx
operator|=
name|sav
operator|->
name|tdb_authalgxform
expr_stmt|;
name|authsize
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|!=
name|authsize
operator|+
name|rplen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ah
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bad authenticator length %u (expecting %lu)"
literal|" for packet in SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|hl
operator|,
call|(
name|u_long
call|)
argument_list|(
name|authsize
operator|+
name|rplen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ah
argument_list|)
argument_list|)
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_badauthl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|AHSTAT_ADD
argument_list|(
name|ahs_ibytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
operator|-
name|hl
argument_list|)
expr_stmt|;
comment|/* Get crypto descriptors. */
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to acquire crypto descriptor\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|crda
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|crda
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null crypto descriptor"
operator|)
argument_list|)
expr_stmt|;
name|crda
operator|->
name|crd_skip
operator|=
literal|0
expr_stmt|;
name|crda
operator|->
name|crd_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|crda
operator|->
name|crd_inject
operator|=
name|skip
operator|+
name|rplen
expr_stmt|;
comment|/* Authentication operation. */
name|crda
operator|->
name|crd_alg
operator|=
name|ahx
operator|->
name|type
expr_stmt|;
name|crda
operator|->
name|crd_klen
operator|=
name|_KEYBITS
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
name|crda
operator|->
name|crd_key
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|key_data
expr_stmt|;
comment|/* Allocate IPsec-specific opaque crypto info. */
name|xd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xd
argument_list|)
operator|+
name|skip
operator|+
name|rplen
operator|+
name|authsize
argument_list|,
name|M_XDATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to allocate xform_data\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Save the authenticator, the skipped portion of the packet, 	 * and the AH header. 	 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
operator|+
name|rplen
operator|+
name|authsize
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zeroize the authenticator on the packet. */
name|m_copyback
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|rplen
argument_list|,
name|authsize
argument_list|,
name|ipseczeroes
argument_list|)
expr_stmt|;
comment|/* "Massage" the packet headers for crypto processing. */
name|error
operator|=
name|ah_massage_headers
argument_list|(
operator|&
name|m
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|skip
argument_list|,
name|ahx
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: mbuf is free'd by ah_massage_headers */
name|AHSTAT_INC
argument_list|(
name|ahs_hdrops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Crypto operation descriptor. */
name|crp
operator|->
name|crp_ilen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Total input length. */
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|ah_input_cb
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|cryptoid
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|caddr_t
operator|)
name|xd
expr_stmt|;
comment|/* These are passed as-is to the callback. */
name|xd
operator|->
name|sav
operator|=
name|sav
expr_stmt|;
name|xd
operator|->
name|nxt
operator|=
name|ah
operator|->
name|ah_nxt
expr_stmt|;
name|xd
operator|->
name|protoff
operator|=
name|protoff
expr_stmt|;
name|xd
operator|->
name|skip
operator|=
name|skip
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|cryptoid
expr_stmt|;
return|return
operator|(
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * AH input callback from the crypto driver.  */
end_comment

begin_function
specifier|static
name|int
name|ah_input_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
name|unsigned
name|char
name|calc
index|[
name|AH_ALEN_MAX
index|]
decl_stmt|;
specifier|const
name|struct
name|auth_hash
modifier|*
name|ahx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|int
name|authsize
decl_stmt|,
name|rplen
decl_stmt|,
name|error
decl_stmt|,
name|skip
decl_stmt|,
name|protoff
decl_stmt|;
name|uint8_t
name|nxt
decl_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|xd
operator|=
operator|(
expr|struct
name|xform_data
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|sav
operator|=
name|xd
operator|->
name|sav
expr_stmt|;
name|skip
operator|=
name|xd
operator|->
name|skip
expr_stmt|;
name|nxt
operator|=
name|xd
operator|->
name|nxt
expr_stmt|;
name|protoff
operator|=
name|xd
operator|->
name|protoff
expr_stmt|;
name|cryptoid
operator|=
name|xd
operator|->
name|cryptoid
expr_stmt|;
name|saidx
operator|=
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|||
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"unexpected protocol family %u"
operator|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|)
argument_list|)
expr_stmt|;
name|ahx
operator|=
name|sav
operator|->
name|tdb_authalgxform
expr_stmt|;
comment|/* Check for crypto errors. */
if|if
condition|(
name|crp
operator|->
name|crp_etype
condition|)
block|{
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
comment|/* Reset the session ID */
if|if
condition|(
name|ipsec_updateid
argument_list|(
name|sav
argument_list|,
operator|&
name|crp
operator|->
name|crp_sid
argument_list|,
operator|&
name|cryptoid
argument_list|)
operator|!=
literal|0
condition|)
name|crypto_freesession
argument_list|(
name|cryptoid
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|crp
operator|->
name|crp_sid
expr_stmt|;
return|return
operator|(
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
operator|)
return|;
block|}
name|AHSTAT_INC
argument_list|(
name|ahs_noxform
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: crypto error %d\n"
operator|,
name|__func__
operator|,
name|crp
operator|->
name|crp_etype
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|AHSTAT_INC
argument_list|(
name|ahs_hist
index|[
name|sav
operator|->
name|alg_auth
index|]
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
comment|/* No longer needed. */
name|crp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Shouldn't happen... */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bogus returned buffer from crypto\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Figure out header size. */
name|rplen
operator|=
name|HDRSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|authsize
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* Copy authenticator off the packet. */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|rplen
argument_list|,
name|authsize
argument_list|,
name|calc
argument_list|)
expr_stmt|;
comment|/* Verify authenticator. */
name|ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|timingsafe_bcmp
argument_list|(
name|ptr
operator|+
name|skip
operator|+
name|rplen
argument_list|,
name|calc
argument_list|,
name|authsize
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: authentication hash mismatch for packet "
literal|"in SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_badauth
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Fix the Next Protocol field. */
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ptr
operator|)
index|[
name|protoff
index|]
operator|=
name|nxt
expr_stmt|;
comment|/* Copyback the saved (uncooked) network headers. */
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
operator|,
name|xd
operator|=
name|NULL
expr_stmt|;
comment|/* No longer needed */
comment|/* 	 * Header is now authenticated. 	 */
name|m
operator|->
name|m_flags
operator||=
name|M_AUTHIPHDR
operator||
name|M_AUTHIPDGM
expr_stmt|;
comment|/* 	 * Update replay sequence number, if appropriate. 	 */
if|if
condition|(
name|sav
operator|->
name|replay
condition|)
block|{
name|u_int32_t
name|seq
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|offsetof
argument_list|(
expr|struct
name|newah
argument_list|,
name|ah_seq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|seq
argument_list|)
expr_stmt|;
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipsec_updatereplay
argument_list|(
name|ntohl
argument_list|(
name|seq
argument_list|)
argument_list|,
name|sav
argument_list|)
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_replay
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the AH header and authenticator from the mbuf. 	 */
name|error
operator|=
name|m_striphdr
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
name|rplen
operator|+
name|authsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: mangled mbuf chain for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|saidx
operator|->
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
switch|switch
condition|(
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|error
operator|=
name|ipsec6_common_input_cb
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|error
operator|=
name|ipsec4_common_input_cb
argument_list|(
name|m
argument_list|,
name|sav
argument_list|,
name|skip
argument_list|,
name|protoff
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: Unexpected address family: %d saidx=%p"
argument_list|,
name|__func__
argument_list|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|saidx
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|bad
label|:
if|if
condition|(
name|sav
condition|)
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|!=
name|NULL
condition|)
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * AH output routine, called by ipsec[46]_perform_request().  */
end_comment

begin_function
specifier|static
name|int
name|ah_output
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|int
name|skip
parameter_list|,
name|int
name|protoff
parameter_list|)
block|{
name|char
name|buf
index|[
name|IPSEC_ADDRSTRLEN
index|]
decl_stmt|;
specifier|const
name|struct
name|auth_hash
modifier|*
name|ahx
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crda
decl_stmt|;
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mi
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|newah
modifier|*
name|ah
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|uint16_t
name|iplen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rplen
decl_stmt|,
name|authsize
decl_stmt|,
name|maxpacketsize
decl_stmt|,
name|roff
decl_stmt|;
name|uint8_t
name|prot
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA"
operator|)
argument_list|)
expr_stmt|;
name|ahx
operator|=
name|sav
operator|->
name|tdb_authalgxform
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|ahx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null authentication xform"
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_output
argument_list|)
expr_stmt|;
comment|/* Figure out header size. */
name|rplen
operator|=
name|HDRSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* Check for maximum packet size violations. */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|maxpacketsize
operator|=
name|IP_MAXPACKET
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|maxpacketsize
operator|=
name|IPV6_MAXPACKET
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unknown/unsupported protocol family %u, "
literal|"SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_nopf
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|authsize
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|rplen
operator|+
name|authsize
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|maxpacketsize
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: packet in SA %s/%08lx got too big "
literal|"(len %u, max len %u)\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|,
name|rplen
operator|+
name|authsize
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|maxpacketsize
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_toobig
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Update the counters. */
name|AHSTAT_ADD
argument_list|(
name|ahs_obytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|skip
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_unshare
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: cannot clone mbuf chain, SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_hdrops
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Inject AH header. */
name|mi
operator|=
name|m_makespace
argument_list|(
name|m
argument_list|,
name|skip
argument_list|,
name|rplen
operator|+
name|authsize
argument_list|,
operator|&
name|roff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to inject %u byte AH header for SA "
literal|"%s/%08lx\n"
operator|,
name|__func__
operator|,
name|rplen
operator|+
name|authsize
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_hdrops
argument_list|)
expr_stmt|;
comment|/*XXX differs from openbsd */
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * The AH header is guaranteed by m_makespace() to be in 	 * contiguous memory, at roff bytes offset into the returned mbuf. 	 */
name|ah
operator|=
operator|(
expr|struct
name|newah
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mi
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|roff
operator|)
expr_stmt|;
comment|/* Initialize the AH header. */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ah
operator|->
name|ah_nxt
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_len
operator|=
operator|(
name|rplen
operator|+
name|authsize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ah
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_reserve
operator|=
literal|0
expr_stmt|;
name|ah
operator|->
name|ah_spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
comment|/* Zeroize authenticator. */
name|m_copyback
argument_list|(
name|m
argument_list|,
name|skip
operator|+
name|rplen
argument_list|,
name|authsize
argument_list|,
name|ipseczeroes
argument_list|)
expr_stmt|;
comment|/* Insert packet replay counter, as requested.  */
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|count
operator|==
operator|~
literal|0
operator|&&
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_CYCSEQ
operator|)
operator|==
literal|0
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: replay counter wrapped for SA %s/%08lx\n"
operator|,
name|__func__
operator|,
name|ipsec_address
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_wrap
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|REGRESSION
comment|/* Emulate replay attack when ipsec_replay is TRUE. */
if|if
condition|(
operator|!
name|V_ipsec_replay
condition|)
endif|#
directive|endif
name|sav
operator|->
name|replay
operator|->
name|count
operator|++
expr_stmt|;
name|ah
operator|->
name|ah_seq
operator|=
name|htonl
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|cryptoid
operator|=
name|sav
operator|->
name|tdb_cryptoid
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* Get crypto descriptors. */
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to acquire crypto descriptors\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|crda
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|crda
operator|->
name|crd_skip
operator|=
literal|0
expr_stmt|;
name|crda
operator|->
name|crd_inject
operator|=
name|skip
operator|+
name|rplen
expr_stmt|;
name|crda
operator|->
name|crd_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Authentication operation. */
name|crda
operator|->
name|crd_alg
operator|=
name|ahx
operator|->
name|type
expr_stmt|;
name|crda
operator|->
name|crd_key
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|key_data
expr_stmt|;
name|crda
operator|->
name|crd_klen
operator|=
name|_KEYBITS
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
comment|/* Allocate IPsec-specific opaque crypto info. */
name|xd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xform_data
argument_list|)
operator|+
name|skip
argument_list|,
name|M_XDATA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|==
name|NULL
condition|)
block|{
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: failed to allocate xform_data\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Save the skipped portion of the packet. */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fix IP header length on the header used for 	 * authentication. We don't need to fix the original 	 * header length as it will be fixed by our caller. 	 */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|bcopy
argument_list|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_len
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iplen
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|iplen
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|iplen
argument_list|)
operator|+
name|rplen
operator|+
name|authsize
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_len
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iplen
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|bcopy
argument_list|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_plen
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iplen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|iplen
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|iplen
argument_list|)
operator|+
name|rplen
operator|+
name|authsize
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_plen
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iplen
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* Fix the Next Header field in saved header. */
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|xd
operator|+
literal|1
operator|)
operator|)
index|[
name|protoff
index|]
operator|=
name|IPPROTO_AH
expr_stmt|;
comment|/* Update the Next Protocol field in the IP header. */
name|prot
operator|=
name|IPPROTO_AH
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|protoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|prot
argument_list|)
expr_stmt|;
comment|/* "Massage" the packet headers for crypto processing. */
name|error
operator|=
name|ah_massage_headers
argument_list|(
operator|&
name|m
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|skip
argument_list|,
name|ahx
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* mbuf was free'd by ah_massage_headers. */
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Crypto operation descriptor. */
name|crp
operator|->
name|crp_ilen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Total input length. */
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|ah_output_cb
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|cryptoid
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|caddr_t
operator|)
name|xd
expr_stmt|;
comment|/* These are passed as-is to the callback. */
name|xd
operator|->
name|sp
operator|=
name|sp
expr_stmt|;
name|xd
operator|->
name|sav
operator|=
name|sav
expr_stmt|;
name|xd
operator|->
name|skip
operator|=
name|skip
expr_stmt|;
name|xd
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|cryptoid
expr_stmt|;
return|return
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * AH output callback from the crypto driver.  */
end_comment

begin_function
specifier|static
name|int
name|ah_output_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|xform_data
modifier|*
name|xd
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|cryptoid
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|int
name|skip
decl_stmt|,
name|error
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|xd
operator|=
operator|(
expr|struct
name|xform_data
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|sp
operator|=
name|xd
operator|->
name|sp
expr_stmt|;
name|sav
operator|=
name|xd
operator|->
name|sav
expr_stmt|;
name|skip
operator|=
name|xd
operator|->
name|skip
expr_stmt|;
name|idx
operator|=
name|xd
operator|->
name|idx
expr_stmt|;
name|cryptoid
operator|=
name|xd
operator|->
name|cryptoid
expr_stmt|;
name|ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|xd
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for crypto errors. */
if|if
condition|(
name|crp
operator|->
name|crp_etype
condition|)
block|{
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
comment|/* Reset the session ID */
if|if
condition|(
name|ipsec_updateid
argument_list|(
name|sav
argument_list|,
operator|&
name|crp
operator|->
name|crp_sid
argument_list|,
operator|&
name|cryptoid
argument_list|)
operator|!=
literal|0
condition|)
name|crypto_freesession
argument_list|(
name|cryptoid
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cryptoid
operator|=
name|crp
operator|->
name|crp_sid
expr_stmt|;
return|return
operator|(
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
operator|)
return|;
block|}
name|AHSTAT_INC
argument_list|(
name|ahs_noxform
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: crypto error %d\n"
operator|,
name|__func__
operator|,
name|crp
operator|->
name|crp_etype
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Shouldn't happen... */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|AHSTAT_INC
argument_list|(
name|ahs_crypto
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bogus returned buffer from crypto\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Copy original headers (with the new protocol number) back 	 * in place. 	 */
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|skip
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|AHSTAT_INC
argument_list|(
name|ahs_hist
index|[
name|sav
operator|->
name|alg_auth
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGRESSION
comment|/* Emulate man-in-the-middle attack when ipsec_integrity is TRUE. */
if|if
condition|(
name|V_ipsec_integrity
condition|)
block|{
name|int
name|alen
decl_stmt|;
comment|/* 		 * Corrupt HMAC if we want to test integrity verification of 		 * the other side. 		 */
name|alen
operator|=
name|AUTHSIZE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|alen
argument_list|,
name|alen
argument_list|,
name|ipseczeroes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NB: m is reclaimed by ipsec_process_done. */
name|error
operator|=
name|ipsec_process_done
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|sav
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|xd
argument_list|,
name|M_XDATA
argument_list|)
expr_stmt|;
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|xformsw
name|ah_xformsw
init|=
block|{
operator|.
name|xf_type
operator|=
name|XF_AH
block|,
operator|.
name|xf_name
operator|=
literal|"IPsec AH"
block|,
operator|.
name|xf_init
operator|=
name|ah_init
block|,
operator|.
name|xf_zeroize
operator|=
name|ah_zeroize
block|,
operator|.
name|xf_input
operator|=
name|ah_input
block|,
operator|.
name|xf_output
operator|=
name|ah_output
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|ah_xform_init
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|xform_attach
argument_list|,
operator|&
name|ah_xformsw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|ah_xform_uninit
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|xform_detach
argument_list|,
operator|&
name|ah_xformsw
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

