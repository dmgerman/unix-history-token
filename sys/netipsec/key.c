begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: key.c,v 1.191 2001/06/27 10:46:49 sakane Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This code is referd to RFC 2367  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<net/pfkeyv2.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keysock.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/* randomness */
end_comment

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_define
define|#
directive|define
name|FULLMASK
value|0xff
end_define

begin_define
define|#
directive|define
name|_BITS
parameter_list|(
name|bytes
parameter_list|)
value|((bytes)<< 3)
end_define

begin_comment
comment|/*  * Note on SA reference counting:  * - SAs that are not in DEAD state will have (total external reference + 1)  *   following value in reference count field.  they cannot be freed and are  *   referenced from SA header.  * - SAs that are in DEAD state will have (total external reference)  *   in reference count field.  they are ready to be freed.  reference from  *   SA header will be removed in key_delsav(), when the reference count  *   field hits 0 (= no external reference other than from SA header.  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_debug_level
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_spi_trycnt
argument_list|)
operator|=
literal|1000
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_spi_trycnt
value|VNET(key_spi_trycnt)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_spi_minval
argument_list|)
operator|=
literal|0x100
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_spi_minval
value|VNET(key_spi_minval)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_spi_maxval
argument_list|)
operator|=
literal|0x0fffffff
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|V_key_spi_maxval
value|VNET(key_spi_maxval)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|policy_id
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_policy_id
value|VNET(policy_id)
end_define

begin_comment
comment|/*interval to initialize randseed,1(m)*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_int_random
argument_list|)
operator|=
literal|60
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_int_random
value|VNET(key_int_random)
end_define

begin_comment
comment|/* interval to expire acquiring, 30(s)*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_larval_lifetime
argument_list|)
operator|=
literal|30
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_larval_lifetime
value|VNET(key_larval_lifetime)
end_define

begin_comment
comment|/* counter for blocking SADB_ACQUIRE.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_blockacq_count
argument_list|)
operator|=
literal|10
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_blockacq_count
value|VNET(key_blockacq_count)
end_define

begin_comment
comment|/* lifetime for blocking SADB_ACQUIRE.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_blockacq_lifetime
argument_list|)
operator|=
literal|20
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_blockacq_lifetime
value|VNET(key_blockacq_lifetime)
end_define

begin_comment
comment|/* preferred old sa rather than new sa.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_preferred_oldsa
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_preferred_oldsa
value|VNET(key_preferred_oldsa)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|acq_seq
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_acq_seq
value|VNET(acq_seq)
end_define

begin_comment
comment|/* SPD */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_sptree
argument_list|,
name|secpolicy
argument_list|)
argument_list|,
name|sptree
index|[
name|IPSEC_DIR_MAX
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_sptree
value|VNET(sptree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sptree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPTREE_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&sptree_lock, "sptree", \ 		"fast ipsec security policy database", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SPTREE_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_LOCK
parameter_list|()
value|mtx_lock(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_UNLOCK
parameter_list|()
value|mtx_unlock(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&sptree_lock, MA_OWNED)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_sahtree
argument_list|,
name|secashead
argument_list|)
argument_list|,
name|sahtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SAD */
end_comment

begin_define
define|#
directive|define
name|V_sahtree
value|VNET(sahtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sahtree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SAHTREE_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&sahtree_lock, "sahtree", \ 		"fast ipsec security association database", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SAHTREE_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_LOCK
parameter_list|()
value|mtx_lock(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_UNLOCK
parameter_list|()
value|mtx_unlock(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&sahtree_lock, MA_OWNED)
end_define

begin_comment
comment|/* registed list */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_regtree
argument_list|,
name|secreg
argument_list|)
argument_list|,
name|regtree
index|[
name|SADB_SATYPE_MAX
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_regtree
value|VNET(regtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|regtree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REGTREE_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&regtree_lock, "regtree", "fast ipsec regtree", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK
parameter_list|()
value|mtx_lock(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_UNLOCK
parameter_list|()
value|mtx_unlock(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&regtree_lock, MA_OWNED)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_acqtree
argument_list|,
name|secacq
argument_list|)
argument_list|,
name|acqtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* acquiring list */
end_comment

begin_define
define|#
directive|define
name|V_acqtree
value|VNET(acqtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|acq_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACQ_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&acq_lock, "acqtree", "fast ipsec acquire list", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK
parameter_list|()
value|mtx_lock(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_UNLOCK
parameter_list|()
value|mtx_unlock(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&acq_lock, MA_OWNED)
end_define

begin_comment
comment|/* SP acquiring list */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_spacqtree
argument_list|,
name|secspacq
argument_list|)
argument_list|,
name|spacqtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_spacqtree
value|VNET(spacqtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|spacq_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPACQ_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&spacq_lock, "spacqtree", \ 		"fast ipsec security policy acquire list", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK
parameter_list|()
value|mtx_lock(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_UNLOCK
parameter_list|()
value|mtx_unlock(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&spacq_lock, MA_OWNED)
end_define

begin_comment
comment|/* search order for SAs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|saorder_state_valid_prefer_old
index|[]
init|=
block|{
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_MATURE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|saorder_state_valid_prefer_new
index|[]
init|=
block|{
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|saorder_state_alive
index|[]
init|=
block|{
comment|/* except DEAD */
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|saorder_state_any
index|[]
init|=
block|{
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|,
name|SADB_SASTATE_DEAD
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|minsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sens
argument_list|)
block|,
comment|/* SADB_EXT_SENSITIVITY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
block|,
comment|/* SADB_EXT_PROPOSAL */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_TYPE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_SPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_DPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_OAI */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_OAR */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_frag
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_FRAG */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|maxsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_DST */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
literal|0
block|,
comment|/* SADB_EXT_KEY_AUTH */
literal|0
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_DST */
literal|0
block|,
comment|/* SADB_EXT_SENSITIVITY */
literal|0
block|,
comment|/* SADB_EXT_PROPOSAL */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
literal|0
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_TYPE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_SPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_DPORT */
literal|0
block|,
comment|/* SADB_X_EXT_NAT_T_OAI */
literal|0
block|,
comment|/* SADB_X_EXT_NAT_T_OAR */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_frag
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_FRAG */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_esp_keymin
argument_list|)
operator|=
literal|256
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ipsec_esp_keymin
value|VNET(ipsec_esp_keymin)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_esp_auth
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ipsec_esp_auth
value|VNET(ipsec_esp_auth)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_ah_keymin
argument_list|)
operator|=
literal|128
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ipsec_ah_keymin
value|VNET(ipsec_ah_keymin)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_DECL
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_key
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_DEBUG_LEVEL
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_debug_level
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max count of trial for the decision of spi value */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_TRY
argument_list|,
name|spi_trycnt
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_trycnt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MIN_VALUE
argument_list|,
name|spi_minval
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_minval
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximun spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MAX_VALUE
argument_list|,
name|spi_maxval
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_maxval
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interval to initialize randseed */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_RANDOM_INT
argument_list|,
name|int_random
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_int_random
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for larval SA */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_LARVAL_LIFETIME
argument_list|,
name|larval_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_larval_lifetime
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* counter for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_COUNT
argument_list|,
name|blockacq_count
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_blockacq_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_LIFETIME
argument_list|,
name|blockacq_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_blockacq_lifetime
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ESP auth */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_AUTH
argument_list|,
name|esp_auth
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_esp_auth
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum ESP key length */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_KEYMIN
argument_list|,
name|esp_keymin
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_esp_keymin
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum AH key length */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_AH_KEYMIN
argument_list|,
name|ah_keymin
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_ah_keymin
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* perfered old SA rather than new SA */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_PREFERED_OLDSA
argument_list|,
name|preferred_oldsa
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_preferred_oldsa
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__LIST_CHAINED
parameter_list|(
name|elm
parameter_list|)
define|\
value|(!((elm)->chain.le_next == NULL&& (elm)->chain.le_prev == NULL))
end_define

begin_define
define|#
directive|define
name|LIST_INSERT_TAIL
parameter_list|(
name|head
parameter_list|,
name|elm
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|)
define|\
value|do {\ 	struct type *curelm = LIST_FIRST(head); \ 	if (curelm == NULL) {\ 		LIST_INSERT_HEAD(head, elm, field); \ 	} else { \ 		while (LIST_NEXT(curelm, field)) \ 			curelm = LIST_NEXT(curelm, field);\ 		LIST_INSERT_AFTER(curelm, elm, field);\ 	}\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEY_CHKSASTATE
parameter_list|(
name|head
parameter_list|,
name|sav
parameter_list|,
name|name
parameter_list|)
define|\
value|do { \ 	if ((head) != (sav)) {						\ 		ipseclog((LOG_DEBUG, "%s: state mismatched (TREE=%d SA=%d)\n", \ 			(name), (head), (sav)));			\ 		continue;						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEY_CHKSPDIR
parameter_list|(
name|head
parameter_list|,
name|sp
parameter_list|,
name|name
parameter_list|)
define|\
value|do { \ 	if ((head) != (sp)) {						\ 		ipseclog((LOG_DEBUG, "%s: direction mismatched (TREE=%d SP=%d), " \ 			"anyway continue.\n",				\ 			(name), (head), (sp)));				\ 	}								\ } while (0)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SA
argument_list|,
literal|"secasvar"
argument_list|,
literal|"ipsec security association"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAH
argument_list|,
literal|"sahead"
argument_list|,
literal|"ipsec sa head"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SP
argument_list|,
literal|"ipsecpolicy"
argument_list|,
literal|"ipsec security policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SR
argument_list|,
literal|"ipsecrequest"
argument_list|,
literal|"ipsec security request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_MISC
argument_list|,
literal|"ipsec-misc"
argument_list|,
literal|"ipsec miscellaneous"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAQ
argument_list|,
literal|"ipsec-saq"
argument_list|,
literal|"ipsec sa acquire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAR
argument_list|,
literal|"ipsec-reg"
argument_list|,
literal|"ipsec sa acquire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * set parameters into secpolicyindex buffer.  * Must allocate secpolicyindex buffer passed to this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECSPIDX
parameter_list|(
name|_dir
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|ps
parameter_list|,
name|pd
parameter_list|,
name|ulp
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secpolicyindex));                         \ 	(idx)->dir = (_dir);                                                 \ 	(idx)->prefs = (ps);                                                 \ 	(idx)->prefd = (pd);                                                 \ 	(idx)->ul_proto = (ulp);                                             \ 	bcopy((s),&(idx)->src, ((const struct sockaddr *)(s))->sa_len);     \ 	bcopy((d),&(idx)->dst, ((const struct sockaddr *)(d))->sa_len);     \ } while (0)
end_define

begin_comment
comment|/*  * set parameters into secasindex buffer.  * Must allocate secasindex buffer before calling this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECASIDX
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|r
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secasindex));                             \ 	(idx)->proto = (p);                                                  \ 	(idx)->mode = (m);                                                   \ 	(idx)->reqid = (r);                                                  \ 	bcopy((s),&(idx)->src, ((const struct sockaddr *)(s))->sa_len);     \ 	bcopy((d),&(idx)->dst, ((const struct sockaddr *)(d))->sa_len);     \ } while (0)
end_define

begin_comment
comment|/* key statistics */
end_comment

begin_struct
struct|struct
name|_keystat
block|{
name|u_long
name|getspi_count
decl_stmt|;
comment|/* the avarage of count to try to get new SPI */
block|}
name|keystat
struct|;
end_struct

begin_struct
struct|struct
name|sadb_msghdr
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extoff
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extlen
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_freesp_so
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|_key_delsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_newreqid
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_gather_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
name|int
operator|,
name|int
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdadd
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_getnewspid
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddelete
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddelete2
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdget
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdflush
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddump
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_getspreqmsglen
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdexpire
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsah
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
expr|struct
name|secashead
operator|*
operator|,
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEY_NEWSAV
parameter_list|(
name|m
parameter_list|,
name|sadb
parameter_list|,
name|sah
parameter_list|,
name|e
parameter_list|)
define|\
value|key_newsav(m, sadb, sah, e, __FILE__, __LINE__)
end_define

begin_decl_stmt
specifier|static
name|void
name|key_delsav
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_setsaval
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_mature
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|,
name|u_int16_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|pid_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|,
specifier|const
expr|struct
name|sockaddr
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
end_ifdef

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxport
parameter_list|(
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxtype
parameter_list|(
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|key_porttosaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|KEY_PORTTOSADDR
parameter_list|(
name|saddr
parameter_list|,
name|port
parameter_list|)
define|\
value|key_porttosaddr((struct sockaddr *)(saddr), (port))
end_define

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|seckey
modifier|*
name|key_dup_keymsg
parameter_list|(
specifier|const
name|struct
name|sadb_key
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|struct
name|malloc_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|seclifetime
modifier|*
name|key_dup_lifemsg
parameter_list|(
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|src
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|key_ismyaddr6
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* flags for key_cmpsaidx() */
end_comment

begin_define
define|#
directive|define
name|CMP_HEAD
value|1
end_define

begin_comment
comment|/* protocol, addresses. */
end_comment

begin_define
define|#
directive|define
name|CMP_MODE_REQID
value|2
end_define

begin_comment
comment|/* additionally HEAD, reqid, mode. */
end_comment

begin_define
define|#
directive|define
name|CMP_REQID
value|3
end_define

begin_comment
comment|/* additionally HEAD, reaid. */
end_comment

begin_define
define|#
directive|define
name|CMP_EXACTLY
value|4
end_define

begin_comment
comment|/* all elements. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_cmpsaidx
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|,
specifier|const
expr|struct
name|secasindex
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_exactly
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|,
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_withmask
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|,
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_sockaddrcmp
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_bbcmp
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|key_satype2proto
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|key_proto2satype
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_getspi
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_do_getnewspi
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|,
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_update
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|key_add
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_setident
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_delete
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_get
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_getcomb_setlifetime
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_esp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_acquire
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|,
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_acquire2
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_register
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_expire
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_flush
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_dump
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_senderror
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_validate_ext
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|sadb_ext
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_align
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setlifetime
parameter_list|(
name|struct
name|seclifetime
modifier|*
name|src
parameter_list|,
name|u_int16_t
name|exttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setkey
parameter_list|(
name|struct
name|seckey
modifier|*
name|src
parameter_list|,
name|u_int16_t
name|exttype
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *key_getfqdn __P((void)); static const char *key_getuserfqdn __P((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|key_sa_chgstate
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_alloc_mbuf
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|sa_initref
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|refcount_init
argument_list|(
operator|&
name|sav
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sa_addref
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|refcnt
operator|!=
literal|0
argument_list|,
operator|(
literal|"SA refcnt overflow"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|sa_delref
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"SA refcnt underflow"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|refcount_release
argument_list|(
operator|&
name|sav
operator|->
name|refcnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SP_ADDREF
parameter_list|(
name|p
parameter_list|)
value|do {						\ 	(p)->refcnt++;							\ 	IPSEC_ASSERT((p)->refcnt != 0, ("SP refcnt overflow"));		\ } while (0)
end_define

begin_define
define|#
directive|define
name|SP_DELREF
parameter_list|(
name|p
parameter_list|)
value|do {						\ 	IPSEC_ASSERT((p)->refcnt> 0, ("SP refcnt underflow"));		\ 	(p)->refcnt--;							\ } while (0)
end_define

begin_comment
comment|/*  * Update the refcnt while holding the SPTREE lock.  */
end_comment

begin_function
name|void
name|key_addref
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 0 when there are known to be no SP's for the specified  * direction.  Otherwise return 1.  This is used by IPsec code  * to optimize performance.  */
end_comment

begin_function
name|int
name|key_havesp
parameter_list|(
name|u_int
name|dir
parameter_list|)
block|{
return|return
operator|(
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|?
name|LIST_FIRST
argument_list|(
operator|&
name|V_sptree
index|[
name|dir
index|]
argument_list|)
operator|!=
name|NULL
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* %%% IPsec policy management */
end_comment

begin_comment
comment|/*  * allocating a SP for OUTBOUND or INBOUND packet.  * Must call key_freesp() later.  * OUT:	NULL:	not found  *	others:	found and return the pointer.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_allocsp
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|,
name|u_int
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|spidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null spidx"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|dir
operator|)
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s from %s:%u\n"
argument_list|,
name|__func__
argument_list|,
name|where
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get a SP entry */
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** objects\n"
argument|); 		kdebug_secpolicyindex(spidx)
argument_list|)
empty_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** in SPD\n"
argument|); 			kdebug_secpolicyindex(&sp->spidx)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_withmask
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|,
name|spidx
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|sp
operator|=
name|NULL
expr_stmt|;
name|found
label|:
if|if
condition|(
name|sp
condition|)
block|{
comment|/* sanity check */
name|KEY_CHKSPDIR
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|dir
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* found a SPD entry */
name|sp
operator|->
name|lastused
operator|=
name|time_second
expr_stmt|;
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s return SP:%p (ID=%u) refcnt %u\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|id
else|:
literal|0
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|refcnt
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SP for OUTBOUND or INBOUND packet.  * Must call key_freesp() later.  * OUT:	NULL:	not found  *	others:	found and return the pointer.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_allocsp2
parameter_list|(
name|u_int32_t
name|spi
parameter_list|,
name|union
name|sockaddr_union
modifier|*
name|dst
parameter_list|,
name|u_int8_t
name|proto
parameter_list|,
name|u_int
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dst
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null dst"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|dir
operator|)
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s from %s:%u\n"
argument_list|,
name|__func__
argument_list|,
name|where
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get a SP entry */
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** objects\n"
argument|); 		printf(
literal|"spi %u proto %u dir %u\n"
argument|, spi, proto, dir); 		kdebug_sockaddr(&dst->sa)
argument_list|)
empty_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** in SPD\n"
argument|); 			kdebug_secpolicyindex(&sp->spidx)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
comment|/* compare simple values, then dst address */
if|if
condition|(
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
operator|!=
name|proto
condition|)
continue|continue;
comment|/* NB: spi's must exist and match */
if|if
condition|(
operator|!
name|sp
operator|->
name|req
operator|||
operator|!
name|sp
operator|->
name|req
operator|->
name|sav
operator|||
name|sp
operator|->
name|req
operator|->
name|sav
operator|->
name|spi
operator|!=
name|spi
condition|)
continue|continue;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|dst
operator|->
name|sa
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
name|sp
operator|=
name|NULL
expr_stmt|;
name|found
label|:
if|if
condition|(
name|sp
condition|)
block|{
comment|/* sanity check */
name|KEY_CHKSPDIR
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|dir
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* found a SPD entry */
name|sp
operator|->
name|lastused
operator|=
name|time_second
expr_stmt|;
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s return SP:%p (ID=%u) refcnt %u\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|id
else|:
literal|0
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|refcnt
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * return a policy that matches this particular inbound packet.  * XXX slow  */
end_comment

begin_comment
unit|struct secpolicy * key_gettunnel(const struct sockaddr *osrc, 	      const struct sockaddr *odst, 	      const struct sockaddr *isrc, 	      const struct sockaddr *idst, 	      const char* where, int tag) { 	struct secpolicy *sp; 	const int dir = IPSEC_DIR_INBOUND; 	struct ipsecrequest *r1, *r2, *p; 	struct secpolicyindex spidx;  	KEYDEBUG(KEYDEBUG_IPSEC_STAMP, 		printf("DP %s from %s:%u\n", __func__, where, tag));  	if (isrc->sa_family != idst->sa_family) { 		ipseclog((LOG_ERR, "%s: protocol family mismatched %d != %d\n.", 			__func__, isrc->sa_family, idst->sa_family)); 		sp = NULL; 		goto done; 	}  	SPTREE_LOCK(); 	LIST_FOREACH(sp,&V_sptree[dir], chain) { 		if (sp->state == IPSEC_SPSTATE_DEAD) 			continue;  		r1 = r2 = NULL; 		for (p = sp->req; p; p = p->next) { 			if (p->saidx.mode != IPSEC_MODE_TUNNEL) 				continue;  			r1 = r2; 			r2 = p;  			if (!r1) {
comment|/* here we look at address matches only */
end_comment

begin_endif
unit|spidx = sp->spidx; 				if (isrc->sa_len> sizeof(spidx.src) || 				    idst->sa_len> sizeof(spidx.dst)) 					continue; 				bcopy(isrc,&spidx.src, isrc->sa_len); 				bcopy(idst,&spidx.dst, idst->sa_len); 				if (!key_cmpspidx_withmask(&sp->spidx,&spidx)) 					continue; 			} else { 				if (key_sockaddrcmp(&r1->saidx.src.sa, isrc, 0) || 				    key_sockaddrcmp(&r1->saidx.dst.sa, idst, 0)) 					continue; 			}  			if (key_sockaddrcmp(&r2->saidx.src.sa, osrc, 0) || 			    key_sockaddrcmp(&r2->saidx.dst.sa, odst, 0)) 				continue;  			goto found; 		} 	} 	sp = NULL; found: 	if (sp) { 		sp->lastused = time_second; 		SP_ADDREF(sp); 	} 	SPTREE_UNLOCK(); done: 	KEYDEBUG(KEYDEBUG_IPSEC_STAMP, 		printf("DP %s return SP:%p (ID=%u) refcnt %u\n", __func__, 			sp, sp ? sp->id : 0, sp ? sp->refcnt : 0)); 	return sp; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * allocating an SA entry for an *OUTBOUND* packet.  * checking each request entries in SP, and acquire an SA if need.  * OUT:	0: there are valid requests.  *	ENOENT: policy may be valid, but SA with REQUIRE is on acquiring.  */
end_comment

begin_function
name|int
name|key_checkrequest
parameter_list|(
name|struct
name|ipsecrequest
modifier|*
name|isr
parameter_list|,
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|u_int
name|level
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|isr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null isr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null saidx"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TRANSPORT
operator|||
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
argument_list|,
operator|(
literal|"unexpected policy %u"
operator|,
name|saidx
operator|->
name|mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX guard against protocol callbacks from the crypto 	 * thread as they reference ipsecrequest.sav which we 	 * temporarily null out below.  Need to rethink how we 	 * handle bundled SA's in the callback thread. 	 */
name|IPSECREQUEST_LOCK_ASSERT
argument_list|(
name|isr
argument_list|)
expr_stmt|;
comment|/* get current level */
name|level
operator|=
name|ipsec_get_reqlevel
argument_list|(
name|isr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * We do allocate new SA only if the state of SA in the holder is 	 * SADB_SASTATE_DEAD.  The SA for outbound must be the oldest. 	 */
block|if (isr->sav != NULL) { 		if (isr->sav->sah == NULL) 			panic("%s: sah is null.\n", __func__); 		if (isr->sav == (struct secasvar *)LIST_FIRST(&isr->sav->sah->savtree[SADB_SASTATE_DEAD])) { 			KEY_FREESAV(&isr->sav); 			isr->sav = NULL; 		} 	}
else|#
directive|else
comment|/* 	 * we free any SA stashed in the IPsec request because a different 	 * SA may be involved each time this request is checked, either 	 * because new SAs are being configured, or this request is 	 * associated with an unconnected datagram socket, or this request 	 * is associated with a system default policy. 	 * 	 * The operation may have negative impact to performance.  We may 	 * want to check cached SA carefully, rather than picking new SA 	 * every time. 	 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEY_FREESAV
argument_list|(
operator|&
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * new SA allocation if no SA found. 	 * key_allocsa_policy should allocate the oldest SA available. 	 * See key_do_allocsa_policy(), and draft-jenkins-ipsec-rekeying-03.txt. 	 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|==
name|NULL
condition|)
name|isr
operator|->
name|sav
operator|=
name|key_allocsa_policy
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
comment|/* When there is SA. */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isr
operator|->
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_MATURE
operator|&&
name|isr
operator|->
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_DYING
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
comment|/* there is no SA */
name|error
operator|=
name|key_acquire
argument_list|(
name|saidx
argument_list|,
name|isr
operator|->
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What should I do ? */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: error %d returned from key_acquire\n"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|level
operator|!=
name|IPSEC_LEVEL_REQUIRE
condition|)
block|{
comment|/* XXX sigh, the interface to this routine is botched */
name|IPSEC_ASSERT
argument_list|(
name|isr
operator|->
name|sav
operator|==
name|NULL
argument_list|,
operator|(
literal|"unexpected SA"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENOENT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocating a SA for policy entry from SAD.  * NOTE: searching SAD of aliving state.  * OUT:	NULL:	not found.  *	others:	found and return the pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|_ARRAYLEN(a)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|arraysize
decl_stmt|;
specifier|const
name|u_int
modifier|*
name|state_valid
decl_stmt|;
name|state_valid
operator|=
name|NULL
expr_stmt|;
comment|/* silence gcc */
name|arraysize
operator|=
literal|0
expr_stmt|;
comment|/* silence gcc */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
block|{
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
block|{
name|state_valid
operator|=
name|saorder_state_valid_prefer_old
expr_stmt|;
name|arraysize
operator|=
name|N
argument_list|(
name|saorder_state_valid_prefer_old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state_valid
operator|=
name|saorder_state_valid_prefer_new
expr_stmt|;
name|arraysize
operator|=
name|N
argument_list|(
name|saorder_state_valid_prefer_new
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|arraysize
condition|;
name|stateidx
operator|++
control|)
block|{
name|sav
operator|=
name|key_do_allocsa_policy
argument_list|(
name|sah
argument_list|,
name|state_valid
index|[
name|stateidx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
return|return
name|sav
return|;
block|}
return|return
name|NULL
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * searching SAD with direction, protocol, mode and state.  * called by key_allocsa_policy().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
parameter_list|(
name|struct
name|secashead
modifier|*
name|sah
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|,
modifier|*
name|candidate
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* initilize */
name|candidate
operator|=
name|NULL
expr_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* initialize */
if|if
condition|(
name|candidate
operator|==
name|NULL
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
continue|continue;
block|}
comment|/* Which SA is the better ? */
name|IPSEC_ASSERT
argument_list|(
name|candidate
operator|->
name|lft_c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null candidate lifetime"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav lifetime"
operator|)
argument_list|)
expr_stmt|;
comment|/* What the best method is to compare ? */
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
block|{
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|->
name|addtime
operator|>
name|sav
operator|->
name|lft_c
operator|->
name|addtime
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
block|}
continue|continue;
comment|/*NOTREACHED*/
block|}
comment|/* preferred new sa rather than old sa */
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|->
name|addtime
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|addtime
condition|)
block|{
name|d
operator|=
name|candidate
expr_stmt|;
name|candidate
operator|=
name|sav
expr_stmt|;
block|}
else|else
name|d
operator|=
name|sav
expr_stmt|;
comment|/* 		 * prepared to delete the SA when there is more 		 * suitable candidate and the lifetime of the SA is not 		 * permanent. 		 */
if|if
condition|(
name|d
operator|->
name|lft_h
operator|->
name|addtime
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
name|key_sa_chgstate
argument_list|(
name|d
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|d
operator|->
name|refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus ref count"
operator|)
argument_list|)
expr_stmt|;
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|satype
operator|==
literal|0
condition|)
goto|goto
name|msgfail
goto|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_DELETE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|refcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|msgfail
goto|;
name|result
operator|=
name|m
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|msgfail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|msgfail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|msgfail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|msgfail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
condition|)
goto|goto
name|msgfail
goto|;
name|msgfail
label|:
name|KEY_FREESAV
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|candidate
condition|)
block|{
name|sa_addref
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s cause refcnt++:%d SA:%p\n"
argument_list|,
name|__func__
argument_list|,
name|candidate
operator|->
name|refcnt
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|candidate
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a usable SA entry for a *INBOUND* packet.  * Must call key_freesav() later.  * OUT: positive:	pointer to a usable sav (i.e. MATURE or DYING state).  *	NULL:		not found, or error occured.  *  * In the comparison, no source address is used--for RFC2401 conformance.  * To quote, from section 4.1:  *	A security association is uniquely identified by a triple consisting  *	of a Security Parameter Index (SPI), an IP Destination Address, and a  *	security protocol (AH or ESP) identifier.  * Note that, however, we do need to keep source address in IPsec SA.  * IKE specification and PF_KEY specification do assume that we  * keep source address in IPsec SA.  We see a tricky situation here.  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa
parameter_list|(
name|union
name|sockaddr_union
modifier|*
name|dst
parameter_list|,
name|u_int
name|proto
parameter_list|,
name|u_int32_t
name|spi
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|arraysize
decl_stmt|,
name|state
decl_stmt|;
specifier|const
name|u_int
modifier|*
name|saorder_state_valid
decl_stmt|;
name|int
name|chkport
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dst
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null dst address"
operator|)
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s from %s:%u\n"
argument_list|,
name|__func__
argument_list|,
name|where
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
name|chkport
operator|=
operator|(
name|dst
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|dst
operator|->
name|sa
operator|.
name|sa_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|&&
name|dst
operator|->
name|sin
operator|.
name|sin_port
operator|!=
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|chkport
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * searching SAD. 	 * XXX: to be checked internal IP header somewhere.  Also when 	 * IPsec tunnel packet is received.  But ESP tunnel mode is 	 * encrypted so we can't check internal IP header. 	 */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
block|{
name|saorder_state_valid
operator|=
name|saorder_state_valid_prefer_old
expr_stmt|;
name|arraysize
operator|=
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid_prefer_old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saorder_state_valid
operator|=
name|saorder_state_valid_prefer_new
expr_stmt|;
name|arraysize
operator|=
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid_prefer_new
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|arraysize
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_valid
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* do not return entries w/ unusable state */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_MATURE
operator|&&
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_DYING
condition|)
continue|continue;
if|if
condition|(
name|proto
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
if|if
condition|(
name|spi
operator|!=
name|sav
operator|->
name|spi
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* don't check src */
comment|/* check src address */
block|if (key_sockaddrcmp(&src->sa,&sav->sah->saidx.src.sa, chkport) != 0) 					continue;
endif|#
directive|endif
comment|/* check dst address */
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|dst
operator|->
name|sa
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|chkport
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sa_addref
argument_list|(
name|sav
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|sav
operator|=
name|NULL
expr_stmt|;
name|done
label|:
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s return SA:%p; refcnt %u\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|sav
condition|?
name|sav
operator|->
name|refcnt
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For both the packet without socket and key_freeso().  */
end_comment

begin_function
name|void
name|_key_freesp
parameter_list|(
name|struct
name|secpolicy
modifier|*
modifier|*
name|spp
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
init|=
operator|*
name|spp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sp"
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|SP_DELREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s SP:%p (ID=%u) from %s:%u; refcnt now %u\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|id
argument_list|,
name|where
argument_list|,
name|tag
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
operator|*
name|spp
operator|=
name|NULL
expr_stmt|;
name|key_delsp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For the packet with socket.  */
end_comment

begin_function
name|void
name|key_freeso
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null so"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
ifdef|#
directive|ifdef
name|INET
case|case
name|PF_INET
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
endif|#
directive|endif
block|{
name|struct
name|inpcb
modifier|*
name|pcb
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET || INET6 */
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unknown address family=%d.\n"
operator|,
name|__func__
operator|,
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|key_freesp_so
parameter_list|(
name|struct
name|secpolicy
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
operator|&&
operator|*
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sp"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
operator|==
name|IPSEC_POLICY_ENTRUST
operator|||
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
operator|==
name|IPSEC_POLICY_BYPASS
condition|)
return|return;
name|IPSEC_ASSERT
argument_list|(
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
argument_list|,
operator|(
literal|"invalid policy %u"
operator|,
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsa().  * This function is called by key_freesp() to free some SA allocated  * for a policy.  */
end_comment

begin_function
name|void
name|key_freesav
parameter_list|(
name|struct
name|secasvar
modifier|*
modifier|*
name|psav
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secasvar
modifier|*
name|sav
init|=
operator|*
name|psav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_delref
argument_list|(
name|sav
argument_list|)
condition|)
block|{
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s SA:%p (SPI %u) from %s:%u; refcnt now %u\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|,
name|where
argument_list|,
name|tag
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|psav
operator|=
name|NULL
expr_stmt|;
name|key_delsav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s SA:%p (SPI %u) from %s:%u; refcnt now %u\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|,
name|where
argument_list|,
name|tag
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* %%% SPD management */
end_comment

begin_comment
comment|/*  * free security policy entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|,
modifier|*
name|nextisr
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sp"
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"SP with references deleted (refcnt %u)"
operator|,
name|sp
operator|->
name|refcnt
operator|)
argument_list|)
expr_stmt|;
comment|/* remove from SP index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sp
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|nextisr
control|)
block|{
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEY_FREESAV
argument_list|(
operator|&
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
name|nextisr
operator|=
name|isr
operator|->
name|next
expr_stmt|;
name|ipsec_delisr
argument_list|(
name|isr
argument_list|)
expr_stmt|;
block|}
name|_key_delsp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * search SPD  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|spidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null spidx"
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[spidx->dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|sp
operator|->
name|spidx
argument_list|)
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * get SP by index.  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
parameter_list|(
name|u_int32_t
name|id
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[IPSEC_DIR_INBOUND]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[IPSEC_DIR_OUTBOUND]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|struct
name|secpolicy
modifier|*
name|key_newsp
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
init|=
name|NULL
decl_stmt|;
name|newsp
operator|=
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secpolicy
argument_list|)
argument_list|,
name|M_IPSEC_SP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsp
condition|)
block|{
name|SECPOLICY_LOCK_INIT
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
block|}
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s from %s:%u return SP:%p\n"
argument_list|,
name|__func__
argument_list|,
name|where
argument_list|,
name|tag
argument_list|,
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newsp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_key_delsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|SECPOLICY_LOCK_DESTROY
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_IPSEC_SP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create secpolicy structure from sadb_x_policy structure.  * NOTE: `state', `secpolicyindex' in secpolicy structure are not set,  * so must be set properly later.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_msg2sp
parameter_list|(
name|xpl0
parameter_list|,
name|len
parameter_list|,
name|error
parameter_list|)
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
modifier|*
name|error
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|xpl0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null xpl0"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
argument_list|,
operator|(
literal|"policy too short: %zu"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid msg length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|newsp
operator|=
name|KEY_NEWSP
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsp
operator|->
name|spidx
operator|.
name|dir
operator|=
name|xpl0
operator|->
name|sadb_x_policy_dir
expr_stmt|;
name|newsp
operator|->
name|policy
operator|=
name|xpl0
operator|->
name|sadb_x_policy_type
expr_stmt|;
comment|/* check policy */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
block|{
name|int
name|tlen
decl_stmt|;
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
modifier|*
name|p_isr
init|=
operator|&
name|newsp
operator|->
name|req
decl_stmt|;
comment|/* validity check */
if|if
condition|(
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid msg length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tlen
operator|=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
expr_stmt|;
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
name|xpl0
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
comment|/* length check */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid ipsecrequest "
literal|"length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocate request buffer */
comment|/* NB: data structure is zero'd */
operator|*
name|p_isr
operator|=
name|ipsec_newisr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p_isr
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* set values */
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_IPCOMP
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid proto type=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|proto
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid mode=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|mode
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
condition|)
block|{
case|case
name|IPSEC_LEVEL_DEFAULT
case|:
case|case
name|IPSEC_LEVEL_USE
case|:
case|case
name|IPSEC_LEVEL_REQUIRE
case|:
break|break;
case|case
name|IPSEC_LEVEL_UNIQUE
case|:
comment|/* validity check */
comment|/* 				 * If range violation of reqid, kernel will 				 * update it, don't refuse it. 				 */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|>
name|IPSEC_MANUAL_REQID_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: reqid=%d range "
literal|"violation, updated by kernel.\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|)
argument_list|)
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* allocate new reqid id if reqid is zero. */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|reqid
decl_stmt|;
if|if
condition|(
operator|(
name|reqid
operator|=
name|key_newreqid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|reqid
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|reqid
expr_stmt|;
block|}
else|else
block|{
comment|/* set it for manual keying. */
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
expr_stmt|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid level=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|level
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
expr_stmt|;
comment|/* set IP addresses if there */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|paddr
decl_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|xisr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"request address length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|paddr
operator|+
name|paddr
operator|->
name|sa_len
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"request address length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|sp
operator|=
name|newsp
expr_stmt|;
comment|/* initialization for the next. */
name|p_isr
operator|=
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|next
expr_stmt|;
name|tlen
operator|-=
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: becoming tlen< 0.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|xisr
operator|+
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid policy type.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|error
operator|=
literal|0
expr_stmt|;
return|return
name|newsp
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|key_newreqid
parameter_list|()
block|{
specifier|static
name|u_int32_t
name|auto_reqid
init|=
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
decl_stmt|;
name|auto_reqid
operator|=
operator|(
name|auto_reqid
operator|==
operator|~
literal|0
condition|?
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
else|:
name|auto_reqid
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* XXX should be unique check */
return|return
name|auto_reqid
return|;
block|}
end_function

begin_comment
comment|/*  * copy secpolicy struct to sadb_x_policy structure indicated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|key_sp2msg
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|sadb_x_policy
modifier|*
name|xpl
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null policy"
operator|)
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|tlen
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|xpl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|xpl
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_type
operator|=
name|sp
operator|->
name|policy
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_dir
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dir
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|xpl
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
name|p
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|=
name|isr
operator|->
name|saidx
operator|.
name|proto
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|=
name|isr
operator|->
name|saidx
operator|.
name|mode
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|=
name|isr
operator|->
name|level
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|isr
operator|->
name|saidx
operator|.
name|reqid
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* m will not be freed nor modified */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|key_gather_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|int
name|ndeep
parameter_list|,
name|int
name|nitem
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|key_gather_mbuf
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|,
name|ndeep
parameter_list|,
name|nitem
parameter_list|,
name|va_alist
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
name|int
name|ndeep
decl_stmt|;
name|int
name|nitem
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|nitem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitem
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
name|SADB_EXT_MAX
condition|)
goto|goto
name|fail
goto|;
comment|/* don't attempt to pull empty extension */
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
operator|&&
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|!=
name|SADB_EXT_RESERVED
operator|&&
operator|(
name|mhp
operator|->
name|ext
index|[
name|idx
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
condition|)
block|{
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|len
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"header too big %u"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
goto|goto
name|fail
goto|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|ndeep
condition|)
block|{
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
expr_stmt|;
name|n
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|||
name|n
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|n
condition|)
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|n
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|result
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDADD, SADB_X_SPDSETIDX or SADB_X_SPDUPDATE processing  * add an entry to SP database, when received  *<base, address(SD), (lifetime(H),) policy>  * from the user(?).  * Adding to SP database,  * and send  *<base, address(SD), (lifetime(H),) policy>  * to the socket which was send.  *  * SPDADD set a unique policy entry.  * SPDSETIDX like SPDADD without a part of policy requests.  * SPDUPDATE replace a unique policy entry.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdadd
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|,
modifier|*
name|xpl
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lft
init|=
name|NULL
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|lft
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/*  	 * Note: do not parse SADB_X_EXT_NAT_T_* here: 	 * we are processing traffic endpoints. 	 */
comment|/* make secindex */
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid SP direction.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check policy */
comment|/* key_spdadd() accepts DISCARD, NONE and IPSEC. */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_ENTRUST
operator|||
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_BYPASS
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid policy type.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* policy requests are mandatory when action is ipsec. */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|!=
name|SADB_X_SPDSETIDX
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_IPSEC
operator|&&
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: some policy requests part required\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * checking there is SP already or not. 	 * SPDUPDATE doesn't depend on whether there is a SP or not. 	 * If the type is either SPDADD or SPDSETIDX AND a SP is found, 	 * then error. 	 */
name|newsp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDUPDATE
condition|)
block|{
if|if
condition|(
name|newsp
condition|)
block|{
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|newsp
operator|!=
name|NULL
condition|)
block|{
name|KEY_FREESP
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: a SP entry exists already.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
block|}
comment|/* allocation new SP entry */
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_msg2sp
argument_list|(
name|xpl0
argument_list|,
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|newsp
operator|->
name|id
operator|=
name|key_getnewspid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|_key_delsp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|newsp
operator|->
name|spidx
argument_list|)
expr_stmt|;
comment|/* sanity check on addr pair */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
operator|!=
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
name|_key_delsp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
condition|)
block|{
name|_key_delsp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|newsp
operator|->
name|req
operator|&&
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|&&
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|if
condition|(
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|_key_delsp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
name|newsp
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|newsp
operator|->
name|lastused
operator|=
name|newsp
operator|->
name|created
expr_stmt|;
name|newsp
operator|->
name|lifetime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_addtime
else|:
literal|0
expr_stmt|;
name|newsp
operator|->
name|validtime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_usetime
else|:
literal|0
expr_stmt|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
comment|/* do not reclaim until I say I do */
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_ALIVE
expr_stmt|;
name|LIST_INSERT_TAIL
argument_list|(
operator|&
name|V_sptree
index|[
name|newsp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|newsp
argument_list|,
name|secpolicy
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* delete the entry in spacqtree */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDUPDATE
condition|)
block|{
name|struct
name|secspacq
modifier|*
name|spacq
init|=
name|key_getspacq
argument_list|(
operator|&
name|spidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|spacq
operator|!=
name|NULL
condition|)
block|{
comment|/* reset counter in order to deletion by timehandler. */
name|spacq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|spacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mpolicy
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* 	 * Note: do not send SADB_X_EXT_NAT_T_* here: 	 * we are sending traffic endpoints. 	 */
comment|/* create new sadb_msg to reply. */
if|if
condition|(
name|lft
condition|)
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|mpolicy
operator|=
name|m_pulldown
argument_list|(
name|n
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpolicy
operator|==
name|NULL
condition|)
block|{
comment|/* n is already freed */
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|xpl
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mpolicy
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|!=
name|SADB_X_EXT_POLICY
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|newsp
operator|->
name|id
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * get new policy id.  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|key_getnewspid
parameter_list|()
block|{
name|u_int32_t
name|newid
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|V_key_spi_trycnt
decl_stmt|;
comment|/* XXX */
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|newid
operator|=
operator|(
name|V_policy_id
operator|=
operator|(
name|V_policy_id
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
name|V_policy_id
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|newid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|KEY_FREESP
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newid
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: to allocate policy id is failed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|newid
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE processing  * receive  *<base, address(SD), policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, address(SD), policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null so"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* 	 * Note: do not parse SADB_X_EXT_NAT_T_* here: 	 * we are processing traffic endpoints. 	 */
comment|/* make secindex */
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid SP direction.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* save policy id to buffer to be returned. */
name|xpl0
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* 	 * Note: do not send SADB_X_EXT_NAT_T_* here: 	 * we are sending traffic endpoints. 	 */
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE2 processing  * receive  *<base, policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete2
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|u_int32_t
name|id
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found id:%u.\n"
operator|,
name|__func__
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|KEY_FREESP
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length inconsistency (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_X_GET processing  * receive  *<base, policy(*)>  * from the user(?),  * and send,  *<base, address(SD), policy>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdget
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|u_int32_t
name|id
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found id:%u.\n"
operator|,
name|__func__
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDGET
argument_list|,
literal|0
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
else|else
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDACQUIRE processing.  * Acquire policy and SA(s) for a *OUTBOUND* packet.  * send  *<base, policy(*)>  * to KMD, and expect to receive  *<base> with SADB_X_SPDACQUIRE if error occured,  * or  *<base, policy>  * with SADB_X_SPDUPDATE from KMD by PF_KEY.  * policy(*) is without policy requests.  *  *    0     : succeed  *    others: error number  */
end_comment

begin_function
name|int
name|key_spdacquire
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|secspacq
modifier|*
name|newspacq
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secpolicy"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|req
operator|==
name|NULL
argument_list|,
operator|(
literal|"policy exists"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
argument_list|,
operator|(
literal|"policy not IPSEC %u"
operator|,
name|sp
operator|->
name|policy
operator|)
argument_list|)
expr_stmt|;
comment|/* Get an entry to check whether sent message or not. */
name|newspacq
operator|=
name|key_getspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspacq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|V_key_blockacq_count
operator|<
name|newspacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newspacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newspacq
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
name|newspacq
operator|=
name|key_newspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspacq
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
block|}
comment|/* create new sadb_msg to reply. */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDACQUIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|ENOBUFS
return|;
name|result
operator|=
name|m
expr_stmt|;
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDFLUSH processing  * receive  *<base>  * from the user, and free all entries in secpctree.  * and send,  *<base>  * to the user.  * NOTE: what to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdflush
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDUMP processing  * receive  *<base>  * from the user, and dump all SP leaves  * and send,  *<base> .....  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddump
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* search SPD entry and get buffer size. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
operator|--
name|cnt
expr_stmt|;
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDDUMP
argument_list|,
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|pid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|seclifetime
name|lt
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|SADB_SATYPE_UNSPEC
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
comment|/* 	 * Note: do not send SADB_X_EXT_NAT_T_* here: 	 * we are sending traffic endpoints. 	 */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_sp2msg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lifetime
condition|)
block|{
name|lt
operator|.
name|addtime
operator|=
name|sp
operator|->
name|created
expr_stmt|;
name|lt
operator|.
name|usetime
operator|=
name|sp
operator|->
name|lastused
expr_stmt|;
name|m
operator|=
name|key_setlifetime
argument_list|(
operator|&
name|lt
argument_list|,
name|SADB_EXT_LIFETIME_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|lt
operator|.
name|addtime
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|lt
operator|.
name|usetime
operator|=
name|sp
operator|->
name|validtime
expr_stmt|;
name|m
operator|=
name|key_setlifetime
argument_list|(
operator|&
name|lt
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * get PFKEY message length for security policy and request.  */
end_comment

begin_function
specifier|static
name|u_int
name|key_getspreqmsglen
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
return|return
name|tlen
return|;
comment|/* get length of ipsec requests */
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_ipsecrequest
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|tlen
operator|+=
name|PFKEY_ALIGN8
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDEXPIRE processing  * send  *<base, address(SD), lifetime(CH), policy>  * to KMD by PF_KEY.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_spdexpire
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
comment|/* XXX: Why do we lock ? */
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secpolicy"
operator|)
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDEXPIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create lifetime extension (current and hard) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|created
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|lastused
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_HARD
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|validtime
expr_stmt|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Note: do not send SADB_X_EXT_NAT_T_* here: 	 * we are sending traffic endpoints. 	 */
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set secpolicy */
name|m
operator|=
name|key_sp2msg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* %%% SAD management */
end_comment

begin_comment
comment|/*  * allocating a memory for new SA head, and copy from the values of mhp.  * OUT:	NULL	: failure due to the lack of memory.  *	others	: pointer to new SA head.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null saidx"
operator|)
argument_list|)
expr_stmt|;
name|newsah
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secashead
argument_list|)
argument_list|,
name|M_IPSEC_SAH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsah
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|newsah
operator|->
name|savtree
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|newsah
operator|->
name|savtree
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|newsah
operator|->
name|savtree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|newsah
operator|->
name|saidx
operator|=
operator|*
name|saidx
expr_stmt|;
comment|/* add to saidxtree */
name|newsah
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_sahtree
argument_list|,
name|newsah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|newsah
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete SA index and all SA registerd.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsah
parameter_list|(
name|sah
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
name|int
name|zombie
init|=
literal|0
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sah"
operator|)
argument_list|)
expr_stmt|;
name|SAHTREE_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* searching all SA registerd in the secindex. */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|u_int
name|state
init|=
name|saorder_state_any
index|[
name|stateidx
index|]
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|,
argument|nextsav
argument_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/*  				 * do NOT call KEY_FREESAV here: 				 * it will only delete the sav if refcnt == 1, 				 * where we already know that refcnt == 0 				 */
name|key_delsav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* give up to delete this sa */
name|zombie
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|zombie
condition|)
block|{
comment|/* delete only if there are savs */
comment|/* remove from tree of SA index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sah
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|sah
argument_list|,
name|M_IPSEC_SAH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocating a new SA with LARVAL state.  key_add() and key_getspi() call,  * and copy the values of mhp into new buffer.  * When SAD message type is GETSPI:  *	to set sequence number from acq_seq++,  *	to set zero to SPI.  *	not to call key_setsava().  * OUT:	NULL	: fail  *	others	: pointer to new secasvar.  *  * does not modify mbuf.  does not free mbuf on error.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|,
name|sah
parameter_list|,
name|errp
parameter_list|,
name|where
parameter_list|,
name|tag
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
specifier|const
name|char
modifier|*
name|where
decl_stmt|;
name|int
name|tag
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
specifier|const
name|struct
name|sadb_sa
modifier|*
name|xsa
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secashead"
operator|)
argument_list|)
expr_stmt|;
name|newsav
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|,
name|M_IPSEC_SA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
name|newsav
operator|->
name|spi
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
comment|/* sync sequence number */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
name|newsav
operator|->
name|seq
operator|=
operator|(
name|V_acq_seq
operator|=
operator|(
name|V_acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|V_acq_seq
operator|)
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|newsav
operator|->
name|seq
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
case|case
name|SADB_ADD
case|:
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|newsav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
name|newsav
operator|=
name|NULL
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|xsa
operator|=
operator|(
specifier|const
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|newsav
operator|->
name|spi
operator|=
name|xsa
operator|->
name|sadb_sa_spi
expr_stmt|;
name|newsav
operator|->
name|seq
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|newsav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
name|newsav
operator|=
name|NULL
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* copy sav values */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|!=
name|SADB_GETSPI
condition|)
block|{
operator|*
name|errp
operator|=
name|key_setsaval
argument_list|(
name|newsav
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
condition|)
block|{
name|free
argument_list|(
name|newsav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
name|newsav
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|SECASVAR_LOCK_INIT
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
comment|/* reset created */
name|newsav
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|newsav
operator|->
name|pid
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
expr_stmt|;
comment|/* add to satree */
name|newsav
operator|->
name|sah
operator|=
name|sah
expr_stmt|;
name|sa_initref
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
name|newsav
operator|->
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_TAIL
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_LARVAL
index|]
argument_list|,
name|newsav
argument_list|,
name|secasvar
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|done
label|:
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s from %s:%u return SP:%p\n"
argument_list|,
name|__func__
argument_list|,
name|where
argument_list|,
name|tag
argument_list|,
name|newsav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newsav
return|;
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_cleansav
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
comment|/* 	 * Cleanup xform state.  Note that zeroize'ing causes the 	 * keys to be cleared; otherwise we must do it ourself. 	 */
if|if
condition|(
name|sav
operator|->
name|tdb_xform
operator|!=
name|NULL
condition|)
block|{
name|sav
operator|->
name|tdb_xform
operator|->
name|xf_zeroize
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tdb_xform
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|sav
operator|->
name|iv
operator|==
name|NULL
argument_list|,
operator|(
literal|"iv but no xform"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|sched
condition|)
block|{
name|bzero
argument_list|(
name|sav
operator|->
name|sched
argument_list|,
name|sav
operator|->
name|schedlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|sched
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|replay
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsav
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"reference count %u> 0"
operator|,
name|sav
operator|->
name|refcnt
operator|)
argument_list|)
expr_stmt|;
comment|/* remove from SA header */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_cleansav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|SECASVAR_LOCK_DESTROY
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * search SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_REQID
argument_list|)
condition|)
break|break;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|sah
return|;
block|}
end_function

begin_comment
comment|/*  * check not to be duplicated SPI.  * NOTE: this function is too slow due to searching all SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
parameter_list|(
name|saidx
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
comment|/* check address family */
if|if
condition|(
name|saidx
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address family mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sav
operator|=
name|NULL
expr_stmt|;
comment|/* check all SAD */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
operator|!
name|key_ismyaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
condition|)
continue|continue;
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
break|break;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|sav
return|;
block|}
end_function

begin_comment
comment|/*  * search SAD litmited alive SA, protocol, SPI.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
parameter_list|(
name|sah
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
name|SAHTREE_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* search all status */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_alive
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: "
literal|"invalid sav->state (queue: %d SA: %d)\n"
operator|,
name|__func__
operator|,
name|state
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
name|spi
condition|)
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * copy SA values from PF_KEY message except *SPI, SEQ, PID, STATE and TYPE*.  * You must update these if need.  * OUT:	0:	success.  *	!0:	failure.  *  * does not modify mbuf.  does not free mbuf on error.  */
end_comment

begin_function
specifier|static
name|int
name|key_setsaval
parameter_list|(
name|sav
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* initialization */
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|schedlen
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|tdb_xform
operator|=
name|NULL
expr_stmt|;
comment|/* transform */
name|sav
operator|->
name|tdb_encalgxform
operator|=
name|NULL
expr_stmt|;
comment|/* encoding algorithm */
name|sav
operator|->
name|tdb_authalgxform
operator|=
name|NULL
expr_stmt|;
comment|/* authentication algorithm */
name|sav
operator|->
name|tdb_compalgxform
operator|=
name|NULL
expr_stmt|;
comment|/* compression algorithm */
comment|/*  Initialize even if NAT-T not compiled in: */
name|sav
operator|->
name|natt_type
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|natt_esp_frag_len
operator|=
literal|0
expr_stmt|;
comment|/* SA */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|sa0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sa0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|alg_auth
operator|=
name|sa0
operator|->
name|sadb_sa_auth
expr_stmt|;
name|sav
operator|->
name|alg_enc
operator|=
name|sa0
operator|->
name|sadb_sa_encrypt
expr_stmt|;
name|sav
operator|->
name|flags
operator|=
name|sa0
operator|->
name|sadb_sa_flags
expr_stmt|;
comment|/* replay window */
if|if
condition|(
operator|(
name|sa0
operator|->
name|sadb_sa_flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|==
literal|0
condition|)
block|{
name|sav
operator|->
name|replay
operator|=
operator|(
expr|struct
name|secreplay
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secreplay
argument_list|)
operator|+
name|sa0
operator|->
name|sadb_sa_replay
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sa0
operator|->
name|sadb_sa_replay
operator|!=
literal|0
condition|)
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sav
operator|->
name|replay
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|=
name|sa0
operator|->
name|sadb_sa_replay
expr_stmt|;
block|}
block|}
comment|/* Authentication keys */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|key0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_X_AALG_NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid key_auth values.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|key_auth
operator|=
operator|(
expr|struct
name|seckey
operator|*
operator|)
name|key_dup_keymsg
argument_list|(
name|key0
argument_list|,
name|len
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Encryption key */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|key0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sav
operator|->
name|key_enc
operator|=
operator|(
expr|struct
name|seckey
operator|*
operator|)
name|key_dup_keymsg
argument_list|(
name|key0
argument_list|,
name|len
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
if|if
condition|(
name|len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
comment|/*just in case*/
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid key_enc value.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* set iv */
name|sav
operator|->
name|ivlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_AH
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_SATYPE_ESP
case|:
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_ESP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_IPCOMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_TCPSIGNATURE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unable to initialize SA type %u.\n"
operator|,
name|__func__
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* reset created */
name|sav
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
comment|/* make lifetime for CURRENT */
name|sav
operator|->
name|lft_c
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seclifetime
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|lft_c
operator|->
name|allocations
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|addtime
operator|=
name|time_second
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|usetime
operator|=
literal|0
expr_stmt|;
comment|/* lifetimes for HARD and SOFT */
block|{
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|lft0
decl_stmt|;
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|lft_h
operator|=
name|key_dup_lifemsg
argument_list|(
name|lft0
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* to be initialize ? */
block|}
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|lft_s
operator|=
name|key_dup_lifemsg
argument_list|(
name|lft0
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* to be initialize ? */
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* initialization */
name|key_cleansav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * validation with a secasvar entry, and set SADB_SATYPE_MATURE.  * OUT:	0:	valid  *	other:	errno  */
end_comment

begin_function
specifier|static
name|int
name|key_mature
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* check SPI value */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* 		 * RFC 4302, 2.4. Security Parameters Index (SPI), SPI values 		 * 1-255 reserved by IANA for future use, 		 * 0 for implementation specific, local use. 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|<=
literal|255
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal range of SPI %u.\n"
operator|,
name|__func__
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
block|}
comment|/* check satype */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
comment|/* check flags */
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
operator|(
name|SADB_X_EXT_OLD
operator||
name|SADB_X_EXT_DERIV
operator|)
operator|)
operator|==
operator|(
name|SADB_X_EXT_OLD
operator||
name|SADB_X_EXT_DERIV
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid flag (derived) "
literal|"given to old-esp.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_ESP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
comment|/* check flags */
if|if
condition|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid flag (derived) "
literal|"given to AH SA.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_AH
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
if|if
condition|(
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_AALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_RAWCPI
operator|)
operator|==
literal|0
operator|&&
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid cpi for IPComp.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_IPCOMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_TCPSIGNATURE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid satype.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_MATURE
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * subroutine for SADB_GET and SADB_DUMP.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|satype
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|pid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|tres
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dumporder
index|[]
init|=
block|{
name|SADB_EXT_SA
block|,
name|SADB_X_EXT_SA2
block|,
name|SADB_EXT_LIFETIME_HARD
block|,
name|SADB_EXT_LIFETIME_SOFT
block|,
name|SADB_EXT_LIFETIME_CURRENT
block|,
name|SADB_EXT_ADDRESS_SRC
block|,
name|SADB_EXT_ADDRESS_DST
block|,
name|SADB_EXT_ADDRESS_PROXY
block|,
name|SADB_EXT_KEY_AUTH
block|,
name|SADB_EXT_KEY_ENCRYPT
block|,
name|SADB_EXT_IDENTITY_SRC
block|,
name|SADB_EXT_IDENTITY_DST
block|,
name|SADB_EXT_SENSITIVITY
block|,
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
name|SADB_X_EXT_NAT_T_TYPE
block|,
name|SADB_X_EXT_NAT_T_SPORT
block|,
name|SADB_X_EXT_NAT_T_DPORT
block|,
name|SADB_X_EXT_NAT_T_OAI
block|,
name|SADB_X_EXT_NAT_T_OAR
block|,
name|SADB_X_EXT_NAT_T_FRAG
block|,
endif|#
directive|endif
block|}
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|dumporder
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dumporder
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|dumporder
index|[
name|i
index|]
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_SA2
case|:
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_DST
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_KEY_AUTH
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_auth
condition|)
continue|continue;
name|m
operator|=
name|key_setkey
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_enc
condition|)
continue|continue;
name|m
operator|=
name|key_setkey
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_c
condition|)
continue|continue;
name|m
operator|=
name|key_setlifetime
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|,
name|SADB_EXT_LIFETIME_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_h
condition|)
continue|continue;
name|m
operator|=
name|key_setlifetime
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_s
condition|)
continue|continue;
name|m
operator|=
name|key_setlifetime
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
case|case
name|SADB_X_EXT_NAT_T_TYPE
case|:
name|m
operator|=
name|key_setsadbxtype
argument_list|(
name|sav
operator|->
name|natt_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_DPORT
case|:
name|m
operator|=
name|key_setsadbxport
argument_list|(
name|KEY_PORTFROMSADDR
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_SPORT
case|:
name|m
operator|=
name|key_setsadbxport
argument_list|(
name|KEY_PORTFROMSADDR
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|)
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_OAI
case|:
case|case
name|SADB_X_EXT_NAT_T_OAR
case|:
case|case
name|SADB_X_EXT_NAT_T_FRAG
case|:
comment|/* We do not (yet) support those. */
continue|continue;
endif|#
directive|endif
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
comment|/* XXX: should we brought from SPD ? */
case|case
name|SADB_EXT_SENSITIVITY
case|:
default|default:
continue|continue;
block|}
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|tres
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|tres
argument_list|)
expr_stmt|;
name|tres
operator|=
name|m
expr_stmt|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|tres
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tres
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_msg.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
parameter_list|(
name|u_int8_t
name|type
parameter_list|,
name|u_int16_t
name|tlen
parameter_list|,
name|u_int8_t
name|satype
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|u_int16_t
name|reserved
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|NULL
return|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_version
operator|=
name|PF_KEY_V2
expr_stmt|;
name|p
operator|->
name|sadb_msg_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_msg_satype
operator|=
name|satype
expr_stmt|;
name|p
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_reserved
operator|=
name|reserved
expr_stmt|;
name|p
operator|->
name|sadb_msg_seq
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_msg_pid
operator|=
operator|(
name|u_int32_t
operator|)
name|pid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * copy secasvar data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_sa
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|p
operator|->
name|sadb_sa_spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|p
operator|->
name|sadb_sa_replay
operator|=
operator|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|?
name|sav
operator|->
name|replay
operator|->
name|wsize
else|:
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_state
operator|=
name|sav
operator|->
name|state
expr_stmt|;
name|p
operator|->
name|sadb_sa_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|p
operator|->
name|sadb_sa_encrypt
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|p
operator|->
name|sadb_sa_flags
operator|=
name|sav
operator|->
name|flags
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
parameter_list|(
name|u_int16_t
name|exttype
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|saddr
parameter_list|,
name|u_int8_t
name|prefixlen
parameter_list|,
name|u_int16_t
name|ul_proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_address
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_address_proto
operator|=
name|ul_proto
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|==
name|FULLMASK
condition|)
block|{
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*XXX*/
block|}
block|}
name|p
operator|->
name|sadb_address_prefixlen
operator|=
name|prefixlen
expr_stmt|;
name|p
operator|->
name|sadb_address_reserved
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|saddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
argument_list|,
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_x_sa2.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
parameter_list|(
name|u_int8_t
name|mode
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|reqid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_sa2
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_sa2
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_exttype
operator|=
name|SADB_X_EXT_SA2
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_mode
operator|=
name|mode
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved2
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_sequence
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reqid
operator|=
name|reqid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
end_ifdef

begin_comment
comment|/*  * Set a type in sadb_x_nat_t_type.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxtype
parameter_list|(
name|u_int16_t
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sadb_x_nat_t_type
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_nat_t_type
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_exttype
operator|=
name|SADB_X_EXT_NAT_T_TYPE
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a port in sadb_x_nat_t_port.  * In contrast to default RFC 2367 behaviour, port is in network byte order.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxport
parameter_list|(
name|u_int16_t
name|port
parameter_list|,
name|u_int16_t
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sadb_x_nat_t_port
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_nat_t_port
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_exttype
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Get port from sockaddr. Port is in network byte order.  */
end_comment

begin_function
name|u_int16_t
name|key_portfromsaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
return|return
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
return|;
endif|#
directive|endif
block|}
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s unexpected address family %d\n"
argument_list|,
name|__func__
argument_list|,
name|sa
operator|->
name|sa_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC_NAT_T */
end_comment

begin_comment
comment|/*  * Set port in struct sockaddr. Port is in network byte order.  */
end_comment

begin_function
specifier|static
name|void
name|key_porttosaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unexpected address family %d.\n"
operator|,
name|__func__
operator|,
name|sa
operator|->
name|sa_family
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * set data into sadb_x_policy  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
parameter_list|(
name|u_int16_t
name|type
parameter_list|,
name|u_int8_t
name|dir
parameter_list|,
name|u_int32_t
name|id
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_dir
operator|=
name|dir
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_id
operator|=
name|id
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* %%% utilities */
end_comment

begin_comment
comment|/* Take a key message (sadb_key) from the socket and turn it into one  * of the kernel's key structures (seckey).  *  * IN: pointer to the src  * OUT: NULL no more memory  */
end_comment

begin_function
name|struct
name|seckey
modifier|*
name|key_dup_keymsg
parameter_list|(
specifier|const
name|struct
name|sadb_key
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|seckey
modifier|*
name|dst
decl_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|seckey
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seckey
argument_list|)
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|->
name|bits
operator|=
name|src
operator|->
name|sadb_key_bits
expr_stmt|;
name|dst
operator|->
name|key_data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|key_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|,
name|dst
operator|->
name|key_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* Take a lifetime message (sadb_lifetime) passed in on a socket and  * turn it into one of the kernel's lifetime structures (seclifetime).  *  * IN: pointer to the destination, source and malloc type  * OUT: NULL, no more memory  */
end_comment

begin_function
specifier|static
name|struct
name|seclifetime
modifier|*
name|key_dup_lifemsg
parameter_list|(
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|src
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|seclifetime
modifier|*
name|dst
init|=
name|NULL
decl_stmt|;
name|dst
operator|=
operator|(
expr|struct
name|seclifetime
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seclifetime
argument_list|)
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
comment|/* XXX counter */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|allocations
operator|=
name|src
operator|->
name|sadb_lifetime_allocations
expr_stmt|;
name|dst
operator|->
name|bytes
operator|=
name|src
operator|->
name|sadb_lifetime_bytes
expr_stmt|;
name|dst
operator|->
name|addtime
operator|=
name|src
operator|->
name|sadb_lifetime_addtime
expr_stmt|;
name|dst
operator|->
name|usetime
operator|=
name|src
operator|->
name|sadb_lifetime_usetime
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* compare my own address  * OUT:	1: true, i.e. my address.  *	0: false  */
end_comment

begin_function
name|int
name|key_ismyaddr
parameter_list|(
name|sa
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
endif|#
directive|endif
name|IPSEC_ASSERT
argument_list|(
name|sa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sockaddr"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|IN_IFADDR_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|ia
operator|=
name|V_in_ifaddrhead
operator|.
name|tqh_first
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_link
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_family
operator|&&
name|sin
operator|->
name|sin_len
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_len
operator|&&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|IN_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|IN_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
name|key_ismyaddr6
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * compare my own address for IPv6.  * 1: ours  * 0: other  * NOTE: derived ip6_input() in KAME. This is necessary to modify more.  */
end_comment

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_function
specifier|static
name|int
name|key_ismyaddr6
parameter_list|(
name|sin6
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
if|#
directive|if
literal|0
block|struct in6_multi *in6m;
endif|#
directive|endif
name|IN6_IFADDR_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|&V_in6_ifaddrhead
argument_list|,
argument|ia_link
argument_list|)
block|{
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IN6_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * XXX Multicast 		 * XXX why do we care about multlicast here while we don't care 		 * about IPv4 multicast?? 		 * XXX scope 		 */
block|in6m = NULL; 		IN6_LOOKUP_MULTI(sin6->sin6_addr, ia->ia_ifp, in6m); 		if (in6m) { 			IN6_IFADDR_RUNLOCK(); 			return 1; 		}
endif|#
directive|endif
block|}
name|IN6_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* loopback, just for safety */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*INET6*/
end_comment

begin_comment
comment|/*  * compare two secasindex structure.  * flag can specify to compare 2 saidxes.  * compare two secasindex structure without both mode and reqid.  * don't compare port.  * IN:    *      saidx0: source, it can be in SAD.  *      saidx1: object.  * OUT:   *      1 : equal  *      0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpsaidx
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx0
parameter_list|,
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx1
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|chkport
init|=
literal|0
decl_stmt|;
comment|/* sanity */
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|&&
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|||
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|proto
operator|!=
name|saidx1
operator|->
name|proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag
operator|==
name|CMP_EXACTLY
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
argument_list|,
operator|&
name|saidx1
operator|->
name|src
argument_list|,
name|saidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
argument_list|,
name|saidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* CMP_MODE_REQID, CMP_REQID, CMP_HEAD */
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
operator|||
name|flag
operator|==
name|CMP_REQID
condition|)
block|{
comment|/* 			 * If reqid of SPD is non-zero, unique SA is required. 			 * The result must be of same reqid in this case. 			 */
if|if
condition|(
name|saidx1
operator|->
name|reqid
operator|!=
literal|0
operator|&&
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|IPSEC_MODE_ANY
operator|&&
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 		 * If NAT-T is enabled, check ports for tunnel mode. 		 * Do not check ports if they are set to zero in the SPD. 		 * Also do not do it for transport mode, as there is no 		 * port information available in the SP. 		 */
if|if
condition|(
name|saidx1
operator|->
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
operator|&&
name|saidx1
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|saidx1
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|saidx1
operator|->
name|src
operator|)
operator|)
operator|->
name|sin_port
operator|&&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|saidx1
operator|->
name|dst
operator|)
operator|)
operator|->
name|sin_port
condition|)
name|chkport
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_NAT_T */
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|saidx1
operator|->
name|src
operator|.
name|sa
argument_list|,
name|chkport
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
operator|.
name|sa
argument_list|,
name|chkport
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * compare two secindex structure exactly.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from PFKEY message.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_exactly
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx0
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx1
parameter_list|)
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|prefs
operator|!=
name|spidx1
operator|->
name|prefs
operator|||
name|spidx0
operator|->
name|prefd
operator|!=
name|spidx1
operator|->
name|prefd
operator|||
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
return|return
name|key_sockaddrcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sa
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|key_sockaddrcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sa
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * compare two secindex structure with mask.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from IP header.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_withmask
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx0
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx1
parameter_list|)
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|||
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
condition|)
return|return
literal|0
return|;
comment|/* if spidx.ul_proto == IPSEC_ULPROTO_ANY, ignore. */
if|if
condition|(
name|spidx0
operator|->
name|ul_proto
operator|!=
operator|(
name|u_int16_t
operator|)
name|IPSEC_ULPROTO_ANY
operator|&&
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|,
operator|&
name|spidx1
operator|->
name|src
argument_list|,
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
switch|switch
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
argument_list|,
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* XXX Do we check other field ?  e.g. flowinfo */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* returns 0 on match */
end_comment

begin_function
specifier|static
name|int
name|key_sockaddrcmp
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|,
name|int
name|port
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|satosin
undef|#
directive|undef
name|satosin
endif|#
directive|endif
define|#
directive|define
name|satosin
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in *)s)
ifdef|#
directive|ifdef
name|satosin6
undef|#
directive|undef
name|satosin6
endif|#
directive|endif
define|#
directive|define
name|satosin6
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in6 *)s)
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
operator|||
name|sa1
operator|->
name|sa_len
operator|!=
name|sa2
operator|->
name|sa_len
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_port
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_port
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/*EINVAL*/
if|if
condition|(
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_scope_id
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_port
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_port
condition|)
block|{
return|return
literal|1
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|bcmp
argument_list|(
name|sa1
argument_list|,
name|sa2
argument_list|,
name|sa1
operator|->
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|satosin
undef|#
directive|undef
name|satosin6
block|}
end_function

begin_comment
comment|/*  * compare two buffers with mask.  * IN:  *	addr1: source  *	addr2: object  *	bits:  Number of bits to compare  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_bbcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a1
parameter_list|,
specifier|const
name|void
modifier|*
name|a2
parameter_list|,
name|u_int
name|bits
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p1
init|=
name|a1
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p2
init|=
name|a2
decl_stmt|;
comment|/* XXX: This could be considerably faster if we compare a word 	 * at a time, but it is complicated on LSB Endian machines */
comment|/* Handle null pointers */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
return|return
operator|(
name|p1
operator|==
name|p2
operator|)
return|;
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|0
return|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|u_int8_t
name|mask
init|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p1
operator|&
name|mask
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|&
name|mask
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Match! */
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_spd
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
specifier|static
name|u_int16_t
name|sptree_scangen
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|gen
init|=
name|sptree_scangen
operator|++
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
comment|/* SPD */
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|restart
label|:
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|scangen
operator|==
name|gen
condition|)
comment|/* previously handled */
continue|continue;
name|sp
operator|->
name|scangen
operator|=
name|gen
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
operator|&&
name|sp
operator|->
name|refcnt
operator|==
literal|1
condition|)
block|{
comment|/* 				 * Ensure that we only decrease refcnt once, 				 * when we're the last consumer. 				 * Directly call SP_DELREF/key_delsp instead 				 * of KEY_FREESP to avoid unlocking/relocking 				 * SPTREE_LOCK before key_delsp: may refcnt 				 * be increased again during that time ? 				 * NB: also clean entries created by 				 * key_spdflush 				 */
name|SP_DELREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|key_delsp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|sp
operator|->
name|lifetime
operator|==
literal|0
operator|&&
name|sp
operator|->
name|validtime
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|lifetime
operator|&&
name|now
operator|-
name|sp
operator|->
name|created
operator|>
name|sp
operator|->
name|lifetime
operator|)
operator|||
operator|(
name|sp
operator|->
name|validtime
operator|&&
name|now
operator|-
name|sp
operator|->
name|lastused
operator|>
name|sp
operator|->
name|validtime
operator|)
condition|)
block|{
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
name|key_spdexpire
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_sad
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
comment|/* SAD */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|,
argument|nextsah
argument_list|)
block|{
comment|/* if sah has been dead, then delete it and process next sah. */
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|key_delsah
argument_list|(
name|sah
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if LARVAL entry doesn't become MATURE, delete it. */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[SADB_SASTATE_LARVAL]
argument_list|,
argument|chain
argument_list|,
argument|nextsav
argument_list|)
block|{
comment|/* Need to also check refcnt for a larval SA ??? */
if|if
condition|(
name|now
operator|-
name|sav
operator|->
name|created
operator|>
name|V_key_larval_lifetime
condition|)
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * check MATURE entry to start to send expire message 		 * whether or not. 		 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[SADB_SASTATE_MATURE]
argument_list|,
argument|chain
argument_list|,
argument|nextsav
argument_list|)
block|{
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there is no CURRENT "
literal|"time, why?\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check SOFT lifetime */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|addtime
operator|!=
literal|0
operator|&&
name|now
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_s
operator|->
name|addtime
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/*  				 * Actually, only send expire message if 				 * SA has been used, as it was done before, 				 * but should we always send such message, 				 * and let IKE daemon decide if it should be 				 * renegotiated or not ? 				 * XXX expire message will actually NOT be 				 * sent if SA is only used after soft 				 * lifetime has been reached, see below 				 * (DYING state) 				 */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|->
name|usetime
operator|!=
literal|0
condition|)
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
comment|/* check SOFT lifetime by bytes */
comment|/* 			 * XXX I don't know the way to delete this SA 			 * when new SA is installed.  Caution when it's 			 * installed too big lifetime by time. 			 */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_s
operator|->
name|bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/* 				 * XXX If we keep to send expire 				 * message in the status of 				 * DYING. Do remove below code. 				 */
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check DYING entry to change status to DEAD. */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[SADB_SASTATE_DYING]
argument_list|,
argument|chain
argument_list|,
argument|nextsav
argument_list|)
block|{
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there is no CURRENT "
literal|"time, why?\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|addtime
operator|!=
literal|0
operator|&&
name|now
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_h
operator|->
name|addtime
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX Should we keep to send expire message until HARD lifetime ? */
if|else if (sav->lft_s != NULL&& sav->lft_s->addtime != 0&& now - sav->created> sav->lft_s->addtime) {
comment|/* 				 * XXX: should be checked to be 				 * installed the valid SA. 				 */
comment|/* 				 * If there is no SA then sending 				 * expire message. 				 */
if|key_expire(sav); 			}
endif|#
directive|endif
comment|/* check HARD lifetime by bytes */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_h
operator|->
name|bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* delete entry in DEAD */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[SADB_SASTATE_DEAD]
argument_list|,
argument|chain
argument_list|,
argument|nextsav
argument_list|)
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_DEAD
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sav->state "
literal|"(queue: %d SA: %d): kill it anyway\n"
operator|,
name|__func__
operator|,
name|SADB_SASTATE_DEAD
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * do not call key_freesav() here. 			 * sav should already be freed, and sav->refcnt 			 * shows other references to sav 			 * (such as from SPD). 			 */
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_acq
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
comment|/* ACQ tree */
name|ACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_acqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|acq
operator|->
name|created
operator|>
name|V_key_blockacq_lifetime
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_spacq
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
comment|/* SP ACQ tree */
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|acq
operator|->
name|created
operator|>
name|V_key_blockacq_lifetime
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * time handler.  * scanning SPD and SAD to check status for each entries,  * and do to remove or to expire.  * XXX: year 2038 problem may remain.  */
end_comment

begin_function
name|void
name|key_timehandler
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|time_t
name|now
init|=
name|time_second
decl_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|key_flush_spd
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_sad
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_acq
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_spacq
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
comment|/* do exchange to tick time !! */
operator|(
name|void
operator|)
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_DEBUG2 */
block|}
end_function

begin_function
name|u_long
name|key_random
parameter_list|()
block|{
name|u_long
name|value
decl_stmt|;
name|key_randomfill
argument_list|(
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|key_randomfill
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
block|{
name|size_t
name|n
decl_stmt|;
name|u_long
name|v
decl_stmt|;
specifier|static
name|int
name|warn
init|=
literal|1
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|size_t
operator|)
name|read_random
argument_list|(
name|p
argument_list|,
operator|(
name|u_int
operator|)
name|l
argument_list|)
expr_stmt|;
comment|/* last resort */
while|while
condition|(
name|n
operator|<
name|l
condition|)
block|{
name|v
operator|=
name|random
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|p
operator|+
name|n
argument_list|,
name|l
operator|-
name|n
operator|<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|?
name|l
operator|-
name|n
else|:
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: pseudo-random number generator "
literal|"used for IPsec processing\n"
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * map SADB_SATYPE_* to IPPROTO_*.  * if satype == SADB_SATYPE then satype is mapped to ~0.  * OUT:  *	0: invalid satype.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_satype2proto
parameter_list|(
name|u_int8_t
name|satype
parameter_list|)
block|{
switch|switch
condition|(
name|satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
return|return
name|IPSEC_PROTO_ANY
return|;
case|case
name|SADB_SATYPE_AH
case|:
return|return
name|IPPROTO_AH
return|;
case|case
name|SADB_SATYPE_ESP
case|:
return|return
name|IPPROTO_ESP
return|;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
return|return
name|IPPROTO_IPCOMP
return|;
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
return|return
name|IPPROTO_TCP
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * map IPPROTO_* to SADB_SATYPE_*  * OUT:  *	0: invalid protocol type.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|key_proto2satype
parameter_list|(
name|u_int16_t
name|proto
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
return|return
name|SADB_SATYPE_AH
return|;
case|case
name|IPPROTO_ESP
case|:
return|return
name|SADB_SATYPE_ESP
return|;
case|case
name|IPPROTO_IPCOMP
case|:
return|return
name|SADB_X_SATYPE_IPCOMP
return|;
case|case
name|IPPROTO_TCP
case|:
return|return
name|SADB_X_SATYPE_TCPSIGNATURE
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* %%% PF_KEY */
end_comment

begin_comment
comment|/*  * SADB_GETSPI processing is to receive  *<base, (SA2), src address, dst address, (SPI range)>  * from the IKMPd, to assign a unique spi value, to hang on the INBOUND  * tree with the status of LARVAL, and send  *<base, SA(*), address(SD)>  * to the IKMPd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|int
name|key_getspi
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*???*/
block|}
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*???*/
block|}
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 * We made sure the port numbers are zero above, so we do 	 * not have to worry in case we do not update them. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
operator|!=
name|NULL
condition|)
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: NAT-T OAi present\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
operator|!=
name|NULL
condition|)
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: NAT-T OAr present\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_type
modifier|*
name|type
decl_stmt|;
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|type
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid nat-t message "
literal|"passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SPI allocation */
name|spi
operator|=
name|key_do_getnewspi
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SPIRANGE
index|]
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|==
literal|0
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
comment|/* get a SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
block|}
comment|/* get a new SA */
comment|/* XXX rewrite */
name|newsav
operator|=
name|KEY_NEWSAV
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
name|newsah
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
comment|/* XXX don't free new SA index allocated in above. */
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* set spi */
name|newsav
operator|->
name|spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
comment|/* delete the entry in acqtree */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|!=
literal|0
condition|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* reset counter in order to deletion by timehandler. */
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|m_sa
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length inconsistency (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
name|newsav
operator|->
name|seq
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocating new SPI  * called by key_getspi().  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|key_do_getnewspi
parameter_list|(
name|spirange
parameter_list|,
name|saidx
parameter_list|)
name|struct
name|sadb_spirange
modifier|*
name|spirange
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|u_int32_t
name|newspi
decl_stmt|;
name|u_int32_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|count
init|=
name|V_key_spi_trycnt
decl_stmt|;
comment|/* set spi range to allocate */
if|if
condition|(
name|spirange
operator|!=
name|NULL
condition|)
block|{
name|min
operator|=
name|spirange
operator|->
name|sadb_spirange_min
expr_stmt|;
name|max
operator|=
name|spirange
operator|->
name|sadb_spirange_max
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|V_key_spi_minval
expr_stmt|;
name|max
operator|=
name|V_key_spi_maxval
expr_stmt|;
block|}
comment|/* IPCOMP needs 2-byte SPI */
if|if
condition|(
name|saidx
operator|->
name|proto
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
name|u_int32_t
name|t
decl_stmt|;
if|if
condition|(
name|min
operator|>=
literal|0x10000
condition|)
name|min
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|max
operator|>=
literal|0x10000
condition|)
name|max
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|t
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|min
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SPI %u exists already.\n"
operator|,
name|__func__
operator|,
name|min
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* taking one cost. */
name|newspi
operator|=
name|min
expr_stmt|;
block|}
else|else
block|{
comment|/* init SPI */
name|newspi
operator|=
literal|0
expr_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* generate pseudo-random SPI value ranged. */
name|newspi
operator|=
name|min
operator|+
operator|(
name|key_random
argument_list|()
operator|%
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|newspi
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newspi
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: to allocate spi is failed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* statistics */
name|keystat
operator|.
name|getspi_count
operator|=
operator|(
name|keystat
operator|.
name|getspi_count
operator|+
name|V_key_spi_trycnt
operator|-
name|count
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|newspi
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_UPDATE processing  * receive  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd, and update a secasvar entry whose status is SADB_SASTATE_LARVAL.  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_update
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
name|struct
name|sadb_x_nat_t_type
modifier|*
name|type
decl_stmt|;
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|iaddr
decl_stmt|,
modifier|*
name|raddr
decl_stmt|;
name|struct
name|sadb_x_nat_t_frag
modifier|*
name|frag
decl_stmt|;
endif|#
directive|endif
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX boundary checking for other extensions */
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|type
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|type
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_type
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
expr_stmt|;
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|0
expr_stmt|;
name|sport
operator|=
name|dport
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|iaddr
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|raddr
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|iaddr
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
expr_stmt|;
name|raddr
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: NAT-T OAi/r present\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iaddr
operator|=
name|raddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|frag
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_frag
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
expr_stmt|;
block|}
else|else
block|{
name|frag
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get a SA header */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA index found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
comment|/* set spidx if there */
comment|/* XXX rewrite */
name|error
operator|=
name|key_setident
argument_list|(
name|sah
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
comment|/* find a SA with sequence number. */
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|!=
literal|0
operator|&&
operator|(
name|sav
operator|=
name|key_getsavbyseq
argument_list|(
name|sah
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no larval SA with sequence %u "
literal|"exists.\n"
operator|,
name|__func__
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
else|#
directive|else
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no such a SA found (spi:%u)\n"
operator|,
name|__func__
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* validity check */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol mismatched "
literal|"(DB=%u param=%u)\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
if|if
condition|(
name|sav
operator|->
name|spi
operator|!=
name|sa0
operator|->
name|sadb_sa_spi
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SPI mismatched (DB:%u param:%u)\n"
operator|,
name|__func__
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sav
operator|->
name|pid
operator|!=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: pid mismatched (DB:%u param:%u)\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|pid
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* copy sav values */
name|error
operator|=
name|key_setsaval
argument_list|(
name|sav
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|key_mature
argument_list|(
name|sav
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle more NAT-T info if present, 	 * now that we have a sav to fill. 	 */
if|if
condition|(
name|type
condition|)
name|sav
operator|->
name|natt_type
operator|=
name|type
operator|->
name|sadb_x_nat_t_type_type
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * In case SADB_X_EXT_NAT_T_FRAG was not given, leave it at 0. 	 * We should actually check for a minimum MTU here, if we 	 * want to support it in ip_output. 	 */
block|if (frag) 		sav->natt_esp_frag_len = frag->sadb_x_nat_t_frag_fraglen;
endif|#
directive|endif
endif|#
directive|endif
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * search SAD with sequence for a SA which state is SADB_SASTATE_LARVAL.  * only called by key_update().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
end_ifdef

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
parameter_list|(
name|sah
parameter_list|,
name|seq
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
comment|/* search SAD with sequence number ? */
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|seq
operator|==
name|seq
condition|)
block|{
name|sa_addref
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP %s cause refcnt++:%d SA:%p\n"
argument_list|,
name|__func__
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SADB_ADD processing  * add an entry to SA database, when received  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd,  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IGNORE identity and sensitivity messages.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_add
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
name|struct
name|sadb_x_nat_t_type
modifier|*
name|type
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|iaddr
decl_stmt|,
modifier|*
name|raddr
decl_stmt|;
name|struct
name|sadb_x_nat_t_frag
modifier|*
name|frag
decl_stmt|;
endif|#
directive|endif
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
comment|/* XXX need more */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|type
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|type
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_type
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
expr_stmt|;
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|iaddr
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|raddr
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|iaddr
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
expr_stmt|;
name|raddr
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: NAT-T OAi/r present\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iaddr
operator|=
name|raddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|frag
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_frag
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_FRAG
index|]
expr_stmt|;
block|}
else|else
block|{
name|frag
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get a SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
block|}
comment|/* set spidx if there */
comment|/* XXX rewrite */
name|error
operator|=
name|key_setident
argument_list|(
name|newsah
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* create new SA entry. */
comment|/* We can create new SA only if SPI is differenct. */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|newsav
operator|=
name|key_getsavbyspi
argument_list|(
name|newsah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|newsav
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SA already exists.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|newsav
operator|=
name|KEY_NEWSAV
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
name|newsah
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|error
operator|=
name|key_mature
argument_list|(
name|newsav
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|KEY_FREESAV
argument_list|(
operator|&
name|newsav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle more NAT-T info if present, 	 * now that we have a sav to fill. 	 */
if|if
condition|(
name|type
condition|)
name|newsav
operator|->
name|natt_type
operator|=
name|type
operator|->
name|sadb_x_nat_t_type_type
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * In case SADB_X_EXT_NAT_T_FRAG was not given, leave it at 0. 	 * We should actually check for a minimum MTU here, if we 	 * want to support it in ip_output. 	 */
block|if (frag) 		newsav->natt_esp_frag_len = frag->sadb_x_nat_t_frag_fraglen;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * don't call key_freesav() here, as we would like to keep the SA 	 * in the database on success. 	 */
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* m is retained */
end_comment

begin_function
specifier|static
name|int
name|key_setident
parameter_list|(
name|sah
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
specifier|const
name|struct
name|sadb_ident
modifier|*
name|idsrc
decl_stmt|,
modifier|*
name|iddst
decl_stmt|;
name|int
name|idsrclen
decl_stmt|,
name|iddstlen
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secashead"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* don't make buffer if not there */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid identity.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|idsrc
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddst
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
name|idsrclen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddstlen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|idsrc
operator|->
name|sadb_ident_type
operator|!=
name|iddst
operator|->
name|sadb_ident_type
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: ident type mismatch.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|idsrc
operator|->
name|sadb_ident_type
condition|)
block|{
case|case
name|SADB_IDENTTYPE_PREFIX
case|:
case|case
name|SADB_IDENTTYPE_FQDN
case|:
case|case
name|SADB_IDENTTYPE_USERFQDN
case|:
default|default:
comment|/* XXX do nothing */
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* make structure */
name|sah
operator|->
name|idents
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secident
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|idents
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|sah
operator|->
name|identd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secident
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|identd
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sah
operator|->
name|idents
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|sah
operator|->
name|idents
operator|->
name|type
operator|=
name|idsrc
operator|->
name|sadb_ident_type
expr_stmt|;
name|sah
operator|->
name|idents
operator|->
name|id
operator|=
name|idsrc
operator|->
name|sadb_ident_id
expr_stmt|;
name|sah
operator|->
name|identd
operator|->
name|type
operator|=
name|iddst
operator|->
name|sadb_ident_type
expr_stmt|;
name|sah
operator|->
name|identd
operator|->
name|id
operator|=
name|iddst
operator|->
name|sadb_ident_id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * m will not be freed on return.  * it is caller's responsibility to free the result.   */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_X_EXT_SA2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|key_delete_all
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SADB_DELETE processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and set SADB_SASTATE_DEAD,  * and send,  *<base, SA(*), address(SD)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_delete
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Caller wants us to delete all non-LARVAL SAs 		 * that match the src/dst.  This is used during 		 * IKE INITIAL-CONTACT. 		 */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: doing delete all.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_delete_all
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|,
name|proto
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get a SA header */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
comment|/* XXX-BZ NAT-T extensions? */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * delete all SAs for src/dst.  Called from key_delete().  */
end_comment

begin_function
specifier|static
name|int
name|key_delete_all
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|u_int16_t
name|proto
parameter_list|)
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Delete all non-LARVAL SAs. */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_alive
index|[
name|stateidx
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SADB_SASTATE_LARVAL
condition|)
continue|continue;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"sav->state (queue %d SA %d)\n"
operator|,
name|__func__
operator|,
name|state
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
comment|/* XXX-BZ NAT-T extensions? */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_GET processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and get a SP and a SA to respond,  * and send,  *<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE),  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_get
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get a SA header */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
condition|)
break|break;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there was invalid proto in SAD.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_GET
argument_list|,
name|satype
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* XXX make it sysctl-configurable? */
end_comment

begin_function
specifier|static
name|void
name|key_getcomb_setlifetime
parameter_list|(
name|comb
parameter_list|)
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
block|{
name|comb
operator|->
name|sadb_comb_soft_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_addtime
operator|=
literal|86400
expr_stmt|;
comment|/* 1 day */
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|=
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_usetime
operator|=
literal|28800
expr_stmt|;
comment|/* 8 hours */
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|=
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX reorder combinations by preference  * XXX no idea if the user wants ESP authentication or not  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_esp
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|struct
name|enc_xform
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|encmin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|,
name|o
decl_stmt|;
name|int
name|totlen
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|NULL
condition|)
continue|continue;
comment|/* discard algorithms with key size smaller than system min */
if|if
condition|(
name|_BITS
argument_list|(
name|algo
operator|->
name|maxkey
argument_list|)
operator|<
name|V_ipsec_esp_keymin
condition|)
continue|continue;
if|if
condition|(
name|_BITS
argument_list|(
name|algo
operator|->
name|minkey
argument_list|)
operator|<
name|V_ipsec_esp_keymin
condition|)
name|encmin
operator|=
name|V_ipsec_esp_keymin
expr_stmt|;
else|else
name|encmin
operator|=
name|_BITS
argument_list|(
name|algo
operator|->
name|minkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_ipsec_esp_auth
condition|)
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
else|else
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
operator|(
name|totlen
operator|%
name|l
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"totlen=%u, l=%u"
operator|,
name|totlen
operator|,
name|l
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|totlen
condition|;
name|off
operator|+=
name|l
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|l
argument_list|,
operator|&
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
goto|goto
name|fail
goto|;
block|}
name|comb
operator|=
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|o
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_minbits
operator|=
name|encmin
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_maxbits
operator|=
name|_BITS
argument_list|(
name|algo
operator|->
name|maxkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|m
expr_stmt|;
else|else
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_getsizes_ah
parameter_list|(
specifier|const
name|struct
name|auth_hash
modifier|*
name|ah
parameter_list|,
name|int
name|alg
parameter_list|,
name|u_int16_t
modifier|*
name|min
parameter_list|,
name|u_int16_t
modifier|*
name|max
parameter_list|)
block|{
operator|*
name|min
operator|=
operator|*
name|max
operator|=
name|ah
operator|->
name|keysize
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|keysize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Transform takes arbitrary key size but algorithm 		 * key size is restricted.  Enforce this here. 		 */
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|SADB_X_AALG_MD5
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_SHA
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_NULL
case|:
operator|*
name|min
operator|=
literal|1
expr_stmt|;
operator|*
name|max
operator|=
literal|256
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unknown AH algorithm %u\n"
operator|,
name|__func__
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|struct
name|auth_hash
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|minkeysize
decl_stmt|,
name|maxkeysize
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|1
comment|/* we prefer HMAC algorithms, not old algorithms */
if|if
condition|(
name|i
operator|!=
name|SADB_AALG_SHA1HMAC
operator|&&
name|i
operator|!=
name|SADB_AALG_MD5HMAC
condition|)
continue|continue;
endif|#
directive|endif
name|algo
operator|=
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
name|key_getsizes_ah
argument_list|(
name|algo
argument_list|,
name|i
argument_list|,
operator|&
name|minkeysize
argument_list|,
operator|&
name|maxkeysize
argument_list|)
expr_stmt|;
comment|/* discard algorithms with key size smaller than system min */
if|if
condition|(
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
operator|<
name|V_ipsec_ah_keymin
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_minbits
operator|=
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_maxbits
operator|=
name|_BITS
argument_list|(
name|maxkeysize
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * not really an official behavior.  discussed in pf_key@inner.net in Sep2000.  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|struct
name|comp_algo
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_X_CALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|ipcomp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
comment|/* what should we set into sadb_comb_*_{min,max}bits? */
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * XXX no way to pass mode (transport/tunnel) to userland  * XXX replay checking?  * XXX sysctl interface to ipsec_{ah,esp}_keymin  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
parameter_list|(
name|saidx
parameter_list|)
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|sadb_prop
modifier|*
name|prop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|totlen
decl_stmt|;
switch|switch
condition|(
name|saidx
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
name|m
operator|=
name|key_getcomb_esp
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
name|m
operator|=
name|key_getcomb_ipcomp
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|prop
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_prop
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_exttype
operator|=
name|SADB_EXT_PROPOSAL
expr_stmt|;
name|prop
operator|->
name|sadb_prop_replay
operator|=
literal|32
expr_stmt|;
comment|/* XXX */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing called by key_checkrequest() and key_acquire2().  * send  *<base, SA, address(SD), (address(P)), x_policy,  *       (identity(SD),) (sensitivity,) proposal>  * to KMD, and expect to receive  *<base> with SADB_ACQUIRE if error occured,  * or  *<base, src address, dst address, (SPI range)> with SADB_GETSPI  * from KMD by PF_KEY.  *  * XXX x_policy is outside of RFC2367 (KAME extension).  * XXX sensitivity is not supported.  * XXX for ipcomp, RFC2367 does not define how to fill in proposal.  * see comment for key_getcomb_ipcomp().  *  * OUT:  *    0     : succeed  *    others: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null saidx"
operator|)
argument_list|)
expr_stmt|;
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|saidx
operator|->
name|proto
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|satype
operator|!=
literal|0
argument_list|,
operator|(
literal|"null satype, protocol %u"
operator|,
name|saidx
operator|->
name|proto
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We never do anything about acquirng SA.  There is anather 	 * solution that kernel blocks to send SADB_ACQUIRE message until 	 * getting something message from IKEd.  In later case, to be 	 * managed with ACQUIRING list. 	 */
comment|/* Get an entry to check whether sending message or not. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_getacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|V_key_blockacq_count
operator|<
name|newacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newacq
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_newacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
block|}
name|seq
operator|=
name|newacq
operator|->
name|seq
expr_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_ACQUIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* 	 * No SADB_X_EXT_NAT_T_* here: we do not know 	 * anything related to NAT-T at this time. 	 */
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|saidx
operator|->
name|src
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX proxy address (optional) */
comment|/* set sadb_x_policy */
if|if
condition|(
name|sp
condition|)
block|{
name|m
operator|=
name|key_setsadbxpolicy
argument_list|(
name|sp
operator|->
name|policy
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|sp
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX identity (optional) */
if|#
directive|if
literal|0
block|if (idexttype&& fqdn) {
comment|/* create identity extension (FQDN) */
block|struct sadb_ident *id; 		int fqdnlen;  		fqdnlen = strlen(fqdn) + 1;
comment|/* +1 for terminating-NUL */
block|id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_FQDN; 		bcopy(fqdn, id + 1, fqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(fqdnlen); 	}  	if (idexttype) {
comment|/* create identity extension (USERFQDN) */
block|struct sadb_ident *id; 		int userfqdnlen;  		if (userfqdn) {
comment|/* +1 for terminating-NUL */
block|userfqdnlen = strlen(userfqdn) + 1; 		} else 			userfqdnlen = 0; 		id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
comment|/* XXX is it correct? */
block|if (curproc&& curproc->p_cred) 			id->sadb_ident_id = curproc->p_cred->p_ruid; 		if (userfqdn&& userfqdnlen) 			bcopy(userfqdn, id + 1, userfqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(userfqdnlen); 	}
endif|#
directive|endif
comment|/* XXX sensitivity (optional) */
comment|/* create proposal/combination extension */
name|m
operator|=
name|key_getprop
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * spec conformant: always attach proposal/combination extension, 	 * the problem is that we have no way to attach it for ipcomp, 	 * due to the way sadb_comb is declared in RFC2367. 	 */
block|if (!m) { 		error = ENOBUFS; 		goto fail; 	} 	m_cat(result, m);
else|#
directive|else
comment|/* 	 * outside of spec; make proposal/combination extension optional. 	 */
if|if
condition|(
name|m
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
comment|/* get new entry */
name|newacq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secacq
argument_list|)
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newacq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy secindex */
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|newacq
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|newacq
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
name|newacq
operator|->
name|seq
operator|=
operator|(
name|V_acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|V_acq_seq
operator|)
expr_stmt|;
name|newacq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* add to acqtree */
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_acqtree
argument_list|,
name|newacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|newacq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&V_acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
name|saidx
argument_list|,
operator|&
name|acq
operator|->
name|saidx
argument_list|,
name|CMP_EXACTLY
argument_list|)
condition|)
break|break;
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|acq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
parameter_list|(
name|seq
parameter_list|)
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&V_acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|acq
operator|->
name|seq
operator|==
name|seq
condition|)
break|break;
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|acq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
comment|/* get new entry */
name|acq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secspacq
argument_list|)
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy secindex */
name|bcopy
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|,
sizeof|sizeof
argument_list|(
name|acq
operator|->
name|spidx
argument_list|)
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* add to spacqtree */
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_spacqtree
argument_list|,
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|acq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&V_spacqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|)
condition|)
block|{
comment|/* NB: return holding spacq_lock */
return|return
name|acq
return|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing,  * in first situation, is receiving  *<base>  * from the ikmpd, and clear sequence of its secasvar entry.  *  * In second situation, is receiving  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * from a user land process, and return  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * to the socket.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire2
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
specifier|const
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Error message from KMd. 	 * We assume that if error was occured in IKEd, the length of PFKEY 	 * message is equal to the size of sadb_msg structure. 	 * We do not raise error even if error occured in this function. 	 */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
operator|==
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
comment|/* check sequence number */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: must specify sequence "
literal|"number.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * the specified larval SA is already gone, or we got 			 * a bogus sequence number.  we can silently ignore it. 			 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* reset acq counter in order to deletion by timehander. */
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * This message is from user land. 	 */
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_PROPOSAL
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* error */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_PROPOSAL
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
condition|)
block|{
comment|/* error */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the port numbers are zero. 	 * In case of NAT-T we will update them later if needed. 	 */
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NAT_T
comment|/* 	 * Handle NAT-T info if present. 	 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sport
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dport
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
name|dport
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|sport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|src
argument_list|,
name|sport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dport
condition|)
name|KEY_PORTTOSADDR
argument_list|(
operator|&
name|saidx
operator|.
name|dst
argument_list|,
name|dport
operator|->
name|sadb_x_nat_t_port_port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get a SA index */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
break|break;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: a SA exists already.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|error
operator|=
name|key_acquire
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: error %d returned from key_acquire\n"
operator|,
name|__func__
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_REGISTER processing.  * If SATYPE_UNSPEC has been passed as satype, only return sabd_supported.  * receive  *<base>  * from the ikmpd, and register a socket to send PF_KEY messages,  * and send  *<base, supported>  * to KMD by PF_KEY.  * If socket is detached, must free from regnode.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_register
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|newreg
init|=
literal|0
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* check for invalid register message */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|>=
sizeof|sizeof
argument_list|(
name|V_regtree
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|V_regtree
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
comment|/* When SATYPE_UNSPEC is specified, only return sabd_supported. */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_UNSPEC
condition|)
goto|goto
name|setmsg
goto|;
comment|/* check whether existing or not */
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[mhp->msg->sadb_msg_satype]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: socket exists already.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
block|}
comment|/* create regnode */
name|newreg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secreg
argument_list|)
argument_list|,
name|M_IPSEC_SAR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|==
name|NULL
condition|)
block|{
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newreg
operator|->
name|so
operator|=
name|so
expr_stmt|;
operator|(
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|->
name|kp_registered
operator|++
expr_stmt|;
comment|/* add regnode to regtree. */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_regtree
index|[
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
index|]
argument_list|,
name|newreg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|setmsg
label|:
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|sadb_supported
modifier|*
name|sup
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|alen
decl_stmt|,
name|elen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sadb_alg
modifier|*
name|alg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|alen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alen
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
name|elen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elen
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|alen
operator|+
name|elen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for authentication algorithm */
if|if
condition|(
name|alen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|alen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_AUTH
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|auth_hash
modifier|*
name|aalgo
decl_stmt|;
name|u_int16_t
name|minkeysize
decl_stmt|,
name|maxkeysize
decl_stmt|;
name|aalgo
operator|=
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aalgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|key_getsizes_ah
argument_list|(
name|aalgo
argument_list|,
name|i
argument_list|,
operator|&
name|minkeysize
argument_list|,
operator|&
name|maxkeysize
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|_BITS
argument_list|(
name|maxkeysize
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for encryption algorithm */
if|if
condition|(
name|elen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|elen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_ENCRYPT
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|enc_xform
modifier|*
name|ealgo
decl_stmt|;
name|ealgo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ealgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
name|ealgo
operator|->
name|blocksize
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|_BITS
argument_list|(
name|ealgo
operator|->
name|minkey
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|_BITS
argument_list|(
name|ealgo
operator|->
name|maxkey
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length assumption failed (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * free secreg entry registered.  * XXX: I want to do free a socket marked done SADB_RESIGER to socket.  */
end_comment

begin_function
name|void
name|key_freereg
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL so"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * check whether existing or not. 	 * check all type of SA, because there is a potential that 	 * one socket is registered to multiple type of SA. 	 */
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
operator|&&
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|,
name|M_IPSEC_SAR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SADB_EXPIRE processing  * send  *<base, SA, SA2, lifetime(C and one of HS), address(SD)>  * to KMD by PF_KEY.  * NOTE: We send only soft lifetime extension.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_expire
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|satype
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
comment|/* XXX: Why do we lock ? */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sa header"
operator|)
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|satype
operator|!=
literal|0
argument_list|,
operator|(
literal|"invalid proto, satype %u"
operator|,
name|satype
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_EXPIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|sav
operator|->
name|seq
argument_list|,
literal|0
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create lifetime extension (current and soft) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|allocations
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|bytes
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|addtime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|usetime
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_SOFT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|allocations
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|bytes
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|addtime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|usetime
expr_stmt|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * XXX-BZ Handle NAT-T extensions here. 	 */
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_FLUSH processing  * receive  *<base>  * from the ikmpd, and free all entries in secastree.  * and send,  *<base>  * to the ikmpd.  * NOTE: to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_flush
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* no SATYPE specified, i.e. flushing all SA. */
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|KEY_FREESAV
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|||
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_DUMP processing  * dump all entries including status of DEAD in SAD.  * receive  *<base>  * from the ikmpd, and dump all secasvar leaves  * and send,  *<base> .....  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_dump
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* count sav entries to be sent to the userland. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
comment|/* send this to the userland, one at a time. */
name|newmsg
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there was invalid proto in "
literal|"SAD.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_DUMP
argument_list|,
name|satype
argument_list|,
operator|--
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_PROMISC processing  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_promisc
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|int
name|olen
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
name|olen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
else|#
directive|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|olen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
comment|/* enable/disable promisc mode */
name|struct
name|keycb
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|(
name|kp
operator|=
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|kp
operator|->
name|kp_promisc
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
expr_stmt|;
break|break;
default|default:
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* send the original message back to everyone */
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
else|else
block|{
comment|/* send packet as is */
name|m_adj
argument_list|(
name|m
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: if sadb_msg_seq is specified, send to specific pid */
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*key_typesw[]
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
operator|=
block|{
name|NULL
block|,
comment|/* SADB_RESERVED */
name|key_getspi
block|,
comment|/* SADB_GETSPI */
name|key_update
block|,
comment|/* SADB_UPDATE */
name|key_add
block|,
comment|/* SADB_ADD */
name|key_delete
block|,
comment|/* SADB_DELETE */
name|key_get
block|,
comment|/* SADB_GET */
name|key_acquire2
block|,
comment|/* SADB_ACQUIRE */
name|key_register
block|,
comment|/* SADB_REGISTER */
name|NULL
block|,
comment|/* SADB_EXPIRE */
name|key_flush
block|,
comment|/* SADB_FLUSH */
name|key_dump
block|,
comment|/* SADB_DUMP */
name|key_promisc
block|,
comment|/* SADB_X_PROMISC */
name|NULL
block|,
comment|/* SADB_X_PCHANGE */
name|key_spdadd
block|,
comment|/* SADB_X_SPDUPDATE */
name|key_spdadd
block|,
comment|/* SADB_X_SPDADD */
name|key_spddelete
block|,
comment|/* SADB_X_SPDDELETE */
name|key_spdget
block|,
comment|/* SADB_X_SPDGET */
name|NULL
block|,
comment|/* SADB_X_SPDACQUIRE */
name|key_spddump
block|,
comment|/* SADB_X_SPDDUMP */
name|key_spdflush
block|,
comment|/* SADB_X_SPDFLUSH */
name|key_spdadd
block|,
comment|/* SADB_X_SPDSETIDX */
name|NULL
block|,
comment|/* SADB_X_SPDEXPIRE */
name|key_spddelete2
block|,
comment|/* SADB_X_SPDDELETE2 */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * parse sadb_msg buffer to process PFKEYv2,  * and create a data to response if needed.  * I think to be dealed with mbuf directly.  * IN:  *     msgp  : pointer to pointer to a received buffer pulluped.  *             This is rewrited to response.  *     so    : pointer to socket.  * OUT:  *    length for buffer to send to user process.  */
end_comment

begin_function
name|int
name|key_parse
parameter_list|(
name|m
parameter_list|,
name|so
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_msghdr
name|mh
decl_stmt|;
name|u_int
name|orglen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|target
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*kdebug_sadb assumes msg in linear buffer*/
block|KEYDEBUG(KEYDEBUG_KEY_DUMP, 		ipseclog((LOG_DEBUG, "%s: passed sadb_msg\n", __func__)); 		kdebug_sadb(msg));
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|ENOBUFS
return|;
block|}
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|orglen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|target
operator|=
name|KEY_SENDUP_ONE
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_version
operator|!=
name|PF_KEY_V2
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: PF_KEY version %u is mismatched.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_version
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invver
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>
name|SADB_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid type %u is passed.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invmsgtype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* for old-fashioned code - should be nuked */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MCLBYTES
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* align the mbuf chain so that extensions are in contiguous region. */
name|error
operator|=
name|key_align
argument_list|(
name|m
argument_list|,
operator|&
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|msg
operator|=
name|mh
operator|.
name|msg
expr_stmt|;
comment|/* check SA type */
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
case|case
name|SADB_UPDATE
case|:
case|case
name|SADB_ADD
case|:
case|case
name|SADB_DELETE
case|:
case|case
name|SADB_GET
case|:
case|case
name|SADB_ACQUIRE
case|:
case|case
name|SADB_EXPIRE
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: must specify satype "
literal|"when msg type=%u.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_X_SPDADD
case|:
case|case
name|SADB_X_SPDDELETE
case|:
case|case
name|SADB_X_SPDGET
case|:
case|case
name|SADB_X_SPDDUMP
case|:
case|case
name|SADB_X_SPDFLUSH
case|:
case|case
name|SADB_X_SPDSETIDX
case|:
case|case
name|SADB_X_SPDUPDATE
case|:
case|case
name|SADB_X_SPDDELETE2
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal satype=%u\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_RSVP
case|:
case|case
name|SADB_SATYPE_OSPFV2
case|:
case|case
name|SADB_SATYPE_RIPV2
case|:
case|case
name|SADB_SATYPE_MIP
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: type %u isn't supported.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|senderror
goto|;
case|case
literal|1
case|:
comment|/* XXX: What does it do? */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_PROMISC
condition|)
break|break;
comment|/*FALLTHROUGH*/
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid type %u is passed.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* check field of upper layer protocol and address family */
if|if
condition|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|!=
name|NULL
operator|&&
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|u_int
name|plen
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* check upper layer protocol */
if|if
condition|(
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: upper layer protocol "
literal|"mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* check family */
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address family mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address struct size "
literal|"mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unsupported address family\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
name|plen
operator|=
literal|0
expr_stmt|;
comment|/*fool gcc*/
break|break;
block|}
comment|/* check max prefix length */
if|if
condition|(
name|src0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
operator|||
name|dst0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal prefixlen.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* 		 * prefixlen == 0 is valid because there can be a case when 		 * all addresses are matched. 		 */
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>=
sizeof|sizeof
argument_list|(
name|key_typesw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|key_typesw
index|[
literal|0
index|]
argument_list|)
operator|||
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
operator|==
name|NULL
condition|)
block|{
name|V_pfkeystat
operator|.
name|out_invmsgtype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
return|return
call|(
modifier|*
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
operator|&
name|mh
argument_list|)
return|;
name|senderror
label|:
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_senderror
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|code
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
operator|(
literal|"mbuf too small, len %u"
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|code
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the pointer to each header into message buffer.  * m will be freed on error.  * XXX larger-than-MCLBYTES extension?  */
end_comment

begin_function
specifier|static
name|int
name|key_align
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|end
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|int
name|toff
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
operator|(
literal|"mbuf too small, len %u"
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize */
name|bzero
argument_list|(
name|mhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mhp
argument_list|)
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|mhp
operator|->
name|msg
expr_stmt|;
comment|/*XXX backward compat */
name|end
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|extlen
operator|=
name|end
expr_stmt|;
comment|/*just in case extlen is not updated*/
for|for
control|(
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
init|;
name|off
operator|<
name|end
condition|;
name|off
operator|+=
name|extlen
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ext
argument_list|)
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
comment|/* set pointer */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
case|case
name|SADB_EXT_KEY_AUTH
case|:
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
case|case
name|SADB_EXT_SENSITIVITY
case|:
case|case
name|SADB_EXT_PROPOSAL
case|:
case|case
name|SADB_EXT_SUPPORTED_AUTH
case|:
case|case
name|SADB_EXT_SUPPORTED_ENCRYPT
case|:
case|case
name|SADB_EXT_SPIRANGE
case|:
case|case
name|SADB_X_EXT_POLICY
case|:
case|case
name|SADB_X_EXT_SA2
case|:
ifdef|#
directive|ifdef
name|IPSEC_NAT_T
case|case
name|SADB_X_EXT_NAT_T_TYPE
case|:
case|case
name|SADB_X_EXT_NAT_T_SPORT
case|:
case|case
name|SADB_X_EXT_NAT_T_DPORT
case|:
case|case
name|SADB_X_EXT_NAT_T_OAI
case|:
case|case
name|SADB_X_EXT_NAT_T_OAR
case|:
case|case
name|SADB_X_EXT_NAT_T_FRAG
case|:
endif|#
directive|endif
comment|/* duplicate check */
comment|/* 			 * XXX Are there duplication payloads of either 			 * KEY_AUTH or KEY_ENCRYPT ? 			 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: duplicate ext_type "
literal|"%u\n"
operator|,
name|__func__
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_dupext
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid ext_type %u\n"
operator|,
name|__func__
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invexttype
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|extlen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_validate_ext
argument_list|(
name|ext
argument_list|,
name|extlen
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|extlen
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|ext
expr_stmt|;
name|mhp
operator|->
name|extoff
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|off
expr_stmt|;
name|mhp
operator|->
name|extlen
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|extlen
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|!=
name|end
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|V_pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_validate_ext
parameter_list|(
name|ext
parameter_list|,
name|len
parameter_list|)
specifier|const
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
enum|enum
block|{
name|NONE
block|,
name|ADDR
block|}
name|checktype
init|=
name|NONE
enum|;
name|int
name|baselen
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|sal
init|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr
argument_list|,
name|sa_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* if it does not match minimum/maximum length, bail */
if|if
condition|(
name|ext
operator|->
name|sadb_ext_type
operator|>=
sizeof|sizeof
argument_list|(
name|minsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|minsize
index|[
literal|0
index|]
argument_list|)
operator|||
name|ext
operator|->
name|sadb_ext_type
operator|>=
sizeof|sizeof
argument_list|(
name|maxsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|maxsize
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|||
name|len
operator|<
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|&&
name|len
operator|>
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
comment|/* more checks based on sadb_ext_type XXX need more */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
break|break;
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|ext
operator|)
operator|->
name|sadb_ident_type
operator|==
name|SADB_X_IDENTTYPE_ADDR
condition|)
block|{
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
block|}
else|else
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
default|default:
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|checktype
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|ADDR
case|:
name|sa
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|ext
operator|)
operator|+
name|baselen
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|baselen
operator|+
name|sal
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|baselen
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
operator|!=
name|len
condition|)
return|return
name|EINVAL
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|key_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_sptree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_sahtree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_regtree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_acqtree
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
expr_stmt|;
comment|/* system default */
name|V_ip4_def_policy
operator|.
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
name|V_ip4_def_policy
operator|.
name|refcnt
operator|++
expr_stmt|;
comment|/*never reclaim this*/
if|if
condition|(
operator|!
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
return|return;
name|SPTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|REGTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|SAHTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|ACQ_LOCK_INIT
argument_list|()
expr_stmt|;
name|SPACQ_LOCK_INIT
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*IPSEC_DEBUG2*/
comment|/* initialize key statistics */
name|keystat
operator|.
name|getspi_count
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"IPsec: Initialized Security Association Processing.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|key_destroy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SPTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_sptree
index|[
name|i
index|]
argument_list|)
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|LIST_NEXT
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_IPSEC_SP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SPTREE_UNLOCK
argument_list|()
expr_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sah
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sah
argument_list|,
name|M_IPSEC_SAH
argument_list|)
expr_stmt|;
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|,
name|M_IPSEC_SAR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX: maybe This function is called after INBOUND IPsec processing.  *  * Special check for tunnel-mode packets.  * We must make some checks for consistency between inner and outer IP header.  *  * xxx more checks to be provided  */
end_comment

begin_function
name|int
name|key_checktunnelsanity
parameter_list|(
name|sav
parameter_list|,
name|family
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|family
decl_stmt|;
name|caddr_t
name|src
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null SA header"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: check inner IP header */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* record data transfer on SA, and update timestamps */
end_comment

begin_function
name|void
name|key_sa_recordxfer
parameter_list|(
name|sav
parameter_list|,
name|m
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null secasvar"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null mbuf"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_c
condition|)
return|return;
comment|/* 	 * XXX Currently, there is a difference of bytes size 	 * between inbound and outbound processing. 	 */
name|sav
operator|->
name|lft_c
operator|->
name|bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* to check bytes lifetime is done in key_timehandler(). */
comment|/* 	 * We use the number of packets as the unit of 	 * allocations.  We increment the variable 	 * whenever {esp,ah}_{in,out}put is called. 	 */
name|sav
operator|->
name|lft_c
operator|->
name|allocations
operator|++
expr_stmt|;
comment|/* XXX check for expires? */
comment|/* 	 * NOTE: We record CURRENT usetime by using wall clock, 	 * in seconds.  HARD and SOFT lifetime are measured by the time 	 * difference (again in seconds) from usetime. 	 * 	 *	usetime 	 *	v     expire   expire 	 * -----+-----+--------+---> t 	 *<--------------> HARD 	 *<-----> SOFT 	 */
name|sav
operator|->
name|lft_c
operator|->
name|usetime
operator|=
name|time_second
expr_stmt|;
comment|/* XXX check for expires? */
return|return;
block|}
end_function

begin_comment
comment|/* dumb version */
end_comment

begin_function
name|void
name|key_sa_routechange
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|SAHTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
name|ro
operator|=
operator|&
name|sah
operator|->
name|sa_route
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
name|dst
operator|->
name|sa_len
operator|==
name|ro
operator|->
name|ro_dst
operator|.
name|sa_len
operator|&&
name|bcmp
argument_list|(
name|dst
argument_list|,
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
name|SAHTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_sa_chgstate
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|u_int8_t
name|state
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sav"
operator|)
argument_list|)
expr_stmt|;
name|SAHTREE_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|key_sa_stir_iv
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|iv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null IV"
operator|)
argument_list|)
expr_stmt|;
name|key_randomfill
argument_list|(
name|sav
operator|->
name|iv
argument_list|,
name|sav
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX too much? */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_alloc_mbuf
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|,
name|t
decl_stmt|;
name|len
operator|=
name|l
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|len
operator|>
name|MLEN
condition|)
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* use the bottom of mbuf, hoping we can prepend afterwards */
if|if
condition|(
name|n
operator|->
name|m_len
operator|>
name|len
condition|)
block|{
name|t
operator|=
operator|(
name|n
operator|->
name|m_len
operator|-
name|len
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|+=
name|t
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Take one of the kernel's security keys and convert it into a PF_KEY  * structure within an mbuf, suitable for sending up to a waiting  * application in user land.  *   * IN:   *    src: A pointer to a kernel security key.  *    exttype: Which type of key this is. Refer to the PF_KEY data structures.  * OUT:  *    a valid mbuf or NULL indicating an error  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setkey
parameter_list|(
name|struct
name|seckey
modifier|*
name|src
parameter_list|,
name|u_int16_t
name|exttype
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_key
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
operator|+
name|_KEYLEN
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_key
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_key_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_key_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_key_bits
operator|=
name|src
operator|->
name|bits
expr_stmt|;
name|bcopy
argument_list|(
name|src
operator|->
name|key_data
argument_list|,
name|_KEYBUF
argument_list|(
name|p
argument_list|)
argument_list|,
name|_KEYLEN
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Take one of the kernel's lifetime data structures and convert it  * into a PF_KEY structure within an mbuf, suitable for sending up to  * a waiting application in user land.  *   * IN:   *    src: A pointer to a kernel lifetime structure.  *    exttype: Which type of lifetime this is. Refer to the PF_KEY   *             data structures for more information.  * OUT:  *    a valid mbuf or NULL indicating an error  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setlifetime
parameter_list|(
name|struct
name|seclifetime
modifier|*
name|src
parameter_list|,
name|u_int16_t
name|exttype
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|m
return|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_allocations
operator|=
name|src
operator|->
name|allocations
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_bytes
operator|=
name|src
operator|->
name|bytes
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_addtime
operator|=
name|src
operator|->
name|addtime
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_usetime
operator|=
name|src
operator|->
name|usetime
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

end_unit

