begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: key.c,v 1.191 2001/06/27 10:46:49 sakane Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This code is referd to RFC 2367  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<net/pfkeyv2.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keysock.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/* randomness */
end_comment

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_define
define|#
directive|define
name|FULLMASK
value|0xff
end_define

begin_define
define|#
directive|define
name|_BITS
parameter_list|(
name|bytes
parameter_list|)
value|((bytes)<< 3)
end_define

begin_comment
comment|/*  * Note on SA reference counting:  * - SAs that are not in DEAD state will have (total external reference + 1)  *   following value in reference count field.  they cannot be freed and are  *   referenced from SA header.  * - SAs that are in DEAD state will have (total external reference)  *   in reference count field.  they are ready to be freed.  reference from  *   SA header will be removed in key_delsav(), when the reference count  *   field hits 0 (= no external reference other than from SA header.  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_debug_level
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_spi_trycnt
argument_list|)
operator|=
literal|1000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_spi_minval
argument_list|)
operator|=
literal|0x100
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|key_spi_maxval
argument_list|)
operator|=
literal|0x0fffffff
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|policy_id
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*interval to initialize randseed,1(m)*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_int_random
argument_list|)
operator|=
literal|60
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interval to expire acquiring, 30(s)*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|key_larval_lifetime
argument_list|)
operator|=
literal|30
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* counter for blocking SADB_ACQUIRE.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_blockacq_count
argument_list|)
operator|=
literal|10
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for blocking SADB_ACQUIRE.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_blockacq_lifetime
argument_list|)
operator|=
literal|20
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* preferred old sa rather than new sa.*/
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|key_preferred_oldsa
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_spi_trycnt
value|VNET(key_spi_trycnt)
end_define

begin_define
define|#
directive|define
name|V_key_spi_minval
value|VNET(key_spi_minval)
end_define

begin_define
define|#
directive|define
name|V_key_spi_maxval
value|VNET(key_spi_maxval)
end_define

begin_define
define|#
directive|define
name|V_policy_id
value|VNET(policy_id)
end_define

begin_define
define|#
directive|define
name|V_key_int_random
value|VNET(key_int_random)
end_define

begin_define
define|#
directive|define
name|V_key_larval_lifetime
value|VNET(key_larval_lifetime)
end_define

begin_define
define|#
directive|define
name|V_key_blockacq_count
value|VNET(key_blockacq_count)
end_define

begin_define
define|#
directive|define
name|V_key_blockacq_lifetime
value|VNET(key_blockacq_lifetime)
end_define

begin_define
define|#
directive|define
name|V_key_preferred_oldsa
value|VNET(key_preferred_oldsa)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int32_t
argument_list|,
name|acq_seq
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_acq_seq
value|VNET(acq_seq)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uint32_t
argument_list|,
name|sp_genid
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_sp_genid
value|VNET(sp_genid)
end_define

begin_comment
comment|/* SPD */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|secpolicy_queue
argument_list|,
name|secpolicy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|secpolicy_list
argument_list|,
name|secpolicy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secpolicy_queue
argument_list|,
name|sptree
index|[
name|IPSEC_DIR_MAX
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secpolicy_queue
argument_list|,
name|sptree_ifnet
index|[
name|IPSEC_DIR_MAX
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|sptree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|V_sptree
value|VNET(sptree)
end_define

begin_define
define|#
directive|define
name|V_sptree_ifnet
value|VNET(sptree_ifnet)
end_define

begin_define
define|#
directive|define
name|SPTREE_LOCK_INIT
parameter_list|()
value|rm_init(&sptree_lock, "sptree")
end_define

begin_define
define|#
directive|define
name|SPTREE_LOCK_DESTROY
parameter_list|()
value|rm_destroy(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_RLOCK_TRACKER
value|struct rm_priotracker sptree_tracker
end_define

begin_define
define|#
directive|define
name|SPTREE_RLOCK
parameter_list|()
value|rm_rlock(&sptree_lock,&sptree_tracker)
end_define

begin_define
define|#
directive|define
name|SPTREE_RUNLOCK
parameter_list|()
value|rm_runlock(&sptree_lock,&sptree_tracker)
end_define

begin_define
define|#
directive|define
name|SPTREE_RLOCK_ASSERT
parameter_list|()
value|rm_assert(&sptree_lock, RA_RLOCKED)
end_define

begin_define
define|#
directive|define
name|SPTREE_WLOCK
parameter_list|()
value|rm_wlock(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_WUNLOCK
parameter_list|()
value|rm_wunlock(&sptree_lock)
end_define

begin_define
define|#
directive|define
name|SPTREE_WLOCK_ASSERT
parameter_list|()
value|rm_assert(&sptree_lock, RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|SPTREE_UNLOCK_ASSERT
parameter_list|()
value|rm_assert(&sptree_lock, RA_UNLOCKED)
end_define

begin_comment
comment|/* Hash table for lookup SP using unique id */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secpolicy_list
operator|*
argument_list|,
name|sphashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|sphash_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_sphashtbl
value|VNET(sphashtbl)
end_define

begin_define
define|#
directive|define
name|V_sphash_mask
value|VNET(sphash_mask)
end_define

begin_define
define|#
directive|define
name|SPHASH_NHASH_LOG2
value|7
end_define

begin_define
define|#
directive|define
name|SPHASH_NHASH
value|(1<< SPHASH_NHASH_LOG2)
end_define

begin_define
define|#
directive|define
name|SPHASH_HASHVAL
parameter_list|(
name|id
parameter_list|)
value|(key_u32hash(id)& V_sphash_mask)
end_define

begin_define
define|#
directive|define
name|SPHASH_HASH
parameter_list|(
name|id
parameter_list|)
value|&V_sphashtbl[SPHASH_HASHVAL(id)]
end_define

begin_comment
comment|/* SAD */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|secashead_queue
argument_list|,
name|secashead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|secashead_list
argument_list|,
name|secashead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secashead_queue
argument_list|,
name|sahtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|sahtree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|V_sahtree
value|VNET(sahtree)
end_define

begin_define
define|#
directive|define
name|SAHTREE_LOCK_INIT
parameter_list|()
value|rm_init(&sahtree_lock, "sahtree")
end_define

begin_define
define|#
directive|define
name|SAHTREE_LOCK_DESTROY
parameter_list|()
value|rm_destroy(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_RLOCK_TRACKER
value|struct rm_priotracker sahtree_tracker
end_define

begin_define
define|#
directive|define
name|SAHTREE_RLOCK
parameter_list|()
value|rm_rlock(&sahtree_lock,&sahtree_tracker)
end_define

begin_define
define|#
directive|define
name|SAHTREE_RUNLOCK
parameter_list|()
value|rm_runlock(&sahtree_lock,&sahtree_tracker)
end_define

begin_define
define|#
directive|define
name|SAHTREE_RLOCK_ASSERT
parameter_list|()
value|rm_assert(&sahtree_lock, RA_RLOCKED)
end_define

begin_define
define|#
directive|define
name|SAHTREE_WLOCK
parameter_list|()
value|rm_wlock(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_WUNLOCK
parameter_list|()
value|rm_wunlock(&sahtree_lock)
end_define

begin_define
define|#
directive|define
name|SAHTREE_WLOCK_ASSERT
parameter_list|()
value|rm_assert(&sahtree_lock, RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|SAHTREE_UNLOCK_ASSERT
parameter_list|()
value|rm_assert(&sahtree_lock, RA_UNLOCKED)
end_define

begin_comment
comment|/* Hash table for lookup in SAD using SA addresses */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secashead_list
operator|*
argument_list|,
name|sahaddrhashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|sahaddrhash_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_sahaddrhashtbl
value|VNET(sahaddrhashtbl)
end_define

begin_define
define|#
directive|define
name|V_sahaddrhash_mask
value|VNET(sahaddrhash_mask)
end_define

begin_define
define|#
directive|define
name|SAHHASH_NHASH_LOG2
value|7
end_define

begin_define
define|#
directive|define
name|SAHHASH_NHASH
value|(1<< SAHHASH_NHASH_LOG2)
end_define

begin_define
define|#
directive|define
name|SAHADDRHASH_HASHVAL
parameter_list|(
name|saidx
parameter_list|)
define|\
value|(key_saidxhash(saidx)& V_sahaddrhash_mask)
end_define

begin_define
define|#
directive|define
name|SAHADDRHASH_HASH
parameter_list|(
name|saidx
parameter_list|)
define|\
value|&V_sahaddrhashtbl[SAHADDRHASH_HASHVAL(saidx)]
end_define

begin_comment
comment|/* Hash table for lookup in SAD using SPI */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|secasvar_list
argument_list|,
name|secasvar
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secasvar_list
operator|*
argument_list|,
name|savhashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|savhash_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_savhashtbl
value|VNET(savhashtbl)
end_define

begin_define
define|#
directive|define
name|V_savhash_mask
value|VNET(savhash_mask)
end_define

begin_define
define|#
directive|define
name|SAVHASH_NHASH_LOG2
value|7
end_define

begin_define
define|#
directive|define
name|SAVHASH_NHASH
value|(1<< SAVHASH_NHASH_LOG2)
end_define

begin_define
define|#
directive|define
name|SAVHASH_HASHVAL
parameter_list|(
name|spi
parameter_list|)
value|(key_u32hash(spi)& V_savhash_mask)
end_define

begin_define
define|#
directive|define
name|SAVHASH_HASH
parameter_list|(
name|spi
parameter_list|)
value|&V_savhashtbl[SAVHASH_HASHVAL(spi)]
end_define

begin_function
specifier|static
name|uint32_t
name|key_saidxhash
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|uint32_t
name|hval
decl_stmt|;
name|hval
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|saidx
operator|->
name|proto
argument_list|,
sizeof|sizeof
argument_list|(
name|saidx
operator|->
name|proto
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|hval
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
argument_list|,
name|hval
argument_list|)
expr_stmt|;
name|hval
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|in_addr_t
argument_list|)
argument_list|,
name|hval
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|hval
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|hval
argument_list|)
expr_stmt|;
name|hval
operator|=
name|fnv_32_buf
argument_list|(
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|hval
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|hval
operator|=
literal|0
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unknown address family %d"
operator|,
name|__func__
operator|,
name|saidx
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|key_u32hash
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_buf
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* registed list */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_regtree
argument_list|,
name|secreg
argument_list|)
argument_list|,
name|regtree
index|[
name|SADB_SATYPE_MAX
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_regtree
value|VNET(regtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|regtree_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REGTREE_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&regtree_lock, "regtree", "fast ipsec regtree", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK
parameter_list|()
value|mtx_lock(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_UNLOCK
parameter_list|()
value|mtx_unlock(&regtree_lock)
end_define

begin_define
define|#
directive|define
name|REGTREE_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&regtree_lock, MA_OWNED)
end_define

begin_comment
comment|/* Acquiring list */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|secacq_list
argument_list|,
name|secacq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secacq_list
argument_list|,
name|acqtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_acqtree
value|VNET(acqtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|acq_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACQ_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&acq_lock, "acqtree", "ipsec SA acquiring list", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK
parameter_list|()
value|mtx_lock(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_UNLOCK
parameter_list|()
value|mtx_unlock(&acq_lock)
end_define

begin_define
define|#
directive|define
name|ACQ_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&acq_lock, MA_OWNED)
end_define

begin_comment
comment|/* Hash table for lookup in ACQ list using SA addresses */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secacq_list
operator|*
argument_list|,
name|acqaddrhashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|acqaddrhash_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_acqaddrhashtbl
value|VNET(acqaddrhashtbl)
end_define

begin_define
define|#
directive|define
name|V_acqaddrhash_mask
value|VNET(acqaddrhash_mask)
end_define

begin_comment
comment|/* Hash table for lookup in ACQ list using SEQ number */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secacq_list
operator|*
argument_list|,
name|acqseqhashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|acqseqhash_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_acqseqhashtbl
value|VNET(acqseqhashtbl)
end_define

begin_define
define|#
directive|define
name|V_acqseqhash_mask
value|VNET(acqseqhash_mask)
end_define

begin_define
define|#
directive|define
name|ACQHASH_NHASH_LOG2
value|7
end_define

begin_define
define|#
directive|define
name|ACQHASH_NHASH
value|(1<< ACQHASH_NHASH_LOG2)
end_define

begin_define
define|#
directive|define
name|ACQADDRHASH_HASHVAL
parameter_list|(
name|saidx
parameter_list|)
define|\
value|(key_saidxhash(saidx)& V_acqaddrhash_mask)
end_define

begin_define
define|#
directive|define
name|ACQSEQHASH_HASHVAL
parameter_list|(
name|seq
parameter_list|)
define|\
value|(key_u32hash(seq)& V_acqseqhash_mask)
end_define

begin_define
define|#
directive|define
name|ACQADDRHASH_HASH
parameter_list|(
name|saidx
parameter_list|)
define|\
value|&V_acqaddrhashtbl[ACQADDRHASH_HASHVAL(saidx)]
end_define

begin_define
define|#
directive|define
name|ACQSEQHASH_HASH
parameter_list|(
name|seq
parameter_list|)
define|\
value|&V_acqseqhashtbl[ACQSEQHASH_HASHVAL(seq)]
end_define

begin_comment
comment|/* SP acquiring list */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(
name|_spacqtree
argument_list|,
name|secspacq
argument_list|)
argument_list|,
name|spacqtree
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_spacqtree
value|VNET(spacqtree)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|spacq_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPACQ_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&spacq_lock, "spacqtree", \ 		"fast ipsec security policy acquire list", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK
parameter_list|()
value|mtx_lock(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_UNLOCK
parameter_list|()
value|mtx_unlock(&spacq_lock)
end_define

begin_define
define|#
directive|define
name|SPACQ_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&spacq_lock, MA_OWNED)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|minsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sens
argument_list|)
block|,
comment|/* SADB_EXT_SENSITIVITY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
block|,
comment|/* SADB_EXT_PROPOSAL */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_TYPE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_SPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_DPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_OAI */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_OAR */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_frag
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_FRAG */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa_replay
argument_list|)
block|,
comment|/* SADB_X_EXT_SA_REPLAY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NEW_ADDRESS_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_X_EXT_NEW_ADDRESS_DST */
block|}
decl_stmt|;
end_decl_stmt

begin_assert
assert|_Static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|minsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
name|SADB_EXT_MAX
operator|+
literal|1
argument_list|,
literal|"minsize size mismatch"
argument_list|)
assert|;
end_assert

begin_decl_stmt
specifier|static
specifier|const
name|int
name|maxsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_DST */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
literal|0
block|,
comment|/* SADB_EXT_KEY_AUTH */
literal|0
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_DST */
literal|0
block|,
comment|/* SADB_EXT_SENSITIVITY */
literal|0
block|,
comment|/* SADB_EXT_PROPOSAL */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
literal|0
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_TYPE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_SPORT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_DPORT */
literal|0
block|,
comment|/* SADB_X_EXT_NAT_T_OAI */
literal|0
block|,
comment|/* SADB_X_EXT_NAT_T_OAR */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_frag
argument_list|)
block|,
comment|/* SADB_X_EXT_NAT_T_FRAG */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa_replay
argument_list|)
block|,
comment|/* SADB_X_EXT_SA_REPLAY */
literal|0
block|,
comment|/* SADB_X_EXT_NEW_ADDRESS_SRC */
literal|0
block|,
comment|/* SADB_X_EXT_NEW_ADDRESS_DST */
block|}
decl_stmt|;
end_decl_stmt

begin_assert
assert|_Static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|maxsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
name|SADB_EXT_MAX
operator|+
literal|1
argument_list|,
literal|"minsize size mismatch"
argument_list|)
assert|;
end_assert

begin_comment
comment|/*  * Internal values for SA flags:  * SADB_X_EXT_F_CLONED means that SA was cloned by key_updateaddresses,  *	thus we will not free the most of SA content in key_delsav().  */
end_comment

begin_define
define|#
directive|define
name|SADB_X_EXT_F_CLONED
value|0x80000000
end_define

begin_define
define|#
directive|define
name|SADB_CHECKLEN
parameter_list|(
name|_mhp
parameter_list|,
name|_ext
parameter_list|)
define|\
value|((_mhp)->extlen[(_ext)]< minsize[(_ext)] || (maxsize[(_ext)] != 0&& \ 	((_mhp)->extlen[(_ext)]> maxsize[(_ext)])))
end_define

begin_define
define|#
directive|define
name|SADB_CHECKHDR
parameter_list|(
name|_mhp
parameter_list|,
name|_ext
parameter_list|)
value|((_mhp)->ext[(_ext)] == NULL)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_esp_keymin
argument_list|)
operator|=
literal|256
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_esp_auth
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_ah_keymin
argument_list|)
operator|=
literal|128
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ipsec_esp_keymin
value|VNET(ipsec_esp_keymin)
end_define

begin_define
define|#
directive|define
name|V_ipsec_esp_auth
value|VNET(ipsec_esp_auth)
end_define

begin_define
define|#
directive|define
name|V_ipsec_ah_keymin
value|VNET(ipsec_ah_keymin)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DEBUG
end_ifdef

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_debug
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_debug
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ipsec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEBUG
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_debug
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable IPsec debugging output when set."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_ipsec6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEBUG
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_debug
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable IPsec debugging output when set."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_key
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_DEBUG_LEVEL
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_debug_level
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max count of trial for the decision of spi value */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_TRY
argument_list|,
name|spi_trycnt
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_trycnt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MIN_VALUE
argument_list|,
name|spi_minval
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_minval
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximun spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MAX_VALUE
argument_list|,
name|spi_maxval
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_spi_maxval
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interval to initialize randseed */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_RANDOM_INT
argument_list|,
name|int_random
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_int_random
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for larval SA */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_LARVAL_LIFETIME
argument_list|,
name|larval_lifetime
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_larval_lifetime
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* counter for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_COUNT
argument_list|,
name|blockacq_count
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_blockacq_count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_LIFETIME
argument_list|,
name|blockacq_lifetime
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_blockacq_lifetime
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ESP auth */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_AUTH
argument_list|,
name|esp_auth
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_esp_auth
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum ESP key length */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_KEYMIN
argument_list|,
name|esp_keymin
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_esp_keymin
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum AH key length */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_AH_KEYMIN
argument_list|,
name|ah_keymin
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_ah_keymin
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* perfered old SA rather than new SA */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_PREFERED_OLDSA
argument_list|,
name|preferred_oldsa
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|key_preferred_oldsa
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__LIST_CHAINED
parameter_list|(
name|elm
parameter_list|)
define|\
value|(!((elm)->chain.le_next == NULL&& (elm)->chain.le_prev == NULL))
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SA
argument_list|,
literal|"secasvar"
argument_list|,
literal|"ipsec security association"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAH
argument_list|,
literal|"sahead"
argument_list|,
literal|"ipsec sa head"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SP
argument_list|,
literal|"ipsecpolicy"
argument_list|,
literal|"ipsec security policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SR
argument_list|,
literal|"ipsecrequest"
argument_list|,
literal|"ipsec security request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_MISC
argument_list|,
literal|"ipsec-misc"
argument_list|,
literal|"ipsec miscellaneous"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAQ
argument_list|,
literal|"ipsec-saq"
argument_list|,
literal|"ipsec sa acquire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IPSEC_SAR
argument_list|,
literal|"ipsec-reg"
argument_list|,
literal|"ipsec sa acquire"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|key_lft_zone
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_key_lft_zone
value|VNET(key_lft_zone)
end_define

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|xforms_list
argument_list|,
argument|xformsw
argument_list|)
name|xforms
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|xforms_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XFORMS_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&xforms_lock, "xforms_list", "IPsec transforms list", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|XFORMS_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&xforms_lock)
end_define

begin_define
define|#
directive|define
name|XFORMS_LOCK
parameter_list|()
value|mtx_lock(&xforms_lock)
end_define

begin_define
define|#
directive|define
name|XFORMS_UNLOCK
parameter_list|()
value|mtx_unlock(&xforms_lock)
end_define

begin_comment
comment|/*  * set parameters into secpolicyindex buffer.  * Must allocate secpolicyindex buffer passed to this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECSPIDX
parameter_list|(
name|_dir
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|ps
parameter_list|,
name|pd
parameter_list|,
name|ulp
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secpolicyindex));                         \ 	(idx)->dir = (_dir);                                                 \ 	(idx)->prefs = (ps);                                                 \ 	(idx)->prefd = (pd);                                                 \ 	(idx)->ul_proto = (ulp);                                             \ 	bcopy((s),&(idx)->src, ((const struct sockaddr *)(s))->sa_len);     \ 	bcopy((d),&(idx)->dst, ((const struct sockaddr *)(d))->sa_len);     \ } while (0)
end_define

begin_comment
comment|/*  * set parameters into secasindex buffer.  * Must allocate secasindex buffer before calling this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECASIDX
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|r
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secasindex));                             \ 	(idx)->proto = (p);                                                  \ 	(idx)->mode = (m);                                                   \ 	(idx)->reqid = (r);                                                  \ 	bcopy((s),&(idx)->src, ((const struct sockaddr *)(s))->sa_len);     \ 	bcopy((d),&(idx)->dst, ((const struct sockaddr *)(d))->sa_len);     \ 	key_porttosaddr(&(idx)->src.sa, 0);				     \ 	key_porttosaddr(&(idx)->dst.sa, 0);				     \ } while (0)
end_define

begin_comment
comment|/* key statistics */
end_comment

begin_struct
struct|struct
name|_keystat
block|{
name|u_long
name|getspi_count
decl_stmt|;
comment|/* the avarage of count to try to get new SPI */
block|}
name|keystat
struct|;
end_struct

begin_struct
struct|struct
name|sadb_msghdr
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extoff
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extlen
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|supported_ealgs
block|{
name|int
name|sadb_alg
decl_stmt|;
specifier|const
name|struct
name|enc_xform
modifier|*
name|xform
decl_stmt|;
block|}
name|supported_ealgs
index|[]
init|=
block|{
block|{
name|SADB_EALG_DESCBC
block|,
operator|&
name|enc_xform_des
block|}
block|,
block|{
name|SADB_EALG_3DESCBC
block|,
operator|&
name|enc_xform_3des
block|}
block|,
block|{
name|SADB_X_EALG_AES
block|,
operator|&
name|enc_xform_rijndael128
block|}
block|,
block|{
name|SADB_X_EALG_BLOWFISHCBC
block|,
operator|&
name|enc_xform_blf
block|}
block|,
block|{
name|SADB_X_EALG_CAST128CBC
block|,
operator|&
name|enc_xform_cast5
block|}
block|,
block|{
name|SADB_EALG_NULL
block|,
operator|&
name|enc_xform_null
block|}
block|,
block|{
name|SADB_X_EALG_CAMELLIACBC
block|,
operator|&
name|enc_xform_camellia
block|}
block|,
block|{
name|SADB_X_EALG_AESCTR
block|,
operator|&
name|enc_xform_aes_icm
block|}
block|,
block|{
name|SADB_X_EALG_AESGCM16
block|,
operator|&
name|enc_xform_aes_nist_gcm
block|}
block|,
block|{
name|SADB_X_EALG_AESGMAC
block|,
operator|&
name|enc_xform_aes_nist_gmac
block|}
block|, }
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|supported_aalgs
block|{
name|int
name|sadb_alg
decl_stmt|;
specifier|const
name|struct
name|auth_hash
modifier|*
name|xform
decl_stmt|;
block|}
name|supported_aalgs
index|[]
init|=
block|{
block|{
name|SADB_X_AALG_NULL
block|,
operator|&
name|auth_hash_null
block|}
block|,
block|{
name|SADB_AALG_MD5HMAC
block|,
operator|&
name|auth_hash_hmac_md5
block|}
block|,
block|{
name|SADB_AALG_SHA1HMAC
block|,
operator|&
name|auth_hash_hmac_sha1
block|}
block|,
block|{
name|SADB_X_AALG_RIPEMD160HMAC
block|,
operator|&
name|auth_hash_hmac_ripemd_160
block|}
block|,
block|{
name|SADB_X_AALG_MD5
block|,
operator|&
name|auth_hash_key_md5
block|}
block|,
block|{
name|SADB_X_AALG_SHA
block|,
operator|&
name|auth_hash_key_sha1
block|}
block|,
block|{
name|SADB_X_AALG_SHA2_256
block|,
operator|&
name|auth_hash_hmac_sha2_256
block|}
block|,
block|{
name|SADB_X_AALG_SHA2_384
block|,
operator|&
name|auth_hash_hmac_sha2_384
block|}
block|,
block|{
name|SADB_X_AALG_SHA2_512
block|,
operator|&
name|auth_hash_hmac_sha2_512
block|}
block|,
block|{
name|SADB_X_AALG_AES128GMAC
block|,
operator|&
name|auth_hash_nist_gmac_aes_128
block|}
block|,
block|{
name|SADB_X_AALG_AES192GMAC
block|,
operator|&
name|auth_hash_nist_gmac_aes_192
block|}
block|,
block|{
name|SADB_X_AALG_AES256GMAC
block|,
operator|&
name|auth_hash_nist_gmac_aes_256
block|}
block|, }
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|supported_calgs
block|{
name|int
name|sadb_alg
decl_stmt|;
specifier|const
name|struct
name|comp_algo
modifier|*
name|xform
decl_stmt|;
block|}
name|supported_calgs
index|[]
init|=
block|{
block|{
name|SADB_X_CALG_DEFLATE
block|,
operator|&
name|comp_algo_deflate
block|}
block|, }
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|callout
name|key_timer
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|key_unlink
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_gather_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spdadd
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|key_getnewspid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spddelete
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spddelete2
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spdget
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spdflush
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spddump
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_sp2mbuf
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|key_getspreqmsglen
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_spdexpire
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
parameter_list|(
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_freesah
parameter_list|(
name|struct
name|secashead
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_delsah
parameter_list|(
name|struct
name|secashead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
parameter_list|(
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|,
name|struct
name|secasindex
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_delsav
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_unlinksav
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
parameter_list|(
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_checkspidup
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_setnatt
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_setsaval
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_updatelifetimes
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_updateaddresses
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|,
name|struct
name|secasvar
modifier|*
parameter_list|,
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
parameter_list|(
name|u_int8_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|pid_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
parameter_list|(
name|u_int16_t
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxport
parameter_list|(
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxtype
parameter_list|(
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
parameter_list|(
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsareplay
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
parameter_list|(
name|u_int16_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|seckey
modifier|*
name|key_dup_keymsg
parameter_list|(
specifier|const
name|struct
name|sadb_key
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|malloc_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|seclifetime
modifier|*
name|key_dup_lifemsg
parameter_list|(
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|src
parameter_list|,
name|struct
name|malloc_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* flags for key_cmpsaidx() */
end_comment

begin_define
define|#
directive|define
name|CMP_HEAD
value|1
end_define

begin_comment
comment|/* protocol, addresses. */
end_comment

begin_define
define|#
directive|define
name|CMP_MODE_REQID
value|2
end_define

begin_comment
comment|/* additionally HEAD, reqid, mode. */
end_comment

begin_define
define|#
directive|define
name|CMP_REQID
value|3
end_define

begin_comment
comment|/* additionally HEAD, reaid. */
end_comment

begin_define
define|#
directive|define
name|CMP_EXACTLY
value|4
end_define

begin_comment
comment|/* all elements. */
end_comment

begin_function_decl
specifier|static
name|int
name|key_cmpsaidx
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_cmpspidx_exactly
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_cmpspidx_withmask
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_bbcmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|key_satype2proto
parameter_list|(
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|key_proto2satype
parameter_list|(
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_getspi
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|key_do_getnewspi
parameter_list|(
name|struct
name|sadb_spirange
modifier|*
parameter_list|,
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_update
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_add
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_setident
parameter_list|(
name|struct
name|secashead
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_delete
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_delete_all
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|,
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_delete_xform
parameter_list|(
specifier|const
name|struct
name|xformsw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_get
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|key_getcomb_setlifetime
parameter_list|(
name|struct
name|sadb_comb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ealg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_acquire
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
name|struct
name|secpolicy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|key_newacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|key_getacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_acqdone
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_acqreset
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_acquire2
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_register
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_expire
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_flush
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_dump
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_promisc
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_senderror
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_validate_ext
parameter_list|(
specifier|const
name|struct
name|sadb_ext
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|key_align
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setlifetime
parameter_list|(
name|struct
name|seclifetime
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setkey
parameter_list|(
name|struct
name|seckey
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xform_init
parameter_list|(
name|struct
name|secasvar
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DBG_IPSEC_INITREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|do {				\ 	refcount_init(&(p)->refcnt, 1);				\ 	KEYDBG(KEY_STAMP,					\ 	    printf("%s: Initialize refcnt %s(%p) = %u\n",	\ 	    __func__, #t, (p), (p)->refcnt));			\ } while (0)
end_define

begin_define
define|#
directive|define
name|DBG_IPSEC_ADDREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|do {				\ 	refcount_acquire(&(p)->refcnt);				\ 	KEYDBG(KEY_STAMP,					\ 	    printf("%s: Acquire refcnt %s(%p) -> %u\n",		\ 	    __func__, #t, (p), (p)->refcnt));			\ } while (0)
end_define

begin_define
define|#
directive|define
name|DBG_IPSEC_DELREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|do {				\ 	KEYDBG(KEY_STAMP,					\ 	    printf("%s: Release refcnt %s(%p) -> %u\n",		\ 	    __func__, #t, (p), (p)->refcnt - 1));		\ 	refcount_release(&(p)->refcnt);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|IPSEC_INITREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|refcount_init(&(p)->refcnt, 1)
end_define

begin_define
define|#
directive|define
name|IPSEC_ADDREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|refcount_acquire(&(p)->refcnt)
end_define

begin_define
define|#
directive|define
name|IPSEC_DELREF
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|refcount_release(&(p)->refcnt)
end_define

begin_define
define|#
directive|define
name|SP_INITREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_INITREF(SP, p)
end_define

begin_define
define|#
directive|define
name|SP_ADDREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_ADDREF(SP, p)
end_define

begin_define
define|#
directive|define
name|SP_DELREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_DELREF(SP, p)
end_define

begin_define
define|#
directive|define
name|SAH_INITREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_INITREF(SAH, p)
end_define

begin_define
define|#
directive|define
name|SAH_ADDREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_ADDREF(SAH, p)
end_define

begin_define
define|#
directive|define
name|SAH_DELREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_DELREF(SAH, p)
end_define

begin_define
define|#
directive|define
name|SAV_INITREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_INITREF(SAV, p)
end_define

begin_define
define|#
directive|define
name|SAV_ADDREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_ADDREF(SAV, p)
end_define

begin_define
define|#
directive|define
name|SAV_DELREF
parameter_list|(
name|p
parameter_list|)
value|IPSEC_DELREF(SAV, p)
end_define

begin_comment
comment|/*  * Update the refcnt while holding the SPTREE lock.  */
end_comment

begin_function
name|void
name|key_addref
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 0 when there are known to be no SP's for the specified  * direction.  Otherwise return 1.  This is used by IPsec code  * to optimize performance.  */
end_comment

begin_function
name|int
name|key_havesp
parameter_list|(
name|u_int
name|dir
parameter_list|)
block|{
return|return
operator|(
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|?
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_sptree
index|[
name|dir
index|]
argument_list|)
operator|!=
name|NULL
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* %%% IPsec policy management */
end_comment

begin_comment
comment|/*  * Return current SPDB generation.  */
end_comment

begin_function
name|uint32_t
name|key_getspgen
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|V_sp_genid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|key_bumpspgen
parameter_list|(
name|void
parameter_list|)
block|{
name|V_sp_genid
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_checksockaddrs
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|)
block|{
comment|/* family match */
if|if
condition|(
name|src
operator|->
name|sa_family
operator|!=
name|dst
operator|->
name|sa_family
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* sa_len match */
if|if
condition|(
name|src
operator|->
name|sa_len
operator|!=
name|dst
operator|->
name|sa_len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|src
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|src
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|src
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SP for OUTBOUND or INBOUND packet.  * Must call key_freesp() later.  * OUT:	NULL:	not found  *	others:	found and return the pointer.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_allocsp
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|,
name|u_int
name|dir
parameter_list|)
block|{
name|SPTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|spidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null spidx"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|dir
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpspidx_withmask
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|,
name|spidx
argument_list|)
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
comment|/* found a SPD entry */
name|sp
operator|->
name|lastused
operator|=
name|time_second
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: return SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYDBG
argument_list|(
argument|IPSEC_DATA
argument_list|,
argument|printf(
literal|"%s: lookup failed for "
argument|, __func__); 		    kdebug_secpolicyindex(spidx, NULL)
argument_list|)
empty_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocating an SA entry for an *INBOUND* or *OUTBOUND* TCP packet, signed  * or should be signed by MD5 signature.  * We don't use key_allocsa() for such lookups, because we don't know SPI.  * Unlike ESP and AH protocols, SPI isn't transmitted in the TCP header with  * signed packet. We use SADB only as storage for password.  * OUT:	positive:	corresponding SA for given saidx found.  *	NULL:		SA not found  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa_tcpmd5
parameter_list|(
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|proto
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|saidx
operator|->
name|proto
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TCPMD5
argument_list|,
operator|(
literal|"unexpected mode %u"
operator|,
name|saidx
operator|->
name|mode
operator|)
argument_list|)
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
name|KEYDBG
argument_list|(
argument|IPSEC_DUMP
argument_list|,
argument|printf(
literal|"%s: checking SAH\n"
argument|, __func__); 		    kdebug_secash(sah,
literal|"  "
argument|)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|IPPROTO_TCP
condition|)
continue|continue;
if|if
condition|(
operator|!
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
name|sav
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|secasvar_queue
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
else|else
name|sav
operator|=
name|NULL
expr_stmt|;
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: return SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA not found\n"
argument_list|,
name|__func__
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasindex
argument_list|(
name|saidx
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sav
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocating an SA entry for an *OUTBOUND* packet.  * OUT:	positive:	corresponding SA for given saidx found.  *	NULL:		SA not found, but will be acquired, check *error  *			for acquiring status.  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null saidx"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TRANSPORT
operator|||
name|saidx
operator|->
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
argument_list|,
operator|(
literal|"unexpected policy %u"
operator|,
name|saidx
operator|->
name|mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We check new SA in the IPsec request because a different 	 * SA may be involved each time this request is checked, either 	 * because new SAs are being configured, or this request is 	 * associated with an unconnected datagram socket, or this request 	 * is associated with a system default policy. 	 */
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
name|KEYDBG
argument_list|(
argument|IPSEC_DUMP
argument_list|,
argument|printf(
literal|"%s: checking SAH\n"
argument|, __func__); 		    kdebug_secash(sah,
literal|"  "
argument|)
argument_list|)
empty_stmt|;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Allocate the oldest SA available according to 		 * draft-jenkins-ipsec-rekeying-03. 		 */
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
name|sav
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|secasvar_queue
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
else|else
name|sav
operator|=
name|NULL
expr_stmt|;
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
literal|0
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: chosen SA(%p) for SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sav
operator|)
return|;
comment|/* return referenced SA */
block|}
comment|/* there is no SA */
operator|*
name|error
operator|=
name|key_acquire
argument_list|(
name|saidx
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|error
operator|)
operator|!=
literal|0
condition|)
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: error %d returned from key_acquire()\n"
operator|,
name|__func__
operator|,
operator|*
name|error
operator|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: acquire SA for SP(%p), error %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
operator|*
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasindex
argument_list|(
name|saidx
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a usable SA entry for a *INBOUND* packet.  * Must call key_freesav() later.  * OUT: positive:	pointer to a usable sav (i.e. MATURE or DYING state).  *	NULL:		not found, or error occurred.  *  * According to RFC 2401 SA is uniquely identified by a triple SPI,  * destination address, and security protocol. But according to RFC 4301,  * SPI by itself suffices to specify an SA.  *  * Note that, however, we do need to keep source address in IPsec SA.  * IKE specification and PF_KEY specification do assume that we  * keep source address in IPsec SA.  We see a tricky situation here.  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa
parameter_list|(
name|union
name|sockaddr_union
modifier|*
name|dst
parameter_list|,
name|uint8_t
name|proto
parameter_list|,
name|uint32_t
name|spi
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|proto
operator|==
name|IPPROTO_ESP
operator|||
name|proto
operator|==
name|IPPROTO_AH
operator|||
name|proto
operator|==
name|IPPROTO_IPCOMP
argument_list|,
operator|(
literal|"unexpected security protocol %u"
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|SAVHASH_HASH(spi)
argument_list|,
argument|spihash
argument_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
name|spi
condition|)
break|break;
block|}
comment|/* 	 * We use single SPI namespace for all protocols, so it is 	 * impossible to have SPI duplicates in the SAVHASH. 	 */
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_LARVAL
operator|&&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|==
name|proto
operator|&&
name|key_sockaddrcmp
argument_list|(
operator|&
name|dst
operator|->
name|sa
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|KEYDBG
argument_list|(
argument|IPSEC_STAMP
argument_list|,
argument|char buf[IPSEC_ADDRSTRLEN]; 		    printf(
literal|"%s: SA not found for spi %u proto %u dst %s\n"
argument|, 			__func__, ntohl(spi), proto, ipsec_address(dst, buf, 			sizeof(buf)))
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: return SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sav
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa_tunnel
parameter_list|(
name|union
name|sockaddr_union
modifier|*
name|src
parameter_list|,
name|union
name|sockaddr_union
modifier|*
name|dst
parameter_list|,
name|uint8_t
name|proto
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|src
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null src address"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|dst
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null dst address"
operator|)
argument_list|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_TUNNEL
argument_list|,
literal|0
argument_list|,
operator|&
name|src
operator|->
name|sa
argument_list|,
operator|&
name|dst
operator|->
name|sa
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(&saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|IPSEC_MODE_TUNNEL
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|mode
condition|)
continue|continue;
if|if
condition|(
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|src
operator|->
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|dst
operator|->
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* XXXAE: is key_preferred_oldsa reasonably?*/
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
name|sav
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|secasvar_queue
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: return SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sav
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  */
end_comment

begin_function
name|void
name|key_freesp
parameter_list|(
name|struct
name|secpolicy
modifier|*
modifier|*
name|spp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
init|=
operator|*
name|spp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sp"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_DELREF
argument_list|(
name|sp
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: last reference to SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|spp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|tcount
operator|>
literal|0
condition|)
name|ipsec_delisr
argument_list|(
name|sp
operator|->
name|req
index|[
operator|--
name|sp
operator|->
name|tcount
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_IPSEC_SP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_unlink
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|sp
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|sp
operator|->
name|spidx
operator|.
name|dir
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|IPSEC_SPSTATE_ALIVE
condition|)
block|{
comment|/* SP is already unlinked */
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_sptree
index|[
name|sp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
name|V_sp_genid
operator|++
expr_stmt|;
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * insert a secpolicy into the SP database. Lower priorities first  */
end_comment

begin_function
specifier|static
name|void
name|key_insertsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|newsp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|SPTREE_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[newsp->spidx.dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|newsp
operator|->
name|priority
operator|<
name|sp
operator|->
name|priority
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|sp
argument_list|,
name|newsp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|V_sptree
index|[
name|newsp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|newsp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|done
label|:
name|LIST_INSERT_HEAD
argument_list|(
name|SPHASH_HASH
argument_list|(
name|newsp
operator|->
name|id
argument_list|)
argument_list|,
name|newsp
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_ALIVE
expr_stmt|;
name|V_sp_genid
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a bunch of VTI secpolicies into the SPDB.  * We keep VTI policies in the separate list due to following reasons:  * 1) they should be immutable to user's or some deamon's attempts to  *    delete. The only way delete such policies - destroy or unconfigure  *    corresponding virtual inteface.  * 2) such policies have traffic selector that matches all traffic per  *    address family.  * Since all VTI policies have the same priority, we don't care about  * policies order.  */
end_comment

begin_function
name|int
name|key_register_ifnet
parameter_list|(
name|struct
name|secpolicy
modifier|*
modifier|*
name|spp
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * First of try to acquire id for each SP. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spp
index|[
name|i
index|]
operator|->
name|id
operator|=
name|key_getnewspid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|V_sptree_ifnet
index|[
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|spp
index|[
name|i
index|]
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* 		 * NOTE: despite the fact that we keep VTI SP in the 		 * separate list, SPHASH contains policies from both 		 * sources. Thus SADB_X_SPDGET will correctly return 		 * SP by id, because it uses SPHASH for lookups. 		 */
name|LIST_INSERT_HEAD
argument_list|(
name|SPHASH_HASH
argument_list|(
name|spp
index|[
name|i
index|]
operator|->
name|id
argument_list|)
argument_list|,
name|spp
index|[
name|i
index|]
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
name|spp
index|[
name|i
index|]
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_IFNET
expr_stmt|;
block|}
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Notify user processes about new SP. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|key_setdumpsp
argument_list|(
name|spp
index|[
name|i
index|]
argument_list|,
name|SADB_X_SPDADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|key_unregister_ifnet
parameter_list|(
name|struct
name|secpolicy
modifier|*
modifier|*
name|spp
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_INBOUND
operator|||
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
argument_list|,
operator|(
literal|"invalid direction %u"
operator|,
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spp
index|[
name|i
index|]
operator|->
name|state
operator|!=
name|IPSEC_SPSTATE_IFNET
condition|)
continue|continue;
name|spp
index|[
name|i
index|]
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_sptree_ifnet
index|[
name|spp
index|[
name|i
index|]
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|spp
index|[
name|i
index|]
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|spp
index|[
name|i
index|]
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
block|}
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|key_setdumpsp
argument_list|(
name|spp
index|[
name|i
index|]
argument_list|,
name|SADB_X_SPDDELETE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsa().  * This function is called by key_freesp() to free some SA allocated  * for a policy.  */
end_comment

begin_function
name|void
name|key_freesav
parameter_list|(
name|struct
name|secasvar
modifier|*
modifier|*
name|psav
parameter_list|)
block|{
name|struct
name|secasvar
modifier|*
name|sav
init|=
operator|*
name|psav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SAV_DELREF
argument_list|(
name|sav
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: last reference to SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|psav
operator|=
name|NULL
expr_stmt|;
name|key_delsav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlink SA from SAH and SPI hash under SAHTREE_WLOCK.  * Expect that SA has extra reference due to lookup.  * Release this references, also release SAH reference after unlink.  */
end_comment

begin_function
specifier|static
name|void
name|key_unlinksav
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|SAHTREE_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
comment|/* SA is already unlinked */
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Unlink from SAH */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_LARVAL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_larval
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Unlink from SPI hash */
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|sah
operator|=
name|sav
operator|->
name|sah
expr_stmt|;
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* Since we are unlinked, release reference to SAH */
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* %%% SPD management */
end_comment

begin_comment
comment|/*  * search SPD  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|SPTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|spidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null spidx"
operator|)
argument_list|)
expr_stmt|;
name|SPTREE_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[spidx->dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|sp
operator|->
name|spidx
argument_list|)
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * get SP by index.  * OUT:	NULL	: not found  *	others	: found, pointer to referenced SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
parameter_list|(
name|uint32_t
name|id
parameter_list|)
block|{
name|SPTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|SPTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|SPHASH_HASH(id)
argument_list|,
argument|idhash
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|secpolicy
modifier|*
name|key_newsp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|M_IPSEC_SP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|SP_INITREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ipsecrequest
modifier|*
name|ipsec_newisr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ipsecrequest
argument_list|)
argument_list|,
name|M_IPSEC_SR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ipsec_delisr
parameter_list|(
name|struct
name|ipsecrequest
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|,
name|M_IPSEC_SR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create secpolicy structure from sadb_x_policy structure.  * NOTE: `state', `secpolicyindex' and 'id' in secpolicy structure  * are not set, so must be set properly later.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_msg2sp
parameter_list|(
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|xpl0
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null xpl0"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
argument_list|,
operator|(
literal|"policy too short: %zu"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid msg length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_newsp
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsp
operator|->
name|spidx
operator|.
name|dir
operator|=
name|xpl0
operator|->
name|sadb_x_policy_dir
expr_stmt|;
name|newsp
operator|->
name|policy
operator|=
name|xpl0
operator|->
name|sadb_x_policy_type
expr_stmt|;
name|newsp
operator|->
name|priority
operator|=
name|xpl0
operator|->
name|sadb_x_policy_priority
expr_stmt|;
name|newsp
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
comment|/* check policy */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
block|{
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|int
name|tlen
decl_stmt|;
comment|/* validity check */
if|if
condition|(
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid msg length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tlen
operator|=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
expr_stmt|;
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
name|xpl0
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
comment|/* length check */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|||
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|>
name|tlen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid ipsecrequest "
literal|"length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|newsp
operator|->
name|tcount
operator|>=
name|IPSEC_MAXREQ
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: too many ipsecrequests.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* allocate request buffer */
comment|/* NB: data structure is zero'd */
name|isr
operator|=
name|ipsec_newisr
argument_list|()
expr_stmt|;
if|if
condition|(
name|isr
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsp
operator|->
name|req
index|[
name|newsp
operator|->
name|tcount
operator|++
index|]
operator|=
name|isr
expr_stmt|;
comment|/* set values */
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_IPCOMP
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid proto type=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|isr
operator|->
name|saidx
operator|.
name|proto
operator|=
operator|(
name|uint8_t
operator|)
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid mode=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|isr
operator|->
name|saidx
operator|.
name|mode
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
condition|)
block|{
case|case
name|IPSEC_LEVEL_DEFAULT
case|:
case|case
name|IPSEC_LEVEL_USE
case|:
case|case
name|IPSEC_LEVEL_REQUIRE
case|:
break|break;
case|case
name|IPSEC_LEVEL_UNIQUE
case|:
comment|/* validity check */
comment|/* 				 * If range violation of reqid, kernel will 				 * update it, don't refuse it. 				 */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|>
name|IPSEC_MANUAL_REQID_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: reqid=%d range "
literal|"violation, updated by kernel.\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|)
argument_list|)
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* allocate new reqid id if reqid is zero. */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|reqid
decl_stmt|;
if|if
condition|(
operator|(
name|reqid
operator|=
name|key_newreqid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|isr
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|reqid
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|reqid
expr_stmt|;
block|}
else|else
block|{
comment|/* set it for manual keying. */
name|isr
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
expr_stmt|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid level=%u\n"
operator|,
name|__func__
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|isr
operator|->
name|level
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
expr_stmt|;
comment|/* set IP addresses if there */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|paddr
decl_stmt|;
name|len
operator|=
name|tlen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|xisr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|||
name|len
operator|<
literal|2
operator|*
name|paddr
operator|->
name|sa_len
operator|||
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"request address length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 				 * Request length should be enough to keep 				 * source and destination addresses. 				 */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|+
literal|2
operator|*
name|paddr
operator|->
name|sa_len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"ipsecrequest length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|paddr
operator|+
name|paddr
operator|->
name|sa_len
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|!=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid "
literal|"request address length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* AF family should match */
if|if
condition|(
name|paddr
operator|->
name|sa_family
operator|!=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address "
literal|"family doesn't match.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
name|isr
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Addresses for TUNNEL mode requests are 				 * mandatory. 				 */
if|if
condition|(
name|isr
operator|->
name|saidx
operator|.
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: missing "
literal|"request addresses.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|tlen
operator|-=
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: becoming tlen< 0.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|xisr
operator|+
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|)
expr_stmt|;
block|}
comment|/* XXXAE: LARVAL SP */
if|if
condition|(
name|newsp
operator|->
name|tcount
operator|<
literal|1
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: valid IPSEC transforms "
literal|"not found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid policy type.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|newsp
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|key_newreqid
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|uint32_t
name|auto_reqid
init|=
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|auto_reqid
operator|==
operator|~
literal|0
condition|)
name|auto_reqid
operator|=
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
expr_stmt|;
else|else
name|auto_reqid
operator|++
expr_stmt|;
comment|/* XXX should be unique check */
return|return
operator|(
name|auto_reqid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copy secpolicy struct to sadb_x_policy structure indicated.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_sp2mbuf
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|tlen
operator|=
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|tlen
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
name|key_sp2msg
argument_list|(
name|sp
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
operator|&
name|tlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|int
name|key_sp2msg
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|void
modifier|*
name|request
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|size_t
name|xlen
decl_stmt|,
name|ilen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null policy"
operator|)
argument_list|)
expr_stmt|;
name|xlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|len
operator|<
name|xlen
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|request
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|xpl
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|request
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_type
operator|=
name|sp
operator|->
name|policy
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_dir
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dir
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_priority
operator|=
name|sp
operator|->
name|priority
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|IPSEC_SPSTATE_IFNET
case|:
name|xpl
operator|->
name|sadb_x_policy_scope
operator|=
name|IPSEC_POLICYSCOPE_IFNET
expr_stmt|;
break|break;
case|case
name|IPSEC_SPSTATE_PCB
case|:
name|xpl
operator|->
name|sadb_x_policy_scope
operator|=
name|IPSEC_POLICYSCOPE_PCB
expr_stmt|;
break|break;
default|default:
name|xpl
operator|->
name|sadb_x_policy_scope
operator|=
name|IPSEC_POLICYSCOPE_GLOBAL
expr_stmt|;
block|}
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|xpl
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|tcount
condition|;
name|i
operator|++
control|)
block|{
name|isr
operator|=
name|sp
operator|->
name|req
index|[
name|i
index|]
expr_stmt|;
name|ilen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|xlen
operator|+=
name|ilen
expr_stmt|;
if|if
condition|(
name|xlen
operator|>
operator|*
name|len
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
comment|/* Calculate needed size */
continue|continue;
block|}
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
name|p
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|=
name|ilen
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|=
name|isr
operator|->
name|saidx
operator|.
name|proto
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|=
name|isr
operator|->
name|saidx
operator|.
name|mode
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|=
name|isr
operator|->
name|level
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|isr
operator|->
name|saidx
operator|.
name|reqid
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
block|}
block|}
name|xpl
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|xlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|len
operator|=
name|xlen
expr_stmt|;
else|else
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* m will not be freed nor modified */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_gather_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|int
name|ndeep
parameter_list|,
name|int
name|nitem
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|nitem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitem
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
name|SADB_EXT_MAX
condition|)
goto|goto
name|fail
goto|;
comment|/* don't attempt to pull empty extension */
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
operator|&&
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|!=
name|SADB_EXT_RESERVED
operator|&&
operator|(
name|mhp
operator|->
name|ext
index|[
name|idx
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
condition|)
block|{
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|len
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"header too big %u"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
goto|goto
name|fail
goto|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|ndeep
condition|)
block|{
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
expr_stmt|;
name|n
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|m_align
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|n
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|result
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDADD, SADB_X_SPDSETIDX or SADB_X_SPDUPDATE processing  * add an entry to SP database, when received  *<base, address(SD), (lifetime(H),) policy>  * from the user(?).  * Adding to SP database,  * and send  *<base, address(SD), (lifetime(H),) policy>  * to the socket which was send.  *  * SPDADD set a unique policy entry.  * SPDSETIDX like SPDADD without a part of policy requests.  * SPDUPDATE replace a unique policy entry.  *  * XXXAE: serialize this in PF_KEY to avoid races.  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdadd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|,
modifier|*
name|xpl
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lft
init|=
name|NULL
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|lft
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* check the direciton */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid SP direction.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* key_spdadd() accepts DISCARD, NONE and IPSEC. */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_DISCARD
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_NONE
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid policy type.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* policy requests are mandatory when action is ipsec. */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_IPSEC
operator|&&
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: policy requests required.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* make secindex */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* Checking there is SP already or not. */
name|newsp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDUPDATE
condition|)
block|{
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: unlink SP(%p) for SPDUPDATE\n"
argument_list|,
name|__func__
argument_list|,
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
name|key_unlink
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: a SP entry exists already."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* allocate new SP entry */
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_msg2sp
argument_list|(
name|xpl0
argument_list|,
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
name|newsp
operator|->
name|lastused
operator|=
name|newsp
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|newsp
operator|->
name|lifetime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_addtime
else|:
literal|0
expr_stmt|;
name|newsp
operator|->
name|validtime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_usetime
else|:
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spidx
argument_list|,
operator|&
name|newsp
operator|->
name|spidx
argument_list|,
sizeof|sizeof
argument_list|(
name|spidx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXXAE: there is race between key_getsp() and key_insertsp() */
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|newsp
operator|->
name|id
operator|=
name|key_getnewspid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|key_insertsp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mpolicy
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* create new sadb_msg to reply. */
if|if
condition|(
name|lft
condition|)
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|mpolicy
operator|=
name|m_pulldown
argument_list|(
name|n
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpolicy
operator|==
name|NULL
condition|)
block|{
comment|/* n is already freed */
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|xpl
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mpolicy
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|!=
name|SADB_X_EXT_POLICY
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|newsp
operator|->
name|id
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * get new policy id.  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|key_getnewspid
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|uint32_t
name|newid
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|V_key_spi_trycnt
decl_stmt|;
comment|/* XXX */
name|SPTREE_WLOCK_ASSERT
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|V_policy_id
operator|==
operator|~
literal|0
condition|)
comment|/* overflowed */
name|newid
operator|=
name|V_policy_id
operator|=
literal|1
expr_stmt|;
else|else
name|newid
operator|=
operator|++
name|V_policy_id
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|SPHASH_HASH(newid)
argument_list|,
argument|idhash
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|newid
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newid
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: failed to allocate policy id.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|newid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE processing  * receive  *<base, address(SD), policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, address(SD), policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null so"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* check the direciton */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid SP direction.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Only DISCARD, NONE and IPSEC are allowed */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_DISCARD
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_NONE
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid policy type.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* make secindex */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* save policy id to buffer to be returned. */
name|xpl0
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|key_unlink
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE2 processing  * receive  *<base, policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found for id %u.\n"
operator|,
name|__func__
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|key_unlink
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|IPSEC_SPSTATE_DEAD
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: failed to delete SP with id %u.\n"
operator|,
name|__func__
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EACCES
argument_list|)
operator|)
return|;
block|}
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length inconsistency (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDGET processing  * receive  *<base, policy(*)>  * from the user(?),  * and send,  *<base, address(SD), policy>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdget
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SP found for id %u.\n"
operator|,
name|__func__
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDGET
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
else|else
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDACQUIRE processing.  * Acquire policy and SA(s) for a *OUTBOUND* packet.  * send  *<base, policy(*)>  * to KMD, and expect to receive  *<base> with SADB_X_SPDACQUIRE if error occurred,  * or  *<base, policy>  * with SADB_X_SPDUPDATE from KMD by PF_KEY.  * policy(*) is without policy requests.  *  *    0     : succeed  *    others: error number  */
end_comment

begin_function
name|int
name|key_spdacquire
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|secspacq
modifier|*
name|newspacq
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secpolicy"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|req
operator|==
name|NULL
argument_list|,
operator|(
literal|"policy exists"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
argument_list|,
operator|(
literal|"policy not IPSEC %u"
operator|,
name|sp
operator|->
name|policy
operator|)
argument_list|)
expr_stmt|;
comment|/* Get an entry to check whether sent message or not. */
name|newspacq
operator|=
name|key_getspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspacq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|V_key_blockacq_count
operator|<
name|newspacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newspacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newspacq
operator|->
name|count
operator|++
expr_stmt|;
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
name|newspacq
operator|=
name|key_newspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspacq
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
block|}
comment|/* create new sadb_msg to reply. */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDACQUIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|ENOBUFS
return|;
name|result
operator|=
name|m
expr_stmt|;
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDFLUSH processing  * receive  *<base>  * from the user, and free all entries in secpctree.  * and send,  *<base>  * to the user.  * NOTE: what to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdflush
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secpolicy_queue
name|drainq
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|TAILQ_CONCAT
argument_list|(
operator|&
name|drainq
argument_list|,
operator|&
name|V_sptree
index|[
name|dir
index|]
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to set state to DEAD for each policy to be sure, 	 * that another thread won't try to unlink it. 	 * Also remove SP from sphash. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&drainq
argument_list|,
argument|chain
argument_list|)
block|{
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
block|}
name|V_sp_genid
operator|++
expr_stmt|;
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|nextsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|nextsp
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|key_satype2scopemask
parameter_list|(
name|uint8_t
name|satype
parameter_list|)
block|{
if|if
condition|(
name|satype
operator|==
name|IPSEC_POLICYSCOPE_ANY
condition|)
return|return
operator|(
literal|0xff
operator|)
return|;
return|return
operator|(
name|satype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDUMP processing  * receive  *<base>  * from the user, and dump all SP leaves and send,  *<base> .....  * to the ikmpd.  *  * NOTE:  *   sadb_msg_satype is considered as mask of policy scopes.  *   m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddump
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|SPTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|u_int
name|dir
decl_stmt|,
name|scope
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* search SPD entry and get buffer size. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|scope
operator|=
name|key_satype2scopemask
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
expr_stmt|;
name|SPTREE_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
if|if
condition|(
name|scope
operator|&
name|IPSEC_POLICYSCOPE_GLOBAL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|&
name|IPSEC_POLICYSCOPE_IFNET
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree_ifnet[dir]
argument_list|,
argument|chain
argument_list|)
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
if|if
condition|(
name|scope
operator|&
name|IPSEC_POLICYSCOPE_GLOBAL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
operator|--
name|cnt
expr_stmt|;
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDDUMP
argument_list|,
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scope
operator|&
name|IPSEC_POLICYSCOPE_IFNET
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree_ifnet[dir]
argument_list|,
argument|chain
argument_list|)
block|{
operator|--
name|cnt
expr_stmt|;
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDDUMP
argument_list|,
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|pid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|seclifetime
name|lt
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|SADB_SATYPE_UNSPEC
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_sp2mbuf
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lifetime
condition|)
block|{
name|lt
operator|.
name|addtime
operator|=
name|sp
operator|->
name|created
expr_stmt|;
name|lt
operator|.
name|usetime
operator|=
name|sp
operator|->
name|lastused
expr_stmt|;
name|m
operator|=
name|key_setlifetime
argument_list|(
operator|&
name|lt
argument_list|,
name|SADB_EXT_LIFETIME_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|lt
operator|.
name|addtime
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|lt
operator|.
name|usetime
operator|=
name|sp
operator|->
name|validtime
expr_stmt|;
name|m
operator|=
name|key_setlifetime
argument_list|(
operator|&
name|lt
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * get PFKEY message length for security policy and request.  */
end_comment

begin_function
specifier|static
name|size_t
name|key_getspreqmsglen
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|size_t
name|tlen
decl_stmt|,
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
return|return
operator|(
name|tlen
operator|)
return|;
comment|/* get length of ipsec requests */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|tcount
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_ipsecrequest
argument_list|)
operator|+
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|+
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|tlen
operator|+=
name|PFKEY_ALIGN8
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDEXPIRE processing  * send  *<base, address(SD), lifetime(CH), policy>  * to KMD by PF_KEY.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_spdexpire
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secpolicy"
operator|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDEXPIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create lifetime extension (current and hard) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|created
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|lastused
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_HARD
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|validtime
expr_stmt|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set secpolicy */
name|m
operator|=
name|key_sp2mbuf
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* %%% SAD management */
end_comment

begin_comment
comment|/*  * allocating and initialize new SA head.  * OUT:	NULL	: failure due to the lack of memory.  *	others	: pointer to new SA head.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
parameter_list|(
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|sah
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secashead
argument_list|)
argument_list|,
name|M_IPSEC_SAH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
name|sah
operator|->
name|saidx
operator|=
operator|*
name|saidx
expr_stmt|;
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|SAH_INITREF
argument_list|(
name|sah
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SAH(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sah
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secash
argument_list|(
name|sah
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sah
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_freesah
parameter_list|(
name|struct
name|secashead
modifier|*
modifier|*
name|psah
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
init|=
operator|*
name|psah
decl_stmt|;
if|if
condition|(
name|SAH_DELREF
argument_list|(
name|sah
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: last reference to SAH(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sah
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secash
argument_list|(
name|sah
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|psah
operator|=
name|NULL
expr_stmt|;
name|key_delsah
argument_list|(
name|sah
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_delsah
parameter_list|(
name|struct
name|secashead
modifier|*
name|sah
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sah"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
argument_list|,
operator|(
literal|"Attempt to free non DEAD SAH %p"
operator|,
name|sah
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|)
argument_list|,
operator|(
literal|"Attempt to free SAH %p with LARVAL SA"
operator|,
name|sah
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
argument_list|,
operator|(
literal|"Attempt to free SAH %p with ALIVE SA"
operator|,
name|sah
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sah
argument_list|,
name|M_IPSEC_SAH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocating a new SA for key_add() and key_getspi() call,  * and copy the values of mhp into new buffer.  * When SAD message type is SADB_GETSPI set SA state to LARVAL.  * For SADB_ADD create and initialize SA with MATURE state.  * OUT:	NULL	: fail  *	others	: pointer to new secasvar.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
parameter_list|(
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|uint32_t
name|spi
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|int
name|isnew
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_GETSPI
operator|||
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_ADD
argument_list|,
operator|(
literal|"wrong message type"
operator|)
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
name|sah
operator|=
name|NULL
expr_stmt|;
comment|/* check SPI value */
switch|switch
condition|(
name|saidx
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
comment|/* 		 * RFC 4302, 2.4. Security Parameters Index (SPI), SPI values 		 * 1-255 reserved by IANA for future use, 		 * 0 for implementation specific, local use. 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|<=
literal|255
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal range of SPI %u.\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
block|}
name|sav
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|,
name|M_IPSEC_SA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sav
operator|->
name|lock
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lock
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_init
argument_list|(
name|sav
operator|->
name|lock
argument_list|,
literal|"ipsec association"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|uma_zalloc
argument_list|(
name|V_key_lft_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|counter_u64_zero
argument_list|(
name|sav
operator|->
name|lft_c_allocations
argument_list|)
expr_stmt|;
name|counter_u64_zero
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|)
expr_stmt|;
name|sav
operator|->
name|spi
operator|=
name|spi
expr_stmt|;
name|sav
operator|->
name|seq
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
name|sav
operator|->
name|pid
operator|=
operator|(
name|pid_t
operator|)
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
expr_stmt|;
name|SAV_INITREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|again
label|:
name|sah
operator|=
name|key_getsah
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA index */
name|sah
operator|=
name|key_newsah
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|isnew
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isnew
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|sah
operator|=
name|sah
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_GETSPI
condition|)
block|{
name|sav
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_LARVAL
condition|)
block|{
comment|/* 		 * Do not call key_setsaval() second time in case 		 * of `goto again`. We will have MATURE state. 		 */
operator|*
name|errp
operator|=
name|key_setsaval
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
block|}
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Check that existing SAH wasn't unlinked. 	 * Since we didn't hold the SAHTREE lock, it is possible, 	 * that callout handler or key_flush() or key_delete() could 	 * unlink this SAH. 	 */
if|if
condition|(
name|isnew
operator|==
literal|0
operator|&&
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* reference from key_getsah() */
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|isnew
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Add new SAH into SADB. 		 * 		 * XXXAE: we can serialize key_add and key_getspi calls, so 		 * several threads will not fight in the race. 		 * Otherwise we should check under SAHTREE lock, that this 		 * SAH would not added twice. 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_sahtree
argument_list|,
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Add new SAH into hash by addresses */
name|LIST_INSERT_HEAD
argument_list|(
name|SAHADDRHASH_HASH
argument_list|(
name|saidx
argument_list|)
argument_list|,
name|sah
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
comment|/* Now we are linked in the chain */
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
comment|/* 		 * SAV references this new SAH. 		 * In case of existing SAH we reuse reference 		 * from key_getsah(). 		 */
name|SAH_ADDREF
argument_list|(
name|sah
argument_list|)
expr_stmt|;
block|}
comment|/* Link SAV with SAH */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_MATURE
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Add SAV into SPI hash */
name|LIST_INSERT_HEAD
argument_list|(
name|SAVHASH_HASH
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|,
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
comment|/* success */
name|done
label|:
if|if
condition|(
operator|*
name|errp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|lock
operator|!=
name|NULL
condition|)
block|{
name|mtx_destroy
argument_list|(
name|sav
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|lock
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|V_key_lft_zone
argument_list|,
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
argument_list|,
name|M_IPSEC_SA
argument_list|)
operator|,
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
operator|==
name|ENOBUFS
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sav
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_cleansav
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|natt
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|natt
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|natt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_F_CLONED
condition|)
return|return;
comment|/* 	 * Cleanup xform state.  Note that zeroize'ing causes the 	 * keys to be cleared; otherwise we must do it ourself. 	 */
if|if
condition|(
name|sav
operator|->
name|tdb_xform
operator|!=
name|NULL
condition|)
block|{
name|sav
operator|->
name|tdb_xform
operator|->
name|xf_zeroize
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tdb_xform
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|key_data
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sav
operator|->
name|key_enc
operator|->
name|key_data
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|replay
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsav
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
argument_list|,
operator|(
literal|"attempt to free non DEAD SA %p"
operator|,
name|sav
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"reference count %u> 0"
operator|,
name|sav
operator|->
name|refcnt
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * SA must be unlinked from the chain and hashtbl. 	 * If SA was cloned, we leave all fields untouched, 	 * except NAT-T config. 	 */
name|key_cleansav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_F_CLONED
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_destroy
argument_list|(
name|sav
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sav
operator|->
name|lock
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_key_lft_zone
argument_list|,
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * search SAH.  * OUT:  *	NULL	: not found  *	others	: found, referenced pointer to a SAH.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
parameter_list|(
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SAH_ADDREF
argument_list|(
name|sah
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sah
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check not to be duplicated SPI.  * OUT:  *	0	: not found  *	1	: found SA with given SPI.  */
end_comment

begin_function
specifier|static
name|int
name|key_checkspidup
parameter_list|(
name|uint32_t
name|spi
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
comment|/* Assume SPI is in network byte order */
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|SAVHASH_HASH(spi)
argument_list|,
argument|spihash
argument_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
name|spi
condition|)
break|break;
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sav
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search SA by SPI.  * OUT:  *	NULL	: not found  *	others	: found, referenced pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
parameter_list|(
name|uint32_t
name|spi
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
comment|/* Assume SPI is in network byte order */
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|SAVHASH_HASH(spi)
argument_list|,
argument|spihash
argument_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|spi
operator|!=
name|spi
condition|)
continue|continue;
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
break|break;
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sav
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_updatelifetimes
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|seclifetime
modifier|*
name|lft_h
decl_stmt|,
modifier|*
name|lft_s
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Lifetime extension is optional, check that it is present. */
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|&&
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
condition|)
block|{
comment|/* 		 * In case of SADB_UPDATE we may need to change 		 * existing lifetimes. 		 */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_MATURE
condition|)
block|{
name|lft_h
operator|=
name|lft_s
operator|=
name|NULL
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Both HARD and SOFT extensions must present */
if|if
condition|(
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|)
operator|||
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lft_h
operator|=
name|key_dup_lifemsg
argument_list|(
operator|(
specifier|const
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|lft_h
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|lft_s
operator|=
name|key_dup_lifemsg
argument_list|(
operator|(
specifier|const
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|lft_s
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lft_h
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|reset
label|:
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_LARVAL
condition|)
block|{
comment|/* 		 * key_update() holds reference to this SA, 		 * so it won't be deleted in meanwhile. 		 */
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|sav
operator|->
name|lft_h
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|lft_h
expr_stmt|;
name|lft_h
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|sav
operator|->
name|lft_s
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|lft_s
expr_stmt|;
name|lft_s
operator|=
name|tmp
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|lft_h
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lft_h
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|lft_s
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lft_s
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* We can update lifetime without holding a lock */
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
argument_list|,
operator|(
literal|"lft_h is already initialized\n"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
argument_list|,
operator|(
literal|"lft_s is already initialized\n"
operator|)
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|lft_h
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|lft_s
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copy SA values from PF_KEY message except *SPI, SEQ, PID and TYPE*.  * You must update these if need. Expects only LARVAL SAs.  * OUT:	0:	success.  *	!0:	failure.  */
end_comment

begin_function
specifier|static
name|int
name|key_setsaval
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
specifier|const
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
specifier|const
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|uint32_t
name|replay
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_LARVAL
argument_list|,
operator|(
literal|"Attempt to update non LARVAL SA"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX rewrite */
name|error
operator|=
name|key_setident
argument_list|(
name|sav
operator|->
name|sah
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* SA */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sa0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|sav
operator|->
name|alg_auth
operator|=
name|sa0
operator|->
name|sadb_sa_auth
expr_stmt|;
name|sav
operator|->
name|alg_enc
operator|=
name|sa0
operator|->
name|sadb_sa_encrypt
expr_stmt|;
name|sav
operator|->
name|flags
operator|=
name|sa0
operator|->
name|sadb_sa_flags
expr_stmt|;
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_KEY_FLAGS_MAX
operator|)
operator|!=
name|sav
operator|->
name|flags
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sa_flags 0x%08x.\n"
operator|,
name|__func__
operator|,
name|sav
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Optional replay window */
name|replay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sa0
operator|->
name|sadb_sa_flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|==
literal|0
condition|)
name|replay
operator|=
name|sa0
operator|->
name|sadb_sa_replay
expr_stmt|;
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA_REPLAY
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA_REPLAY
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|replay
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|sadb_x_sa_replay
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA_REPLAY
index|]
operator|)
operator|->
name|sadb_x_sa_replay_replay
expr_stmt|;
if|if
condition|(
name|replay
operator|>
name|UINT32_MAX
operator|-
literal|32
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: replay window too big.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|replay
operator|=
operator|(
name|replay
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
name|sav
operator|->
name|replay
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secreplay
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|replay
operator|!=
literal|0
condition|)
block|{
comment|/* number of 32b blocks to be allocated */
name|uint32_t
name|bitmap_size
decl_stmt|;
comment|/* RFC 6479: 			 * - the allocated replay window size must be 			 *   a power of two. 			 * - use an extra 32b block as a redundant window. 			 */
name|bitmap_size
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|replay
operator|+
literal|4
operator|>
name|bitmap_size
condition|)
name|bitmap_size
operator|<<=
literal|1
expr_stmt|;
name|bitmap_size
operator|=
name|bitmap_size
operator|/
literal|4
expr_stmt|;
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|=
name|malloc
argument_list|(
name|bitmap_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|replay
operator|->
name|bitmap_size
operator|=
name|bitmap_size
expr_stmt|;
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|=
name|replay
expr_stmt|;
block|}
block|}
comment|/* Authentication keys */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_X_AALG_NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid key_auth values.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|key_auth
operator|=
name|key_dup_keymsg
argument_list|(
name|key0
argument_list|,
name|len
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Encryption key */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sav
operator|->
name|key_enc
operator|=
name|key_dup_keymsg
argument_list|(
name|key0
argument_list|,
name|len
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
if|if
condition|(
name|len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
comment|/*just in case*/
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid key_enc value.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* set iv */
name|sav
operator|->
name|ivlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
if|if
condition|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid flag (derived) "
literal|"given to AH SA.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_AH
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
operator|(
name|SADB_X_EXT_OLD
operator||
name|SADB_X_EXT_DERIV
operator|)
operator|)
operator|==
operator|(
name|SADB_X_EXT_OLD
operator||
name|SADB_X_EXT_DERIV
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid flag (derived) "
literal|"given to old-esp.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_ESP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
if|if
condition|(
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_AALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_RAWCPI
operator|)
operator|==
literal|0
operator|&&
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid cpi for IPComp.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_IPCOMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: protocol and algorithm "
literal|"mismated.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|xform_init
argument_list|(
name|sav
argument_list|,
name|XF_TCPSIGNATURE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Invalid satype.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unable to initialize SA type %u.\n"
operator|,
name|__func__
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Handle NAT-T headers */
name|error
operator|=
name|key_setnatt
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Initialize lifetime for CURRENT */
name|sav
operator|->
name|firstused
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
comment|/* lifetimes for HARD and SOFT */
name|error
operator|=
name|key_updatelifetimes
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|key_cleansav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * subroutine for SADB_GET and SADB_DUMP.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|satype
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
name|struct
name|seclifetime
name|lft_c
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|tres
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dumporder
index|[]
init|=
block|{
name|SADB_EXT_SA
block|,
name|SADB_X_EXT_SA2
block|,
name|SADB_X_EXT_SA_REPLAY
block|,
name|SADB_EXT_LIFETIME_HARD
block|,
name|SADB_EXT_LIFETIME_SOFT
block|,
name|SADB_EXT_LIFETIME_CURRENT
block|,
name|SADB_EXT_ADDRESS_SRC
block|,
name|SADB_EXT_ADDRESS_DST
block|,
name|SADB_EXT_ADDRESS_PROXY
block|,
name|SADB_EXT_KEY_AUTH
block|,
name|SADB_EXT_KEY_ENCRYPT
block|,
name|SADB_EXT_IDENTITY_SRC
block|,
name|SADB_EXT_IDENTITY_DST
block|,
name|SADB_EXT_SENSITIVITY
block|,
name|SADB_X_EXT_NAT_T_TYPE
block|,
name|SADB_X_EXT_NAT_T_SPORT
block|,
name|SADB_X_EXT_NAT_T_DPORT
block|,
name|SADB_X_EXT_NAT_T_OAI
block|,
name|SADB_X_EXT_NAT_T_OAR
block|,
name|SADB_X_EXT_NAT_T_FRAG
block|, 	}
decl_stmt|;
name|uint32_t
name|replay_count
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nitems
argument_list|(
name|dumporder
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|dumporder
index|[
name|i
index|]
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_SA2
case|:
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|replay_count
operator|=
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|replay_count
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_SA_REPLAY
case|:
if|if
condition|(
name|sav
operator|->
name|replay
operator|==
name|NULL
operator|||
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|<=
name|UINT8_MAX
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbxsareplay
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_DST
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_KEY_AUTH
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_auth
condition|)
continue|continue;
name|m
operator|=
name|key_setkey
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_enc
condition|)
continue|continue;
name|m
operator|=
name|key_setkey
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
name|lft_c
operator|.
name|addtime
operator|=
name|sav
operator|->
name|created
expr_stmt|;
name|lft_c
operator|.
name|allocations
operator|=
operator|(
name|uint32_t
operator|)
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_allocations
argument_list|)
expr_stmt|;
name|lft_c
operator|.
name|bytes
operator|=
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|)
expr_stmt|;
name|lft_c
operator|.
name|usetime
operator|=
name|sav
operator|->
name|firstused
expr_stmt|;
name|m
operator|=
name|key_setlifetime
argument_list|(
operator|&
name|lft_c
argument_list|,
name|SADB_EXT_LIFETIME_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_h
condition|)
continue|continue;
name|m
operator|=
name|key_setlifetime
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_s
condition|)
continue|continue;
name|m
operator|=
name|key_setlifetime
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_TYPE
case|:
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbxtype
argument_list|(
name|UDP_ENCAP_ESPINUDP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_DPORT
case|:
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbxport
argument_list|(
name|sav
operator|->
name|natt
operator|->
name|dport
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_SPORT
case|:
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbxport
argument_list|(
name|sav
operator|->
name|natt
operator|->
name|sport
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_OAI
case|:
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
operator|||
operator|(
name|sav
operator|->
name|natt
operator|->
name|flags
operator|&
name|IPSEC_NATT_F_OAI
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_X_EXT_NAT_T_OAI
argument_list|,
operator|&
name|sav
operator|->
name|natt
operator|->
name|oai
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_OAR
case|:
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
operator|||
operator|(
name|sav
operator|->
name|natt
operator|->
name|flags
operator|&
name|IPSEC_NATT_F_OAR
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_X_EXT_NAT_T_OAR
argument_list|,
operator|&
name|sav
operator|->
name|natt
operator|->
name|oar
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_NAT_T_FRAG
case|:
comment|/* We do not (yet) support those. */
continue|continue;
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
comment|/* XXX: should we brought from SPD ? */
case|case
name|SADB_EXT_SENSITIVITY
case|:
default|default:
continue|continue;
block|}
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|tres
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|tres
argument_list|)
expr_stmt|;
name|tres
operator|=
name|m
expr_stmt|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|tres
argument_list|)
expr_stmt|;
name|tres
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tres
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_msg.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
parameter_list|(
name|u_int8_t
name|type
parameter_list|,
name|u_int16_t
name|tlen
parameter_list|,
name|u_int8_t
name|satype
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|u_int16_t
name|reserved
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|NULL
return|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_version
operator|=
name|PF_KEY_V2
expr_stmt|;
name|p
operator|->
name|sadb_msg_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_msg_satype
operator|=
name|satype
expr_stmt|;
name|p
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_reserved
operator|=
name|reserved
expr_stmt|;
name|p
operator|->
name|sadb_msg_seq
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_msg_pid
operator|=
operator|(
name|u_int32_t
operator|)
name|pid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * copy secasvar data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_sa
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|p
operator|->
name|sadb_sa_spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|p
operator|->
name|sadb_sa_replay
operator|=
name|sav
operator|->
name|replay
condition|?
operator|(
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|>
name|UINT8_MAX
condition|?
name|UINT8_MAX
else|:
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_sa_state
operator|=
name|sav
operator|->
name|state
expr_stmt|;
name|p
operator|->
name|sadb_sa_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|p
operator|->
name|sadb_sa_encrypt
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|p
operator|->
name|sadb_sa_flags
operator|=
name|sav
operator|->
name|flags
operator|&
name|SADB_KEY_FLAGS_MAX
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
parameter_list|(
name|u_int16_t
name|exttype
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|saddr
parameter_list|,
name|u_int8_t
name|prefixlen
parameter_list|,
name|u_int16_t
name|ul_proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_address
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_address_proto
operator|=
name|ul_proto
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|==
name|FULLMASK
condition|)
block|{
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*XXX*/
block|}
block|}
name|p
operator|->
name|sadb_address_prefixlen
operator|=
name|prefixlen
expr_stmt|;
name|p
operator|->
name|sadb_address_reserved
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|saddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
argument_list|,
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_x_sa2.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
parameter_list|(
name|u_int8_t
name|mode
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|u_int32_t
name|reqid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_sa2
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_sa2
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_exttype
operator|=
name|SADB_X_EXT_SA2
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_mode
operator|=
name|mode
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved2
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_sequence
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reqid
operator|=
name|reqid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Set data into sadb_x_sa_replay.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsareplay
parameter_list|(
name|u_int32_t
name|replay
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_sa_replay
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa_replay
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_sa_replay
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa_replay_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa_replay_exttype
operator|=
name|SADB_X_EXT_SA_REPLAY
expr_stmt|;
name|p
operator|->
name|sadb_x_sa_replay_replay
operator|=
operator|(
name|replay
operator|<<
literal|3
operator|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Set a type in sadb_x_nat_t_type.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxtype
parameter_list|(
name|u_int16_t
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sadb_x_nat_t_type
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_type
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_nat_t_type
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_exttype
operator|=
name|SADB_X_EXT_NAT_T_TYPE
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_type_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a port in sadb_x_nat_t_port.  * In contrast to default RFC 2367 behaviour, port is in network byte order.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxport
parameter_list|(
name|u_int16_t
name|port
parameter_list|,
name|u_int16_t
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sadb_x_nat_t_port
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_nat_t_port
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_nat_t_port
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_exttype
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_x_nat_t_port_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get port from sockaddr. Port is in network byte order.  */
end_comment

begin_function
name|uint16_t
name|key_portfromsaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
return|return
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set port in struct sockaddr. Port is in network byte order.  */
end_comment

begin_function
name|void
name|key_porttosaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unexpected address family %d.\n"
operator|,
name|__func__
operator|,
name|sa
operator|->
name|sa_family
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * set data into sadb_x_policy  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
parameter_list|(
name|u_int16_t
name|type
parameter_list|,
name|u_int8_t
name|dir
parameter_list|,
name|u_int32_t
name|id
parameter_list|,
name|u_int32_t
name|priority
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_dir
operator|=
name|dir
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_id
operator|=
name|id
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_priority
operator|=
name|priority
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* %%% utilities */
end_comment

begin_comment
comment|/* Take a key message (sadb_key) from the socket and turn it into one  * of the kernel's key structures (seckey).  *  * IN: pointer to the src  * OUT: NULL no more memory  */
end_comment

begin_function
name|struct
name|seckey
modifier|*
name|key_dup_keymsg
parameter_list|(
specifier|const
name|struct
name|sadb_key
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|seckey
modifier|*
name|dst
decl_stmt|;
name|dst
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|->
name|bits
operator|=
name|src
operator|->
name|sadb_key_bits
expr_stmt|;
name|dst
operator|->
name|key_data
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|key_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|src
operator|+
literal|1
operator|)
argument_list|,
name|dst
operator|->
name|key_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Take a lifetime message (sadb_lifetime) passed in on a socket and  * turn it into one of the kernel's lifetime structures (seclifetime).  *  * IN: pointer to the destination, source and malloc type  * OUT: NULL, no more memory  */
end_comment

begin_function
specifier|static
name|struct
name|seclifetime
modifier|*
name|key_dup_lifemsg
parameter_list|(
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|src
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|seclifetime
modifier|*
name|dst
decl_stmt|;
name|dst
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|,
name|type
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dst
operator|->
name|allocations
operator|=
name|src
operator|->
name|sadb_lifetime_allocations
expr_stmt|;
name|dst
operator|->
name|bytes
operator|=
name|src
operator|->
name|sadb_lifetime_bytes
expr_stmt|;
name|dst
operator|->
name|addtime
operator|=
name|src
operator|->
name|sadb_lifetime_addtime
expr_stmt|;
name|dst
operator|->
name|usetime
operator|=
name|src
operator|->
name|sadb_lifetime_usetime
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two secasindex structure.  * flag can specify to compare 2 saidxes.  * compare two secasindex structure without both mode and reqid.  * don't compare port.  * IN:    *      saidx0: source, it can be in SAD.  *      saidx1: object.  * OUT:   *      1 : equal  *      0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpsaidx
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx0
parameter_list|,
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx1
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
comment|/* sanity */
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|&&
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|||
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|proto
operator|!=
name|saidx1
operator|->
name|proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag
operator|==
name|CMP_EXACTLY
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
argument_list|,
operator|&
name|saidx1
operator|->
name|src
argument_list|,
name|saidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
argument_list|,
name|saidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* CMP_MODE_REQID, CMP_REQID, CMP_HEAD */
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
operator|||
name|flag
operator|==
name|CMP_REQID
condition|)
block|{
comment|/* 			 * If reqid of SPD is non-zero, unique SA is required. 			 * The result must be of same reqid in this case. 			 */
if|if
condition|(
name|saidx1
operator|->
name|reqid
operator|!=
literal|0
operator|&&
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|IPSEC_MODE_ANY
operator|&&
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|saidx1
operator|->
name|src
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * compare two secindex structure exactly.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from PFKEY message.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_exactly
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx0
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx1
parameter_list|)
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|prefs
operator|!=
name|spidx1
operator|->
name|prefs
operator|||
name|spidx0
operator|->
name|prefd
operator|!=
name|spidx1
operator|->
name|prefd
operator|||
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
return|return
name|key_sockaddrcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sa
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|key_sockaddrcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sa
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * compare two secindex structure with mask.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from IP header.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_withmask
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx0
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx1
parameter_list|)
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|||
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
condition|)
return|return
literal|0
return|;
comment|/* if spidx.ul_proto == IPSEC_ULPROTO_ANY, ignore. */
if|if
condition|(
name|spidx0
operator|->
name|ul_proto
operator|!=
operator|(
name|u_int16_t
operator|)
name|IPSEC_ULPROTO_ANY
operator|&&
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|,
operator|&
name|spidx1
operator|->
name|src
argument_list|,
name|spidx0
operator|->
name|src
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
switch|switch
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|&&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
argument_list|,
name|spidx0
operator|->
name|dst
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* XXX Do we check other field ?  e.g. flowinfo */
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|satosin
end_ifdef

begin_undef
undef|#
directive|undef
name|satosin
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|satosin
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in *)s)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|satosin6
end_ifdef

begin_undef
undef|#
directive|undef
name|satosin6
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|satosin6
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in6 *)s)
end_define

begin_comment
comment|/* returns 0 on match */
end_comment

begin_function
name|int
name|key_sockaddrcmp
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
operator|||
name|sa1
operator|->
name|sa_len
operator|!=
name|sa2
operator|->
name|sa_len
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_port
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_port
condition|)
return|return
literal|1
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/*EINVAL*/
if|if
condition|(
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_scope_id
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_port
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_port
condition|)
block|{
return|return
literal|1
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|bcmp
argument_list|(
name|sa1
argument_list|,
name|sa2
argument_list|,
name|sa1
operator|->
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* returns 0 on match */
end_comment

begin_function
name|int
name|key_sockaddrcmp_withmask
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|,
name|size_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
operator|||
name|sa1
operator|->
name|sa_len
operator|!=
name|sa2
operator|->
name|sa_len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
return|return
operator|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_addr
argument_list|,
operator|&
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|mask
argument_list|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_scope_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|!
name|key_bbcmp
argument_list|(
operator|&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|mask
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|satosin
end_undef

begin_undef
undef|#
directive|undef
name|satosin6
end_undef

begin_comment
comment|/*  * compare two buffers with mask.  * IN:  *	addr1: source  *	addr2: object  *	bits:  Number of bits to compare  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_bbcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a1
parameter_list|,
specifier|const
name|void
modifier|*
name|a2
parameter_list|,
name|u_int
name|bits
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p1
init|=
name|a1
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p2
init|=
name|a2
decl_stmt|;
comment|/* XXX: This could be considerably faster if we compare a word 	 * at a time, but it is complicated on LSB Endian machines */
comment|/* Handle null pointers */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
return|return
operator|(
name|p1
operator|==
name|p2
operator|)
return|;
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|0
return|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|u_int8_t
name|mask
init|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p1
operator|&
name|mask
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|&
name|mask
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Match! */
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_spd
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|SPTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secpolicy_list
name|drainq
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|SPTREE_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&V_sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|lifetime
operator|==
literal|0
operator|&&
name|sp
operator|->
name|validtime
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|lifetime
operator|&&
name|now
operator|-
name|sp
operator|->
name|created
operator|>
name|sp
operator|->
name|lifetime
operator|)
operator|||
operator|(
name|sp
operator|->
name|validtime
operator|&&
name|now
operator|-
name|sp
operator|->
name|lastused
operator|>
name|sp
operator|->
name|validtime
operator|)
condition|)
block|{
comment|/* Hold extra reference to send SPDEXPIRE */
name|SP_ADDREF
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|drainq
argument_list|,
name|sp
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SPTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|drainq
argument_list|)
condition|)
return|return;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
name|sp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|nextsp
operator|=
name|LIST_NEXT
argument_list|(
name|sp
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
comment|/* Check that SP is still linked */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|IPSEC_SPSTATE_ALIVE
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|sp
operator|=
name|nextsp
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_sptree
index|[
name|sp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|idhash
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|sp
operator|=
name|nextsp
expr_stmt|;
block|}
name|V_sp_genid
operator|++
expr_stmt|;
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|sp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|nextsp
operator|=
name|LIST_NEXT
argument_list|(
name|sp
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_spdexpire
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sp
operator|=
name|nextsp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_sad
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead_list
name|emptyq
decl_stmt|;
name|struct
name|secasvar_list
name|drainq
decl_stmt|,
name|hexpireq
decl_stmt|,
name|sexpireq
decl_stmt|,
name|freeq
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|hexpireq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sexpireq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|emptyq
argument_list|)
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* Check for empty SAH */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
condition|)
block|{
name|SAH_ADDREF
argument_list|(
name|sah
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|emptyq
argument_list|,
name|sah
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add all stale LARVAL SAs into drainq */
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|now
operator|-
name|sav
operator|->
name|created
operator|<
name|V_key_larval_lifetime
condition|)
continue|continue;
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|drainq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* lifetimes aren't specified */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
continue|continue;
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* 			 * Check again with lock held, because it may 			 * be updated by SADB_UPDATE. 			 */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * RFC 2367: 			 * HARD lifetimes MUST take precedence over SOFT 			 * lifetimes, meaning if the HARD and SOFT lifetimes 			 * are the same, the HARD lifetime will appear on the 			 * EXPIRE message. 			 */
comment|/* check HARD lifetime */
if|if
condition|(
operator|(
name|sav
operator|->
name|lft_h
operator|->
name|addtime
operator|!=
literal|0
operator|&&
name|now
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_h
operator|->
name|addtime
operator|)
operator|||
operator|(
name|sav
operator|->
name|lft_h
operator|->
name|usetime
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|firstused
operator|&&
name|now
operator|-
name|sav
operator|->
name|firstused
operator|>
name|sav
operator|->
name|lft_h
operator|->
name|usetime
operator|)
operator|||
operator|(
name|sav
operator|->
name|lft_h
operator|->
name|bytes
operator|!=
literal|0
operator|&&
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|)
operator|>
name|sav
operator|->
name|lft_h
operator|->
name|bytes
operator|)
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|hexpireq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check SOFT lifetime (only for MATURE SAs) */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_MATURE
operator|&&
operator|(
operator|(
name|sav
operator|->
name|lft_s
operator|->
name|addtime
operator|!=
literal|0
operator|&&
name|now
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_s
operator|->
name|addtime
operator|)
operator|||
operator|(
name|sav
operator|->
name|lft_s
operator|->
name|usetime
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|firstused
operator|&&
name|now
operator|-
name|sav
operator|->
name|firstused
operator|>
name|sav
operator|->
name|lft_s
operator|->
name|usetime
operator|)
operator|||
operator|(
name|sav
operator|->
name|lft_s
operator|->
name|bytes
operator|!=
literal|0
operator|&&
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|)
operator|>
name|sav
operator|->
name|lft_s
operator|->
name|bytes
operator|)
operator|)
condition|)
block|{
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sexpireq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|emptyq
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|drainq
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|hexpireq
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|sexpireq
argument_list|)
condition|)
return|return;
name|LIST_INIT
argument_list|(
operator|&
name|freeq
argument_list|)
expr_stmt|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
comment|/* Unlink stale LARVAL SAs */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
comment|/* Check that SA is still LARVAL */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_LARVAL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freeq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_larval
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Unlink all SAs with expired HARD lifetime */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|hexpireq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
comment|/* Check that SA is not unlinked */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freeq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Mark all SAs with expired SOFT lifetime as DYING */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sexpireq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
comment|/* Check that SA is not unlinked */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freeq
argument_list|,
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * NOTE: this doesn't change SA order in the chain. 		 */
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DYING
expr_stmt|;
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Unlink empty SAHs */
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|emptyq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
comment|/* Check that SAH is still empty and not unlinked */
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|sah
operator|=
name|nextsah
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_sahtree
argument_list|,
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|sah
operator|=
name|nextsah
expr_stmt|;
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* Send SPDEXPIRE messages */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|hexpireq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_expire
argument_list|(
name|sav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sav
operator|->
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sexpireq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_expire
argument_list|(
name|sav
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Free stale LARVAL SAs */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sav
operator|->
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Free SAs that were unlinked/changed by someone else */
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freeq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
comment|/* Free empty SAH */
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|emptyq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|drainq
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release extra reference */
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sah
operator|=
name|nextsah
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_acq
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
comment|/* ACQ tree */
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_acqtree
argument_list|)
expr_stmt|;
while|while
condition|(
name|acq
operator|!=
name|NULL
condition|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|acq
operator|->
name|created
operator|>
name|V_key_blockacq_lifetime
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|seqhash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
name|acq
operator|=
name|nextacq
expr_stmt|;
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_flush_spacq
parameter_list|(
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
comment|/* SP ACQ tree */
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|acq
operator|->
name|created
operator|>
name|V_key_blockacq_lifetime
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * time handler.  * scanning SPD and SAD to check status for each entries,  * and do to remove or to expire.  * XXX: year 2038 problem may remain.  */
end_comment

begin_function
specifier|static
name|void
name|key_timehandler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|time_t
name|now
init|=
name|time_second
decl_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|key_flush_spd
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_sad
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_acq
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|key_flush_spacq
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
comment|/* do exchange to tick time !! */
name|callout_schedule
argument_list|(
operator|&
name|key_timer
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_DEBUG2 */
block|}
end_function

begin_function
name|u_long
name|key_random
parameter_list|()
block|{
name|u_long
name|value
decl_stmt|;
name|key_randomfill
argument_list|(
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|key_randomfill
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|u_long
name|v
decl_stmt|;
specifier|static
name|int
name|warn
init|=
literal|1
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|size_t
operator|)
name|read_random
argument_list|(
name|p
argument_list|,
operator|(
name|u_int
operator|)
name|l
argument_list|)
expr_stmt|;
comment|/* last resort */
while|while
condition|(
name|n
operator|<
name|l
condition|)
block|{
name|v
operator|=
name|random
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|p
operator|+
name|n
argument_list|,
name|l
operator|-
name|n
operator|<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|?
name|l
operator|-
name|n
else|:
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: pseudo-random number generator "
literal|"used for IPsec processing\n"
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * map SADB_SATYPE_* to IPPROTO_*.  * if satype == SADB_SATYPE then satype is mapped to ~0.  * OUT:  *	0: invalid satype.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|key_satype2proto
parameter_list|(
name|uint8_t
name|satype
parameter_list|)
block|{
switch|switch
condition|(
name|satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
return|return
name|IPSEC_PROTO_ANY
return|;
case|case
name|SADB_SATYPE_AH
case|:
return|return
name|IPPROTO_AH
return|;
case|case
name|SADB_SATYPE_ESP
case|:
return|return
name|IPPROTO_ESP
return|;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
return|return
name|IPPROTO_IPCOMP
return|;
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
return|return
name|IPPROTO_TCP
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * map IPPROTO_* to SADB_SATYPE_*  * OUT:  *	0: invalid protocol type.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|key_proto2satype
parameter_list|(
name|uint8_t
name|proto
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
return|return
name|SADB_SATYPE_AH
return|;
case|case
name|IPPROTO_ESP
case|:
return|return
name|SADB_SATYPE_ESP
return|;
case|case
name|IPPROTO_IPCOMP
case|:
return|return
name|SADB_X_SATYPE_IPCOMP
return|;
case|case
name|IPPROTO_TCP
case|:
return|return
name|SADB_X_SATYPE_TCPSIGNATURE
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* %%% PF_KEY */
end_comment

begin_comment
comment|/*  * SADB_GETSPI processing is to receive  *<base, (SA2), src address, dst address, (SPI range)>  * from the IKMPd, to assign a unique spi value, to hang on the INBOUND  * tree with the status of LARVAL, and send  *<base, SA(*), address(SD)>  * to the IKMPd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|int
name|key_getspi
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint32_t
name|reqid
decl_stmt|,
name|spi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
ifdef|#
directive|ifdef
name|PFKEY_STRICT_CHECKS
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SPIRANGE
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
ifdef|#
directive|ifdef
name|PFKEY_STRICT_CHECKS
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SPIRANGE
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* SPI allocation */
name|spi
operator|=
name|key_do_getnewspi
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SPIRANGE
index|]
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Requested SPI or SPI range is not available or 		 * already used. 		 */
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|=
name|key_newsav
argument_list|(
name|mhp
argument_list|,
operator|&
name|saidx
argument_list|,
name|spi
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|sav
operator|->
name|seq
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * RFC2367: 		 * If the SADB_GETSPI message is in response to a 		 * kernel-generated SADB_ACQUIRE, the sadb_msg_seq 		 * MUST be the same as the SADB_ACQUIRE message. 		 * 		 * XXXAE: However it doesn't definethe behaviour how to 		 * check this and what to do if it doesn't match. 		 * Also what we should do if it matches? 		 * 		 * We can compare saidx used in SADB_ACQUIRE with saidx 		 * used in SADB_GETSPI, but this probably can break 		 * existing software. For now just warn if it doesn't match. 		 * 		 * XXXAE: anyway it looks useless. 		 */
name|key_acqdone
argument_list|(
operator|&
name|saidx
argument_list|,
name|sav
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|m_sa
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_spi
operator|=
name|spi
expr_stmt|;
comment|/* SPI is already in network byte order */
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length inconsistency (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
name|sav
operator|->
name|seq
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
name|fail
label|:
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocating new SPI  * called by key_getspi().  * OUT:  *	0:	failure.  *	others: success, SPI in network byte order.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|key_do_getnewspi
parameter_list|(
name|struct
name|sadb_spirange
modifier|*
name|spirange
parameter_list|,
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|uint32_t
name|min
decl_stmt|,
name|max
decl_stmt|,
name|newspi
decl_stmt|,
name|t
decl_stmt|;
name|int
name|count
init|=
name|V_key_spi_trycnt
decl_stmt|;
comment|/* set spi range to allocate */
if|if
condition|(
name|spirange
operator|!=
name|NULL
condition|)
block|{
name|min
operator|=
name|spirange
operator|->
name|sadb_spirange_min
expr_stmt|;
name|max
operator|=
name|spirange
operator|->
name|sadb_spirange_max
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|V_key_spi_minval
expr_stmt|;
name|max
operator|=
name|V_key_spi_maxval
expr_stmt|;
block|}
comment|/* IPCOMP needs 2-byte SPI */
if|if
condition|(
name|saidx
operator|->
name|proto
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
if|if
condition|(
name|min
operator|>=
literal|0x10000
condition|)
name|min
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|max
operator|>=
literal|0x10000
condition|)
name|max
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|t
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
if|if
condition|(
operator|!
name|key_checkspidup
argument_list|(
name|htonl
argument_list|(
name|min
argument_list|)
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SPI %u exists already.\n"
operator|,
name|__func__
operator|,
name|min
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* taking one cost. */
name|newspi
operator|=
name|min
expr_stmt|;
block|}
else|else
block|{
comment|/* init SPI */
name|newspi
operator|=
literal|0
expr_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* generate pseudo-random SPI value ranged. */
name|newspi
operator|=
name|min
operator|+
operator|(
name|key_random
argument_list|()
operator|%
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_checkspidup
argument_list|(
name|htonl
argument_list|(
name|newspi
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newspi
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: failed to allocate SPI.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* statistics */
name|keystat
operator|.
name|getspi_count
operator|=
operator|(
name|keystat
operator|.
name|getspi_count
operator|+
name|V_key_spi_trycnt
operator|-
name|count
operator|)
operator|/
literal|2
expr_stmt|;
return|return
operator|(
name|htonl
argument_list|(
name|newspi
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find TCP-MD5 SA with corresponding secasindex.  * If not found, return NULL and fill SPI with usable value if needed.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsav_tcpmd5
parameter_list|(
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|uint32_t
modifier|*
name|spi
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|->
name|proto
operator|==
name|IPPROTO_TCP
argument_list|,
operator|(
literal|"wrong proto"
operator|)
argument_list|)
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|IPPROTO_TCP
condition|)
continue|continue;
if|if
condition|(
operator|!
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|key_sockaddrcmp
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|V_key_preferred_oldsa
condition|)
name|sav
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|secasvar_queue
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|SAV_ADDREF
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sav
operator|)
return|;
block|}
block|}
if|if
condition|(
name|spi
operator|==
name|NULL
condition|)
block|{
comment|/* No SPI required */
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Check that SPI is unique */
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|SAVHASH_HASH(*spi)
argument_list|,
argument|spihash
argument_list|)
block|{
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
operator|*
name|spi
condition|)
break|break;
block|}
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* SPI is already unique */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* XXX: not optimal */
operator|*
name|spi
operator|=
name|key_do_getnewspi
argument_list|(
name|NULL
argument_list|,
name|saidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_updateaddresses
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|newaddr
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isnew
decl_stmt|;
comment|/* Check that we need to change SAH */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_SRC
argument_list|)
condition|)
block|{
name|newaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NEW_ADDRESS_SRC
index|]
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|newaddr
argument_list|,
operator|&
name|saidx
operator|->
name|src
argument_list|,
name|newaddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|key_porttosaddr
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_DST
argument_list|)
condition|)
block|{
name|newaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NEW_ADDRESS_DST
index|]
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|newaddr
argument_list|,
operator|&
name|saidx
operator|->
name|dst
argument_list|,
name|newaddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|key_porttosaddr
argument_list|(
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_SRC
argument_list|)
operator|||
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_DST
argument_list|)
condition|)
block|{
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|&
name|saidx
operator|->
name|src
operator|.
name|sa
argument_list|,
operator|&
name|saidx
operator|->
name|dst
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid new sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sah
operator|=
name|key_getsah
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA index */
name|sah
operator|=
name|key_newsah
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|isnew
operator|=
literal|2
expr_stmt|;
comment|/* SAH is new */
block|}
else|else
name|isnew
operator|=
literal|1
expr_stmt|;
comment|/* existing SAH is referenced */
block|}
else|else
block|{
comment|/* 		 * src and dst addresses are still the same. 		 * Do we want to change NAT-T config? 		 */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|IPPROTO_ESP
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_TYPE
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* We hold reference to SA, thus SAH will be referenced too. */
name|sah
operator|=
name|sav
operator|->
name|sah
expr_stmt|;
name|isnew
operator|=
literal|0
expr_stmt|;
block|}
name|newsav
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|,
name|M_IPSEC_SA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clone SA's content into newsav */
name|SAV_INITREF
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sav
argument_list|,
name|newsav
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|secasvar
argument_list|,
name|chain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We create new NAT-T config if it is needed. 	 * Old NAT-T config will be freed by key_cleansav() when 	 * last reference to SA will be released. 	 */
name|newsav
operator|->
name|natt
operator|=
name|NULL
expr_stmt|;
name|newsav
operator|->
name|sah
operator|=
name|sah
expr_stmt|;
name|newsav
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|error
operator|=
name|key_setnatt
argument_list|(
name|newsav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
comment|/* Check that SA is still alive */
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
comment|/* SA was unlinked */
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Unlink SA from SAH and SPI hash */
name|IPSEC_ASSERT
argument_list|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_F_CLONED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"SA is already cloned"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_MATURE
operator|||
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DYING
argument_list|,
operator|(
literal|"Wrong SA state %u\n"
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
comment|/* 	 * Link new SA with SAH. Keep SAs ordered by 	 * create time (newer are first). 	 */
name|TAILQ_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|newsav
operator|->
name|created
operator|>
name|tmp
operator|->
name|created
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tmp
argument_list|,
name|newsav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|newsav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Add new SA into SPI hash. */
name|LIST_INSERT_HEAD
argument_list|(
name|SAVHASH_HASH
argument_list|(
name|newsav
operator|->
name|spi
argument_list|)
argument_list|,
name|newsav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
comment|/* Add new SAH into SADB. */
if|if
condition|(
name|isnew
operator|==
literal|2
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|V_sahtree
argument_list|,
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|SAHADDRHASH_HASH
argument_list|(
name|saidx
argument_list|)
argument_list|,
name|sah
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|SAH_ADDREF
argument_list|(
name|sah
argument_list|)
expr_stmt|;
comment|/* newsav references new SAH */
block|}
comment|/* 	 * isnew == 1 -> @sah was referenced by key_getsah(). 	 * isnew == 0 -> we use the same @sah, that was used by @sav, 	 *	and we use its reference for @newsav. 	 */
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* XXX: replace cntr with pointer? */
name|newsav
operator|->
name|cntr
operator|=
name|sav
operator|->
name|cntr
expr_stmt|;
name|sav
operator|->
name|flags
operator||=
name|SADB_X_EXT_F_CLONED
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p) cloned into SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|newsav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|newsav
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|isnew
operator|!=
literal|0
condition|)
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|newsav
operator|->
name|natt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|newsav
operator|->
name|natt
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newsav
argument_list|,
name|M_IPSEC_SA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_UPDATE processing  * receive  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd, and update a secasvar entry whose status is SADB_SASTATE_LARVAL.  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_update
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|)
operator|||
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* 	 * Only SADB_SASTATE_MATURE SAs may be submitted in an 	 * SADB_UPDATE message. 	 */
if|if
condition|(
name|sa0
operator|->
name|sadb_sa_state
operator|!=
name|SADB_SASTATE_MATURE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid state.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PFKEY_STRICT_CHECKS
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
endif|#
directive|endif
block|}
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA found for SPI %u\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * Check that SADB_UPDATE issued by the same process that did 	 * SADB_GETSPI or SADB_ADD. 	 */
if|if
condition|(
name|sav
operator|->
name|pid
operator|!=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: pid mismatched (SPI %u, pid %u vs. %u)\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|,
name|sav
operator|->
name|pid
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* saidx should match with SA. */
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: saidx mismatched for SPI %u"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_LARVAL
condition|)
block|{
if|if
condition|(
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 		 * We can set any values except src, dst and SPI. 		 */
name|error
operator|=
name|key_setsaval
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* Change SA state to MATURE */
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_LARVAL
condition|)
block|{
comment|/* SA was deleted or another thread made it MATURE. */
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * NOTE: we keep SAs in savtree_alive ordered by created 		 * time. When SA's state changed from LARVAL to MATURE, 		 * we update its created time in key_setsaval() and move 		 * it into head of savtree_alive. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_larval
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For DYING and MATURE SA we can change only state 		 * and lifetimes. Report EINVAL if something else attempted 		 * to change. 		 */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
operator|||
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
condition|)
block|{
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|key_updatelifetimes
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * This is FreeBSD extension to RFC2367. 		 * IKEd can specify SADB_X_EXT_NEW_ADDRESS_SRC and/or 		 * SADB_X_EXT_NEW_ADDRESS_DST when it wants to change 		 * SA addresses (for example to implement MOBIKE protocol 		 * as described in RFC4555). Also we allow to change 		 * NAT-T config. 		 */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_SRC
argument_list|)
operator|||
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_DST
argument_list|)
operator|||
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_TYPE
argument_list|)
operator|||
name|sav
operator|->
name|natt
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|key_updateaddresses
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|,
name|sav
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check that SA is still alive */
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
comment|/* SA was unlinked */
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * NOTE: there is possible state moving from DYING to MATURE, 		 * but this doesn't change created time, so we won't reorder 		 * this SA. 		 */
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
block|}
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_ADD processing  * add an entry to SA database, when received  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd,  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IGNORE identity and sensitivity messages.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_add
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint32_t
name|reqid
decl_stmt|,
name|spi
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_ENCRYPT
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_KEY_AUTH
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|)
operator|||
operator|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|)
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* 	 * Only SADB_SASTATE_MATURE SAs may be submitted in an 	 * SADB_ADD message. 	 */
if|if
condition|(
name|sa0
operator|->
name|sadb_sa_state
operator|!=
name|SADB_SASTATE_MATURE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid state.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PFKEY_STRICT_CHECKS
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
endif|#
directive|endif
block|}
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
name|spi
operator|=
name|sa0
operator|->
name|sadb_sa_spi
expr_stmt|;
comment|/* 	 * For TCP-MD5 SAs we don't use SPI. Check the uniqueness using 	 * secasindex. 	 * XXXAE: IPComp seems also doesn't use SPI. 	 */
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|sav
operator|=
name|key_getsav_tcpmd5
argument_list|(
operator|&
name|saidx
argument_list|,
operator|&
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
operator|&&
name|spi
operator|==
literal|0
condition|)
block|{
comment|/* Failed to allocate SPI */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SA already exists.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
comment|/* XXX: SPI that we report back can have another value */
block|}
else|else
block|{
comment|/* We can create new SA only if SPI is different. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|spi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: SA already exists.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|sav
operator|=
name|key_newsav
argument_list|(
name|mhp
argument_list|,
operator|&
name|saidx
argument_list|,
name|spi
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: return SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If SADB_ADD was in response to SADB_ACQUIRE, we need to schedule 	 * ACQ for deletion. 	 */
if|if
condition|(
name|sav
operator|->
name|seq
operator|!=
literal|0
condition|)
name|key_acqdone
argument_list|(
operator|&
name|saidx
argument_list|,
name|sav
operator|->
name|seq
argument_list|)
expr_stmt|;
block|{
comment|/* 	 * Don't call key_freesav() on error here, as we would like to 	 * keep the SA in the database. 	 */
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * NAT-T support.  * IKEd may request the use ESP in UDP encapsulation when it detects the  * presence of NAT. It uses NAT-T extension headers for such SAs to specify  * parameters needed for encapsulation and decapsulation. These PF_KEY  * extension headers are not standardized, so this comment addresses our  * implementation.  * SADB_X_EXT_NAT_T_TYPE specifies type of encapsulation, we support only  * UDP_ENCAP_ESPINUDP as described in RFC3948.  * SADB_X_EXT_NAT_T_SPORT/DPORT specifies source and destination ports for  * UDP header. We use these ports in UDP encapsulation procedure, also we  * can check them in UDP decapsulation procedure.  * SADB_X_EXT_NAT_T_OA[IR] specifies original address of initiator or  * responder. These addresses can be used for transport mode to adjust  * checksum after decapsulation and decryption. Since original IP addresses  * used by peer usually different (we detected presence of NAT), TCP/UDP  * pseudo header checksum and IP header checksum was calculated using original  * addresses. After decapsulation and decryption we need to adjust checksum  * to have correct datagram.  *  * We expect presence of NAT-T extension headers only in SADB_ADD and  * SADB_UPDATE messages. We report NAT-T extension headers in replies  * to SADB_ADD, SADB_UPDATE, SADB_GET, and SADB_DUMP messages.  */
end_comment

begin_function
specifier|static
name|int
name|key_setnatt
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|sadb_x_nat_t_port
modifier|*
name|port
decl_stmt|;
name|struct
name|sadb_x_nat_t_type
modifier|*
name|type
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|oai
decl_stmt|,
modifier|*
name|oar
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint16_t
name|cksum
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|natt
operator|==
name|NULL
argument_list|,
operator|(
literal|"natt is already initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore NAT-T headers if sproto isn't ESP. 	 */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|IPPROTO_ESP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_TYPE
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|)
operator|&&
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_TYPE
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_type
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_TYPE
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|sadb_x_nat_t_type_type
operator|!=
name|UDP_ENCAP_ESPINUDP
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unsupported NAT-T type %u.\n"
operator|,
name|__func__
operator|,
name|type
operator|->
name|sadb_x_nat_t_type_type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Allocate storage for NAT-T config. 	 * On error it will be released by key_cleansav(). 	 */
name|sav
operator|->
name|natt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secnatt
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|natt
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|in_nomem
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|port
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_SPORT
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|sadb_x_nat_t_port_port
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid NAT-T sport specified.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sav
operator|->
name|natt
operator|->
name|sport
operator|=
name|port
operator|->
name|sadb_x_nat_t_port_port
expr_stmt|;
name|port
operator|=
operator|(
expr|struct
name|sadb_x_nat_t_port
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_DPORT
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|sadb_x_nat_t_port_port
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid NAT-T dport specified.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sav
operator|->
name|natt
operator|->
name|dport
operator|=
name|port
operator|->
name|sadb_x_nat_t_port_port
expr_stmt|;
comment|/* 	 * SADB_X_EXT_NAT_T_OAI and SADB_X_EXT_NAT_T_OAR are optional 	 * and needed only for transport mode IPsec. 	 * Usually NAT translates only one address, but it is possible, 	 * that both addresses could be translated. 	 * NOTE: Value of SADB_X_EXT_NAT_T_OAI is equal to SADB_X_EXT_NAT_T_OA. 	 */
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_OAI
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_OAI
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oai
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAI
index|]
expr_stmt|;
block|}
else|else
name|oai
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_OAR
argument_list|)
condition|)
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_NAT_T_OAR
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oar
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_NAT_T_OAR
index|]
expr_stmt|;
block|}
else|else
name|oar
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize addresses only for transport mode */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
operator|!=
name|IPSEC_MODE_TUNNEL
condition|)
block|{
name|cksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oai
operator|!=
name|NULL
condition|)
block|{
comment|/* Currently we support only AF_INET */
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|oai
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: wrong NAT-OAi header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Ignore address if it the same */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|&
name|sav
operator|->
name|natt
operator|->
name|oai
operator|.
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|sav
operator|->
name|natt
operator|->
name|flags
operator||=
name|IPSEC_NATT_F_OAI
expr_stmt|;
comment|/* Calculate checksum delta */
name|addr
operator|=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
operator|~
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
operator|~
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sav
operator|->
name|natt
operator|->
name|oai
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oar
operator|!=
name|NULL
condition|)
block|{
comment|/* Currently we support only AF_INET */
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|oar
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: wrong NAT-OAr header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Ignore address if it the same */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|&
name|sav
operator|->
name|natt
operator|->
name|oar
operator|.
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|sav
operator|->
name|natt
operator|->
name|flags
operator||=
name|IPSEC_NATT_F_OAR
expr_stmt|;
comment|/* Calculate checksum delta */
name|addr
operator|=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
operator|~
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
operator|~
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sav
operator|->
name|natt
operator|->
name|oar
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|in_addword
argument_list|(
name|cksum
argument_list|,
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
name|sav
operator|->
name|natt
operator|->
name|cksum
operator|=
name|cksum
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_setident
parameter_list|(
name|struct
name|secashead
modifier|*
name|sah
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
specifier|const
name|struct
name|sadb_ident
modifier|*
name|idsrc
decl_stmt|,
modifier|*
name|iddst
decl_stmt|;
name|int
name|idsrclen
decl_stmt|,
name|iddstlen
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null secashead"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* don't make buffer if not there */
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|)
operator|&&
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|)
condition|)
block|{
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid identity.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|idsrc
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddst
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
name|idsrclen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddstlen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|idsrc
operator|->
name|sadb_ident_type
operator|!=
name|iddst
operator|->
name|sadb_ident_type
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: ident type mismatch.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|idsrc
operator|->
name|sadb_ident_type
condition|)
block|{
case|case
name|SADB_IDENTTYPE_PREFIX
case|:
case|case
name|SADB_IDENTTYPE_FQDN
case|:
case|case
name|SADB_IDENTTYPE_USERFQDN
case|:
default|default:
comment|/* XXX do nothing */
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* make structure */
name|sah
operator|->
name|idents
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secident
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|idents
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|sah
operator|->
name|identd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secident
argument_list|)
argument_list|,
name|M_IPSEC_MISC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|identd
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sah
operator|->
name|idents
argument_list|,
name|M_IPSEC_MISC
argument_list|)
expr_stmt|;
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|sah
operator|->
name|idents
operator|->
name|type
operator|=
name|idsrc
operator|->
name|sadb_ident_type
expr_stmt|;
name|sah
operator|->
name|idents
operator|->
name|id
operator|=
name|idsrc
operator|->
name|sadb_ident_id
expr_stmt|;
name|sah
operator|->
name|identd
operator|->
name|type
operator|=
name|iddst
operator|->
name|sadb_ident_type
expr_stmt|;
name|sah
operator|->
name|identd
operator|->
name|id
operator|=
name|iddst
operator|->
name|sadb_ident_id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * m will not be freed on return.  * it is caller's responsibility to free the result.  *  * Called from SADB_ADD and SADB_UPDATE. Reply will contain headers  * from the request in defined order.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_X_EXT_SA2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|,
name|SADB_X_EXT_NAT_T_TYPE
argument_list|,
name|SADB_X_EXT_NAT_T_SPORT
argument_list|,
name|SADB_X_EXT_NAT_T_DPORT
argument_list|,
name|SADB_X_EXT_NAT_T_OAI
argument_list|,
name|SADB_X_EXT_NAT_T_OAR
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_SRC
argument_list|,
name|SADB_X_EXT_NEW_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_DELETE processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and set SADB_SASTATE_DEAD,  * and send,  *<base, SA(*), address(SD)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_delete
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
condition|)
block|{
comment|/* 		 * Caller wants us to delete all non-LARVAL SAs 		 * that match the src/dst.  This is used during 		 * IKE INITIAL-CONTACT. 		 * XXXAE: this looks like some extension to RFC2367. 		 */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: doing delete all.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_delete_all
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|,
operator|&
name|saidx
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|sav
operator|=
name|key_getsav_tcpmd5
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA found for SPI %u.\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: saidx mismatched for SPI %u.\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
operator|)
return|;
block|}
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|key_unlinksav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * delete all SAs for src/dst.  Called from key_delete().  */
end_comment

begin_function
specifier|static
name|int
name|key_delete_all
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|secasvar_queue
name|drainq
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Move all ALIVE SAs into drainq */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|drainq
argument_list|,
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* Unlink all queued SAs from SPI hash */
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&drainq
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* Now we can release reference for all SAs in drainq */
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|nextsav
operator|=
name|TAILQ_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sav
operator|->
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete all alive SAs for corresponding xform.  * Larval SAs have not initialized tdb_xform, so it is safe to leave them  * here when xform disappears.  */
end_comment

begin_function
specifier|static
name|void
name|key_delete_xform
parameter_list|(
specifier|const
name|struct
name|xformsw
modifier|*
name|xsp
parameter_list|)
block|{
name|struct
name|secasvar_queue
name|drainq
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sav
operator|->
name|tdb_xform
operator|!=
name|xsp
condition|)
continue|continue;
comment|/* 		 * It is supposed that all SAs in the chain are related to 		 * one xform. 		 */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|drainq
argument_list|,
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* Unlink all queued SAs from SPI hash */
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&drainq
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* Now we can release reference for all SAs in drainq */
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|nextsav
operator|=
name|TAILQ_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sav
operator|->
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_GET processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and get a SP and a SA to respond,  * and send,  *<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE),  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_get
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_SA
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
if|if
condition|(
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_TCP
condition|)
name|sav
operator|=
name|key_getsav_tcpmd5
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: no SA found.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
return|;
block|}
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: saidx mismatched for SPI %u.\n"
operator|,
name|__func__
operator|,
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ESRCH
argument_list|)
operator|)
return|;
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|uint8_t
name|satype
decl_stmt|;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there was invalid proto in SAD.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_GET
argument_list|,
name|satype
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* XXX make it sysctl-configurable? */
end_comment

begin_function
specifier|static
name|void
name|key_getcomb_setlifetime
parameter_list|(
name|struct
name|sadb_comb
modifier|*
name|comb
parameter_list|)
block|{
name|comb
operator|->
name|sadb_comb_soft_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_addtime
operator|=
literal|86400
expr_stmt|;
comment|/* 1 day */
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|=
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_usetime
operator|=
literal|28800
expr_stmt|;
comment|/* 8 hours */
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|=
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX reorder combinations by preference  * XXX no idea if the user wants ESP authentication or not  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ealg
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
specifier|const
name|struct
name|enc_xform
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|encmin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|,
name|o
decl_stmt|;
name|int
name|totlen
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|enc_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|NULL
condition|)
continue|continue;
comment|/* discard algorithms with key size smaller than system min */
if|if
condition|(
name|_BITS
argument_list|(
name|algo
operator|->
name|maxkey
argument_list|)
operator|<
name|V_ipsec_esp_keymin
condition|)
continue|continue;
if|if
condition|(
name|_BITS
argument_list|(
name|algo
operator|->
name|minkey
argument_list|)
operator|<
name|V_ipsec_esp_keymin
condition|)
name|encmin
operator|=
name|V_ipsec_esp_keymin
expr_stmt|;
else|else
name|encmin
operator|=
name|_BITS
argument_list|(
name|algo
operator|->
name|minkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_ipsec_esp_auth
condition|)
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
else|else
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
operator|(
name|totlen
operator|%
name|l
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"totlen=%u, l=%u"
operator|,
name|totlen
operator|,
name|l
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|totlen
condition|;
name|off
operator|+=
name|l
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|l
argument_list|,
operator|&
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
goto|goto
name|fail
goto|;
block|}
name|comb
operator|=
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|o
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_minbits
operator|=
name|encmin
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_maxbits
operator|=
name|_BITS
argument_list|(
name|algo
operator|->
name|maxkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|m
expr_stmt|;
else|else
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_getsizes_ah
parameter_list|(
specifier|const
name|struct
name|auth_hash
modifier|*
name|ah
parameter_list|,
name|int
name|alg
parameter_list|,
name|u_int16_t
modifier|*
name|min
parameter_list|,
name|u_int16_t
modifier|*
name|max
parameter_list|)
block|{
operator|*
name|min
operator|=
operator|*
name|max
operator|=
name|ah
operator|->
name|hashsize
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|keysize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Transform takes arbitrary key size but algorithm 		 * key size is restricted.  Enforce this here. 		 */
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|SADB_X_AALG_MD5
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_SHA
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_NULL
case|:
operator|*
name|min
operator|=
literal|1
expr_stmt|;
operator|*
name|max
operator|=
literal|256
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_SHA2_256
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_SHA2_384
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|48
expr_stmt|;
break|break;
case|case
name|SADB_X_AALG_SHA2_512
case|:
operator|*
name|min
operator|=
operator|*
name|max
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: unknown AH algorithm %u\n"
operator|,
name|__func__
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
parameter_list|()
block|{
specifier|const
name|struct
name|auth_hash
modifier|*
name|algo
decl_stmt|;
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|minkeysize
decl_stmt|,
name|maxkeysize
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|1
comment|/* we prefer HMAC algorithms, not old algorithms */
if|if
condition|(
name|i
operator|!=
name|SADB_AALG_SHA1HMAC
operator|&&
name|i
operator|!=
name|SADB_AALG_MD5HMAC
operator|&&
name|i
operator|!=
name|SADB_X_AALG_SHA2_256
operator|&&
name|i
operator|!=
name|SADB_X_AALG_SHA2_384
operator|&&
name|i
operator|!=
name|SADB_X_AALG_SHA2_512
condition|)
continue|continue;
endif|#
directive|endif
name|algo
operator|=
name|auth_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
name|key_getsizes_ah
argument_list|(
name|algo
argument_list|,
name|i
argument_list|,
operator|&
name|minkeysize
argument_list|,
operator|&
name|maxkeysize
argument_list|)
expr_stmt|;
comment|/* discard algorithms with key size smaller than system min */
if|if
condition|(
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
operator|<
name|V_ipsec_ah_keymin
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_minbits
operator|=
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_maxbits
operator|=
name|_BITS
argument_list|(
name|maxkeysize
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * not really an official behavior.  discussed in pf_key@inner.net in Sep2000.  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
parameter_list|()
block|{
specifier|const
name|struct
name|comp_algo
modifier|*
name|algo
decl_stmt|;
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_X_CALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|comp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|l
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"l=%u> MLEN=%lu"
operator|,
name|l
operator|,
operator|(
name|u_long
operator|)
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
comment|/* what should we set into sadb_comb_*_{min,max}bits? */
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * XXX no way to pass mode (transport/tunnel) to userland  * XXX replay checking?  * XXX sysctl interface to ipsec_{ah,esp}_keymin  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|)
block|{
name|struct
name|sadb_prop
modifier|*
name|prop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|totlen
decl_stmt|;
switch|switch
condition|(
name|saidx
operator|->
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
name|m
operator|=
name|key_getcomb_ealg
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
name|m
operator|=
name|key_getcomb_ipcomp
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|prop
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_prop
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_exttype
operator|=
name|SADB_EXT_PROPOSAL
expr_stmt|;
name|prop
operator|->
name|sadb_prop_replay
operator|=
literal|32
expr_stmt|;
comment|/* XXX */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing called by key_checkrequest() and key_acquire2().  * send  *<base, SA, address(SD), (address(P)), x_policy,  *       (identity(SD),) (sensitivity,) proposal>  * to KMD, and expect to receive  *<base> with SADB_ACQUIRE if error occurred,  * or  *<base, src address, dst address, (SPI range)> with SADB_GETSPI  * from KMD by PF_KEY.  *  * XXX x_policy is outside of RFC2367 (KAME extension).  * XXX sensitivity is not supported.  * XXX for ipcomp, RFC2367 does not define how to fill in proposal.  * see comment for key_getcomb_ipcomp().  *  * OUT:  *    0     : succeed  *    others: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|union
name|sockaddr_union
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|ul_proto
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|,
name|satype
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|saidx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null saidx"
operator|)
argument_list|)
expr_stmt|;
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|saidx
operator|->
name|proto
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|satype
operator|!=
literal|0
argument_list|,
operator|(
literal|"null satype, protocol %u"
operator|,
name|saidx
operator|->
name|proto
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
name|ul_proto
operator|=
name|IPSEC_ULPROTO_ANY
expr_stmt|;
comment|/* Get seq number to check whether sending message or not. */
name|seq
operator|=
name|key_getacq
argument_list|(
name|saidx
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_ACQUIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* 	 * set sadb_address for saidx's. 	 * 	 * Note that if sp is supplied, then we're being called from 	 * key_allocsa_policy() and should supply port and protocol 	 * information. 	 * XXXAE: why only TCP and UDP? ICMP and SCTP looks applicable too. 	 * XXXAE: probably we can handle this in the ipsec[46]_allocsa(). 	 * XXXAE: it looks like we should save this info in the ACQ entry. 	 */
if|if
condition|(
name|sp
operator|!=
name|NULL
operator|&&
operator|(
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
operator|==
name|IPPROTO_TCP
operator|||
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
operator|==
name|IPPROTO_UDP
operator|)
condition|)
name|ul_proto
operator|=
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
expr_stmt|;
name|addr
operator|=
name|saidx
operator|->
name|src
expr_stmt|;
name|mask
operator|=
name|FULLMASK
expr_stmt|;
if|if
condition|(
name|ul_proto
operator|!=
name|IPSEC_ULPROTO_ANY
condition|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
condition|)
block|{
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sin
operator|.
name|sin_port
expr_stmt|;
name|mask
operator|=
name|sp
operator|->
name|spidx
operator|.
name|prefs
expr_stmt|;
block|}
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
condition|)
block|{
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sin6
operator|.
name|sin6_port
expr_stmt|;
name|mask
operator|=
name|sp
operator|->
name|spidx
operator|.
name|prefs
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|addr
operator|.
name|sa
argument_list|,
name|mask
argument_list|,
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|addr
operator|=
name|saidx
operator|->
name|dst
expr_stmt|;
name|mask
operator|=
name|FULLMASK
expr_stmt|;
if|if
condition|(
name|ul_proto
operator|!=
name|IPSEC_ULPROTO_ANY
condition|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
condition|)
block|{
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sin
operator|.
name|sin_port
expr_stmt|;
name|mask
operator|=
name|sp
operator|->
name|spidx
operator|.
name|prefd
expr_stmt|;
block|}
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
condition|)
block|{
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
expr_stmt|;
name|mask
operator|=
name|sp
operator|->
name|spidx
operator|.
name|prefd
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|addr
operator|.
name|sa
argument_list|,
name|mask
argument_list|,
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX proxy address (optional) */
comment|/* set sadb_x_policy */
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|key_setsadbxpolicy
argument_list|(
name|sp
operator|->
name|policy
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|sp
operator|->
name|id
argument_list|,
name|sp
operator|->
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX identity (optional) */
if|#
directive|if
literal|0
block|if (idexttype&& fqdn) {
comment|/* create identity extension (FQDN) */
block|struct sadb_ident *id; 		int fqdnlen;  		fqdnlen = strlen(fqdn) + 1;
comment|/* +1 for terminating-NUL */
block|id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_FQDN; 		bcopy(fqdn, id + 1, fqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(fqdnlen); 	}  	if (idexttype) {
comment|/* create identity extension (USERFQDN) */
block|struct sadb_ident *id; 		int userfqdnlen;  		if (userfqdn) {
comment|/* +1 for terminating-NUL */
block|userfqdnlen = strlen(userfqdn) + 1; 		} else 			userfqdnlen = 0; 		id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
comment|/* XXX is it correct? */
block|if (curproc&& curproc->p_cred) 			id->sadb_ident_id = curproc->p_cred->p_ruid; 		if (userfqdn&& userfqdnlen) 			bcopy(userfqdn, id + 1, userfqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(userfqdnlen); 	}
endif|#
directive|endif
comment|/* XXX sensitivity (optional) */
comment|/* create proposal/combination extension */
name|m
operator|=
name|key_getprop
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * spec conformant: always attach proposal/combination extension, 	 * the problem is that we have no way to attach it for ipcomp, 	 * due to the way sadb_comb is declared in RFC2367. 	 */
block|if (!m) { 		error = ENOBUFS; 		goto fail; 	} 	m_cat(result, m);
else|#
directive|else
comment|/* 	 * outside of spec; make proposal/combination extension optional. 	 */
if|if
condition|(
name|m
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasindex
argument_list|(
name|saidx
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|key_newacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|int
modifier|*
name|perror
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|acq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|acq
argument_list|)
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|perror
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* copy secindex */
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|acq
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|acq
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* add to acqtree */
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|seq
operator|=
name|acq
operator|->
name|seq
operator|=
operator|(
name|V_acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|V_acq_seq
operator|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_acqtree
argument_list|,
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|ACQADDRHASH_HASH
argument_list|(
name|saidx
argument_list|)
argument_list|,
name|acq
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|ACQSEQHASH_HASH
argument_list|(
name|seq
argument_list|)
argument_list|,
name|acq
argument_list|,
name|seqhash
argument_list|)
expr_stmt|;
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
operator|*
name|perror
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|seq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|key_getacq
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|int
modifier|*
name|perror
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|ACQADDRHASH_HASH(saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|acq
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_EXACTLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|acq
operator|->
name|count
operator|>
name|V_key_blockacq_count
condition|)
block|{
comment|/* 				 * Reset counter and send message. 				 * Also reset created time to keep ACQ for 				 * this saidx. 				 */
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|acq
operator|->
name|seq
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Increment counter and do nothing. 				 * We send SADB_ACQUIRE message only 				 * for each V_key_blockacq_count packet. 				 */
name|acq
operator|->
name|count
operator|++
expr_stmt|;
name|seq
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|acq
operator|!=
name|NULL
condition|)
block|{
operator|*
name|perror
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|seq
operator|)
return|;
block|}
comment|/* allocate new  entry */
return|return
operator|(
name|key_newacq
argument_list|(
name|saidx
argument_list|,
name|perror
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_acqreset
parameter_list|(
name|uint32_t
name|seq
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|ACQSEQHASH_HASH(seq)
argument_list|,
argument|seqhash
argument_list|)
block|{
if|if
condition|(
name|acq
operator|->
name|seq
operator|==
name|seq
condition|)
block|{
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
break|break;
block|}
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark ACQ entry as stale to remove it in key_flush_acq().  * Called after successful SADB_GETSPI message.  */
end_comment

begin_function
specifier|static
name|int
name|key_acqdone
parameter_list|(
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|ACQSEQHASH_HASH(seq)
argument_list|,
argument|seqhash
argument_list|)
block|{
if|if
condition|(
name|acq
operator|->
name|seq
operator|==
name|seq
condition|)
break|break;
block|}
if|if
condition|(
name|acq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|acq
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_EXACTLY
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: Mismatched saidx for ACQ %u"
operator|,
name|__func__
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
name|acq
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|acq
operator|->
name|created
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: ACQ %u is not found."
operator|,
name|__func__
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
comment|/* get new entry */
name|acq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secspacq
argument_list|)
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy secindex */
name|bcopy
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|,
sizeof|sizeof
argument_list|(
name|acq
operator|->
name|spidx
argument_list|)
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|time_second
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* add to spacqtree */
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_spacqtree
argument_list|,
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|acq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
parameter_list|(
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&V_spacqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|)
condition|)
block|{
comment|/* NB: return holding spacq_lock */
return|return
name|acq
return|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing,  * in first situation, is receiving  *<base>  * from the ikmpd, and clear sequence of its secasvar entry.  *  * In second situation, is receiving  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * from a user land process, and return  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * to the socket.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|uint32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|,
name|proto
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Error message from KMd. 	 * We assume that if error was occurred in IKEd, the length of PFKEY 	 * message is equal to the size of sadb_msg structure. 	 * We do not raise error even if error occurred in this function. 	 */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
operator|==
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* check sequence number */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|==
literal|0
operator|||
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: must specify sequence "
literal|"number and errno.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * IKEd reported that error occurred. 			 * XXXAE: what it expects from the kernel? 			 * Probably we should send SADB_ACQUIRE again? 			 * If so, reset ACQ's state. 			 * XXXAE: it looks useless. 			 */
name|key_acqreset
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This message is from user land. 	 */
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_PROPOSAL
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: missing required header.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
operator|||
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_EXT_PROPOSAL
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|SADB_CHECKHDR
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SADB_CHECKLEN
argument_list|(
name|mhp
argument_list|,
name|SADB_X_EXT_SA2
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message: wrong header size.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|error
operator|=
name|key_checksockaddrs
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid sockaddr.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA index */
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|SAHADDRHASH_HASH(&saidx)
argument_list|,
argument|addrhash
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
break|break;
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: a SA exists already.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|error
operator|=
name|key_acquire
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: error %d returned from key_acquire()\n"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_REGISTER processing.  * If SATYPE_UNSPEC has been passed as satype, only return sabd_supported.  * receive  *<base>  * from the ikmpd, and register a socket to send PF_KEY messages,  * and send  *<base, supported>  * to KMD by PF_KEY.  * If socket is detached, must free from regnode.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_register
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|newreg
init|=
name|NULL
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* check for invalid register message */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|>=
sizeof|sizeof
argument_list|(
name|V_regtree
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|V_regtree
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
comment|/* When SATYPE_UNSPEC is specified, only return sabd_supported. */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_UNSPEC
condition|)
goto|goto
name|setmsg
goto|;
comment|/* check whether existing or not */
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[mhp->msg->sadb_msg_satype]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: socket exists already.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
block|}
comment|/* create regnode */
name|newreg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|secreg
argument_list|)
argument_list|,
name|M_IPSEC_SAR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|==
name|NULL
condition|)
block|{
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newreg
operator|->
name|so
operator|=
name|so
expr_stmt|;
operator|(
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|->
name|kp_registered
operator|++
expr_stmt|;
comment|/* add regnode to regtree. */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_regtree
index|[
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
index|]
argument_list|,
name|newreg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|setmsg
label|:
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|sadb_supported
modifier|*
name|sup
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|alen
decl_stmt|,
name|elen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sadb_alg
modifier|*
name|alg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|alen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|auth_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alen
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
name|elen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|enc_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elen
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|alen
operator|+
name|elen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for authentication algorithm */
if|if
condition|(
name|alen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|alen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_AUTH
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|auth_hash
modifier|*
name|aalgo
decl_stmt|;
name|u_int16_t
name|minkeysize
decl_stmt|,
name|maxkeysize
decl_stmt|;
name|aalgo
operator|=
name|auth_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aalgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|key_getsizes_ah
argument_list|(
name|aalgo
argument_list|,
name|i
argument_list|,
operator|&
name|minkeysize
argument_list|,
operator|&
name|maxkeysize
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|_BITS
argument_list|(
name|minkeysize
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|_BITS
argument_list|(
name|maxkeysize
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for encryption algorithm */
if|if
condition|(
name|elen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|elen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_ENCRYPT
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|enc_xform
modifier|*
name|ealgo
decl_stmt|;
name|ealgo
operator|=
name|enc_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ealgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
name|ealgo
operator|->
name|ivsize
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|_BITS
argument_list|(
name|ealgo
operator|->
name|minkey
argument_list|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|_BITS
argument_list|(
name|ealgo
operator|->
name|maxkey
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|IPSEC_ASSERT
argument_list|(
name|off
operator|==
name|len
argument_list|,
operator|(
literal|"length assumption failed (off %u len %u)"
operator|,
name|off
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * free secreg entry registered.  * XXX: I want to do free a socket marked done SADB_RESIGER to socket.  */
end_comment

begin_function
name|void
name|key_freereg
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL so"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * check whether existing or not. 	 * check all type of SA, because there is a potential that 	 * one socket is registered to multiple type of SA. 	 */
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
operator|&&
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|,
name|M_IPSEC_SAR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SADB_EXPIRE processing  * send  *<base, SA, SA2, lifetime(C and one of HS), address(SD)>  * to KMD by PF_KEY.  * NOTE: We send only soft lifetime extension.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_expire
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|int
name|hard
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
name|uint32_t
name|replay_count
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|uint8_t
name|satype
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sav"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|sah
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null sa header"
operator|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p) expired %s lifetime\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
name|hard
condition|?
literal|"hard"
else|:
literal|"soft"
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|KEY_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|satype
operator|!=
literal|0
argument_list|,
operator|(
literal|"invalid proto, satype %u"
operator|,
name|satype
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_EXPIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|sav
operator|->
name|seq
argument_list|,
literal|0
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|replay_count
operator|=
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|replay_count
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|&&
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|>
name|UINT8_MAX
condition|)
block|{
name|m
operator|=
name|key_setsadbxsareplay
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* create lifetime extension (current and soft) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
operator|(
name|uint32_t
operator|)
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_allocations
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|counter_u64_fetch
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|created
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|firstused
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard
condition|)
block|{
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_HARD
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_h
operator|->
name|allocations
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_h
operator|->
name|bytes
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_h
operator|->
name|addtime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_h
operator|->
name|usetime
expr_stmt|;
block|}
else|else
block|{
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_SOFT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|allocations
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|bytes
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|addtime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_s
operator|->
name|usetime
expr_stmt|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * XXX-BZ Handle NAT-T extensions here. 	 * XXXAE: it doesn't seem quite useful. IKEs should not depend on 	 * this information, we report only significant SA fields. 	 */
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|key_freesah_flushed
parameter_list|(
name|struct
name|secashead_queue
modifier|*
name|flushq
parameter_list|)
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|sah
operator|=
name|TAILQ_FIRST
argument_list|(
name|flushq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|TAILQ_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sah
operator|->
name|savtree_larval
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
name|sav
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|)
expr_stmt|;
while|while
condition|(
name|sav
operator|!=
name|NULL
condition|)
block|{
name|nextsav
operator|=
name|TAILQ_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sah
operator|->
name|savtree_alive
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release reference from SAV */
name|sav
operator|=
name|nextsav
expr_stmt|;
block|}
name|nextsah
operator|=
name|TAILQ_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesah
argument_list|(
operator|&
name|sah
argument_list|)
expr_stmt|;
comment|/* release last reference */
name|sah
operator|=
name|nextsah
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_FLUSH processing  * receive  *<base>  * from the ikmpd, and free all entries in secastree.  * and send,  *<base>  * to the ikmpd.  * NOTE: to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_flush
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|secashead_queue
name|flushq
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|KEYDBG
argument_list|(
name|KEY_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: proto %u\n"
argument_list|,
name|__func__
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|flushq
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPSEC_PROTO_ANY
condition|)
block|{
comment|/* no SATYPE specified, i.e. flushing all SA. */
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
comment|/* Move all SAHs into flushq */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|flushq
argument_list|,
operator|&
name|V_sahtree
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* Flush all buckets in SPI hash */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V_savhash_mask
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_savhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Flush all buckets in SAHADDRHASH */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V_sahaddrhash_mask
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_sahaddrhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Mark all SAHs as unlinked */
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&flushq
argument_list|,
argument|chain
argument_list|)
block|{
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
comment|/* 			 * Callout handler makes its job using 			 * RLOCK and drain queues. In case, when this 			 * function will be called just before it 			 * acquires WLOCK, we need to mark SAs as 			 * unlinked to prevent second unlink. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
name|sah
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_sahtree
argument_list|)
expr_stmt|;
while|while
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sah
operator|->
name|state
operator|!=
name|SADB_SASTATE_DEAD
argument_list|,
operator|(
literal|"DEAD SAH %p in SADB_FLUSH"
operator|,
name|sah
operator|)
argument_list|)
expr_stmt|;
name|nextsah
operator|=
name|TAILQ_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|proto
condition|)
block|{
name|sah
operator|=
name|nextsah
expr_stmt|;
continue|continue;
block|}
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|V_sahtree
argument_list|,
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|addrhash
argument_list|)
expr_stmt|;
comment|/* Unlink all SAs from SPI hash */
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|spihash
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
comment|/* Add SAH into flushq */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|flushq
argument_list|,
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sah
operator|=
name|nextsah
expr_stmt|;
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
block|}
name|key_freesah_flushed
argument_list|(
operator|&
name|flushq
argument_list|)
expr_stmt|;
comment|/* Free all queued SAs and SAHs */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|||
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: No more memory.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_DUMP processing  * dump all entries including status of DEAD in SAD.  * receive  *<base>  * from the ikmpd, and dump all secasvar leaves  * and send,  *<base> .....  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_dump
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|SAHTREE_RLOCK_TRACKER
expr_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|uint32_t
name|cnt
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|,
name|satype
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid satype is passed.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* count sav entries to be sent to the userland. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|SAHTREE_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
name|cnt
operator|++
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
comment|/* send this to the userland, one at a time. */
name|newmsg
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&V_sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: there was invalid proto in "
literal|"SAD.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
block|{
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_DUMP
argument_list|,
name|satype
argument_list|,
operator|--
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_DUMP
argument_list|,
name|satype
argument_list|,
operator|--
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
name|SAHTREE_RUNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_PROMISC processing  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_promisc
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|int
name|olen
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|->
name|msg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msg"
operator|)
argument_list|)
expr_stmt|;
name|olen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
else|#
directive|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|olen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
comment|/* enable/disable promisc mode */
name|struct
name|keycb
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|(
name|kp
operator|=
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|kp
operator|->
name|kp_promisc
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
expr_stmt|;
break|break;
default|default:
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* send the original message back to everyone */
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
else|else
block|{
comment|/* send packet as is */
name|m_adj
argument_list|(
name|m
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: if sadb_msg_seq is specified, send to specific pid */
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|key_typesw
index|[]
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
parameter_list|)
init|=
block|{
name|NULL
operator|,
comment|/* SADB_RESERVED */
function_decl|key_getspi
operator|,
comment|/* SADB_GETSPI */
function_decl|key_update
operator|,
comment|/* SADB_UPDATE */
function_decl|key_add
operator|,
comment|/* SADB_ADD */
function_decl|key_delete
operator|,
comment|/* SADB_DELETE */
function_decl|key_get
operator|,
comment|/* SADB_GET */
function_decl|key_acquire2
operator|,
comment|/* SADB_ACQUIRE */
function_decl|key_register
operator|,
comment|/* SADB_REGISTER */
function_decl|NULL
operator|,
comment|/* SADB_EXPIRE */
function_decl|key_flush
operator|,
comment|/* SADB_FLUSH */
function_decl|key_dump
operator|,
comment|/* SADB_DUMP */
function_decl|key_promisc
operator|,
comment|/* SADB_X_PROMISC */
function_decl|NULL
operator|,
comment|/* SADB_X_PCHANGE */
function_decl|key_spdadd
operator|,
comment|/* SADB_X_SPDUPDATE */
function_decl|key_spdadd
operator|,
comment|/* SADB_X_SPDADD */
function_decl|key_spddelete
operator|,
comment|/* SADB_X_SPDDELETE */
function_decl|key_spdget
operator|,
comment|/* SADB_X_SPDGET */
function_decl|NULL
operator|,
comment|/* SADB_X_SPDACQUIRE */
function_decl|key_spddump
operator|,
comment|/* SADB_X_SPDDUMP */
function_decl|key_spdflush
operator|,
comment|/* SADB_X_SPDFLUSH */
function_decl|key_spdadd
operator|,
comment|/* SADB_X_SPDSETIDX */
function_decl|NULL
operator|,
comment|/* SADB_X_SPDEXPIRE */
function_decl|key_spddelete2
operator|,
end_function_decl

begin_comment
comment|/* SADB_X_SPDDELETE2 */
end_comment

begin_comment
unit|};
comment|/*  * parse sadb_msg buffer to process PFKEYv2,  * and create a data to response if needed.  * I think to be dealed with mbuf directly.  * IN:  *     msgp  : pointer to pointer to a received buffer pulluped.  *             This is rewrited to response.  *     so    : pointer to socket.  * OUT:  *    length for buffer to send to user process.  */
end_comment

begin_function
name|int
name|key_parse
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_msghdr
name|mh
decl_stmt|;
name|u_int
name|orglen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|target
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null socket"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|ENOBUFS
return|;
block|}
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|orglen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|target
operator|=
name|KEY_SENDUP_ONE
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|orglen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid message length.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_version
operator|!=
name|PF_KEY_V2
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: PF_KEY version %u is mismatched.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_version
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invver
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>
name|SADB_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid type %u is passed.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invmsgtype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* for old-fashioned code - should be nuked */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MCLBYTES
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* align the mbuf chain so that extensions are in contiguous region. */
name|error
operator|=
name|key_align
argument_list|(
name|m
argument_list|,
operator|&
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|msg
operator|=
name|mh
operator|.
name|msg
expr_stmt|;
comment|/* We use satype as scope mask for spddump */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDDUMP
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|IPSEC_POLICYSCOPE_ANY
case|:
case|case
name|IPSEC_POLICYSCOPE_GLOBAL
case|:
case|case
name|IPSEC_POLICYSCOPE_IFNET
case|:
case|case
name|IPSEC_POLICYSCOPE_PCB
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal satype=%u\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invsatype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
comment|/* check SA type */
case|case
name|SADB_SATYPE_UNSPEC
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
case|case
name|SADB_UPDATE
case|:
case|case
name|SADB_ADD
case|:
case|case
name|SADB_DELETE
case|:
case|case
name|SADB_GET
case|:
case|case
name|SADB_ACQUIRE
case|:
case|case
name|SADB_EXPIRE
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: must specify satype "
literal|"when msg type=%u.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invsatype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
case|case
name|SADB_X_SATYPE_TCPSIGNATURE
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_X_SPDADD
case|:
case|case
name|SADB_X_SPDDELETE
case|:
case|case
name|SADB_X_SPDGET
case|:
case|case
name|SADB_X_SPDFLUSH
case|:
case|case
name|SADB_X_SPDSETIDX
case|:
case|case
name|SADB_X_SPDUPDATE
case|:
case|case
name|SADB_X_SPDDELETE2
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal satype=%u\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invsatype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_RSVP
case|:
case|case
name|SADB_SATYPE_OSPFV2
case|:
case|case
name|SADB_SATYPE_RIPV2
case|:
case|case
name|SADB_SATYPE_MIP
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: type %u isn't supported.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invsatype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|senderror
goto|;
case|case
literal|1
case|:
comment|/* XXX: What does it do? */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_PROMISC
condition|)
break|break;
comment|/*FALLTHROUGH*/
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid type %u is passed.\n"
operator|,
name|__func__
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invsatype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
block|}
comment|/* check field of upper layer protocol and address family */
if|if
condition|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|!=
name|NULL
operator|&&
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|u_int
name|plen
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* check upper layer protocol */
if|if
condition|(
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: upper layer protocol "
literal|"mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* check family */
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address family mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: address struct size "
literal|"mismatched.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: unsupported address family\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
name|plen
operator|=
literal|0
expr_stmt|;
comment|/*fool gcc*/
break|break;
block|}
comment|/* check max prefix length */
if|if
condition|(
name|src0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
operator|||
name|dst0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: illegal prefixlen.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* 		 * prefixlen == 0 is valid because there can be a case when 		 * all addresses are matched. 		 */
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>=
name|nitems
argument_list|(
name|key_typesw
argument_list|)
operator|||
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
operator|==
name|NULL
condition|)
block|{
name|PFKEYSTAT_INC
argument_list|(
name|out_invmsgtype
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
return|return
call|(
modifier|*
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
operator|&
name|mh
argument_list|)
return|;
name|senderror
label|:
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_senderror
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
operator|(
literal|"mbuf too small, len %u"
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|code
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the pointer to each header into message buffer.  * m will be freed on error.  * XXX larger-than-MCLBYTES extension?  */
end_comment

begin_function
specifier|static
name|int
name|key_align
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|end
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|int
name|toff
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|mhp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null msghdr"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
operator|(
literal|"mbuf too small, len %u"
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize */
name|bzero
argument_list|(
name|mhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mhp
argument_list|)
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|mhp
operator|->
name|msg
expr_stmt|;
comment|/*XXX backward compat */
name|end
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|extlen
operator|=
name|end
expr_stmt|;
comment|/*just in case extlen is not updated*/
for|for
control|(
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
init|;
name|off
operator|<
name|end
condition|;
name|off
operator|+=
name|extlen
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ext
argument_list|)
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
comment|/* set pointer */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
case|case
name|SADB_EXT_KEY_AUTH
case|:
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
case|case
name|SADB_EXT_SENSITIVITY
case|:
case|case
name|SADB_EXT_PROPOSAL
case|:
case|case
name|SADB_EXT_SUPPORTED_AUTH
case|:
case|case
name|SADB_EXT_SUPPORTED_ENCRYPT
case|:
case|case
name|SADB_EXT_SPIRANGE
case|:
case|case
name|SADB_X_EXT_POLICY
case|:
case|case
name|SADB_X_EXT_SA2
case|:
case|case
name|SADB_X_EXT_NAT_T_TYPE
case|:
case|case
name|SADB_X_EXT_NAT_T_SPORT
case|:
case|case
name|SADB_X_EXT_NAT_T_DPORT
case|:
case|case
name|SADB_X_EXT_NAT_T_OAI
case|:
case|case
name|SADB_X_EXT_NAT_T_OAR
case|:
case|case
name|SADB_X_EXT_NAT_T_FRAG
case|:
case|case
name|SADB_X_EXT_SA_REPLAY
case|:
case|case
name|SADB_X_EXT_NEW_ADDRESS_SRC
case|:
case|case
name|SADB_X_EXT_NEW_ADDRESS_DST
case|:
comment|/* duplicate check */
comment|/* 			 * XXX Are there duplication payloads of either 			 * KEY_AUTH or KEY_ENCRYPT ? 			 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: duplicate ext_type "
literal|"%u\n"
operator|,
name|__func__
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_dupext
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"%s: invalid ext_type %u\n"
operator|,
name|__func__
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invexttype
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|extlen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_validate_ext
argument_list|(
name|ext
argument_list|,
name|extlen
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invlen
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|extlen
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|ext
expr_stmt|;
name|mhp
operator|->
name|extoff
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|off
expr_stmt|;
name|mhp
operator|->
name|extlen
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|extlen
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|!=
name|end
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|PFKEYSTAT_INC
argument_list|(
name|out_invlen
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_validate_ext
parameter_list|(
specifier|const
name|struct
name|sadb_ext
modifier|*
name|ext
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
enum|enum
block|{
name|NONE
block|,
name|ADDR
block|}
name|checktype
init|=
name|NONE
enum|;
name|int
name|baselen
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|sal
init|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr
argument_list|,
name|sa_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* if it does not match minimum/maximum length, bail */
if|if
condition|(
name|ext
operator|->
name|sadb_ext_type
operator|>=
name|nitems
argument_list|(
name|minsize
argument_list|)
operator|||
name|ext
operator|->
name|sadb_ext_type
operator|>=
name|nitems
argument_list|(
name|maxsize
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|||
name|len
operator|<
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|&&
name|len
operator|>
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
comment|/* more checks based on sadb_ext_type XXX need more */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_X_EXT_NAT_T_OAI
case|:
case|case
name|SADB_X_EXT_NAT_T_OAR
case|:
case|case
name|SADB_X_EXT_NEW_ADDRESS_SRC
case|:
case|case
name|SADB_X_EXT_NEW_ADDRESS_DST
case|:
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
break|break;
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|ext
operator|)
operator|->
name|sadb_ident_type
operator|==
name|SADB_X_IDENTTYPE_ADDR
condition|)
block|{
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
block|}
else|else
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
default|default:
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|checktype
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|ADDR
case|:
name|sa
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|ext
operator|)
operator|+
name|baselen
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|baselen
operator|+
name|sal
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|baselen
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
operator|!=
name|len
condition|)
return|return
name|EINVAL
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|key_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|V_sptree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_sptree_ifnet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|V_key_lft_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"IPsec SA lft_c"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_PCPU
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_sahtree
argument_list|)
expr_stmt|;
name|V_sphashtbl
operator|=
name|hashinit
argument_list|(
name|SPHASH_NHASH
argument_list|,
name|M_IPSEC_SP
argument_list|,
operator|&
name|V_sphash_mask
argument_list|)
expr_stmt|;
name|V_savhashtbl
operator|=
name|hashinit
argument_list|(
name|SAVHASH_NHASH
argument_list|,
name|M_IPSEC_SA
argument_list|,
operator|&
name|V_savhash_mask
argument_list|)
expr_stmt|;
name|V_sahaddrhashtbl
operator|=
name|hashinit
argument_list|(
name|SAHHASH_NHASH
argument_list|,
name|M_IPSEC_SAH
argument_list|,
operator|&
name|V_sahaddrhash_mask
argument_list|)
expr_stmt|;
name|V_acqaddrhashtbl
operator|=
name|hashinit
argument_list|(
name|ACQHASH_NHASH
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
operator|&
name|V_acqaddrhash_mask
argument_list|)
expr_stmt|;
name|V_acqseqhashtbl
operator|=
name|hashinit
argument_list|(
name|ACQHASH_NHASH
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
operator|&
name|V_acqseqhash_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_regtree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_acqtree
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
return|return;
name|XFORMS_LOCK_INIT
argument_list|()
expr_stmt|;
name|SPTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|REGTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|SAHTREE_LOCK_INIT
argument_list|()
expr_stmt|;
name|ACQ_LOCK_INIT
argument_list|()
expr_stmt|;
name|SPACQ_LOCK_INIT
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
name|callout_init
argument_list|(
operator|&
name|key_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|key_timer
argument_list|,
name|hz
argument_list|,
name|key_timehandler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*IPSEC_DEBUG2*/
comment|/* initialize key statistics */
name|keystat
operator|.
name|getspi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"IPsec: Initialized Security Association Processing.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|key_destroy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|secashead_queue
name|sahdrainq
decl_stmt|;
name|struct
name|secpolicy_queue
name|drainq
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
name|struct
name|secspacq
modifier|*
name|spacq
decl_stmt|,
modifier|*
name|nextspacq
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * XXX: can we just call free() for each object without 	 * walking through safe way with releasing references? 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
name|SPTREE_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_CONCAT
argument_list|(
operator|&
name|drainq
argument_list|,
operator|&
name|V_sptree
index|[
name|i
index|]
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|drainq
argument_list|,
operator|&
name|V_sptree_ifnet
index|[
name|i
index|]
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
name|SPTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|drainq
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|nextsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|nextsp
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sahdrainq
argument_list|)
expr_stmt|;
name|SAHTREE_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sahdrainq
argument_list|,
operator|&
name|V_sahtree
argument_list|,
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V_savhash_mask
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_savhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V_sahaddrhash_mask
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|V_sahaddrhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahdrainq
argument_list|,
argument|chain
argument_list|)
block|{
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_larval
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree_alive
argument_list|,
argument|chain
argument_list|)
block|{
name|sav
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
block|}
name|SAHTREE_WUNLOCK
argument_list|()
expr_stmt|;
name|key_freesah_flushed
argument_list|(
operator|&
name|sahdrainq
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|V_sphashtbl
argument_list|,
name|M_IPSEC_SP
argument_list|,
name|V_sphash_mask
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|V_savhashtbl
argument_list|,
name|M_IPSEC_SA
argument_list|,
name|V_savhash_mask
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|V_sahaddrhashtbl
argument_list|,
name|M_IPSEC_SAH
argument_list|,
name|V_sahaddrhash_mask
argument_list|)
expr_stmt|;
name|REGTREE_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&V_regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|,
name|M_IPSEC_SAR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|REGTREE_UNLOCK
argument_list|()
expr_stmt|;
name|ACQ_LOCK
argument_list|()
expr_stmt|;
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_acqtree
argument_list|)
expr_stmt|;
while|while
condition|(
name|acq
operator|!=
name|NULL
condition|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|acq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
name|acq
operator|=
name|nextacq
expr_stmt|;
block|}
name|ACQ_UNLOCK
argument_list|()
expr_stmt|;
name|SPACQ_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|spacq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|V_spacqtree
argument_list|)
init|;
name|spacq
operator|!=
name|NULL
condition|;
name|spacq
operator|=
name|nextspacq
control|)
block|{
name|nextspacq
operator|=
name|LIST_NEXT
argument_list|(
name|spacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|spacq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|spacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|spacq
argument_list|,
name|M_IPSEC_SAQ
argument_list|)
expr_stmt|;
block|}
block|}
name|SPACQ_UNLOCK
argument_list|()
expr_stmt|;
name|hashdestroy
argument_list|(
name|V_acqaddrhashtbl
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|V_acqaddrhash_mask
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|V_acqseqhashtbl
argument_list|,
name|M_IPSEC_SAQ
argument_list|,
name|V_acqseqhash_mask
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_key_lft_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* record data transfer on SA, and update timestamps */
end_comment

begin_function
name|void
name|key_sa_recordxfer
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null secasvar"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null mbuf"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Currently, there is a difference of bytes size 	 * between inbound and outbound processing. 	 */
name|counter_u64_add
argument_list|(
name|sav
operator|->
name|lft_c_bytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * We use the number of packets as the unit of 	 * allocations.  We increment the variable 	 * whenever {esp,ah}_{in,out}put is called. 	 */
name|counter_u64_add
argument_list|(
name|sav
operator|->
name|lft_c_allocations
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: We record CURRENT usetime by using wall clock, 	 * in seconds.  HARD and SOFT lifetime are measured by the time 	 * difference (again in seconds) from usetime. 	 * 	 *	usetime 	 *	v     expire   expire 	 * -----+-----+--------+---> t 	 *<--------------> HARD 	 *<-----> SOFT 	 */
if|if
condition|(
name|sav
operator|->
name|firstused
operator|==
literal|0
condition|)
name|sav
operator|->
name|firstused
operator|=
name|time_second
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take one of the kernel's security keys and convert it into a PF_KEY  * structure within an mbuf, suitable for sending up to a waiting  * application in user land.  *   * IN:   *    src: A pointer to a kernel security key.  *    exttype: Which type of key this is. Refer to the PF_KEY data structures.  * OUT:  *    a valid mbuf or NULL indicating an error  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setkey
parameter_list|(
name|struct
name|seckey
modifier|*
name|src
parameter_list|,
name|uint16_t
name|exttype
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_key
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
operator|+
name|_KEYLEN
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_key
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_key_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_key_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_key_bits
operator|=
name|src
operator|->
name|bits
expr_stmt|;
name|bcopy
argument_list|(
name|src
operator|->
name|key_data
argument_list|,
name|_KEYBUF
argument_list|(
name|p
argument_list|)
argument_list|,
name|_KEYLEN
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Take one of the kernel's lifetime data structures and convert it  * into a PF_KEY structure within an mbuf, suitable for sending up to  * a waiting application in user land.  *   * IN:   *    src: A pointer to a kernel lifetime structure.  *    exttype: Which type of lifetime this is. Refer to the PF_KEY   *             data structures for more information.  * OUT:  *    a valid mbuf or NULL indicating an error  *  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setlifetime
parameter_list|(
name|struct
name|seclifetime
modifier|*
name|src
parameter_list|,
name|uint16_t
name|exttype
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|m
return|;
name|m_align
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_allocations
operator|=
name|src
operator|->
name|allocations
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_bytes
operator|=
name|src
operator|->
name|bytes
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_addtime
operator|=
name|src
operator|->
name|addtime
expr_stmt|;
name|p
operator|->
name|sadb_lifetime_usetime
operator|=
name|src
operator|->
name|usetime
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|enc_xform
modifier|*
name|enc_algorithm_lookup
parameter_list|(
name|int
name|alg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|supported_ealgs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alg
operator|==
name|supported_ealgs
index|[
name|i
index|]
operator|.
name|sadb_alg
condition|)
return|return
operator|(
name|supported_ealgs
index|[
name|i
index|]
operator|.
name|xform
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|auth_hash
modifier|*
name|auth_algorithm_lookup
parameter_list|(
name|int
name|alg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|supported_aalgs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alg
operator|==
name|supported_aalgs
index|[
name|i
index|]
operator|.
name|sadb_alg
condition|)
return|return
operator|(
name|supported_aalgs
index|[
name|i
index|]
operator|.
name|xform
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|comp_algo
modifier|*
name|comp_algorithm_lookup
parameter_list|(
name|int
name|alg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|supported_calgs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alg
operator|==
name|supported_calgs
index|[
name|i
index|]
operator|.
name|sadb_alg
condition|)
return|return
operator|(
name|supported_calgs
index|[
name|i
index|]
operator|.
name|xform
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a transform.  */
end_comment

begin_function
specifier|static
name|int
name|xform_register
parameter_list|(
name|struct
name|xformsw
modifier|*
name|xsp
parameter_list|)
block|{
name|struct
name|xformsw
modifier|*
name|entry
decl_stmt|;
name|XFORMS_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&xforms
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|xf_type
operator|==
name|xsp
operator|->
name|xf_type
condition|)
block|{
name|XFORMS_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|xforms
argument_list|,
name|xsp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|XFORMS_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xform_attach
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|xformsw
modifier|*
name|xsp
init|=
operator|(
expr|struct
name|xformsw
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|xform_register
argument_list|(
name|xsp
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: failed to register %s xform\n"
argument_list|,
name|__func__
argument_list|,
name|xsp
operator|->
name|xf_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xform_detach
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|xformsw
modifier|*
name|xsp
init|=
operator|(
expr|struct
name|xformsw
operator|*
operator|)
name|data
decl_stmt|;
name|XFORMS_LOCK
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|xsp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|XFORMS_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Delete all SAs related to this xform. */
name|key_delete_xform
argument_list|(
name|xsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize transform support in an sav.  */
end_comment

begin_function
specifier|static
name|int
name|xform_init
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|u_short
name|xftype
parameter_list|)
block|{
name|struct
name|xformsw
modifier|*
name|entry
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|tdb_xform
operator|==
name|NULL
argument_list|,
operator|(
literal|"tdb_xform is already initialized"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|XFORMS_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&xforms
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|xf_type
operator|==
name|xftype
condition|)
block|{
name|ret
operator|=
call|(
modifier|*
name|entry
operator|->
name|xf_init
call|)
argument_list|(
name|sav
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|XFORMS_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

