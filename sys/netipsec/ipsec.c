begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: ipsec.c,v 1.103 2001/05/24 07:14:18 sakane Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * IPsec controller part.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/hhook.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_enc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netipsec/ah_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/esp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipcomp.h>
end_include

begin_comment
comment|/*XXX*/
end_comment

begin_include
include|#
directive|include
file|<netipsec/ipcomp_var.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec_support.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/xform.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_comment
comment|/* NB: name changed so netstat doesn't use it. */
end_comment

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|ipsecstat
argument_list|,
name|ipsec4stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ipsec4stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ipsec4stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_ah_offsetmask
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maybe IP_DF? */
end_comment

begin_comment
comment|/* DF bit on encap. 0: clear 1: set 2: copy */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_ipsec_dfbit
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_esp_trans_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_esp_net_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_ah_trans_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_ah_net_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ECN ignore(-1)/forbidden(0)/allowed(1) */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_ipsec_ecn
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_esp_randpad
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip4_filtertunnel
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip4_filtertunnel
value|VNET(ip4_filtertunnel)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|check_policy_history
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_check_policy_history
value|VNET(check_policy_history)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|secpolicy
operator|*
argument_list|,
name|def_policy
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_def_policy
value|VNET(def_policy)
end_define

begin_function
specifier|static
name|int
name|sysctl_def_policy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
name|V_def_policy
operator|->
name|policy
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|IPSEC_POLICY_DISCARD
operator|&&
name|value
operator|!=
name|IPSEC_POLICY_NONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|V_def_policy
operator|->
name|policy
operator|=
name|value
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Crypto support requirements:  *  *  1	require hardware support  * -1	require software support  *  0	take anything  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|crypto_support
argument_list|)
operator|=
name|CRYPTOCAP_F_HARDWARE
operator||
name|CRYPTOCAP_F_SOFTWARE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * TCP/UDP checksum handling policy for transport mode NAT-T (RFC3948)  *  * 0 - auto: incrementally recompute, when checksum delta is known;  *     if checksum delta isn't known, reset checksum to zero for UDP,  *     and mark csum_flags as valid for TCP.  * 1 - fully recompute TCP/UDP checksum.  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|natt_cksum_policy
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FEATURE
argument_list|(
name|ipsec
argument_list|,
literal|"Internet Protocol Security (IPsec)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FEATURE
argument_list|(
name|ipsec_natt
argument_list|,
literal|"UDP Encapsulation of IPsec ESP Packets ('NAT-T')"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_ipsec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* net.inet.ipsec */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEF_POLICY
argument_list|,
name|def_policy
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_def_policy
argument_list|,
literal|"I"
argument_list|,
literal|"IPsec default policy."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEF_ESP_TRANSLEV
argument_list|,
name|esp_trans_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_esp_trans_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default ESP transport mode level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEF_ESP_NETLEV
argument_list|,
name|esp_net_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_esp_net_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default ESP tunnel mode level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEF_AH_TRANSLEV
argument_list|,
name|ah_trans_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_ah_trans_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"AH transfer mode default level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DEF_AH_NETLEV
argument_list|,
name|ah_net_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_ah_net_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"AH tunnel mode default level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_AH_CLEARTOS
argument_list|,
name|ah_cleartos
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ah_cleartos
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"If set, clear type-of-service field when doing AH computation."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_AH_OFFSETMASK
argument_list|,
name|ah_offsetmask
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_ah_offsetmask
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"If not set, clear offset field mask when doing AH computation."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_DFBIT
argument_list|,
name|dfbit
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_ipsec_dfbit
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Do not fragment bit on encap."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|IPSECCTL_ECN
argument_list|,
name|ecn
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_ipsec_ecn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Explicit Congestion Notification handling."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|crypto_support
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|crypto_support
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Crypto driver selection."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|check_policy_history
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|check_policy_history
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Use strict check of inbound packets to security policy compliance."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|natt_cksum_policy
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|natt_cksum_policy
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Method to fix TCP/UDP checksum for transport mode IPsec after NAT."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|filtertunnel
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip4_filtertunnel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"If set, filter packets from an IPsec tunnel."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|ipsecstats
argument_list|,
expr|struct
name|ipsecstat
argument_list|,
name|ipsec4stat
argument_list|,
literal|"IPsec IPv4 statistics."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REGRESSION
end_ifdef

begin_comment
comment|/*  * When set to 1, IPsec will send packets with the same sequence number.  * This allows to verify if the other side has proper replay attacks detection.  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_replay
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|test_replay
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_replay
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Emulate replay attack"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * When set 1, IPsec will send packets with corrupted HMAC.  * This allows to verify if the other side properly detects modified packets.  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsec_integrity
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ipsec
argument_list|,
name|OID_AUTO
argument_list|,
name|test_integrity
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsec_integrity
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Emulate man-in-the-middle attack"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|ipsecstat
argument_list|,
name|ipsec6stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ipsec6stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ipsec6stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_esp_trans_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_esp_net_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_ah_trans_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_ah_net_deflev
argument_list|)
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_ipsec_ecn
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ECN ignore(-1)/forbidden(0)/allowed(1) */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip6_filtertunnel
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip6_filtertunnel
value|VNET(ip6_filtertunnel)
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet6_ipsec6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* net.inet6.ipsec6 */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEF_POLICY
argument_list|,
name|def_policy
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_def_policy
argument_list|,
literal|"I"
argument_list|,
literal|"IPsec default policy."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEF_ESP_TRANSLEV
argument_list|,
name|esp_trans_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_esp_trans_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default ESP transport mode level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEF_ESP_NETLEV
argument_list|,
name|esp_net_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_esp_net_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default ESP tunnel mode level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEF_AH_TRANSLEV
argument_list|,
name|ah_trans_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_ah_trans_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"AH transfer mode default level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_DEF_AH_NETLEV
argument_list|,
name|ah_net_deflev
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_ah_net_deflev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"AH tunnel mode default level."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_ECN
argument_list|,
name|ecn
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_ipsec_ecn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Explicit Congestion Notification handling."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|OID_AUTO
argument_list|,
name|filtertunnel
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip6_filtertunnel
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"If set, filter packets from an IPsec tunnel."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet6_ipsec6
argument_list|,
name|IPSECCTL_STATS
argument_list|,
name|ipsecstats
argument_list|,
expr|struct
name|ipsecstat
argument_list|,
name|ipsec6stat
argument_list|,
literal|"IPsec IPv6 statistics."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function_decl
specifier|static
name|int
name|ipsec_in_reject
parameter_list|(
name|struct
name|secpolicy
modifier|*
parameter_list|,
name|struct
name|inpcb
modifier|*
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|void
name|ipsec4_get_ulp
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipsec4_setspidx_ipaddr
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|void
name|ipsec6_get_ulp
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipsec6_setspidx_ipaddr
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return a held reference to the default SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_allocsp_default
parameter_list|(
name|void
parameter_list|)
block|{
name|key_addref
argument_list|(
name|V_def_policy
argument_list|)
expr_stmt|;
return|return
operator|(
name|V_def_policy
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipsec_invalidate_cache
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|u_int
name|dir
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|flags
operator|&
name|INP_INBOUND_POLICY
condition|)
return|return;
name|sp
operator|=
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
expr_stmt|;
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|flags
operator|&
name|INP_OUTBOUND_POLICY
condition|)
return|return;
name|sp
operator|=
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
expr_stmt|;
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/* release extra reference */
block|}
end_function

begin_function
specifier|static
name|void
name|ipsec_cachepolicy
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|u_int
name|dir
parameter_list|)
block|{
name|uint32_t
name|genid
decl_stmt|;
name|int
name|downgrade
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|)
block|{
comment|/* Do we have configured PCB policy? */
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|flags
operator|&
name|INP_OUTBOUND_POLICY
condition|)
return|return;
comment|/* Another thread has already set cached policy */
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
operator|!=
name|NULL
condition|)
return|return;
comment|/* 		 * Do not cache OUTBOUND policy if PCB isn't connected, 		 * i.e. foreign address is INADDR_ANY/UNSPECIFIED. 		 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|!=
literal|0
operator|&&
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|!=
literal|0
operator|&&
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
condition|)
return|return;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Do we have configured PCB policy? */
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|flags
operator|&
name|INP_INBOUND_POLICY
condition|)
return|return;
comment|/* Another thread has already set cached policy */
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
operator|!=
name|NULL
condition|)
return|return;
comment|/* 		 * Do not cache INBOUND policy for listen socket, 		 * that is bound to INADDR_ANY/UNSPECIFIED address. 		 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|!=
literal|0
operator|&&
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
operator|)
operator|!=
literal|0
operator|&&
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
condition|)
return|return;
endif|#
directive|endif
block|}
name|downgrade
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INP_WLOCKED
argument_list|(
name|inp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|downgrade
operator|=
name|INP_TRY_UPGRADE
argument_list|(
name|inp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|)
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
operator|=
name|sp
expr_stmt|;
else|else
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
operator|=
name|sp
expr_stmt|;
comment|/* 	 * SP is already referenced by the lookup code. 	 * We take extra reference here to avoid race in the 	 * ipsec_getpcbpolicy() function - SP will not be freed in the 	 * time between we take SP pointer from the cache and key_addref() 	 * call. 	 */
name|key_addref
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|genid
operator|=
name|key_getspgen
argument_list|()
expr_stmt|;
if|if
condition|(
name|genid
operator|!=
name|inp
operator|->
name|inp_sp
operator|->
name|genid
condition|)
block|{
name|ipsec_invalidate_cache
argument_list|(
name|inp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_sp
operator|->
name|genid
operator|=
name|genid
expr_stmt|;
block|}
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: PCB(%p): cached %s SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|inp
argument_list|,
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|?
literal|"OUTBOUND"
else|:
literal|"INBOUND"
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|downgrade
operator|!=
literal|0
condition|)
name|INP_DOWNGRADE
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|ipsec_checkpolicy
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
comment|/* Save found OUTBOUND policy into PCB SP cache. */
if|if
condition|(
name|inp
operator|!=
name|NULL
operator|&&
name|inp
operator|->
name|inp_sp
operator|!=
name|NULL
operator|&&
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
operator|==
name|NULL
condition|)
name|ipsec_cachepolicy
argument_list|(
name|inp
argument_list|,
name|sp
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|policy
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"%s: invalid policy %u\n"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|policy
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IPSEC_POLICY_DISCARD
case|:
operator|*
name|error
operator|=
operator|-
name|EINVAL
expr_stmt|;
comment|/* Packet is discarded by caller. */
comment|/* FALLTHROUGH */
case|case
name|IPSEC_POLICY_BYPASS
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
comment|/* NB: force NULL result. */
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
comment|/* XXXAE: handle LARVAL SP */
break|break;
block|}
name|KEYDBG
argument_list|(
name|IPSEC_DUMP
argument_list|,
name|printf
argument_list|(
literal|"%s: get SP(%p), error %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
operator|*
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|ipsec_getpcbpolicy
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|u_int
name|dir
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|downgrade
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
operator|||
name|inp
operator|->
name|inp_sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|inp
operator|->
name|inp_sp
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|IPSEC_DIR_OUTBOUND
condition|)
block|{
name|sp
operator|=
name|inp
operator|->
name|inp_sp
operator|->
name|sp_out
expr_stmt|;
name|flags
operator|&=
name|INP_OUTBOUND_POLICY
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
expr_stmt|;
name|flags
operator|&=
name|INP_INBOUND_POLICY
expr_stmt|;
block|}
comment|/* 	 * Check flags. If we have PCB SP, just return it. 	 * Otherwise we need to check that cached SP entry isn't stale. 	 */
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|inp
operator|->
name|inp_sp
operator|->
name|genid
operator|!=
name|key_getspgen
argument_list|()
condition|)
block|{
comment|/* Invalidate the cache. */
name|downgrade
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INP_WLOCKED
argument_list|(
name|inp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|downgrade
operator|=
name|INP_TRY_UPGRADE
argument_list|(
name|inp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ipsec_invalidate_cache
argument_list|(
name|inp
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|)
expr_stmt|;
name|ipsec_invalidate_cache
argument_list|(
name|inp
argument_list|,
name|IPSEC_DIR_INBOUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|downgrade
operator|!=
literal|0
condition|)
name|INP_DOWNGRADE
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: PCB(%p): cache hit SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|inp
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return referenced cached policy */
block|}
name|key_addref
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|ipsec4_get_ulp
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|uint8_t
name|nxt
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* Sanity check. */
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
literal|"packet too short"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|off
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|nxt
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip
name|ih
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|.
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|off
operator|=
name|ih
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|nxt
operator|=
name|ih
operator|.
name|ip_p
expr_stmt|;
block|}
while|while
condition|(
name|off
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|struct
name|ip6_ext
name|ip6e
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|udphdr
name|uh
decl_stmt|;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
if|if
condition|(
operator|!
name|needport
condition|)
goto|goto
name|done_proto
goto|;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|done
goto|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|th
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|th
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|th
operator|.
name|th_sport
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|th
operator|.
name|th_dport
expr_stmt|;
return|return;
case|case
name|IPPROTO_UDP
case|:
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
if|if
condition|(
operator|!
name|needport
condition|)
goto|goto
name|done_proto
goto|;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|done
goto|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|uh
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|uh
operator|.
name|uh_sport
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|uh
operator|.
name|uh_dport
expr_stmt|;
return|return;
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|done
goto|;
comment|/* XXX Sigh, this works but is totally bogus. */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6e
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip6e
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
name|ip6e
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|nxt
operator|=
name|ip6e
operator|.
name|ip6e_nxt
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
default|default:
comment|/* XXX Intermediate headers??? */
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
goto|goto
name|done_proto
goto|;
block|}
block|}
name|done
label|:
name|spidx
operator|->
name|ul_proto
operator|=
name|IPSEC_ULPROTO_ANY
expr_stmt|;
name|done_proto
label|:
name|spidx
operator|->
name|src
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|IPSEC_PORT_ANY
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|IPSEC_PORT_ANY
expr_stmt|;
name|KEYDBG
argument_list|(
argument|IPSEC_DUMP
argument_list|,
argument|printf(
literal|"%s: "
argument|, __func__); kdebug_secpolicyindex(spidx, NULL)
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipsec4_setspidx_ipaddr
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|ipsec4_setsockaddrs
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
operator|->
name|src
argument_list|,
operator|&
name|spidx
operator|->
name|dst
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|prefs
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|spidx
operator|->
name|prefd
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|ipsec4_getpolicy
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|u_int
name|dir
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|ipsec_getpcbpolicy
argument_list|(
name|inp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
name|key_havesp
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* Make an index to look for a policy. */
name|ipsec4_setspidx_ipaddr
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
name|ipsec4_get_ulp
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
argument_list|,
name|needport
argument_list|)
expr_stmt|;
name|spidx
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|sp
operator|=
name|key_allocsp
argument_list|(
operator|&
name|spidx
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
comment|/* No SP found, use system default. */
name|sp
operator|=
name|key_allocsp_default
argument_list|()
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check security policy for *OUTBOUND* IPv4 packet.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|ipsec4_checkpolicy
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|ipsec4_getpolicy
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
name|needport
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|sp
operator|=
name|ipsec_checkpolicy
argument_list|(
name|sp
argument_list|,
name|inp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* No IPsec required: BYPASS or NONE */
break|break;
case|case
operator|-
name|EINVAL
case|:
name|IPSECSTAT_INC
argument_list|(
name|ips_out_polvio
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IPSECSTAT_INC
argument_list|(
name|ips_out_inval
argument_list|)
expr_stmt|;
block|}
block|}
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: using SP(%p), error %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
operator|*
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check IPv4 packet against *INBOUND* security policy.  * This function is called from tcp_input(), udp_input(),  * rip_input() and sctp_input().  */
end_comment

begin_function
name|int
name|ipsec4_in_reject
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|sp
operator|=
name|ipsec4_getpolicy
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|IPSEC_DIR_INBOUND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ipsec_in_reject
argument_list|(
name|sp
argument_list|,
name|inp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|IPSECSTAT_INC
argument_list|(
name|ips_in_polvio
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPSEC_CAP() method implementation for IPv4.  */
end_comment

begin_function
name|int
name|ipsec4_capability
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|cap
parameter_list|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|IPSEC_CAP_BYPASS_FILTER
case|:
comment|/* 		 * Bypass packet filtering for packets previously handled 		 * by IPsec. 		 */
if|if
condition|(
operator|!
name|V_ip4_filtertunnel
operator|&&
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPSEC_CAP_OPERABLE
case|:
comment|/* Do we have active security policies? */
if|if
condition|(
name|key_havesp
argument_list|(
name|IPSEC_DIR_INBOUND
argument_list|)
operator|!=
literal|0
operator|||
name|key_havesp
argument_list|(
name|IPSEC_DIR_OUTBOUND
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|ipsec6_get_ulp
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|udphdr
name|uh
decl_stmt|;
name|struct
name|icmp6_hdr
name|ih
decl_stmt|;
name|int
name|off
decl_stmt|,
name|nxt
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
operator|(
literal|"packet too short"
operator|)
argument_list|)
expr_stmt|;
comment|/* Set default. */
name|spidx
operator|->
name|ul_proto
operator|=
name|IPSEC_ULPROTO_ANY
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|IPSEC_PORT_ANY
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|IPSEC_PORT_ANY
expr_stmt|;
name|nxt
operator|=
operator|-
literal|1
expr_stmt|;
name|off
operator|=
name|ip6_lasthdr
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|IPPROTO_IPV6
argument_list|,
operator|&
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|off
condition|)
return|return;
switch|switch
condition|(
name|nxt
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
if|if
condition|(
operator|!
name|needport
condition|)
break|break;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
break|break;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|th
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|th
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|th
operator|.
name|th_sport
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|th
operator|.
name|th_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
if|if
condition|(
operator|!
name|needport
condition|)
break|break;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
break|break;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|uh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|uh
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|uh
operator|.
name|uh_sport
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|uh
operator|.
name|uh_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
if|if
condition|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
break|break;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ih
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ih
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|src
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ih
operator|.
name|icmp6_type
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|dst
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ih
operator|.
name|icmp6_code
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX Intermediate headers??? */
name|spidx
operator|->
name|ul_proto
operator|=
name|nxt
expr_stmt|;
break|break;
block|}
name|KEYDBG
argument_list|(
argument|IPSEC_DUMP
argument_list|,
argument|printf(
literal|"%s: "
argument|, __func__); kdebug_secpolicyindex(spidx, NULL)
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipsec6_setspidx_ipaddr
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicyindex
modifier|*
name|spidx
parameter_list|)
block|{
name|ipsec6_setsockaddrs
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
operator|->
name|src
argument_list|,
operator|&
name|spidx
operator|->
name|dst
argument_list|)
expr_stmt|;
name|spidx
operator|->
name|prefs
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|spidx
operator|->
name|prefd
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|ipsec6_getpolicy
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|u_int
name|dir
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|ipsec_getpcbpolicy
argument_list|(
name|inp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
name|key_havesp
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* Make an index to look for a policy. */
name|ipsec6_setspidx_ipaddr
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
name|ipsec6_get_ulp
argument_list|(
name|m
argument_list|,
operator|&
name|spidx
argument_list|,
name|needport
argument_list|)
expr_stmt|;
name|spidx
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|sp
operator|=
name|key_allocsp
argument_list|(
operator|&
name|spidx
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
comment|/* No SP found, use system default. */
name|sp
operator|=
name|key_allocsp_default
argument_list|()
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check security policy for *OUTBOUND* IPv6 packet.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|ipsec6_checkpolicy
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|int
name|needport
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|ipsec6_getpolicy
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
name|needport
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|sp
operator|=
name|ipsec_checkpolicy
argument_list|(
name|sp
argument_list|,
name|inp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* No IPsec required: BYPASS or NONE */
break|break;
case|case
operator|-
name|EINVAL
case|:
name|IPSEC6STAT_INC
argument_list|(
name|ips_out_polvio
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IPSEC6STAT_INC
argument_list|(
name|ips_out_inval
argument_list|)
expr_stmt|;
block|}
block|}
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: using SP(%p), error %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|,
operator|*
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check IPv6 packet against inbound security policy.  * This function is called from tcp6_input(), udp6_input(),  * rip6_input() and sctp_input().  */
end_comment

begin_function
name|int
name|ipsec6_in_reject
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|sp
operator|=
name|ipsec6_getpolicy
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|IPSEC_DIR_INBOUND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ipsec_in_reject
argument_list|(
name|sp
argument_list|,
name|inp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|IPSEC6STAT_INC
argument_list|(
name|ips_in_polvio
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IPSEC_CAP() method implementation for IPv6.  */
end_comment

begin_function
name|int
name|ipsec6_capability
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|cap
parameter_list|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|IPSEC_CAP_BYPASS_FILTER
case|:
comment|/* 		 * Bypass packet filtering for packets previously handled 		 * by IPsec. 		 */
if|if
condition|(
operator|!
name|V_ip6_filtertunnel
operator|&&
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IPSEC_CAP_OPERABLE
case|:
comment|/* Do we have active security policies? */
if|if
condition|(
name|key_havesp
argument_list|(
name|IPSEC_DIR_INBOUND
argument_list|)
operator|!=
literal|0
operator|||
name|key_havesp
argument_list|(
name|IPSEC_DIR_OUTBOUND
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
name|int
name|ipsec_run_hhooks
parameter_list|(
name|struct
name|ipsec_ctx_data
modifier|*
name|ctx
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|idx
operator|=
name|HHOOK_IPSEC_INET
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|idx
operator|=
name|HHOOK_IPSEC_INET6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EPFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|HHOOK_TYPE_IPSEC_IN
condition|)
name|HHOOKS_RUN_IF
argument_list|(
name|V_ipsec_hhh_in
index|[
name|idx
index|]
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|HHOOKS_RUN_IF
argument_list|(
name|V_ipsec_hhh_out
index|[
name|idx
index|]
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ctx
operator|->
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return current level.  * Either IPSEC_LEVEL_USE or IPSEC_LEVEL_REQUIRE are always returned.  */
end_comment

begin_function
name|u_int
name|ipsec_get_reqlevel
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|u_int
name|idx
parameter_list|)
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|u_int
name|esp_trans_deflev
decl_stmt|,
name|esp_net_deflev
decl_stmt|;
name|u_int
name|ah_trans_deflev
decl_stmt|,
name|ah_net_deflev
decl_stmt|;
name|u_int
name|level
init|=
literal|0
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|idx
operator|<
name|sp
operator|->
name|tcount
argument_list|,
operator|(
literal|"Wrong IPsec request index %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Note that we have ipseclog() expanded here - code sync issue. */
define|#
directive|define
name|IPSEC_CHECK_DEFAULT
parameter_list|(
name|lev
parameter_list|)
define|\
value|(((lev) != IPSEC_LEVEL_USE&& (lev) != IPSEC_LEVEL_REQUIRE&&	\ 	  (lev) != IPSEC_LEVEL_UNIQUE)					\ 		? (V_ipsec_debug  ?					\ 		log(LOG_INFO, "fixed system default level " #lev ":%d->%d\n",\ 		(lev), IPSEC_LEVEL_REQUIRE) : 0),			\ 		(lev) = IPSEC_LEVEL_REQUIRE, (lev) : (lev))
comment|/* 	 * IPsec VTI uses unique security policy with fake spidx filled 	 * with zeroes. Just return IPSEC_LEVEL_REQUIRE instead of doing 	 * full level lookup for such policies. 	 */
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_IFNET
condition|)
block|{
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|level
operator|==
name|IPSEC_LEVEL_UNIQUE
argument_list|,
operator|(
literal|"Wrong IPsec request level %d"
operator|,
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|level
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPSEC_LEVEL_REQUIRE
operator|)
return|;
block|}
comment|/* Set default level. */
switch|switch
condition|(
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|esp_trans_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip4_esp_trans_deflev
argument_list|)
expr_stmt|;
name|esp_net_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip4_esp_net_deflev
argument_list|)
expr_stmt|;
name|ah_trans_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip4_ah_trans_deflev
argument_list|)
expr_stmt|;
name|ah_net_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip4_ah_net_deflev
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|esp_trans_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip6_esp_trans_deflev
argument_list|)
expr_stmt|;
name|esp_net_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip6_esp_net_deflev
argument_list|)
expr_stmt|;
name|ah_trans_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip6_ah_trans_deflev
argument_list|)
expr_stmt|;
name|ah_net_deflev
operator|=
name|IPSEC_CHECK_DEFAULT
argument_list|(
name|V_ip6_ah_net_deflev
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|panic
argument_list|(
literal|"%s: unknown af %u"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|IPSEC_CHECK_DEFAULT
name|isr
operator|=
name|sp
operator|->
name|req
index|[
name|idx
index|]
expr_stmt|;
comment|/* Set level. */
switch|switch
condition|(
name|isr
operator|->
name|level
condition|)
block|{
case|case
name|IPSEC_LEVEL_DEFAULT
case|:
switch|switch
condition|(
name|isr
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
if|if
condition|(
name|isr
operator|->
name|saidx
operator|.
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
name|level
operator|=
name|esp_net_deflev
expr_stmt|;
else|else
name|level
operator|=
name|esp_trans_deflev
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
name|isr
operator|->
name|saidx
operator|.
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
name|level
operator|=
name|ah_net_deflev
expr_stmt|;
else|else
name|level
operator|=
name|ah_trans_deflev
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
comment|/* 			 * We don't really care, as IPcomp document says that 			 * we shouldn't compress small packets. 			 */
name|level
operator|=
name|IPSEC_LEVEL_USE
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Illegal protocol defined %u\n"
argument_list|,
name|__func__
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|proto
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPSEC_LEVEL_USE
case|:
case|case
name|IPSEC_LEVEL_REQUIRE
case|:
name|level
operator|=
name|isr
operator|->
name|level
expr_stmt|;
break|break;
case|case
name|IPSEC_LEVEL_UNIQUE
case|:
name|level
operator|=
name|IPSEC_LEVEL_REQUIRE
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Illegal IPsec level %u\n"
argument_list|,
name|__func__
argument_list|,
name|isr
operator|->
name|level
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|level
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipsec_check_history
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|u_int
name|idx
parameter_list|)
block|{
name|struct
name|xform_history
modifier|*
name|xh
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|__DECONST
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|,
name|m
argument_list|)
argument_list|,
name|PACKET_TAG_IPSEC_IN_DONE
argument_list|,
name|mtag
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xh
operator|=
operator|(
expr|struct
name|xform_history
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|KEYDBG
argument_list|(
argument|IPSEC_DATA
argument_list|,
argument|char buf[IPSEC_ADDRSTRLEN]; 		    printf(
literal|"%s: mode %s proto %u dst %s\n"
argument|, __func__, 			kdebug_secasindex_mode(xh->mode), xh->proto, 			ipsec_address(&xh->dst, buf, sizeof(buf)))
argument_list|)
empty_stmt|;
if|if
condition|(
name|xh
operator|->
name|proto
operator|!=
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
comment|/* If SA had IPSEC_MODE_ANY, consider this as match. */
if|if
condition|(
name|xh
operator|->
name|mode
operator|!=
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|saidx
operator|.
name|mode
operator|&&
name|xh
operator|->
name|mode
operator|!=
name|IPSEC_MODE_ANY
condition|)
continue|continue;
comment|/* 		 * For transport mode IPsec request doesn't contain 		 * addresses. We need to use address from spidx. 		 */
if|if
condition|(
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|saidx
operator|.
name|mode
operator|==
name|IPSEC_MODE_TRANSPORT
condition|)
block|{
if|if
condition|(
name|key_sockaddrcmp_withmask
argument_list|(
operator|&
name|xh
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|&
name|xh
operator|->
name|dst
operator|.
name|sa
argument_list|,
operator|&
name|sp
operator|->
name|req
index|[
name|idx
index|]
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* matched */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check security policy requirements against the actual  * packet contents.  Return one if the packet should be  * reject as "invalid"; otherwiser return zero to have the  * packet treated as "valid".  *  * OUT:  *	0: valid  *	1: invalid  */
end_comment

begin_function
specifier|static
name|int
name|ipsec_in_reject
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: PCB(%p): using SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|inp
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
operator|&&
name|inp
operator|->
name|inp_sp
operator|!=
name|NULL
operator|&&
name|inp
operator|->
name|inp_sp
operator|->
name|sp_in
operator|==
name|NULL
condition|)
name|ipsec_cachepolicy
argument_list|(
name|inp
argument_list|,
name|sp
argument_list|,
name|IPSEC_DIR_INBOUND
argument_list|)
expr_stmt|;
comment|/* Check policy. */
switch|switch
condition|(
name|sp
operator|->
name|policy
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|IPSEC_POLICY_BYPASS
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
argument_list|,
operator|(
literal|"invalid policy %u"
operator|,
name|sp
operator|->
name|policy
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * ipsec[46]_common_input_cb after each transform adds 	 * PACKET_TAG_IPSEC_IN_DONE mbuf tag. It contains SPI, proto, mode 	 * and destination address from saidx. We can compare info from 	 * these tags with requirements in SP. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|tcount
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Do not check IPcomp, since IPcomp document 		 * says that we shouldn't compress small packets. 		 * IPComp policy should always be treated as being 		 * in "use" level. 		 */
if|if
condition|(
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|proto
operator|==
name|IPPROTO_IPCOMP
operator|||
name|ipsec_get_reqlevel
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|!=
name|IPSEC_LEVEL_REQUIRE
condition|)
continue|continue;
if|if
condition|(
name|V_check_policy_history
operator|!=
literal|0
operator|&&
name|ipsec_check_history
argument_list|(
name|m
argument_list|,
name|sp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
switch|switch
condition|(
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_DECRYPTED
operator|)
operator|==
literal|0
condition|)
block|{
name|KEYDBG
argument_list|(
name|IPSEC_DUMP
argument_list|,
name|printf
argument_list|(
literal|"%s: ESP m_flags:%x\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_AUTHIPHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|KEYDBG
argument_list|(
name|IPSEC_DUMP
argument_list|,
name|printf
argument_list|(
literal|"%s: AH m_flags:%x\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Valid. */
block|}
end_function

begin_comment
comment|/*  * Compute the byte size to be occupied by IPsec header.  * In case it is tunnelled, it includes the size of outer IP header.  */
end_comment

begin_function
specifier|static
name|size_t
name|ipsec_hdrsiz_internal
parameter_list|(
name|struct
name|secpolicy
modifier|*
name|sp
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: using SP(%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secpolicy
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|policy
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IPSEC_ASSERT
argument_list|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
argument_list|,
operator|(
literal|"invalid policy %u"
operator|,
name|sp
operator|->
name|policy
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: for each transform we need to lookup suitable SA 	 * and use info from SA to calculate headers size. 	 * XXX: for NAT-T we need to cosider UDP header size. 	 */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|tcount
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
name|size
operator|+=
name|esp_hdrsiz
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|size
operator|+=
name|ah_hdrsiz
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ipcomp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|mode
operator|==
name|IPSEC_MODE_TUNNEL
condition|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"%s: unknown AF %d in "
literal|"IPsec tunnel SA\n"
operator|,
name|__func__
operator|,
name|sp
operator|->
name|req
index|[
name|i
index|]
operator|->
name|saidx
operator|.
name|dst
operator|.
name|sa
operator|.
name|sa_family
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute ESP/AH header size for protocols with PCB, including  * outer IP header. Currently only tcp_output() uses it.  */
end_comment

begin_function
name|size_t
name|ipsec_hdrsiz_inpcb
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sp
operator|=
name|ipsec_getpcbpolicy
argument_list|(
name|inp
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
name|key_havesp
argument_list|(
name|IPSEC_DIR_OUTBOUND
argument_list|)
condition|)
block|{
name|ipsec_setspidx_inpcb
argument_list|(
name|inp
argument_list|,
operator|&
name|spidx
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|)
expr_stmt|;
name|sp
operator|=
name|key_allocsp
argument_list|(
operator|&
name|spidx
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|key_allocsp_default
argument_list|()
expr_stmt|;
name|sz
operator|=
name|ipsec_hdrsiz_internal
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the variable replay window.  * ipsec_chkreplay() performs replay check before ICV verification.  * ipsec_updatereplay() updates replay bitmap.  This must be called after  * ICV verification (it also performs replay check, which is usually done  * beforehand).  * 0 (zero) is returned if packet disallowed, 1 if packet permitted.  *  * Based on RFC 6479. Blocks are 32 bits unsigned integers  */
end_comment

begin_define
define|#
directive|define
name|IPSEC_BITMAP_INDEX_MASK
parameter_list|(
name|w
parameter_list|)
value|(w - 1)
end_define

begin_define
define|#
directive|define
name|IPSEC_REDUNDANT_BIT_SHIFTS
value|5
end_define

begin_define
define|#
directive|define
name|IPSEC_REDUNDANT_BITS
value|(1<< IPSEC_REDUNDANT_BIT_SHIFTS)
end_define

begin_define
define|#
directive|define
name|IPSEC_BITMAP_LOC_MASK
value|(IPSEC_REDUNDANT_BITS - 1)
end_define

begin_function
name|int
name|ipsec_chkreplay
parameter_list|(
name|uint32_t
name|seq
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
specifier|const
name|struct
name|secreplay
modifier|*
name|replay
decl_stmt|;
name|uint32_t
name|wsizeb
decl_stmt|;
comment|/* Constant: window size. */
name|int
name|index
decl_stmt|,
name|bit_location
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null replay state"
operator|)
argument_list|)
expr_stmt|;
name|replay
operator|=
name|sav
operator|->
name|replay
expr_stmt|;
comment|/* No need to check replay if disabled. */
if|if
condition|(
name|replay
operator|->
name|wsize
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Constant. */
name|wsizeb
operator|=
name|replay
operator|->
name|wsize
operator|<<
literal|3
expr_stmt|;
comment|/* Sequence number of 0 is invalid. */
if|if
condition|(
name|seq
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* First time is always okay. */
if|if
condition|(
name|replay
operator|->
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Larger sequences are okay. */
if|if
condition|(
name|seq
operator|>
name|replay
operator|->
name|lastseq
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Over range to check, i.e. too old or wrapped. */
if|if
condition|(
name|replay
operator|->
name|lastseq
operator|-
name|seq
operator|>=
name|wsizeb
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The sequence is inside the sliding window 	 * now check the bit in the bitmap 	 * bit location only depends on the sequence number 	 */
name|bit_location
operator|=
name|seq
operator|&
name|IPSEC_BITMAP_LOC_MASK
expr_stmt|;
name|index
operator|=
operator|(
name|seq
operator|>>
name|IPSEC_REDUNDANT_BIT_SHIFTS
operator|)
operator|&
name|IPSEC_BITMAP_INDEX_MASK
argument_list|(
name|replay
operator|->
name|bitmap_size
argument_list|)
expr_stmt|;
comment|/* This packet already seen? */
if|if
condition|(
operator|(
name|replay
operator|->
name|bitmap
operator|)
index|[
name|index
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit_location
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check replay counter whether to update or not.  * OUT:	0:	OK  *	1:	NG  */
end_comment

begin_function
name|int
name|ipsec_updatereplay
parameter_list|(
name|uint32_t
name|seq
parameter_list|,
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|secreplay
modifier|*
name|replay
decl_stmt|;
name|uint32_t
name|wsizeb
decl_stmt|;
comment|/* Constant: window size. */
name|int
name|diff
decl_stmt|,
name|index
decl_stmt|,
name|bit_location
decl_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null SA"
operator|)
argument_list|)
expr_stmt|;
name|IPSEC_ASSERT
argument_list|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null replay state"
operator|)
argument_list|)
expr_stmt|;
name|replay
operator|=
name|sav
operator|->
name|replay
expr_stmt|;
if|if
condition|(
name|replay
operator|->
name|wsize
operator|==
literal|0
condition|)
goto|goto
name|ok
goto|;
comment|/* No need to check replay. */
comment|/* Constant. */
name|wsizeb
operator|=
name|replay
operator|->
name|wsize
operator|<<
literal|3
expr_stmt|;
comment|/* Sequence number of 0 is invalid. */
if|if
condition|(
name|seq
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* The packet is too old, no need to update */
if|if
condition|(
name|wsizeb
operator|+
name|seq
operator|<
name|replay
operator|->
name|lastseq
condition|)
goto|goto
name|ok
goto|;
comment|/* Now update the bit */
name|index
operator|=
operator|(
name|seq
operator|>>
name|IPSEC_REDUNDANT_BIT_SHIFTS
operator|)
expr_stmt|;
comment|/* First check if the sequence number is in the range */
if|if
condition|(
name|seq
operator|>
name|replay
operator|->
name|lastseq
condition|)
block|{
name|int
name|id
decl_stmt|;
name|int
name|index_cur
init|=
name|replay
operator|->
name|lastseq
operator|>>
name|IPSEC_REDUNDANT_BIT_SHIFTS
decl_stmt|;
name|diff
operator|=
name|index
operator|-
name|index_cur
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|replay
operator|->
name|bitmap_size
condition|)
block|{
comment|/* something unusual in this case */
name|diff
operator|=
name|replay
operator|->
name|bitmap_size
expr_stmt|;
block|}
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|diff
condition|;
operator|++
name|id
control|)
block|{
name|replay
operator|->
name|bitmap
index|[
operator|(
name|id
operator|+
name|index_cur
operator|+
literal|1
operator|)
operator|&
name|IPSEC_BITMAP_INDEX_MASK
argument_list|(
name|replay
operator|->
name|bitmap_size
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|replay
operator|->
name|lastseq
operator|=
name|seq
expr_stmt|;
block|}
name|index
operator|&=
name|IPSEC_BITMAP_INDEX_MASK
argument_list|(
name|replay
operator|->
name|bitmap_size
argument_list|)
expr_stmt|;
name|bit_location
operator|=
name|seq
operator|&
name|IPSEC_BITMAP_LOC_MASK
expr_stmt|;
comment|/* this packet has already been received */
if|if
condition|(
name|replay
operator|->
name|bitmap
index|[
name|index
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit_location
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|replay
operator|->
name|bitmap
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit_location
operator|)
expr_stmt|;
name|ok
label|:
if|if
condition|(
name|replay
operator|->
name|count
operator|==
operator|~
literal|0
condition|)
block|{
comment|/* Set overflow flag. */
name|replay
operator|->
name|overflow
operator|++
expr_stmt|;
comment|/* Don't increment, no more packets accepted. */
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_CYCSEQ
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|==
name|IPPROTO_AH
condition|)
name|AHSTAT_INC
argument_list|(
name|ahs_wrap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|==
name|IPPROTO_ESP
condition|)
name|ESPSTAT_INC
argument_list|(
name|esps_wrap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ipseclog
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"%s: replay counter made %d cycle. %s\n"
operator|,
name|__func__
operator|,
name|replay
operator|->
name|overflow
operator|,
name|ipsec_sa2str
argument_list|(
name|sav
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ipsec_updateid
parameter_list|(
name|struct
name|secasvar
modifier|*
name|sav
parameter_list|,
name|uint64_t
modifier|*
name|new
parameter_list|,
name|uint64_t
modifier|*
name|old
parameter_list|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
comment|/* 	 * tdb_cryptoid is initialized by xform_init(). 	 * Then it can be changed only when some crypto error occurred or 	 * when SA is deleted. We stored used cryptoid in the xform_data 	 * structure. In case when crypto error occurred and crypto 	 * subsystem has reinited the session, it returns new cryptoid 	 * and EAGAIN error code. 	 * 	 * This function will be called when we got EAGAIN from crypto 	 * subsystem. 	 * *new is cryptoid that was returned by crypto subsystem in 	 * the crp_sid. 	 * *old is the original cryptoid that we stored in xform_data. 	 * 	 * For first failed request *old == sav->tdb_cryptoid, then 	 * we update sav->tdb_cryptoid and redo crypto_dispatch(). 	 * For next failed request *old != sav->tdb_cryptoid, then 	 * we store cryptoid from first request into the *new variable 	 * and crp_sid from this second session will be returned via 	 * *old pointer, so caller can release second session. 	 * 	 * XXXAE: check this more carefully. 	 */
name|KEYDBG
argument_list|(
name|IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"%s: SA(%p) moves cryptoid %jd -> %jd\n"
argument_list|,
name|__func__
argument_list|,
name|sav
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|*
name|old
argument_list|)
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|KEYDBG
argument_list|(
name|IPSEC_DATA
argument_list|,
name|kdebug_secasv
argument_list|(
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|SECASVAR_LOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|tdb_cryptoid
operator|!=
operator|*
name|old
condition|)
block|{
comment|/* cryptoid was already updated */
name|tmp
operator|=
operator|*
name|new
expr_stmt|;
operator|*
name|new
operator|=
name|sav
operator|->
name|tdb_cryptoid
expr_stmt|;
operator|*
name|old
operator|=
name|tmp
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sav
operator|->
name|tdb_cryptoid
operator|=
operator|*
name|new
expr_stmt|;
name|SECASVAR_UNLOCK
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ipsec_initialized
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|V_def_policy
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_policy_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|V_def_policy
operator|=
name|key_newsp
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_def_policy
operator|!=
name|NULL
condition|)
block|{
name|V_def_policy
operator|->
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
comment|/* Force INPCB SP cache invalidation */
name|key_bumpspgen
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: failed to initialize default policy\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_policy_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|V_def_policy
operator|!=
name|NULL
condition|)
block|{
name|key_freesp
argument_list|(
operator|&
name|V_def_policy
argument_list|)
expr_stmt|;
name|key_bumpspgen
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|def_policy_init
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|def_policy_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|def_policy_uninit
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|def_policy_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

