begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ntfs_vfsops.c,v 1.23 1999/11/15 19:38:14 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define NTFS_DEBUG 1*/
end_comment

begin_include
include|#
directive|include
file|<ntfs/ntfs.h>
end_include

begin_include
include|#
directive|include
file|<ntfs/ntfs_inode.h>
end_include

begin_include
include|#
directive|include
file|<ntfs/ntfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<ntfs/ntfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<ntfs/ntfs_ihash.h>
end_include

begin_include
include|#
directive|include
file|<ntfs/ntfsmount.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSMNT
argument_list|,
literal|"NTFS mount"
argument_list|,
literal|"NTFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSNTNODE
argument_list|,
literal|"NTFS ntnode"
argument_list|,
literal|"NTFS ntnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSFNODE
argument_list|,
literal|"NTFS fnode"
argument_list|,
literal|"NTFS fnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSDIR
argument_list|,
literal|"NTFS dir"
argument_list|,
literal|"NTFS dir buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ntfs_root
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_statfs
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|statfs
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_unmount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_vget
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
name|mp
operator|,
name|ino_t
name|ino
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_mountfs
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|ntfs_args
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_vptofh
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|fid
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_fhtovp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|fid
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|ntfs_quotactl
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
name|uid_t
operator|,
name|caddr_t
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_start
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_sync
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|ntfs_mount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|char
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|nameidata
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_init
name|__P
argument_list|(
operator|(
expr|struct
name|vfsconf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_checkexp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|int
name|ntfs_mount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|void
operator|*
operator|,
expr|struct
name|nameidata
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ntfs_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_mountroot
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_sysctl
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|,
name|u_int
operator|,
name|void
operator|*
operator|,
name|size_t
operator|*
operator|,
name|void
operator|*
operator|,
name|size_t
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntfs_checkexp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Verify a remote client has export rights and return these rights via.  * exflagsp and credanonp.  */
end_comment

begin_function
specifier|static
name|int
name|ntfs_checkexp
parameter_list|(
name|mp
parameter_list|,
name|nam
parameter_list|,
name|exflagsp
parameter_list|,
name|credanonp
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|int
modifier|*
name|exflagsp
decl_stmt|;
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
decl_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
name|int
modifier|*
name|exflagsp
decl_stmt|;
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|struct
name|netcred
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|ntfsmount
modifier|*
name|ntm
init|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
comment|/* 	 * Get the export permission structure for this<mp, client> tuple. 	 */
name|np
operator|=
name|vfs_export_lookup
argument_list|(
name|mp
argument_list|,
operator|&
name|ntm
operator|->
name|ntm_export
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
operator|*
name|exflagsp
operator|=
name|np
operator|->
name|netc_exflags
expr_stmt|;
operator|*
name|credanonp
operator|=
operator|&
name|np
operator|->
name|netc_anon
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|ntfs_sysctl
parameter_list|(
name|name
parameter_list|,
name|namelen
parameter_list|,
name|oldp
parameter_list|,
name|oldlenp
parameter_list|,
name|newp
parameter_list|,
name|newlen
parameter_list|,
name|p
parameter_list|)
name|int
modifier|*
name|name
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|void
modifier|*
name|oldp
decl_stmt|;
name|size_t
modifier|*
name|oldlenp
decl_stmt|;
name|void
modifier|*
name|newp
decl_stmt|;
name|size_t
name|newlen
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_mountroot
parameter_list|()
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|extern
name|struct
name|vnode
modifier|*
name|rootvp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|error
decl_stmt|;
name|struct
name|ntfs_args
name|args
decl_stmt|;
if|if
condition|(
name|root_device
operator|->
name|dv_class
operator|!=
name|DV_DISK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Get vnodes for rootdev. 	 */
if|if
condition|(
name|bdevvp
argument_list|(
name|rootdev
argument_list|,
operator|&
name|rootvp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ntfs_mountroot: can't setup rootvp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vfs_rootmountalloc
argument_list|(
name|MOUNT_NTFS
argument_list|,
literal|"root_device"
argument_list|,
operator|&
name|mp
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|rootvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|args
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|uid
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|gid
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|mode
operator|=
literal|0777
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ntfs_mountfs
argument_list|(
name|rootvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mp
operator|->
name|mnt_op
operator|->
name|vfs_refcount
operator|--
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|rootvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|simple_lock
argument_list|(
operator|&
name|mountlist_slock
argument_list|)
expr_stmt|;
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|mountlist_slock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ntfs_statfs
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntfs_init
parameter_list|()
block|{
name|ntfs_nthashinit
argument_list|()
expr_stmt|;
name|ntfs_toupper_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function
specifier|static
name|int
name|ntfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vcp
parameter_list|)
block|{
name|ntfs_nthashinit
argument_list|()
expr_stmt|;
name|ntfs_toupper_init
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD */
end_comment

begin_function
specifier|static
name|int
name|ntfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|data
parameter_list|,
else|#
directive|else
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
endif|#
directive|endif
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|ntfs_args
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * Use NULL path to flag a root mount 	 */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* 		 *** 		 * Mounting root file system 		 *** 		 */
comment|/* Get vnode for root device*/
if|if
condition|(
name|bdevvp
argument_list|(
name|rootdev
argument_list|,
operator|&
name|rootvp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ffs_mountroot: can't setup bdevvp for root"
argument_list|)
expr_stmt|;
comment|/* 		 * FS specific handling 		 */
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_RDONLY
expr_stmt|;
comment|/* XXX globally applicable?*/
comment|/* 		 * Attempt mount 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|ntfs_mountfs
argument_list|(
name|rootvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* fs specific cleanup (if any)*/
goto|goto
name|error_1
goto|;
block|}
goto|goto
name|dostatfs
goto|;
comment|/* success*/
block|}
endif|#
directive|endif
comment|/* FreeBSD */
comment|/* 	 *** 	 * Mounting non-root file system or updating a file system 	 *** 	 */
comment|/* copy in user arguments*/
name|err
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntfs_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|error_1
goto|;
comment|/* can't get arguments*/
comment|/* 	 * If updating, check whether changing from read-only to 	 * read/write; if there is no device name, that's all we do. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
comment|/* if not updating name...*/
if|if
condition|(
name|args
operator|.
name|fspec
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Process export requests.  Jumping to "success" 			 * will return the vfs_export() error code. 			 */
name|struct
name|ntfsmount
modifier|*
name|ntm
init|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|err
operator|=
name|vfs_export
argument_list|(
name|mp
argument_list|,
operator|&
name|ntm
operator|->
name|ntm_export
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
block|}
name|printf
argument_list|(
literal|"ntfs_mount(): MNT_UPDATE not supported\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error_1
goto|;
block|}
comment|/* 	 * Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible block device. 	 */
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|err
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* can't get devvp!*/
goto|goto
name|error_1
goto|;
block|}
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|err
argument_list|)
condition|)
goto|goto
name|error_2
goto|;
else|#
directive|else
if|if
condition|(
name|devvp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|err
operator|=
name|ENOTBLK
expr_stmt|;
goto|goto
name|error_2
goto|;
block|}
if|if
condition|(
name|major
argument_list|(
name|devvp
operator|->
name|v_rdev
argument_list|)
operator|>=
name|nblkdev
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error_2
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		 ******************** 		 * UPDATE 		 ******************** 		 */
block|if (devvp != ntmp->um_devvp) 			err = EINVAL;
comment|/* needs translation */
block|else 			vrele(devvp);
comment|/* 		 * Update device name only on success 		 */
block|if( !err) {
comment|/* Save "mounted from" info for mount point (NULL pad)*/
block|copyinstr(	args.fspec, 					mp->mnt_stat.f_mntfromname, 					MNAMELEN - 1,&size); 			bzero( mp->mnt_stat.f_mntfromname + size, MNAMELEN - size); 		}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 ******************** 		 * NEW MOUNT 		 ******************** 		 */
comment|/* 		 * Since this is a new mount, we want the names for 		 * the device and the mount point copied in.  If an 		 * error occurs,  the mountpoint is discarded by the 		 * upper level code. 		 */
comment|/* Save "last mounted on" info for mount point (NULL pad)*/
name|copyinstr
argument_list|(
name|path
argument_list|,
comment|/* mount point*/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
comment|/* save area*/
name|MNAMELEN
operator|-
literal|1
argument_list|,
comment|/* max size*/
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* real size*/
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/* Save "mounted from" info for mount point (NULL pad)*/
name|copyinstr
argument_list|(
name|args
operator|.
name|fspec
argument_list|,
comment|/* device name*/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
comment|/* save area*/
name|MNAMELEN
operator|-
literal|1
argument_list|,
comment|/* max size*/
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* real size*/
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
name|err
operator|=
name|ntfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|error_2
goto|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|dostatfs
label|:
endif|#
directive|endif
comment|/* 	 * Initialize FS stat information in mount struct; uses both 	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname 	 * 	 * This code is common to root and non-root mounts 	 */
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
name|error_2
label|:
comment|/* error with devvp held*/
comment|/* release devvp before failing*/
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|error_1
label|:
comment|/* no state to back out*/
name|success
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
name|int
name|ntfs_mountfs
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|argsp
parameter_list|,
name|p
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ntfs_args
modifier|*
name|argsp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|dev_t
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|,
name|ncount
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Disallow multiple mounts of the same device. 	 * Disallow mounting of a device that is currently in use 	 * (except for root, which might share swap device for miniroot). 	 * Flush out any old buffers remaining from a previous use. 	 */
name|error
operator|=
name|vfs_mountedon
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ncount
operator|=
name|vcount
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|devvp
operator|->
name|v_object
condition|)
name|ncount
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ncount
operator|>
literal|1
operator|&&
name|devvp
operator|!=
name|rootvp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|VN_LOCK
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|VN_LOCK
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|FSCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|BBLOCK
argument_list|,
name|BBSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ntmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ntmp
argument_list|,
sizeof|sizeof
expr|*
name|ntmp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_bootfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bootfile
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_sysid
argument_list|,
name|NTFS_BBID
argument_list|,
name|NTFS_BBIDLEN
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: invalid boot block\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|{
name|int8_t
name|cpr
init|=
name|ntmp
operator|->
name|ntm_mftrecsz
decl_stmt|;
if|if
condition|(
name|cpr
operator|>
literal|0
condition|)
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
name|ntmp
operator|->
name|ntm_spc
operator|*
name|cpr
expr_stmt|;
else|else
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|-
name|cpr
operator|)
operator|)
operator|/
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): bps: %d, spc: %d, media: %x, mftrecsz: %d (%d sects)\n"
operator|,
name|ntmp
operator|->
name|ntm_bps
operator|,
name|ntmp
operator|->
name|ntm_spc
operator|,
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_media
operator|,
name|ntmp
operator|->
name|ntm_mftrecsz
operator|,
name|ntmp
operator|->
name|ntm_bpmftrec
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): mftcn: 0x%x|0x%x\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftcn
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftmirrcn
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_mountp
operator|=
name|mp
expr_stmt|;
name|ntmp
operator|->
name|ntm_dev
operator|=
name|dev
expr_stmt|;
name|ntmp
operator|->
name|ntm_devvp
operator|=
name|devvp
expr_stmt|;
name|ntmp
operator|->
name|ntm_uid
operator|=
name|argsp
operator|->
name|uid
expr_stmt|;
name|ntmp
operator|->
name|ntm_gid
operator|=
name|argsp
operator|->
name|gid
expr_stmt|;
name|ntmp
operator|->
name|ntm_mode
operator|=
name|argsp
operator|->
name|mode
expr_stmt|;
name|ntmp
operator|->
name|ntm_flag
operator|=
name|argsp
operator|->
name|flag
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|ntmp
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): case-%s,%s uid: %d, gid: %d, mode: %o\n"
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_CASEINS
operator|)
condition|?
literal|"insens."
else|:
literal|"sens."
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_ALLNAMES
operator|)
condition|?
literal|" allnames,"
else|:
literal|""
operator|,
name|ntmp
operator|->
name|ntm_uid
operator|,
name|ntmp
operator|->
name|ntm_gid
operator|,
name|ntmp
operator|->
name|ntm_mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We read in some system nodes to do not allow  	 * reclaim them and to have everytime access to them. 	 */
block|{
name|int
name|pi
index|[
literal|3
index|]
init|=
block|{
name|NTFS_MFTINO
block|,
name|NTFS_ROOTINO
block|,
name|NTFS_BITMAPINO
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|pi
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|->
name|v_flag
operator||=
name|VSYSTEM
expr_stmt|;
name|VREF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* read the Unicode lowercase --> uppercase translation table, 	 * if necessary */
if|if
condition|(
operator|(
name|error
operator|=
name|ntfs_toupper_use
argument_list|(
name|mp
argument_list|,
name|ntmp
argument_list|)
operator|)
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Scan $BitMap and count free clusters 	 */
name|error
operator|=
name|ntfs_calccfree
argument_list|(
name|ntmp
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Read and translate to internal format attribute 	 * definition file.  	 */
block|{
name|int
name|num
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|attrdef
name|ad
decl_stmt|;
comment|/* Open $AttrDef */
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|NTFS_ATTRDEFINO
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* Count valid entries */
for|for
control|(
name|num
operator|=
literal|0
init|;
condition|;
name|num
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
if|if
condition|(
name|ad
operator|.
name|ad_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Alloc memory for attribute definitions */
name|MALLOC
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
expr|struct
name|ntvattrdef
operator|*
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ntvattrdef
argument_list|)
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_adnum
operator|=
name|num
expr_stmt|;
comment|/* Read them and translate */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_name
index|[
name|j
index|]
operator|=
name|ad
operator|.
name|ad_name
index|[
name|j
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ad
operator|.
name|ad_name
index|[
name|j
operator|++
index|]
condition|)
do|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_namelen
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_type
operator|=
name|ad
operator|.
name|ad_type
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
else|#
directive|else
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|makefstype
argument_list|(
name|MOUNT_NTFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|mnt_maxsymlinklen
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|devvp
operator|->
name|v_specmountpoint
operator|=
name|mp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflush
argument_list|(
name|mp
argument_list|,
name|NULLVP
argument_list|,
literal|0
argument_list|)
condition|)
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: vflush failed\n"
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
name|devvp
operator|->
name|v_specmountpoint
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|__NetBSD__
comment|/* lock the device vnode before calling VOP_CLOSE() */
name|VN_LOCK
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|ntfs_start
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ntfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: unmounting...\n"
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: vflushing...\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|flags
operator||
name|SKIPSYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check if only system vnodes are rest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
operator|->
name|v_usecount
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Dereference all system vnodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* vflush system vnodes */
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed(sysnodes): %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Check if the type of device node isn't VBAD before 	 * touching v_specinfo.  If the device vnode is revoked, the 	 * field is NULL and touching it causes null pointer derefercence. 	 */
if|if
condition|(
name|ntmp
operator|->
name|ntm_devvp
operator|->
name|v_type
operator|!=
name|VBAD
condition|)
name|ntmp
operator|->
name|ntm_devvp
operator|->
name|v_specmountpoint
operator|=
name|NULL
expr_stmt|;
name|vinvalbuf
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|V_SAVE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* lock the device vnode before calling VOP_CLOSE() */
name|VOP_LOCK
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CLOSE
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|VOP_CLOSE
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|)
expr_stmt|;
comment|/* free the toupper table, if this has been last mounted ntfs volume */
name|ntfs_toupper_unuse
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_umount: freeing memory...\n"
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_root(): sysvn: %p\n"
operator|,
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
operator|->
name|ntm_sysvn
index|[
name|NTFS_ROOTINO
index|]
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
operator|(
name|ino_t
operator|)
name|NTFS_ROOTINO
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_root: VFS_VGET failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|ntfs_quotactl
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|cmds
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\nntfs_quotactl():\n"
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ntfs_calccfree
parameter_list|(
name|struct
name|ntfsmount
modifier|*
name|ntmp
parameter_list|,
name|cn_t
modifier|*
name|cfreep
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|u_int8_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|error
decl_stmt|;
name|long
name|cfree
init|=
literal|0
decl_stmt|;
name|size_t
name|bmsize
decl_stmt|,
name|i
decl_stmt|;
name|vp
operator|=
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_BITMAPINO
index|]
expr_stmt|;
name|bmsize
operator|=
name|VTOF
argument_list|(
name|vp
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|bmsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bmsize
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bmsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|~
name|tmp
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|cfree
operator|++
expr_stmt|;
operator|*
name|cfreep
operator|=
name|cfree
expr_stmt|;
name|out
label|:
name|FREE
argument_list|(
name|tmp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ntfsmount
modifier|*
name|ntmp
init|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|u_int64_t
name|mftsize
decl_stmt|,
name|mftallocated
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_statfs():\n"
operator|)
argument_list|)
expr_stmt|;
name|mftsize
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|mftallocated
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_allocated
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sbp
operator|->
name|f_type
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sbp
operator|->
name|f_type
operator|=
name|MOUNT_NTFS
expr_stmt|;
endif|#
directive|endif
name|sbp
operator|->
name|f_bsize
operator|=
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|ntmp
operator|->
name|ntm_bps
operator|*
name|ntmp
operator|->
name|ntm_spc
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_spv
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sbp
operator|->
name|f_bavail
operator|=
name|ntfs_cntobn
argument_list|(
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|sbp
operator|->
name|f_bfree
operator|/
name|ntmp
operator|->
name|ntm_bpmftrec
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|mftallocated
operator|/
name|ntfs_bntob
argument_list|(
name|ntmp
operator|->
name|ntm_bpmftrec
argument_list|)
operator|+
name|sbp
operator|->
name|f_ffree
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntonname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntfromname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
block|}
name|sbp
operator|->
name|f_flags
operator|=
name|mp
operator|->
name|mnt_flag
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|strncpy
argument_list|(
name|sbp
operator|->
name|f_fstypename
argument_list|,
name|mp
operator|->
name|mnt_op
operator|->
name|vfs_name
argument_list|,
name|MFSNAMELEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|ntfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
comment|/*dprintf(("ntfs_sync():\n"));*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|ntfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|ntfid
modifier|*
name|ntfhp
init|=
operator|(
expr|struct
name|ntfid
operator|*
operator|)
name|fhp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ddprintf
argument_list|(
operator|(
literal|"ntfs_fhtovp(): %s: %d\n"
operator|,
name|mp
operator|->
name|mnt_stat
operator|->
name|f_mntonname
operator|,
name|ntfhp
operator|->
name|ntfid_ino
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ntfhp
operator|->
name|ntfid_ino
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX as unlink/rmdir/mkdir/creat are not currently possible 	 * with NTFS, we don't need to check anything else for now */
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_vptofh
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|)
block|{
specifier|register
name|struct
name|ntnode
modifier|*
name|ntp
decl_stmt|;
specifier|register
name|struct
name|ntfid
modifier|*
name|ntfhp
decl_stmt|;
name|ddprintf
argument_list|(
operator|(
literal|"ntfs_fhtovp(): %s: %p\n"
operator|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|->
name|f_mntonname
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
name|ntp
operator|=
name|VTONT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ntfhp
operator|=
operator|(
expr|struct
name|ntfid
operator|*
operator|)
name|fhp
expr_stmt|;
name|ntfhp
operator|->
name|ntfid_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ntfid
argument_list|)
expr_stmt|;
name|ntfhp
operator|->
name|ntfid_ino
operator|=
name|ntp
operator|->
name|i_number
expr_stmt|;
comment|/* ntfhp->ntfid_gen = ntp->i_gen; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ntfs_vgetex
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|u_int32_t
name|attrtype
parameter_list|,
name|char
modifier|*
name|attrname
parameter_list|,
name|u_long
name|lkflags
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|struct
name|ntnode
modifier|*
name|ip
decl_stmt|;
name|struct
name|fnode
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|enum
name|vtype
name|f_type
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vgetex: ino: %d, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n"
operator|,
name|ino
operator|,
name|attrtype
operator|,
name|attrname
condition|?
name|attrname
else|:
literal|""
operator|,
operator|(
name|u_long
operator|)
name|lkflags
operator|,
operator|(
name|u_long
operator|)
name|flags
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
comment|/* Get ntnode */
name|error
operator|=
name|ntfs_ntlookup
argument_list|(
name|ntmp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_ntget failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* It may be not initialized fully, so force load it */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTLOADIN
operator|)
operator|&&
operator|!
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_LOADED
operator|)
condition|)
block|{
name|error
operator|=
name|ntfs_loadntnode
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: CAN'T LOAD ATTRIBUTES FOR INO: %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|ntfs_fget
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|,
name|attrtype
argument_list|,
name|attrname
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_fget failed\n"
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|f_type
operator|=
name|VNON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTVALIDFN
operator|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FN_VALID
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_frflag
operator|&
name|NTFS_FRFLAG_DIR
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_attrtype
operator|==
name|NTFS_A_DATA
operator|&&
name|fp
operator|->
name|f_attrname
operator|==
name|NULL
operator|)
condition|)
block|{
name|f_type
operator|=
name|VDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|VG_EXT
condition|)
block|{
name|f_type
operator|=
name|VNON
expr_stmt|;
name|fp
operator|->
name|f_size
operator|=
name|fp
operator|->
name|f_allocated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|f_type
operator|=
name|VREG
expr_stmt|;
name|error
operator|=
name|ntfs_filesize
argument_list|(
name|ntmp
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|f_size
argument_list|,
operator|&
name|fp
operator|->
name|f_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|fp
operator|->
name|f_flag
operator||=
name|FN_VALID
expr_stmt|;
block|}
if|if
condition|(
name|FTOV
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|VGET
argument_list|(
name|FTOV
argument_list|(
name|fp
argument_list|)
argument_list|,
name|lkflags
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|FTOV
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_NTFS
argument_list|,
name|ntmp
operator|->
name|ntm_mountp
argument_list|,
name|ntfs_vnodeop_p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_frele
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vget: vnode: %p for ntnode: %d\n"
operator|,
name|vp
operator|,
name|ino
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|lockinit
argument_list|(
operator|&
name|fp
operator|->
name|f_lock
argument_list|,
name|PINOD
argument_list|,
literal|"fnode"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|->
name|f_vp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|fp
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|f_type
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|NTFS_ROOTINO
condition|)
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
block|{
name|error
operator|=
name|VN_LOCK
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|VREF
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
return|return
name|ntfs_vgetex
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
literal|0
argument_list|,
name|curproc
argument_list|,
name|vpp
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|ntfs_vfsops
init|=
block|{
name|ntfs_mount
block|,
name|vfs_stdstart
block|,
name|ntfs_unmount
block|,
name|ntfs_root
block|,
name|vfs_stdquotactl
block|,
name|ntfs_statfs
block|,
name|vfs_stdsync
block|,
name|ntfs_vget
block|,
name|ntfs_fhtovp
block|,
name|ntfs_checkexp
block|,
name|ntfs_vptofh
block|,
name|ntfs_init
block|,
name|vfs_stduninit
block|,
name|vfs_stdextattrctl
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|ntfs_vfsops
argument_list|,
name|ntfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|extern
name|struct
name|vnodeopv_desc
name|ntfs_vnodeop_opv_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
modifier|*
name|ntfs_vnodeopv_descs
index|[]
init|=
block|{
operator|&
name|ntfs_vnodeop_opv_desc
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsops
name|ntfs_vfsops
init|=
block|{
name|MOUNT_NTFS
block|,
name|ntfs_mount
block|,
name|ntfs_start
block|,
name|ntfs_unmount
block|,
name|ntfs_root
block|,
name|ntfs_quotactl
block|,
name|ntfs_statfs
block|,
name|ntfs_sync
block|,
name|ntfs_vget
block|,
name|ntfs_fhtovp
block|,
name|ntfs_vptofh
block|,
name|ntfs_init
block|,
name|ntfs_sysctl
block|,
name|ntfs_mountroot
block|,
name|ntfs_checkexp
block|,
name|ntfs_vnodeopv_descs
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NetBSD&& !FreeBSD */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|ntfs_vfsops
init|=
block|{
name|ntfs_mount
block|,
name|ntfs_start
block|,
name|ntfs_unmount
block|,
name|ntfs_root
block|,
name|ntfs_quotactl
block|,
name|ntfs_statfs
block|,
name|ntfs_sync
block|,
name|ntfs_vget
block|,
name|ntfs_fhtovp
block|,
name|ntfs_vptofh
block|,
name|ntfs_init
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|ntfs_vfsops
argument_list|,
name|ntfs
argument_list|,
name|MOUNT_NTFS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

