begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)isa.c	7.2 (Berkeley) 5/13/91  *	from: isa_dma.c,v 1.3 1999/05/09 23:56:00 peter Exp $  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * code to manage AT bus  *  * 92/08/18  Frank P. MacLachlan (fpm@crash.cts.com):  * Fixed uninitialized variable problem and added code to deal  * with DMA page boundaries in isa_dmarangecheck().  Fixed word  * mode DMA count compution and reorganized DMA setup code in  * isa_dmastart()  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/i8237.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* **  Register definitions for DMA controller 1 (channels 0..3): */
end_comment

begin_define
define|#
directive|define
name|DMA1_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA1 + 1*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA1_SMSK
value|(IO_DMA1 + 1*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA1_MODE
value|(IO_DMA1 + 1*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA1_FFC
value|(IO_DMA1 + 1*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_define
define|#
directive|define
name|DMA1_RESET
value|(IO_DMA1 + 1*13)
end_define

begin_comment
comment|/* reset */
end_comment

begin_comment
comment|/* **  Register definitions for DMA controller 2 (channels 4..7): */
end_comment

begin_define
define|#
directive|define
name|DMA2_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA2 + 2*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA2_SMSK
value|(IO_DMA2 + 2*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA2_MODE
value|(IO_DMA2 + 2*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA2_FFC
value|(IO_DMA2 + 2*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_define
define|#
directive|define
name|DMA2_RESET
value|(IO_DMA2 + 2*13)
end_define

begin_comment
comment|/* reset */
end_comment

begin_decl_stmt
specifier|static
name|bus_dma_tag_t
name|dma_tag
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_t
name|dma_map
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in isa_dmastart() */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_inuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User for acquire/release */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_auto_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_bounced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VALID_DMA_MASK
value|(7)
end_define

begin_comment
comment|/* high byte of address is stored in this port for i-th dma channel */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dmapageport
index|[
literal|8
index|]
init|=
block|{
literal|0x87
block|,
literal|0x83
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x8f
block|,
literal|0x8b
block|,
literal|0x89
block|,
literal|0x8a
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setup a DMA channel's bounce buffer.  */
end_comment

begin_function
name|int
name|isa_dma_init
parameter_list|(
name|int
name|chan
parameter_list|,
name|u_int
name|bouncebufsize
parameter_list|,
name|int
name|flag
name|__unused
parameter_list|)
block|{
specifier|static
name|int
name|initted
init|=
literal|0
decl_stmt|;
name|bus_addr_t
name|boundary
init|=
name|chan
operator|>=
literal|4
condition|?
literal|0x20000
else|:
literal|0x10000
decl_stmt|;
if|if
condition|(
operator|!
name|initted
condition|)
block|{
comment|/* 		 * Reset the DMA hardware. 		 */
name|outb
argument_list|(
name|DMA1_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isa_dmacascade
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|initted
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dma_init: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_tag
index|[
name|chan
index|]
operator|||
name|dma_map
index|[
name|chan
index|]
condition|)
name|panic
argument_list|(
literal|"isa_dma_init: impossible request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
name|boundary
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|bouncebufsize
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
name|BUS_DMA_ISA
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|dma_tag
index|[
name|chan
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"isa_dma_init: unable to create dma tag\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|dma_tag
index|[
name|chan
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|dma_map
index|[
name|chan
index|]
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"isa_dma_init: unable to create dma map\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a DMA channel's usage.  Usually called from a device driver  * in open() or during its initialization.  */
end_comment

begin_function
name|int
name|isa_dma_acquire
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dma_acquire: channel out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isa_dma_acquire: channel %d already in use\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dma_inuse
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
name|dma_auto_mode
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister a DMA channel's usage.  Usually called from a device driver  * during close() or during its shutdown.  */
end_comment

begin_function
name|void
name|isa_dma_release
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dma_release: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dma_release: channel %d not in use\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
name|dma_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
comment|/*  		 * XXX We should also do "dma_bounced&= (1<< chan);" 		 * because we are acting on behalf of isa_dmadone() which 		 * was not called to end the last DMA operation.  This does 		 * not matter now, but it may in the future. 		 */
block|}
name|dma_inuse
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
name|dma_auto_mode
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * isa_dmacascade(): program 8237 DMA controller channel to accept  * external dma control by a board.  */
end_comment

begin_function
name|void
name|isa_dmacascade
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmacascade: channel out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set dma channel mode, and set dma channel mode */
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * isa_dmastart(): program 8237 DMA controller channel.  */
end_comment

begin_struct
struct|struct
name|isa_dmastart_arg
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|isa_dmastart_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|#
directive|if
literal|0
block|caddr_t addr = ((struct isa_dmastart_arg *) arg)->addr;
endif|#
directive|endif
name|int
name|chan
init|=
operator|(
operator|(
expr|struct
name|isa_dmastart_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
decl_stmt|;
name|int
name|flags
init|=
operator|(
operator|(
expr|struct
name|isa_dmastart_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|flags
decl_stmt|;
name|bus_addr_t
name|phys
init|=
name|segs
operator|->
name|ds_addr
decl_stmt|;
name|int
name|nbytes
init|=
name|segs
operator|->
name|ds_len
decl_stmt|;
name|int
name|waport
decl_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: transfer mapping not contiguous"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((chipset.sgmap == NULL)&&  	    (pmap_extract(kernel_pmap, (vm_offset_t)addr)> BUS_SPACE_MAXADDR_24BIT)) {
comment|/* we bounced */
block|dma_bounced |= (1<< chan);
comment|/* copy bounce buffer on write */
block|if (!(flags& ISADMA_READ))                          bus_dmamap_sync(dma_tag[chan], dma_map[chan],  			                  BUS_DMASYNC_PREWRITE); 	}
endif|#
directive|endif
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Program one of DMA channels 0..3.  These are 		 * byte mode channels. 		 */
comment|/* set dma channel mode, and reset address ff */
comment|/* If ISADMA_RAW flag is set, then use autoinitialise mode */
if|if
condition|(
name|flags
operator|&
name|ISADMA_RAW
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ISADMA_READ
condition|)
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_WRITE
operator||
name|chan
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_READ
operator||
name|chan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ISADMA_READ
condition|)
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
name|chan
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA1_CHN
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|outb
argument_list|(
name|waport
operator|+
literal|1
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|1
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Program one of DMA channels 4..7.  These are 		 * word mode channels. 		 */
comment|/* set dma channel mode, and reset address ff */
comment|/* If ISADMA_RAW flag is set, then use autoinitialise mode */
if|if
condition|(
name|flags
operator|&
name|ISADMA_RAW
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ISADMA_READ
condition|)
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ISADMA_READ
condition|)
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA2_CHN
argument_list|(
name|chan
operator|-
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|nbytes
operator|>>=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isa_dmastart
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|u_int
name|nbytes
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|struct
name|isa_dmastart_arg
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|<
literal|4
operator|&&
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
operator|||
operator|(
name|chan
operator|>=
literal|4
operator|&&
operator|(
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|||
operator|(
name|uintptr_t
operator|)
name|addr
operator|&
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: impossible request"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmastart: channel %d not acquired\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * XXX This should be checked, but drivers like ad1848 only call 	 * isa_dmastart() once because they use Auto DMA mode.  If we 	 * leave this in, drivers that do this will print this continuously. 	 */
block|if (dma_busy& (1<< chan)) 		printf("isa_dmastart: channel %d busy\n", chan);
endif|#
directive|endif
if|if
condition|(
operator|!
name|dma_tag
operator|||
operator|!
name|dma_map
index|[
name|chan
index|]
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: called without isa_dma_init"
argument_list|)
expr_stmt|;
name|dma_busy
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ISADMA_RAW
condition|)
block|{
name|dma_auto_mode
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dma_auto_mode
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
comment|/* 	 * Freeze dma while updating registers. 	 */
name|outb
argument_list|(
name|chan
operator|&
literal|4
condition|?
name|DMA2_SMSK
else|:
name|DMA1_SMSK
argument_list|,
operator|(
name|chan
operator|&
literal|3
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
name|args
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|args
operator|.
name|chan
operator|=
name|chan
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|dma_tag
index|[
name|chan
index|]
argument_list|,
name|dma_map
index|[
name|chan
index|]
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|,
name|isa_dmastart_cb
argument_list|,
operator|&
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isa_dmadone
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmadone: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmadone: channel %d not acquired\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dma_auto_mode
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmadone: channel %d not busy\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_bounced
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
comment|/* copy bounce buffer on read */
if|if
condition|(
name|flags
operator|&
name|ISADMA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma_tag
index|[
name|chan
index|]
argument_list|,
name|dma_map
index|[
name|chan
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
name|dma_bounced
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dma_auto_mode
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|chan
operator|&
literal|4
condition|?
name|DMA2_SMSK
else|:
name|DMA1_SMSK
argument_list|,
operator|(
name|chan
operator|&
literal|3
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma_tag
index|[
name|chan
index|]
argument_list|,
name|dma_map
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
block|}
name|dma_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query the progress of a transfer on a DMA channel.  *  * To avoid having to interrupt a transfer in progress, we sample  * each of the high and low databytes twice, and apply the following  * logic to determine the correct count.  *  * Reads are performed with interrupts disabled, thus it is to be  * expected that the time between reads is very small.  At most  * one rollover in the low count byte can be expected within the  * four reads that are performed.  *  * There are three gaps in which a rollover can occur :  *  * - read low1  *              gap1  * - read high1  *              gap2  * - read low2  *              gap3  * - read high2  *  * If a rollover occurs in gap1 or gap2, the low2 value will be  * greater than the low1 value.  In this case, low2 and high2 are a  * corresponding pair.   *  * In any other case, low1 and high1 can be considered to be correct.  *  * The function returns the number of bytes remaining in the transfer,  * or -1 if the channel requested is not active.  *  */
end_comment

begin_function
name|int
name|isa_dmastatus
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
name|u_long
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|ffport
decl_stmt|,
name|waport
decl_stmt|;
name|u_long
name|low1
decl_stmt|,
name|high1
decl_stmt|,
name|low2
decl_stmt|,
name|high2
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* channel active? */
if|if
condition|(
operator|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"isa_dmastatus: channel %d not active\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* channel busy? */
if|if
condition|(
operator|(
operator|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dma_auto_mode
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"chan %d not busy\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|chan
operator|<
literal|4
condition|)
block|{
comment|/* low DMA controller */
name|ffport
operator|=
name|DMA1_FFC
expr_stmt|;
name|waport
operator|=
name|DMA1_CHN
argument_list|(
name|chan
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* high DMA controller */
name|ffport
operator|=
name|DMA2_FFC
expr_stmt|;
name|waport
operator|=
name|DMA2_CHN
argument_list|(
name|chan
operator|-
literal|4
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* no interrupts Mr Jones! */
name|outb
argument_list|(
name|ffport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear register LSB flipflop */
name|low1
operator|=
name|inb
argument_list|(
name|waport
argument_list|)
expr_stmt|;
name|high1
operator|=
name|inb
argument_list|(
name|waport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ffport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear again */
name|low2
operator|=
name|inb
argument_list|(
name|waport
argument_list|)
expr_stmt|;
name|high2
operator|=
name|inb
argument_list|(
name|waport
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable interrupts again */
comment|/*  	 * Now decide if a wrap has tried to skew our results. 	 * Note that after TC, the count will read 0xffff, while we want  	 * to return zero, so we add and then mask to compensate. 	 */
if|if
condition|(
name|low1
operator|>=
name|low2
condition|)
block|{
name|cnt
operator|=
operator|(
name|low1
operator|+
operator|(
name|high1
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
operator|(
name|low2
operator|+
operator|(
name|high2
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|>=
literal|4
condition|)
comment|/* high channels move words */
name|cnt
operator|*=
literal|2
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a DMA transfer currently in progress.  */
end_comment

begin_function
name|int
name|isa_dmastop
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmastop: channel %d not acquired\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|dma_auto_mode
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"chan %d not busy\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
operator|(
name|chan
operator|&
literal|3
operator|)
operator||
literal|4
comment|/* disable mask */
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
operator|(
name|chan
operator|&
literal|3
operator|)
operator||
literal|4
comment|/* disable mask */
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|isa_dmastatus
argument_list|(
name|chan
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

