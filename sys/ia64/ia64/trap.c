begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* From: src/sys/alpha/alpha/trap.c,v 1.33 */
end_comment

begin_comment
comment|/* $NetBSD: trap.c,v 1.31 1998/03/26 02:21:46 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/efi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia32_syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * EFI-Provided FPSWA interface (Floating Point SoftWare Assist  */
end_comment

begin_comment
comment|/* The function entry address */
end_comment

begin_decl_stmt
specifier|extern
name|FPSWA_INTERFACE
modifier|*
name|fpswa_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of the faulting instruction bundle */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int64_t
name|bundle_low64
decl_stmt|;
name|u_int64_t
name|bundle_high64
decl_stmt|;
block|}
name|FPSWA_BUNDLE
typedef|;
end_typedef

begin_comment
comment|/*  * The fp state descriptor... tell FPSWA where the "true" copy is.  * We save some registers in the trapframe, so we have to point some of  * these there.  The rest of the registers are "live"  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int64_t
name|bitmask_low64
decl_stmt|;
comment|/* f63 - f2 */
name|u_int64_t
name|bitmask_high64
decl_stmt|;
comment|/* f127 - f64 */
name|struct
name|ia64_fpreg
modifier|*
name|fp_low_preserved
decl_stmt|;
comment|/* f2 - f5 */
name|struct
name|ia64_fpreg
modifier|*
name|fp_low_volatile
decl_stmt|;
comment|/* f6 - f15 */
name|struct
name|ia64_fpreg
modifier|*
name|fp_high_preserved
decl_stmt|;
comment|/* f16 - f31 */
name|struct
name|ia64_fpreg
modifier|*
name|fp_high_volatile
decl_stmt|;
comment|/* f32 - f127 */
block|}
name|FP_STATE
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ia64_vector_names
index|[]
init|=
block|{
literal|"VHPT Translation"
block|,
comment|/* 0 */
literal|"Instruction TLB"
block|,
comment|/* 1 */
literal|"Data TLB"
block|,
comment|/* 2 */
literal|"Alternate Instruction TLB"
block|,
comment|/* 3 */
literal|"Alternate Data TLB"
block|,
comment|/* 4 */
literal|"Data Nested TLB"
block|,
comment|/* 5 */
literal|"Instruction Key Miss"
block|,
comment|/* 6 */
literal|"Data Key Miss"
block|,
comment|/* 7 */
literal|"Dirty-Bit"
block|,
comment|/* 8 */
literal|"Instruction Access-Bit"
block|,
comment|/* 9 */
literal|"Data Access-Bit"
block|,
comment|/* 10 */
literal|"Break Instruction"
block|,
comment|/* 11 */
literal|"External Interrupt"
block|,
comment|/* 12 */
literal|"Reserved 13"
block|,
comment|/* 13 */
literal|"Reserved 14"
block|,
comment|/* 14 */
literal|"Reserved 15"
block|,
comment|/* 15 */
literal|"Reserved 16"
block|,
comment|/* 16 */
literal|"Reserved 17"
block|,
comment|/* 17 */
literal|"Reserved 18"
block|,
comment|/* 18 */
literal|"Reserved 19"
block|,
comment|/* 19 */
literal|"Page Not Present"
block|,
comment|/* 20 */
literal|"Key Permission"
block|,
comment|/* 21 */
literal|"Instruction Access Rights"
block|,
comment|/* 22 */
literal|"Data Access Rights"
block|,
comment|/* 23 */
literal|"General Exception"
block|,
comment|/* 24 */
literal|"Disabled FP-Register"
block|,
comment|/* 25 */
literal|"NaT Consumption"
block|,
comment|/* 26 */
literal|"Speculation"
block|,
comment|/* 27 */
literal|"Reserved 28"
block|,
comment|/* 28 */
literal|"Debug"
block|,
comment|/* 29 */
literal|"Unaligned Reference"
block|,
comment|/* 30 */
literal|"Unsupported Data Reference"
block|,
comment|/* 31 */
literal|"Floating-point Fault"
block|,
comment|/* 32 */
literal|"Floating-point Trap"
block|,
comment|/* 33 */
literal|"Lower-Privilege Transfer Trap"
block|,
comment|/* 34 */
literal|"Taken Branch Trap"
block|,
comment|/* 35 */
literal|"Single Step Trap"
block|,
comment|/* 36 */
literal|"Reserved 37"
block|,
comment|/* 37 */
literal|"Reserved 38"
block|,
comment|/* 38 */
literal|"Reserved 39"
block|,
comment|/* 39 */
literal|"Reserved 40"
block|,
comment|/* 40 */
literal|"Reserved 41"
block|,
comment|/* 41 */
literal|"Reserved 42"
block|,
comment|/* 42 */
literal|"Reserved 43"
block|,
comment|/* 43 */
literal|"Reserved 44"
block|,
comment|/* 44 */
literal|"IA-32 Exception"
block|,
comment|/* 45 */
literal|"IA-32 Intercept"
block|,
comment|/* 46 */
literal|"IA-32 Interrupt"
block|,
comment|/* 47 */
literal|"Reserved 48"
block|,
comment|/* 48 */
literal|"Reserved 49"
block|,
comment|/* 49 */
literal|"Reserved 50"
block|,
comment|/* 50 */
literal|"Reserved 51"
block|,
comment|/* 51 */
literal|"Reserved 52"
block|,
comment|/* 52 */
literal|"Reserved 53"
block|,
comment|/* 53 */
literal|"Reserved 54"
block|,
comment|/* 54 */
literal|"Reserved 55"
block|,
comment|/* 55 */
literal|"Reserved 56"
block|,
comment|/* 56 */
literal|"Reserved 57"
block|,
comment|/* 57 */
literal|"Reserved 58"
block|,
comment|/* 58 */
literal|"Reserved 59"
block|,
comment|/* 59 */
literal|"Reserved 60"
block|,
comment|/* 60 */
literal|"Reserved 61"
block|,
comment|/* 61 */
literal|"Reserved 62"
block|,
comment|/* 62 */
literal|"Reserved 63"
block|,
comment|/* 63 */
literal|"Reserved 64"
block|,
comment|/* 64 */
literal|"Reserved 65"
block|,
comment|/* 65 */
literal|"Reserved 66"
block|,
comment|/* 66 */
literal|"Reserved 67"
block|,
comment|/* 67 */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bitname
block|{
name|u_int64_t
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|printbits
parameter_list|(
name|u_int64_t
name|mask
parameter_list|,
name|struct
name|bitname
modifier|*
name|bn
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|u_int64_t
name|bit
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Handle fields wider than one bit. 		 */
name|bit
operator|=
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|&
operator|~
operator|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|>
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s=%ld"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|mask
operator|&
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|/
name|bit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|psr_bits
index|[]
init|=
block|{
block|{
name|IA64_PSR_BE
block|,
literal|"be"
block|}
block|,
block|{
name|IA64_PSR_UP
block|,
literal|"up"
block|}
block|,
block|{
name|IA64_PSR_AC
block|,
literal|"ac"
block|}
block|,
block|{
name|IA64_PSR_MFL
block|,
literal|"mfl"
block|}
block|,
block|{
name|IA64_PSR_MFH
block|,
literal|"mfh"
block|}
block|,
block|{
name|IA64_PSR_IC
block|,
literal|"ic"
block|}
block|,
block|{
name|IA64_PSR_I
block|,
literal|"i"
block|}
block|,
block|{
name|IA64_PSR_PK
block|,
literal|"pk"
block|}
block|,
block|{
name|IA64_PSR_DT
block|,
literal|"dt"
block|}
block|,
block|{
name|IA64_PSR_DFL
block|,
literal|"dfl"
block|}
block|,
block|{
name|IA64_PSR_DFH
block|,
literal|"dfh"
block|}
block|,
block|{
name|IA64_PSR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_PSR_PP
block|,
literal|"pp"
block|}
block|,
block|{
name|IA64_PSR_DI
block|,
literal|"di"
block|}
block|,
block|{
name|IA64_PSR_SI
block|,
literal|"si"
block|}
block|,
block|{
name|IA64_PSR_DB
block|,
literal|"db"
block|}
block|,
block|{
name|IA64_PSR_LP
block|,
literal|"lp"
block|}
block|,
block|{
name|IA64_PSR_TB
block|,
literal|"tb"
block|}
block|,
block|{
name|IA64_PSR_RT
block|,
literal|"rt"
block|}
block|,
block|{
name|IA64_PSR_CPL
block|,
literal|"cpl"
block|}
block|,
block|{
name|IA64_PSR_IS
block|,
literal|"is"
block|}
block|,
block|{
name|IA64_PSR_MC
block|,
literal|"mc"
block|}
block|,
block|{
name|IA64_PSR_IT
block|,
literal|"it"
block|}
block|,
block|{
name|IA64_PSR_ID
block|,
literal|"id"
block|}
block|,
block|{
name|IA64_PSR_DA
block|,
literal|"da"
block|}
block|,
block|{
name|IA64_PSR_DD
block|,
literal|"dd"
block|}
block|,
block|{
name|IA64_PSR_SS
block|,
literal|"ss"
block|}
block|,
block|{
name|IA64_PSR_RI
block|,
literal|"ri"
block|}
block|,
block|{
name|IA64_PSR_ED
block|,
literal|"ed"
block|}
block|,
block|{
name|IA64_PSR_BN
block|,
literal|"bn"
block|}
block|,
block|{
name|IA64_PSR_IA
block|,
literal|"ia"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printpsr
parameter_list|(
name|u_int64_t
name|psr
parameter_list|)
block|{
name|printbits
argument_list|(
name|psr
argument_list|,
name|psr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|psr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|psr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|isr_bits
index|[]
init|=
block|{
block|{
name|IA64_ISR_CODE
block|,
literal|"code"
block|}
block|,
block|{
name|IA64_ISR_VECTOR
block|,
literal|"vector"
block|}
block|,
block|{
name|IA64_ISR_X
block|,
literal|"x"
block|}
block|,
block|{
name|IA64_ISR_W
block|,
literal|"w"
block|}
block|,
block|{
name|IA64_ISR_R
block|,
literal|"r"
block|}
block|,
block|{
name|IA64_ISR_NA
block|,
literal|"na"
block|}
block|,
block|{
name|IA64_ISR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_ISR_RS
block|,
literal|"rs"
block|}
block|,
block|{
name|IA64_ISR_IR
block|,
literal|"ir"
block|}
block|,
block|{
name|IA64_ISR_NI
block|,
literal|"ni"
block|}
block|,
block|{
name|IA64_ISR_SO
block|,
literal|"so"
block|}
block|,
block|{
name|IA64_ISR_EI
block|,
literal|"ei"
block|}
block|,
block|{
name|IA64_ISR_ED
block|,
literal|"ed"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printisr
parameter_list|(
name|u_int64_t
name|isr
parameter_list|)
block|{
name|printbits
argument_list|(
name|isr
argument_list|,
name|isr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|isr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|isr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printtrap
parameter_list|(
name|int
name|vector
parameter_list|,
name|int
name|imm
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|int
name|isfatal
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s trap (cpu %d):\n"
argument_list|,
name|isfatal
condition|?
literal|"fatal"
else|:
literal|"handled"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    trap vector = 0x%x (%s)\n"
argument_list|,
name|vector
argument_list|,
name|ia64_vector_names
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.iip      = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_cr_iip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ipsr     = 0x%lx ("
argument_list|,
name|framep
operator|->
name|tf_cr_ipsr
argument_list|)
expr_stmt|;
name|printpsr
argument_list|(
name|framep
operator|->
name|tf_cr_ipsr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.isr      = 0x%lx ("
argument_list|,
name|framep
operator|->
name|tf_cr_isr
argument_list|)
expr_stmt|;
name|printisr
argument_list|(
name|framep
operator|->
name|tf_cr_isr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ifa      = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_cr_ifa
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.iim      = 0x%x\n"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_IS
condition|)
block|{
name|printf
argument_list|(
literal|"    ar.cflg     = 0x%x\n"
argument_list|,
name|ia64_get_cflg
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ar.csd      = 0x%x\n"
argument_list|,
name|ia64_get_csd
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ar.ssd      = 0x%x\n"
argument_list|,
name|ia64_get_ssd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    curthread   = %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"        pid = %d, comm = %s\n"
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from exception.s to handle most types of processor traps.  * System calls are broken out for efficiency and ASTs are broken out  * to make the code a bit cleaner and more representative of the  * architecture.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|int
name|vector
parameter_list|,
name|int
name|imm
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int64_t
name|ucode
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|user
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure we have a sane floating-point state in case the 	 * user has trashed it. 	 */
name|ia64_set_fpsr
argument_list|(
name|IA64_FPSR_DEFAULT
argument_list|)
expr_stmt|;
name|user
operator|=
operator|(
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_CPL
operator|)
operator|==
name|IA64_PSR_CPL_USER
operator|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sticks
operator|=
literal|0
expr_stmt|;
comment|/* XXX bogus -Wuninitialized warning */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|vector
condition|)
block|{
case|case
name|IA64_VEC_UNALIGNED_REFERENCE
case|:
comment|/* 		 * If user-land, do whatever fixups, printing, and 		 * signalling is appropriate (based on system-wide 		 * and per-process unaligned-access-handling flags). 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|unaligned_fixup
argument_list|(
name|framep
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|framep
operator|->
name|tf_cr_ifa
expr_stmt|;
comment|/* VA */
break|break;
block|}
comment|/* 		 * Unaligned access from kernel mode is always an error, 		 * EVEN IF A COPY FAULT HANDLER IS SET! 		 * 		 * It's an error if a copy fault handler is set because 		 * the various routines which do user-initiated copies 		 * do so in a bcopy-like manner.  In other words, the 		 * kernel never assumes that pointers provided by the 		 * user are properly aligned, and so if the kernel 		 * does cause an unaligned access it's a kernel bug. 		 */
goto|goto
name|dopanic
goto|;
case|case
name|IA64_VEC_FLOATING_POINT_FAULT
case|:
block|{
name|FP_STATE
name|fp_state
decl_stmt|;
name|FPSWA_RET
name|fpswa_ret
decl_stmt|;
name|FPSWA_BUNDLE
name|bundle
decl_stmt|;
comment|/* Always fatal in kernel.  Should never happen. */
if|if
condition|(
operator|!
name|user
condition|)
goto|goto
name|dopanic
goto|;
if|if
condition|(
name|fpswa_interface
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|framep
operator|->
name|tf_cr_iip
operator|)
argument_list|,
operator|&
name|bundle
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|=
name|SIGBUS
expr_stmt|;
comment|/* EFAULT, basically */
name|ucode
operator|=
comment|/*a0*/
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* f6-f15 are saved in exception_save */
name|fp_state
operator|.
name|bitmask_low64
operator|=
literal|0xffc0
expr_stmt|;
comment|/* bits 6 - 15 */
name|fp_state
operator|.
name|bitmask_high64
operator|=
literal|0x0
expr_stmt|;
name|fp_state
operator|.
name|fp_low_preserved
operator|=
name|NULL
expr_stmt|;
name|fp_state
operator|.
name|fp_low_volatile
operator|=
name|framep
operator|->
name|tf_f
expr_stmt|;
name|fp_state
operator|.
name|fp_high_preserved
operator|=
name|NULL
expr_stmt|;
name|fp_state
operator|.
name|fp_high_volatile
operator|=
name|NULL
expr_stmt|;
comment|/* The docs are unclear.  Is Fpswa reentrant? */
name|fpswa_ret
operator|=
name|fpswa_interface
operator|->
name|Fpswa
argument_list|(
literal|1
argument_list|,
operator|&
name|bundle
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_ipsr
argument_list|,
operator|&
name|framep
operator|->
name|tf_ar_fpsr
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_isr
argument_list|,
operator|&
name|framep
operator|->
name|tf_pr
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_ifs
argument_list|,
operator|&
name|fp_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|==
literal|0
condition|)
block|{
comment|/* fixed.  update ipsr and iip to next insn */
name|int
name|ei
decl_stmt|;
name|ei
operator|=
operator|(
name|framep
operator|->
name|tf_cr_isr
operator|>>
literal|41
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|ei
operator|==
literal|0
condition|)
block|{
comment|/* no template for this case */
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator||=
name|IA64_ISR_EI_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ei
operator|==
literal|1
condition|)
block|{
comment|/* MFI or MFB */
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator||=
name|IA64_ISR_EI_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ei
operator|==
literal|2
condition|)
block|{
comment|/* MMF */
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|framep
operator|->
name|tf_cr_iip
operator|+=
literal|0x10
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"FATAL: FPSWA err1 %lx, err2 %lx, err3 %lx\n"
argument_list|,
name|fpswa_ret
operator|.
name|err1
argument_list|,
name|fpswa_ret
operator|.
name|err2
argument_list|,
name|fpswa_ret
operator|.
name|err3
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"fpswa fatal error on fp fault"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|>
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (fpswa_ret.status& 1) {
comment|/* 				 * New exception needs to be raised. 				 * If set then the following bits also apply: 				 *& 2 -> fault was converted to a trap 				 *& 4 -> SIMD caused the exception 				 */
block|i = SIGFPE; 				ucode =
comment|/*a0*/
block|0;
comment|/* exception summary */
block|break; 			}
endif|#
directive|endif
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
comment|/*a0*/
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"bad fpswa return code %lx"
argument_list|,
name|fpswa_ret
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|IA64_VEC_FLOATING_POINT_TRAP
case|:
block|{
name|FP_STATE
name|fp_state
decl_stmt|;
name|FPSWA_RET
name|fpswa_ret
decl_stmt|;
name|FPSWA_BUNDLE
name|bundle
decl_stmt|;
comment|/* Always fatal in kernel.  Should never happen. */
if|if
condition|(
operator|!
name|user
condition|)
goto|goto
name|dopanic
goto|;
if|if
condition|(
name|fpswa_interface
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|framep
operator|->
name|tf_cr_iip
operator|)
argument_list|,
operator|&
name|bundle
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|=
name|SIGBUS
expr_stmt|;
comment|/* EFAULT, basically */
name|ucode
operator|=
comment|/*a0*/
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* f6-f15 are saved in exception_save */
name|fp_state
operator|.
name|bitmask_low64
operator|=
literal|0xffc0
expr_stmt|;
comment|/* bits 6 - 15 */
name|fp_state
operator|.
name|bitmask_high64
operator|=
literal|0x0
expr_stmt|;
name|fp_state
operator|.
name|fp_low_preserved
operator|=
name|NULL
expr_stmt|;
name|fp_state
operator|.
name|fp_low_volatile
operator|=
name|framep
operator|->
name|tf_f
expr_stmt|;
name|fp_state
operator|.
name|fp_high_preserved
operator|=
name|NULL
expr_stmt|;
name|fp_state
operator|.
name|fp_high_volatile
operator|=
name|NULL
expr_stmt|;
comment|/* The docs are unclear.  Is Fpswa reentrant? */
name|fpswa_ret
operator|=
name|fpswa_interface
operator|->
name|Fpswa
argument_list|(
literal|0
argument_list|,
operator|&
name|bundle
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_ipsr
argument_list|,
operator|&
name|framep
operator|->
name|tf_ar_fpsr
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_isr
argument_list|,
operator|&
name|framep
operator|->
name|tf_pr
argument_list|,
operator|&
name|framep
operator|->
name|tf_cr_ifs
argument_list|,
operator|&
name|fp_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|==
literal|0
condition|)
block|{
comment|/* fixed */
comment|/* 			 * should we increment iip like the fault case? 			 * or has fpswa done something like normalizing a 			 * register so that we should just rerun it? 			 */
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"FATAL: FPSWA err1 %lx, err2 %lx, err3 %lx\n"
argument_list|,
name|fpswa_ret
operator|.
name|err1
argument_list|,
name|fpswa_ret
operator|.
name|err2
argument_list|,
name|fpswa_ret
operator|.
name|err3
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"fpswa fatal error on fp trap"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fpswa_ret
operator|.
name|status
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
comment|/*a0*/
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"bad fpswa return code %lx"
argument_list|,
name|fpswa_ret
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|IA64_VEC_DISABLED_FP
case|:
comment|/* 		 * on exit from the kernel, if thread == fpcurthread, 		 * FP is enabled. 		 */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
operator|==
name|td
condition|)
block|{
name|printf
argument_list|(
literal|"trap: fp disabled for fpcurthread == %p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|ia64_fpstate_switch
argument_list|(
name|td
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|IA64_VEC_PAGE_NOT_PRESENT
case|:
case|case
name|IA64_VEC_INST_ACCESS_RIGHTS
case|:
case|case
name|IA64_VEC_DATA_ACCESS_RIGHTS
case|:
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|va
operator|=
name|framep
operator|->
name|tf_cr_ifa
expr_stmt|;
comment|/* 		 * If it was caused by fuswintr or suswintr, just punt. Note 		 * that we check the faulting address against the address 		 * accessed by [fs]uswintr, in case another fault happens when 		 * they are running. 		 */
if|if
condition|(
operator|!
name|user
operator|&&
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_accessaddr
operator|==
name|va
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
operator|(
name|unsigned
name|long
operator|)
name|fswintrberr
condition|)
block|{
name|framep
operator|->
name|tf_cr_iip
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
comment|/* 			 * Don't allow user-mode faults for kernel virtual 			 * addresses 			 */
if|if
condition|(
name|user
condition|)
goto|goto
name|no_fault_in
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
name|vm
operator|=
operator|(
name|p
operator|!=
name|NULL
operator|)
condition|?
name|p
operator|->
name|p_vmspace
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|no_fault_in
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|framep
operator|->
name|tf_cr_isr
operator|&
name|IA64_ISR_X
condition|)
name|ftype
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|framep
operator|->
name|tf_cr_isr
operator|&
name|IA64_ISR_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 			 * Keep swapout from messing with us during this 			 * critical time. 			 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't have to worry about process locking or 			 * stacks in the kernel. 			 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|no_fault_in
label|:
if|if
condition|(
operator|!
name|user
condition|)
block|{
comment|/* Check for copyin/copyout fault. */
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
literal|0
condition|)
block|{
name|framep
operator|->
name|tf_cr_iip
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|va
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
case|case
name|IA64_VEC_SINGLE_STEP_TRAP
case|:
case|case
name|IA64_VEC_DEBUG
case|:
case|case
name|IA64_VEC_TAKEN_BRANCH_TRAP
case|:
case|case
name|IA64_VEC_BREAK
case|:
comment|/* 		 * These are always fatal in kernel, and should never happen. 		 */
if|if
condition|(
operator|!
name|user
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 			 * ...unless, of course, DDB is configured. 			 */
if|if
condition|(
name|kdb_trap
argument_list|(
name|vector
argument_list|,
name|framep
argument_list|)
condition|)
return|return;
comment|/* 			 * If we get here, DDB did _not_ handle the 			 * trap, and we need to PANIC! 			 */
endif|#
directive|endif
goto|goto
name|dopanic
goto|;
block|}
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|IA64_VEC_GENERAL_EXCEPTION
case|:
if|if
condition|(
name|user
condition|)
block|{
name|ucode
operator|=
name|vector
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
goto|goto
name|dopanic
goto|;
case|case
name|IA64_VEC_UNSUPP_DATA_REFERENCE
case|:
case|case
name|IA64_VEC_LOWER_PRIVILEGE_TRANSFER
case|:
if|if
condition|(
name|user
condition|)
block|{
name|ucode
operator|=
name|vector
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
block|}
goto|goto
name|dopanic
goto|;
case|case
name|IA64_VEC_IA32_EXCEPTION
case|:
block|{
name|u_int64_t
name|isr
init|=
name|framep
operator|->
name|tf_cr_isr
decl_stmt|;
switch|switch
condition|(
operator|(
name|isr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
condition|)
block|{
case|case
name|IA32_EXCEPTION_DIVIDE
case|:
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_DEBUG
case|:
case|case
name|IA32_EXCEPTION_BREAK
case|:
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_OVERFLOW
case|:
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_BOUND
case|:
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_DNA
case|:
name|ucode
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_NOT_PRESENT
case|:
case|case
name|IA32_EXCEPTION_STACK_FAULT
case|:
case|case
name|IA32_EXCEPTION_GPFAULT
case|:
name|ucode
operator|=
operator|(
name|isr
operator|&
literal|0xffff
operator|)
operator|+
name|BUS_SEGM_FAULT
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_FPERROR
case|:
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_ALIGNMENT_CHECK
case|:
name|ucode
operator|=
name|framep
operator|->
name|tf_cr_ifa
expr_stmt|;
comment|/* VA */
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
case|case
name|IA32_EXCEPTION_STREAMING_SIMD
case|:
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
default|default:
goto|goto
name|dopanic
goto|;
block|}
break|break;
block|}
case|case
name|IA64_VEC_IA32_INTERRUPT
case|:
comment|/* 		 * INT n instruction - probably a syscall. 		 */
if|if
condition|(
operator|(
operator|(
name|framep
operator|->
name|tf_cr_isr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0x80
condition|)
block|{
name|ia32_syscall
argument_list|(
name|framep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|ucode
operator|=
operator|(
name|framep
operator|->
name|tf_cr_isr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
case|case
name|IA64_VEC_IA32_INTERCEPT
case|:
comment|/* 		 * Maybe need to emulate ia32 instruction. 		 */
goto|goto
name|dopanic
goto|;
default|default:
goto|goto
name|dopanic
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|vector
argument_list|,
name|imm
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|user
condition|)
block|{
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
name|dopanic
label|:
name|printtrap
argument_list|(
name|vector
argument_list|,
name|imm
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* XXX dump registers */
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|vector
argument_list|,
name|framep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a system call.  *  * System calls are strange beasts.  They are passed the syscall number  * in r15, and the arguments in the registers (as normal).  They return  * an error flag in r10 (if r10 != 0 on return, the syscall had an error),  * and the return value (if any) in r8 and r9.  *  * The assembly stub takes care of moving the call number into a register  * we can get to, and moves all of the argument registers into a stack   * buffer.  On return, it restores r8-r10 from the frame before  * returning to the user process.   */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|int
name|code
parameter_list|,
name|u_int64_t
modifier|*
name|args
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
block|{
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|oldip
decl_stmt|,
name|oldri
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Skip past the break instruction. Remember old address in case 	 * we have to restart. 	 */
name|oldip
operator|=
name|framep
operator|->
name|tf_cr_iip
expr_stmt|;
name|oldri
operator|=
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_RI
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|+=
name|IA64_PSR_RI_1
expr_stmt|;
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_RI
operator|)
operator|>
name|IA64_PSR_RI_2
condition|)
block|{
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|framep
operator|->
name|tf_cr_iip
operator|+=
literal|16
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ia64_fpstate_check
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* (*p->p_sysent->sv_prepsyscall)(framep, args,&code,&params); */
name|panic
argument_list|(
literal|"prepsyscall"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * syscall() and __syscall() are handled the same on 		 * the ia64, as everything is 64-bit aligned, anyway. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
comment|/* 	 * Try to run the syscall without Giant if the syscall is MP safe. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R9
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|framep
operator|->
name|tf_cr_iip
operator|=
name|oldip
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|=
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
operator|~
name|IA64_PSR_RI
operator|)
operator||
name|oldri
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|error
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
comment|/* 	 * Release Giant if we had to get it. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<i386/include/psl.h>
end_include

begin_function
specifier|static
name|void
name|ia32_syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
block|{
name|caddr_t
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|register_t
name|orig_eflags
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|u_int32_t
name|args
index|[
literal|8
index|]
decl_stmt|;
name|u_int64_t
name|args64
index|[
literal|8
index|]
decl_stmt|;
name|u_int
name|code
decl_stmt|;
comment|/* 	 * note: PCPU_LAZY_INC() can only be used if we can afford 	 * occassional inaccuracy in the count. 	 */
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|params
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|framep
operator|->
name|tf_r
index|[
name|FRAME_SP
index|]
operator|&
operator|(
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|code
operator|=
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
expr_stmt|;
comment|/* eax */
name|orig_eflags
operator|=
name|ia64_get_eflag
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* 		 * The prep code is MP aware. 		 */
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
call|)
argument_list|(
name|framep
argument_list|,
name|args
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need to check if this is a 32 bit or 64 bit syscall. 		 * fuword is MP aware. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|fuword32
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Like syscall, but code is a quad, so as to maintain 			 * quad alignment for the rest of the arguments. 			 * We use a 32-bit fetch in case params is not 			 * aligned. 			 */
name|code
operator|=
name|fuword32
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|narg
operator|=
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
expr_stmt|;
comment|/* 	 * copyin and the ktrsyscall()/ktrsysret() code is MP-aware 	 */
if|if
condition|(
name|params
operator|!=
name|NULL
operator|&&
name|narg
operator|!=
literal|0
condition|)
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narg
condition|;
name|i
operator|++
control|)
name|args64
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
name|narg
argument_list|,
name|args64
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try to run the syscall without Giant if the syscall 	 * is MP safe. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
expr_stmt|;
comment|/* edx */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args64
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
comment|/* eax */
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
comment|/* edx */
name|ia64_set_eflag
argument_list|(
name|ia64_get_eflag
argument_list|()
operator|&
operator|~
name|PSL_C
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
comment|/* 		 * Reconstruct pc, assuming lcall $X,y is 7 bytes, 		 * int 0x80 is 2 bytes. XXX Assume int 0x80. 		 */
name|framep
operator|->
name|tf_cr_iip
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|error
expr_stmt|;
name|ia64_set_eflag
argument_list|(
name|ia64_get_eflag
argument_list|()
operator||
name|PSL_C
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Traced syscall. 	 */
if|if
condition|(
operator|(
name|orig_eflags
operator|&
name|PSL_T
operator|)
operator|&&
operator|!
operator|(
name|orig_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
name|ia64_set_eflag
argument_list|(
name|ia64_get_eflag
argument_list|()
operator|&
operator|~
name|PSL_T
argument_list|)
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle reschedule and other end-of-syscall issues 	 */
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
comment|/* 	 * Release Giant if we previously set it. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

