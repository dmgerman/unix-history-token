begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/efi.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<ia64/disasm/disasm.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|print_usertrap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|print_usertrap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|print_usertrap
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|break_syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * EFI-Provided FPSWA interface (Floating Point SoftWare Assist)  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|fpswa_iface
modifier|*
name|fpswa_iface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ia64_vector_names
index|[]
init|=
block|{
literal|"VHPT Translation"
block|,
comment|/* 0 */
literal|"Instruction TLB"
block|,
comment|/* 1 */
literal|"Data TLB"
block|,
comment|/* 2 */
literal|"Alternate Instruction TLB"
block|,
comment|/* 3 */
literal|"Alternate Data TLB"
block|,
comment|/* 4 */
literal|"Data Nested TLB"
block|,
comment|/* 5 */
literal|"Instruction Key Miss"
block|,
comment|/* 6 */
literal|"Data Key Miss"
block|,
comment|/* 7 */
literal|"Dirty-Bit"
block|,
comment|/* 8 */
literal|"Instruction Access-Bit"
block|,
comment|/* 9 */
literal|"Data Access-Bit"
block|,
comment|/* 10 */
literal|"Break Instruction"
block|,
comment|/* 11 */
literal|"External Interrupt"
block|,
comment|/* 12 */
literal|"Reserved 13"
block|,
comment|/* 13 */
literal|"Reserved 14"
block|,
comment|/* 14 */
literal|"Reserved 15"
block|,
comment|/* 15 */
literal|"Reserved 16"
block|,
comment|/* 16 */
literal|"Reserved 17"
block|,
comment|/* 17 */
literal|"Reserved 18"
block|,
comment|/* 18 */
literal|"Reserved 19"
block|,
comment|/* 19 */
literal|"Page Not Present"
block|,
comment|/* 20 */
literal|"Key Permission"
block|,
comment|/* 21 */
literal|"Instruction Access Rights"
block|,
comment|/* 22 */
literal|"Data Access Rights"
block|,
comment|/* 23 */
literal|"General Exception"
block|,
comment|/* 24 */
literal|"Disabled FP-Register"
block|,
comment|/* 25 */
literal|"NaT Consumption"
block|,
comment|/* 26 */
literal|"Speculation"
block|,
comment|/* 27 */
literal|"Reserved 28"
block|,
comment|/* 28 */
literal|"Debug"
block|,
comment|/* 29 */
literal|"Unaligned Reference"
block|,
comment|/* 30 */
literal|"Unsupported Data Reference"
block|,
comment|/* 31 */
literal|"Floating-point Fault"
block|,
comment|/* 32 */
literal|"Floating-point Trap"
block|,
comment|/* 33 */
literal|"Lower-Privilege Transfer Trap"
block|,
comment|/* 34 */
literal|"Taken Branch Trap"
block|,
comment|/* 35 */
literal|"Single Step Trap"
block|,
comment|/* 36 */
literal|"Reserved 37"
block|,
comment|/* 37 */
literal|"Reserved 38"
block|,
comment|/* 38 */
literal|"Reserved 39"
block|,
comment|/* 39 */
literal|"Reserved 40"
block|,
comment|/* 40 */
literal|"Reserved 41"
block|,
comment|/* 41 */
literal|"Reserved 42"
block|,
comment|/* 42 */
literal|"Reserved 43"
block|,
comment|/* 43 */
literal|"Reserved 44"
block|,
comment|/* 44 */
literal|"IA-32 Exception"
block|,
comment|/* 45 */
literal|"IA-32 Intercept"
block|,
comment|/* 46 */
literal|"IA-32 Interrupt"
block|,
comment|/* 47 */
literal|"Reserved 48"
block|,
comment|/* 48 */
literal|"Reserved 49"
block|,
comment|/* 49 */
literal|"Reserved 50"
block|,
comment|/* 50 */
literal|"Reserved 51"
block|,
comment|/* 51 */
literal|"Reserved 52"
block|,
comment|/* 52 */
literal|"Reserved 53"
block|,
comment|/* 53 */
literal|"Reserved 54"
block|,
comment|/* 54 */
literal|"Reserved 55"
block|,
comment|/* 55 */
literal|"Reserved 56"
block|,
comment|/* 56 */
literal|"Reserved 57"
block|,
comment|/* 57 */
literal|"Reserved 58"
block|,
comment|/* 58 */
literal|"Reserved 59"
block|,
comment|/* 59 */
literal|"Reserved 60"
block|,
comment|/* 60 */
literal|"Reserved 61"
block|,
comment|/* 61 */
literal|"Reserved 62"
block|,
comment|/* 62 */
literal|"Reserved 63"
block|,
comment|/* 63 */
literal|"Reserved 64"
block|,
comment|/* 64 */
literal|"Reserved 65"
block|,
comment|/* 65 */
literal|"Reserved 66"
block|,
comment|/* 66 */
literal|"Reserved 67"
block|,
comment|/* 67 */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bitname
block|{
name|uint64_t
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|printbits
parameter_list|(
name|uint64_t
name|mask
parameter_list|,
name|struct
name|bitname
modifier|*
name|bn
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|uint64_t
name|bit
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Handle fields wider than one bit. 		 */
name|bit
operator|=
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|&
operator|~
operator|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|>
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s=%ld"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|mask
operator|&
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|/
name|bit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|psr_bits
index|[]
init|=
block|{
block|{
name|IA64_PSR_BE
block|,
literal|"be"
block|}
block|,
block|{
name|IA64_PSR_UP
block|,
literal|"up"
block|}
block|,
block|{
name|IA64_PSR_AC
block|,
literal|"ac"
block|}
block|,
block|{
name|IA64_PSR_MFL
block|,
literal|"mfl"
block|}
block|,
block|{
name|IA64_PSR_MFH
block|,
literal|"mfh"
block|}
block|,
block|{
name|IA64_PSR_IC
block|,
literal|"ic"
block|}
block|,
block|{
name|IA64_PSR_I
block|,
literal|"i"
block|}
block|,
block|{
name|IA64_PSR_PK
block|,
literal|"pk"
block|}
block|,
block|{
name|IA64_PSR_DT
block|,
literal|"dt"
block|}
block|,
block|{
name|IA64_PSR_DFL
block|,
literal|"dfl"
block|}
block|,
block|{
name|IA64_PSR_DFH
block|,
literal|"dfh"
block|}
block|,
block|{
name|IA64_PSR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_PSR_PP
block|,
literal|"pp"
block|}
block|,
block|{
name|IA64_PSR_DI
block|,
literal|"di"
block|}
block|,
block|{
name|IA64_PSR_SI
block|,
literal|"si"
block|}
block|,
block|{
name|IA64_PSR_DB
block|,
literal|"db"
block|}
block|,
block|{
name|IA64_PSR_LP
block|,
literal|"lp"
block|}
block|,
block|{
name|IA64_PSR_TB
block|,
literal|"tb"
block|}
block|,
block|{
name|IA64_PSR_RT
block|,
literal|"rt"
block|}
block|,
block|{
name|IA64_PSR_CPL
block|,
literal|"cpl"
block|}
block|,
block|{
name|IA64_PSR_IS
block|,
literal|"is"
block|}
block|,
block|{
name|IA64_PSR_MC
block|,
literal|"mc"
block|}
block|,
block|{
name|IA64_PSR_IT
block|,
literal|"it"
block|}
block|,
block|{
name|IA64_PSR_ID
block|,
literal|"id"
block|}
block|,
block|{
name|IA64_PSR_DA
block|,
literal|"da"
block|}
block|,
block|{
name|IA64_PSR_DD
block|,
literal|"dd"
block|}
block|,
block|{
name|IA64_PSR_SS
block|,
literal|"ss"
block|}
block|,
block|{
name|IA64_PSR_RI
block|,
literal|"ri"
block|}
block|,
block|{
name|IA64_PSR_ED
block|,
literal|"ed"
block|}
block|,
block|{
name|IA64_PSR_BN
block|,
literal|"bn"
block|}
block|,
block|{
name|IA64_PSR_IA
block|,
literal|"ia"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printpsr
parameter_list|(
name|uint64_t
name|psr
parameter_list|)
block|{
name|printbits
argument_list|(
name|psr
argument_list|,
name|psr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|psr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|psr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|isr_bits
index|[]
init|=
block|{
block|{
name|IA64_ISR_CODE
block|,
literal|"code"
block|}
block|,
block|{
name|IA64_ISR_VECTOR
block|,
literal|"vector"
block|}
block|,
block|{
name|IA64_ISR_X
block|,
literal|"x"
block|}
block|,
block|{
name|IA64_ISR_W
block|,
literal|"w"
block|}
block|,
block|{
name|IA64_ISR_R
block|,
literal|"r"
block|}
block|,
block|{
name|IA64_ISR_NA
block|,
literal|"na"
block|}
block|,
block|{
name|IA64_ISR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_ISR_RS
block|,
literal|"rs"
block|}
block|,
block|{
name|IA64_ISR_IR
block|,
literal|"ir"
block|}
block|,
block|{
name|IA64_ISR_NI
block|,
literal|"ni"
block|}
block|,
block|{
name|IA64_ISR_SO
block|,
literal|"so"
block|}
block|,
block|{
name|IA64_ISR_EI
block|,
literal|"ei"
block|}
block|,
block|{
name|IA64_ISR_ED
block|,
literal|"ed"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printisr
parameter_list|(
name|uint64_t
name|isr
parameter_list|)
block|{
name|printbits
argument_list|(
name|isr
argument_list|,
name|isr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|isr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|isr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printtrap
parameter_list|(
name|int
name|vector
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
name|isfatal
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s trap (cpu %d):\n"
argument_list|,
name|isfatal
condition|?
literal|"fatal"
else|:
literal|"handled"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    trap vector = 0x%x (%s)\n"
argument_list|,
name|vector
argument_list|,
name|ia64_vector_names
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.iip      = 0x%lx\n"
argument_list|,
name|tf
operator|->
name|tf_special
operator|.
name|iip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ipsr     = 0x%lx ("
argument_list|,
name|tf
operator|->
name|tf_special
operator|.
name|psr
argument_list|)
expr_stmt|;
name|printpsr
argument_list|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.isr      = 0x%lx ("
argument_list|,
name|tf
operator|->
name|tf_special
operator|.
name|isr
argument_list|)
expr_stmt|;
name|printisr
argument_list|(
name|tf
operator|->
name|tf_special
operator|.
name|isr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ifa      = 0x%lx\n"
argument_list|,
name|tf
operator|->
name|tf_special
operator|.
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_IS
condition|)
block|{
name|printf
argument_list|(
literal|"    ar.cflg     = 0x%lx\n"
argument_list|,
name|ia64_get_cflg
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ar.csd      = 0x%lx\n"
argument_list|,
name|ia64_get_csd
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ar.ssd      = 0x%lx\n"
argument_list|,
name|ia64_get_ssd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    curthread   = %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"        pid = %d, comm = %s\n"
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We got a trap caused by a break instruction and the immediate was 0.  * This indicates that we may have a break.b with some non-zero immediate.  * The break.b doesn't cause the immediate to be put in cr.iim.  Hence,  * we need to disassemble the bundle and return the immediate found there.  * This may be a 0 value anyway.  Return 0 for any error condition.  This  * will result in a SIGILL, which is pretty much the best thing to do.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|trap_decode_break
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|asm_bundle
name|bundle
decl_stmt|;
name|struct
name|asm_inst
modifier|*
name|inst
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|asm_decode
argument_list|(
name|tf
operator|->
name|tf_special
operator|.
name|iip
argument_list|,
operator|&
name|bundle
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|slot
operator|=
operator|(
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_RI
operator|)
operator|==
name|IA64_PSR_RI_0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_RI
operator|)
operator|==
name|IA64_PSR_RI_1
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|inst
operator|=
name|bundle
operator|.
name|b_inst
operator|+
name|slot
expr_stmt|;
comment|/* 	 * Sanity checking: It must be a break instruction and the operand 	 * that has the break value must be an immediate. 	 */
if|if
condition|(
name|inst
operator|->
name|i_op
operator|!=
name|ASM_OP_BREAK
operator|||
name|inst
operator|->
name|i_oper
index|[
literal|1
index|]
operator|.
name|o_type
operator|!=
name|ASM_OPER_IMM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|inst
operator|->
name|i_oper
index|[
literal|1
index|]
operator|.
name|o_value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|trap_panic
parameter_list|(
name|int
name|vector
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|printtrap
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|,
literal|1
argument_list|,
name|TRAPF_USERMODE
argument_list|(
name|tf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_trap
argument_list|(
name|vector
argument_list|,
literal|0
argument_list|,
name|tf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|int
name|do_ast
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
while|while
condition|(
name|curthread
operator|->
name|td_flags
operator|&
operator|(
name|TDF_ASTPENDING
operator||
name|TDF_NEEDRESCHED
operator|)
condition|)
block|{
name|enable_intr
argument_list|()
expr_stmt|;
name|ast
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Keep interrupts disabled. We return r10 as a favor to the EPC 	 * syscall code so that it can quicky determine if the syscall 	 * needs to be restarted or not. 	 */
return|return
operator|(
name|tf
operator|->
name|tf_scratch
operator|.
name|gr10
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from exception.s to handle most types of processor traps.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|int
name|vector
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|uint64_t
name|ucode
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sig
decl_stmt|,
name|user
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|user
operator|=
name|TRAPF_USERMODE
argument_list|(
name|tf
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|PCPU_LAZY_INC
argument_list|(
name|cnt
operator|.
name|v_trap
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|ia64_set_fpsr
argument_list|(
name|IA64_FPSR_DEFAULT
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pticks
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|tf
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_active
condition|)
name|kdb_reenter
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|sig
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|vector
condition|)
block|{
case|case
name|IA64_VEC_VHPT
case|:
comment|/* 		 * This one is tricky. We should hardwire the VHPT, but 		 * don't at this time. I think we're mostly lucky that 		 * the VHPT is mapped. 		 */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_ITLB
case|:
case|case
name|IA64_VEC_DTLB
case|:
case|case
name|IA64_VEC_EXT_INTR
case|:
comment|/* We never call trap() with these vectors. */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_ALT_ITLB
case|:
case|case
name|IA64_VEC_ALT_DTLB
case|:
comment|/* 		 * These should never happen, because regions 0-4 use the 		 * VHPT. If we get one of these it means we didn't program 		 * the region registers correctly. 		 */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_NESTED_DTLB
case|:
comment|/* 		 * We never call trap() with this vector. We may want to 		 * do that in the future in case the nested TLB handler 		 * could not find the translation it needs. In that case 		 * we could switch to a special (hardwired) stack and 		 * come here to produce a nice panic(). 		 */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_IKEY_MISS
case|:
case|case
name|IA64_VEC_DKEY_MISS
case|:
case|case
name|IA64_VEC_KEY_PERMISSION
case|:
comment|/* 		 * We don't use protection keys, so we should never get 		 * these faults. 		 */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_DIRTY_BIT
case|:
case|case
name|IA64_VEC_INST_ACCESS
case|:
case|case
name|IA64_VEC_DATA_ACCESS
case|:
comment|/* 		 * We get here if we read or write to a page of which the 		 * PTE does not have the access bit or dirty bit set and 		 * we can not find the PTE in our datastructures. This 		 * either means we have a stale PTE in the TLB, or we lost 		 * the PTE in our datastructures. 		 */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_BREAK
case|:
if|if
condition|(
name|user
condition|)
block|{
name|ucode
operator|=
operator|(
name|int
operator|)
name|tf
operator|->
name|tf_special
operator|.
name|ifa
operator|&
literal|0x1FFFFF
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
literal|0
condition|)
block|{
comment|/* 				 * A break.b doesn't cause the immediate to be 				 * stored in cr.iim (and saved in the TF in 				 * tf_special.ifa).  We need to decode the 				 * instruction to find out what the immediate 				 * was.  Note that if the break instruction 				 * didn't happen to be a break.b, but any 				 * other break with an immediate of 0, we 				 * will do unnecessary work to get the value 				 * we already had.  Not an issue, because a 				 * break 0 is invalid. 				 */
name|ucode
operator|=
name|trap_decode_break
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ucode
operator|<
literal|0x80000
condition|)
block|{
comment|/* Software interrupts. */
switch|switch
condition|(
name|ucode
condition|)
block|{
case|case
literal|0
case|:
comment|/* Unknown error. */
name|sig
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Integer divide by zero. */
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Integer overflow. */
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Range check/bounds check. */
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Decimal overflow. */
case|case
literal|7
case|:
comment|/* Decimal divide by zero. */
case|case
literal|8
case|:
comment|/* Packed decimal error. */
case|case
literal|9
case|:
comment|/* Invalid ASCII digit. */
case|case
literal|10
case|:
comment|/* Invalid decimal digit. */
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|FPE_FLTINV
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Null pointer dereference. */
case|case
literal|5
case|:
comment|/* Misaligned data. */
case|case
literal|11
case|:
comment|/* Paragraph stack overflow. */
name|sig
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
default|default:
name|sig
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ucode
operator|<
literal|0x100000
condition|)
block|{
comment|/* Debugger breakpoint. */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_SS
expr_stmt|;
name|sig
operator|=
name|SIGTRAP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucode
operator|==
literal|0x100000
condition|)
block|{
name|break_syscall
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return;
comment|/* do_ast() already called. */
block|}
elseif|else
if|if
condition|(
name|ucode
operator|==
literal|0x180000
condition|)
block|{
name|mcontext_t
name|mc
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tf
operator|->
name|tf_scratch
operator|.
name|gr8
argument_list|,
operator|&
name|mc
argument_list|,
sizeof|sizeof
argument_list|(
name|mc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|set_mcontext
argument_list|(
name|td
argument_list|,
operator|&
name|mc
argument_list|)
expr_stmt|;
return|return;
comment|/* Don't call do_ast()!!! */
block|}
name|sig
operator|=
name|SIGSEGV
expr_stmt|;
name|ucode
operator|=
name|tf
operator|->
name|tf_scratch
operator|.
name|gr8
expr_stmt|;
block|}
else|else
name|sig
operator|=
name|SIGILL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
name|vector
argument_list|,
literal|0
argument_list|,
name|tf
argument_list|)
condition|)
return|return;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
else|#
directive|else
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|IA64_VEC_PAGE_NOT_PRESENT
case|:
case|case
name|IA64_VEC_INST_ACCESS_RIGHTS
case|:
case|case
name|IA64_VEC_DATA_ACCESS_RIGHTS
case|:
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|tf
operator|->
name|tf_special
operator|.
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAX_ADDRESS
condition|)
block|{
comment|/* 			 * Don't allow user-mode faults for kernel virtual 			 * addresses, including the gateway page. 			 */
if|if
condition|(
name|user
condition|)
goto|goto
name|no_fault_in
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
name|vm
operator|=
operator|(
name|p
operator|!=
name|NULL
operator|)
condition|?
name|p
operator|->
name|p_vmspace
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
goto|goto
name|no_fault_in
goto|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|tf
operator|->
name|tf_special
operator|.
name|isr
operator|&
name|IA64_ISR_X
condition|)
name|ftype
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|tf
operator|->
name|tf_special
operator|.
name|isr
operator|&
name|IA64_ISR_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 			 * Keep swapout from messing with us during this 			 * critical time. 			 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't have to worry about process locking or 			 * stacks in the kernel. 			 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|no_fault_in
label|:
if|if
condition|(
operator|!
name|user
condition|)
block|{
comment|/* Check for copyin/copyout fault. */
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
literal|0
condition|)
block|{
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
name|ucode
operator|=
name|va
expr_stmt|;
name|sig
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
case|case
name|IA64_VEC_GENERAL_EXCEPTION
case|:
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|user
condition|)
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|code
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|isr
operator|&
operator|(
name|IA64_ISR_CODE
operator|&
literal|0xf0ull
operator|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* Illegal Operation Fault. */
name|sig
operator|=
name|ia64_emulate
argument_list|(
name|tf
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sig
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|vector
expr_stmt|;
break|break;
block|}
case|case
name|IA64_VEC_NAT_CONSUMPTION
case|:
case|case
name|IA64_VEC_SPECULATION
case|:
case|case
name|IA64_VEC_UNSUPP_DATA_REFERENCE
case|:
if|if
condition|(
name|user
condition|)
block|{
name|ucode
operator|=
name|vector
expr_stmt|;
name|sig
operator|=
name|SIGILL
expr_stmt|;
block|}
else|else
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_VEC_DISABLED_FP
case|:
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
comment|/* Always fatal in kernel. Should never happen. */
if|if
condition|(
operator|!
name|user
condition|)
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|thr
operator|=
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|==
name|td
condition|)
block|{
comment|/* 			 * Short-circuit handling the trap when this CPU 			 * already holds the high FP registers for this 			 * thread.  We really shouldn't get the trap in the 			 * first place, but since it's only a performance 			 * issue and not a correctness issue, we emit a 			 * message for now, enable the high FP registers and 			 * return. 			 */
name|printf
argument_list|(
literal|"XXX: bogusly disabled high FP regs\n"
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_DFH
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|thr
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|thr
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|thr
operator|->
name|td_pcb
expr_stmt|;
name|save_high_fp
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_high_fp
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_fpcpu
operator|=
name|NULL
expr_stmt|;
name|PCPU_SET
argument_list|(
name|fpcurthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|thr
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|thr
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|td
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|td
operator|->
name|td_pcb
expr_stmt|;
name|pcpu
operator|=
name|pcb
operator|->
name|pcb_fpcpu
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|pcpu
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|td
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|ipi_send
argument_list|(
name|pcpu
argument_list|,
name|IPI_HIGH_FP
argument_list|)
expr_stmt|;
while|while
condition|(
name|pcb
operator|->
name|pcb_fpcpu
operator|==
name|pcpu
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|pcpu
operator|=
name|pcb
operator|->
name|pcb_fpcpu
expr_stmt|;
name|thr
operator|=
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|thr
operator|==
name|NULL
operator|&&
name|pcpu
operator|==
name|NULL
condition|)
block|{
name|restore_high_fp
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_high_fp
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|fpcurthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_fpcpu
operator|=
name|pcpup
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_MFH
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_DFH
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|td
operator|->
name|td_md
operator|.
name|md_highfp_mtx
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|IA64_VEC_DEBUG
case|:
case|case
name|IA64_VEC_SINGLE_STEP_TRAP
case|:
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_SS
expr_stmt|;
if|if
condition|(
operator|!
name|user
condition|)
block|{
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_trap
argument_list|(
name|vector
argument_list|,
literal|0
argument_list|,
name|tf
argument_list|)
condition|)
return|return;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
else|#
directive|else
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sig
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|IA64_VEC_UNALIGNED_REFERENCE
case|:
comment|/* 		 * If user-land, do whatever fixups, printing, and 		 * signalling is appropriate (based on system-wide 		 * and per-process unaligned-access-handling flags). 		 */
if|if
condition|(
name|user
condition|)
block|{
name|sig
operator|=
name|unaligned_fixup
argument_list|(
name|tf
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|ifa
expr_stmt|;
comment|/* VA */
block|}
else|else
block|{
comment|/* Check for copyin/copyout fault. */
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
literal|0
condition|)
block|{
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IA64_VEC_FLOATING_POINT_FAULT
case|:
case|case
name|IA64_VEC_FLOATING_POINT_TRAP
case|:
block|{
name|struct
name|fpswa_bundle
name|bundle
decl_stmt|;
name|struct
name|fpswa_fpctx
name|fpctx
decl_stmt|;
name|struct
name|fpswa_ret
name|ret
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
name|u_long
name|fault
decl_stmt|;
comment|/* Always fatal in kernel. Should never happen. */
if|if
condition|(
operator|!
name|user
condition|)
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpswa_iface
operator|==
name|NULL
condition|)
block|{
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ip
operator|=
operator|(
name|char
operator|*
operator|)
name|tf
operator|->
name|tf_special
operator|.
name|iip
expr_stmt|;
if|if
condition|(
name|vector
operator|==
name|IA64_VEC_FLOATING_POINT_TRAP
operator|&&
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_RI
operator|)
operator|==
literal|0
condition|)
name|ip
operator|-=
literal|16
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ip
argument_list|,
operator|&
name|bundle
argument_list|,
sizeof|sizeof
argument_list|(
name|bundle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sig
operator|=
name|SIGBUS
expr_stmt|;
comment|/* EFAULT, basically */
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* f6-f15 are saved in exception_save */
name|fpctx
operator|.
name|mask_low
operator|=
literal|0xffc0
expr_stmt|;
comment|/* bits 6 - 15 */
name|fpctx
operator|.
name|mask_high
operator|=
literal|0
expr_stmt|;
name|fpctx
operator|.
name|fp_low_preserved
operator|=
name|NULL
expr_stmt|;
name|fpctx
operator|.
name|fp_low_volatile
operator|=
operator|&
name|tf
operator|->
name|tf_scratch_fp
operator|.
name|fr6
expr_stmt|;
name|fpctx
operator|.
name|fp_high_preserved
operator|=
name|NULL
expr_stmt|;
name|fpctx
operator|.
name|fp_high_volatile
operator|=
name|NULL
expr_stmt|;
name|fault
operator|=
operator|(
name|vector
operator|==
name|IA64_VEC_FLOATING_POINT_FAULT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 		 * We have the high FP registers disabled while in the 		 * kernel. Enable them for the FPSWA handler only. 		 */
name|ia64_enable_highfp
argument_list|()
expr_stmt|;
comment|/* The docs are unclear.  Is Fpswa reentrant? */
name|ret
operator|=
name|fpswa_iface
operator|->
name|if_fpswa
argument_list|(
name|fault
argument_list|,
operator|&
name|bundle
argument_list|,
operator|&
name|tf
operator|->
name|tf_special
operator|.
name|psr
argument_list|,
operator|&
name|tf
operator|->
name|tf_special
operator|.
name|fpsr
argument_list|,
operator|&
name|tf
operator|->
name|tf_special
operator|.
name|isr
argument_list|,
operator|&
name|tf
operator|->
name|tf_special
operator|.
name|pr
argument_list|,
operator|&
name|tf
operator|->
name|tf_special
operator|.
name|cfm
argument_list|,
operator|&
name|fpctx
argument_list|)
expr_stmt|;
name|ia64_disable_highfp
argument_list|()
expr_stmt|;
comment|/* 		 * Update ipsr and iip to next instruction. We only 		 * have to do that for faults. 		 */
if|if
condition|(
name|fault
operator|&&
operator|(
name|ret
operator|.
name|status
operator|==
literal|0
operator|||
operator|(
name|ret
operator|.
name|status
operator|&
literal|2
operator|)
operator|)
condition|)
block|{
name|int
name|ei
decl_stmt|;
name|ei
operator|=
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|isr
operator|>>
literal|41
operator|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|ei
operator|==
literal|0
condition|)
block|{
comment|/* no template for this case */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator||=
name|IA64_ISR_EI_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ei
operator|==
literal|1
condition|)
block|{
comment|/* MFI or MFB */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator||=
name|IA64_ISR_EI_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ei
operator|==
literal|2
condition|)
block|{
comment|/* MMF */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_ISR_EI
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|+=
literal|0x10
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|.
name|status
operator|==
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"FATAL: FPSWA err1 %lx, err2 %lx, err3 %lx\n"
argument_list|,
name|ret
operator|.
name|err1
argument_list|,
name|ret
operator|.
name|err2
argument_list|,
name|ret
operator|.
name|err3
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"fpswa fatal error on fp fault"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sig
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
comment|/* XXX exception summary */
break|break;
block|}
block|}
case|case
name|IA64_VEC_LOWER_PRIVILEGE_TRANSFER
case|:
comment|/* 		 * The lower-privilege transfer trap is used by the EPC 		 * syscall code to trigger re-entry into the kernel when the 		 * process should be single stepped. The problem is that 		 * there's no way to set single stepping directly without 		 * using the rfi instruction. So instead we enable the 		 * lower-privilege transfer trap and when we get here we 		 * know that the process is about to enter userland (and 		 * has already lowered its privilege). 		 * However, there's another gotcha. When the process has 		 * lowered it's privilege it's still running in the gateway 		 * page. If we enable single stepping, we'll be stepping 		 * the code in the gateway page. In and by itself this is 		 * not a problem, but it's an address debuggers won't know 		 * anything about. Hence, it can only cause confusion. 		 * We know that we need to branch to get out of the gateway 		 * page, so what we do here is enable the taken branch 		 * trap and just let the process continue. When we branch 		 * out of the gateway page we'll get back into the kernel 		 * and then we enable single stepping. 		 * Since this a rather round-about way of enabling single 		 * stepping, don't make things complicated even more by 		 * calling userret() and do_ast(). We do that later... 		 */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_LP
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator||=
name|IA64_PSR_TB
expr_stmt|;
return|return;
case|case
name|IA64_VEC_TAKEN_BRANCH_TRAP
case|:
comment|/* 		 * Don't assume there aren't any branches other than the 		 * branch that takes us out of the gateway page. Check the 		 * iip and raise SIGTRAP only when it's an user address. 		 */
if|if
condition|(
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|>=
name|VM_MAX_ADDRESS
condition|)
return|return;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_TB
expr_stmt|;
name|sig
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|IA64_VEC_IA32_EXCEPTION
case|:
case|case
name|IA64_VEC_IA32_INTERCEPT
case|:
case|case
name|IA64_VEC_IA32_INTERRUPT
case|:
name|sig
operator|=
name|SIGEMT
expr_stmt|;
name|ucode
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|iip
expr_stmt|;
break|break;
default|default:
comment|/* Reserved vectors get here. Should never happen of course. */
name|trap_panic
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|sig
operator|!=
literal|0
argument_list|,
operator|(
literal|"foo"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_usertrap
condition|)
name|printtrap
argument_list|(
name|vector
argument_list|,
name|tf
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|ksiginfo_init
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|sig
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|ucode
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|user
condition|)
block|{
name|userret
argument_list|(
name|td
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|do_ast
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Handle break instruction based system calls.  */
end_comment

begin_function
name|void
name|break_syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|uint64_t
modifier|*
name|bsp
decl_stmt|,
modifier|*
name|tfp
decl_stmt|;
name|uint64_t
name|iip
decl_stmt|,
name|psr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nargs
decl_stmt|;
comment|/* Save address of break instruction. */
name|iip
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|iip
expr_stmt|;
name|psr
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|psr
expr_stmt|;
comment|/* Advance to the next instruction. */
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|+=
name|IA64_PSR_RI_1
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_RI
operator|)
operator|>
name|IA64_PSR_RI_2
condition|)
block|{
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|+=
literal|16
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
block|}
comment|/* 	 * Copy the arguments on the register stack into the trapframe 	 * to avoid having interleaved NaT collections. 	 */
name|tfp
operator|=
operator|&
name|tf
operator|->
name|tf_scratch
operator|.
name|gr16
expr_stmt|;
name|nargs
operator|=
name|tf
operator|->
name|tf_special
operator|.
name|cfm
operator|&
literal|0x7f
expr_stmt|;
name|bsp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|curthread
operator|->
name|td_kstack
operator|+
name|tf
operator|->
name|tf_special
operator|.
name|ndirty
operator|+
operator|(
name|tf
operator|->
name|tf_special
operator|.
name|bspstore
operator|&
literal|0x1ffUL
operator|)
operator|)
expr_stmt|;
name|bsp
operator|-=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|bsp
operator|&
literal|0x1ff
operator|)
operator|<
operator|(
name|nargs
operator|<<
literal|3
operator|)
operator|)
condition|?
operator|(
name|nargs
operator|+
literal|1
operator|)
else|:
name|nargs
expr_stmt|;
while|while
condition|(
name|nargs
operator|--
condition|)
block|{
operator|*
name|tfp
operator|++
operator|=
operator|*
name|bsp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|bsp
operator|&
literal|0x1ff
operator|)
operator|==
literal|0x1f8
condition|)
name|bsp
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|syscall
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|tf
operator|->
name|tf_special
operator|.
name|iip
operator|=
name|iip
expr_stmt|;
name|tf
operator|->
name|tf_special
operator|.
name|psr
operator|=
name|psr
expr_stmt|;
block|}
name|do_ast
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a system call.  *  * See syscall.s for details as to how we get here. In order to support  * the ERESTART case, we return the error to our caller. They deal with  * the hairy details.  */
end_comment

begin_function
name|int
name|syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|uint64_t
modifier|*
name|args
decl_stmt|;
name|int
name|code
decl_stmt|,
name|error
decl_stmt|;
name|ia64_set_fpsr
argument_list|(
name|IA64_FPSR_DEFAULT
argument_list|)
expr_stmt|;
name|code
operator|=
name|tf
operator|->
name|tf_scratch
operator|.
name|gr15
expr_stmt|;
name|args
operator|=
operator|&
name|tf
operator|->
name|tf_scratch
operator|.
name|gr16
expr_stmt|;
name|PCPU_LAZY_INC
argument_list|(
name|cnt
operator|.
name|v_syscall
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|tf
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|td
operator|->
name|td_pticks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KSE
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SA
condition|)
name|thread_user_enter
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* (*p->p_sysent->sv_prepsyscall)(tf, args,&code,&params); */
name|panic
argument_list|(
literal|"prepsyscall"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * syscall() and __syscall() are handled the same on 		 * the ia64, as everything is 64-bit aligned, anyway. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_SYSC
argument_list|,
literal|"syscall enter thread %p pid %d proc %s code %d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tf
operator|->
name|tf_scratch
operator|.
name|gr10
operator|=
name|EJUSTRETURN
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCE
argument_list|)
expr_stmt|;
name|AUDIT_SYSCALL_ENTER
argument_list|(
name|code
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|AUDIT_SYSCALL_EXIT
argument_list|(
name|error
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EJUSTRETURN
condition|)
block|{
comment|/* 		 * Save the "raw" error code in r10. We use this to handle 		 * syscall restarts (see do_ast()). 		 */
name|tf
operator|->
name|tf_scratch
operator|.
name|gr10
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|tf
operator|->
name|tf_scratch
operator|.
name|gr8
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|tf
operator|->
name|tf_scratch
operator|.
name|gr9
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
name|ERESTART
condition|)
block|{
if|if
condition|(
name|error
operator|<
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
comment|/* 			 * Translated error codes are returned in r8. User 			 * processes use the translated error code. 			 */
name|tf
operator|->
name|tf_scratch
operator|.
name|gr8
operator|=
name|error
expr_stmt|;
block|}
block|}
name|td
operator|->
name|td_syscalls
operator|++
expr_stmt|;
comment|/* 	 * Check for misbehavior. 	 */
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"System call %s returning"
argument_list|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|==
literal|0
argument_list|,
operator|(
literal|"System call %s returning in a critical section"
operator|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_locks
operator|==
literal|0
argument_list|,
operator|(
literal|"System call %s returning with %d locks held"
operator|,
operator|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|SYS_MAXSYSCALL
operator|)
condition|?
name|syscallnames
index|[
name|code
index|]
else|:
literal|"???"
operator|,
name|td
operator|->
name|td_locks
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Handle reschedule and other end-of-syscall issues 	 */
name|userret
argument_list|(
name|td
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_SYSC
argument_list|,
literal|"syscall exit thread %p pid %d proc %s code %d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|PTRACESTOP_SC
argument_list|(
name|p
argument_list|,
name|td
argument_list|,
name|S_PT_SCX
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

