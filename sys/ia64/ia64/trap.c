begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* From: src/sys/alpha/alpha/trap.c,v 1.33 */
end_comment

begin_comment
comment|/* $NetBSD: trap.c,v 1.31 1998/03/26 02:21:46 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ia64_vector_names
index|[]
init|=
block|{
literal|"VHPT Translation"
block|,
comment|/* 0 */
literal|"Instruction TLB"
block|,
comment|/* 1 */
literal|"Data TLB"
block|,
comment|/* 2 */
literal|"Alternate Instruction TLB"
block|,
comment|/* 3 */
literal|"Alternate Data TLB"
block|,
comment|/* 4 */
literal|"Data Nested TLB"
block|,
comment|/* 5 */
literal|"Instruction Key Miss"
block|,
comment|/* 6 */
literal|"Data Key Miss"
block|,
comment|/* 7 */
literal|"Dirty-Bit"
block|,
comment|/* 8 */
literal|"Instruction Access-Bit"
block|,
comment|/* 9 */
literal|"Data Access-Bit"
block|,
comment|/* 10 */
literal|"Break Instruction"
block|,
comment|/* 11 */
literal|"External Interrupt"
block|,
comment|/* 12 */
literal|"Reserved 13"
block|,
comment|/* 13 */
literal|"Reserved 14"
block|,
comment|/* 14 */
literal|"Reserved 15"
block|,
comment|/* 15 */
literal|"Reserved 16"
block|,
comment|/* 16 */
literal|"Reserved 17"
block|,
comment|/* 17 */
literal|"Reserved 18"
block|,
comment|/* 18 */
literal|"Reserved 19"
block|,
comment|/* 19 */
literal|"Page Not Present"
block|,
comment|/* 20 */
literal|"Key Permission"
block|,
comment|/* 21 */
literal|"Instruction Access Rights"
block|,
comment|/* 22 */
literal|"Data Access Rights"
block|,
comment|/* 23 */
literal|"General Exception"
block|,
comment|/* 24 */
literal|"Disabled FP-Register"
block|,
comment|/* 25 */
literal|"NaT Consumption"
block|,
comment|/* 26 */
literal|"Speculation"
block|,
comment|/* 27 */
literal|"Reserved 28"
block|,
comment|/* 28 */
literal|"Debug"
block|,
comment|/* 29 */
literal|"Unaligned Reference"
block|,
comment|/* 30 */
literal|"Unsupported Data Reference"
block|,
comment|/* 31 */
literal|"Floating-point Fault"
block|,
comment|/* 32 */
literal|"Floating-point Trap"
block|,
comment|/* 33 */
literal|"Lower-Privilege Transfer Trap"
block|,
comment|/* 34 */
literal|"Taken Branch Trap"
block|,
comment|/* 35 */
literal|"Single Step Trap"
block|,
comment|/* 36 */
literal|"Reserved 37"
block|,
comment|/* 37 */
literal|"Reserved 38"
block|,
comment|/* 38 */
literal|"Reserved 39"
block|,
comment|/* 39 */
literal|"Reserved 40"
block|,
comment|/* 40 */
literal|"Reserved 41"
block|,
comment|/* 41 */
literal|"Reserved 42"
block|,
comment|/* 42 */
literal|"Reserved 43"
block|,
comment|/* 43 */
literal|"Reserved 44"
block|,
comment|/* 44 */
literal|"IA-32 Exception"
block|,
comment|/* 45 */
literal|"IA-32 Intercept"
block|,
comment|/* 46 */
literal|"IA-32 Interrupt"
block|,
comment|/* 47 */
literal|"Reserved 48"
block|,
comment|/* 48 */
literal|"Reserved 49"
block|,
comment|/* 49 */
literal|"Reserved 50"
block|,
comment|/* 50 */
literal|"Reserved 51"
block|,
comment|/* 51 */
literal|"Reserved 52"
block|,
comment|/* 52 */
literal|"Reserved 53"
block|,
comment|/* 53 */
literal|"Reserved 54"
block|,
comment|/* 54 */
literal|"Reserved 55"
block|,
comment|/* 55 */
literal|"Reserved 56"
block|,
comment|/* 56 */
literal|"Reserved 57"
block|,
comment|/* 57 */
literal|"Reserved 58"
block|,
comment|/* 58 */
literal|"Reserved 59"
block|,
comment|/* 59 */
literal|"Reserved 60"
block|,
comment|/* 60 */
literal|"Reserved 61"
block|,
comment|/* 61 */
literal|"Reserved 62"
block|,
comment|/* 62 */
literal|"Reserved 63"
block|,
comment|/* 63 */
literal|"Reserved 64"
block|,
comment|/* 64 */
literal|"Reserved 65"
block|,
comment|/* 65 */
literal|"Reserved 66"
block|,
comment|/* 66 */
literal|"Reserved 67"
block|,
comment|/* 67 */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bitname
block|{
name|u_int64_t
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|printbits
parameter_list|(
name|u_int64_t
name|mask
parameter_list|,
name|struct
name|bitname
modifier|*
name|bn
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|u_int64_t
name|bit
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Handle fields wider than one bit. 		 */
name|bit
operator|=
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|&
operator|~
operator|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|>
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s=%ld"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|mask
operator|&
name|bn
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|/
name|bit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bn
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|psr_bits
index|[]
init|=
block|{
block|{
name|IA64_PSR_BE
block|,
literal|"be"
block|}
block|,
block|{
name|IA64_PSR_UP
block|,
literal|"up"
block|}
block|,
block|{
name|IA64_PSR_AC
block|,
literal|"ac"
block|}
block|,
block|{
name|IA64_PSR_MFL
block|,
literal|"mfl"
block|}
block|,
block|{
name|IA64_PSR_MFH
block|,
literal|"mfh"
block|}
block|,
block|{
name|IA64_PSR_IC
block|,
literal|"ic"
block|}
block|,
block|{
name|IA64_PSR_I
block|,
literal|"i"
block|}
block|,
block|{
name|IA64_PSR_PK
block|,
literal|"pk"
block|}
block|,
block|{
name|IA64_PSR_DT
block|,
literal|"dt"
block|}
block|,
block|{
name|IA64_PSR_DFL
block|,
literal|"dfl"
block|}
block|,
block|{
name|IA64_PSR_DFH
block|,
literal|"dfh"
block|}
block|,
block|{
name|IA64_PSR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_PSR_PP
block|,
literal|"pp"
block|}
block|,
block|{
name|IA64_PSR_DI
block|,
literal|"di"
block|}
block|,
block|{
name|IA64_PSR_SI
block|,
literal|"si"
block|}
block|,
block|{
name|IA64_PSR_DB
block|,
literal|"db"
block|}
block|,
block|{
name|IA64_PSR_LP
block|,
literal|"lp"
block|}
block|,
block|{
name|IA64_PSR_TB
block|,
literal|"tb"
block|}
block|,
block|{
name|IA64_PSR_RT
block|,
literal|"rt"
block|}
block|,
block|{
name|IA64_PSR_CPL
block|,
literal|"cpl"
block|}
block|,
block|{
name|IA64_PSR_IS
block|,
literal|"is"
block|}
block|,
block|{
name|IA64_PSR_MC
block|,
literal|"mc"
block|}
block|,
block|{
name|IA64_PSR_IT
block|,
literal|"it"
block|}
block|,
block|{
name|IA64_PSR_ID
block|,
literal|"id"
block|}
block|,
block|{
name|IA64_PSR_DA
block|,
literal|"da"
block|}
block|,
block|{
name|IA64_PSR_DD
block|,
literal|"dd"
block|}
block|,
block|{
name|IA64_PSR_SS
block|,
literal|"ss"
block|}
block|,
block|{
name|IA64_PSR_RI
block|,
literal|"ri"
block|}
block|,
block|{
name|IA64_PSR_ED
block|,
literal|"ed"
block|}
block|,
block|{
name|IA64_PSR_BN
block|,
literal|"bn"
block|}
block|,
block|{
name|IA64_PSR_IA
block|,
literal|"ia"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printpsr
parameter_list|(
name|u_int64_t
name|psr
parameter_list|)
block|{
name|printbits
argument_list|(
name|psr
argument_list|,
name|psr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|psr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|psr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|bitname
name|isr_bits
index|[]
init|=
block|{
block|{
name|IA64_ISR_X
block|,
literal|"x"
block|}
block|,
block|{
name|IA64_ISR_W
block|,
literal|"w"
block|}
block|,
block|{
name|IA64_ISR_R
block|,
literal|"r"
block|}
block|,
block|{
name|IA64_ISR_NA
block|,
literal|"na"
block|}
block|,
block|{
name|IA64_ISR_SP
block|,
literal|"sp"
block|}
block|,
block|{
name|IA64_ISR_RS
block|,
literal|"rs"
block|}
block|,
block|{
name|IA64_ISR_IR
block|,
literal|"ir"
block|}
block|,
block|{
name|IA64_ISR_NI
block|,
literal|"ni"
block|}
block|,
block|{
name|IA64_ISR_SO
block|,
literal|"so"
block|}
block|,
block|{
name|IA64_ISR_EI
block|,
literal|"ei"
block|}
block|,
block|{
name|IA64_ISR_ED
block|,
literal|"ed"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printisr
parameter_list|(
name|u_int64_t
name|isr
parameter_list|)
block|{
name|printbits
argument_list|(
name|isr
argument_list|,
name|isr_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|isr_bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|isr_bits
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printtrap
parameter_list|(
name|int
name|vector
parameter_list|,
name|int
name|imm
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|int
name|isfatal
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s trap:\n"
argument_list|,
name|isfatal
condition|?
literal|"fatal"
else|:
literal|"handled"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    trap vector = 0x%x (%s)\n"
argument_list|,
name|vector
argument_list|,
name|ia64_vector_names
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.iip      = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_cr_iip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ipsr     = 0x%lx ("
argument_list|,
name|framep
operator|->
name|tf_cr_ipsr
argument_list|)
expr_stmt|;
name|printpsr
argument_list|(
name|framep
operator|->
name|tf_cr_ipsr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.isr      = 0x%lx ("
argument_list|,
name|framep
operator|->
name|tf_cr_isr
argument_list|)
expr_stmt|;
name|printisr
argument_list|(
name|framep
operator|->
name|tf_cr_isr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.ifa      = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_cr_ifa
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cr.iim      = 0x%x\n"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    curthread   = %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"        pid = %d, comm = %s\n"
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from exception.s to handle most types of processor traps.  * System calls are broken out for efficiency and ASTs are broken out  * to make the code a bit cleaner and more representative of the  * architecture.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|int
name|vector
parameter_list|,
name|int
name|imm
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int64_t
name|ucode
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|user
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
name|user
operator|=
operator|(
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_CPL
operator|)
operator|==
name|IA64_PSR_CPL_USER
operator|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
block|}
else|else
block|{
name|sticks
operator|=
literal|0
expr_stmt|;
comment|/* XXX bogus -Wuninitialized warning */
block|}
switch|switch
condition|(
name|vector
condition|)
block|{
case|case
name|IA64_VEC_UNALIGNED_REFERENCE
case|:
comment|/* 		 * If user-land, do whatever fixups, printing, and 		 * signalling is appropriate (based on system-wide 		 * and per-process unaligned-access-handling flags). 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|unaligned_fixup
argument_list|(
name|framep
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|framep
operator|->
name|tf_cr_ifa
expr_stmt|;
comment|/* VA */
break|break;
block|}
comment|/* 		 * Unaligned access from kernel mode is always an error, 		 * EVEN IF A COPY FAULT HANDLER IS SET! 		 * 		 * It's an error if a copy fault handler is set because 		 * the various routines which do user-initiated copies 		 * do so in a bcopy-like manner.  In other words, the 		 * kernel never assumes that pointers provided by the 		 * user are properly aligned, and so if the kernel 		 * does cause an unaligned access it's a kernel bug. 		 */
goto|goto
name|dopanic
goto|;
case|case
name|IA64_VEC_FLOATING_POINT_FAULT
case|:
case|case
name|IA64_VEC_FLOATING_POINT_TRAP
case|:
comment|/*  		 * If user-land, give a SIGFPE if software completion 		 * is not requested or if the completion fails. 		 */
if|if
condition|(
name|user
condition|)
block|{
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
comment|/*a0*/
literal|0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* Always fatal in kernel.  Should never happen. */
goto|goto
name|dopanic
goto|;
case|case
name|IA64_VEC_DISABLED_FP
case|:
comment|/* 		 * on exit from the kernel, if thread == fpcurthread, 		 * FP is enabled. 		 */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
operator|==
name|td
condition|)
block|{
name|printf
argument_list|(
literal|"trap: fp disabled for fpcurthread == %p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|ia64_fpstate_switch
argument_list|(
name|td
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|IA64_VEC_PAGE_NOT_PRESENT
case|:
case|case
name|IA64_VEC_INST_ACCESS_RIGHTS
case|:
case|case
name|IA64_VEC_DATA_ACCESS_RIGHTS
case|:
block|{
name|vm_offset_t
name|va
init|=
name|framep
operator|->
name|tf_cr_ifa
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_prot_t
name|ftype
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 		 * If it was caused by fuswintr or suswintr, 		 * just punt.  Note that we check the faulting 		 * address against the address accessed by 		 * [fs]uswintr, in case another fault happens 		 * when they are running. 			 */
if|if
condition|(
operator|!
name|user
operator|&&
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
operator|(
name|unsigned
name|long
operator|)
name|fswintrberr
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_accessaddr
operator|==
name|va
condition|)
block|{
name|framep
operator|->
name|tf_cr_iip
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 		 * It is only a kernel address space fault iff: 		 *	1. !user and 		 *	2. pcb_onfault not set or 		 *	3. pcb_onfault set but kernel space data fault 		 * The last can occur during an exec() copyin where the 		 * argument space is lazy-allocated. 		 * 		 * For the purposes of the Linux emulator, we allow 		 * kernel accesses to a small region of the 		 * user stack which the emulator uses to 		 * translate syscall arguments. 		 */
if|if
condition|(
operator|!
name|user
operator|&&
operator|(
operator|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|||
operator|(
name|td
operator|==
name|NULL
operator|)
operator|||
operator|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|va
operator|>=
name|trunc_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
operator|-
name|SPARE_USRSPACE
argument_list|)
operator|&&
name|va
operator|<
name|round_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
argument_list|)
condition|)
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
if|if
condition|(
name|framep
operator|->
name|tf_cr_isr
operator|&
name|IA64_ISR_X
condition|)
name|ftype
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|framep
operator|->
name|tf_cr_isr
operator|&
name|IA64_ISR_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 			 * Keep swapout from messing with us 			 * during this critical time. 			 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 			 * Grow the stack if necessary 			 */
comment|/* grow_stack returns false only if va falls into 			 * a growable stack region and the stack growth 			 * fails.  It returns true if va was not within 			 * a growable stack region, or if the stack  			 * growth succeeded. 			 */
if|if
condition|(
operator|!
name|grow_stack
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
else|else
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't have to worry about process 			 * locking or stacks in the kernel. 			 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this was a stack access we keep track of the 		 * maximum accessed stack size.  Also, if vm_fault 		 * gets a protection failure it is due to accessing 		 * the stack region outside the current limit and 		 * we need to reflect that as an access error. 		 */
if|if
condition|(
name|map
operator|!=
name|kernel_map
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|ia64_btop
argument_list|(
name|round_page
argument_list|(
name|USRSTACK
operator|-
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|va
expr_stmt|;
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
case|case
name|IA64_VEC_SINGLE_STEP_TRAP
case|:
case|case
name|IA64_VEC_DEBUG
case|:
case|case
name|IA64_VEC_TAKEN_BRANCH_TRAP
case|:
case|case
name|IA64_VEC_BREAK
case|:
comment|/* 		 * These are always fatal in kernel, and should never happen. 		 */
if|if
condition|(
operator|!
name|user
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 			 * ...unless, of course, DDB is configured. 			 */
if|if
condition|(
name|kdb_trap
argument_list|(
name|vector
argument_list|,
name|framep
argument_list|)
condition|)
return|return;
comment|/* 			 * If we get here, DDB did _not_ handle the 			 * trap, and we need to PANIC! 			 */
endif|#
directive|endif
goto|goto
name|dopanic
goto|;
block|}
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|IA64_VEC_GENERAL_EXCEPTION
case|:
case|case
name|IA64_VEC_UNSUPP_DATA_REFERENCE
case|:
case|case
name|IA64_VEC_LOWER_PRIVILEGE_TRANSFER
case|:
if|if
condition|(
name|user
condition|)
block|{
name|ucode
operator|=
name|vector
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
block|}
goto|goto
name|dopanic
goto|;
block|}
default|default:
goto|goto
name|dopanic
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|vector
argument_list|,
name|imm
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|user
condition|)
block|{
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
return|return;
name|dopanic
label|:
name|printtrap
argument_list|(
name|vector
argument_list|,
name|imm
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* XXX dump registers */
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|vector
argument_list|,
name|framep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a system call.  *  * System calls are strange beasts.  They are passed the syscall number  * in r15, and the arguments in the registers (as normal).  They return  * an error flag in r10 (if r10 != 0 on return, the syscall had an error),  * and the return value (if any) in r8 and r9.  *  * The assembly stub takes care of moving the call number into a register  * we can get to, and moves all of the argument registers into a stack   * buffer.  On return, it restores r8-r10 from the frame before  * returning to the user process.   */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|int
name|code
parameter_list|,
name|u_int64_t
modifier|*
name|args
parameter_list|,
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|)
block|{
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|oldip
decl_stmt|,
name|oldri
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
comment|/* 	 * Skip past the break instruction. Remember old address in case 	 * we have to restart. 	 */
name|oldip
operator|=
name|framep
operator|->
name|tf_cr_iip
expr_stmt|;
name|oldri
operator|=
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_RI
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|+=
name|IA64_PSR_RI_1
expr_stmt|;
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
name|IA64_PSR_RI
operator|)
operator|>
name|IA64_PSR_RI_2
condition|)
block|{
name|framep
operator|->
name|tf_cr_ipsr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|framep
operator|->
name|tf_cr_iip
operator|+=
literal|16
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|ia64_fpstate_check
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* (*p->p_sysent->sv_prepsyscall)(framep, args,&code,&params); */
name|panic
argument_list|(
literal|"prepsyscall"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * syscall() and __syscall() are handled the same on 		 * the ia64, as everything is 64-bit aligned, anyway. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
comment|/* 	 * Try to run the syscall without Giant if the syscall is MP safe. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R9
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|framep
operator|->
name|tf_cr_iip
operator|=
name|oldip
expr_stmt|;
name|framep
operator|->
name|tf_cr_ipsr
operator|=
operator|(
name|framep
operator|->
name|tf_cr_ipsr
operator|&
operator|~
name|IA64_PSR_RI
operator|)
operator||
name|oldri
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R8
index|]
operator|=
name|error
expr_stmt|;
name|framep
operator|->
name|tf_r
index|[
name|FRAME_R10
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Release Giant if we had to get it. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|ia64_unaligned_print
decl_stmt|,
name|ia64_unaligned_fix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ia64_unaligned_sigbus
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|framep
operator|->
name|tf_cr_ifa
decl_stmt|;
name|int
name|doprint
decl_stmt|,
name|dofix
decl_stmt|,
name|dosigbus
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|uac
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Figure out what actions to take. 	 */
if|if
condition|(
name|td
condition|)
block|{
name|uac
operator|=
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDP_UAC_MASK
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
block|}
else|else
block|{
name|uac
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
name|doprint
operator|=
name|ia64_unaligned_print
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOPRINT
operator|)
expr_stmt|;
name|dofix
operator|=
name|ia64_unaligned_fix
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOFIX
operator|)
expr_stmt|;
name|dosigbus
operator|=
name|ia64_unaligned_sigbus
operator||
operator|(
name|uac
operator|&
name|MDP_UAC_SIGBUS
operator|)
expr_stmt|;
comment|/* 	 * See if the user can access the memory in question. 	 * Even if it's an unknown opcode, SEGV if the access 	 * should have failed. 	 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGSEGV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we're supposed to be noisy, squawk now. 	 */
if|if
condition|(
name|doprint
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|va
argument_list|,
name|td
operator|->
name|td_frame
operator|->
name|tf_cr_iip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we should try to fix it and know how, give it a shot. 	 * 	 * We never allow bad data to be unknowingly used by the 	 * user process.  That is, if we decide not to fix up an 	 * access we cause a SIGBUS rather than letting the user 	 * process go on without warning. 	 * 	 * If we're trying to do a fixup, we assume that things 	 * will be botched.  If everything works out OK,  	 * unaligned_{load,store}_* clears the signal flag. 	 */
name|signal
operator|=
name|SIGBUS
expr_stmt|;
if|if
condition|(
name|dofix
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * XXX not done yet. 		 */
block|}
comment|/* 	 * Force SIGBUS if requested. 	 */
if|if
condition|(
name|dosigbus
condition|)
name|signal
operator|=
name|SIGBUS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|signal
operator|)
return|;
block|}
end_function

end_unit

