begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or its performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for FreeBSD by Stu Grossman.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *  The external function exceptionHandler() is  *  used to attach a specific handler to a specific 386 vector number.  *  It should use the same privilege level it runs at.  It should  *  install it as an interrupt gate so that interrupts are masked  *  while the handler runs.  *  Also, need to assign exceptionHook and oldExceptionHook.  *  *  Because gdb will sometimes write to the stack area to execute function  *  calls, this program cannot rely on using the supervisor stack so it  *  uses its own stack area reserved in the int array remcomStack.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  *    D             detach                                 OK  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_comment
comment|/************************************************************************/
end_comment

begin_function_decl
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|jmp_buf
name|db_jmpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|1500
end_define

begin_comment
comment|/* Create private copies of common functions used by the stub.  This prevents    nasty interactions between app code and the stub (for instance if user steps    into strlen, etc..) */
end_comment

begin_define
define|#
directive|define
name|strlen
value|gdb_strlen
end_define

begin_define
define|#
directive|define
name|strcpy
value|gdb_strcpy
end_define

begin_function
specifier|static
name|int
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|s1
operator|-
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|strcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|dst
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* XXX sio always uses its major with minor 0 no matter what we specify.  */
end_comment

begin_define
define|#
directive|define
name|REMOTE_DEV
value|0
end_define

begin_function
specifier|static
name|int
name|putDebugChar
parameter_list|(
name|int
name|c
parameter_list|)
comment|/* write a single character      */
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getDebugChar
parameter_list|(
name|void
parameter_list|)
comment|/* read and return a single char */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
specifier|static
name|void
name|getpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|xmitcsum
operator|=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>=
name|BUFMAX
condition|)
name|panic
argument_list|(
literal|"kgdb: buffer overflow"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>=
name|BUFMAX
condition|)
name|panic
argument_list|(
literal|"kgdb: buffer overflow"
argument_list|)
expr_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
comment|/*  * This is a non-standard hack to allow use of the serial console for  * operation as well as debugging.  Simply turn on 'remotechat' in gdb.  *  * This extension is not part of the Cygnus protocol, is kinda gross,  * but gets the job done.  */
ifdef|#
directive|ifdef
name|GDB_REMOTE_CHAT
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|db_read_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
name|val
expr_stmt|;
name|db_write_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* convert the memory pointed to by mem into hex, placing result in buf */
end_comment

begin_comment
comment|/* return a pointer to the last char put in buf (null) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mem2hex
parameter_list|(
name|vm_offset_t
name|mem
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|mem
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem */
end_comment

begin_comment
comment|/* return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|vm_offset_t
name|mem
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|ch
operator|+
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|rv
operator|=
name|set_char
argument_list|(
name|mem
operator|++
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this function takes the 386 exception vector and attempts to    translate this number into a unix compatible signal value */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
name|entry
parameter_list|,
name|int
name|code
parameter_list|)
block|{
return|return
name|SIGILL
return|;
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|long
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|>=
literal|0
condition|)
block|{
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
block|}
else|else
break|break;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(sizeof registers)
end_define

begin_define
define|#
directive|define
name|PC
value|64
end_define

begin_define
define|#
directive|define
name|SP
value|30
end_define

begin_define
define|#
directive|define
name|FP
value|15
end_define

begin_define
define|#
directive|define
name|VFP
value|65
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|66
end_define

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  */
end_comment

begin_function
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
name|raw_regs
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int    sigval;   long   addr, length;   char * ptr;   struct alpharegs {     u_int64_t r[32];     u_int64_t f[32];     u_int64_t pc, vfp;   };   static struct alpharegs registers;   int i;    clear_single_step(raw_regs);    bzero(&registers, sizeof registers);
comment|/*    * Map trapframe to registers.    * Ignore float regs for now.    */
block|for (i = 0; i< FRAME_SIZE; i++)     if (tf2gdb[i]>= 0)       registers.r[tf2gdb[i]] = raw_regs->tf_regs[i];   registers.pc = raw_regs->tf_regs[FRAME_PC];
comment|/* reply to host that an exception has occurred */
block|sigval = computeSignal (type, code);   ptr = remcomOutBuffer;    *ptr++ = 'T';   *ptr++ = hexchars[sigval>> 4];   *ptr++ = hexchars[sigval& 0xf];    *ptr++ = hexchars[PC>> 4];   *ptr++ = hexchars[PC& 0xf];   *ptr++ = ':';   ptr = mem2hex ((vm_offset_t)&registers.pc, ptr, 8);   *ptr++ = ';';    *ptr++ = hexchars[FP>> 4];   *ptr++ = hexchars[FP& 0xf];   *ptr++ = ':';   ptr = mem2hex ((vm_offset_t)&registers.r[FP], ptr, 8);   *ptr++ = ';';    *ptr++ = hexchars[SP>> 4];   *ptr++ = hexchars[SP& 0xf];   *ptr++ = ':';   ptr = mem2hex ((vm_offset_t)&registers.r[SP], ptr, 8);   *ptr++ = ';';    *ptr++ = 0;    putpacket (remcomOutBuffer);    while (1)     {       remcomOutBuffer[0] = 0;        getpacket (remcomInBuffer);       switch (remcomInBuffer[0])  	{ 	case '?': 	  remcomOutBuffer[0] = 'S'; 	  remcomOutBuffer[1] = hexchars[sigval>> 4]; 	  remcomOutBuffer[2] = hexchars[sigval % 16]; 	  remcomOutBuffer[3] = 0; 	  break;  	case 'D':
comment|/* detach; say OK and turn off gdb */
block|putpacket(remcomOutBuffer); 	  boothowto&= ~RB_GDB; 	  return;  	case 'k': 	  prom_halt();
comment|/*NOTREACHED*/
block|break;  	case 'g':
comment|/* return the value of the CPU registers */
block|mem2hex ((vm_offset_t)&registers, remcomOutBuffer, NUMREGBYTES); 	  break;  	case 'G':
comment|/* set the value of the CPU registers - return OK */
block|hex2mem (&remcomInBuffer[1], (vm_offset_t)&registers, NUMREGBYTES); 	  strcpy (remcomOutBuffer, "OK"); 	  break;  	case 'P':
comment|/* Set the value of one register */
block|{ 	    long regno;  	    ptr =&remcomInBuffer[1];  	    if (hexToInt (&ptr,&regno)&& *ptr++ == '='&& regno< NUM_REGS) 	      { 		hex2mem (ptr, (vm_offset_t)&registers + regno * 8, 8); 		strcpy(remcomOutBuffer,"OK"); 	      } 	    else 	      strcpy (remcomOutBuffer, "P01"); 	    break; 	  } 	case 'm':
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
block|ptr =&remcomInBuffer[1];  	  if (hexToInt (&ptr,&addr)&& *(ptr++) == ','&& hexToInt (&ptr,&length)) 	    { 	      if (mem2hex((vm_offset_t) addr, remcomOutBuffer, length) == NULL) 		strcpy (remcomOutBuffer, "E03"); 	      break; 	    } 	  else 	    strcpy (remcomOutBuffer, "E01"); 	  break;  	case 'M':
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
block|ptr =&remcomInBuffer[1];  	  if (hexToInt(&ptr,&addr)&& *(ptr++) == ','&& hexToInt(&ptr,&length)&& *(ptr++) == ':') 	    { 	      if (hex2mem(ptr, (vm_offset_t) addr, length) == NULL) 		strcpy (remcomOutBuffer, "E03"); 	      else 		strcpy (remcomOutBuffer, "OK"); 	    } 	  else 	    strcpy (remcomOutBuffer, "E02"); 	  break;
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* sAA..AA   Step one instruction from AA..AA(optional) */
block|case 'c' : 	case 's' :
comment|/* try to read optional parameter, pc unchanged if no parm */
block|ptr =&remcomInBuffer[1]; 	  if (hexToInt(&ptr,&addr)) 	    registers.pc = addr;
comment|/* 	   * Map gdb registers back to trapframe (ignoring fp regs). 	   */
block|for (i = 0; i< NUM_REGS; i++) 	    if (gdb2tf[i]>= 0) 	      raw_regs->tf_regs[gdb2tf[i]] = registers.r[i]; 	  raw_regs->tf_regs[FRAME_PC] = registers.pc;  	  if (remcomInBuffer[0] == 's') 	    if (!set_single_step(raw_regs)) 	      printf("Can't set single step breakpoint\n");  	  return;  	}
comment|/* switch */
comment|/* reply to the request */
block|putpacket (remcomOutBuffer);     }
endif|#
directive|endif
block|}
end_function

end_unit

