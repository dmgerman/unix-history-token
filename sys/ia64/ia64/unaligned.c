begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/inst.h>
end_include

begin_define
define|#
directive|define
name|sign_extend
parameter_list|(
name|imm
parameter_list|,
name|w
parameter_list|)
value|(((int64_t)(imm)<< (64 - (w)))>> (64 - (w)))
end_define

begin_decl_stmt
specifier|extern
name|int
name|ia64_unaligned_print
decl_stmt|,
name|ia64_unaligned_fix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ia64_unaligned_sigbus
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|type
block|{
name|LD_SA
block|,
name|LD_S
block|,
name|LD_A
block|,
name|LD_C_CLR
block|,
name|LD_C_NC
block|,
name|LD
block|}
enum|;
end_enum

begin_struct
struct|struct
name|decoding
block|{
name|int
name|isload
decl_stmt|;
comment|/* non-zero if load */
name|enum
name|type
name|type
decl_stmt|;
comment|/* type of load or store */
name|int
name|basereg
decl_stmt|;
comment|/* address to load or store */
name|int
name|reg
decl_stmt|;
comment|/* register number to load or store */
name|int
name|width
decl_stmt|;
comment|/* number of bytes */
name|int
name|update
decl_stmt|;
comment|/* update value for basereg */
name|int
name|updateisreg
decl_stmt|;
comment|/* non-zero if update is a register */
name|int
name|fence
decl_stmt|;
comment|/* non-zero if fence needed */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|unaligned_decode_M1
parameter_list|(
name|union
name|ia64_instruction
name|ins
parameter_list|,
name|struct
name|decoding
modifier|*
name|d
parameter_list|)
block|{
specifier|static
name|enum
name|type
name|types
index|[]
init|=
block|{
name|LD
block|,
name|LD_S
block|,
name|LD_A
block|,
name|LD_SA
block|,
name|LD
block|,
name|LD
block|,
name|LD
block|,
name|LD_C_CLR
block|,
name|LD_C_NC
block|,
name|LD_C_CLR
block|}
decl_stmt|;
name|d
operator|->
name|isload
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|types
index|[
name|ins
operator|.
name|M1
operator|.
name|x6
operator|>>
literal|2
index|]
expr_stmt|;
name|d
operator|->
name|basereg
operator|=
name|ins
operator|.
name|M1
operator|.
name|r3
expr_stmt|;
name|d
operator|->
name|reg
operator|=
name|ins
operator|.
name|M1
operator|.
name|r1
expr_stmt|;
name|d
operator|->
name|width
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ins
operator|.
name|M1
operator|.
name|x6
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ins
operator|.
name|M1
operator|.
name|x6
operator|>=
literal|0x14
operator|&&
name|ins
operator|.
name|M1
operator|.
name|x6
operator|<=
literal|0x17
operator|)
operator|||
operator|(
name|ins
operator|.
name|M1
operator|.
name|x6
operator|>=
literal|0x28
operator|&&
name|ins
operator|.
name|M1
operator|.
name|x6
operator|<=
literal|0x2b
operator|)
condition|)
name|d
operator|->
name|fence
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unaligned_decode_M2
parameter_list|(
name|union
name|ia64_instruction
name|ins
parameter_list|,
name|struct
name|decoding
modifier|*
name|d
parameter_list|)
block|{
specifier|static
name|enum
name|type
name|types
index|[]
init|=
block|{
name|LD
block|,
name|LD_S
block|,
name|LD_A
block|,
name|LD_SA
block|,
name|LD
block|,
name|LD
block|,
name|LD
block|,
name|LD_C_CLR
block|,
name|LD_C_NC
block|,
name|LD_C_CLR
block|}
decl_stmt|;
name|d
operator|->
name|isload
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|types
index|[
name|ins
operator|.
name|M1
operator|.
name|x6
operator|>>
literal|2
index|]
expr_stmt|;
name|d
operator|->
name|basereg
operator|=
name|ins
operator|.
name|M2
operator|.
name|r3
expr_stmt|;
name|d
operator|->
name|reg
operator|=
name|ins
operator|.
name|M2
operator|.
name|r1
expr_stmt|;
name|d
operator|->
name|width
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ins
operator|.
name|M2
operator|.
name|x6
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
name|d
operator|->
name|update
operator|=
name|ins
operator|.
name|M2
operator|.
name|r2
expr_stmt|;
name|d
operator|->
name|updateisreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ins
operator|.
name|M2
operator|.
name|x6
operator|>=
literal|0x14
operator|&&
name|ins
operator|.
name|M2
operator|.
name|x6
operator|<=
literal|0x17
operator|)
operator|||
operator|(
name|ins
operator|.
name|M2
operator|.
name|x6
operator|>=
literal|0x28
operator|&&
name|ins
operator|.
name|M2
operator|.
name|x6
operator|<=
literal|0x2b
operator|)
condition|)
name|d
operator|->
name|fence
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unaligned_decode_M3
parameter_list|(
name|union
name|ia64_instruction
name|ins
parameter_list|,
name|struct
name|decoding
modifier|*
name|d
parameter_list|)
block|{
specifier|static
name|enum
name|type
name|types
index|[]
init|=
block|{
name|LD
block|,
name|LD_S
block|,
name|LD_A
block|,
name|LD_SA
block|,
name|LD
block|,
name|LD
block|,
name|LD
block|,
name|LD_C_CLR
block|,
name|LD_C_NC
block|,
name|LD_C_CLR
block|}
decl_stmt|;
name|d
operator|->
name|isload
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|types
index|[
name|ins
operator|.
name|M1
operator|.
name|x6
operator|>>
literal|2
index|]
expr_stmt|;
name|d
operator|->
name|basereg
operator|=
name|ins
operator|.
name|M3
operator|.
name|r3
expr_stmt|;
name|d
operator|->
name|reg
operator|=
name|ins
operator|.
name|M3
operator|.
name|r1
expr_stmt|;
name|d
operator|->
name|width
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ins
operator|.
name|M3
operator|.
name|x6
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
name|d
operator|->
name|update
operator|=
name|sign_extend
argument_list|(
operator|(
name|ins
operator|.
name|M3
operator|.
name|s
operator|<<
literal|8
operator|)
operator||
operator|(
name|ins
operator|.
name|M3
operator|.
name|i
operator|<<
literal|7
operator|)
operator||
name|ins
operator|.
name|M3
operator|.
name|imm7b
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ins
operator|.
name|M3
operator|.
name|x6
operator|>=
literal|0x14
operator|&&
name|ins
operator|.
name|M3
operator|.
name|x6
operator|<=
literal|0x17
operator|)
operator|||
operator|(
name|ins
operator|.
name|M3
operator|.
name|x6
operator|>=
literal|0x28
operator|&&
name|ins
operator|.
name|M3
operator|.
name|x6
operator|<=
literal|0x2b
operator|)
condition|)
name|d
operator|->
name|fence
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unaligned_decode_M4
parameter_list|(
name|union
name|ia64_instruction
name|ins
parameter_list|,
name|struct
name|decoding
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|isload
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|basereg
operator|=
name|ins
operator|.
name|M4
operator|.
name|r3
expr_stmt|;
name|d
operator|->
name|reg
operator|=
name|ins
operator|.
name|M4
operator|.
name|r2
expr_stmt|;
name|d
operator|->
name|width
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ins
operator|.
name|M4
operator|.
name|x6
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|M4
operator|.
name|x6
operator|>=
literal|0x34
operator|&&
name|ins
operator|.
name|M4
operator|.
name|x6
operator|<=
literal|0x37
condition|)
name|d
operator|->
name|fence
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unaligned_decode_M5
parameter_list|(
name|union
name|ia64_instruction
name|ins
parameter_list|,
name|struct
name|decoding
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|isload
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|basereg
operator|=
name|ins
operator|.
name|M5
operator|.
name|r3
expr_stmt|;
name|d
operator|->
name|reg
operator|=
name|ins
operator|.
name|M5
operator|.
name|r2
expr_stmt|;
name|d
operator|->
name|width
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ins
operator|.
name|M5
operator|.
name|x6
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
name|d
operator|->
name|update
operator|=
name|sign_extend
argument_list|(
operator|(
name|ins
operator|.
name|M5
operator|.
name|s
operator|<<
literal|8
operator|)
operator||
operator|(
name|ins
operator|.
name|M5
operator|.
name|i
operator|<<
literal|7
operator|)
operator||
name|ins
operator|.
name|M5
operator|.
name|imm7a
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|M5
operator|.
name|x6
operator|>=
literal|0x34
operator|&&
name|ins
operator|.
name|M5
operator|.
name|x6
operator|<=
literal|0x37
condition|)
name|d
operator|->
name|fence
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_register
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int64_t
modifier|*
name|valuep
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|<
literal|32
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_special
operator|.
name|gp
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr2
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr3
expr_stmt|;
break|break;
case|case
literal|8
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr8
expr_stmt|;
break|break;
case|case
literal|9
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr9
expr_stmt|;
break|break;
case|case
literal|10
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr10
expr_stmt|;
break|break;
case|case
literal|11
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr11
expr_stmt|;
break|break;
case|case
literal|12
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_special
operator|.
name|sp
expr_stmt|;
break|break;
case|case
literal|13
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_special
operator|.
name|tp
expr_stmt|;
break|break;
case|case
literal|14
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr14
expr_stmt|;
break|break;
case|case
literal|15
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr15
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr16
expr_stmt|;
break|break;
case|case
literal|17
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr17
expr_stmt|;
break|break;
case|case
literal|18
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr18
expr_stmt|;
break|break;
case|case
literal|19
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr19
expr_stmt|;
break|break;
case|case
literal|20
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr20
expr_stmt|;
break|break;
case|case
literal|21
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr21
expr_stmt|;
break|break;
case|case
literal|22
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr22
expr_stmt|;
break|break;
case|case
literal|23
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr23
expr_stmt|;
break|break;
case|case
literal|24
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr24
expr_stmt|;
break|break;
case|case
literal|25
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr25
expr_stmt|;
break|break;
case|case
literal|26
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr26
expr_stmt|;
break|break;
case|case
literal|27
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr27
expr_stmt|;
break|break;
case|case
literal|28
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr28
expr_stmt|;
break|break;
case|case
literal|29
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr29
expr_stmt|;
break|break;
case|case
literal|30
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr30
expr_stmt|;
break|break;
case|case
literal|31
case|:
operator|*
name|valuep
operator|=
name|framep
operator|->
name|tf_scratch
operator|.
name|gr31
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|0
block|u_int64_t cfm = framep->tf_special.cfm; 		u_int64_t *bsp = (u_int64_t *)(td->td_kstack + 		    framep->tf_ndirty); 		int sof = cfm& 0x7f; 		int sor = 8*((cfm>> 14)& 15); 		int rrb_gr = (cfm>> 18)& 0x7f;
comment|/* 		 * Skip back to the start of the interrupted frame. 		 */
block|bsp = ia64_rse_previous_frame(bsp, sof);  		if (reg - 32> sof) 			return EINVAL; 		if (reg - 32< sor) { 			if (reg - 32 + rrb_gr>= sor) 				reg = reg + rrb_gr - sor; 			else 				reg = reg + rrb_gr; 		}  		*valuep = *ia64_rse_register_address(bsp, reg); 		return (0);
else|#
directive|else
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_register
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int64_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|<
literal|32
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|1
case|:
name|framep
operator|->
name|tf_special
operator|.
name|gp
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr2
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr3
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr8
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr9
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr10
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr11
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|framep
operator|->
name|tf_special
operator|.
name|sp
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|framep
operator|->
name|tf_special
operator|.
name|tp
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr14
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr15
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr16
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr17
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr18
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr19
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr20
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr21
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr22
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr23
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr24
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|25
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr25
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr26
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr27
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr28
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr29
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr30
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|framep
operator|->
name|tf_scratch
operator|.
name|gr31
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|0
block|u_int64_t cfm = framep->tf_special.cfm; 		u_int64_t *bsp = (u_int64_t *) (td->td_kstack 						+ framep->tf_ndirty); 		int sof = cfm& 0x7f; 		int sor = 8*((cfm>> 14)& 15); 		int rrb_gr = (cfm>> 18)& 0x7f;
comment|/* 		 * Skip back to the start of the interrupted frame. 		 */
block|bsp = ia64_rse_previous_frame(bsp, sof);  		if (reg - 32> sof) 			return EINVAL; 		if (reg - 32< sor) { 			if (reg - 32 + rrb_gr>= sor) 				reg = reg + rrb_gr - sor; 			else 				reg = reg + rrb_gr; 		}  		*ia64_rse_register_address(bsp, reg) = value; 		return 0;
else|#
directive|else
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Messy.  */
end_comment

begin_function
specifier|static
name|void
name|invala_e
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
asm|__asm __volatile("invala.e r0");
break|break;
case|case
literal|1
case|:
asm|__asm __volatile("invala.e r1");
break|break;
case|case
literal|2
case|:
asm|__asm __volatile("invala.e r2");
break|break;
case|case
literal|3
case|:
asm|__asm __volatile("invala.e r3");
break|break;
case|case
literal|4
case|:
asm|__asm __volatile("invala.e r4");
break|break;
case|case
literal|5
case|:
asm|__asm __volatile("invala.e r5");
break|break;
case|case
literal|6
case|:
asm|__asm __volatile("invala.e r6");
break|break;
case|case
literal|7
case|:
asm|__asm __volatile("invala.e r7");
break|break;
case|case
literal|8
case|:
asm|__asm __volatile("invala.e r8");
break|break;
case|case
literal|9
case|:
asm|__asm __volatile("invala.e r9");
break|break;
case|case
literal|10
case|:
asm|__asm __volatile("invala.e r10");
break|break;
case|case
literal|11
case|:
asm|__asm __volatile("invala.e r11");
break|break;
case|case
literal|12
case|:
asm|__asm __volatile("invala.e r12");
break|break;
case|case
literal|13
case|:
asm|__asm __volatile("invala.e r13");
break|break;
case|case
literal|14
case|:
asm|__asm __volatile("invala.e r14");
break|break;
case|case
literal|15
case|:
asm|__asm __volatile("invala.e r15");
break|break;
case|case
literal|16
case|:
asm|__asm __volatile("invala.e r16");
break|break;
case|case
literal|17
case|:
asm|__asm __volatile("invala.e r17");
break|break;
case|case
literal|18
case|:
asm|__asm __volatile("invala.e r18");
break|break;
case|case
literal|19
case|:
asm|__asm __volatile("invala.e r19");
break|break;
case|case
literal|20
case|:
asm|__asm __volatile("invala.e r20");
break|break;
case|case
literal|21
case|:
asm|__asm __volatile("invala.e r21");
break|break;
case|case
literal|22
case|:
asm|__asm __volatile("invala.e r22");
break|break;
case|case
literal|23
case|:
asm|__asm __volatile("invala.e r23");
break|break;
case|case
literal|24
case|:
asm|__asm __volatile("invala.e r24");
break|break;
case|case
literal|25
case|:
asm|__asm __volatile("invala.e r25");
break|break;
case|case
literal|26
case|:
asm|__asm __volatile("invala.e r26");
break|break;
case|case
literal|27
case|:
asm|__asm __volatile("invala.e r27");
break|break;
case|case
literal|28
case|:
asm|__asm __volatile("invala.e r28");
break|break;
case|case
literal|29
case|:
asm|__asm __volatile("invala.e r29");
break|break;
case|case
literal|30
case|:
asm|__asm __volatile("invala.e r30");
break|break;
case|case
literal|31
case|:
asm|__asm __volatile("invala.e r31");
break|break;
case|case
literal|32
case|:
asm|__asm __volatile("invala.e r32");
break|break;
case|case
literal|33
case|:
asm|__asm __volatile("invala.e r33");
break|break;
case|case
literal|34
case|:
asm|__asm __volatile("invala.e r34");
break|break;
case|case
literal|35
case|:
asm|__asm __volatile("invala.e r35");
break|break;
case|case
literal|36
case|:
asm|__asm __volatile("invala.e r36");
break|break;
case|case
literal|37
case|:
asm|__asm __volatile("invala.e r37");
break|break;
case|case
literal|38
case|:
asm|__asm __volatile("invala.e r38");
break|break;
case|case
literal|39
case|:
asm|__asm __volatile("invala.e r39");
break|break;
case|case
literal|40
case|:
asm|__asm __volatile("invala.e r40");
break|break;
case|case
literal|41
case|:
asm|__asm __volatile("invala.e r41");
break|break;
case|case
literal|42
case|:
asm|__asm __volatile("invala.e r42");
break|break;
case|case
literal|43
case|:
asm|__asm __volatile("invala.e r43");
break|break;
case|case
literal|44
case|:
asm|__asm __volatile("invala.e r44");
break|break;
case|case
literal|45
case|:
asm|__asm __volatile("invala.e r45");
break|break;
case|case
literal|46
case|:
asm|__asm __volatile("invala.e r46");
break|break;
case|case
literal|47
case|:
asm|__asm __volatile("invala.e r47");
break|break;
case|case
literal|48
case|:
asm|__asm __volatile("invala.e r48");
break|break;
case|case
literal|49
case|:
asm|__asm __volatile("invala.e r49");
break|break;
case|case
literal|50
case|:
asm|__asm __volatile("invala.e r50");
break|break;
case|case
literal|51
case|:
asm|__asm __volatile("invala.e r51");
break|break;
case|case
literal|52
case|:
asm|__asm __volatile("invala.e r52");
break|break;
case|case
literal|53
case|:
asm|__asm __volatile("invala.e r53");
break|break;
case|case
literal|54
case|:
asm|__asm __volatile("invala.e r54");
break|break;
case|case
literal|55
case|:
asm|__asm __volatile("invala.e r55");
break|break;
case|case
literal|56
case|:
asm|__asm __volatile("invala.e r56");
break|break;
case|case
literal|57
case|:
asm|__asm __volatile("invala.e r57");
break|break;
case|case
literal|58
case|:
asm|__asm __volatile("invala.e r58");
break|break;
case|case
literal|59
case|:
asm|__asm __volatile("invala.e r59");
break|break;
case|case
literal|60
case|:
asm|__asm __volatile("invala.e r60");
break|break;
case|case
literal|61
case|:
asm|__asm __volatile("invala.e r61");
break|break;
case|case
literal|62
case|:
asm|__asm __volatile("invala.e r62");
break|break;
case|case
literal|63
case|:
asm|__asm __volatile("invala.e r63");
break|break;
case|case
literal|64
case|:
asm|__asm __volatile("invala.e r64");
break|break;
case|case
literal|65
case|:
asm|__asm __volatile("invala.e r65");
break|break;
case|case
literal|66
case|:
asm|__asm __volatile("invala.e r66");
break|break;
case|case
literal|67
case|:
asm|__asm __volatile("invala.e r67");
break|break;
case|case
literal|68
case|:
asm|__asm __volatile("invala.e r68");
break|break;
case|case
literal|69
case|:
asm|__asm __volatile("invala.e r69");
break|break;
case|case
literal|70
case|:
asm|__asm __volatile("invala.e r70");
break|break;
case|case
literal|71
case|:
asm|__asm __volatile("invala.e r71");
break|break;
case|case
literal|72
case|:
asm|__asm __volatile("invala.e r72");
break|break;
case|case
literal|73
case|:
asm|__asm __volatile("invala.e r73");
break|break;
case|case
literal|74
case|:
asm|__asm __volatile("invala.e r74");
break|break;
case|case
literal|75
case|:
asm|__asm __volatile("invala.e r75");
break|break;
case|case
literal|76
case|:
asm|__asm __volatile("invala.e r76");
break|break;
case|case
literal|77
case|:
asm|__asm __volatile("invala.e r77");
break|break;
case|case
literal|78
case|:
asm|__asm __volatile("invala.e r78");
break|break;
case|case
literal|79
case|:
asm|__asm __volatile("invala.e r79");
break|break;
case|case
literal|80
case|:
asm|__asm __volatile("invala.e r80");
break|break;
case|case
literal|81
case|:
asm|__asm __volatile("invala.e r81");
break|break;
case|case
literal|82
case|:
asm|__asm __volatile("invala.e r82");
break|break;
case|case
literal|83
case|:
asm|__asm __volatile("invala.e r83");
break|break;
case|case
literal|84
case|:
asm|__asm __volatile("invala.e r84");
break|break;
case|case
literal|85
case|:
asm|__asm __volatile("invala.e r85");
break|break;
case|case
literal|86
case|:
asm|__asm __volatile("invala.e r86");
break|break;
case|case
literal|87
case|:
asm|__asm __volatile("invala.e r87");
break|break;
case|case
literal|88
case|:
asm|__asm __volatile("invala.e r88");
break|break;
case|case
literal|89
case|:
asm|__asm __volatile("invala.e r89");
break|break;
case|case
literal|90
case|:
asm|__asm __volatile("invala.e r90");
break|break;
case|case
literal|91
case|:
asm|__asm __volatile("invala.e r91");
break|break;
case|case
literal|92
case|:
asm|__asm __volatile("invala.e r92");
break|break;
case|case
literal|93
case|:
asm|__asm __volatile("invala.e r93");
break|break;
case|case
literal|94
case|:
asm|__asm __volatile("invala.e r94");
break|break;
case|case
literal|95
case|:
asm|__asm __volatile("invala.e r95");
break|break;
case|case
literal|96
case|:
asm|__asm __volatile("invala.e r96");
break|break;
case|case
literal|97
case|:
asm|__asm __volatile("invala.e r97");
break|break;
case|case
literal|98
case|:
asm|__asm __volatile("invala.e r98");
break|break;
case|case
literal|99
case|:
asm|__asm __volatile("invala.e r99");
break|break;
case|case
literal|100
case|:
asm|__asm __volatile("invala.e r100");
break|break;
case|case
literal|101
case|:
asm|__asm __volatile("invala.e r101");
break|break;
case|case
literal|102
case|:
asm|__asm __volatile("invala.e r102");
break|break;
case|case
literal|103
case|:
asm|__asm __volatile("invala.e r103");
break|break;
case|case
literal|104
case|:
asm|__asm __volatile("invala.e r104");
break|break;
case|case
literal|105
case|:
asm|__asm __volatile("invala.e r105");
break|break;
case|case
literal|106
case|:
asm|__asm __volatile("invala.e r106");
break|break;
case|case
literal|107
case|:
asm|__asm __volatile("invala.e r107");
break|break;
case|case
literal|108
case|:
asm|__asm __volatile("invala.e r108");
break|break;
case|case
literal|109
case|:
asm|__asm __volatile("invala.e r109");
break|break;
case|case
literal|110
case|:
asm|__asm __volatile("invala.e r110");
break|break;
case|case
literal|111
case|:
asm|__asm __volatile("invala.e r111");
break|break;
case|case
literal|112
case|:
asm|__asm __volatile("invala.e r112");
break|break;
case|case
literal|113
case|:
asm|__asm __volatile("invala.e r113");
break|break;
case|case
literal|114
case|:
asm|__asm __volatile("invala.e r114");
break|break;
case|case
literal|115
case|:
asm|__asm __volatile("invala.e r115");
break|break;
case|case
literal|116
case|:
asm|__asm __volatile("invala.e r116");
break|break;
case|case
literal|117
case|:
asm|__asm __volatile("invala.e r117");
break|break;
case|case
literal|118
case|:
asm|__asm __volatile("invala.e r118");
break|break;
case|case
literal|119
case|:
asm|__asm __volatile("invala.e r119");
break|break;
case|case
literal|120
case|:
asm|__asm __volatile("invala.e r120");
break|break;
case|case
literal|121
case|:
asm|__asm __volatile("invala.e r121");
break|break;
case|case
literal|122
case|:
asm|__asm __volatile("invala.e r122");
break|break;
case|case
literal|123
case|:
asm|__asm __volatile("invala.e r123");
break|break;
case|case
literal|124
case|:
asm|__asm __volatile("invala.e r124");
break|break;
case|case
literal|125
case|:
asm|__asm __volatile("invala.e r125");
break|break;
case|case
literal|126
case|:
asm|__asm __volatile("invala.e r126");
break|break;
case|case
literal|127
case|:
asm|__asm __volatile("invala.e r127");
break|break;
block|}
block|}
end_function

begin_function
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|trapframe
modifier|*
name|framep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|framep
operator|->
name|tf_special
operator|.
name|ifa
decl_stmt|;
name|int
name|doprint
decl_stmt|,
name|dofix
decl_stmt|,
name|dosigbus
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|uac
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_int64_t
name|low
decl_stmt|,
name|high
decl_stmt|;
name|struct
name|ia64_bundle
name|b
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|union
name|ia64_instruction
name|ins
decl_stmt|;
name|int
name|decoded
decl_stmt|;
name|struct
name|decoding
name|dec
decl_stmt|;
comment|/* 	 * Figure out what actions to take. 	 */
if|if
condition|(
name|td
condition|)
block|{
name|uac
operator|=
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDP_UAC_MASK
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
block|}
else|else
block|{
name|uac
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
name|doprint
operator|=
name|ia64_unaligned_print
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOPRINT
operator|)
expr_stmt|;
name|dofix
operator|=
name|ia64_unaligned_fix
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOFIX
operator|)
expr_stmt|;
name|dosigbus
operator|=
name|ia64_unaligned_sigbus
operator||
operator|(
name|uac
operator|&
name|MDP_UAC_SIGBUS
operator|)
expr_stmt|;
comment|/* 	 * If psr.ac is set, then clearly the user program *wants* to 	 * fault. 	 */
if|if
condition|(
name|framep
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_AC
condition|)
block|{
name|dofix
operator|=
literal|0
expr_stmt|;
name|dosigbus
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * See if the user can access the memory in question. 	 * Even if it's an unknown opcode, SEGV if the access 	 * should have failed. 	 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGSEGV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Read the instruction bundle and attempt to decode the 	 * offending instruction. 	 * XXX assume that the instruction is in an 'M' slot. 	 */
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|framep
operator|->
name|tf_special
operator|.
name|iip
argument_list|,
operator|&
name|low
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|framep
operator|->
name|tf_special
operator|.
name|iip
operator|+
literal|8
operator|)
argument_list|,
operator|&
name|high
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ia64_unpack_bundle
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
name|framep
operator|->
name|tf_special
operator|.
name|psr
operator|>>
literal|41
operator|)
operator|&
literal|3
expr_stmt|;
name|ins
operator|.
name|ins
operator|=
name|b
operator|.
name|slot
index|[
name|slot
index|]
expr_stmt|;
name|decoded
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dec
argument_list|,
sizeof|sizeof
argument_list|(
name|dec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|op
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|m
operator|==
literal|0
operator|&&
name|ins
operator|.
name|M1
operator|.
name|x
operator|==
literal|0
condition|)
block|{
comment|/* Table 4-29 */
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|x6
operator|<
literal|0x30
condition|)
name|decoded
operator|=
name|unaligned_decode_M1
argument_list|(
name|ins
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
else|else
name|decoded
operator|=
name|unaligned_decode_M4
argument_list|(
name|ins
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|m
operator|==
literal|1
operator|&&
name|ins
operator|.
name|M1
operator|.
name|x
operator|==
literal|0
condition|)
block|{
comment|/* Table 4-30 */
name|decoded
operator|=
name|unaligned_decode_M2
argument_list|(
name|ins
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|op
operator|==
literal|5
condition|)
block|{
comment|/* Table 4-31 */
if|if
condition|(
name|ins
operator|.
name|M1
operator|.
name|x6
operator|<
literal|0x30
condition|)
name|decoded
operator|=
name|unaligned_decode_M3
argument_list|(
name|ins
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
else|else
name|decoded
operator|=
name|unaligned_decode_M5
argument_list|(
name|ins
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're supposed to be noisy, squawk now. 	 */
if|if
condition|(
name|doprint
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|va
argument_list|,
name|framep
operator|->
name|tf_special
operator|.
name|iip
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
condition|)
block|{
name|uprintf
argument_list|(
literal|" op="
argument_list|)
expr_stmt|;
if|if
condition|(
name|dec
operator|.
name|isload
condition|)
block|{
specifier|static
name|char
modifier|*
name|ldops
index|[]
init|=
block|{
literal|"ld%d.sa"
block|,
literal|"ld%d.s"
block|,
literal|"ld%d.a"
block|,
literal|"ld%d.c.clr"
block|,
literal|"ld%d.c.nc"
block|,
literal|"ld%d"
block|}
decl_stmt|;
name|uprintf
argument_list|(
name|ldops
index|[
name|dec
operator|.
name|type
index|]
argument_list|,
name|dec
operator|.
name|width
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|" r%d=[r%d]"
argument_list|,
name|dec
operator|.
name|reg
argument_list|,
name|dec
operator|.
name|basereg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uprintf
argument_list|(
literal|"st%d [r%d]=r%d"
argument_list|,
name|dec
operator|.
name|width
argument_list|,
name|dec
operator|.
name|basereg
argument_list|,
name|dec
operator|.
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dec
operator|.
name|updateisreg
condition|)
name|uprintf
argument_list|(
literal|",r%d\n"
argument_list|,
name|dec
operator|.
name|update
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dec
operator|.
name|update
condition|)
name|uprintf
argument_list|(
literal|",%d\n"
argument_list|,
name|dec
operator|.
name|update
argument_list|)
expr_stmt|;
else|else
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we should try to fix it and know how, give it a shot. 	 * 	 * We never allow bad data to be unknowingly used by the 	 * user process.  That is, if we decide not to fix up an 	 * access we cause a SIGBUS rather than letting the user 	 * process go on without warning. 	 * 	 * If we're trying to do a fixup, we assume that things 	 * will be botched.  If everything works out OK,  	 * unaligned_{load,store}_* clears the signal flag. 	 */
name|signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dofix
operator|&&
name|decoded
condition|)
block|{
name|u_int64_t
name|addr
decl_stmt|,
name|update
decl_stmt|,
name|value
decl_stmt|,
name|isr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 		 * We only really need this if the current bspstore 		 * hasn't advanced past the user's register frame. Its 		 * hardly worth trying to optimise though. 		 */
asm|__asm __volatile("flushrs");
name|isr
operator|=
name|framep
operator|->
name|tf_special
operator|.
name|isr
expr_stmt|;
name|error
operator|=
name|read_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|basereg
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|signal
operator|=
name|SIGBUS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dec
operator|.
name|updateisreg
condition|)
block|{
name|error
operator|=
name|read_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|update
argument_list|,
operator|&
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|signal
operator|=
name|SIGBUS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|update
operator|=
name|dec
operator|.
name|update
expr_stmt|;
block|}
comment|/* Assume little-endian */
if|if
condition|(
name|dec
operator|.
name|isload
condition|)
block|{
comment|/* 			 * Sanity checks. 			 */
if|if
condition|(
operator|!
operator|(
name|isr
operator|&
name|IA64_ISR_R
operator|)
operator|||
operator|(
name|isr
operator|&
operator|(
name|IA64_ISR_W
operator||
name|IA64_ISR_X
operator||
name|IA64_ISR_NA
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"unaligned_fixup: unexpected cr.isr value\n"
argument_list|)
expr_stmt|;
name|signal
operator|=
name|SIGBUS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dec
operator|.
name|type
operator|==
name|LD_SA
operator|||
name|dec
operator|.
name|type
operator|==
name|LD_A
condition|)
block|{
name|invala_e
argument_list|(
name|dec
operator|.
name|reg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dec
operator|.
name|type
operator|==
name|LD_C_CLR
condition|)
name|invala_e
argument_list|(
name|dec
operator|.
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dec
operator|.
name|type
operator|==
name|LD_S
condition|)
comment|/* XXX not quite sure what to do here */
empty_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|dec
operator|.
name|fence
condition|)
name|ia64_mf
argument_list|()
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|value
argument_list|,
name|dec
operator|.
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|write_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|update
condition|)
name|error
operator|=
name|write_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|basereg
argument_list|,
name|addr
operator|+
name|update
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|read_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|reg
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|dec
operator|.
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|dec
operator|.
name|fence
condition|)
name|ia64_mf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|update
condition|)
name|error
operator|=
name|write_register
argument_list|(
name|framep
argument_list|,
name|td
argument_list|,
name|dec
operator|.
name|basereg
argument_list|,
name|addr
operator|+
name|update
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|signal
operator|=
name|SIGBUS
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Advance to the instruction following the 			 * one which faulted. 			 */
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_special
operator|.
name|psr
operator|&
name|IA64_PSR_RI
operator|)
operator|==
name|IA64_PSR_RI_2
condition|)
block|{
name|framep
operator|->
name|tf_special
operator|.
name|psr
operator|&=
operator|~
name|IA64_PSR_RI
expr_stmt|;
name|framep
operator|->
name|tf_special
operator|.
name|iip
operator|+=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|framep
operator|->
name|tf_special
operator|.
name|psr
operator|+=
name|IA64_PSR_RI_1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|signal
operator|=
name|SIGBUS
expr_stmt|;
block|}
comment|/* 	 * Force SIGBUS if requested. 	 */
if|if
condition|(
name|dosigbus
condition|)
name|signal
operator|=
name|SIGBUS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|signal
operator|)
return|;
block|}
end_function

end_unit

