begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_md.h"
end_include

begin_include
include|#
directive|include
file|"opt_ski.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SKI_ROOT_FILESYSTEM
end_ifndef

begin_define
define|#
directive|define
name|SKI_ROOT_FILESYSTEM
value|"ia64-root.fs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SSC_OPEN
value|50
end_define

begin_define
define|#
directive|define
name|SSC_CLOSE
value|51
end_define

begin_define
define|#
directive|define
name|SSC_READ
value|52
end_define

begin_define
define|#
directive|define
name|SSC_WRITE
value|53
end_define

begin_define
define|#
directive|define
name|SSC_GET_COMPLETION
value|54
end_define

begin_define
define|#
directive|define
name|SSC_WAIT_COMPLETION
value|55
end_define

begin_struct
struct|struct
name|disk_req
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|disk_stat
block|{
name|int
name|fd
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|u_int64_t
name|ssc
parameter_list|(
name|u_int64_t
name|in0
parameter_list|,
name|u_int64_t
name|in1
parameter_list|,
name|u_int64_t
name|in2
parameter_list|,
name|u_int64_t
name|in3
parameter_list|,
name|int
name|which
parameter_list|)
block|{
specifier|register
name|u_int64_t
name|ret0
asm|__asm("r8");
asm|__asm __volatile("mov r15=%1\n\t"
literal|"break 0x80001"
operator|:
literal|"=r"
operator|(
name|ret0
operator|)
operator|:
literal|"r"
operator|(
name|which
operator|)
operator|,
literal|"r"
operator|(
name|in0
operator|)
operator|,
literal|"r"
operator|(
name|in1
operator|)
operator|,
literal|"r"
operator|(
name|in2
operator|)
operator|,
literal|"r"
operator|(
name|in3
operator|)
block|)
function|;
end_function

begin_return
return|return
name|ret0
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|SSC_NSECT
end_ifndef

begin_define
define|#
directive|define
name|SSC_NSECT
value|409600
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|MALLOC_DEFINE
operator|(
name|M_SSC
operator|,
literal|"ssc_disk"
operator|,
literal|"Simulator Disk"
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|sscstrategy
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ssc_s
argument_list|)
name|ssc_softc_list
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|ssc_softc_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ssc_s
block|{
name|int
name|unit
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|ssc_s
argument_list|)
name|list
expr_stmt|;
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|sscunits
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sscstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|ssc_s
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|disk_req
name|req
decl_stmt|;
name|struct
name|disk_stat
name|stat
decl_stmt|;
name|u_long
name|len
decl_stmt|,
name|va
decl_stmt|,
name|off
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|busy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|busy
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
break|break;
name|va
operator|=
operator|(
name|u_long
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|off
operator|=
name|bp
operator|->
name|bio_pblkno
operator|<<
name|DEV_BSHIFT
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|u_int
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
operator|+
name|len
operator|>
name|PAGE_SIZE
condition|)
name|t
operator|=
name|PAGE_SIZE
operator|-
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
else|else
name|t
operator|=
name|len
expr_stmt|;
name|req
operator|.
name|len
operator|=
name|t
expr_stmt|;
name|req
operator|.
name|addr
operator|=
name|ia64_tpa
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|ssc
argument_list|(
name|sc
operator|->
name|fd
argument_list|,
literal|1
argument_list|,
name|ia64_tpa
argument_list|(
operator|(
name|long
operator|)
operator|&
name|req
argument_list|)
argument_list|,
name|off
argument_list|,
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|?
name|SSC_READ
else|:
name|SSC_WRITE
argument_list|)
expr_stmt|;
name|stat
operator|.
name|fd
operator|=
name|sc
operator|->
name|fd
expr_stmt|;
name|ssc
argument_list|(
name|ia64_tpa
argument_list|(
operator|(
name|long
operator|)
operator|&
name|stat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SSC_WAIT_COMPLETION
argument_list|)
expr_stmt|;
name|va
operator|+=
name|t
expr_stmt|;
name|len
operator|-=
name|t
expr_stmt|;
name|off
operator|+=
name|t
expr_stmt|;
block|}
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
name|sc
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ssc_s
modifier|*
name|ssccreate
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ssc_s
modifier|*
name|sc
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|ssc
argument_list|(
name|ia64_tpa
argument_list|(
operator|(
name|u_int64_t
operator|)
name|SKI_ROOT_FILESYSTEM
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SSC_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|unit
operator|=
name|sscunits
operator|++
expr_stmt|;
comment|/* Make sure this unit isn't already in action */
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&ssc_softc_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|unit
operator|==
name|unit
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|MALLOC
argument_list|(
name|sc
argument_list|,
expr|struct
name|ssc_s
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_SSC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ssc_softc_list
argument_list|,
name|sc
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|disk
operator|=
name|disk_alloc
argument_list|()
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_drv1
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_fwheads
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_fwsectors
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_maxsize
operator|=
name|DFLTPHYS
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_mediasize
operator|=
operator|(
name|off_t
operator|)
name|SSC_NSECT
operator|*
name|DEV_BSIZE
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_name
operator|=
literal|"sscdisk"
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_sectorsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_strategy
operator|=
name|sscstrategy
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|sc
operator|->
name|disk
operator|->
name|d_flags
operator|=
name|DISKFLAG_NEEDSGIANT
expr_stmt|;
name|disk_create
argument_list|(
name|sc
operator|->
name|disk
argument_list|,
name|DISK_VERSION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unit
operator|==
literal|0
condition|)
name|rootdevnames
index|[
literal|0
index|]
operator|=
literal|"ufs:/dev/sscdisk0"
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssc_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|ssccreate
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sscdev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|ssc_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

