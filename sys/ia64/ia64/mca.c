begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2010 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/sal.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MCA
argument_list|,
literal|"MCA"
argument_list|,
literal|"Machine Check Architecture"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|mca_info
block|{
name|STAILQ_ENTRY
argument_list|(
argument|mca_info
argument_list|)
name|mi_link
expr_stmt|;
name|u_long
name|mi_seqnr
decl_stmt|;
name|u_int
name|mi_cpuid
decl_stmt|;
name|size_t
name|mi_recsz
decl_stmt|;
name|char
name|mi_record
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|mca_info_list
argument_list|,
name|mca_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int64_t
name|mca_info_size
index|[
name|SAL_INFO_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|mca_info_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mca_info_block_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mca
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"MCA container"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mca_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of records stored. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mca_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First (lowest) record ID. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mca_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last (highest) record ID. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_count
argument_list|,
literal|0
argument_list|,
literal|"Record count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|first
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_first
argument_list|,
literal|0
argument_list|,
literal|"First record id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|last
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_last
argument_list|,
literal|0
argument_list|,
literal|"Last record id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mca_sysctl_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|mca_xiv_cmc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mca_sysctl_inject
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
name|u_int
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Example values for injecting PAL determined machine checks: 	 *	corrected	9 	 *	recoverable	73 	 *	fatal		137 	 */
name|res
operator|=
name|ia64_call_pal_stacked
argument_list|(
name|PAL_MC_ERROR_INJECT
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %#lx, %#lx, %#lx, %#lx\n"
argument_list|,
name|__func__
argument_list|,
name|res
operator|.
name|pal_status
argument_list|,
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
argument_list|,
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
argument_list|,
name|res
operator|.
name|pal_result
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|inject
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mca_sysctl_inject
argument_list|,
literal|"I"
argument_list|,
literal|"set to trigger a MCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mca_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_mca_collect_state
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|mca_info_list
modifier|*
name|reclst
parameter_list|)
block|{
name|struct
name|ia64_sal_result
name|result
decl_stmt|;
name|struct
name|mca_record_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mca_info
modifier|*
name|rec
decl_stmt|;
name|uint64_t
name|seqnr
decl_stmt|;
name|size_t
name|recsz
decl_stmt|;
comment|/* 	 * Don't try to get the state if we couldn't get the size of 	 * the state information previously. 	 */
if|if
condition|(
name|mca_info_size
index|[
name|type
index|]
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|mca_info_block
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|mca_info_block
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|sal_status
operator|<
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|mca_record_header
operator|*
operator|)
name|mca_info_block
expr_stmt|;
name|recsz
operator|=
name|hdr
operator|->
name|rh_length
expr_stmt|;
name|seqnr
operator|=
name|hdr
operator|->
name|rh_seqnr
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|rec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mca_info
argument_list|)
operator|+
name|recsz
argument_list|,
name|M_MCA
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
comment|/* XXX: Not sure what to do. */
break|break;
name|rec
operator|->
name|mi_seqnr
operator|=
name|seqnr
expr_stmt|;
name|rec
operator|->
name|mi_cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If the info block doesn't have our record anymore because 		 * we temporarily unlocked it, get it again from SAL. I assume 		 * that it's possible that we could get a different record. 		 * I expect this to happen in a SMP configuration where the 		 * record has been cleared by a different processor. So, if 		 * we get a different record we simply abort with this record 		 * and start over. 		 */
if|if
condition|(
name|seqnr
operator|!=
name|hdr
operator|->
name|rh_seqnr
condition|)
block|{
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|mca_info_block
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqnr
operator|!=
name|hdr
operator|->
name|rh_seqnr
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rec
argument_list|,
name|M_MCA
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|rec
operator|->
name|mi_recsz
operator|=
name|recsz
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mca_info_block
argument_list|,
name|rec
operator|->
name|mi_record
argument_list|,
name|recsz
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the state so that we get any other records when 		 * they exist. 		 */
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_CLEAR_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|reclst
argument_list|,
name|rec
argument_list|,
name|mi_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ia64_mca_save_state
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|mca_info_list
name|reclst
init|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|reclst
argument_list|)
decl_stmt|;
name|struct
name|mca_info
modifier|*
name|rec
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|ia64_mca_collect_state
argument_list|(
name|type
argument_list|,
operator|&
name|reclst
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|rec
argument_list|,
argument|&reclst
argument_list|,
argument|mi_link
argument_list|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%lu"
argument_list|,
name|rec
operator|->
name|mi_seqnr
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_mca
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|mca_sysctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mca_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rec
operator|->
name|mi_seqnr
operator|<
name|mca_first
condition|)
name|mca_first
operator|=
name|rec
operator|->
name|mi_seqnr
expr_stmt|;
elseif|else
if|if
condition|(
name|rec
operator|->
name|mi_seqnr
operator|>
name|mca_last
condition|)
name|mca_last
operator|=
name|rec
operator|->
name|mi_seqnr
expr_stmt|;
block|}
else|else
name|mca_first
operator|=
name|mca_last
operator|=
name|rec
operator|->
name|mi_seqnr
expr_stmt|;
name|mca_count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mca_sysctl_lock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%u"
argument_list|,
name|rec
operator|->
name|mi_cpuid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|rec
operator|->
name|mi_cpuid
argument_list|,
name|name
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|rec
operator|->
name|mi_record
argument_list|,
name|rec
operator|->
name|mi_recsz
argument_list|,
name|mca_sysctl_handler
argument_list|,
literal|"S,MCA"
argument_list|,
literal|"MCA record"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|ia64_mca_intr
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_int
name|xiv
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
if|if
condition|(
name|xiv
operator|==
name|mca_xiv_cmc
condition|)
block|{
name|printf
argument_list|(
literal|"MCA: corrected machine check (CMC) interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_mca_init_ap
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mca_xiv_cmc
operator|!=
literal|0
condition|)
name|ia64_set_cmcv
argument_list|(
name|mca_xiv_cmc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_mca_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ia64_sal_result
name|result
decl_stmt|;
name|uint64_t
name|max_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Get the sizes of the state information we can get from SAL and 	 * allocate a common block (forgive me my Fortran :-) for use by 	 * support functions. We create a region 7 address to make it 	 * easy on the OS_MCA or OS_INIT handlers to get the state info 	 * under unreliable conditions. 	 */
name|max_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAL_INFO_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO_SIZE
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|sal_status
operator|==
literal|0
condition|)
block|{
name|mca_info_size
index|[
name|i
index|]
operator|=
name|result
operator|.
name|sal_result
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mca_info_size
index|[
name|i
index|]
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|mca_info_size
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|mca_info_size
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|max_size
operator|=
name|round_page
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|max_size
operator|)
condition|?
name|contigmalloc
argument_list|(
name|max_size
argument_list|,
name|M_TEMP
argument_list|,
literal|0
argument_list|,
literal|0ul
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|mca_info_block
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|ia64_tpa
argument_list|(
operator|(
name|u_int64_t
operator|)
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MCA: allocated %ld bytes for state info.\n"
argument_list|,
name|max_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the spin lock used to protect the info block. When APs 	 * get launched, there's a short moment of contention, but in all other 	 * cases it's not a hot spot. I think it's possible to have the MCA 	 * handler be called on multiple processors at the same time, but that 	 * should be rare. On top of that, performance is not an issue when 	 * dealing with machine checks... 	 */
name|mtx_init
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|,
literal|"MCA info lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Serialize sysctl operations with a sleep lock. Note that this 	 * implies that we update the sysctl tree in a context that allows 	 * sleeping. 	 */
name|mtx_init
argument_list|(
operator|&
name|mca_sysctl_lock
argument_list|,
literal|"MCA sysctl lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Get and save any processor and platfom error records. Note that in 	 * a SMP configuration the processor records are for the BSP only. We 	 * let the APs get and save their own records when we wake them up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAL_INFO_TYPES
condition|;
name|i
operator|++
control|)
name|ia64_mca_save_state
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a XIV for CMC interrupts, so that we can collect and save 	 * the corrected processor checks. 	 */
name|mca_xiv_cmc
operator|=
name|ia64_xiv_alloc
argument_list|(
name|PI_SOFT
argument_list|,
name|IA64_XIV_PLAT
argument_list|,
name|ia64_mca_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mca_xiv_cmc
operator|!=
literal|0
condition|)
name|ia64_set_cmcv
argument_list|(
name|mca_xiv_cmc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"MCA: CMC vector could not be allocated\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

