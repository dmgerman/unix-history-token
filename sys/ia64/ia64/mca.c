begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/sal.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MCA
argument_list|,
literal|"MCA"
argument_list|,
literal|"Machine Check Architecture"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int64_t
name|mca_info_size
index|[
name|SAL_INFO_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|mca_info_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|mca_info_block_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mca
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"MCA container"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mca_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of records stored. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mca_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First (lowest) record ID. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mca_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last (highest) record ID. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_count
argument_list|,
literal|0
argument_list|,
literal|"Record count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|first
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_first
argument_list|,
literal|0
argument_list|,
literal|"First record id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mca
argument_list|,
name|OID_AUTO
argument_list|,
name|last
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mca_last
argument_list|,
literal|0
argument_list|,
literal|"Last record id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mca_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_mca_save_state
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|ia64_sal_result
name|result
decl_stmt|;
name|struct
name|mca_record_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oidp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|state
decl_stmt|;
name|uint64_t
name|seqnr
decl_stmt|;
name|size_t
name|recsz
decl_stmt|,
name|totsz
decl_stmt|;
comment|/* 	 * Don't try to get the state if we couldn't get the size of 	 * the state information previously. 	 */
if|if
condition|(
name|mca_info_size
index|[
name|type
index|]
operator|==
operator|-
literal|1
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|mca_info_block
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|sal_status
operator|<
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|mca_record_header
operator|*
operator|)
name|mca_info_block
expr_stmt|;
name|recsz
operator|=
name|hdr
operator|->
name|rh_length
expr_stmt|;
name|seqnr
operator|=
name|hdr
operator|->
name|rh_seqnr
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|totsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sysctl_oid
argument_list|)
operator|+
name|recsz
operator|+
literal|32
expr_stmt|;
name|oidp
operator|=
name|malloc
argument_list|(
name|totsz
argument_list|,
name|M_MCA
argument_list|,
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|oidp
operator|+
literal|1
operator|)
expr_stmt|;
name|name
operator|=
name|state
operator|+
name|recsz
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|seqnr
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If the info block doesn't have our record anymore because 		 * we temporarily unlocked it, get it again from SAL. I assume 		 * that it's possible that we could get a different record. 		 * I expect this to happen in a SMP configuration where the 		 * record has been cleared by a different processor. So, if 		 * we get a different record we simply abort with this record 		 * and start over. 		 */
if|if
condition|(
name|seqnr
operator|!=
name|hdr
operator|->
name|rh_seqnr
condition|)
block|{
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|mca_info_block
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqnr
operator|!=
name|hdr
operator|->
name|rh_seqnr
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oidp
argument_list|,
name|M_MCA
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mca_info_block
argument_list|,
name|state
argument_list|,
name|recsz
argument_list|)
expr_stmt|;
name|oidp
operator|->
name|oid_parent
operator|=
operator|&
name|sysctl__hw_mca_children
expr_stmt|;
name|oidp
operator|->
name|oid_number
operator|=
name|OID_AUTO
expr_stmt|;
name|oidp
operator|->
name|oid_kind
operator|=
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_DYN
expr_stmt|;
name|oidp
operator|->
name|oid_arg1
operator|=
name|state
expr_stmt|;
name|oidp
operator|->
name|oid_arg2
operator|=
name|recsz
expr_stmt|;
name|oidp
operator|->
name|oid_name
operator|=
name|name
expr_stmt|;
name|oidp
operator|->
name|oid_handler
operator|=
name|mca_sysctl_handler
expr_stmt|;
name|oidp
operator|->
name|oid_fmt
operator|=
literal|"S,MCA"
expr_stmt|;
name|oidp
operator|->
name|descr
operator|=
literal|"Error record"
expr_stmt|;
name|sysctl_register_oid
argument_list|(
name|oidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mca_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|seqnr
operator|<
name|mca_first
condition|)
name|mca_first
operator|=
name|seqnr
expr_stmt|;
elseif|else
if|if
condition|(
name|seqnr
operator|>
name|mca_last
condition|)
name|mca_last
operator|=
name|seqnr
expr_stmt|;
block|}
else|else
name|mca_first
operator|=
name|mca_last
operator|=
name|seqnr
expr_stmt|;
name|mca_count
operator|++
expr_stmt|;
comment|/* 		 * Clear the state so that we get any other records when 		 * they exist. 		 */
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_CLEAR_STATE_INFO
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ia64_mca_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ia64_sal_result
name|result
decl_stmt|;
name|uint64_t
name|max_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Get the sizes of the state information we can get from SAL and 	 * allocate a common block (forgive me my Fortran :-) for use by 	 * support functions. We create a region 7 address to make it 	 * easy on the OS_MCA or OS_INIT handlers to get the state info 	 * under unreliable conditions. 	 */
name|max_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAL_INFO_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|ia64_sal_entry
argument_list|(
name|SAL_GET_STATE_INFO_SIZE
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|sal_status
operator|==
literal|0
condition|)
block|{
name|mca_info_size
index|[
name|i
index|]
operator|=
name|result
operator|.
name|sal_result
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mca_info_size
index|[
name|i
index|]
operator|>
name|max_size
condition|)
name|max_size
operator|=
name|mca_info_size
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|mca_info_size
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|max_size
operator|=
name|round_page
argument_list|(
name|max_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|contigmalloc
argument_list|(
name|max_size
argument_list|,
name|M_TEMP
argument_list|,
literal|0
argument_list|,
literal|0ul
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|mca_info_block
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|ia64_tpa
argument_list|(
operator|(
name|u_int64_t
operator|)
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MCA: allocated %ld bytes for state information\n"
argument_list|,
name|max_size
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the spin lock used to protect the info block. When APs 	 * get launched, there's a short moment of contention, but in all other 	 * cases it's not a hot spot. I think it's possible to have the MCA 	 * handler be called on multiple processors at the same time, but that 	 * should be rare. On top of that, performance is not an issue when 	 * dealing with machine checks... 	 */
name|mtx_init
argument_list|(
operator|&
name|mca_info_block_lock
argument_list|,
literal|"MCA spin lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Get and save any processor and platfom error records. Note that in 	 * a SMP configuration the processor records are for the BSP only. We 	 * let the APs get and save their own records when we wake them up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAL_INFO_TYPES
condition|;
name|i
operator|++
control|)
name|ia64_mca_save_state
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

