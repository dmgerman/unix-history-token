begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  * Copyright (c) 1998,2000 Doug Rabson  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	from:	i386 Id: pmap.c,v 1.193 1998/04/19 15:22:48 bde Exp  *		with some ideas from NetBSD's alpha pmap  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_comment
comment|/*  * Following the Linux model, region IDs are allocated in groups of  * eight so that a single region ID can be used for as many RRs as we  * want by encoding the RR number into the low bits of the ID.  *  * We reserve region ID 0 for the kernel and allocate the remaining  * IDs for user pmaps.  *  * Region 0..4  *	User virtually mapped  *  * Region 5  *	Kernel virtually mapped  *  * Region 6  *	Kernel physically mapped uncacheable  *  * Region 7  *	Kernel physically mapped cacheable  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMAP
argument_list|,
literal|"PMAP"
argument_list|,
literal|"PMAP Structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MINPV
value|2048
end_define

begin_comment
comment|/* Preallocate at least this many */
end_comment

begin_define
define|#
directive|define
name|MAXPV
value|20480
end_define

begin_comment
comment|/* But no more than this */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_define
define|#
directive|define
name|PMAP_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get PDEs and PTEs for user/kernel address space  */
end_comment

begin_define
define|#
directive|define
name|pmap_pte_w
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pte_ig& PTE_IG_WIRED)
end_define

begin_define
define|#
directive|define
name|pmap_pte_managed
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pte_ig& PTE_IG_MANAGED)
end_define

begin_define
define|#
directive|define
name|pmap_pte_v
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pte_p)
end_define

begin_define
define|#
directive|define
name|pmap_pte_pa
parameter_list|(
name|pte
parameter_list|)
value|(((pte)->pte_ppn)<< 12)
end_define

begin_define
define|#
directive|define
name|pmap_pte_prot
parameter_list|(
name|pte
parameter_list|)
value|(((pte)->pte_ar<< 2) | (pte)->pte_pl)
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_w
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((v)?((pte)->pte_ig |= PTE_IG_WIRED) \ 				:((pte)->pte_ig&= ~PTE_IG_WIRED))
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_prot
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|do {		\     (pte)->pte_ar = v>> 2;			\     (pte)->pte_pl = v& 3;			\ } while (0)
end_define

begin_comment
comment|/*  * Given a map and a machine independent protection code,  * convert to an ia64 protection code.  */
end_comment

begin_define
define|#
directive|define
name|pte_prot
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(protection_codes[m == kernel_pmap ? 0 : 1][p])
end_define

begin_define
define|#
directive|define
name|pte_prot_pl
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(pte_prot(m, p)& 3)
end_define

begin_define
define|#
directive|define
name|pte_prot_ar
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(pte_prot(m, p)>> 2)
end_define

begin_decl_stmt
name|int
name|protection_codes
index|[
literal|2
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return non-zero if this pmap is currently active  */
end_comment

begin_define
define|#
directive|define
name|pmap_isactive
parameter_list|(
name|pmap
parameter_list|)
value|(pmap->pm_active)
end_define

begin_comment
comment|/*  * Statically allocated kernel pmap  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
specifier|static
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Has pmap_init completed? */
end_comment

begin_decl_stmt
name|vm_offset_t
name|vhpt_base
decl_stmt|,
name|vhpt_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We use an object to own the kernel's 'page tables'. For simplicity,  * we use one page directory to index a set of pages containing  * ia64_lptes. This gives us up to 2Gb of kernel virtual space.  */
end_comment

begin_decl_stmt
specifier|static
name|vm_object_t
name|kptobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ia64_lpte
modifier|*
modifier|*
name|kptdir
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KPTE_DIR_INDEX
parameter_list|(
name|va
parameter_list|)
define|\
value|((va>> (2*PAGE_SHIFT-5))& ((1<<(PAGE_SHIFT-3))-1))
end_define

begin_define
define|#
directive|define
name|KPTE_PTE_INDEX
parameter_list|(
name|va
parameter_list|)
define|\
value|((va>> PAGE_SHIFT)& ((1<<(PAGE_SHIFT-5))-1))
end_define

begin_define
define|#
directive|define
name|NKPTEPG
value|(PAGE_SIZE / sizeof(struct ia64_lpte))
end_define

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Values for ptc.e. XXX values for SKI.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|pmap_ptc_e_base
init|=
literal|0x100000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|pmap_ptc_e_count1
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|pmap_ptc_e_count2
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|pmap_ptc_e_stride1
init|=
literal|0x2000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|pmap_ptc_e_stride2
init|=
literal|0x100000000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the RID allocator  */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
modifier|*
name|pmap_ridbusy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_ridmax
decl_stmt|,
name|pmap_ridcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|pmap_ridmutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_pagedaemon_waken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pv_entry
modifier|*
name|pvbootentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pvbootnext
decl_stmt|,
name|pvbootmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for allocating PTEs for user processes.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ptezone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * VHPT instrumentation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmap_vhpt_inserts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_vhpt_collisions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_vhpt_resident
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vm_stats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|vhpt
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|inserts
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_inserts
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|collisions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_collisions
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|resident
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_resident
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_protection_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|vm_offset_t
name|pmap_steal_memory
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_size_t
name|bank_size
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|,
name|va
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|bank_size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|phys_avail
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"pmap_steal_memory: out of memory"
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pa
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
name|phys_avail
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
name|va
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|va
return|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|,
name|ridbits
decl_stmt|;
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
comment|/* 	 * Query the PAL Code to find the loop parameters for the 	 * ptc.e instruction. 	 */
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_PTCE_INFO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Can't configure ptc.e parameters"
argument_list|)
expr_stmt|;
name|pmap_ptc_e_base
operator|=
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
expr_stmt|;
name|pmap_ptc_e_count1
operator|=
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
operator|>>
literal|32
expr_stmt|;
name|pmap_ptc_e_count2
operator|=
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
operator|&
operator|(
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|pmap_ptc_e_stride1
operator|=
name|res
operator|.
name|pal_result
index|[
literal|2
index|]
operator|>>
literal|32
expr_stmt|;
name|pmap_ptc_e_stride2
operator|=
name|res
operator|.
name|pal_result
index|[
literal|2
index|]
operator|&
operator|(
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ptc.e base=0x%lx, count1=%ld, count2=%ld, "
literal|"stride1=0x%lx, stride2=0x%lx\n"
argument_list|,
name|pmap_ptc_e_base
argument_list|,
name|pmap_ptc_e_count1
argument_list|,
name|pmap_ptc_e_count2
argument_list|,
name|pmap_ptc_e_stride1
argument_list|,
name|pmap_ptc_e_stride2
argument_list|)
expr_stmt|;
comment|/* 	 * Setup RIDs. RIDs 0..7 are reserved for the kernel. 	 */
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_VM_SUMMARY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Can't read VM Summary - assuming 18 Region ID bits\n"
argument_list|)
expr_stmt|;
name|ridbits
operator|=
literal|18
expr_stmt|;
comment|/* guaranteed minimum */
block|}
else|else
block|{
name|ridbits
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Processor supports %d Region ID bits\n"
argument_list|,
name|ridbits
argument_list|)
expr_stmt|;
block|}
name|pmap_ridmax
operator|=
operator|(
literal|1
operator|<<
name|ridbits
operator|)
expr_stmt|;
name|pmap_ridcount
operator|=
literal|8
expr_stmt|;
name|pmap_ridbusy
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|pmap_ridmax
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pmap_ridbusy
argument_list|,
name|pmap_ridmax
operator|/
literal|8
argument_list|)
expr_stmt|;
name|pmap_ridbusy
index|[
literal|0
index|]
operator||=
literal|0xff
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|,
literal|"RID allocator lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate some memory for initial kernel 'page tables'. 	 */
name|kptdir
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKPT
condition|;
name|i
operator|++
control|)
block|{
name|kptdir
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|nkpt
operator|=
name|NKPT
expr_stmt|;
name|avail_start
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|avail_end
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|count
operator|=
name|i
operator|+
literal|2
expr_stmt|;
comment|/* 	 * Figure out a useful size for the VHPT, based on the size of 	 * physical memory and try to locate a region which is large 	 * enough to contain the VHPT (which must be a power of two in 	 * size and aligned to a natural boundary). 	 */
name|vhpt_size
operator|=
literal|15
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|vhpt_size
operator|)
operator|<
name|ia64_btop
argument_list|(
name|avail_end
operator|-
name|avail_start
argument_list|)
operator|*
literal|32
condition|)
name|vhpt_size
operator|++
expr_stmt|;
name|vhpt_base
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|vhpt_base
condition|)
block|{
name|vm_offset_t
name|mask
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Trying VHPT size 0x%lx\n"
argument_list|,
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|limit
decl_stmt|;
name|base
operator|=
operator|(
name|phys_avail
index|[
name|i
index|]
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
name|limit
operator|=
name|base
operator|+
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
comment|/* 				 * VHPT can fit in this region 				 */
break|break;
block|}
if|if
condition|(
operator|!
name|phys_avail
index|[
name|i
index|]
condition|)
block|{
comment|/* 			 * Can't fit, try next smaller size. 			 */
name|vhpt_size
operator|--
expr_stmt|;
block|}
else|else
block|{
name|vhpt_base
operator|=
operator|(
name|phys_avail
index|[
name|i
index|]
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vhpt_size
operator|<
literal|15
condition|)
name|panic
argument_list|(
literal|"Can't find space for VHPT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Putting VHPT at %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhpt_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhpt_base
operator|!=
name|phys_avail
index|[
name|i
index|]
condition|)
block|{
comment|/* 		 * Split this region. 		 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Splitting [%p-%p]\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|count
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|-=
literal|2
control|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|j
operator|-
literal|2
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|count
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|count
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|vhpt_base
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|vhpt_base
operator|+
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|vhpt_base
operator|+
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
expr_stmt|;
block|}
name|vhpt_base
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|vhpt_base
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vhpt_base
argument_list|,
operator|(
literal|1L
operator|<<
name|vhpt_size
operator|)
argument_list|)
expr_stmt|;
asm|__asm __volatile("mov cr.pta=%0;; srlz.i;;"
operator|::
literal|"r"
operator|(
name|vhpt_base
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
operator|(
name|vhpt_size
operator|<<
literal|2
operator|)
operator|+
literal|1
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|virtual_avail
operator|=
name|IA64_RR_BASE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|virtual_end
operator|=
name|IA64_RR_BASE
argument_list|(
literal|6
argument_list|)
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialize protection array. 	 */
end_comment

begin_expr_stmt
name|ia64_protection_init
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|kernel_pmap
operator|->
name|pm_rid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|kernel_pmap
operator|->
name|pm_active
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PCPU_SET
argument_list|(
name|current_pmap
argument_list|,
name|kernel_pmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Region 5 is mapped via the vhpt. 	 */
end_comment

begin_expr_stmt
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|5
argument_list|)
argument_list|,
operator|(
literal|5
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Region 6 is direct mapped UC and region 7 is direct mapped 	 * WC. The details of this is controlled by the Alt {I,D}TLB 	 * handlers. Here we just make sure that they have the largest  	 * possible page size to minimise TLB usage. 	 */
end_comment

begin_expr_stmt
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|6
argument_list|)
argument_list|,
operator|(
literal|6
operator|<<
literal|8
operator|)
operator||
operator|(
literal|28
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|7
argument_list|)
argument_list|,
operator|(
literal|7
operator|<<
literal|8
operator|)
operator||
operator|(
literal|28
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set up proc0's PCB. 	 */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|thread0.td_pcb->pcb_hw.apcb_asn = 0;
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * Reserve some memory for allocating pvs while bootstrapping 	 * the pv allocator. We need to have enough to cover mapping 	 * the kmem_alloc region used to allocate the initial_pvs in 	 * pmap_init. In general, the size of this region is 	 * approximately (# physical pages) * (size of pv entry). 	 */
end_comment

begin_expr_stmt
name|pvbootmax
operator|=
operator|(
operator|(
name|physmem
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
operator|+
literal|128
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pvbootentries
operator|=
operator|(
expr|struct
name|pv_entry
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|pvbootmax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pvbootnext
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Clear out any random TLB entries left over from booting. 	 */
end_comment

begin_expr_stmt
name|pmap_invalidate_all
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  void
operator|*
name|uma_small_alloc
argument_list|(
argument|uma_zone_t zone
argument_list|,
argument|int bytes
argument_list|,
argument|u_int8_t *flags
argument_list|,
argument|int wait
argument_list|)
block|{
specifier|static
name|vm_pindex_t
name|color
block|;
name|vm_page_t
name|m
block|;
name|int
name|pflags
block|;
name|void
operator|*
name|va
block|;
operator|*
name|flags
operator|=
name|UMA_SLAB_PRIV
block|;
if|if
condition|(
operator|(
name|wait
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_USE_RESERVE
operator|)
operator|)
operator|==
name|M_NOWAIT
condition|)
name|pflags
operator|=
name|VM_ALLOC_INTERRUPT
expr_stmt|;
else|else
name|pflags
operator|=
name|VM_ALLOC_SYSTEM
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|wait
operator|&
name|M_ZERO
condition|)
name|pflags
operator||=
name|VM_ALLOC_ZERO
expr_stmt|;
end_if

begin_expr_stmt
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|color
operator|++
argument_list|,
name|pflags
operator||
name|VM_ALLOC_NOOBJ
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|m
condition|)
block|{
name|va
operator|=
operator|(
name|void
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
name|NULL
operator|)
return|;
end_return

begin_macro
unit|}  void
name|uma_small_free
argument_list|(
argument|void *mem
argument_list|,
argument|int size
argument_list|,
argument|u_int8_t flags
argument_list|)
end_macro

begin_block
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|IA64_RR_MASK
argument_list|(
operator|(
name|u_int64_t
operator|)
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  *	pmap_init has been enhanced to support in a fairly consistant  *	way, discontiguous physical memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|vm_offset_t
name|phys_start
parameter_list|,
name|vm_offset_t
name|phys_end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|initial_pvs
decl_stmt|;
comment|/* 	 * Allocate memory for random pmap data structures.  Includes the 	 * pv_head_table. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_array_size
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
operator|&
name|vm_page_array
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Init the pv free list and the PTE free list. 	 */
name|initial_pvs
operator|=
name|vm_page_array_size
expr_stmt|;
if|if
condition|(
name|initial_pvs
operator|<
name|MINPV
condition|)
name|initial_pvs
operator|=
name|MINPV
expr_stmt|;
if|if
condition|(
name|initial_pvs
operator|>
name|MAXPV
condition|)
name|initial_pvs
operator|=
name|MAXPV
expr_stmt|;
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|pvzone
argument_list|,
name|initial_pvs
argument_list|)
expr_stmt|;
name|ptezone
operator|=
name|uma_zcreate
argument_list|(
literal|"PT ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ia64_lpte
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|ptezone
argument_list|,
name|initial_pvs
argument_list|)
expr_stmt|;
comment|/* 	 * Create the object for the kernel's page tables. 	 */
name|kptobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|MAXKPT
argument_list|)
expr_stmt|;
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the address space (zone) for the pv_entries.  Set a  * high water mark so that the system can recover from excessive  * numbers of pv entries.  */
end_comment

begin_function
name|void
name|pmap_init2
parameter_list|()
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|vm_page_array_size
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Manipulate TLBs for a pmap  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
operator|)
argument_list|,
operator|(
literal|"invalidating TLB for non-current pmap"
operator|)
argument_list|)
expr_stmt|;
name|ia64_ptc_g
argument_list|(
name|va
argument_list|,
name|PAGE_SHIFT
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_all_1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int64_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|register_t
name|psr
decl_stmt|;
name|psr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|addr
operator|=
name|pmap_ptc_e_base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_ptc_e_count1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pmap_ptc_e_count2
condition|;
name|j
operator|++
control|)
block|{
name|ia64_ptc_e
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|pmap_ptc_e_stride2
expr_stmt|;
block|}
name|addr
operator|+=
name|pmap_ptc_e_stride1
expr_stmt|;
block|}
name|intr_restore
argument_list|(
name|psr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
operator|)
argument_list|,
operator|(
literal|"invalidating TLB for non-current pmap"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|smp_rendezvous
argument_list|(
literal|0
argument_list|,
name|pmap_invalidate_all_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pmap_invalidate_all_1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|pmap_allocate_rid
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|pmap_ridcount
operator|==
name|pmap_ridmax
condition|)
name|panic
argument_list|(
literal|"pmap_allocate_rid: All Region IDs used"
argument_list|)
expr_stmt|;
do|do
block|{
name|rid
operator|=
name|arc4random
argument_list|()
operator|&
operator|(
name|pmap_ridmax
operator|-
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|pmap_ridbusy
index|[
name|rid
operator|/
literal|64
index|]
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|rid
operator|&
literal|63
operator|)
operator|)
condition|)
do|;
name|pmap_ridbusy
index|[
name|rid
operator|/
literal|64
index|]
operator||=
operator|(
literal|1L
operator|<<
operator|(
name|rid
operator|&
literal|63
operator|)
operator|)
expr_stmt|;
name|pmap_ridcount
operator|++
expr_stmt|;
return|return
name|rid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_free_rid
parameter_list|(
name|u_int32_t
name|rid
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
name|pmap_ridbusy
index|[
name|rid
operator|/
literal|64
index|]
operator|&=
operator|~
operator|(
literal|1L
operator|<<
operator|(
name|rid
operator|&
literal|63
operator|)
operator|)
expr_stmt|;
name|pmap_ridcount
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_ensure_rid
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|rr
decl_stmt|;
name|rr
operator|=
name|va
operator|>>
literal|61
expr_stmt|;
comment|/* 	 * We get called for virtual addresses that may just as well be 	 * kernel addresses (ie region 5, 6 or 7). Since the pm_rid field 	 * only holds region IDs for user regions, we have to make sure 	 * the region is within bounds. 	 */
if|if
condition|(
name|rr
operator|>=
literal|5
condition|)
return|return;
if|if
condition|(
name|pmap
operator|->
name|pm_rid
index|[
name|rr
index|]
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_rid
index|[
name|rr
index|]
operator|=
name|pmap_allocate_rid
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
condition|)
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
name|rr
argument_list|)
argument_list|,
operator|(
name|pmap
operator|->
name|pm_rid
index|[
name|rr
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level helper routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Install a pte into the VHPT  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_install_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|vhpte
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|)
block|{
name|u_int64_t
modifier|*
name|vhp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* invalidate the pte */
name|atomic_set_64
argument_list|(
operator|&
name|vhpte
operator|->
name|pte_tag
argument_list|,
literal|1L
operator|<<
literal|63
argument_list|)
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
comment|/* make sure everyone sees */
name|vhp
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|vhpte
expr_stmt|;
name|p
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|pte
expr_stmt|;
name|vhp
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|vhp
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|vhp
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
comment|/* sets ti to one */
name|ia64_mf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare essential parts of pte.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_equal_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte1
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte2
parameter_list|)
block|{
return|return
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
name|pte1
operator|==
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
name|pte2
return|;
block|}
end_function

begin_comment
comment|/*  * this routine defines the region(s) of memory that should  * not be tested for the modified bit.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_track_modified
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
operator|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|)
operator|||
operator|(
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|KSTACK_MAX_PAGES
end_ifndef

begin_define
define|#
directive|define
name|KSTACK_MAX_PAGES
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Create the KSTACK for a new thread.  * This routine directly affects the fork perf for a process/thread.  */
end_comment

begin_function
name|void
name|pmap_new_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pages
parameter_list|)
block|{
name|vm_offset_t
modifier|*
name|ks
decl_stmt|;
comment|/* Bounds check */
if|if
condition|(
name|pages
operator|<=
literal|1
condition|)
name|pages
operator|=
name|KSTACK_PAGES
expr_stmt|;
elseif|else
if|if
condition|(
name|pages
operator|>
name|KSTACK_MAX_PAGES
condition|)
name|pages
operator|=
name|KSTACK_MAX_PAGES
expr_stmt|;
comment|/* 	 * Use contigmalloc for user area so that we can use a region 	 * 7 address for it which makes it impossible to accidentally 	 * lose when recording a trapframe. 	 */
name|ks
operator|=
name|contigmalloc
argument_list|(
name|pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_PMAP
argument_list|,
name|M_WAITOK
argument_list|,
literal|0ul
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|256
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ks
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_new_thread: could not contigmalloc %d pages\n"
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_kstackvirt
operator|=
name|ks
expr_stmt|;
name|td
operator|->
name|td_kstack
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|ia64_tpa
argument_list|(
operator|(
name|u_int64_t
operator|)
name|ks
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kstack_pages
operator|=
name|pages
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispose the KSTACK for a thread that has exited.  * This routine directly impacts the exit perf of a process/thread.  */
end_comment

begin_function
name|void
name|pmap_dispose_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|pages
decl_stmt|;
name|pages
operator|=
name|td
operator|->
name|td_kstack_pages
expr_stmt|;
name|contigfree
argument_list|(
name|td
operator|->
name|td_md
operator|.
name|md_kstackvirt
argument_list|,
name|pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_PMAP
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|md_kstackvirt
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_kstack
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up a variable sized alternate kstack.  This appears to be MI.  */
end_comment

begin_function
name|void
name|pmap_new_altkstack
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pages
parameter_list|)
block|{
comment|/* 	 * Shuffle the original stack. Save the virtual kstack address 	 * instead of the physical address because 1) we can derive the 	 * physical address from the virtual address and 2) we need the 	 * virtual address in pmap_dispose_thread. 	 */
name|td
operator|->
name|td_altkstack_obj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|td
operator|->
name|td_altkstack
operator|=
operator|(
name|vm_offset_t
operator|)
name|td
operator|->
name|td_md
operator|.
name|md_kstackvirt
expr_stmt|;
name|td
operator|->
name|td_altkstack_pages
operator|=
name|td
operator|->
name|td_kstack_pages
expr_stmt|;
name|pmap_new_thread
argument_list|(
name|td
argument_list|,
name|pages
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_dispose_altkstack
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_dispose_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the original kstack. Note that td_altkstack holds the 	 * virtual kstack address of the previous kstack. 	 */
name|td
operator|->
name|td_md
operator|.
name|md_kstackvirt
operator|=
operator|(
name|void
operator|*
operator|)
name|td
operator|->
name|td_altkstack
expr_stmt|;
name|td
operator|->
name|td_kstack
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|ia64_tpa
argument_list|(
name|td
operator|->
name|td_altkstack
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kstack_obj
operator|=
name|td
operator|->
name|td_altkstack_obj
expr_stmt|;
name|td
operator|->
name|td_kstack_pages
operator|=
name|td
operator|->
name|td_altkstack_pages
expr_stmt|;
name|td
operator|->
name|td_altkstack
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_altkstack_obj
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_altkstack_pages
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow the KSTACK for a thread to be prejudicially paged out.  */
end_comment

begin_function
name|void
name|pmap_swapout_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Bring the KSTACK for a specified thread back in.  */
end_comment

begin_function
name|void
name|pmap_swapin_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{ }
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{
comment|/* kernel_pmap is the same as any other pmap. */
name|pmap_pinit
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmap
operator|->
name|pm_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wire in kernel global address entries.  To avoid a race condition  * between pmap initialization and pmap_growkernel, this procedure  * should be called after the vmspace is attached to the process  * but before this pmap is activated.  */
end_comment

begin_function
name|void
name|pmap_pinit2
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*************************************************** * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
condition|)
name|pmap_free_rid
argument_list|(
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|ptepage
decl_stmt|;
name|vm_page_t
name|nkpg
decl_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|==
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
name|nkpt
operator|*
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|+
name|IA64_RR_BASE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
operator|(
name|addr
operator|+
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
if|if
condition|(
name|kptdir
index|[
name|KPTE_DIR_INDEX
argument_list|(
name|kernel_vm_end
argument_list|)
index|]
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We could handle more by increasing the size of kptdir. 		 */
if|if
condition|(
name|nkpt
operator|==
name|MAXKPT
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: out of kernel address space"
argument_list|)
expr_stmt|;
comment|/* 		 * This index is bogus, but out of the way 		 */
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|kptobj
argument_list|,
name|nkpt
argument_list|,
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|nkpt
operator|++
expr_stmt|;
name|ptepage
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ptepage
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kptdir
index|[
name|KPTE_DIR_INDEX
argument_list|(
name|kernel_vm_end
argument_list|)
index|]
operator|=
name|ptepage
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  * the memory allocation is performed bypassing the malloc code  * because of the possibility of allocations at interrupt time.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_high_water
operator|&&
operator|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
operator|)
operator|&&
operator|(
name|pmap_pagedaemon_waken
operator|==
literal|0
operator|)
condition|)
block|{
name|pmap_pagedaemon_waken
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
block|}
return|return
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an ia64_lpte to the VHPT.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_vhpt
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|vhpte
decl_stmt|;
name|pmap_vhpt_inserts
operator|++
expr_stmt|;
name|pmap_vhpt_resident
operator|++
expr_stmt|;
name|vhpte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhpte
operator|->
name|pte_chain
condition|)
name|pmap_vhpt_collisions
operator|++
expr_stmt|;
name|pte
operator|->
name|pte_chain
operator|=
name|vhpte
operator|->
name|pte_chain
expr_stmt|;
name|vhpte
operator|->
name|pte_chain
operator|=
name|ia64_tpa
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vhpte
operator|->
name|pte_p
operator|&&
name|pte
operator|->
name|pte_p
condition|)
name|pmap_install_pte
argument_list|(
name|vhpte
argument_list|,
name|pte
argument_list|)
expr_stmt|;
else|else
name|ia64_mf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update VHPT after a pte has changed.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_update_vhpt
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|vhpte
decl_stmt|;
name|vhpte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|vhpte
operator|->
name|pte_p
operator|||
name|vhpte
operator|->
name|pte_tag
operator|==
name|pte
operator|->
name|pte_tag
operator|)
operator|&&
name|pte
operator|->
name|pte_p
condition|)
name|pmap_install_pte
argument_list|(
name|vhpte
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the ia64_lpte matching va from the VHPT. Return zero if it  * worked or an appropriate error code otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|lpte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|vhpte
decl_stmt|;
name|u_int64_t
name|tag
decl_stmt|;
name|int
name|error
init|=
name|ENOENT
decl_stmt|;
name|vhpte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * If the VHPTE is invalid, there can't be a collision chain. 	 */
if|if
condition|(
operator|!
name|vhpte
operator|->
name|pte_p
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|vhpte
operator|->
name|pte_chain
argument_list|,
operator|(
literal|"bad vhpte"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can't remove vhpt entry for 0x%lx\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lpte
operator|=
name|vhpte
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|vhpte
operator|->
name|pte_chain
argument_list|)
expr_stmt|;
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
while|while
condition|(
name|pte
operator|->
name|pte_tag
operator|!=
name|tag
condition|)
block|{
name|lpte
operator|=
name|pte
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_chain
condition|)
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|pte
operator|->
name|pte_chain
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"can't remove vhpt entry for 0x%lx\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Snip this pv_entry out of the collision chain. 	 */
name|lpte
operator|->
name|pte_chain
operator|=
name|pte
operator|->
name|pte_chain
expr_stmt|;
comment|/* 	 * If the VHPTE matches as well, change it to map the first 	 * element from the chain if there is one. 	 */
if|if
condition|(
name|vhpte
operator|->
name|pte_tag
operator|==
name|tag
condition|)
block|{
if|if
condition|(
name|vhpte
operator|->
name|pte_chain
condition|)
block|{
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|vhpte
operator|->
name|pte_chain
argument_list|)
expr_stmt|;
name|pmap_install_pte
argument_list|(
name|vhpte
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhpte
operator|->
name|pte_p
operator|=
literal|0
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
block|}
block|}
name|pmap_vhpt_resident
operator|--
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Find the ia64_lpte for the given va, if any.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|u_int64_t
name|tag
decl_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte
operator|->
name|pte_chain
condition|)
block|{
name|pte
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|pte
operator|->
name|pte_chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|pte
operator|->
name|pte_tag
operator|!=
name|tag
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pte_chain
condition|)
block|{
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|pte
operator|->
name|pte_chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pte
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
return|return
name|pte
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from the list of managed mappings.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pv
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|<
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pmap->pm_pvlist
argument_list|,
argument|pv_plist
argument_list|)
block|{
if|if
condition|(
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|pv
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENOENT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|()
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pa
operator|=
name|ia64_tpa
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return
name|pa
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Find the kernel lpte for mapping the given virtual address, which  * must be in the part of region 5 which we can cover with our kernel  * 'page tables'.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_kpte
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|va
operator|>>
literal|61
operator|)
operator|==
literal|5
argument_list|,
operator|(
literal|"kernel mapping 0x%lx not in region 5"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IA64_RR_MASK
argument_list|(
name|va
argument_list|)
operator|<
operator|(
name|nkpt
operator|*
name|PAGE_SIZE
operator|*
name|NKPTEPG
operator|)
argument_list|,
operator|(
literal|"kernel mapping 0x%lx out of range"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|kptdir
index|[
name|KPTE_DIR_INDEX
argument_list|(
name|va
argument_list|)
index|]
index|[
name|KPTE_PTE_INDEX
argument_list|(
name|va
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Find a pte suitable for mapping a user-space address. If one exists   * in the VHPT, that one will be returned, otherwise a new pte is  * allocated.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_pte
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
return|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte
condition|)
block|{
name|pte
operator|=
name|uma_zalloc
argument_list|(
name|ptezone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pte_p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|pte
return|;
block|}
end_function

begin_comment
comment|/*  * Free a pte which is now unused. This simply returns it to the zone  * allocator if it is a user mapping. For kernel mappings, clear the  * valid bit to make it clear that the mapping is not currently used.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
name|uma_zfree
argument_list|(
name|ptezone
argument_list|,
name|pte
argument_list|)
expr_stmt|;
else|else
name|pte
operator|->
name|pte_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a pte to contain a valid mapping and enter it in the VHPT. If  * the pte was orginally valid, then its assumed to already be in the  * VHPT.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_set_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|ig
parameter_list|,
name|int
name|pl
parameter_list|,
name|int
name|ar
parameter_list|)
block|{
name|int
name|wasvalid
init|=
name|pte
operator|->
name|pte_p
decl_stmt|;
name|pte
operator|->
name|pte_p
operator|=
literal|1
expr_stmt|;
name|pte
operator|->
name|pte_ma
operator|=
name|PTE_MA_WB
expr_stmt|;
if|if
condition|(
name|ig
operator|&
name|PTE_IG_MANAGED
condition|)
block|{
name|pte
operator|->
name|pte_a
operator|=
literal|0
expr_stmt|;
name|pte
operator|->
name|pte_d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pte
operator|->
name|pte_a
operator|=
literal|1
expr_stmt|;
name|pte
operator|->
name|pte_d
operator|=
literal|1
expr_stmt|;
block|}
name|pte
operator|->
name|pte_pl
operator|=
name|pl
expr_stmt|;
name|pte
operator|->
name|pte_ar
operator|=
name|ar
expr_stmt|;
name|pte
operator|->
name|pte_ppn
operator|=
name|pa
operator|>>
literal|12
expr_stmt|;
name|pte
operator|->
name|pte_ed
operator|=
literal|0
expr_stmt|;
name|pte
operator|->
name|pte_ig
operator|=
name|ig
expr_stmt|;
name|pte
operator|->
name|pte_ps
operator|=
name|PAGE_SHIFT
expr_stmt|;
name|pte
operator|->
name|pte_key
operator|=
literal|0
expr_stmt|;
name|pte
operator|->
name|pte_tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasvalid
condition|)
block|{
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If a pte contains a valid mapping, clear it and update the VHPT.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_clear_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|pte
operator|->
name|pte_p
condition|)
block|{
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|ia64_ptc_g
argument_list|(
name|va
argument_list|,
name|PAGE_SHIFT
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pte_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove the (possibly managed) mapping represented by pte from the  * given pmap.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|,
name|int
name|freepte
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
operator|)
argument_list|,
operator|(
literal|"removing pte for non-current pmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First remove from the VHPT. 	 */
name|error
operator|=
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * Make sure pmap_set_pte() knows it isn't in the VHPT. 	 */
name|pte
operator|->
name|pte_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_ig
operator|&
name|PTE_IG_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_ig
operator|&
name|PTE_IG_MANAGED
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_d
condition|)
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_a
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|freepte
condition|)
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|pv
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|freepte
condition|)
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|tva
init|=
name|va
operator|+
name|i
operator|*
name|PAGE_SIZE
decl_stmt|;
name|int
name|wasvalid
decl_stmt|;
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|tva
argument_list|)
expr_stmt|;
name|wasvalid
operator|=
name|pte
operator|->
name|pte_p
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|tva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|PTE_PL_KERN
argument_list|,
name|PTE_AR_RWX
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasvalid
condition|)
name|ia64_ptc_g
argument_list|(
name|tva
argument_list|,
name|PAGE_SHIFT
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_clear_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a wired page to the kva.  */
end_comment

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|wasvalid
decl_stmt|;
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|wasvalid
operator|=
name|pte
operator|->
name|pte_p
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|,
name|PTE_PL_KERN
argument_list|,
name|PTE_AR_RWX
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasvalid
condition|)
name|ia64_ptc_g
argument_list|(
name|va
argument_list|,
name|PAGE_SHIFT
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a page from the kva  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_clear_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
name|IA64_PHYS_TO_RR7
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a single page from a process address space  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
operator|)
argument_list|,
operator|(
literal|"removing page for non-current pmap"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
condition|)
block|{
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * special handling of removing one page.  a very 	 * common operation and easy to short circuit some 	 * code. 	 */
if|if
condition|(
name|sva
operator|+
name|PAGE_SIZE
operator|==
name|eva
condition|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|<
operator|(
operator|(
name|eva
operator|-
name|sva
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pmap->pm_pvlist
argument_list|,
argument|pv_plist
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|sva
operator|&&
name|va
operator|<
name|eva
condition|)
block|{
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
name|pv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|=
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
condition|)
block|{
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
comment|/* 	 * XXX this makes pmap_page_protect(NONE) illegal for non-managed 	 * pages! 	 */
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_page_protect: illegal for unmanaged page, va: 0x%lx"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|pmap
init|=
name|pv
operator|->
name|pv_pmap
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|pv
operator|->
name|pv_va
decl_stmt|;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
operator|!=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_remove_all: pv_table for %lx is inconsistent"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
name|pv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|newprot
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|newprot
operator|=
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sva
operator|&
name|PAGE_MASK
operator|)
operator|||
operator|(
name|eva
operator|&
name|PAGE_MASK
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_protect: unaligned addresses"
argument_list|)
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
comment|/*  		 * If page is invalid, skip this page 		 */
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte
condition|)
block|{
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pmap_pte_prot
argument_list|(
name|pte
argument_list|)
operator|!=
name|newprot
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pte_ig
operator|&
name|PTE_IG_MANAGED
condition|)
block|{
name|vm_offset_t
name|pa
init|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
decl_stmt|;
name|vm_page_t
name|m
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
decl_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_d
condition|)
block|{
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|sva
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pte_d
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pte
operator|->
name|pte_a
condition|)
block|{
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pte_a
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|pmap_pte_set_prot
argument_list|(
name|pte
argument_list|,
name|newprot
argument_list|)
expr_stmt|;
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|struct
name|ia64_lpte
name|origpte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|managed
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|pmap_ensure_rid
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DIAGNOSTIC
if|if
condition|(
name|va
operator|>
name|VM_MAX_KERNEL_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: toobig"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Find (or create) a pte for the given mapping. 	 */
name|pte
operator|=
name|pmap_find_pte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|origpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|origpte
operator|.
name|pte_p
condition|)
name|opa
operator|=
name|pmap_pte_pa
argument_list|(
operator|&
name|origpte
argument_list|)
expr_stmt|;
else|else
name|opa
operator|=
literal|0
expr_stmt|;
name|managed
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|origpte
operator|.
name|pte_p
operator|&&
operator|(
name|opa
operator|==
name|pa
operator|)
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|(
operator|(
name|origpte
operator|.
name|pte_ig
operator|&
name|PTE_IG_WIRED
operator|)
operator|==
literal|0
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|origpte
operator|.
name|pte_ig
operator|&
name|PTE_IG_WIRED
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. 		 */
if|if
condition|(
name|origpte
operator|.
name|pte_ig
operator|&
name|PTE_IG_MANAGED
condition|)
block|{
if|if
condition|(
name|origpte
operator|.
name|pte_d
operator|&&
name|pmap_track_modified
argument_list|(
name|va
argument_list|)
condition|)
block|{
name|vm_page_t
name|om
decl_stmt|;
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|opa
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
block|}
block|}
name|managed
operator|=
name|origpte
operator|.
name|pte_ig
operator|&
name|PTE_IG_MANAGED
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall 	 * through to handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pte vanished, va: 0x%lx"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
name|pmap_initialized
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|managed
operator||=
name|PTE_IG_MANAGED
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. This 	 * adds the pte to the VHPT if necessary. 	 */
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|managed
operator||
operator|(
name|wired
condition|?
name|PTE_IG_WIRED
else|:
literal|0
operator|)
argument_list|,
name|pte_prot_pl
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
argument_list|,
name|pte_prot_ar
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * if the mapping or permission bits are different, we need 	 * to invalidate the page. 	 */
if|if
condition|(
operator|!
name|pmap_equal_pte
argument_list|(
operator|&
name|origpte
argument_list|,
name|pte
argument_list|)
condition|)
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * 5. Tlbflush is deferred to calling procedure.  * 6. Page IS managed.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|;
name|pmap_ensure_rid
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_pte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_p
condition|)
return|return;
comment|/* 	 * Enter on the PV list since its part of our managed memory. 	 */
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Initialise PTE with read-only protection and enter into VHPT. 	 */
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|PTE_IG_MANAGED
argument_list|,
name|PTE_PL_USER
argument_list|,
name|PTE_AR_R
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make temporary mapping for a physical address. This is called  * during dump.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temporary
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|pa
operator|-
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_INIT_PT
value|(96)
end_define

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|tmpidx
decl_stmt|;
name|int
name|psize
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|objpgs
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
operator|||
name|object
operator|==
name|NULL
condition|)
return|return;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|psize
operator|=
name|ia64_btop
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
operator|)
operator|||
operator|(
operator|(
name|limit
operator|&
name|MAP_PREFAULT_PARTIAL
operator|)
operator|&&
operator|(
name|psize
operator|>
name|MAX_INIT_PT
operator|)
operator|&&
operator|(
name|object
operator|->
name|resident_page_count
operator|>
name|MAX_INIT_PT
operator|)
operator|)
condition|)
block|{
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|psize
operator|+
name|pindex
operator|>
name|object
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|size
operator|<
name|pindex
condition|)
return|return;
name|psize
operator|=
name|object
operator|->
name|size
operator|-
name|pindex
expr_stmt|;
block|}
comment|/* 	 * if we are processing a major portion of the object, then scan the 	 * entire thing. 	 */
if|if
condition|(
name|psize
operator|>
operator|(
name|object
operator|->
name|resident_page_count
operator|>>
literal|2
operator|)
condition|)
block|{
name|objpgs
operator|=
name|psize
expr_stmt|;
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
init|;
operator|(
operator|(
name|objpgs
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|)
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
control|)
block|{
name|tmpidx
operator|=
name|p
operator|->
name|pindex
expr_stmt|;
if|if
condition|(
name|tmpidx
operator|<
name|pindex
condition|)
block|{
continue|continue;
block|}
name|tmpidx
operator|-=
name|pindex
expr_stmt|;
if|if
condition|(
name|tmpidx
operator|>=
name|psize
condition|)
block|{
continue|continue;
block|}
comment|/* 			 * don't allow an madvise to blow away our really 			 * free pages allocating pv entries. 			 */
if|if
condition|(
operator|(
name|limit
operator|&
name|MAP_PREFAULT_MADVISE
operator|)
operator|&&
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
break|break;
block|}
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
operator|(
name|p
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|queue
operator|-
name|p
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|vm_page_deactivate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_busy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
operator|+
name|ia64_ptob
argument_list|(
name|tmpidx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|objpgs
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * else lookup the pages one-by-one. 		 */
for|for
control|(
name|tmpidx
operator|=
literal|0
init|;
name|tmpidx
operator|<
name|psize
condition|;
name|tmpidx
operator|+=
literal|1
control|)
block|{
comment|/* 			 * don't allow an madvise to blow away our really 			 * free pages allocating pv entries. 			 */
if|if
condition|(
operator|(
name|limit
operator|&
name|MAP_PREFAULT_MADVISE
operator|)
operator|&&
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
break|break;
block|}
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|tmpidx
operator|+
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|&&
operator|(
name|p
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|queue
operator|-
name|p
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|vm_page_deactivate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_busy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
operator|+
name|ia64_ptob
argument_list|(
name|tmpidx
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * pmap_prefault provides a quick way of clustering  * pagefaults into a processes address space.  It is a "cousin"  * of pmap_object_init_pt, except it runs at page fault time instead  * of mmap time.  */
end_comment

begin_define
define|#
directive|define
name|PFBAK
value|4
end_define

begin_define
define|#
directive|define
name|PFFOR
value|4
end_define

begin_define
define|#
directive|define
name|PAGEORDER_SIZE
value|(PFBAK+PFFOR)
end_define

begin_decl_stmt
specifier|static
name|int
name|pmap_prefault_pageorder
index|[]
init|=
block|{
operator|-
literal|1
operator|*
name|PAGE_SIZE
block|,
literal|1
operator|*
name|PAGE_SIZE
block|,
operator|-
literal|2
operator|*
name|PAGE_SIZE
block|,
literal|2
operator|*
name|PAGE_SIZE
block|,
operator|-
literal|3
operator|*
name|PAGE_SIZE
block|,
literal|3
operator|*
name|PAGE_SIZE
block|,
operator|-
literal|4
operator|*
name|PAGE_SIZE
block|,
literal|4
operator|*
name|PAGE_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_prefault
parameter_list|(
name|pmap
parameter_list|,
name|addra
parameter_list|,
name|entry
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|addra
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|starta
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
operator|!
name|curthread
operator|||
operator|(
name|pmap
operator|!=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
operator|)
condition|)
return|return;
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|starta
operator|=
name|addra
operator|-
name|PFBAK
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|starta
operator|<
name|entry
operator|->
name|start
condition|)
block|{
name|starta
operator|=
name|entry
operator|->
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starta
operator|>
name|addra
condition|)
block|{
name|starta
operator|=
literal|0
expr_stmt|;
block|}
name|mpte
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGEORDER_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vm_object_t
name|lobject
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|addr
operator|=
name|addra
operator|+
name|pmap_prefault_pageorder
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|addra
operator|+
operator|(
name|PFFOR
operator|*
name|PAGE_SIZE
operator|)
condition|)
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|starta
operator|||
name|addr
operator|>=
name|entry
operator|->
name|end
condition|)
continue|continue;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|&&
name|pte
operator|->
name|pte_p
condition|)
continue|continue;
name|pindex
operator|=
operator|(
operator|(
name|addr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|lobject
operator|=
name|object
expr_stmt|;
for|for
control|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|lobject
argument_list|,
name|pindex
argument_list|)
init|;
operator|(
operator|!
name|m
operator|&&
operator|(
name|lobject
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|)
operator|&&
operator|(
name|lobject
operator|->
name|backing_object
operator|)
operator|)
condition|;
name|lobject
operator|=
name|lobject
operator|->
name|backing_object
control|)
block|{
if|if
condition|(
name|lobject
operator|->
name|backing_object_offset
operator|&
name|PAGE_MASK
condition|)
break|break;
name|pindex
operator|+=
operator|(
name|lobject
operator|->
name|backing_object_offset
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|lobject
operator|->
name|backing_object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * give-up when a page is not in memory 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|m
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|==
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
block|{
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|pmap_enter_quick
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Wiring is not a hardware characteristic so there is no need to 	 * invalidate TLB. 	 */
name|pmap_pte_set_w
argument_list|(
name|pte
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  *  *	off and size must reside within a single page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|caddr_t
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  This is for the vm_idlezero process.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|src
init|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
argument_list|)
decl_stmt|;
name|vm_offset_t
name|dst
init|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 	 * Not found, check current mappings returning immediately if found. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
end_define

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
if|if
condition|(
operator|!
name|curthread
operator|||
operator|(
name|pmap
operator|!=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"warning: pmap_remove_pages called with non-current pmap\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|>=
name|eva
operator|||
name|pv
operator|->
name|pv_va
operator|<
name|sva
condition|)
block|{
continue|continue;
block|}
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte
condition|)
name|panic
argument_list|(
literal|"pmap_remove_pages: page on pm_pvlist has no pte\n"
argument_list|)
expr_stmt|;
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|pte
operator|->
name|pte_ig
operator|&
name|PTE_IG_WIRED
condition|)
block|{
continue|continue;
block|}
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      pmap_page_protect:  *  *      Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|int
name|newprot
init|=
name|pte_prot
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|prot
argument_list|)
decl_stmt|;
name|pmap_t
name|oldpmap
init|=
name|pmap_install
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_pte_set_prot
argument_list|(
name|pte
argument_list|,
name|newprot
argument_list|)
expr_stmt|;
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pmap_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|int
name|ppn
parameter_list|)
block|{
return|return
operator|(
name|ia64_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *   *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return
literal|0
return|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap_t
name|oldpmap
init|=
name|pmap_install
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_a
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|pte
operator|->
name|pte_a
operator|=
literal|0
expr_stmt|;
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_endif
unit|static boolean_t pmap_is_referenced(vm_page_t m) { 	pv_entry_t pv;  	if (!pmap_initialized || (m->flags& PG_FICTITIOUS)) 		return FALSE;  	TAILQ_FOREACH(pv,&m->md.pv_list, pv_list) { 		pmap_t oldpmap = pmap_install(pv->pv_pmap); 		struct ia64_lpte *pte = pmap_find_vhpt(pv->pv_va); 		pmap_install(oldpmap); 		if (pte->pte_a) 			return 1; 	}  	return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return
name|FALSE
return|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap_t
name|oldpmap
init|=
name|pmap_install
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
init|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
decl_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_d
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap_t
name|oldpmap
init|=
name|pmap_install
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
init|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
decl_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_d
condition|)
block|{
name|pte
operator|->
name|pte_d
operator|=
literal|0
expr_stmt|;
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_initialized
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
return|return;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap_t
name|oldpmap
init|=
name|pmap_install
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
init|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
decl_stmt|;
if|if
condition|(
name|pte
operator|->
name|pte_a
condition|)
block|{
name|pte
operator|->
name|pte_a
operator|=
literal|0
expr_stmt|;
name|pmap_update_vhpt
argument_list|(
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_function
specifier|static
name|void
name|ia64_protection_init
parameter_list|()
block|{
name|int
name|prot
decl_stmt|,
modifier|*
name|kp
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|kp
operator|=
name|protection_codes
index|[
literal|0
index|]
expr_stmt|;
name|up
operator|=
name|protection_codes
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|prot
operator|=
literal|0
init|;
name|prot
operator|<
literal|8
condition|;
name|prot
operator|++
control|)
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_R
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_R
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_X_RX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_X_RX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_RW
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_RW
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_RWX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_RWX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_R
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_R
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_RX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_RX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_RW
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_RW
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
operator|(
name|PTE_AR_RWX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_KERN
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|PTE_AR_RWX
operator|<<
literal|2
operator|)
operator||
name|PTE_PL_USER
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|IA64_PHYS_TO_RR6
argument_list|(
name|pa
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'Unmap' a range mapped by pmap_mapdev().  */
end_comment

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|oldpmap
operator|=
name|pmap_install
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pmap_install
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pte
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|->
name|pte_ig
operator|&
name|PTE_IG_MANAGED
operator|)
operator|==
literal|0
condition|)
return|return
name|val
return|;
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 		 * Modified by us 		 */
if|if
condition|(
name|pte
operator|->
name|pte_d
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
comment|/* 		 * Modified by someone 		 */
elseif|else
if|if
condition|(
name|pmap_is_modified
argument_list|(
name|m
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
comment|/* 		 * Referenced by us 		 */
if|if
condition|(
name|pte
operator|->
name|pte_a
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
comment|/* 		 * Referenced by someone 		 */
elseif|else
if|if
condition|(
name|pmap_ts_referenced
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|val
operator||=
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_install
argument_list|(
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|pmap_t
name|pmap_install
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|oldpmap
operator|=
name|PCPU_GET
argument_list|(
name|current_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|oldpmap
operator|||
name|pmap
operator|==
name|kernel_pmap
condition|)
block|{
name|critical_exit
argument_list|()
expr_stmt|;
return|return
name|pmap
return|;
block|}
if|if
condition|(
name|oldpmap
condition|)
block|{
name|atomic_clear_32
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|current_pmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap
condition|)
block|{
comment|/* 		 * RIDs 0..4 have no mappings to make sure we generate  		 * page faults on accesses. 		 */
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|(
literal|2
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|3
argument_list|)
argument_list|,
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|4
argument_list|)
argument_list|,
operator|(
literal|4
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
name|oldpmap
return|;
block|}
name|atomic_set_32
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
name|oldpmap
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
name|addr
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|psnames
index|[]
init|=
block|{
literal|"1B"
block|,
literal|"2B"
block|,
literal|"4B"
block|,
literal|"8B"
block|,
literal|"16B"
block|,
literal|"32B"
block|,
literal|"64B"
block|,
literal|"128B"
block|,
literal|"256B"
block|,
literal|"512B"
block|,
literal|"1K"
block|,
literal|"2K"
block|,
literal|"4K"
block|,
literal|"8K"
block|,
literal|"16K"
block|,
literal|"32K"
block|,
literal|"64K"
block|,
literal|"128K"
block|,
literal|"256K"
block|,
literal|"512K"
block|,
literal|"1M"
block|,
literal|"2M"
block|,
literal|"4M"
block|,
literal|"8M"
block|,
literal|"16M"
block|,
literal|"32M"
block|,
literal|"64M"
block|,
literal|"128M"
block|,
literal|"256M"
block|,
literal|"512M"
block|,
literal|"1G"
block|,
literal|"2G"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_trs
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxtr
decl_stmt|;
struct|struct
block|{
name|struct
name|ia64_pte
name|pte
decl_stmt|;
name|struct
name|ia64_itir
name|itir
decl_stmt|;
name|struct
name|ia64_ifa
name|ifa
decl_stmt|;
name|struct
name|ia64_rr
name|rr
decl_stmt|;
block|}
name|buf
struct|;
specifier|static
specifier|const
name|char
modifier|*
name|manames
index|[]
init|=
block|{
literal|"WB"
block|,
literal|"bad"
block|,
literal|"bad"
block|,
literal|"bad"
block|,
literal|"UC"
block|,
literal|"UCE"
block|,
literal|"WC"
block|,
literal|"NaT"
block|, 		 	}
decl_stmt|;
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_VM_SUMMARY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Can't get VM summary\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|maxtr
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|>>
literal|40
operator|)
operator|&
literal|0xff
expr_stmt|;
else|else
name|maxtr
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|>>
literal|32
operator|)
operator|&
literal|0xff
expr_stmt|;
name|db_printf
argument_list|(
literal|"V RID    Virtual Page  Physical Page PgSz ED AR PL D A MA  P KEY\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxtr
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|ia64_call_pal_stacked_physical
argument_list|(
name|PAL_VM_TR_READ
argument_list|,
name|i
argument_list|,
name|type
argument_list|,
name|ia64_tpa
argument_list|(
operator|(
name|u_int64_t
operator|)
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|1
operator|)
condition|)
name|buf
operator|.
name|pte
operator|.
name|pte_ar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|2
operator|)
condition|)
name|buf
operator|.
name|pte
operator|.
name|pte_pl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|4
operator|)
condition|)
name|buf
operator|.
name|pte
operator|.
name|pte_d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|8
operator|)
condition|)
name|buf
operator|.
name|pte
operator|.
name|pte_ma
operator|=
literal|0
expr_stmt|;
name|db_printf
argument_list|(
literal|"%d %06x %013lx %013lx %4s %d  %d  %d  %d %d %-3s %d %06x\n"
argument_list|,
name|buf
operator|.
name|ifa
operator|.
name|ifa_ig
operator|&
literal|1
argument_list|,
name|buf
operator|.
name|rr
operator|.
name|rr_rid
argument_list|,
name|buf
operator|.
name|ifa
operator|.
name|ifa_vpn
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_ppn
argument_list|,
name|psnames
index|[
name|buf
operator|.
name|itir
operator|.
name|itir_ps
index|]
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_ed
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_ar
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_pl
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_d
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_a
argument_list|,
name|manames
index|[
name|buf
operator|.
name|pte
operator|.
name|pte_ma
index|]
argument_list|,
name|buf
operator|.
name|pte
operator|.
name|pte_p
argument_list|,
name|buf
operator|.
name|itir
operator|.
name|itir_key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|DB_COMMAND
argument_list|(
argument|itr
argument_list|,
argument|db_itr
argument_list|)
end_macro

begin_block
block|{
name|print_trs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|dtr
argument_list|,
argument|db_dtr
argument_list|)
end_macro

begin_block
block|{
name|print_trs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|rr
argument_list|,
argument|db_rr
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|u_int64_t
name|t
decl_stmt|;
name|struct
name|ia64_rr
name|rr
decl_stmt|;
name|printf
argument_list|(
literal|"RR RID    PgSz VE\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
asm|__asm __volatile ("mov %0=rr[%1]"
block|:
literal|"=r"
operator|(
name|t
operator|)
operator|:
literal|"r"
operator|(
name|IA64_RR_BASE
argument_list|(
name|i
argument_list|)
operator|)
block|)
empty_stmt|;
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
operator|&
name|rr
operator|=
name|t
expr_stmt|;
name|printf
argument_list|(
literal|"%d  %06x %4s %d\n"
argument_list|,
name|i
argument_list|,
name|rr
operator|.
name|rr_rid
argument_list|,
name|psnames
index|[
name|rr
operator|.
name|rr_ps
index|]
argument_list|,
name|rr
operator|.
name|rr_ve
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}  DB_COMMAND
operator|(
name|thash
operator|,
name|db_thash
operator|)
block|{
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
name|db_printf
argument_list|(
literal|"%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ia64_thash
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DB_COMMAND
operator|(
name|ttag
operator|,
name|db_ttag
operator|)
block|{
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
name|db_printf
argument_list|(
literal|"0x%lx\n"
argument_list|,
name|ia64_ttag
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

