begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  * Copyright (c) 1998,2000 Doug Rabson  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	from:	i386 Id: pmap.c,v 1.193 1998/04/19 15:22:48 bde Exp  *		with some ideas from NetBSD's alpha pmap  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/efi.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_comment
comment|/*  *	Manages physical address maps.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_comment
comment|/*  * Following the Linux model, region IDs are allocated in groups of  * eight so that a single region ID can be used for as many RRs as we  * want by encoding the RR number into the low bits of the ID.  *  * We reserve region ID 0 for the kernel and allocate the remaining  * IDs for user pmaps.  *  * Region 0-3:	User virtually mapped  * Region 4:	PBVM and special mappings  * Region 5:	Kernel virtual memory  * Region 6:	Direct-mapped uncacheable  * Region 7:	Direct-mapped cacheable  */
end_comment

begin_comment
comment|/* XXX move to a header. */
end_comment

begin_decl_stmt
specifier|extern
name|uint64_t
name|ia64_gateway_page
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_accessed
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_ACCESSED)
end_define

begin_define
define|#
directive|define
name|pmap_dirty
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_DIRTY)
end_define

begin_define
define|#
directive|define
name|pmap_exec
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_AR_RX)
end_define

begin_define
define|#
directive|define
name|pmap_managed
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_MANAGED)
end_define

begin_define
define|#
directive|define
name|pmap_ppn
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_PPN_MASK)
end_define

begin_define
define|#
directive|define
name|pmap_present
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_PRESENT)
end_define

begin_define
define|#
directive|define
name|pmap_prot
parameter_list|(
name|lpte
parameter_list|)
value|(((lpte)->pte& PTE_PROT_MASK)>> 56)
end_define

begin_define
define|#
directive|define
name|pmap_wired
parameter_list|(
name|lpte
parameter_list|)
value|((lpte)->pte& PTE_WIRED)
end_define

begin_define
define|#
directive|define
name|pmap_clear_accessed
parameter_list|(
name|lpte
parameter_list|)
value|(lpte)->pte&= ~PTE_ACCESSED
end_define

begin_define
define|#
directive|define
name|pmap_clear_dirty
parameter_list|(
name|lpte
parameter_list|)
value|(lpte)->pte&= ~PTE_DIRTY
end_define

begin_define
define|#
directive|define
name|pmap_clear_present
parameter_list|(
name|lpte
parameter_list|)
value|(lpte)->pte&= ~PTE_PRESENT
end_define

begin_define
define|#
directive|define
name|pmap_clear_wired
parameter_list|(
name|lpte
parameter_list|)
value|(lpte)->pte&= ~PTE_WIRED
end_define

begin_define
define|#
directive|define
name|pmap_set_wired
parameter_list|(
name|lpte
parameter_list|)
value|(lpte)->pte |= PTE_WIRED
end_define

begin_comment
comment|/*  * Individual PV entries are stored in per-pmap chunks.  This saves  * space by eliminating the need to record the pmap within every PV  * entry.  */
end_comment

begin_if
if|#
directive|if
name|PAGE_SIZE
operator|==
literal|8192
end_if

begin_define
define|#
directive|define
name|_NPCM
value|6
end_define

begin_define
define|#
directive|define
name|_NPCPV
value|337
end_define

begin_define
define|#
directive|define
name|_NPCS
value|2
end_define

begin_elif
elif|#
directive|elif
name|PAGE_SIZE
operator|==
literal|16384
end_elif

begin_define
define|#
directive|define
name|_NPCM
value|11
end_define

begin_define
define|#
directive|define
name|_NPCPV
value|677
end_define

begin_define
define|#
directive|define
name|_NPCS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|pv_chunk
block|{
name|pmap_t
name|pc_pmap
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|pv_chunk
argument_list|)
name|pc_list
expr_stmt|;
name|u_long
name|pc_map
index|[
name|_NPCM
index|]
decl_stmt|;
comment|/* bitmap; 1 = free */
name|TAILQ_ENTRY
argument_list|(
argument|pv_chunk
argument_list|)
name|pc_lru
expr_stmt|;
name|u_long
name|pc_spare
index|[
name|_NPCS
index|]
decl_stmt|;
name|struct
name|pv_entry
name|pc_pventry
index|[
name|_NPCPV
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The VHPT bucket head structure.  */
end_comment

begin_struct
struct|struct
name|ia64_bucket
block|{
name|uint64_t
name|chain
decl_stmt|;
name|struct
name|mtx
name|mutex
decl_stmt|;
name|u_int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Statically allocated kernel pmap  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_comment
comment|/*  * Kernel virtual memory management.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ia64_lpte
modifier|*
modifier|*
modifier|*
name|ia64_kptdir
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KPTE_DIR0_INDEX
parameter_list|(
name|va
parameter_list|)
define|\
value|(((va)>> (3*PAGE_SHIFT-8))& ((1<<(PAGE_SHIFT-3))-1))
end_define

begin_define
define|#
directive|define
name|KPTE_DIR1_INDEX
parameter_list|(
name|va
parameter_list|)
define|\
value|(((va)>> (2*PAGE_SHIFT-5))& ((1<<(PAGE_SHIFT-3))-1))
end_define

begin_define
define|#
directive|define
name|KPTE_PTE_INDEX
parameter_list|(
name|va
parameter_list|)
define|\
value|(((va)>> PAGE_SHIFT)& ((1<<(PAGE_SHIFT-5))-1))
end_define

begin_define
define|#
directive|define
name|NKPTEPG
value|(PAGE_SIZE / sizeof(struct ia64_lpte))
end_define

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defaults for ptc.e. */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|pmap_ptc_e_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|pmap_ptc_e_count1
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|pmap_ptc_e_count2
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|pmap_ptc_e_stride1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|pmap_ptc_e_stride2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|pmap_ptc_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the RID allocator  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmap_ridcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_rididx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_ridmapsz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_ridmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
modifier|*
name|pmap_ridmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|pmap_ridmutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock_padalign
name|pvh_global_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|pch
argument_list|,
argument|pv_chunk
argument_list|)
name|pv_chunks
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pv_chunks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for allocating PTEs for user processes.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ptezone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Virtual Hash Page Table (VHPT) data.  */
end_comment

begin_comment
comment|/* SYSCTL_DECL(_machdep); */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|vhpt
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ia64_bucket
modifier|*
name|pmap_vhpt_bucket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_vhpt_nbuckets
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|nbuckets
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_nbuckets
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pmap_vhpt_log2size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"machdep.vhpt.log2size"
argument_list|,
operator|&
name|pmap_vhpt_log2size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|log2size
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_log2size
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_vhpt_inserts
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|inserts
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_vhpt_inserts
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|pmap_vhpt_population
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep_vhpt
argument_list|,
name|OID_AUTO
argument_list|,
name|population
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|pmap_vhpt_population
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|,
name|int
name|freepte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|pmap_initialize_vhpt
parameter_list|(
name|vm_offset_t
name|vhpt
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|vhpt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_vhpt_nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|pte
index|[
name|i
index|]
operator|.
name|pte
operator|=
literal|0
expr_stmt|;
name|pte
index|[
name|i
index|]
operator|.
name|itir
operator|=
literal|0
expr_stmt|;
name|pte
index|[
name|i
index|]
operator|.
name|tag
operator|=
literal|1UL
operator|<<
literal|63
expr_stmt|;
comment|/* Invalid tag */
name|pte
index|[
name|i
index|]
operator|.
name|chain
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|pmap_vhpt_bucket
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|vm_offset_t
name|pmap_alloc_vhpt
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|vhpt
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|size
operator|=
literal|1UL
operator|<<
name|pmap_vhpt_log2size
expr_stmt|;
name|m
operator|=
name|vm_page_alloc_contig
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|,
name|atop
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0UL
argument_list|,
operator|~
literal|0UL
argument_list|,
name|size
argument_list|,
literal|0UL
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|vhpt
operator|=
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_initialize_vhpt
argument_list|(
name|vhpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|vhpt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|()
block|{
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
name|vm_offset_t
name|base
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ridbits
decl_stmt|;
comment|/* 	 * Query the PAL Code to find the loop parameters for the 	 * ptc.e instruction. 	 */
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_PTCE_INFO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Can't configure ptc.e parameters"
argument_list|)
expr_stmt|;
name|pmap_ptc_e_base
operator|=
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
expr_stmt|;
name|pmap_ptc_e_count1
operator|=
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
operator|>>
literal|32
expr_stmt|;
name|pmap_ptc_e_count2
operator|=
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
expr_stmt|;
name|pmap_ptc_e_stride1
operator|=
name|res
operator|.
name|pal_result
index|[
literal|2
index|]
operator|>>
literal|32
expr_stmt|;
name|pmap_ptc_e_stride2
operator|=
name|res
operator|.
name|pal_result
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ptc.e base=0x%lx, count1=%u, count2=%u, "
literal|"stride1=0x%x, stride2=0x%x\n"
argument_list|,
name|pmap_ptc_e_base
argument_list|,
name|pmap_ptc_e_count1
argument_list|,
name|pmap_ptc_e_count2
argument_list|,
name|pmap_ptc_e_stride1
argument_list|,
name|pmap_ptc_e_stride2
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmap_ptc_mutex
argument_list|,
literal|"PTC.G mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Setup RIDs. RIDs 0..7 are reserved for the kernel. 	 * 	 * We currently need at least 19 bits in the RID because PID_MAX 	 * can only be encoded in 17 bits and we need RIDs for 4 regions 	 * per process. With PID_MAX equalling 99999 this means that we 	 * need to be able to encode 399996 (=4*PID_MAX). 	 * The Itanium processor only has 18 bits and the architected 	 * minimum is exactly that. So, we cannot use a PID based scheme 	 * in those cases. Enter pmap_ridmap... 	 * We should avoid the map when running on a processor that has 	 * implemented enough bits. This means that we should pass the 	 * process/thread ID to pmap. This we currently don't do, so we 	 * use the map anyway. However, we don't want to allocate a map 	 * that is large enough to cover the range dictated by the number 	 * of bits in the RID, because that may result in a RID map of 	 * 2MB in size for a 24-bit RID. A 64KB map is enough. 	 * The bottomline: we create a 32KB map when the processor only 	 * implements 18 bits (or when we can't figure it out). Otherwise 	 * we create a 64KB map. 	 */
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_VM_SUMMARY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Can't read VM Summary - assuming 18 Region ID bits\n"
argument_list|)
expr_stmt|;
name|ridbits
operator|=
literal|18
expr_stmt|;
comment|/* guaranteed minimum */
block|}
else|else
block|{
name|ridbits
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Processor supports %d Region ID bits\n"
argument_list|,
name|ridbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ridbits
operator|>
literal|19
condition|)
name|ridbits
operator|=
literal|19
expr_stmt|;
name|pmap_ridmax
operator|=
operator|(
literal|1
operator|<<
name|ridbits
operator|)
expr_stmt|;
name|pmap_ridmapsz
operator|=
name|pmap_ridmax
operator|/
literal|64
expr_stmt|;
name|pmap_ridmap
operator|=
name|ia64_physmem_alloc
argument_list|(
name|pmap_ridmax
operator|/
literal|8
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_ridmap
index|[
literal|0
index|]
operator||=
literal|0xff
expr_stmt|;
name|pmap_rididx
operator|=
literal|0
expr_stmt|;
name|pmap_ridcount
operator|=
literal|8
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|,
literal|"RID allocator lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate some memory for initial kernel 'page tables'. 	 */
name|ia64_kptdir
operator|=
name|ia64_physmem_alloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|nkpt
operator|=
literal|0
expr_stmt|;
name|kernel_vm_end
operator|=
name|VM_INIT_KERNEL_ADDRESS
expr_stmt|;
comment|/* 	 * Determine a valid (mappable) VHPT size. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"machdep.vhpt.log2size"
argument_list|,
operator|&
name|pmap_vhpt_log2size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_vhpt_log2size
operator|==
literal|0
condition|)
name|pmap_vhpt_log2size
operator|=
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap_vhpt_log2size
operator|<
literal|16
condition|)
name|pmap_vhpt_log2size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap_vhpt_log2size
operator|>
literal|28
condition|)
name|pmap_vhpt_log2size
operator|=
literal|28
expr_stmt|;
if|if
condition|(
name|pmap_vhpt_log2size
operator|&
literal|1
condition|)
name|pmap_vhpt_log2size
operator|--
expr_stmt|;
name|size
operator|=
literal|1UL
operator|<<
name|pmap_vhpt_log2size
expr_stmt|;
name|base
operator|=
operator|(
name|uintptr_t
operator|)
name|ia64_physmem_alloc
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Unable to allocate VHPT"
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|md
operator|.
name|vhpt
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"VHPT: address=%#lx, size=%#lx\n"
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pmap_vhpt_nbuckets
operator|=
name|size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ia64_lpte
argument_list|)
expr_stmt|;
name|pmap_vhpt_bucket
operator|=
name|ia64_physmem_alloc
argument_list|(
name|pmap_vhpt_nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ia64_bucket
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_vhpt_nbuckets
condition|;
name|i
operator|++
control|)
block|{
comment|/* Stolen memory is zeroed. */
name|mtx_init
argument_list|(
operator|&
name|pmap_vhpt_bucket
index|[
name|i
index|]
operator|.
name|mutex
argument_list|,
literal|"VHPT bucket lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_NOWITNESS
operator||
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
name|pmap_initialize_vhpt
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|map_vhpt
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ia64_set_pta
argument_list|(
name|base
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
operator|(
name|pmap_vhpt_log2size
operator|<<
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ia64_srlz_i
argument_list|()
expr_stmt|;
name|virtual_avail
operator|=
name|VM_INIT_KERNEL_ADDRESS
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_VM_MINKERN_REGION
condition|;
name|i
operator|++
control|)
name|kernel_pmap
operator|->
name|pm_rid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|md
operator|.
name|current_pmap
argument_list|,
name|kernel_pmap
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the global pv list lock. 	 */
name|rw_init
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|)
expr_stmt|;
comment|/* Region 5 is mapped via the VHPT. */
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
literal|5
argument_list|)
argument_list|,
operator|(
literal|5
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear out any random TLB entries left over from booting. 	 */
name|pmap_invalidate_all
argument_list|()
expr_stmt|;
name|map_gateway_page
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_vhpt_population
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_vhpt_nbuckets
condition|;
name|i
operator|++
control|)
name|count
operator|+=
name|pmap_vhpt_bucket
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_page_to_va
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|m
operator|->
name|md
operator|.
name|memattr
operator|==
name|VM_MEMATTR_UNCACHEABLE
operator|)
condition|?
name|IA64_PHYS_TO_RR6
argument_list|(
name|pa
argument_list|)
else|:
name|IA64_PHYS_TO_RR7
argument_list|(
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|memattr
operator|=
name|VM_MEMATTR_DEFAULT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s()"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ptezone
operator|=
name|uma_zcreate
argument_list|(
literal|"PT ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ia64_lpte
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Manipulate TLBs for a pmap  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_invalidate_page
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|uint64_t
name|tag
decl_stmt|;
name|u_int
name|vhpt_ofs
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|vhpt_ofs
operator|=
name|ia64_thash
argument_list|(
name|va
argument_list|)
operator|-
name|PCPU_GET
argument_list|(
name|md
operator|.
name|vhpt
argument_list|)
expr_stmt|;
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
operator|(
name|pc
operator|->
name|pc_md
operator|.
name|vhpt
operator|+
name|vhpt_ofs
operator|)
expr_stmt|;
name|atomic_cmpset_64
argument_list|(
operator|&
name|pte
operator|->
name|tag
argument_list|,
name|tag
argument_list|,
literal|1UL
operator|<<
literal|63
argument_list|)
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|pmap_ptc_mutex
argument_list|)
expr_stmt|;
name|ia64_ptc_ga
argument_list|(
name|va
argument_list|,
name|PAGE_SHIFT
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|ia64_srlz_i
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmap_ptc_mutex
argument_list|)
expr_stmt|;
name|ia64_invala
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_all
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|addr
operator|=
name|pmap_ptc_e_base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmap_ptc_e_count1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pmap_ptc_e_count2
condition|;
name|j
operator|++
control|)
block|{
name|ia64_ptc_e
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|pmap_ptc_e_stride2
expr_stmt|;
block|}
name|addr
operator|+=
name|pmap_ptc_e_stride1
expr_stmt|;
block|}
name|ia64_srlz_i
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|pmap_allocate_rid
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|bit
decl_stmt|,
name|bits
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_ridcount
operator|==
name|pmap_ridmax
condition|)
name|panic
argument_list|(
literal|"pmap_allocate_rid: All Region IDs used"
argument_list|)
expr_stmt|;
comment|/* Find an index with a free bit. */
while|while
condition|(
operator|(
name|bits
operator|=
name|pmap_ridmap
index|[
name|pmap_rididx
index|]
operator|)
operator|==
operator|~
literal|0UL
condition|)
block|{
name|pmap_rididx
operator|++
expr_stmt|;
if|if
condition|(
name|pmap_rididx
operator|==
name|pmap_ridmapsz
condition|)
name|pmap_rididx
operator|=
literal|0
expr_stmt|;
block|}
name|rid
operator|=
name|pmap_rididx
operator|*
literal|64
expr_stmt|;
comment|/* Find a free bit. */
name|bit
operator|=
literal|1UL
expr_stmt|;
while|while
condition|(
name|bits
operator|&
name|bit
condition|)
block|{
name|rid
operator|++
expr_stmt|;
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
name|pmap_ridmap
index|[
name|pmap_rididx
index|]
operator||=
name|bit
expr_stmt|;
name|pmap_ridcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
return|return
name|rid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_free_rid
parameter_list|(
name|uint32_t
name|rid
parameter_list|)
block|{
name|uint64_t
name|bit
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|rid
operator|/
literal|64
expr_stmt|;
name|bit
operator|=
operator|~
operator|(
literal|1UL
operator|<<
operator|(
name|rid
operator|&
literal|63
operator|)
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
name|pmap_ridmap
index|[
name|idx
index|]
operator|&=
name|bit
expr_stmt|;
name|pmap_ridcount
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pmap_ridmutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_pinit_common
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_VM_MINKERN_REGION
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
operator|=
name|pmap_allocate_rid
argument_list|()
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_pinit_common
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|pmap_pinit_common
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_VM_MINKERN_REGION
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
condition|)
name|pmap_free_rid
argument_list|(
name|pmap
operator|->
name|pm_rid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
modifier|*
name|dir1
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|leaf
decl_stmt|;
name|vm_page_t
name|nkpg
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<=
name|addr
condition|)
block|{
if|if
condition|(
name|nkpt
operator|==
name|PAGE_SIZE
operator|/
literal|8
operator|+
name|PAGE_SIZE
operator|*
name|PAGE_SIZE
operator|/
literal|64
condition|)
name|panic
argument_list|(
literal|"%s: out of kernel address space"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|dir1
operator|=
name|ia64_kptdir
index|[
name|KPTE_DIR0_INDEX
argument_list|(
name|kernel_vm_end
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|dir1
operator|==
name|NULL
condition|)
block|{
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|nkpt
operator|++
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"%s: cannot add dir. page"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|dir1
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dir1
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ia64_kptdir
index|[
name|KPTE_DIR0_INDEX
argument_list|(
name|kernel_vm_end
argument_list|)
index|]
operator|=
name|dir1
expr_stmt|;
block|}
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|nkpt
operator|++
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"%s: cannot add PTE page"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|leaf
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|dir1
index|[
name|KPTE_DIR1_INDEX
argument_list|(
name|kernel_vm_end
argument_list|)
index|]
operator|=
name|leaf
expr_stmt|;
name|kernel_vm_end
operator|+=
name|PAGE_SIZE
operator|*
name|NKPTEPG
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_chunk
argument_list|)
operator|==
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_chunk
operator|*
name|pv_to_chunk
argument_list|(
argument|pv_entry_t pv
argument_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|pv
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|PV_PMAP
parameter_list|(
name|pv
parameter_list|)
value|(pv_to_chunk(pv)->pc_pmap)
end_define

begin_define
define|#
directive|define
name|PC_FREE_FULL
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE_PARTIAL
define|\
value|((1UL<< (_NPCPV - sizeof(u_long) * 8 * (_NPCM - 1))) - 1)
end_define

begin_if
if|#
directive|if
name|PAGE_SIZE
operator|==
literal|8192
end_if

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_PARTIAL
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|PAGE_SIZE
operator|==
literal|16384
end_elif

begin_decl_stmt
specifier|static
specifier|const
name|u_long
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_FULL
block|,
name|PC_FREE_PARTIAL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM/pmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pc_chunk_count
decl_stmt|,
name|pc_chunk_allocs
decl_stmt|,
name|pc_chunk_frees
decl_stmt|,
name|pc_chunk_tryfail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_tryfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_tryfail
argument_list|,
literal|0
argument_list|,
literal|"Number of times tried to get a chunk page but failed."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|pv_entry_frees
decl_stmt|,
name|pv_entry_allocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_spare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry allocs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_spare
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_spare
argument_list|,
literal|0
argument_list|,
literal|"Current number of spare pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We are in a serious low memory condition.  Resort to  * drastic measures to free some pages so we can allocate  * another pv entry chunk.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
block|{
name|struct
name|pch
name|newtail
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|m_pc
decl_stmt|;
name|u_long
name|inuse
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|freed
decl_stmt|,
name|idx
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|locked_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|NULL
expr_stmt|;
name|m_pc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newtail
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_chunks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|pc
operator|->
name|pc_pmap
condition|)
block|{
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
block|{
name|pmap_switch
argument_list|(
name|locked_pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap
operator|=
name|pc
operator|->
name|pc_pmap
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pmap
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Destroy every non-wired, 8 KB page mapping in the chunk. 		 */
name|freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
for|for
control|(
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
init|;
name|inuse
operator|!=
literal|0
condition|;
name|inuse
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
control|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
continue|continue;
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freed
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Every freed mapping is for a 8 KB page. */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|freed
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|-=
name|freed
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
name|pc_freemask
index|[
name|field
index|]
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
comment|/* 				 * One freed pv entry in locked_pmap is 				 * sufficient. 				 */
if|if
condition|(
name|pmap
operator|==
name|locked_pmap
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|field
operator|==
name|_NPCM
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* Entire chunk is free; return it. */
name|m_pc
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|IA64_RR_MASK
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pv_chunks
argument_list|,
operator|&
name|newtail
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
block|{
name|pmap_switch
argument_list|(
name|locked_pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m_pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|=
name|pv_to_chunk
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pv
operator|-
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|field
operator|=
name|idx
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|bit
operator|=
name|idx
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1ul
operator|<<
name|bit
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|_NPCM
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|idx
index|]
operator|!=
name|pc_freemask
index|[
name|idx
index|]
condition|)
block|{
comment|/* 			 * 98% of the time, pc is already at the head of the 			 * list.  If it isn't already, move it to the head. 			 */
if|if
condition|(
name|__predict_false
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
operator|!=
name|pc
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* entire chunk is free, return it */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|IA64_RR_MASK
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_allocs
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
name|retry
label|:
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|field
operator|<
name|_NPCM
condition|)
block|{
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* If this was the last item, move it to tail */
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
literal|0
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
comment|/* not full, return */
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
block|}
comment|/* No free items, allocate another chunk */
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|try
condition|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_tryfail
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
name|pmap_pv_reclaim
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_allocs
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|pc_freemask
index|[
literal|0
index|]
operator|&
operator|~
literal|1ul
expr_stmt|;
comment|/* preallocated bit 0 */
for|for
control|(
name|field
operator|=
literal|1
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|=
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|_NPCPV
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conditionally create a pv entry.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an ia64_lpte to the VHPT.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_vhpt
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_bucket
modifier|*
name|bckt
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|vhpte
decl_stmt|;
name|uint64_t
name|pte_pa
decl_stmt|;
comment|/* Can fault, so get it out of the way. */
name|pte_pa
operator|=
name|ia64_tpa
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte
argument_list|)
expr_stmt|;
name|vhpte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|bckt
operator|=
operator|(
expr|struct
name|ia64_bucket
operator|*
operator|)
name|vhpte
operator|->
name|chain
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pte
operator|->
name|chain
operator|=
name|bckt
operator|->
name|chain
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|bckt
operator|->
name|chain
operator|=
name|pte_pa
expr_stmt|;
name|pmap_vhpt_inserts
operator|++
expr_stmt|;
name|bckt
operator|->
name|length
operator|++
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the ia64_lpte matching va from the VHPT. Return zero if it  * worked or an appropriate error code otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_bucket
modifier|*
name|bckt
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|lpte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|vhpte
decl_stmt|;
name|uint64_t
name|chain
decl_stmt|,
name|tag
decl_stmt|;
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|vhpte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|bckt
operator|=
operator|(
expr|struct
name|ia64_bucket
operator|*
operator|)
name|vhpte
operator|->
name|chain
expr_stmt|;
name|lpte
operator|=
name|NULL
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|chain
operator|=
name|bckt
operator|->
name|chain
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
operator|!=
literal|0
operator|&&
name|pte
operator|->
name|tag
operator|!=
name|tag
condition|)
block|{
name|lpte
operator|=
name|pte
expr_stmt|;
name|chain
operator|=
name|pte
operator|->
name|chain
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|==
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Snip this pv_entry out of the collision chain. */
if|if
condition|(
name|lpte
operator|==
name|NULL
condition|)
name|bckt
operator|->
name|chain
operator|=
name|pte
operator|->
name|chain
expr_stmt|;
else|else
name|lpte
operator|->
name|chain
operator|=
name|pte
operator|->
name|chain
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|bckt
operator|->
name|length
operator|--
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the ia64_lpte for the given va, if any.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_vhpt
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_bucket
modifier|*
name|bckt
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|uint64_t
name|chain
decl_stmt|,
name|tag
decl_stmt|;
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|ia64_thash
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|bckt
operator|=
operator|(
expr|struct
name|ia64_bucket
operator|*
operator|)
name|pte
operator|->
name|chain
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|chain
operator|=
name|bckt
operator|->
name|chain
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|chain
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
operator|!=
literal|0
operator|&&
name|pte
operator|->
name|tag
operator|!=
name|tag
condition|)
block|{
name|chain
operator|=
name|pte
operator|->
name|chain
expr_stmt|;
name|pte
operator|=
operator|(
expr|struct
name|ia64_lpte
operator|*
operator|)
name|IA64_PHYS_TO_RR7
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|bckt
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|chain
operator|!=
literal|0
operator|)
condition|?
name|pte
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from the list of managed mappings.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pv
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pv
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|ENOENT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
name|pa
operator|=
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract_and_hold  *	Function:  *		Atomically extract and hold the physical page  *		with the given pmap and virtual address pair  *		if that mapping permits the given protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, prot=%#x)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_present
argument_list|(
name|pte
argument_list|)
operator|&&
operator|(
name|pmap_prot
argument_list|(
name|pte
argument_list|)
operator|&
name|prot
operator|)
operator|==
name|prot
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|PA_UNLOCK_COND
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Find the kernel lpte for mapping the given virtual address, which  * must be in the part of region 5 which we can cover with our kernel  * 'page tables'.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_kpte
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
modifier|*
name|dir1
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|leaf
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|va
operator|>>
literal|61
operator|)
operator|==
literal|5
argument_list|,
operator|(
literal|"kernel mapping 0x%lx not in region 5"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kernel_vm_end
argument_list|,
operator|(
literal|"kernel mapping 0x%lx out of range"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|dir1
operator|=
name|ia64_kptdir
index|[
name|KPTE_DIR0_INDEX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|leaf
operator|=
name|dir1
index|[
name|KPTE_DIR1_INDEX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|&
name|leaf
index|[
name|KPTE_PTE_INDEX
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a pte suitable for mapping a user-space address. If one exists   * in the VHPT, that one will be returned, otherwise a new pte is  * allocated.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_lpte
modifier|*
name|pmap_find_pte
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
return|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|pte
operator|=
name|uma_zalloc
argument_list|(
name|ptezone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pte
operator|->
name|tag
operator|=
literal|1UL
operator|<<
literal|63
expr_stmt|;
block|}
return|return
operator|(
name|pte
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a pte which is now unused. This simply returns it to the zone  * allocator if it is a user mapping. For kernel mappings, clear the  * valid bit to make it clear that the mapping is not currently used.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
name|uma_zfree
argument_list|(
name|ptezone
argument_list|,
name|pte
argument_list|)
expr_stmt|;
else|else
name|pmap_clear_present
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_pte_prot
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
specifier|static
name|long
name|prot2ar
index|[
literal|4
index|]
init|=
block|{
name|PTE_AR_R
block|,
comment|/* VM_PROT_NONE */
name|PTE_AR_RW
block|,
comment|/* VM_PROT_WRITE */
name|PTE_AR_RX
operator||
name|PTE_ED
block|,
comment|/* VM_PROT_EXECUTE */
name|PTE_AR_RWX
operator||
name|PTE_ED
comment|/* VM_PROT_WRITE|VM_PROT_EXECUTE */
block|}
decl_stmt|;
name|pte
operator|->
name|pte
operator|&=
operator|~
operator|(
name|PTE_PROT_MASK
operator||
name|PTE_PL_MASK
operator||
name|PTE_AR_MASK
operator||
name|PTE_ED
operator|)
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|prot
operator|&
name|VM_PROT_ALL
argument_list|)
operator|<<
literal|56
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
operator|(
name|prot
operator|==
name|VM_PROT_NONE
operator|||
name|pm
operator|==
name|kernel_pmap
operator|)
condition|?
name|PTE_PL_KERN
else|:
name|PTE_PL_USER
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
name|prot2ar
index|[
operator|(
name|prot
operator|&
name|VM_PROT_ALL
operator|)
operator|>>
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_pte_attr
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|pte
operator|->
name|pte
operator|&=
operator|~
name|PTE_MA_MASK
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
operator|(
name|ma
operator|&
name|PTE_MA_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a pte to contain a valid mapping and enter it in the VHPT. If  * the pte was orginally valid, then its assumed to already be in the  * VHPT.  * This functions does not set the protection bits.  It's expected  * that those have been set correctly prior to calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_set_pte
parameter_list|(
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|boolean_t
name|wired
parameter_list|,
name|boolean_t
name|managed
parameter_list|)
block|{
name|pte
operator|->
name|pte
operator|&=
name|PTE_PROT_MASK
operator||
name|PTE_MA_MASK
operator||
name|PTE_PL_MASK
operator||
name|PTE_AR_MASK
operator||
name|PTE_ED
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
name|PTE_PRESENT
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
operator|(
name|managed
operator|)
condition|?
name|PTE_MANAGED
else|:
operator|(
name|PTE_DIRTY
operator||
name|PTE_ACCESSED
operator|)
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
operator|(
name|wired
operator|)
condition|?
name|PTE_WIRED
else|:
literal|0
expr_stmt|;
name|pte
operator|->
name|pte
operator||=
name|pa
operator|&
name|PTE_PPN_MASK
expr_stmt|;
name|pte
operator|->
name|itir
operator|=
name|PAGE_SHIFT
operator|<<
literal|2
expr_stmt|;
name|ia64_mf
argument_list|()
expr_stmt|;
name|pte
operator|->
name|tag
operator|=
name|ia64_ttag
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the (possibly managed) mapping represented by pte from the  * given pmap.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|ia64_lpte
modifier|*
name|pte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|,
name|int
name|freepte
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
comment|/* 	 * First remove from the VHPT. 	 */
name|error
operator|=
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: pmap_remove_vhpt returned %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|pmap_managed
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|error
operator|=
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freepte
condition|)
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with a kernel  * virtual address.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|uint64_t
modifier|*
name|pbvm_pgtbl
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
argument_list|,
operator|(
literal|"Must be kernel VA"
operator|)
argument_list|)
expr_stmt|;
comment|/* Regions 6 and 7 are direct mapped. */
if|if
condition|(
name|va
operator|>=
name|IA64_RR_BASE
argument_list|(
literal|6
argument_list|)
condition|)
block|{
name|pa
operator|=
name|IA64_RR_MASK
argument_list|(
name|va
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Region 5 is our KVA. Bail out if the VA is beyond our limits. */
if|if
condition|(
name|va
operator|>=
name|kernel_vm_end
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
name|va
operator|>=
name|VM_INIT_KERNEL_ADDRESS
condition|)
block|{
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|?
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
operator||
operator|(
name|va
operator|&
name|PAGE_MASK
operator|)
else|:
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The PBVM page table. */
if|if
condition|(
name|va
operator|>=
name|IA64_PBVM_PGTBL
operator|+
name|bootinfo
operator|->
name|bi_pbvm_pgtblsz
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
name|va
operator|>=
name|IA64_PBVM_PGTBL
condition|)
block|{
name|pa
operator|=
operator|(
name|va
operator|-
name|IA64_PBVM_PGTBL
operator|)
operator|+
name|bootinfo
operator|->
name|bi_pbvm_pgtbl
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The PBVM itself. */
if|if
condition|(
name|va
operator|>=
name|IA64_PBVM_BASE
condition|)
block|{
name|pbvm_pgtbl
operator|=
operator|(
name|void
operator|*
operator|)
name|IA64_PBVM_PGTBL
expr_stmt|;
name|idx
operator|=
operator|(
name|va
operator|-
name|IA64_PBVM_BASE
operator|)
operator|>>
name|IA64_PBVM_PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
operator|(
name|bootinfo
operator|->
name|bi_pbvm_pgtblsz
operator|>>
literal|3
operator|)
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
operator|(
name|pbvm_pgtbl
index|[
name|idx
index|]
operator|&
name|PTE_PRESENT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|err_out
goto|;
name|pa
operator|=
operator|(
name|pbvm_pgtbl
index|[
name|idx
index|]
operator|&
name|PTE_PPN_MASK
operator|)
operator|+
operator|(
name|va
operator|&
name|IA64_PBVM_PAGE_MASK
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err_out
label|:
name|printf
argument_list|(
literal|"XXX: %s: va=%#lx is invalid\n"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
name|out
label|:
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva this routine is only used for  * temporary kernel mappings that do not need to have page modification  * or references recorded.  Note that old mappings are simply written  * over.  The page is effectively wired, but it's customary to not have  * the PTE reflect that, nor update statistics.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx, m_p=%p, cnt=%d)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
else|else
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_pte_prot
argument_list|(
name|kernel_pmap
argument_list|,
name|pte
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|m
index|[
name|i
index|]
operator|->
name|md
operator|.
name|memattr
argument_list|)
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx, cnt=%d)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_clear_present
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a wired page to the kva.  As for pmap_qenter(), it's customary  * to not have the PTE reflect that, nor update statistics.  */
end_comment

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx, pa=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
else|else
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_pte_prot
argument_list|(
name|kernel_pmap
argument_list|,
name|pte
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a page from the kva  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_clear_present
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va_p=%p, sva=%#lx, eva=%#lx, prot=%#x)"
argument_list|,
name|__func__
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|prot
argument_list|)
expr_stmt|;
return|return
name|IA64_PHYS_TO_RR7
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  *  *	Sparsely used ranges are inefficiently removed.  The VHPT is  *	probed for every page within the range.  XXX  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, sva=%#lx, eva=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
comment|/* 	 * Perform an unsynchronized read.  This is, however, safe. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|pmap
init|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|pv
operator|->
name|pv_va
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
operator|!=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_remove_all: pv_table for %lx is inconsistent"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
name|pv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, sva=%#lx, eva=%#lx, prot=%#x)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
operator|)
operator|)
operator|==
operator|(
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|sva
operator|&
name|PAGE_MASK
operator|)
operator|||
operator|(
name|eva
operator|&
name|PAGE_MASK
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_protect: unaligned addresses"
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
comment|/* If page is invalid, skip this page */
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If there's no change, skip it too */
if|if
condition|(
name|pmap_prot
argument_list|(
name|pte
argument_list|)
operator|==
name|prot
condition|)
continue|continue;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|&&
name|pmap_managed
argument_list|(
name|pte
argument_list|)
operator|&&
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|vm_paddr_t
name|pa
init|=
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
decl_stmt|;
name|vm_page_t
name|m
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
decl_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_clear_dirty
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|ia64_sync_icache
argument_list|(
name|sva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_pte_prot
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|int
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
name|__unused
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|struct
name|ia64_lpte
name|origpte
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|icache_inval
decl_stmt|,
name|managed
decl_stmt|,
name|wired
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter(pm=%p, va=%#lx, m=%p, prot=%#x, "
literal|"flags=%u)"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wired
operator|=
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|!=
literal|0
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<=
name|VM_MAX_KERNEL_ADDRESS
argument_list|,
operator|(
literal|"pmap_enter: toobig"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
operator|||
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"pmap_enter: page %p is not busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find (or create) a pte for the given mapping. 	 */
while|while
condition|(
operator|(
name|pte
operator|=
name|pmap_find_pte
argument_list|(
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_NOSLEEP
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
name|VM_WAIT
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|origpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|opa
operator|=
operator|~
literal|0UL
expr_stmt|;
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
name|opa
operator|=
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|managed
operator|=
name|FALSE
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|icache_inval
operator|=
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|opa
operator|==
name|pa
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_wired
argument_list|(
operator|&
name|origpte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pmap_wired
argument_list|(
operator|&
name|origpte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|managed
operator|=
operator|(
name|pmap_managed
argument_list|(
operator|&
name|origpte
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. Otherwise, 		 * we can avoid I-cache invalidation if the page 		 * already allowed execution. 		 */
if|if
condition|(
name|managed
operator|&&
name|pmap_dirty
argument_list|(
operator|&
name|origpte
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap_exec
argument_list|(
operator|&
name|origpte
argument_list|)
condition|)
name|icache_inval
operator|=
name|FALSE
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall 	 * through to handle validating new mapping. 	 */
if|if
condition|(
name|opa
operator|!=
operator|~
literal|0UL
condition|)
block|{
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|managed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. This 	 * adds the pte to the VHPT if necessary. 	 */
name|pmap_pte_prot
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|m
operator|->
name|md
operator|.
name|memattr
argument_list|)
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|wired
argument_list|,
name|managed
argument_list|)
expr_stmt|;
comment|/* Invalidate the I-cache when needed. */
if|if
condition|(
name|icache_inval
condition|)
name|ia64_sync_icache
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|&&
name|managed
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, sva=%#lx, eva=%#lx, m=%p, prot=%#x)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|m_start
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m_start
operator|->
name|object
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, m=%p, prot=%#x)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|managed
decl_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|||
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|=
name|pmap_find_pte
argument_list|(
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* Enter on the PV list if the page is managed. */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_try_insert_pv_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
name|managed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|managed
operator|=
name|FALSE
expr_stmt|;
comment|/* Increment counters. */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* Initialise with R/O protection and enter into VHPT. */
name|pmap_enter_vhpt
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_pte_prot
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|m
operator|->
name|md
operator|.
name|memattr
argument_list|)
expr_stmt|;
name|pmap_set_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|managed
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|ia64_sync_icache
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, obj=%p, idx=%lu, sz=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|addr
argument_list|,
name|object
argument_list|,
name|pindex
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, wired=%u)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pmap_set_wired
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap_clear_wired
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_va
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_va
parameter_list|)
block|{
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(dpm=%p, spm=%p, dva=%#lx, sz=%#lx, sva=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|dst_pmap
argument_list|,
name|src_pmap
argument_list|,
name|dst_va
argument_list|,
name|len
argument_list|,
name|src_va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  *  *	off and size must reside within a single page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p, ofs=%d, len=%d)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  This is for the vm_idlezero process.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|void
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(sm=%p, dm=%p)"
argument_list|,
name|__func__
argument_list|,
name|msrc
argument_list|,
name|mdst
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|msrc
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|mdst
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_copy_pages
parameter_list|(
name|vm_page_t
name|ma
index|[]
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
name|mb
index|[]
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
block|{
name|void
modifier|*
name|a_cp
decl_stmt|,
modifier|*
name|b_cp
decl_stmt|;
name|vm_offset_t
name|a_pg_offset
decl_stmt|,
name|b_pg_offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m0=%p, va0=%#lx, m1=%p, va1=%#lx, sz=%#x)"
argument_list|,
name|__func__
argument_list|,
name|ma
argument_list|,
name|a_offset
argument_list|,
name|mb
argument_list|,
name|b_offset
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
while|while
condition|(
name|xfersize
operator|>
literal|0
condition|)
block|{
name|a_pg_offset
operator|=
name|a_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|xfersize
argument_list|,
name|PAGE_SIZE
operator|-
name|a_pg_offset
argument_list|)
expr_stmt|;
name|a_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|ma
index|[
name|a_offset
operator|>>
name|PAGE_SHIFT
index|]
argument_list|)
operator|+
name|a_pg_offset
expr_stmt|;
name|b_pg_offset
operator|=
name|b_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|cnt
argument_list|,
name|PAGE_SIZE
operator|-
name|b_pg_offset
argument_list|)
expr_stmt|;
name|b_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|mb
index|[
name|b_offset
operator|>>
name|PAGE_SHIFT
index|]
argument_list|)
operator|+
name|b_pg_offset
expr_stmt|;
name|bcopy
argument_list|(
name|a_cp
argument_list|,
name|b_cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|a_offset
operator|+=
name|cnt
expr_stmt|;
name|b_offset
operator|+=
name|cnt
expr_stmt|;
name|xfersize
operator|-=
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, m=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_page_wired_mappings:  *  *	Return the number of managed mappings to the given physical page  *	that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|,
modifier|*
name|npc
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|u_long
name|inuse
decl_stmt|,
name|bitmask
decl_stmt|;
name|int
name|allfree
decl_stmt|,
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|,
argument|npc
argument_list|)
block|{
name|allfree
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
while|while
condition|(
name|inuse
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|inuse
operator|&=
operator|~
name|bitmask
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_wired
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|allfree
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pmap_remove_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_free_pte
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* Mark free */
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
name|bitmask
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allfree
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *   *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|pmap_clear_accessed
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no PTEs can be dirty. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Apply the given advice to the specified range of addresses within the  *	given pmap.  Depending on the advice, clear the referenced and/or  *	modified flags in each mapping and set the mapped page's dirty field.  */
end_comment

begin_function
name|void
name|pmap_advise
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|int
name|advice
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, sva=%#lx, eva=%#lx, adv=%d)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|advice
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
comment|/* If page is invalid, skip this page. */
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If it isn't managed, skip it too. */
if|if
condition|(
operator|!
name|pmap_managed
argument_list|(
name|pte
argument_list|)
condition|)
continue|continue;
comment|/* Clear its modified and referenced bits. */
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|advice
operator|==
name|MADV_DONTNEED
condition|)
block|{
comment|/* 				 * Future calls to pmap_is_modified() can be 				 * avoided by making the page dirty now. 				 */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_clear_dirty
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|)
continue|continue;
name|pmap_clear_accessed
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is exclusive busied"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no PTEs can be modified. 	 * If the object containing the page is locked and the page is not 	 * exclusive busied, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pmap_clear_dirty
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * set by another thread while the object is locked.  Thus, 	 * if PGA_WRITEABLE is clear, no page table entries need updating. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
name|prot
operator|=
name|pmap_prot
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_clear_dirty
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
name|pmap_pte_prot
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|m
operator|->
name|md
operator|.
name|memattr
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_mapdev_priv
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|sz
parameter_list|,
name|vm_memattr_t
name|attr
parameter_list|)
block|{
specifier|static
name|vm_offset_t
name|last_va
init|=
literal|0
decl_stmt|;
specifier|static
name|vm_paddr_t
name|last_pa
init|=
operator|~
literal|0UL
decl_stmt|;
specifier|static
name|vm_size_t
name|last_sz
init|=
literal|0
decl_stmt|;
name|struct
name|efi_md
modifier|*
name|md
decl_stmt|;
if|if
condition|(
name|pa
operator|==
name|last_pa
operator|&&
name|sz
operator|==
name|last_sz
condition|)
return|return
operator|(
name|last_va
operator|)
return|;
name|md
operator|=
name|efi_md_find
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: [%#lx..%#lx] not covered by memory descriptor\n"
argument_list|,
name|__func__
argument_list|,
name|pa
argument_list|,
name|pa
operator|+
name|sz
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|IA64_PHYS_TO_RR6
argument_list|(
name|pa
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_type
operator|==
name|EFI_MD_TYPE_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: [%#lx..%#lx] is in DRAM\n"
argument_list|,
name|__func__
argument_list|,
name|pa
argument_list|,
name|pa
operator|+
name|sz
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|last_va
operator|=
operator|(
name|md
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_WB
operator|)
condition|?
name|IA64_PHYS_TO_RR7
argument_list|(
name|pa
argument_list|)
else|:
name|IA64_PHYS_TO_RR6
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|last_pa
operator|=
name|pa
expr_stmt|;
name|last_sz
operator|=
name|sz
expr_stmt|;
return|return
operator|(
name|last_va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev_attr
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|sz
parameter_list|,
name|vm_memattr_t
name|attr
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pa=%#lx, sz=%#lx, attr=%#x)"
argument_list|,
name|__func__
argument_list|,
name|pa
argument_list|,
name|sz
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|va
operator|=
name|pmap_mapdev_priv
argument_list|(
name|pa
argument_list|,
name|sz
argument_list|,
name|attr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'Unmap' a range mapped by pmap_mapdev_attr().  */
end_comment

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(va=%#lx, sz=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|va
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sets the memory attribute for the specified page.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_page_set_memattr_1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
name|register_t
name|is
decl_stmt|;
name|uintptr_t
name|pp
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
name|is
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intr_restore
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_page_set_memattr
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|pmap_t
name|oldpmap
decl_stmt|,
name|pmap
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|void
modifier|*
name|va
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(m=%p, attr=%#x)"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|memattr
operator|=
name|ma
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pte"
operator|)
argument_list|)
expr_stmt|;
name|pmap_pte_attr
argument_list|(
name|pte
argument_list|,
name|ma
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ma
operator|==
name|VM_MEMATTR_UNCACHEABLE
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|pmap_page_set_memattr_1
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|PAL_PREFETCH_VISIBILITY
argument_list|)
expr_stmt|;
else|#
directive|else
name|pmap_page_set_memattr_1
argument_list|(
operator|(
name|void
operator|*
operator|)
name|PAL_PREFETCH_VISIBILITY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va
operator|=
operator|(
name|void
operator|*
operator|)
name|pmap_page_to_va
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu_flush_dcache
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|pmap_page_set_memattr_1
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|PAL_MC_DRAIN
argument_list|)
expr_stmt|;
else|#
directive|else
name|pmap_page_set_memattr_1
argument_list|(
operator|(
name|void
operator|*
operator|)
name|PAL_MC_DRAIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
name|pmap_t
name|oldpmap
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|val
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, pa_p=%p)"
argument_list|,
name|__func__
argument_list|,
name|pmap
argument_list|,
name|addr
argument_list|,
name|locked_pa
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|oldpmap
operator|=
name|pmap_switch
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
block|{
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
name|pte
operator|=
operator|&
name|tpte
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
operator|||
operator|!
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|pmap_dirty
argument_list|(
name|pte
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
if|if
condition|(
name|pmap_accessed
argument_list|(
name|pte
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|)
operator|!=
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|&&
name|pmap_managed
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|pa
operator|=
name|pmap_ppn
argument_list|(
name|pte
argument_list|)
expr_stmt|;
comment|/* Ensure that "PHYS_TO_VM_PAGE(pa)->object" doesn't change. */
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
argument_list|,
name|locked_pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
else|else
name|out
label|:
name|PA_UNLOCK_COND
argument_list|(
operator|*
name|locked_pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(td=%p)"
argument_list|,
name|__func__
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|pmap_switch
argument_list|(
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|pmap_t
name|pmap_switch
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|pmap_t
name|prevpm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|prevpm
operator|=
name|PCPU_GET
argument_list|(
name|md
operator|.
name|current_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevpm
operator|==
name|pm
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_VM_MINKERN_REGION
condition|;
name|i
operator|++
control|)
block|{
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IA64_VM_MINKERN_REGION
condition|;
name|i
operator|++
control|)
block|{
name|ia64_set_rr
argument_list|(
name|IA64_RR_BASE
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|pm
operator|->
name|pm_rid
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|PAGE_SHIFT
operator|<<
literal|2
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|PCPU_SET
argument_list|(
name|md
operator|.
name|current_pmap
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|ia64_srlz_d
argument_list|()
expr_stmt|;
name|out
label|:
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|prevpm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{
name|pmap_t
name|oldpm
decl_stmt|;
name|struct
name|ia64_lpte
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|lim
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(pm=%p, va=%#lx, sz=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|pm
argument_list|,
name|va
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|va
operator|&
literal|31
expr_stmt|;
name|va
operator|&=
operator|~
literal|31
expr_stmt|;
name|sz
operator|=
operator|(
name|sz
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|oldpm
operator|=
name|pmap_switch
argument_list|(
name|pm
argument_list|)
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|lim
operator|=
name|round_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|lim
operator|-
name|va
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_find_vhpt
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_present
argument_list|(
name|pte
argument_list|)
condition|)
name|ia64_sync_icache
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|va
operator|+=
name|len
expr_stmt|;
name|sz
operator|-=
name|len
expr_stmt|;
block|}
name|pmap_switch
argument_list|(
name|oldpm
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Increase the starting virtual address of the given mapping if a  *	different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"%s(obj=%p, ofs=%#lx, va_p=%p, sz=%#lx)"
argument_list|,
name|__func__
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|psnames
index|[]
init|=
block|{
literal|"1B"
block|,
literal|"2B"
block|,
literal|"4B"
block|,
literal|"8B"
block|,
literal|"16B"
block|,
literal|"32B"
block|,
literal|"64B"
block|,
literal|"128B"
block|,
literal|"256B"
block|,
literal|"512B"
block|,
literal|"1K"
block|,
literal|"2K"
block|,
literal|"4K"
block|,
literal|"8K"
block|,
literal|"16K"
block|,
literal|"32K"
block|,
literal|"64K"
block|,
literal|"128K"
block|,
literal|"256K"
block|,
literal|"512K"
block|,
literal|"1M"
block|,
literal|"2M"
block|,
literal|"4M"
block|,
literal|"8M"
block|,
literal|"16M"
block|,
literal|"32M"
block|,
literal|"64M"
block|,
literal|"128M"
block|,
literal|"256M"
block|,
literal|"512M"
block|,
literal|"1G"
block|,
literal|"2G"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_trs
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|ia64_pal_result
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxtr
decl_stmt|;
struct|struct
block|{
name|pt_entry_t
name|pte
decl_stmt|;
name|uint64_t
name|itir
decl_stmt|;
name|uint64_t
name|ifa
decl_stmt|;
name|struct
name|ia64_rr
name|rr
decl_stmt|;
block|}
name|buf
struct|;
specifier|static
specifier|const
name|char
modifier|*
name|manames
index|[]
init|=
block|{
literal|"WB"
block|,
literal|"bad"
block|,
literal|"bad"
block|,
literal|"bad"
block|,
literal|"UC"
block|,
literal|"UCE"
block|,
literal|"WC"
block|,
literal|"NaT"
block|, 	}
decl_stmt|;
name|res
operator|=
name|ia64_call_pal_static
argument_list|(
name|PAL_VM_SUMMARY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pal_status
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Can't get VM summary\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|maxtr
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|>>
literal|40
operator|)
operator|&
literal|0xff
expr_stmt|;
else|else
name|maxtr
operator|=
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|>>
literal|32
operator|)
operator|&
literal|0xff
expr_stmt|;
name|db_printf
argument_list|(
literal|"V RID    Virtual Page  Physical Page PgSz ED AR PL D A MA  P KEY\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxtr
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|ia64_pal_physical
argument_list|(
name|PAL_VM_TR_READ
argument_list|,
name|i
argument_list|,
name|type
argument_list|,
name|ia64_tpa
argument_list|(
operator|(
name|uint64_t
operator|)
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|1
operator|)
condition|)
name|buf
operator|.
name|pte
operator|&=
operator|~
name|PTE_AR_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|2
operator|)
condition|)
name|buf
operator|.
name|pte
operator|&=
operator|~
name|PTE_PL_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|4
operator|)
condition|)
name|pmap_clear_dirty
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|pal_result
index|[
literal|0
index|]
operator|&
literal|8
operator|)
condition|)
name|buf
operator|.
name|pte
operator|&=
operator|~
name|PTE_MA_MASK
expr_stmt|;
name|db_printf
argument_list|(
literal|"%d %06x %013lx %013lx %4s %d  %d  %d  %d %d %-3s "
literal|"%d %06x\n"
argument_list|,
operator|(
name|int
operator|)
name|buf
operator|.
name|ifa
operator|&
literal|1
argument_list|,
name|buf
operator|.
name|rr
operator|.
name|rr_rid
argument_list|,
name|buf
operator|.
name|ifa
operator|>>
literal|12
argument_list|,
operator|(
name|buf
operator|.
name|pte
operator|&
name|PTE_PPN_MASK
operator|)
operator|>>
literal|12
argument_list|,
name|psnames
index|[
operator|(
name|buf
operator|.
name|itir
operator|&
name|ITIR_PS_MASK
operator|)
operator|>>
literal|2
index|]
argument_list|,
operator|(
name|buf
operator|.
name|pte
operator|&
name|PTE_ED
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|buf
operator|.
name|pte
operator|&
name|PTE_AR_MASK
argument_list|)
operator|>>
literal|9
argument_list|,
call|(
name|int
call|)
argument_list|(
name|buf
operator|.
name|pte
operator|&
name|PTE_PL_MASK
argument_list|)
operator|>>
literal|7
argument_list|,
operator|(
name|pmap_dirty
argument_list|(
operator|&
name|buf
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|pmap_accessed
argument_list|(
operator|&
name|buf
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|manames
index|[
operator|(
name|buf
operator|.
name|pte
operator|&
name|PTE_MA_MASK
operator|)
operator|>>
literal|2
index|]
argument_list|,
operator|(
name|pmap_present
argument_list|(
operator|&
name|buf
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|buf
operator|.
name|itir
operator|&
name|ITIR_KEY_MASK
operator|)
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|DB_COMMAND
argument_list|(
argument|itr
argument_list|,
argument|db_itr
argument_list|)
end_macro

begin_block
block|{
name|print_trs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|dtr
argument_list|,
argument|db_dtr
argument_list|)
end_macro

begin_block
block|{
name|print_trs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|rr
argument_list|,
argument|db_rr
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|struct
name|ia64_rr
name|rr
decl_stmt|;
name|printf
argument_list|(
literal|"RR RID    PgSz VE\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
asm|__asm __volatile ("mov %0=rr[%1]"
block|:
literal|"=r"
operator|(
name|t
operator|)
operator|:
literal|"r"
operator|(
name|IA64_RR_BASE
argument_list|(
name|i
argument_list|)
operator|)
block|)
empty_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|rr
operator|=
name|t
expr_stmt|;
name|printf
argument_list|(
literal|"%d  %06x %4s %d\n"
argument_list|,
name|i
argument_list|,
name|rr
operator|.
name|rr_rid
argument_list|,
name|psnames
index|[
name|rr
operator|.
name|rr_ps
index|]
argument_list|,
name|rr
operator|.
name|rr_ve
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}  DB_COMMAND
operator|(
name|thash
operator|,
name|db_thash
operator|)
block|{
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
name|db_printf
argument_list|(
literal|"%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ia64_thash
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DB_COMMAND
operator|(
name|ttag
operator|,
name|db_ttag
operator|)
block|{
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
name|db_printf
argument_list|(
literal|"0x%lx\n"
argument_list|,
name|ia64_ttag
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DB_COMMAND
operator|(
name|kpte
operator|,
name|db_kpte
operator|)
block|{ 	struct
name|ia64_lpte
operator|*
name|pte
block|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: kpte<kva>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|addr
operator|<
name|VM_INIT_KERNEL_ADDRESS
condition|)
block|{
name|db_printf
argument_list|(
literal|"kpte: error: invalid<kva>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|pte
operator|=
name|pmap_find_kpte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|db_printf
argument_list|(
literal|"kpte at %p:\n"
argument_list|,
name|pte
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|db_printf
argument_list|(
literal|"  pte  =%016lx\n"
argument_list|,
name|pte
operator|->
name|pte
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|db_printf
argument_list|(
literal|"  itir =%016lx\n"
argument_list|,
name|pte
operator|->
name|itir
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|db_printf
argument_list|(
literal|"  tag  =%016lx\n"
argument_list|,
name|pte
operator|->
name|tag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|db_printf
argument_list|(
literal|"  chain=%016lx\n"
argument_list|,
name|pte
operator|->
name|chain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

