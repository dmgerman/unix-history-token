begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2005, 2009, 2013 Jeffrey Roberson<jeff@FreeBSD.org>  * Copyright (c) 2004, 2005 Bosko Milekic<bmilekic@FreeBSD.org>  * Copyright (c) 2004-2006 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * uma_core.c  Implementation of the Universal Memory allocator  *  * This allocator is intended to replace the multitude of similar object caches  * in the standard FreeBSD kernel.  The intent is to be flexible as well as  * efficient.  A primary design goal is to return unused memory to the rest of  * the system.  This will make the system as a whole more flexible due to the  * ability to move memory to subsystems which most need it instead of leaving  * pools of reserved memory unused.  *  * The basic ideas stem from similar slab/zone based allocators whose algorithms  * are well known.  *  */
end_comment

begin_comment
comment|/*  * TODO:  *	- Improve memory usage for large allocations  *	- Investigate cache size adjustments  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_dbg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_MEMGUARD
end_ifdef

begin_include
include|#
directive|include
file|<vm/memguard.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is the zone and keg from which all zones are spawned.  The idea is that  * even the zone& keg heads are allocated from the allocator, so we use the  * bss section to bootstrap us.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uma_keg
name|masterkeg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uma_zone
name|masterzone_k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uma_zone
name|masterzone_z
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kegs
init|=
operator|&
name|masterzone_k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|zones
init|=
operator|&
name|masterzone_z
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the zone from which all of uma_slab_t's are allocated. */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|slabzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The initial hash tables come out of this zone so they can be allocated  * prior to malloc coming up.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|hashzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The boot-time adjusted value for cache line alignment. */
end_comment

begin_decl_stmt
name|int
name|uma_align_cache
init|=
literal|64
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMAHASH
argument_list|,
literal|"UMAHash"
argument_list|,
literal|"UMA Hash Buckets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Are we allowed to allocate buckets?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bucketdisable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all kegs in the system */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_keg
argument_list|)
name|uma_kegs
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|uma_kegs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Linked list of all cache-only zones in the system */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_zone
argument_list|)
name|uma_cachezones
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|uma_cachezones
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This RW lock protects the keg list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rwlock_padalign
name|uma_rwlock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointer and counter to pool of pages, that is preallocated at  * startup to bootstrap UMA.  Early zones continue to use the pool  * until it is depleted, so allocations may happen after boot, thus  * we need a mutex to protect it.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bootmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|boot_pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|uma_boot_pages_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|uma_drain_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is the VM done starting up? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|booted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UMA_STARTUP
value|1
end_define

begin_define
define|#
directive|define
name|UMA_STARTUP2
value|2
end_define

begin_comment
comment|/*  * This is the handle used to schedule events that need to happen  * outside of the allocation fast path.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|uma_callout
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UMA_TIMEOUT
value|20
end_define

begin_comment
comment|/* Seconds for callout interval. */
end_comment

begin_comment
comment|/*  * This structure is passed as the zone ctor arg so that I don't have to create  * a special allocation function just for zones.  */
end_comment

begin_struct
struct|struct
name|uma_zctor_args
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uma_ctor
name|ctor
decl_stmt|;
name|uma_dtor
name|dtor
decl_stmt|;
name|uma_init
name|uminit
decl_stmt|;
name|uma_fini
name|fini
decl_stmt|;
name|uma_import
name|import
decl_stmt|;
name|uma_release
name|release
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|align
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uma_kctor_args
block|{
name|uma_zone_t
name|zone
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uma_init
name|uminit
decl_stmt|;
name|uma_fini
name|fini
decl_stmt|;
name|int
name|align
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uma_bucket_zone
block|{
name|uma_zone_t
name|ubz_zone
decl_stmt|;
name|char
modifier|*
name|ubz_name
decl_stmt|;
name|int
name|ubz_entries
decl_stmt|;
comment|/* Number of items it can hold. */
name|int
name|ubz_maxsize
decl_stmt|;
comment|/* Maximum allocation size per-item. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Compute the actual number of bucket entries to pack them in power  * of two sizes for more efficient space utilization.  */
end_comment

begin_define
define|#
directive|define
name|BUCKET_SIZE
parameter_list|(
name|n
parameter_list|)
define|\
value|(((sizeof(void *) * (n)) - sizeof(struct uma_bucket)) / sizeof(void *))
end_define

begin_define
define|#
directive|define
name|BUCKET_MAX
value|BUCKET_SIZE(256)
end_define

begin_decl_stmt
name|struct
name|uma_bucket_zone
name|bucket_zones
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|"4 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|4
argument_list|)
block|,
literal|4096
block|}
block|,
block|{
name|NULL
block|,
literal|"6 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|6
argument_list|)
block|,
literal|3072
block|}
block|,
block|{
name|NULL
block|,
literal|"8 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|8
argument_list|)
block|,
literal|2048
block|}
block|,
block|{
name|NULL
block|,
literal|"12 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|12
argument_list|)
block|,
literal|1536
block|}
block|,
block|{
name|NULL
block|,
literal|"16 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|16
argument_list|)
block|,
literal|1024
block|}
block|,
block|{
name|NULL
block|,
literal|"32 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|32
argument_list|)
block|,
literal|512
block|}
block|,
block|{
name|NULL
block|,
literal|"64 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|64
argument_list|)
block|,
literal|256
block|}
block|,
block|{
name|NULL
block|,
literal|"128 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|128
argument_list|)
block|,
literal|128
block|}
block|,
block|{
name|NULL
block|,
literal|"256 Bucket"
block|,
name|BUCKET_SIZE
argument_list|(
literal|256
argument_list|)
block|,
literal|64
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags and enumerations to be passed to internal functions.  */
end_comment

begin_enum
enum|enum
name|zfreeskip
block|{
name|SKIP_NONE
init|=
literal|0
block|,
name|SKIP_DTOR
block|,
name|SKIP_FINI
block|}
enum|;
end_enum

begin_comment
comment|/* Prototypes.. */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|noobj_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|startup_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|vm_size_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|vm_size_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|keg_alloc_slab
parameter_list|(
name|uma_keg_t
parameter_list|,
name|uma_zone_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
parameter_list|,
name|uma_bucket_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|keg_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zone_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zero_init
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_small_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_large_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash_alloc
parameter_list|(
name|struct
name|uma_hash
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
parameter_list|,
name|struct
name|uma_hash
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|zone_alloc_item
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_free_item
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|enum
name|zfreeskip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_bucket_t
name|bucket_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_free
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_bucket_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_zone_drain
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_bucket_t
name|zone_alloc_bucket
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|zone_fetch_slab
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|zone_fetch_slab_multi
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|slab_alloc_item
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|slab_free_item
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_keg_t
name|uma_kcreate
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zone_import
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
modifier|*
name|bucket
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_release
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
modifier|*
name|bucket
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_zero_item
parameter_list|(
name|void
modifier|*
name|item
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vm_zone_count
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vm_zone_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|uma_dbg_free
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_dbg_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSINIT
argument_list|(
name|uma_startup3
argument_list|,
name|SI_SUB_VM_CONF
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|uma_startup3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_count
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_INT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone_count
argument_list|,
literal|"I"
argument_list|,
literal|"Number of UMA zones"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_stats
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone_stats
argument_list|,
literal|"s,struct uma_type_header"
argument_list|,
literal|"Zone Stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zone_warnings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_warnings
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zone_warnings
argument_list|,
literal|0
argument_list|,
literal|"Warn when UMA zones becomes full"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine checks to see whether or not it's safe to enable buckets.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|bucketdisable
operator|=
name|vm_page_count_min
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize bucket_zones, the array of zones of buckets of various sizes.  *  * For each zone, calculate the memory required for each bucket, consisting  * of the header and an array of pointers.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|int
name|size
decl_stmt|;
for|for
control|(
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
literal|0
index|]
init|;
name|ubz
operator|->
name|ubz_entries
operator|!=
literal|0
condition|;
name|ubz
operator|++
control|)
block|{
name|size
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uma_bucket
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ubz
operator|->
name|ubz_entries
expr_stmt|;
name|ubz
operator|->
name|ubz_zone
operator|=
name|uma_zcreate
argument_list|(
name|ubz
operator|->
name|ubz_name
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_MTXCLASS
operator||
name|UMA_ZFLAG_BUCKET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a desired number of entries for a bucket, return the zone from which  * to allocate the bucket.  */
end_comment

begin_function
specifier|static
name|struct
name|uma_bucket_zone
modifier|*
name|bucket_zone_lookup
parameter_list|(
name|int
name|entries
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
for|for
control|(
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
literal|0
index|]
init|;
name|ubz
operator|->
name|ubz_entries
operator|!=
literal|0
condition|;
name|ubz
operator|++
control|)
if|if
condition|(
name|ubz
operator|->
name|ubz_entries
operator|>=
name|entries
condition|)
return|return
operator|(
name|ubz
operator|)
return|;
name|ubz
operator|--
expr_stmt|;
return|return
operator|(
name|ubz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bucket_select
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ubz
operator|->
name|ubz_maxsize
condition|)
return|return
name|MAX
argument_list|(
operator|(
name|ubz
operator|->
name|ubz_maxsize
operator|*
name|ubz
operator|->
name|ubz_entries
operator|)
operator|/
name|size
argument_list|,
literal|1
argument_list|)
return|;
for|for
control|(
init|;
name|ubz
operator|->
name|ubz_entries
operator|!=
literal|0
condition|;
name|ubz
operator|++
control|)
if|if
condition|(
name|ubz
operator|->
name|ubz_maxsize
operator|<
name|size
condition|)
break|break;
name|ubz
operator|--
expr_stmt|;
return|return
operator|(
name|ubz
operator|->
name|ubz_entries
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uma_bucket_t
name|bucket_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
comment|/* 	 * This is to stop us from allocating per cpu buckets while we're 	 * running out of vm.boot_pages.  Otherwise, we would exhaust the 	 * boot pages.  This also prevents us from allocating buckets in 	 * low memory situations. 	 */
if|if
condition|(
name|bucketdisable
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * To limit bucket recursion we store the original zone flags 	 * in a cookie passed via zalloc_arg/zfree_arg.  This allows the 	 * NOVM flag to persist even through deep recursions.  We also 	 * store ZFLAG_BUCKET once we have recursed attempting to allocate 	 * a bucket for a bucket zone so we do not allow infinite bucket 	 * recursion.  This cookie will even persist to frees of unused 	 * buckets via the allocation path or bucket allocations in the 	 * free path. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_BUCKET
operator|)
operator|==
literal|0
condition|)
name|udata
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zone
operator|->
name|uz_flags
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|udata
operator|&
name|UMA_ZFLAG_BUCKET
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|udata
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|udata
operator||
name|UMA_ZFLAG_BUCKET
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|udata
operator|&
name|UMA_ZFLAG_CACHEONLY
condition|)
name|flags
operator||=
name|M_NOVM
expr_stmt|;
name|ubz
operator|=
name|bucket_zone_lookup
argument_list|(
name|zone
operator|->
name|uz_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubz
operator|->
name|ubz_zone
operator|==
name|zone
operator|&&
operator|(
name|ubz
operator|+
literal|1
operator|)
operator|->
name|ubz_entries
operator|!=
literal|0
condition|)
name|ubz
operator|++
expr_stmt|;
name|bucket
operator|=
name|uma_zalloc_arg
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
name|bucket
operator|->
name|ub_bucket
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ubz
operator|->
name|ubz_entries
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_cnt
operator|=
literal|0
expr_stmt|;
name|bucket
operator|->
name|ub_entries
operator|=
name|ubz
operator|->
name|ubz_entries
expr_stmt|;
block|}
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bucket_free
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_bucket_t
name|bucket
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"bucket_free: Freeing a non free bucket."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_BUCKET
operator|)
operator|==
literal|0
condition|)
name|udata
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zone
operator|->
name|uz_flags
expr_stmt|;
name|ubz
operator|=
name|bucket_zone_lookup
argument_list|(
name|bucket
operator|->
name|ub_entries
argument_list|)
expr_stmt|;
name|uma_zfree_arg
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|,
name|bucket
argument_list|,
name|udata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bucket_zone_drain
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
for|for
control|(
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
literal|0
index|]
init|;
name|ubz
operator|->
name|ubz_entries
operator|!=
literal|0
condition|;
name|ubz
operator|++
control|)
name|zone_drain
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_log_warning
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|timeval
name|warninterval
init|=
block|{
literal|300
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|zone_warnings
operator|||
name|zone
operator|->
name|uz_warning
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|zone
operator|->
name|uz_ratecheck
argument_list|,
operator|&
name|warninterval
argument_list|)
condition|)
name|printf
argument_list|(
literal|"[zone: %s] %s\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
operator|->
name|uz_warning
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|zone_maxaction
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_maxaction
operator|.
name|ta_func
operator|!=
name|NULL
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|zone
operator|->
name|uz_maxaction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_foreach_keg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
function_decl|(
modifier|*
name|kegfn
function_decl|)
parameter_list|(
name|uma_keg_t
parameter_list|)
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|klink
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
name|kegfn
argument_list|(
name|klink
operator|->
name|kl_keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine called by timeout which is used to fire off some time interval  * based calculations.  (stats, hash size, etc.)  *  * Arguments:  *	arg   Unused  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_timeout
argument_list|)
expr_stmt|;
comment|/* Reschedule this event */
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_TIMEOUT
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to perform timeout driven calculations.  This expands the  * hashes and does per cpu statistics aggregation.  *  *  Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|keg_timeout
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
comment|/* 	 * Expand the keg hash table. 	 * 	 * This is done if the number of slabs is larger than the hash size. 	 * What I'm trying to do here is completely reduce collisions.  This 	 * may be a little aggressive.  Should I allow for two collisions max? 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
operator|&&
name|keg
operator|->
name|uk_pages
operator|/
name|keg
operator|->
name|uk_ppera
operator|>=
name|keg
operator|->
name|uk_hash
operator|.
name|uh_hashsize
condition|)
block|{
name|struct
name|uma_hash
name|newhash
decl_stmt|;
name|struct
name|uma_hash
name|oldhash
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 		 * This is so involved because allocating and freeing 		 * while the keg lock is held will lead to deadlock. 		 * I have to do everything in stages and check for 		 * races. 		 */
name|newhash
operator|=
name|keg
operator|->
name|uk_hash
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hash_alloc
argument_list|(
operator|&
name|newhash
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|hash_expand
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
operator|&
name|newhash
argument_list|)
condition|)
block|{
name|oldhash
operator|=
name|keg
operator|->
name|uk_hash
expr_stmt|;
name|keg
operator|->
name|uk_hash
operator|=
name|newhash
expr_stmt|;
block|}
else|else
name|oldhash
operator|=
name|newhash
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
operator|&
name|oldhash
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|zone_foreach_keg
argument_list|(
name|zone
argument_list|,
operator|&
name|keg_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and zero fill the next sized hash table from the appropriate  * backing store.  *  * Arguments:  *	hash  A new hash structure with the old hash size in uh_hashsize  *  * Returns:  *	1 on success and 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hash_alloc
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
name|int
name|oldsize
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|oldsize
operator|=
name|hash
operator|->
name|uh_hashsize
expr_stmt|;
comment|/* We're just going to go to a power of two greater */
if|if
condition|(
name|oldsize
condition|)
block|{
name|hash
operator|->
name|uh_hashsize
operator|=
name|oldsize
operator|*
literal|2
expr_stmt|;
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|hash
operator|->
name|uh_hashsize
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
operator|(
expr|struct
name|slabhead
operator|*
operator|)
name|malloc
argument_list|(
name|alloc
argument_list|,
name|M_UMAHASH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
name|zone_alloc_item
argument_list|(
name|hashzone
argument_list|,
name|NULL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_hashsize
operator|=
name|UMA_HASH_SIZE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|->
name|uh_slab_hash
condition|)
block|{
name|bzero
argument_list|(
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_hashmask
operator|=
name|hash
operator|->
name|uh_hashsize
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expands the hash table for HASH zones.  This is done from zone_timeout  * to reduce collisions.  This must not be done in the regular allocation  * path, otherwise, we can recurse on the vm while allocating pages.  *  * Arguments:  *	oldhash  The hash you want to expand  *	newhash  The hash structure for the new table  *  * Returns:  *	Nothing  *  * Discussion:  */
end_comment

begin_function
specifier|static
name|int
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|oldhash
parameter_list|,
name|struct
name|uma_hash
modifier|*
name|newhash
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|hval
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|newhash
operator|->
name|uh_slab_hash
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|oldhash
operator|->
name|uh_hashsize
operator|>=
name|newhash
operator|->
name|uh_hashsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * I need to investigate hash algorithms for resizing without a 	 * full rehash. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldhash
operator|->
name|uh_hashsize
condition|;
name|i
operator|++
control|)
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slab
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
name|hval
operator|=
name|UMA_HASH
argument_list|(
name|newhash
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|newhash
operator|->
name|uh_slab_hash
index|[
name|hval
index|]
argument_list|,
name|slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the hash bucket to the appropriate backing store.  *  * Arguments:  *	slab_hash  The hash bucket we're freeing  *	hashsize   The number of entries in that hash bucket  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
if|if
condition|(
name|hash
operator|->
name|uh_slab_hash
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|hash
operator|->
name|uh_hashsize
operator|==
name|UMA_HASH_SIZE_INIT
condition|)
name|zone_free_item
argument_list|(
name|hashzone
argument_list|,
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|M_UMAHASH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Frees all outstanding items in a bucket  *  * Arguments:  *	zone   The zone to free to, must be unlocked.  *	bucket The free/alloc bucket with items, cpu queue must be locked.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_bucket_t
name|bucket
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|zone
operator|->
name|uz_fini
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bucket
operator|->
name|ub_cnt
condition|;
name|i
operator|++
control|)
name|zone
operator|->
name|uz_fini
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|i
index|]
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_release
argument_list|(
name|zone
operator|->
name|uz_arg
argument_list|,
name|bucket
operator|->
name|ub_bucket
argument_list|,
name|bucket
operator|->
name|ub_cnt
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|ub_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drains the per cpu caches for a zone.  *  * NOTE: This may only be called while the zone is being turn down, and not  * during normal operation.  This is necessary in order that we do not have  * to migrate CPUs to drain the per-CPU caches.  *  * Arguments:  *	zone     The zone to drain, must be unlocked.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* 	 * XXX: It is safe to not lock the per-CPU caches, because we're 	 * tearing down the zone anyway.  I.e., there will be no further use 	 * of the caches at this point. 	 * 	 * XXX: It would good to be able to assert that the zone is being 	 * torn down to prevent improper use of cache_drain(). 	 * 	 * XXX: We lock the zone before passing into bucket_cache_drain() as 	 * it is used elsewhere.  Should the tear-down path be made special 	 * there in some form? 	 */
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket_cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_shrink
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
return|return;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_count
operator|=
operator|(
name|zone
operator|->
name|uz_count_min
operator|+
name|zone
operator|->
name|uz_count
operator|)
operator|/
literal|2
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_drain_safe_cpu
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|b1
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
return|return;
name|b1
operator|=
name|b2
operator|=
name|NULL
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|curcpu
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
operator|!=
literal|0
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
else|else
name|b1
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
operator|!=
literal|0
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
else|else
name|b2
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
condition|)
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|b1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
condition|)
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|b2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Safely drain per-CPU caches of a zone(s) to alloc bucket.  * This is an expensive call because it needs to bind to all CPUs  * one by one and enter a critical section on each of them in order  * to safely access their cache buckets.  * Zone lock must not be held on call this function.  */
end_comment

begin_function
specifier|static
name|void
name|cache_drain_safe
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
comment|/* 	 * Polite bucket sizes shrinking was not enouth, shrink aggressively. 	 */
if|if
condition|(
name|zone
condition|)
name|cache_shrink
argument_list|(
name|zone
argument_list|)
expr_stmt|;
else|else
name|zone_foreach
argument_list|(
name|cache_shrink
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
condition|)
name|cache_drain_safe_cpu
argument_list|(
name|zone
argument_list|)
expr_stmt|;
else|else
name|zone_foreach
argument_list|(
name|cache_drain_safe_cpu
argument_list|)
expr_stmt|;
block|}
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain the cached buckets from a zone.  Expects a locked zone on entry.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_bucket_t
name|bucket
decl_stmt|;
comment|/* 	 * Drain the bucket queues and free the buckets, we just keep two per 	 * cpu (alloc/free). 	 */
while|while
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shrink further bucket sizes.  Price of single zone lock collision 	 * is probably lower then price of global cache drain. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_count
operator|>
name|zone
operator|->
name|uz_count_min
condition|)
name|zone
operator|->
name|uz_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keg_free_slab
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|uint8_t
modifier|*
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_UMA
argument_list|,
literal|"keg_free_slab keg %s(%p) slab %p, returning %d bytes"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|,
name|slab
argument_list|,
name|PAGE_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
argument_list|)
expr_stmt|;
name|mem
operator|=
name|slab
operator|->
name|us_data
expr_stmt|;
name|flags
operator|=
name|slab
operator|->
name|us_flags
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_fini
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
name|keg
operator|->
name|uk_fini
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|i
operator|)
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|zone_free_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_freef
argument_list|(
name|mem
argument_list|,
name|PAGE_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Frees pages from a keg back to the system.  This is done on demand from  * the pageout daemon.  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|keg_drain
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|struct
name|slabhead
name|freeslabs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* 	 * We don't want to take pages from statically allocated kegs at this 	 * time 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_NOFREE
operator|||
name|keg
operator|->
name|uk_freef
operator|==
name|NULL
condition|)
return|return;
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"keg_drain %s(%p) free items: %u"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|==
literal|0
condition|)
goto|goto
name|finished
goto|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_free_slab
argument_list|,
argument|us_link
argument_list|,
argument|tmp
argument_list|)
block|{
comment|/* We have nowhere to free these to. */
if|if
condition|(
name|slab
operator|->
name|us_flags
operator|&
name|UMA_SLAB_BOOT
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|-=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|-=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|UMA_HASH_REMOVE
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|freeslabs
argument_list|,
name|slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
block|}
name|finished
label|:
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|slab
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|freeslabs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|freeslabs
argument_list|,
name|slab
argument_list|,
name|uma_slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
name|keg_free_slab
argument_list|(
name|keg
argument_list|,
name|slab
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_drain_wait
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
comment|/* 	 * Set draining to interlock with zone_dtor() so we can release our 	 * locks as we go.  Only dtor() should do a WAITOK call since it 	 * is the only call that knows the structure will still be available 	 * when it wakes up. 	 */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
while|while
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_DRAINING
condition|)
block|{
if|if
condition|(
name|waitok
operator|==
name|M_NOWAIT
condition|)
goto|goto
name|out
goto|;
name|msleep
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|uz_lockptr
argument_list|,
name|PVM
argument_list|,
literal|"zonedrain"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_DRAINING
expr_stmt|;
name|bucket_cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * The DRAINING flag protects us from being freed while 	 * we're running.  Normally the uma_rwlock would protect us but we 	 * must be able to release and acquire the right lock for each keg. 	 */
name|zone_foreach_keg
argument_list|(
name|zone
argument_list|,
operator|&
name|keg_drain
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_DRAINING
expr_stmt|;
name|wakeup
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|out
label|:
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zone_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|zone_drain_wait
argument_list|(
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new slab for a keg.  This does not insert the slab onto a list.  *  * Arguments:  *	wait  Shall we wait?  *  * Returns:  *	The slab that was allocated or NULL if there is no memory and the  *	caller specified M_NOWAIT.  */
end_comment

begin_function
specifier|static
name|uma_slab_t
name|keg_alloc_slab
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uma_alloc
name|allocf
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uint8_t
modifier|*
name|mem
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
name|mem
operator|=
name|NULL
expr_stmt|;
name|allocf
operator|=
name|keg
operator|->
name|uk_allocf
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
block|{
name|slab
operator|=
name|zone_alloc_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * This reproduces the old vm_zone behavior of zero filling pages the 	 * first time they are added to a zone. 	 * 	 * Malloced items are zeroed in uma_zalloc. 	 */
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_MALLOC
operator|)
operator|==
literal|0
condition|)
name|wait
operator||=
name|M_ZERO
expr_stmt|;
else|else
name|wait
operator|&=
operator|~
name|M_ZERO
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_NODUMP
condition|)
name|wait
operator||=
name|M_NODUMP
expr_stmt|;
comment|/* zone is passed for legacy reasons. */
name|mem
operator|=
name|allocf
argument_list|(
name|zone
argument_list|,
name|keg
operator|->
name|uk_ppera
operator|*
name|PAGE_SIZE
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|zone_free_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Point the slab into the allocated memory */
if|if
condition|(
operator|!
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
condition|)
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
name|mem
operator|+
name|keg
operator|->
name|uk_pgoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ppera
condition|;
name|i
operator|++
control|)
name|vsetslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_keg
operator|=
name|keg
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
expr_stmt|;
name|BIT_FILL
argument_list|(
name|SLAB_SETSIZE
argument_list|,
operator|&
name|slab
operator|->
name|us_free
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|BIT_ZERO
argument_list|(
name|SLAB_SETSIZE
argument_list|,
operator|&
name|slab
operator|->
name|us_debugfree
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keg
operator|->
name|uk_init
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ipers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|keg
operator|->
name|uk_init
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|i
operator|)
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|,
name|wait
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|keg
operator|->
name|uk_ipers
condition|)
block|{
name|keg_free_slab
argument_list|(
name|keg
argument_list|,
name|slab
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"keg_alloc_slab: allocated slab %p for %s(%p)"
argument_list|,
name|slab
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|UMA_HASH_INSERT
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|slab
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|+=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|+=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
block|}
return|return
operator|(
name|slab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is intended to be used early on in place of page_alloc() so  * that we may use the boot time page cache to satisfy allocations before  * the VM is ready.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|startup_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|vm_size_t
name|bytes
parameter_list|,
name|uint8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|pages
operator|=
name|howmany
argument_list|(
name|bytes
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pages
operator|>
literal|0
argument_list|,
operator|(
literal|"startup_alloc can't reserve 0 pages\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check our small startup cache to see if it has pages remaining. 	 */
name|mtx_lock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
operator|<=
name|boot_pages
condition|)
block|{
name|mem
operator|=
name|bootmem
expr_stmt|;
name|boot_pages
operator|-=
name|pages
expr_stmt|;
name|bootmem
operator|+=
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
operator|*
name|pflag
operator|=
name|UMA_SLAB_BOOT
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP2
condition|)
name|panic
argument_list|(
literal|"UMA: Increase vm.boot_pages"
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've booted reset these users to their real allocator. 	 */
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
name|keg
operator|->
name|uk_allocf
operator|=
operator|(
name|keg
operator|->
name|uk_ppera
operator|>
literal|1
operator|)
condition|?
name|page_alloc
else|:
name|uma_small_alloc
expr_stmt|;
else|#
directive|else
name|keg
operator|->
name|uk_allocf
operator|=
name|page_alloc
expr_stmt|;
endif|#
directive|endif
return|return
name|keg
operator|->
name|uk_allocf
argument_list|(
name|zone
argument_list|,
name|bytes
argument_list|,
name|pflag
argument_list|,
name|wait
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from the system  *  * Arguments:  *	bytes  The number of bytes requested  *	wait  Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly  *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|vm_size_t
name|bytes
parameter_list|,
name|uint8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Returned page */
operator|*
name|pflag
operator|=
name|UMA_SLAB_KMEM
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kmem_arena
argument_list|,
name|bytes
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from within an object  *  * Arguments:  *	bytes  The number of bytes requested  *	wait   Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly  *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|noobj_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|vm_size_t
name|bytes
parameter_list|,
name|uint8_t
modifier|*
name|flags
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|vm_page
argument_list|)
name|alloctail
expr_stmt|;
name|u_long
name|npages
decl_stmt|;
name|vm_offset_t
name|retkva
decl_stmt|,
name|zkva
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|p_next
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|alloctail
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|npages
operator|=
name|howmany
argument_list|(
name|bytes
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|npages
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_NOOBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Since the page does not belong to an object, its 			 * listq is unused. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|alloctail
argument_list|,
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|npages
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wait
operator|&
name|M_WAITOK
condition|)
block|{
name|VM_WAIT
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Page allocation failed, free intermediate pages and 		 * exit. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&alloctail
argument_list|,
argument|listq
argument_list|,
argument|p_next
argument_list|)
block|{
name|vm_page_unwire
argument_list|(
name|p
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|flags
operator|=
name|UMA_SLAB_PRIV
expr_stmt|;
name|zkva
operator|=
name|keg
operator|->
name|uk_kva
operator|+
name|atomic_fetchadd_long
argument_list|(
operator|&
name|keg
operator|->
name|uk_offset
argument_list|,
name|round_page
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|retkva
operator|=
name|zkva
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&alloctail
argument_list|,
argument|listq
argument_list|)
block|{
name|pmap_qenter
argument_list|(
name|zkva
argument_list|,
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zkva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|retkva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees a number of pages to the system  *  * Arguments:  *	mem   A pointer to the memory to be freed  *	size  The size of the memory being freed  *	flags The original p->us_flags field  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|vmem
modifier|*
name|vmem
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMEM
condition|)
name|vmem
operator|=
name|kmem_arena
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KERNEL
condition|)
name|vmem
operator|=
name|kernel_arena
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"UMA: page_free used with invalid flags %x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vmem
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero fill initializer  *  * Arguments/Returns follow uma_init specifications  */
end_comment

begin_function
specifier|static
name|int
name|zero_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bzero
argument_list|(
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish creating a small uma keg.  This calculates ipers, and the keg size.  *  * Arguments  *	keg  The zone we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|keg_small_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|u_int
name|rsize
decl_stmt|;
name|u_int
name|memused
decl_stmt|;
name|u_int
name|wastedspace
decl_stmt|;
name|u_int
name|shsize
decl_stmt|;
name|u_int
name|slabsize
decl_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_PCPU
condition|)
block|{
name|u_int
name|ncpus
init|=
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
condition|?
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
else|:
name|MAXCPU
decl_stmt|;
name|slabsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
name|howmany
argument_list|(
name|ncpus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slabsize
operator|=
name|UMA_SLAB_SIZE
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Calculate the size of each allocation (rsize) according to 	 * alignment.  If the requested size is smaller than we have 	 * allocation bits for we round it up. 	 */
name|rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|slabsize
operator|/
name|SLAB_SETSIZE
condition|)
name|rsize
operator|=
name|slabsize
operator|/
name|SLAB_SETSIZE
expr_stmt|;
if|if
condition|(
name|rsize
operator|&
name|keg
operator|->
name|uk_align
condition|)
name|rsize
operator|=
operator|(
name|rsize
operator|&
operator|~
name|keg
operator|->
name|uk_align
operator|)
operator|+
operator|(
name|keg
operator|->
name|uk_align
operator|+
literal|1
operator|)
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|rsize
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_PCPU
operator|)
operator|==
literal|0
operator|||
name|keg
operator|->
name|uk_rsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|,
operator|(
literal|"%s: size %u too large"
operator|,
name|__func__
operator|,
name|keg
operator|->
name|uk_rsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|shsize
operator|=
literal|0
expr_stmt|;
else|else
name|shsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_ipers
operator|=
operator|(
name|slabsize
operator|-
name|shsize
operator|)
operator|/
name|rsize
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|>
literal|0
operator|&&
name|keg
operator|->
name|uk_ipers
operator|<=
name|SLAB_SETSIZE
argument_list|,
operator|(
literal|"%s: keg->uk_ipers %u"
operator|,
name|__func__
operator|,
name|keg
operator|->
name|uk_ipers
operator|)
argument_list|)
expr_stmt|;
name|memused
operator|=
name|keg
operator|->
name|uk_ipers
operator|*
name|rsize
operator|+
name|shsize
expr_stmt|;
name|wastedspace
operator|=
name|slabsize
operator|-
name|memused
expr_stmt|;
comment|/* 	 * We can't do OFFPAGE if we're internal or if we've been 	 * asked to not go to the VM for buckets.  If we do this we 	 * may end up going to the VM  for slabs which we do not 	 * want to do if we're UMA_ZFLAG_CACHEONLY as a result 	 * of UMA_ZONE_VM, which clearly forbids it. 	 */
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
operator|||
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
operator|)
condition|)
return|return;
comment|/* 	 * See if using an OFFPAGE slab will limit our waste.  Only do 	 * this if it permits more items per-slab. 	 * 	 * XXX We could try growing slabsize to limit max waste as well. 	 * Historically this was not done because the VM could not 	 * efficiently handle contiguous allocations. 	 */
if|if
condition|(
operator|(
name|wastedspace
operator|>=
name|slabsize
operator|/
name|UMA_MAX_WASTE
operator|)
operator|&&
operator|(
name|keg
operator|->
name|uk_ipers
operator|<
operator|(
name|slabsize
operator|/
name|keg
operator|->
name|uk_rsize
operator|)
operator|)
condition|)
block|{
name|keg
operator|->
name|uk_ipers
operator|=
name|slabsize
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|>
literal|0
operator|&&
name|keg
operator|->
name|uk_ipers
operator|<=
name|SLAB_SETSIZE
argument_list|,
operator|(
literal|"%s: keg->uk_ipers %u"
operator|,
name|__func__
operator|,
name|keg
operator|->
name|uk_ipers
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_UMA
argument_list|,
literal|"UMA decided we need offpage slab headers for "
literal|"keg: %s(%p), calculated wastedspace = %d, "
literal|"maximum wasted space allowed = %d, "
literal|"calculated ipers = %d, "
literal|"new wasted space = %d\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|,
name|wastedspace
argument_list|,
name|slabsize
operator|/
name|UMA_MAX_WASTE
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|slabsize
operator|-
name|keg
operator|->
name|uk_ipers
operator|*
name|keg
operator|->
name|uk_rsize
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
operator|&&
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|==
literal|0
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_HASH
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Finish creating a large (> UMA_SLAB_SIZE) uma kegs.  Just give in and do  * OFFPAGE for now.  When I can allow for more dynamic slab sizes this will be  * more complicated.  *  * Arguments  *	keg  The keg we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|keg_large_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|u_int
name|shsize
decl_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Keg is null in keg_large_init"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"keg_large_init: Cannot large-init a UMA_ZFLAG_CACHEONLY keg"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_PCPU
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Cannot large-init a UMA_ZONE_PCPU keg"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
name|howmany
argument_list|(
name|keg
operator|->
name|uk_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_ipers
operator|=
literal|1
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
comment|/* We can't do OFFPAGE if we're internal, bail out here. */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
return|return;
comment|/* Check whether we have enough space to not do OFFPAGE. */
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
operator|==
literal|0
condition|)
block|{
name|shsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
if|if
condition|(
name|shsize
operator|&
name|UMA_ALIGN_PTR
condition|)
name|shsize
operator|=
operator|(
name|shsize
operator|&
operator|~
name|UMA_ALIGN_PTR
operator|)
operator|+
operator|(
name|UMA_ALIGN_PTR
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|PAGE_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
operator|)
operator|-
name|keg
operator|->
name|uk_rsize
operator|<
name|shsize
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
operator|&&
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|==
literal|0
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_HASH
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keg_cachespread_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|int
name|alignsize
decl_stmt|;
name|int
name|trailer
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|int
name|rsize
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_PCPU
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Cannot cachespread-init a UMA_ZONE_PCPU keg"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alignsize
operator|=
name|keg
operator|->
name|uk_align
operator|+
literal|1
expr_stmt|;
name|rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
comment|/* 	 * We want one item to start on every align boundary in a page.  To 	 * do this we will span pages.  We will also extend the item by the 	 * size of align if it is an even multiple of align.  Otherwise, it 	 * would fall on the same boundary every time. 	 */
if|if
condition|(
name|rsize
operator|&
name|keg
operator|->
name|uk_align
condition|)
name|rsize
operator|=
operator|(
name|rsize
operator|&
operator|~
name|keg
operator|->
name|uk_align
operator|)
operator|+
name|alignsize
expr_stmt|;
if|if
condition|(
operator|(
name|rsize
operator|&
name|alignsize
operator|)
operator|==
literal|0
condition|)
name|rsize
operator|+=
name|alignsize
expr_stmt|;
name|trailer
operator|=
name|rsize
operator|-
name|keg
operator|->
name|uk_size
expr_stmt|;
name|pages
operator|=
operator|(
name|rsize
operator|*
operator|(
name|PAGE_SIZE
operator|/
name|alignsize
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
name|pages
operator|=
name|MIN
argument_list|(
name|pages
argument_list|,
operator|(
literal|128
operator|*
literal|1024
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|rsize
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
name|pages
expr_stmt|;
name|keg
operator|->
name|uk_ipers
operator|=
operator|(
operator|(
name|pages
operator|*
name|PAGE_SIZE
operator|)
operator|+
name|trailer
operator|)
operator|/
name|rsize
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
operator||
name|UMA_ZONE_VTOSLAB
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|<=
name|SLAB_SETSIZE
argument_list|,
operator|(
literal|"%s: keg->uk_ipers too high(%d) increase max_ipers"
operator|,
name|__func__
operator|,
name|keg
operator|->
name|uk_ipers
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keg header ctor.  This initializes all fields, locks, etc.  And inserts  * the keg onto the global keg list.  *  * Arguments/Returns follow uma_ctor specifications  *	udata  Actually uma_kctor_args  */
end_comment

begin_function
specifier|static
name|int
name|keg_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_kctor_args
modifier|*
name|arg
init|=
name|udata
decl_stmt|;
name|uma_keg_t
name|keg
init|=
name|mem
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|bzero
argument_list|(
name|keg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|keg
operator|->
name|uk_init
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|keg
operator|->
name|uk_fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|keg
operator|->
name|uk_align
operator|=
name|arg
operator|->
name|align
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_reserve
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator|=
name|arg
operator|->
name|flags
expr_stmt|;
name|keg
operator|->
name|uk_allocf
operator|=
name|page_alloc
expr_stmt|;
name|keg
operator|->
name|uk_freef
operator|=
name|page_free
expr_stmt|;
name|keg
operator|->
name|uk_slabzone
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The master zone is passed to us at keg-creation time. 	 */
name|zone
operator|=
name|arg
operator|->
name|zone
expr_stmt|;
name|keg
operator|->
name|uk_name
operator|=
name|zone
operator|->
name|uz_name
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_VM
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZFLAG_CACHEONLY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_ZINIT
condition|)
name|keg
operator|->
name|uk_init
operator|=
name|zero_init
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_VTOSLAB
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_PCPU
condition|)
ifdef|#
directive|ifdef
name|SMP
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
expr_stmt|;
else|#
directive|else
name|keg
operator|->
name|uk_flags
operator|&=
operator|~
name|UMA_ZONE_PCPU
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_CACHESPREAD
condition|)
block|{
name|keg_cachespread_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|keg
operator|->
name|uk_size
operator|>
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|)
condition|)
name|keg_large_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
else|else
name|keg_small_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|keg
operator|->
name|uk_slabzone
operator|=
name|slabzone
expr_stmt|;
comment|/* 	 * If we haven't booted yet we need allocations to go through the 	 * startup cache until the vm is ready. 	 */
if|if
condition|(
name|keg
operator|->
name|uk_ppera
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
name|keg
operator|->
name|uk_allocf
operator|=
name|uma_small_alloc
expr_stmt|;
name|keg
operator|->
name|uk_freef
operator|=
name|uma_small_free
expr_stmt|;
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP
condition|)
name|keg
operator|->
name|uk_allocf
operator|=
name|startup_alloc
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP2
condition|)
name|keg
operator|->
name|uk_allocf
operator|=
name|startup_alloc
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP2
operator|&&
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
name|keg
operator|->
name|uk_allocf
operator|=
name|startup_alloc
expr_stmt|;
comment|/* 	 * Initialize keg's lock 	 */
name|KEG_LOCK_INIT
argument_list|(
name|keg
argument_list|,
operator|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MTXCLASS
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we're putting the slab header in the actual page we need to 	 * figure out where in each page it goes.  This calculates a right 	 * justified offset into the memory on an ALIGN_PTR boundary. 	 */
if|if
condition|(
operator|!
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
condition|)
block|{
name|u_int
name|totsize
decl_stmt|;
comment|/* Size of the slab struct and free list */
name|totsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
if|if
condition|(
name|totsize
operator|&
name|UMA_ALIGN_PTR
condition|)
name|totsize
operator|=
operator|(
name|totsize
operator|&
operator|~
name|UMA_ALIGN_PTR
operator|)
operator|+
operator|(
name|UMA_ALIGN_PTR
operator|+
literal|1
operator|)
expr_stmt|;
name|keg
operator|->
name|uk_pgoff
operator|=
operator|(
name|PAGE_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
operator|)
operator|-
name|totsize
expr_stmt|;
comment|/* 		 * The only way the following is possible is if with our 		 * UMA_ALIGN_PTR adjustments we are now bigger than 		 * UMA_SLAB_SIZE.  I haven't checked whether this is 		 * mathematically possible for all cases, so we make 		 * sure here anyway. 		 */
name|totsize
operator|=
name|keg
operator|->
name|uk_pgoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
if|if
condition|(
name|totsize
operator|>
name|PAGE_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
condition|)
block|{
name|printf
argument_list|(
literal|"zone %s ipers %d rsize %d size %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|keg
operator|->
name|uk_rsize
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"UMA slab won't fit."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|hash_alloc
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_UMA
argument_list|,
literal|"keg_ctor %p zone %s(%p) out %d free %d\n"
argument_list|,
name|keg
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
operator|(
name|keg
operator|->
name|uk_pages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
operator|-
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_zones
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_kegs
argument_list|,
name|keg
argument_list|,
name|uk_link
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zone header ctor.  This initializes all fields, locks, etc.  *  * Arguments/Returns follow uma_ctor specifications  *	udata  Actually uma_zctor_args  */
end_comment

begin_function
specifier|static
name|int
name|zone_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
modifier|*
name|arg
init|=
name|udata
decl_stmt|;
name|uma_zone_t
name|zone
init|=
name|mem
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|bzero
argument_list|(
name|zone
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_name
operator|=
name|arg
operator|->
name|name
expr_stmt|;
name|zone
operator|->
name|uz_ctor
operator|=
name|arg
operator|->
name|ctor
expr_stmt|;
name|zone
operator|->
name|uz_dtor
operator|=
name|arg
operator|->
name|dtor
expr_stmt|;
name|zone
operator|->
name|uz_slab
operator|=
name|zone_fetch_slab
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_allocs
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_frees
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_fails
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_sleeps
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_count
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_count_min
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_warning
operator|=
name|NULL
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|zone
operator|->
name|uz_ratecheck
argument_list|)
expr_stmt|;
name|keg
operator|=
name|arg
operator|->
name|keg
expr_stmt|;
name|ZONE_LOCK_INIT
argument_list|(
name|zone
argument_list|,
operator|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MTXCLASS
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is a pure cache zone, no kegs. 	 */
if|if
condition|(
name|arg
operator|->
name|import
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_VM
condition|)
name|arg
operator|->
name|flags
operator||=
name|UMA_ZFLAG_CACHEONLY
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|=
name|arg
operator|->
name|flags
expr_stmt|;
name|zone
operator|->
name|uz_size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|zone
operator|->
name|uz_import
operator|=
name|arg
operator|->
name|import
expr_stmt|;
name|zone
operator|->
name|uz_release
operator|=
name|arg
operator|->
name|release
expr_stmt|;
name|zone
operator|->
name|uz_arg
operator|=
name|arg
operator|->
name|arg
expr_stmt|;
name|zone
operator|->
name|uz_lockptr
operator|=
operator|&
name|zone
operator|->
name|uz_lock
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_cachezones
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Use the regular zone/keg/slab allocator. 	 */
name|zone
operator|->
name|uz_import
operator|=
operator|(
name|uma_import
operator|)
name|zone_import
expr_stmt|;
name|zone
operator|->
name|uz_release
operator|=
operator|(
name|uma_release
operator|)
name|zone_release
expr_stmt|;
name|zone
operator|->
name|uz_arg
operator|=
name|zone
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_SECONDARY
condition|)
block|{
name|KASSERT
argument_list|(
name|arg
operator|->
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Secondary zone on zero'd keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|zone
operator|->
name|uz_lockptr
operator|=
operator|&
name|keg
operator|->
name|uk_lock
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZONE_SECONDARY
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&keg->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|z
argument_list|,
name|uz_link
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|z
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|keg
operator|=
name|uma_kcreate
argument_list|(
name|zone
argument_list|,
name|arg
operator|->
name|size
argument_list|,
name|arg
operator|->
name|uminit
argument_list|,
name|arg
operator|->
name|fini
argument_list|,
name|arg
operator|->
name|align
argument_list|,
name|arg
operator|->
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|else
block|{
name|struct
name|uma_kctor_args
name|karg
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* We should only be here from uma_startup() */
name|karg
operator|.
name|size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|karg
operator|.
name|uminit
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|karg
operator|.
name|fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|karg
operator|.
name|align
operator|=
name|arg
operator|->
name|align
expr_stmt|;
name|karg
operator|.
name|flags
operator|=
name|arg
operator|->
name|flags
expr_stmt|;
name|karg
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|error
operator|=
name|keg_ctor
argument_list|(
name|arg
operator|->
name|keg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_keg
argument_list|)
argument_list|,
operator|&
name|karg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Link in the first keg. 	 */
name|zone
operator|->
name|uz_klink
operator|.
name|kl_keg
operator|=
name|keg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|,
operator|&
name|zone
operator|->
name|uz_klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_lockptr
operator|=
operator|&
name|keg
operator|->
name|uk_lock
expr_stmt|;
name|zone
operator|->
name|uz_size
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
operator|(
name|keg
operator|->
name|uk_flags
operator|&
operator|(
name|UMA_ZONE_INHERIT
operator||
name|UMA_ZFLAG_INHERIT
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Some internal zones don't have room allocated for the per cpu 	 * caches.  If we're internal, bail out here. 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Secondary zone requested UMA_ZFLAG_INTERNAL"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|out
label|:
if|if
condition|(
operator|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MAXBUCKET
operator|)
operator|==
literal|0
condition|)
name|zone
operator|->
name|uz_count
operator|=
name|bucket_select
argument_list|(
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
else|else
name|zone
operator|->
name|uz_count
operator|=
name|BUCKET_MAX
expr_stmt|;
name|zone
operator|->
name|uz_count_min
operator|=
name|zone
operator|->
name|uz_count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Keg header dtor.  This frees all data, destroys locks, frees the hash  * table and removes the keg from the global list.  *  * Arguments/Returns follow uma_dtor specifications  *	udata  unused  */
end_comment

begin_function
specifier|static
name|void
name|keg_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
operator|(
name|uma_keg_t
operator|)
name|arg
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Freed UMA keg (%s) was not empty (%d items). "
literal|" Lost %d pages of memory.\n"
argument_list|,
name|keg
operator|->
name|uk_name
condition|?
name|keg
operator|->
name|uk_name
else|:
literal|""
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_pages
argument_list|)
expr_stmt|;
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|)
expr_stmt|;
name|KEG_LOCK_FINI
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zone header dtor.  *  * Arguments/Returns follow uma_dtor specifications  *	udata  unused  */
end_comment

begin_function
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|zone
operator|=
operator|(
name|uma_zone_t
operator|)
name|arg
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
name|cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * XXX there are some races here where 	 * the zone can be drained but zone lock 	 * released and then refilled before we 	 * remove it... we dont care for now 	 */
name|zone_drain_wait
argument_list|(
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Unlink all of our kegs. 	 */
while|while
condition|(
operator|(
name|klink
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|klink
operator|->
name|kl_keg
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|klink
operator|==
operator|&
name|zone
operator|->
name|uz_klink
condition|)
continue|continue;
name|free
argument_list|(
name|klink
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only destroy kegs from non secondary zones. 	 */
if|if
condition|(
name|keg
operator|!=
name|NULL
operator|&&
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|==
literal|0
condition|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|keg
argument_list|,
name|uk_link
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|kegs
argument_list|,
name|keg
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
block|}
name|ZONE_LOCK_FINI
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Traverses every zone in the system and calls a callback  *  * Arguments:  *	zfunc  A pointer to a function which accepts a zone  *		as an argument.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|keg
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|zone
argument_list|,
argument|&keg->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|zfunc
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public functions */
end_comment

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_startup
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|rw_init
argument_list|(
operator|&
name|uma_rwlock
argument_list|,
literal|"UMA lock"
argument_list|)
expr_stmt|;
comment|/* "manually" create the initial zone */
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
literal|"UMA Kegs"
expr_stmt|;
name|args
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_keg
argument_list|)
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|keg_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|keg_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zero_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|keg
operator|=
operator|&
name|masterkeg
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|32
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|UMA_ZFLAG_INTERNAL
expr_stmt|;
comment|/* The initial zone has no Per cpu queues so it's smaller */
name|zone_ctor
argument_list|(
name|kegs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|,
literal|"UMA boot pages"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bootmem
operator|=
name|mem
expr_stmt|;
name|boot_pages
operator|=
name|npages
expr_stmt|;
name|args
operator|.
name|name
operator|=
literal|"UMA Zones"
expr_stmt|;
name|args
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|uma_cache
argument_list|)
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|zone_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|zone_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zero_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|32
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|UMA_ZFLAG_INTERNAL
expr_stmt|;
comment|/* The initial zone has no Per cpu queues so it's smaller */
name|zone_ctor
argument_list|(
name|zones
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Now make a zone for slab headers */
name|slabzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Slabs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
argument_list|)
expr_stmt|;
name|hashzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Hash"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slabhead
operator|*
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
argument_list|)
expr_stmt|;
name|bucket_init
argument_list|()
expr_stmt|;
name|booted
operator|=
name|UMA_STARTUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* see uma.h */
end_comment

begin_function
name|void
name|uma_startup2
parameter_list|(
name|void
parameter_list|)
block|{
name|booted
operator|=
name|UMA_STARTUP2
expr_stmt|;
name|bucket_enable
argument_list|()
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|uma_drain_lock
argument_list|,
literal|"umadrain"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize our callout handle  *  */
end_comment

begin_function
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|uma_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_TIMEOUT
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uma_keg_t
name|uma_kcreate
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|uma_kctor_args
name|args
decl_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|uminit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|fini
expr_stmt|;
name|args
operator|.
name|align
operator|=
operator|(
name|align
operator|==
name|UMA_ALIGN_CACHE
operator|)
condition|?
name|uma_align_cache
else|:
name|align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
return|return
operator|(
name|zone_alloc_item
argument_list|(
name|kegs
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_set_align
parameter_list|(
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|!=
name|UMA_ALIGN_CACHE
condition|)
name|uma_align_cache
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zcreate
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|uma_zone_t
name|res
decl_stmt|;
name|bool
name|locked
decl_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|align
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
literal|"invalid zone alignment %d for \"%s\""
operator|,
name|align
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* This stuff is essential for the zone ctor */
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|uminit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|fini
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * If a zone is being created with an empty constructor and 	 * destructor, pass UMA constructor/destructor which checks for 	 * memory use after free. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|UMA_ZONE_ZINIT
operator||
name|UMA_ZONE_NOFREE
operator|)
operator|)
operator|)
operator|&&
name|ctor
operator|==
name|NULL
operator|&&
name|dtor
operator|==
name|NULL
operator|&&
name|uminit
operator|==
name|NULL
operator|&&
name|fini
operator|==
name|NULL
condition|)
block|{
name|args
operator|.
name|ctor
operator|=
name|trash_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|trash_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|trash_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|trash_fini
expr_stmt|;
block|}
endif|#
directive|endif
name|args
operator|.
name|align
operator|=
name|align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP2
condition|)
block|{
name|locked
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|sx_slock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|true
expr_stmt|;
block|}
name|res
operator|=
name|zone_alloc_item
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|sx_sunlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zsecond_create
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|zinit
parameter_list|,
name|uma_fini
name|zfini
parameter_list|,
name|uma_zone_t
name|master
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|uma_zone_t
name|res
decl_stmt|;
name|bool
name|locked
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zinit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|zfini
expr_stmt|;
name|args
operator|.
name|align
operator|=
name|keg
operator|->
name|uk_align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|keg
operator|->
name|uk_flags
operator||
name|UMA_ZONE_SECONDARY
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|keg
expr_stmt|;
if|if
condition|(
name|booted
operator|<
name|UMA_STARTUP2
condition|)
block|{
name|locked
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|sx_slock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|true
expr_stmt|;
block|}
comment|/* XXX Attaches only one keg of potentially many. */
name|res
operator|=
name|zone_alloc_item
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|sx_sunlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zcache_create
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|zinit
parameter_list|,
name|uma_fini
name|zfini
parameter_list|,
name|uma_import
name|zimport
parameter_list|,
name|uma_release
name|zrelease
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zinit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|zfini
expr_stmt|;
name|args
operator|.
name|import
operator|=
name|zimport
expr_stmt|;
name|args
operator|.
name|release
operator|=
name|zrelease
expr_stmt|;
name|args
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|zone_alloc_item
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_lock_pair
parameter_list|(
name|uma_zone_t
name|a
parameter_list|,
name|uma_zone_t
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
name|b
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|mtx_lock_flags
argument_list|(
name|b
operator|->
name|uz_lockptr
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZONE_LOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|mtx_lock_flags
argument_list|(
name|a
operator|->
name|uz_lockptr
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_unlock_pair
parameter_list|(
name|uma_zone_t
name|a
parameter_list|,
name|uma_zone_t
name|b
parameter_list|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uma_zsecond_add
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_zone_t
name|master
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|klink
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|klink
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|zone_lock_pair
argument_list|(
name|zone
argument_list|,
name|master
argument_list|)
expr_stmt|;
comment|/* 	 * zone must use vtoslab() to resolve objects and must already be 	 * a secondary. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
operator|(
name|UMA_ZONE_VTOSLAB
operator||
name|UMA_ZONE_SECONDARY
operator|)
operator|)
operator|!=
operator|(
name|UMA_ZONE_VTOSLAB
operator||
name|UMA_ZONE_SECONDARY
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The new master must also use vtoslab(). 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|!=
name|UMA_ZONE_VTOSLAB
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The underlying object must be the same size.  rsize 	 * may be different. 	 */
if|if
condition|(
name|master
operator|->
name|uz_size
operator|!=
name|zone
operator|->
name|uz_size
condition|)
block|{
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Put it at the end of the list. 	 */
name|klink
operator|->
name|kl_keg
operator|=
name|zone_first_keg
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|kl
argument_list|,
name|kl_link
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|kl
argument_list|,
name|klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|klink
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_MULTI
expr_stmt|;
name|zone
operator|->
name|uz_slab
operator|=
name|zone_fetch_slab_multi
expr_stmt|;
name|out
label|:
name|zone_unlock_pair
argument_list|(
name|zone
argument_list|,
name|master
argument_list|)
expr_stmt|;
if|if
condition|(
name|klink
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|klink
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zdestroy
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|sx_slock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|zones
argument_list|,
name|zone
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
modifier|*
name|uma_zalloc_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|lockfail
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* Enable entropy collection for RANDOM_ENABLE_UMA kernel option */
name|random_harvest_fast_uma
argument_list|(
operator|&
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
argument_list|)
argument_list|,
literal|1
argument_list|,
name|RANDOM_UMA
argument_list|)
expr_stmt|;
comment|/* This is the fast path allocation */
name|CTR4
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zalloc_arg thread %x zone %s(%p) flags %d"
argument_list|,
name|curthread
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"uma_zalloc_arg: zone \"%s\""
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_critnest
operator|==
literal|0
operator|||
name|SCHEDULER_STOPPED
argument_list|()
argument_list|,
operator|(
literal|"uma_zalloc_arg: called with spinlock or critical section held"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEMGUARD
if|if
condition|(
name|memguard_cmp_zone
argument_list|(
name|zone
argument_list|)
condition|)
block|{
name|item
operator|=
name|memguard_alloc
argument_list|(
name|zone
operator|->
name|uz_size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_init
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|uz_init
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone
operator|->
name|uz_fini
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
comment|/* This is unfortunate but should not be fatal. */
block|}
endif|#
directive|endif
comment|/* 	 * If possible, allocate from the per-CPU cache.  There are two 	 * requirements for safe access to the per-CPU cache: (1) the thread 	 * accessing the cache must not be preempted or yield during access, 	 * and (2) the thread must not migrate CPUs without switching which 	 * cache it accesses.  We rely on a critical section to prevent 	 * preemption and migration.  We release the critical section in 	 * order to acquire the zone mutex if we are unable to allocate from 	 * the current cache; when we re-acquire the critical section, we 	 * must detect and handle migration if it has occurred. 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zalloc_start
label|:
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|bucket
operator|->
name|ub_cnt
operator|--
expr_stmt|;
name|item
operator|=
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zalloc: Bucket pointer mangled."
operator|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|++
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
operator|&&
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_fails
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|uma_dbg_alloc
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|M_ZERO
condition|)
name|uma_zero_item
argument_list|(
name|item
argument_list|,
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
comment|/* 	 * We have run out of items in our alloc bucket. 	 * See if we can switch with our free bucket. 	 */
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zalloc: zone %s(%p) swapping empty with alloc"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* 	 * Discard any empty allocation bucket while we hold no locks. 	 */
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|NULL
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|,
name|udata
argument_list|)
expr_stmt|;
comment|/* Short-circuit for zones without buckets and low memory. */
if|if
condition|(
name|zone
operator|->
name|uz_count
operator|==
literal|0
operator|||
name|bucketdisable
condition|)
goto|goto
name|zalloc_item
goto|;
comment|/* 	 * Attempt to retrieve the item from the per-CPU cache has failed, so 	 * we must go back to the zone.  This requires the zone lock, so we 	 * must drop the critical section, then re-acquire it when we go back 	 * to the cache.  Since the critical section is released, we may be 	 * preempted or migrate.  As such, make sure not to maintain any 	 * thread-local state specific to the cache from prior to releasing 	 * the critical section. 	 */
name|lockfail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ZONE_TRYLOCK
argument_list|(
name|zone
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Record contention to size the buckets. */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|lockfail
operator|=
literal|1
expr_stmt|;
block|}
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 	 * Since we have locked the zone we may as well send back our stats. 	 */
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_allocs
argument_list|,
name|cache
operator|->
name|uc_allocs
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_frees
argument_list|,
name|cache
operator|->
name|uc_frees
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|=
literal|0
expr_stmt|;
comment|/* See if we lost the race to fill the cache. */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* 	 * Check the zone's cache of buckets. 	 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
argument_list|,
operator|(
literal|"uma_zalloc_arg: Returning an empty bucket."
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* We are no longer associated with this CPU. */
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* 	 * We bump the uz count when the cache size is insufficient to 	 * handle the working set. 	 */
if|if
condition|(
name|lockfail
operator|&&
name|zone
operator|->
name|uz_count
operator|<
name|BUCKET_MAX
condition|)
name|zone
operator|->
name|uz_count
operator|++
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Now lets just fill a bucket and put it on the free list.  If that 	 * works we'll restart the allocation from the beginning and it 	 * will use the just filled bucket. 	 */
name|bucket
operator|=
name|zone_alloc_bucket
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zalloc: zone %s(%p) bucket zone returned %p"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 		 * See if we lost the race or were migrated.  Cache the 		 * initialized bucket to make this less likely or claim 		 * the memory directly. 		 */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|==
name|NULL
condition|)
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* 	 * We may not be able to get a bucket so return an actual item. 	 */
name|zalloc_item
label|:
name|item
operator|=
name|zone_alloc_item
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uma_slab_t
name|keg_fetch_slab
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|reserve
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
name|reserve
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|M_USE_RESERVE
operator|)
operator|==
literal|0
condition|)
name|reserve
operator|=
name|keg
operator|->
name|uk_reserve
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Find a slab with some space.  Prefer slabs that are partially 		 * used over those that are totally full.  This helps to reduce 		 * fragmentation. 		 */
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|>
name|reserve
condition|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|)
condition|)
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
comment|/* 		 * M_NOVM means don't ask at all! 		 */
if|if
condition|(
name|flags
operator|&
name|M_NOVM
condition|)
break|break;
if|if
condition|(
name|keg
operator|->
name|uk_maxpages
operator|&&
name|keg
operator|->
name|uk_pages
operator|>=
name|keg
operator|->
name|uk_maxpages
condition|)
block|{
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
comment|/* 			 * If this is not a multi-zone, set the FULL bit. 			 * Otherwise slab_multi() takes care of it. 			 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
name|zone_log_warning
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_maxaction
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|M_NOWAIT
condition|)
break|break;
name|zone
operator|->
name|uz_sleeps
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|keg
argument_list|,
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|PVM
argument_list|,
literal|"keglimit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|slab
operator|=
name|keg_alloc_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * If we got a slab here it's safe to mark it partially used 		 * and return.  We assume that the caller is going to remove 		 * at least one item. 		 */
if|if
condition|(
name|slab
condition|)
block|{
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
comment|/* 		 * We might not have been able to get a slab but another cpu 		 * could have while we were unlocked.  Check again before we 		 * fail. 		 */
name|flags
operator||=
name|M_NOVM
expr_stmt|;
block|}
return|return
operator|(
name|slab
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uma_slab_t
name|zone_fetch_slab
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|keg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
block|{
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_NOVM
operator|)
condition|)
break|break;
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * uma_zone_fetch_slab_multi:  Fetches a slab from one available keg.  Returns  * with the keg locked.  On NULL no lock is held.  *  * The last pointer is used to seed the search.  It is not required.  */
end_comment

begin_function
specifier|static
name|uma_slab_t
name|zone_fetch_slab_multi
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|rflags
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|full
decl_stmt|;
comment|/* 	 * Don't wait on the first pass.  This will skip limit tests 	 * as well.  We don't want to block if we can find a provider 	 * without blocking. 	 */
name|flags
operator|=
operator|(
name|rflags
operator|&
operator|~
name|M_WAITOK
operator|)
operator||
name|M_NOWAIT
expr_stmt|;
comment|/* 	 * Use the last slab allocated as a hint for where to start 	 * the search. 	 */
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|last
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
name|KEG_UNLOCK
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop until we have a slab incase of transient failures 	 * while M_WAITOK is specified.  I'm not sure this is 100% 	 * required but we've done it for so long now. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Search the available kegs for slabs.  Be careful to hold the 		 * correct lock while calling into the keg layer. 		 */
name|LIST_FOREACH
argument_list|(
argument|klink
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
name|keg
operator|=
name|klink
operator|->
name|kl_keg
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
operator|==
literal|0
condition|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
name|full
operator|++
expr_stmt|;
else|else
name|empty
operator|++
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rflags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_NOVM
operator|)
condition|)
break|break;
name|flags
operator|=
name|rflags
expr_stmt|;
comment|/* 		 * All kegs are full.  XXX We can't atomically check all kegs 		 * and sleep so just sleep for a short period and retry. 		 */
if|if
condition|(
name|full
operator|&&
operator|!
name|empty
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
name|zone
operator|->
name|uz_sleeps
operator|++
expr_stmt|;
name|zone_log_warning
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_maxaction
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|uz_lockptr
argument_list|,
name|PVM
argument_list|,
literal|"zonelimit"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|slab_alloc_item
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|uint8_t
name|freei
decl_stmt|;
name|MPASS
argument_list|(
name|keg
operator|==
name|slab
operator|->
name|us_keg
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|freei
operator|=
name|BIT_FFS
argument_list|(
name|SLAB_SETSIZE
argument_list|,
operator|&
name|slab
operator|->
name|us_free
argument_list|)
operator|-
literal|1
expr_stmt|;
name|BIT_CLR
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_free
argument_list|)
expr_stmt|;
name|item
operator|=
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|freei
operator|)
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|--
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|--
expr_stmt|;
comment|/* Move this slab to the full list */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_full_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zone_import
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
modifier|*
name|bucket
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
name|keg
operator|=
name|NULL
expr_stmt|;
comment|/* Try to keep the buckets totally full */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|slab
operator|=
name|zone
operator|->
name|uz_slab
argument_list|(
name|zone
argument_list|,
name|keg
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
while|while
condition|(
name|slab
operator|->
name|us_freecount
operator|&&
name|i
operator|<
name|max
condition|)
block|{
name|bucket
index|[
name|i
operator|++
index|]
operator|=
name|slab_alloc_item
argument_list|(
name|keg
argument_list|,
name|slab
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|<=
name|keg
operator|->
name|uk_reserve
condition|)
break|break;
block|}
comment|/* Don't grab more than one slab at a time. */
name|flags
operator|&=
operator|~
name|M_WAITOK
expr_stmt|;
name|flags
operator||=
name|M_NOWAIT
expr_stmt|;
block|}
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|uma_bucket_t
name|zone_alloc_bucket
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|max
decl_stmt|;
comment|/* Don't wait for buckets, preserve caller's NOVM setting. */
name|bucket
operator|=
name|bucket_alloc
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|M_NOWAIT
operator||
operator|(
name|flags
operator|&
name|M_NOVM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|max
operator|=
name|MIN
argument_list|(
name|bucket
operator|->
name|ub_entries
argument_list|,
name|zone
operator|->
name|uz_count
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|ub_cnt
operator|=
name|zone
operator|->
name|uz_import
argument_list|(
name|zone
operator|->
name|uz_arg
argument_list|,
name|bucket
operator|->
name|ub_bucket
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the memory if necessary. 	 */
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
operator|&&
name|zone
operator|->
name|uz_init
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bucket
operator|->
name|ub_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|zone
operator|->
name|uz_init
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|i
index|]
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * If we couldn't initialize the whole bucket, put the 		 * rest back onto the freelist. 		 */
if|if
condition|(
name|i
operator|!=
name|bucket
operator|->
name|ub_cnt
condition|)
block|{
name|zone
operator|->
name|uz_release
argument_list|(
name|zone
operator|->
name|uz_arg
argument_list|,
operator|&
name|bucket
operator|->
name|ub_bucket
index|[
name|i
index|]
argument_list|,
name|bucket
operator|->
name|ub_cnt
operator|-
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
operator|&
name|bucket
operator|->
name|ub_bucket
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|bucket
operator|->
name|ub_cnt
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_cnt
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|==
literal|0
condition|)
block|{
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|,
name|udata
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_fails
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a single item from a zone.  *  * Arguments  *	zone   The zone to alloc for.  *	udata  The data to be passed to the constructor.  *	flags  M_WAITOK, M_NOWAIT, M_ZERO.  *  * Returns  *	NULL if there is no memory and M_NOWAIT is set  *	An item if successful  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zone_alloc_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_import
argument_list|(
name|zone
operator|->
name|uz_arg
argument_list|,
operator|&
name|item
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_allocs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * We have to call both the zone's init (not the keg's init) 	 * and the zone's ctor.  This is because the item is going from 	 * a keg slab directly to the user, and the user is expecting it 	 * to be both zone-init'd as well as zone-ctor'd. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_init
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_init
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_FINI
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|uma_dbg_alloc
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|M_ZERO
condition|)
name|uma_zero_item
argument_list|(
name|item
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"zone_alloc_item item %p from %s(%p)"
argument_list|,
name|item
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
name|fail
label|:
name|CTR2
argument_list|(
name|KTR_UMA
argument_list|,
literal|"zone_alloc_item failed from %s(%p)"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_fails
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zfree_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|lockfail
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* Enable entropy collection for RANDOM_ENABLE_UMA kernel option */
name|random_harvest_fast_uma
argument_list|(
operator|&
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
argument_list|)
argument_list|,
literal|1
argument_list|,
name|RANDOM_UMA
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zfree_arg thread %x zone %s"
argument_list|,
name|curthread
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_critnest
operator|==
literal|0
operator|||
name|SCHEDULER_STOPPED
argument_list|()
argument_list|,
operator|(
literal|"uma_zfree_arg: called with spinlock or critical section held"
operator|)
argument_list|)
expr_stmt|;
comment|/* uma_zfree(..., NULL) does nothing, to match free(9). */
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG_MEMGUARD
if|if
condition|(
name|is_memguard_addr
argument_list|(
name|item
argument_list|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_dtor
operator|!=
name|NULL
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_fini
operator|!=
name|NULL
condition|)
name|zone
operator|->
name|uz_fini
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|memguard_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|item
argument_list|)
expr_stmt|;
else|else
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zone
operator|->
name|uz_dtor
operator|!=
name|NULL
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
comment|/* 	 * The race here is acceptable.  If we miss it we'll just have to wait 	 * a little longer for the limits to be reset. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
goto|goto
name|zfree_item
goto|;
comment|/* 	 * If possible, free to the per-CPU cache.  There are two 	 * requirements for safe access to the per-CPU cache: (1) the thread 	 * accessing the cache must not be preempted or yield during access, 	 * and (2) the thread must not migrate CPUs without switching which 	 * cache it accesses.  We rely on a critical section to prevent 	 * preemption and migration.  We release the critical section in 	 * order to acquire the zone mutex if we are unable to free to the 	 * current cache; when we re-acquire the critical section, we must 	 * detect and handle migration if it has occurred. 	 */
name|zfree_restart
label|:
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zfree_start
label|:
comment|/* 	 * Try to free into the allocbucket first to give LIFO ordering 	 * for cache-hot datastructures.  Spill over into the freebucket 	 * if necessary.  Alloc will swap them if one runs dry. 	 */
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
operator|||
name|bucket
operator|->
name|ub_cnt
operator|>=
name|bucket
operator|->
name|ub_entries
condition|)
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|<
name|bucket
operator|->
name|ub_entries
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"uma_zfree: Freeing to non free bucket index."
operator|)
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|=
name|item
expr_stmt|;
name|bucket
operator|->
name|ub_cnt
operator|++
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|++
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * We must go back the zone, which requires acquiring the zone lock, 	 * which in turn means we must release and re-acquire the critical 	 * section.  Since the critical section is released, we may be 	 * preempted or migrate.  As such, make sure not to maintain any 	 * thread-local state specific to the cache from prior to releasing 	 * the critical section. 	 */
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_count
operator|==
literal|0
operator|||
name|bucketdisable
condition|)
goto|goto
name|zfree_item
goto|;
name|lockfail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ZONE_TRYLOCK
argument_list|(
name|zone
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Record contention to size the buckets. */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|lockfail
operator|=
literal|1
expr_stmt|;
block|}
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 	 * Since we have locked the zone we may as well send back our stats. 	 */
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_allocs
argument_list|,
name|cache
operator|->
name|uc_allocs
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_frees
argument_list|,
name|cache
operator|->
name|uc_frees
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|=
literal|0
expr_stmt|;
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|<
name|bucket
operator|->
name|ub_entries
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
comment|/* We are no longer associated with this CPU. */
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* Can we throw this on the zone full list? */
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zfree: zone %s(%p) putting bucket %p on free list"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
comment|/* ub_cnt is pointing to the last free item */
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
argument_list|,
operator|(
literal|"uma_zfree: Attempting to insert an empty bucket onto the full list.\n"
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_buckets
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We bump the uz count when the cache size is insufficient to 	 * handle the working set. 	 */
if|if
condition|(
name|lockfail
operator|&&
name|zone
operator|->
name|uz_count
operator|<
name|BUCKET_MAX
condition|)
name|zone
operator|->
name|uz_count
operator|++
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|bucket_alloc
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zfree: zone %s(%p) allocated bucket %p"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|==
name|NULL
condition|)
block|{
name|cache
operator|->
name|uc_freebucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
comment|/* 		 * We lost the race, start over.  We have to drop our 		 * critical section to free the bucket. 		 */
name|critical_exit
argument_list|()
expr_stmt|;
name|bucket_free
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|,
name|udata
argument_list|)
expr_stmt|;
goto|goto
name|zfree_restart
goto|;
block|}
comment|/* 	 * If nothing else caught this, we'll just do an internal free. 	 */
name|zfree_item
label|:
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|slab_free_item
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|uint8_t
name|freei
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|keg
operator|==
name|slab
operator|->
name|us_keg
argument_list|)
expr_stmt|;
comment|/* Do we need to remove from any lists? */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|+
literal|1
operator|==
name|keg
operator|->
name|uk_ipers
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
comment|/* Slab management. */
name|freei
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|item
operator|-
operator|(
name|uintptr_t
operator|)
name|slab
operator|->
name|us_data
operator|)
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
name|BIT_SET
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_free
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|++
expr_stmt|;
comment|/* Keg statistics. */
name|keg
operator|->
name|uk_free
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_release
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
modifier|*
name|bucket
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|uint8_t
modifier|*
name|mem
decl_stmt|;
name|int
name|clearfull
decl_stmt|;
name|int
name|i
decl_stmt|;
name|clearfull
operator|=
literal|0
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
name|bucket
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
condition|)
block|{
name|mem
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_HASH
condition|)
block|{
name|slab
operator|=
name|hash_sfind
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem
operator|+=
name|keg
operator|->
name|uk_pgoff
expr_stmt|;
name|slab
operator|=
operator|(
name|uma_slab_t
operator|)
name|mem
expr_stmt|;
block|}
block|}
else|else
block|{
name|slab
operator|=
name|vtoslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|->
name|us_keg
operator|!=
name|keg
condition|)
block|{
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
block|}
name|slab_free_item
argument_list|(
name|keg
argument_list|,
name|slab
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_pages
operator|<
name|keg
operator|->
name|uk_maxpages
condition|)
block|{
name|keg
operator|->
name|uk_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
name|clearfull
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  			 * We can handle one more allocation. Since we're 			 * clearing ZFLAG_FULL, wake up all procs blocked 			 * on pages. This should be uncommon, so keeping this 			 * simple for now (rather than adding count of blocked  			 * threads etc). 			 */
name|wakeup
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearfull
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
name|wakeup
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Frees a single item to any zone.  *  * Arguments:  *	zone   The zone to free to  *	item   The item we're freeing  *	udata  User supplied data for the dtor  *	skip   Skip dtors and finis  */
end_comment

begin_function
specifier|static
name|void
name|zone_free_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|enum
name|zfreeskip
name|skip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|skip
operator|==
name|SKIP_NONE
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|item
argument_list|)
expr_stmt|;
else|else
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|skip
operator|<
name|SKIP_DTOR
operator|&&
name|zone
operator|->
name|uz_dtor
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
name|SKIP_FINI
operator|&&
name|zone
operator|->
name|uz_fini
condition|)
name|zone
operator|->
name|uz_fini
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|zone
operator|->
name|uz_frees
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_release
argument_list|(
name|zone
operator|->
name|uz_arg
argument_list|,
operator|&
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_set_max
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|nitems
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_maxpages
operator|=
operator|(
name|nitems
operator|/
name|keg
operator|->
name|uk_ipers
operator|)
operator|*
name|keg
operator|->
name|uk_ppera
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_maxpages
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|nitems
condition|)
name|keg
operator|->
name|uk_maxpages
operator|+=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|nitems
operator|=
operator|(
name|keg
operator|->
name|uk_maxpages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|nitems
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_get_max
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|nitems
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|nitems
operator|=
operator|(
name|keg
operator|->
name|uk_maxpages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|nitems
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_warning
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|warning
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_warning
operator|=
name|warning
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_maxaction
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_maxaction_t
name|maxaction
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|zone
operator|->
name|uz_maxaction
argument_list|,
literal|0
argument_list|,
operator|(
name|task_fn_t
operator|*
operator|)
name|maxaction
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_get_cur
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int64_t
name|nitems
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|zone
operator|->
name|uz_allocs
operator|-
name|zone
operator|->
name|uz_frees
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
comment|/* 		 * See the comment in sysctl_vm_zone_stats() regarding the 		 * safety of accessing the per-cpu caches. With the zone lock 		 * held, it is safe, but can potentially result in stale data. 		 */
name|nitems
operator|+=
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
operator|.
name|uc_allocs
operator|-
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
operator|.
name|uc_frees
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|nitems
operator|<
literal|0
condition|?
literal|0
else|:
name|nitems
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_init
name|uminit
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zone_set_init: Invalid zone type"
operator|)
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_init on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_init
operator|=
name|uminit
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_fini
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_fini
name|fini
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zone_set_fini: Invalid zone type"
operator|)
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_fini on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_fini
operator|=
name|fini
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_zinit
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_init
name|zinit
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_zinit on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|zinit
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_zfini
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_fini
name|zfini
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_zfini on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|zfini
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_comment
comment|/* XXX uk_freef is not actually used with the zone locked */
end_comment

begin_function
name|void
name|uma_zone_set_freef
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_free
name|freef
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zone_set_freef: Invalid zone type"
operator|)
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_freef
operator|=
name|freef
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_comment
comment|/* XXX uk_allocf is not actually used with the zone locked */
end_comment

begin_function
name|void
name|uma_zone_set_allocf
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_alloc
name|allocf
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_allocf
operator|=
name|allocf
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_reserve
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|items
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
return|return;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_reserve
operator|=
name|items
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_reserve_kva
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|u_int
name|pages
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pages
operator|=
name|count
operator|/
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|pages
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|count
condition|)
name|pages
operator|++
expr_stmt|;
name|pages
operator|*=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
if|if
condition|(
name|keg
operator|->
name|uk_ppera
operator|>
literal|1
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|kva
operator|=
name|kva_alloc
argument_list|(
operator|(
name|vm_size_t
operator|)
name|pages
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kva
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|kva
operator|=
literal|0
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_kva
operator|=
name|kva
expr_stmt|;
name|keg
operator|->
name|uk_offset
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_maxpages
operator|=
name|pages
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
name|keg
operator|->
name|uk_allocf
operator|=
operator|(
name|keg
operator|->
name|uk_ppera
operator|>
literal|1
operator|)
condition|?
name|noobj_alloc
else|:
name|uma_small_alloc
expr_stmt|;
else|#
directive|else
name|keg
operator|->
name|uk_allocf
operator|=
name|noobj_alloc
expr_stmt|;
endif|#
directive|endif
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_NOFREE
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* See uma.h */
name|void
name|uma_prealloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|items
parameter_list|)
block|{
name|int
name|slabs
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
return|return;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|slabs
operator|=
name|items
operator|/
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|slabs
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|items
condition|)
name|slabs
operator|++
expr_stmt|;
while|while
condition|(
name|slabs
operator|>
literal|0
condition|)
block|{
name|slab
operator|=
name|keg_alloc_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
break|break;
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|slabs
operator|--
expr_stmt|;
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
specifier|static
name|void
name|uma_reclaim_locked
parameter_list|(
name|bool
name|kmem_danger
parameter_list|)
block|{
name|CTR0
argument_list|(
name|KTR_UMA
argument_list|,
literal|"UMA: vm asked us to release pages!"
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|uma_drain_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_drain
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_count_min
argument_list|()
operator|||
name|kmem_danger
condition|)
block|{
name|cache_drain_safe
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_drain
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some slabs may have been freed but this zone will be visited early 	 * we visit again so that we can free pages that are empty once other 	 * zones are drained.  We have to do the same for buckets. 	 */
name|zone_drain
argument_list|(
name|slabzone
argument_list|)
expr_stmt|;
name|bucket_zone_drain
argument_list|()
expr_stmt|;
block|}
name|void
name|uma_reclaim
parameter_list|(
name|void
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|uma_reclaim_locked
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|uma_reclaim_needed
decl_stmt|;
name|void
name|uma_reclaim_wakeup
parameter_list|(
name|void
parameter_list|)
block|{
name|uma_reclaim_needed
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|uma_reclaim_needed
argument_list|)
expr_stmt|;
block|}
name|void
name|uma_reclaim_worker
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sx_sleep
argument_list|(
operator|&
name|uma_reclaim_needed
argument_list|,
operator|&
name|uma_drain_lock
argument_list|,
name|PVM
argument_list|,
literal|"umarcl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|uma_reclaim_needed
condition|)
block|{
name|uma_reclaim_needed
operator|=
literal|0
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|vm_lowmem
argument_list|,
name|VM_LOW_KMEM
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|uma_drain_lock
argument_list|)
expr_stmt|;
name|uma_reclaim_locked
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* See uma.h */
name|int
name|uma_zone_exhausted
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|full
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|full
operator|=
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|full
operator|)
return|;
block|}
name|int
name|uma_zone_exhausted_nolock
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
return|return
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
return|;
block|}
name|void
modifier|*
name|uma_large_malloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|slab
operator|=
name|zone_alloc_item
argument_list|(
name|slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mem
operator|=
name|page_alloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|vsetslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
operator||
name|UMA_SLAB_MALLOC
expr_stmt|;
name|slab
operator|->
name|us_size
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|zone_free_item
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mem
operator|)
return|;
block|}
name|void
name|uma_large_free
parameter_list|(
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|page_free
argument_list|(
name|slab
operator|->
name|us_data
argument_list|,
name|slab
operator|->
name|us_size
argument_list|,
name|slab
operator|->
name|us_flags
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|uma_zero_item
parameter_list|(
name|void
modifier|*
name|item
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_PCPU
condition|)
block|{
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
name|bzero
argument_list|(
name|zpcpu_get_cpu
argument_list|(
name|item
argument_list|,
name|i
argument_list|)
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
block|}
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|zone_foreach
argument_list|(
name|uma_print_zone
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|slab_print
parameter_list|(
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|printf
argument_list|(
literal|"slab: keg %p, data %p, freecount %d\n"
argument_list|,
name|slab
operator|->
name|us_keg
argument_list|,
name|slab
operator|->
name|us_data
argument_list|,
name|slab
operator|->
name|us_freecount
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|cache_print
parameter_list|(
name|uma_cache_t
name|cache
parameter_list|)
block|{
name|printf
argument_list|(
literal|"alloc: %p(%d), free: %p(%d)\n"
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|cache
operator|->
name|uc_allocbucket
condition|?
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
else|:
literal|0
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|,
name|cache
operator|->
name|uc_freebucket
condition|?
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|uma_print_keg
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|printf
argument_list|(
literal|"keg: %s(%p) size %d(%d) flags %#x ipers %d ppera %d "
literal|"out %d free %d limit %d\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|,
name|keg
operator|->
name|uk_rsize
argument_list|,
name|keg
operator|->
name|uk_flags
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|keg
operator|->
name|uk_ppera
argument_list|,
operator|(
name|keg
operator|->
name|uk_pages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
operator|-
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|,
operator|(
name|keg
operator|->
name|uk_maxpages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Part slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_part_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Free slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_free_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Full slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_full_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
block|}
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"zone: %s(%p) size %d flags %#x\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|zone
operator|->
name|uz_flags
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
name|uma_print_keg
argument_list|(
name|kl
operator|->
name|kl_keg
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"CPU %d Cache:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cache_print
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DDB
comment|/*  * Generate statistics across both the zone and its per-cpu cache's.  Return  * desired statistics if the pointer is non-NULL for that statistic.  *  * Note: does not update the zone statistics, as it can't safely clear the  * per-CPU cache statistic.  *  * XXXRW: Following the uc_allocbucket and uc_freebucket pointers here isn't  * safe from off-CPU; we should modify the caches to track this information  * directly so that we don't have to.  */
specifier|static
name|void
name|uma_zone_sumstat
parameter_list|(
name|uma_zone_t
name|z
parameter_list|,
name|int
modifier|*
name|cachefreep
parameter_list|,
name|uint64_t
modifier|*
name|allocsp
parameter_list|,
name|uint64_t
modifier|*
name|freesp
parameter_list|,
name|uint64_t
modifier|*
name|sleepsp
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uint64_t
name|allocs
decl_stmt|,
name|frees
decl_stmt|,
name|sleeps
decl_stmt|;
name|int
name|cachefree
decl_stmt|,
name|cpu
decl_stmt|;
name|allocs
operator|=
name|frees
operator|=
name|sleeps
operator|=
literal|0
expr_stmt|;
name|cachefree
operator|=
literal|0
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|cache
operator|=
operator|&
name|z
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|cachefree
operator|+=
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|cachefree
operator|+=
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
expr_stmt|;
name|allocs
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|frees
operator|+=
name|cache
operator|->
name|uc_frees
expr_stmt|;
block|}
name|allocs
operator|+=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|frees
operator|+=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|sleeps
operator|+=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
if|if
condition|(
name|cachefreep
operator|!=
name|NULL
condition|)
operator|*
name|cachefreep
operator|=
name|cachefree
expr_stmt|;
if|if
condition|(
name|allocsp
operator|!=
name|NULL
condition|)
operator|*
name|allocsp
operator|=
name|allocs
expr_stmt|;
if|if
condition|(
name|freesp
operator|!=
name|NULL
condition|)
operator|*
name|freesp
operator|=
name|frees
expr_stmt|;
if|if
condition|(
name|sleepsp
operator|!=
name|NULL
condition|)
operator|*
name|sleepsp
operator|=
name|sleeps
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DDB */
specifier|static
name|int
name|sysctl_vm_zone_count
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|count
operator|++
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|sysctl_vm_zone_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|uma_stream_header
name|ush
decl_stmt|;
name|struct
name|uma_type_header
name|uth
decl_stmt|;
name|struct
name|uma_percpu_stat
name|ups
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|uma_keg_t
name|k
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_clear_flags
argument_list|(
operator|&
name|sbuf
argument_list|,
name|SBUF_INCLUDENUL
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* 	 * Insert stream header. 	 */
name|bzero
argument_list|(
operator|&
name|ush
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
name|ush
operator|.
name|ush_version
operator|=
name|UMA_STREAM_VERSION
expr_stmt|;
name|ush
operator|.
name|ush_maxcpus
operator|=
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
expr_stmt|;
name|ush
operator|.
name|ush_count
operator|=
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|ush
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
name|bzero
argument_list|(
operator|&
name|uth
argument_list|,
sizeof|sizeof
argument_list|(
name|uth
argument_list|)
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uth
operator|.
name|uth_name
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
name|UTH_MAX_NAME
argument_list|)
expr_stmt|;
name|uth
operator|.
name|uth_align
operator|=
name|kz
operator|->
name|uk_align
expr_stmt|;
name|uth
operator|.
name|uth_size
operator|=
name|kz
operator|->
name|uk_size
expr_stmt|;
name|uth
operator|.
name|uth_rsize
operator|=
name|kz
operator|->
name|uk_rsize
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&z->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
name|k
operator|=
name|kl
operator|->
name|kl_keg
expr_stmt|;
name|uth
operator|.
name|uth_maxpages
operator|+=
name|k
operator|->
name|uk_maxpages
expr_stmt|;
name|uth
operator|.
name|uth_pages
operator|+=
name|k
operator|->
name|uk_pages
expr_stmt|;
name|uth
operator|.
name|uth_keg_free
operator|+=
name|k
operator|->
name|uk_free
expr_stmt|;
name|uth
operator|.
name|uth_limit
operator|=
operator|(
name|k
operator|->
name|uk_maxpages
operator|/
name|k
operator|->
name|uk_ppera
operator|)
operator|*
name|k
operator|->
name|uk_ipers
expr_stmt|;
block|}
comment|/* 			 * A zone is secondary is it is not the first entry 			 * on the keg's zone list. 			 */
if|if
condition|(
operator|(
name|z
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|->
name|uk_zones
argument_list|)
operator|!=
name|z
operator|)
condition|)
name|uth
operator|.
name|uth_zone_flags
operator|=
name|UTH_ZONE_SECONDARY
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bucket
argument_list|,
argument|&z->uz_buckets
argument_list|,
argument|ub_link
argument_list|)
name|uth
operator|.
name|uth_zone_free
operator|+=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|uth
operator|.
name|uth_allocs
operator|=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|uth
operator|.
name|uth_frees
operator|=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|uth
operator|.
name|uth_fails
operator|=
name|z
operator|->
name|uz_fails
expr_stmt|;
name|uth
operator|.
name|uth_sleeps
operator|=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|uth
argument_list|,
sizeof|sizeof
argument_list|(
name|uth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * While it is not normally safe to access the cache 			 * bucket pointers while not on the CPU that owns the 			 * cache, we only allow the pointers to be exchanged 			 * without the zone lock held, not invalidated, so 			 * accept the possible race associated with bucket 			 * exchange during monitoring. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|ups
argument_list|,
sizeof|sizeof
argument_list|(
name|ups
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kz
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|cache
operator|=
operator|&
name|z
operator|->
name|uz_cpu
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|ups
operator|.
name|ups_cache_free
operator|+=
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|ups
operator|.
name|ups_cache_free
operator|+=
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
expr_stmt|;
name|ups
operator|.
name|ups_allocs
operator|=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|ups
operator|.
name|ups_frees
operator|=
name|cache
operator|->
name|uc_frees
expr_stmt|;
name|skip
label|:
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|ups
argument_list|,
sizeof|sizeof
argument_list|(
name|ups
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_runlock
argument_list|(
operator|&
name|uma_rwlock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|sysctl_handle_uma_zone_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uma_zone_t
name|zone
init|=
operator|*
operator|(
name|uma_zone_t
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
name|uma_zone_get_max
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|max
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uma_zone_set_max
argument_list|(
name|zone
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|sysctl_handle_uma_zone_cur
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uma_zone_t
name|zone
init|=
operator|*
operator|(
name|uma_zone_t
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|cur
operator|=
name|uma_zone_get_cur
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|cur
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|static
name|uma_slab_t
name|uma_dbg_getslab
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|uint8_t
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_VTOSLAB
condition|)
block|{
name|slab
operator|=
name|vtoslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It is safe to return the slab here even though the 		 * zone is unlocked because the item's allocation state 		 * essentially holds a reference. 		 */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|)
operator|->
name|kl_keg
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|slab
operator|=
name|hash_sfind
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|else
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
name|mem
operator|+
name|keg
operator|->
name|uk_pgoff
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|slab
operator|)
return|;
block|}
comment|/*  * Set up the slab's freei data such that uma_dbg_free can function.  *  */
specifier|static
name|void
name|uma_dbg_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|freei
decl_stmt|;
if|if
condition|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|slab
operator|=
name|uma_dbg_getslab
argument_list|(
name|zone
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uma: item %p did not belong to zone %s\n"
argument_list|,
name|item
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
block|}
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
name|freei
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|item
operator|-
operator|(
name|uintptr_t
operator|)
name|slab
operator|->
name|us_data
operator|)
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_debugfree
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Duplicate alloc of %p from zone %p(%s) slab %p(%d)\n"
argument_list|,
name|item
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|)
expr_stmt|;
name|BIT_SET_ATOMIC
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_debugfree
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Verifies freed addresses.  Checks for alignment, valid slab membership  * and duplicate frees.  *  */
specifier|static
name|void
name|uma_dbg_free
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|freei
decl_stmt|;
if|if
condition|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|slab
operator|=
name|uma_dbg_getslab
argument_list|(
name|zone
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uma: Freed item %p did not belong to zone %s\n"
argument_list|,
name|item
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
block|}
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
name|freei
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|item
operator|-
operator|(
name|uintptr_t
operator|)
name|slab
operator|->
name|us_data
operator|)
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
if|if
condition|(
name|freei
operator|>=
name|keg
operator|->
name|uk_ipers
condition|)
name|panic
argument_list|(
literal|"Invalid free of %p from zone %p(%s) slab %p(%d)\n"
argument_list|,
name|item
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|freei
operator|*
name|keg
operator|->
name|uk_rsize
operator|)
operator|+
name|slab
operator|->
name|us_data
operator|)
operator|!=
name|item
condition|)
name|panic
argument_list|(
literal|"Unaligned free of %p from zone %p(%s) slab %p(%d)\n"
argument_list|,
name|item
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BIT_ISSET
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_debugfree
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Duplicate free of %p from zone %p(%s) slab %p(%d)\n"
argument_list|,
name|item
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|)
expr_stmt|;
name|BIT_CLR_ATOMIC
argument_list|(
name|SLAB_SETSIZE
argument_list|,
name|freei
argument_list|,
operator|&
name|slab
operator|->
name|us_debugfree
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INVARIANTS */
ifdef|#
directive|ifdef
name|DDB
name|DB_SHOW_COMMAND
argument_list|(
argument|uma
argument_list|,
argument|db_show_uma
argument_list|)
block|{
name|uint64_t
name|allocs
decl_stmt|,
name|frees
decl_stmt|,
name|sleeps
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|int
name|cachefree
decl_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8s %8s %8s %12s %8s %8s\n"
argument_list|,
literal|"Zone"
argument_list|,
literal|"Size"
argument_list|,
literal|"Used"
argument_list|,
literal|"Free"
argument_list|,
literal|"Requests"
argument_list|,
literal|"Sleeps"
argument_list|,
literal|"Bucket"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
if|if
condition|(
name|kz
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
block|{
name|allocs
operator|=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|frees
operator|=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|sleeps
operator|=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
name|cachefree
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|uma_zone_sumstat
argument_list|(
name|z
argument_list|,
operator|&
name|cachefree
argument_list|,
operator|&
name|allocs
argument_list|,
operator|&
name|frees
argument_list|,
operator|&
name|sleeps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|z
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|->
name|uk_zones
argument_list|)
operator|!=
name|z
operator|)
operator|)
condition|)
name|cachefree
operator|+=
name|kz
operator|->
name|uk_free
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bucket
argument_list|,
argument|&z->uz_buckets
argument_list|,
argument|ub_link
argument_list|)
name|cachefree
operator|+=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8ju %8jd %8d %12ju %8ju %8u\n"
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|kz
operator|->
name|uk_size
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|allocs
operator|-
name|frees
argument_list|)
argument_list|,
name|cachefree
argument_list|,
operator|(
name|uintmax_t
operator|)
name|allocs
argument_list|,
name|sleeps
argument_list|,
name|z
operator|->
name|uz_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
block|}
block|}
block|}
name|DB_SHOW_COMMAND
argument_list|(
argument|umacache
argument_list|,
argument|db_show_umacache
argument_list|)
block|{
name|uint64_t
name|allocs
decl_stmt|,
name|frees
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|int
name|cachefree
decl_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8s %8s %8s %12s %8s\n"
argument_list|,
literal|"Zone"
argument_list|,
literal|"Size"
argument_list|,
literal|"Used"
argument_list|,
literal|"Free"
argument_list|,
literal|"Requests"
argument_list|,
literal|"Bucket"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&uma_cachezones
argument_list|,
argument|uz_link
argument_list|)
block|{
name|uma_zone_sumstat
argument_list|(
name|z
argument_list|,
operator|&
name|cachefree
argument_list|,
operator|&
name|allocs
argument_list|,
operator|&
name|frees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bucket
argument_list|,
argument|&z->uz_buckets
argument_list|,
argument|ub_link
argument_list|)
name|cachefree
operator|+=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8ju %8jd %8d %12ju %8u\n"
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|z
operator|->
name|uz_size
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|allocs
operator|-
name|frees
argument_list|)
argument_list|,
name|cachefree
argument_list|,
operator|(
name|uintmax_t
operator|)
name|allocs
argument_list|,
name|z
operator|->
name|uz_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

