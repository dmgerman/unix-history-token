begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002, Jeffrey Roberson<jroberson@chesapeake.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * uma_core.c  Implementation of the Universal Memory allocator  *  * This allocator is intended to replace the multitude of similar object caches  * in the standard FreeBSD kernel.  The intent is to be flexible as well as  * effecient.  A primary design goal is to return unused memory to the rest of  * the system.  This will make the system as a whole more flexible due to the   * ability to move memory to subsystems which most need it instead of leaving  * pools of reserved memory unused.  *  * The basic ideas stem from similar slab/zone based allocators whose algorithms  * are well known.  *  */
end_comment

begin_comment
comment|/*  * TODO:  *	- Improve memory usage for large allocations  *	- Improve INVARIANTS (0xdeadc0de write out)  *	- Investigate cache size adjustments  */
end_comment

begin_comment
comment|/* I should really use ktr.. */
end_comment

begin_comment
comment|/* #define UMA_DEBUG 1 #define UMA_DEBUG_ALLOC 1 #define UMA_DEBUG_ALLOC_1 1 */
end_comment

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<machine/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_comment
comment|/*  * This is the zone from which all zones are spawned.  The idea is that even   * the zone heads are allocated from the allocator, so we use the bss section  * to bootstrap us.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uma_zone
name|masterzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|zones
init|=
operator|&
name|masterzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the zone from which all of uma_slab_t's are allocated. */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|slabzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The initial hash tables come out of this zone so they can be allocated  * prior to malloc coming up.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|hashzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Zone that buckets come from.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|bucketzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Are we allowed to allocate buckets?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bucketdisable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all zones in the system */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_zone
argument_list|)
name|uma_zones
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|uma_zones
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This mutex protects the zone list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|uma_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of boot time pages */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_slab
argument_list|)
name|uma_boot_pages
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|uma_boot_pages
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Count of free boottime pages */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uma_boot_free
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is the VM done starting up? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|booted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the handle used to schedule our working set calculator */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|uma_callout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is mp_maxid + 1, for use while looping over each cpu */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure is passed as the zone ctor arg so that I don't have to create  * a special allocation function just for zones.  */
end_comment

begin_struct
struct|struct
name|uma_zctor_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|uma_ctor
name|ctor
decl_stmt|;
name|uma_dtor
name|dtor
decl_stmt|;
name|uma_init
name|uminit
decl_stmt|;
name|uma_fini
name|fini
decl_stmt|;
name|int
name|align
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is the malloc hash table which is used to find the zone that a  * malloc allocation came from.  It is not currently resizeable.  The  * memory for the actual hash bucket is allocated in kmeminit.  */
end_comment

begin_decl_stmt
name|struct
name|uma_hash
name|mhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uma_hash
modifier|*
name|mallochash
init|=
operator|&
name|mhash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes.. */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|obj_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|slab_zalloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
parameter_list|,
name|uma_bucket_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_drain
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_init
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_small_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_large_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|uma_zalloc_internal
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uma_bucket_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_zfree_internal
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vm_zone
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_OID
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone
argument_list|,
literal|"A"
argument_list|,
literal|"Zone Info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|uma_startup3
argument_list|,
name|SI_SUB_VM_CONF
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|uma_startup3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine checks to see whether or not it's safe to enable buckets.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_min
condition|)
name|bucketdisable
operator|=
literal|1
expr_stmt|;
else|else
name|bucketdisable
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine called by timeout which is used to fire off some time interval  * based calculations.  (working set, stats, etc.)  *  * Arguments:  *	arg   Unused  *   * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_timeout
argument_list|)
expr_stmt|;
comment|/* Reschedule this event */
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_WORKING_TIME
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to perform timeout driven calculations.  This does the working set  * as well as hash expanding, and per cpu statistics aggregation.  *  *  Arguments:  *	zone  The zone to operate on  *  *  Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|u_int64_t
name|alloc
decl_stmt|;
name|int
name|free
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|alloc
operator|=
literal|0
expr_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Aggregate per cpu cache statistics back to the zone. 	 * 	 * I may rewrite this to set a flag in the per cpu cache instead of 	 * locking.  If the flag is not cleared on the next round I will have 	 * to lock and do it here instead so that the statistics don't get too 	 * far out of sync. 	 */
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
block|{
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|maxcpu
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|CPU_LOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* Add them up, and reset */
name|alloc
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
name|free
operator|+=
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_ptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
condition|)
name|free
operator|+=
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_ptr
operator|+
literal|1
expr_stmt|;
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now push these stats back into the zone.. */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_allocs
operator|+=
name|alloc
expr_stmt|;
comment|/* 	 * cachefree is an instantanious snapshot of what is in the per cpu 	 * caches, not an accurate counter 	 */
name|zone
operator|->
name|uz_cachefree
operator|=
name|free
expr_stmt|;
comment|/* 	 * Expand the zone hash table. 	 *  	 * This is done if the number of slabs is larger than the hash size. 	 * What I'm trying to do here is completely reduce collisions.  This 	 * may be a little aggressive.  Should I allow for two collisions max? 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
operator|)
operator|&&
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
operator|)
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_pages
operator|/
name|zone
operator|->
name|uz_ppera
operator|>=
name|zone
operator|->
name|uz_hash
operator|.
name|uh_hashsize
condition|)
name|hash_expand
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here we compute the working set size as the total number of items  	 * left outstanding since the last time interval.  This is slightly 	 * suboptimal. What we really want is the highest number of outstanding 	 * items during the last time quantum.  This should be close enough. 	 * 	 * The working set size is used to throttle the zone_drain function. 	 * We don't want to return memory that we may need again immediately. 	 */
name|alloc
operator|=
name|zone
operator|->
name|uz_allocs
operator|-
name|zone
operator|->
name|uz_oallocs
expr_stmt|;
name|zone
operator|->
name|uz_oallocs
operator|=
name|zone
operator|->
name|uz_allocs
expr_stmt|;
name|zone
operator|->
name|uz_wssize
operator|=
name|alloc
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expands the hash table for OFFPAGE zones.  This is done from zone_timeout  * to reduce collisions.  This must not be done in the regular allocation path,  * otherwise, we can recurse on the vm while allocating pages.  *  * Arguments:  *	hash  The hash you want to expand by a factor of two.  *  * Returns:  * 	Nothing  *  * Discussion:  */
end_comment

begin_function
specifier|static
name|void
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|slabhead
modifier|*
name|newhash
decl_stmt|;
name|struct
name|slabhead
modifier|*
name|oldhash
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|oldsize
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|int
name|hval
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Remember the old hash size and see if it has to go back to the  	 * hash zone, or malloc.  The hash zone is used for the initial hash 	 */
name|oldsize
operator|=
name|hash
operator|->
name|uh_hashsize
expr_stmt|;
name|oldhash
operator|=
name|hash
operator|->
name|uh_slab_hash
expr_stmt|;
comment|/* We're just going to go to a power of two greater */
if|if
condition|(
name|hash
operator|->
name|uh_hashsize
condition|)
block|{
name|newsize
operator|=
name|oldsize
operator|*
literal|2
expr_stmt|;
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|newsize
expr_stmt|;
comment|/* XXX Shouldn't be abusing DEVBUF here */
name|newhash
operator|=
operator|(
expr|struct
name|slabhead
operator|*
operator|)
name|malloc
argument_list|(
name|alloc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhash
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
expr_stmt|;
name|newhash
operator|=
name|uma_zalloc_internal
argument_list|(
name|hashzone
argument_list|,
name|NULL
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|UMA_HASH_SIZE_INIT
expr_stmt|;
block|}
name|bzero
argument_list|(
name|newhash
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_hashmask
operator|=
name|newsize
operator|-
literal|1
expr_stmt|;
comment|/* 	 * I need to investigate hash algorithms for resizing without a 	 * full rehash. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
control|)
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|hash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slab
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|hash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|hash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
name|hval
operator|=
name|UMA_HASH
argument_list|(
name|hash
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|newhash
index|[
name|hval
index|]
argument_list|,
name|slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldhash
condition|)
name|hash_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
name|newhash
expr_stmt|;
name|hash
operator|->
name|uh_hashsize
operator|=
name|newsize
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
if|if
condition|(
name|hash
operator|->
name|uh_hashsize
operator|==
name|UMA_HASH_SIZE_INIT
condition|)
name|uma_zfree_internal
argument_list|(
name|hashzone
argument_list|,
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Frees all outstanding items in a bucket  *  * Arguments:  *	zone   The zone to free to, must be unlocked.  *	bucket The free/alloc bucket with items, cpu queue must be locked.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_bucket_t
name|bucket
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|mzone
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return;
name|slab
operator|=
name|NULL
expr_stmt|;
name|mzone
operator|=
literal|0
expr_stmt|;
comment|/* We have to lookup the slab again for malloc.. */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
condition|)
name|mzone
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|bucket
operator|->
name|ub_ptr
operator|>
operator|-
literal|1
condition|)
block|{
name|item
operator|=
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bucket_drain: botched ptr, item is NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_ptr
operator|--
expr_stmt|;
comment|/*  		 * This is extremely inefficient.  The slab pointer was passed 		 * to uma_zfree_arg, but we lost it because the buckets don't 		 * hold them.  This will go away when free() gets a size passed 		 * to it. 		 */
if|if
condition|(
name|mzone
condition|)
name|slab
operator|=
name|hash_sfind
argument_list|(
name|mallochash
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree_internal
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|slab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drains the per cpu caches for a zone.  *  * Arguments:  *	zone  The zone to drain, must be unlocked.  *  * Returns:  *	Nothing  *  * This function returns with the zone locked so that the per cpu queues can  * not be filled until zone_drain is finished.  *  */
end_comment

begin_function
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_bucket_t
name|bucket
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* 	 * Flush out the per cpu queues. 	 * 	 * XXX This causes unnecessary thrashing due to immediately having 	 * empty per cpu queues.  I need to improve this. 	 */
comment|/* 	 * We have to lock each cpu cache before locking the zone 	 */
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|maxcpu
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|CPU_LOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Drain the bucket queues and free the buckets, we just keep two per 	 * cpu (alloc/free). 	 */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|uma_zfree_internal
argument_list|(
name|bucketzone
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* Now we do the free queue.. */
while|while
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|uma_zfree_internal
argument_list|(
name|bucketzone
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We unlock here, but they will all block until the zone is unlocked */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|maxcpu
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|uz_cachefree
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Frees pages from a zone back to the system.  This is done on demand from  * the pageout daemon.  *  * Arguments:  *	zone  The zone to free pages from  *	all   Should we drain all items?  *  * Returns:  *	Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|zone_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_slab_t
name|n
decl_stmt|;
name|u_int64_t
name|extra
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We don't want to take pages from staticly allocated zones at this 	 * time 	 */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_NOFREE
operator|||
name|zone
operator|->
name|uz_freef
operator|==
name|NULL
condition|)
return|return;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
name|cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_free
operator|<
name|zone
operator|->
name|uz_wssize
condition|)
goto|goto
name|finished
goto|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"%s working set size: %llu free items: %u\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|zone
operator|->
name|uz_wssize
argument_list|,
name|zone
operator|->
name|uz_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|extra
operator|=
name|zone
operator|->
name|uz_free
operator|-
name|zone
operator|->
name|uz_wssize
expr_stmt|;
name|extra
operator|/=
name|zone
operator|->
name|uz_ipers
expr_stmt|;
comment|/* extra is now the number of extra slabs that we can free */
if|if
condition|(
name|extra
operator|==
literal|0
condition|)
goto|goto
name|finished
goto|;
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_slab
argument_list|)
expr_stmt|;
while|while
condition|(
name|slab
operator|&&
name|extra
condition|)
block|{
name|n
operator|=
name|LIST_NEXT
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
comment|/* We have no where to free these to */
if|if
condition|(
name|slab
operator|->
name|us_flags
operator|&
name|UMA_SLAB_BOOT
condition|)
block|{
name|slab
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_pages
operator|-=
name|zone
operator|->
name|uz_ppera
expr_stmt|;
name|zone
operator|->
name|uz_free
operator|-=
name|zone
operator|->
name|uz_ipers
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_fini
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|uz_ipers
condition|;
name|i
operator|++
control|)
name|zone
operator|->
name|uz_fini
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|zone
operator|->
name|uz_rsize
operator|*
name|i
operator|)
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|flags
operator|=
name|slab
operator|->
name|us_flags
expr_stmt|;
name|mem
operator|=
name|slab
operator|->
name|us_data
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
condition|)
block|{
name|UMA_HASH_REMOVE
argument_list|(
name|mallochash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UMA_HASH_REMOVE
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
block|}
name|uma_zfree_internal
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
condition|)
name|UMA_HASH_REMOVE
argument_list|(
name|mallochash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"%s: Returning %d bytes.\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|UMA_SLAB_SIZE
operator|*
name|zone
operator|->
name|uz_ppera
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zone
operator|->
name|uz_freef
argument_list|(
name|mem
argument_list|,
name|UMA_SLAB_SIZE
operator|*
name|zone
operator|->
name|uz_ppera
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|slab
operator|=
name|n
expr_stmt|;
name|extra
operator|--
expr_stmt|;
block|}
name|finished
label|:
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new slab for a zone.  This does not insert the slab onto a list.  *  * Arguments:  *	zone  The zone to allocate slabs for  *	wait  Shall we wait?  *  * Returns:  *	The slab that was allocated or NULL if there is no memory and the  *	caller specified M_NOWAIT.  *	  */
end_comment

begin_function
specifier|static
name|uma_slab_t
name|slab_zalloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
comment|/* Starting slab */
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"slab_zalloc:  Allocating a new slab for %s\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
condition|)
block|{
name|slab
operator|=
name|uma_zalloc_internal
argument_list|(
name|slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|booted
operator|||
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_PRIVALLOC
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mem
operator|=
name|zone
operator|->
name|uz_allocf
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|uz_ppera
operator|*
name|UMA_SLAB_SIZE
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|uma_slab_t
name|tmps
decl_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_ppera
operator|>
literal|1
condition|)
name|panic
argument_list|(
literal|"UMA: Attemping to allocate multiple pages before vm has started.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
condition|)
name|panic
argument_list|(
literal|"Mallocing before uma_startup2 has been called.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uma_boot_free
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"UMA: Ran out of pre init pages, increase UMA_BOOT_PAGES\n"
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uma_boot_pages
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|tmps
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|uma_boot_free
operator|--
expr_stmt|;
name|mem
operator|=
name|tmps
operator|->
name|us_data
expr_stmt|;
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Alloc slab structure for offpage, otherwise adjust it's position */
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
operator|)
condition|)
block|{
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
name|mem
operator|+
name|zone
operator|->
name|uz_pgoff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
operator|)
condition|)
name|UMA_HASH_INSERT
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|,
name|slab
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Inserting %p into malloc hash from slab %p\n"
argument_list|,
name|mem
argument_list|,
name|slab
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX Yikes! No lock on the malloc hash! */
name|UMA_HASH_INSERT
argument_list|(
name|mallochash
argument_list|,
name|slab
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|slab
operator|->
name|us_zone
operator|=
name|zone
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
comment|/* 	 * This is intended to spread data out across cache lines. 	 * 	 * This code doesn't seem to work properly on x86, and on alpha 	 * it makes absolutely no performance difference. I'm sure it could 	 * use some tuning, but sun makes outrageous claims about it's 	 * performance. 	 */
if|#
directive|if
literal|0
block|if (zone->uz_cachemax) { 		slab->us_data += zone->uz_cacheoff; 		zone->uz_cacheoff += UMA_CACHE_INC; 		if (zone->uz_cacheoff> zone->uz_cachemax) 			zone->uz_cacheoff = 0; 	}
endif|#
directive|endif
name|slab
operator|->
name|us_freecount
operator|=
name|zone
operator|->
name|uz_ipers
expr_stmt|;
name|slab
operator|->
name|us_firstfree
operator|=
literal|0
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|uz_ipers
condition|;
name|i
operator|++
control|)
name|slab
operator|->
name|us_freelist
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_init
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zone
operator|->
name|uz_ipers
condition|;
name|i
operator|++
control|)
name|zone
operator|->
name|uz_init
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|zone
operator|->
name|uz_rsize
operator|*
name|i
operator|)
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_pages
operator|+=
name|zone
operator|->
name|uz_ppera
expr_stmt|;
name|zone
operator|->
name|uz_free
operator|+=
name|zone
operator|->
name|uz_ipers
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from the system  *  * Arguments:  *	zone  Unused  *	bytes  The number of bytes requested  *	wait  Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly   *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Returned page */
comment|/* 	 * XXX The original zone allocator did this, but I don't think it's 	 * necessary in current. 	 */
if|if
condition|(
name|lockstatus
argument_list|(
operator|&
name|kernel_map
operator|->
name|lock
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|*
name|pflag
operator|=
name|UMA_SLAB_KMEM
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kmem_map
argument_list|,
name|bytes
argument_list|,
name|wait
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pflag
operator|=
name|UMA_SLAB_KMAP
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from within an object  *  * Arguments:  *	zone   Unused  *	bytes  The number of bytes requested  *	wait   Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly   *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|obj_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|flags
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|vm_offset_t
name|zkva
decl_stmt|;
name|vm_offset_t
name|retkva
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|retkva
operator|=
name|NULL
expr_stmt|;
name|pages
operator|=
name|zone
operator|->
name|uz_pages
expr_stmt|;
comment|/*  	 * This looks a little weird since we're getting one page at a time 	 */
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|zone
operator|->
name|uz_obj
argument_list|,
name|pages
argument_list|,
name|VM_ALLOC_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zkva
operator|=
name|zone
operator|->
name|uz_kva
operator|+
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|retkva
operator|==
name|NULL
condition|)
name|retkva
operator|=
name|zkva
expr_stmt|;
name|pmap_qenter
argument_list|(
name|zkva
argument_list|,
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|pages
operator|+=
literal|1
expr_stmt|;
block|}
operator|*
name|flags
operator|=
name|UMA_SLAB_PRIV
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|retkva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees a number of pages to the system  *   * Arguments:  *	mem   A pointer to the memory to be freed  *	size  The size of the memory being freed  *	flags The original p->us_flags field  *  * Returns:  *	Nothing  *  */
end_comment

begin_function
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|u_int8_t
name|flags
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMEM
condition|)
name|map
operator|=
name|kmem_map
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMAP
condition|)
name|map
operator|=
name|kernel_map
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"UMA: page_free used with invalid flags %d\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero fill initializer  *  * Arguments/Returns follow uma_init specifications  *  */
end_comment

begin_function
specifier|static
name|void
name|zero_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bzero
argument_list|(
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Finish creating a small uma zone.  This calculates ipers, and the zone size.  *  * Arguments  *	zone  The zone we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_small_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|;
name|int
name|memused
decl_stmt|;
name|int
name|ipers
decl_stmt|;
name|rsize
operator|=
name|zone
operator|->
name|uz_size
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|UMA_SMALLEST_UNIT
condition|)
name|rsize
operator|=
name|UMA_SMALLEST_UNIT
expr_stmt|;
if|if
condition|(
name|rsize
operator|&
name|zone
operator|->
name|uz_align
condition|)
name|rsize
operator|=
operator|(
name|rsize
operator|&
operator|~
name|zone
operator|->
name|uz_align
operator|)
operator|+
operator|(
name|zone
operator|->
name|uz_align
operator|+
literal|1
operator|)
expr_stmt|;
name|zone
operator|->
name|uz_rsize
operator|=
name|rsize
expr_stmt|;
name|rsize
operator|+=
literal|1
expr_stmt|;
comment|/* Account for the byte of linkage */
name|zone
operator|->
name|uz_ipers
operator|=
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|)
operator|/
name|rsize
expr_stmt|;
name|zone
operator|->
name|uz_ppera
operator|=
literal|1
expr_stmt|;
name|memused
operator|=
name|zone
operator|->
name|uz_ipers
operator|*
name|zone
operator|->
name|uz_rsize
expr_stmt|;
comment|/* Can we do any better? */
if|if
condition|(
operator|(
name|UMA_SLAB_SIZE
operator|-
name|memused
operator|)
operator|>=
name|UMA_MAX_WASTE
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
return|return;
name|ipers
operator|=
name|UMA_SLAB_SIZE
operator|/
name|zone
operator|->
name|uz_rsize
expr_stmt|;
if|if
condition|(
name|ipers
operator|>
name|zone
operator|->
name|uz_ipers
condition|)
block|{
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_OFFPAGE
expr_stmt|;
name|zone
operator|->
name|uz_ipers
operator|=
name|ipers
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Finish creating a large (> UMA_SLAB_SIZE) uma zone.  Just give in and do   * OFFPAGE for now.  When I can allow for more dynamic slab sizes this will be  * more complicated.  *  * Arguments  *	zone  The zone we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_large_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|pages
decl_stmt|;
name|pages
operator|=
name|zone
operator|->
name|uz_size
operator|/
name|UMA_SLAB_SIZE
expr_stmt|;
comment|/* Account for remainder */
if|if
condition|(
operator|(
name|pages
operator|*
name|UMA_SLAB_SIZE
operator|)
operator|<
name|zone
operator|->
name|uz_size
condition|)
name|pages
operator|++
expr_stmt|;
name|zone
operator|->
name|uz_ppera
operator|=
name|pages
expr_stmt|;
name|zone
operator|->
name|uz_ipers
operator|=
literal|1
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_OFFPAGE
expr_stmt|;
name|zone
operator|->
name|uz_rsize
operator|=
name|zone
operator|->
name|uz_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Zone header ctor.  This initializes all fields, locks, etc.  And inserts  * the zone onto the global zone list.  *  * Arguments/Returns follow uma_ctor specifications  *	udata  Actually uma_zcreat_args  *  */
end_comment

begin_function
specifier|static
name|void
name|zone_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|uma_zctor_args
modifier|*
name|arg
init|=
name|udata
decl_stmt|;
name|uma_zone_t
name|zone
init|=
name|mem
decl_stmt|;
name|int
name|cplen
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|bzero
argument_list|(
name|zone
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_name
operator|=
name|arg
operator|->
name|name
expr_stmt|;
name|zone
operator|->
name|uz_size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|zone
operator|->
name|uz_ctor
operator|=
name|arg
operator|->
name|ctor
expr_stmt|;
name|zone
operator|->
name|uz_dtor
operator|=
name|arg
operator|->
name|dtor
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|zone
operator|->
name|uz_align
operator|=
name|arg
operator|->
name|align
expr_stmt|;
name|zone
operator|->
name|uz_free
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_pages
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_allocf
operator|=
name|page_alloc
expr_stmt|;
name|zone
operator|->
name|uz_freef
operator|=
name|page_free
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_ZINIT
condition|)
name|zone
operator|->
name|uz_init
operator|=
name|zero_init
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_INTERNAL
condition|)
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_INTERNAL
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_MALLOC
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_NOFREE
condition|)
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_NOFREE
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_size
operator|>
name|UMA_SLAB_SIZE
condition|)
name|zone_large_init
argument_list|(
name|zone
argument_list|)
expr_stmt|;
else|else
name|zone_small_init
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* We do this so that the per cpu lock name is unique for each zone */
name|memcpy
argument_list|(
name|zone
operator|->
name|uz_lname
argument_list|,
literal|"PCPU "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|cplen
operator|=
name|min
argument_list|(
name|strlen
argument_list|(
name|zone
operator|->
name|uz_name
argument_list|)
operator|+
literal|1
argument_list|,
name|LOCKNAME_LEN
operator|-
literal|6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zone
operator|->
name|uz_lname
operator|+
literal|5
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_lname
index|[
name|LOCKNAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * If we're putting the slab header in the actual page we need to 	 * figure out where in each page it goes.  This calculates a right  	 * justified offset into the memory on a ALIGN_PTR boundary. 	 */
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
operator|)
condition|)
block|{
name|int
name|totsize
decl_stmt|;
name|int
name|waste
decl_stmt|;
comment|/* Size of the slab struct and free list */
name|totsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|+
name|zone
operator|->
name|uz_ipers
expr_stmt|;
if|if
condition|(
name|totsize
operator|&
name|UMA_ALIGN_PTR
condition|)
name|totsize
operator|=
operator|(
name|totsize
operator|&
operator|~
name|UMA_ALIGN_PTR
operator|)
operator|+
operator|(
name|UMA_ALIGN_PTR
operator|+
literal|1
operator|)
expr_stmt|;
name|zone
operator|->
name|uz_pgoff
operator|=
name|UMA_SLAB_SIZE
operator|-
name|totsize
expr_stmt|;
name|waste
operator|=
name|zone
operator|->
name|uz_pgoff
expr_stmt|;
name|waste
operator|-=
operator|(
name|zone
operator|->
name|uz_ipers
operator|*
name|zone
operator|->
name|uz_rsize
operator|)
expr_stmt|;
comment|/* 		 * This calculates how much space we have for cache line size 		 * optimizations.  It works by offseting each slab slightly. 		 * Currently it breaks on x86, and so it is disabled. 		 */
if|if
condition|(
name|zone
operator|->
name|uz_align
operator|<
name|UMA_CACHE_INC
operator|&&
name|waste
operator|>
name|UMA_CACHE_INC
condition|)
block|{
name|zone
operator|->
name|uz_cachemax
operator|=
name|waste
operator|-
name|UMA_CACHE_INC
expr_stmt|;
name|zone
operator|->
name|uz_cacheoff
operator|=
literal|0
expr_stmt|;
block|}
name|totsize
operator|=
name|zone
operator|->
name|uz_pgoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|+
name|zone
operator|->
name|uz_ipers
expr_stmt|;
comment|/* I don't think it's possible, but I'll make sure anyway */
if|if
condition|(
name|totsize
operator|>
name|UMA_SLAB_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"zone %s ipers %d rsize %d size %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
operator|->
name|uz_ipers
argument_list|,
name|zone
operator|->
name|uz_rsize
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"UMA slab won't fit.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* hash_expand here to allocate the initial hash table */
name|hash_expand
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_pgoff
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"%s(%p) size = %d ipers = %d ppera = %d pgoff = %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|zone
operator|->
name|uz_ipers
argument_list|,
name|zone
operator|->
name|uz_ppera
argument_list|,
name|zone
operator|->
name|uz_pgoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ZONE_LOCK_INIT
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_zones
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Some internal zones don't have room allocated for the per cpu 	 * caches.  If we're internal, bail out here. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
return|return;
if|if
condition|(
name|zone
operator|->
name|uz_ipers
operator|<
name|UMA_BUCKET_SIZE
condition|)
name|zone
operator|->
name|uz_count
operator|=
name|zone
operator|->
name|uz_ipers
operator|-
literal|1
expr_stmt|;
else|else
name|zone
operator|->
name|uz_count
operator|=
name|UMA_BUCKET_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|maxcpu
condition|;
name|cpu
operator|++
control|)
name|CPU_LOCK_INIT
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Zone header dtor.  This frees all data, destroys locks, frees the hash table  * and removes the zone from the global list.  *  * Arguments/Returns follow uma_dtor specifications  *	udata  unused  */
end_comment

begin_function
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_zone_t
name|zone
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|zone
operator|=
operator|(
name|uma_zone_t
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_wssize
operator|=
literal|0
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_free
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Zone %s was not empty.  Lost %d pages of memory.\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
operator|->
name|uz_pages
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|maxcpu
condition|;
name|cpu
operator|++
control|)
name|CPU_LOCK_FINI
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
operator|)
operator|!=
literal|0
condition|)
name|hash_free
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_LOCK_FINI
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Traverses every zone in the system and calls a callback  *  * Arguments:  *	zfunc  A pointer to a function which accepts a zone  *		as an argument.  *   * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
block|{
name|uma_zone_t
name|zone
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|zone
argument_list|,
argument|&uma_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
name|zfunc
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public functions */
end_comment

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_startup
parameter_list|(
name|void
modifier|*
name|bootmem
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|slabsize
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Creating uma zone headers zone.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMP
name|maxcpu
operator|=
name|mp_maxid
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|maxcpu
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Max cpu = %d, mp_maxid = %d\n"
argument_list|,
name|maxcpu
argument_list|,
name|mp_maxid
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"stop"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|uma_mtx
argument_list|,
literal|"UMA lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* "manually" Create the initial zone */
name|args
operator|.
name|name
operator|=
literal|"UMA Zones"
expr_stmt|;
name|args
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|uma_cache
argument_list|)
operator|*
operator|(
name|maxcpu
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|zone_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|zone_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zero_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|32
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|UMA_ZONE_INTERNAL
expr_stmt|;
comment|/* The initial zone has no Per cpu queues so it's smaller */
name|zone_ctor
argument_list|(
name|zones
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Filling boot free list.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UMA_BOOT_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|bootmem
operator|+
operator|(
name|i
operator|*
name|UMA_SLAB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|slab
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|UMA_SLAB_BOOT
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_boot_pages
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|uma_boot_free
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Creating slab zone.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is the max number of free list items we'll have with 	 * offpage slabs. 	 */
name|slabsize
operator|=
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
name|slabsize
operator|/=
name|UMA_MAX_WASTE
expr_stmt|;
name|slabsize
operator|++
expr_stmt|;
comment|/* In case there it's rounded */
name|slabsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
comment|/* Now make a zone for slab headers */
name|slabzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Slabs"
argument_list|,
name|slabsize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_INTERNAL
argument_list|)
expr_stmt|;
name|hashzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Hash"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slabhead
operator|*
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_INTERNAL
argument_list|)
expr_stmt|;
name|bucketzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Buckets"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_bucket
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_INTERNAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* see uma.h */
end_comment

begin_function
name|void
name|uma_startup2
parameter_list|(
name|void
modifier|*
name|hashmem
parameter_list|,
name|u_long
name|elems
parameter_list|)
block|{
name|bzero
argument_list|(
name|hashmem
argument_list|,
name|elems
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|mallochash
operator|->
name|uh_slab_hash
operator|=
name|hashmem
expr_stmt|;
name|mallochash
operator|->
name|uh_hashsize
operator|=
name|elems
expr_stmt|;
name|mallochash
operator|->
name|uh_hashmask
operator|=
name|elems
operator|-
literal|1
expr_stmt|;
name|booted
operator|=
literal|1
expr_stmt|;
name|bucket_enable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup2 complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize our callout handle  *  */
end_comment

begin_function
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Starting callout.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|uma_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_WORKING_TIME
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup3 complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zcreate
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|u_int16_t
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
comment|/* This stuff is essential for the zone ctor */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|uminit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|fini
expr_stmt|;
name|args
operator|.
name|align
operator|=
name|align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|uma_zalloc_internal
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zdestroy
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_zfree_internal
argument_list|(
name|zones
argument_list|,
name|zone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
modifier|*
name|uma_zalloc_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* This is the fast path allocation */
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC_1
name|printf
argument_list|(
literal|"Allocating one item from %s(%p)\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zalloc_restart
label|:
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|CPU_LOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zalloc_start
label|:
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|ub_ptr
operator|>
operator|-
literal|1
condition|)
block|{
name|item
operator|=
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_ptr
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zalloc: Bucket pointer mangled."
operator|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|++
expr_stmt|;
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_ctor
condition|)
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
condition|)
block|{
comment|/* 			 * We have run out of items in our allocbucket. 			 * See if we can switch with our free bucket. 			 */
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_ptr
operator|>
operator|-
literal|1
condition|)
block|{
name|uma_bucket_t
name|swap
decl_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zalloc: Swapping empty with alloc.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swap
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|swap
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
block|}
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Since we have locked the zone we may as well send back our stats */
name|zone
operator|->
name|uz_allocs
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
comment|/* Our old one is now a free bucket */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
block|{
name|KASSERT
argument_list|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_ptr
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"uma_zalloc_arg: Freeing a non free bucket."
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check the free list for a new alloc bucket */
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_ptr
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"uma_zalloc_arg: Returning an empty bucket."
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* Bump up our uz_count so we get here less */
if|if
condition|(
name|zone
operator|->
name|uz_count
operator|<
name|UMA_BUCKET_SIZE
operator|-
literal|1
condition|)
name|zone
operator|->
name|uz_count
operator|++
expr_stmt|;
comment|/* We are no longer associated with this cpu!!! */
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
comment|/* 	 * Now lets just fill a bucket and put it on the free list.  If that 	 * works we'll restart the allocation from the begining. 	 * 	 * Try this zone's free list first so we don't allocate extra buckets. 	 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
comment|/* Now we no longer need the zone lock. */
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
name|bucket
operator|=
name|uma_zalloc_internal
argument_list|(
name|bucketzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
name|bucket
argument_list|,
name|bucketzone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_ptr
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uma_zalloc_internal
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|wait
argument_list|,
name|bucket
argument_list|)
condition|)
goto|goto
name|zalloc_restart
goto|;
else|else
name|uma_zfree_internal
argument_list|(
name|bucketzone
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We may not get a bucket if we recurse, so  	 * return an actual item. 	 */
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"uma_zalloc_arg: Bucketzone returned NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|uma_zalloc_internal
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|wait
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates an item for an internal zone OR fills a bucket  *  * Arguments  *	zone   The zone to alloc for.  *	udata  The data to be passed to the constructor.  *	wait   M_WAITOK or M_NOWAIT.  *	bucket The bucket to fill or NULL  *  * Returns  *	NULL if there is no memory and M_NOWAIT is set  *	An item if called on an interal zone  *	Non NULL if called to fill a bucket and it was successful.  *  * Discussion:  *	This was much cleaner before it had to do per cpu caches.  It is  *	complicated now because it has to handle the simple internal case, and  *	the more involved bucket filling and allocation.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|uma_zalloc_internal
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|wait
parameter_list|,
name|uma_bucket_t
name|bucket
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int8_t
name|freei
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This is to stop us from allocating per cpu buckets while we're 	 * running out of UMA_BOOT_PAGES.  Otherwise, we would exhaust the 	 * boot pages. 	 */
if|if
condition|(
name|bucketdisable
operator|&&
name|zone
operator|==
name|bucketzone
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"INTERNAL: Allocating one item from %s(%p)\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * This code is here to limit the number of simultaneous bucket fills 	 * for any given zone to the number of per cpu caches in this zone. This 	 * is done so that we don't allocate more memory than we really need. 	 */
if|if
condition|(
name|bucket
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|zone
operator|->
name|uz_fills
operator|>=
name|mp_ncpus
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|zone
operator|->
name|uz_fills
operator|>
literal|1
condition|)
block|{
endif|#
directive|endif
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|zone
operator|->
name|uz_fills
operator|++
expr_stmt|;
block|}
name|new_slab
label|:
comment|/* Find a slab with some space */
if|if
condition|(
name|zone
operator|->
name|uz_free
condition|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|zone
operator|->
name|uz_part_slab
argument_list|)
condition|)
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_part_slab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_slab
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  		 * This is to prevent us from recursively trying to allocate 		 * buckets.  The problem is that if an allocation forces us to 		 * grab a new bucket we will call page_alloc, which will go off 		 * and cause the vm to allocate vm_map_entries.  If we need new 		 * buckets there too we will recurse in kmem_alloc and bad  		 * things happen.  So instead we return a NULL bucket, and make 		 * the code that allocates buckets smart enough to deal with it			 */
if|if
condition|(
name|zone
operator|==
name|bucketzone
operator|&&
name|zone
operator|->
name|uz_recurse
operator|!=
literal|0
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|zone
operator|->
name|uz_maxpages
operator|&&
name|zone
operator|->
name|uz_pages
operator|>=
name|zone
operator|->
name|uz_maxpages
condition|)
block|{
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
if|if
condition|(
name|wait
operator|&
name|M_WAITOK
condition|)
name|msleep
argument_list|(
name|zone
argument_list|,
operator|&
name|zone
operator|->
name|uz_lock
argument_list|,
name|PVM
argument_list|,
literal|"zonelimit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
goto|goto
name|alloc_fail
goto|;
goto|goto
name|new_slab
goto|;
block|}
name|zone
operator|->
name|uz_recurse
operator|++
expr_stmt|;
name|slab
operator|=
name|slab_zalloc
argument_list|(
name|zone
argument_list|,
name|wait
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_recurse
operator|--
expr_stmt|;
comment|/*  		 * We might not have been able to get a slab but another cpu 		 * could have while we were unlocked.  If we did get a slab put 		 * it on the partially used slab list.  If not check the free 		 * count and restart or fail accordingly. 		 */
if|if
condition|(
name|slab
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zone
operator|->
name|uz_free
operator|==
literal|0
condition|)
goto|goto
name|alloc_fail
goto|;
else|else
goto|goto
name|new_slab
goto|;
block|}
comment|/* 	 * If this is our first time though put this guy on the list. 	 */
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_ptr
operator|==
operator|-
literal|1
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|slab
operator|->
name|us_freecount
condition|)
block|{
name|freei
operator|=
name|slab
operator|->
name|us_firstfree
expr_stmt|;
name|slab
operator|->
name|us_firstfree
operator|=
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
name|slab
operator|->
name|us_freecount
operator|--
expr_stmt|;
name|zone
operator|->
name|uz_free
operator|--
expr_stmt|;
name|item
operator|=
name|slab
operator|->
name|us_data
operator|+
operator|(
name|zone
operator|->
name|uz_rsize
operator|*
name|freei
operator|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
block|{
name|zone
operator|->
name|uz_allocs
operator|++
expr_stmt|;
break|break;
block|}
name|bucket
operator|->
name|ub_bucket
index|[
operator|++
name|bucket
operator|->
name|ub_ptr
index|]
operator|=
name|item
expr_stmt|;
comment|/* Don't overfill the bucket! */
if|if
condition|(
name|bucket
operator|->
name|ub_ptr
operator|==
name|zone
operator|->
name|uz_count
condition|)
break|break;
block|}
comment|/* Move this slab to the full list */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
comment|/* Try to keep the buckets totally full, but don't block */
if|if
condition|(
name|bucket
operator|->
name|ub_ptr
operator|<
name|zone
operator|->
name|uz_count
condition|)
block|{
name|wait
operator|=
name|M_NOWAIT
expr_stmt|;
goto|goto
name|new_slab
goto|;
block|}
else|else
name|zone
operator|->
name|uz_fills
operator|--
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Only construct at this time if we're not filling a bucket */
if|if
condition|(
name|bucket
operator|==
name|NULL
operator|&&
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
condition|)
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
name|alloc_fail
label|:
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
name|zone
operator|->
name|uz_fills
operator|--
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_ptr
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|bucket
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* See uma.h */
name|void
name|uma_zfree_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* This is the fast path free */
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC_1
name|printf
argument_list|(
literal|"Freeing item %p to %s(%p)\n"
argument_list|,
name|item
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The race here is acceptable.  If we miss it we'll just have to wait 	 * a little longer for the limits to be reset. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
goto|goto
name|zfree_internal
goto|;
name|zfree_restart
label|:
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|CPU_LOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zfree_start
label|:
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
comment|/* 		 * Do we have room in our bucket? It is OK for this uz count 		 * check to be slightly out of sync. 		 */
if|if
condition|(
name|bucket
operator|->
name|ub_ptr
operator|<
name|zone
operator|->
name|uz_count
condition|)
block|{
name|bucket
operator|->
name|ub_ptr
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"uma_zfree: Freeing to non free bucket index."
operator|)
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_ptr
index|]
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_dtor
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Swapping buckets.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * We have run out of space in our freebucket. 			 * See if we can switch with our alloc bucket. 			 */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_ptr
operator|<
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_ptr
condition|)
block|{
name|uma_bucket_t
name|swap
decl_stmt|;
name|swap
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|swap
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
block|}
block|}
comment|/* 	 * We can get here for two reasons: 	 * 	 * 1) The buckets are NULL 	 * 2) The alloc and free buckets are both somewhat full. 	 * 	 */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
comment|/* Can we throw this on the zone full list? */
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Putting old bucket on the free list.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ub_ptr is pointing to the last free item */
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_ptr
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"uma_zfree: Attempting to insert an empty bucket onto the full list.\n"
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
comment|/* We're done with this CPU now */
name|CPU_UNLOCK
argument_list|(
name|zone
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
comment|/* And the zone.. */
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Allocating new free bucket.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|=
name|uma_zalloc_internal
argument_list|(
name|bucketzone
argument_list|,
name|NULL
argument_list|,
name|M_NOWAIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
name|bucket
argument_list|,
name|bucketzone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_ptr
operator|=
operator|-
literal|1
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zfree_restart
goto|;
block|}
comment|/* 	 * If nothing else caught this, we'll just do an internal free. 	 */
name|zfree_internal
label|:
name|uma_zfree_internal
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * Frees an item to an INTERNAL zone or allocates a free bucket  *  * Arguments:  *	zone   The zone to free to  *	item   The item we're freeing  *	udata  User supplied data for the dtor  *	skip   Skip the dtor, it was done in uma_zfree_arg  */
specifier|static
name|void
name|uma_zfree_internal
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|skip
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|u_int8_t
name|freei
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MALLOC
operator|)
condition|)
block|{
name|mem
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_OFFPAGE
condition|)
name|slab
operator|=
name|hash_sfind
argument_list|(
operator|&
name|zone
operator|->
name|uz_hash
argument_list|,
name|mem
argument_list|)
expr_stmt|;
else|else
block|{
name|mem
operator|+=
name|zone
operator|->
name|uz_pgoff
expr_stmt|;
name|slab
operator|=
operator|(
name|uma_slab_t
operator|)
name|mem
expr_stmt|;
block|}
block|}
else|else
block|{
name|slab
operator|=
operator|(
name|uma_slab_t
operator|)
name|udata
expr_stmt|;
block|}
comment|/* Do we need to remove from any lists? */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|+
literal|1
operator|==
name|zone
operator|->
name|uz_ipers
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
comment|/* Slab management stuff */
name|freei
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|-
operator|(
name|unsigned
name|long
operator|)
name|slab
operator|->
name|us_data
operator|)
operator|/
name|zone
operator|->
name|uz_rsize
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
operator|(
name|freei
operator|*
name|zone
operator|->
name|uz_rsize
operator|)
operator|+
name|slab
operator|->
name|us_data
operator|)
operator|!=
name|item
condition|)
name|panic
argument_list|(
literal|"zone: %s(%p) slab %p freed address %p unaligned.\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|slab
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|freei
operator|>=
name|zone
operator|->
name|uz_ipers
condition|)
name|panic
argument_list|(
literal|"zone: %s(%p) slab %p freelist %i out of range 0-%d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|,
name|zone
operator|->
name|uz_ipers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|!=
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"Slab at %p, freei %d = %d.\n"
argument_list|,
name|slab
argument_list|,
name|freei
argument_list|,
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Duplicate free of item %p from zone %p(%s)\n"
argument_list|,
name|item
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|=
name|slab
operator|->
name|us_firstfree
expr_stmt|;
name|slab
operator|->
name|us_firstfree
operator|=
name|freei
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|++
expr_stmt|;
comment|/* Zone statistics */
name|zone
operator|->
name|uz_free
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|skip
operator|&&
name|zone
operator|->
name|uz_dtor
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_pages
operator|<
name|zone
operator|->
name|uz_maxpages
condition|)
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
comment|/* We can handle one more allocation */
name|wakeup_one
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
name|void
name|uma_zone_set_max
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|nitems
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_ppera
operator|>
literal|1
condition|)
name|zone
operator|->
name|uz_maxpages
operator|=
name|nitems
operator|*
name|zone
operator|->
name|uz_ppera
expr_stmt|;
else|else
name|zone
operator|->
name|uz_maxpages
operator|=
name|nitems
operator|/
name|zone
operator|->
name|uz_ipers
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
name|void
name|uma_zone_set_freef
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_free
name|freef
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_freef
operator|=
name|freef
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
name|void
name|uma_zone_set_allocf
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_alloc
name|allocf
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_PRIVALLOC
expr_stmt|;
name|zone
operator|->
name|uz_allocf
operator|=
name|allocf
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
name|int
name|uma_zone_set_obj
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|struct
name|vm_object
modifier|*
name|obj
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|pages
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pages
operator|=
name|count
operator|/
name|zone
operator|->
name|uz_ipers
expr_stmt|;
if|if
condition|(
name|pages
operator|*
name|zone
operator|->
name|uz_ipers
operator|<
name|count
condition|)
name|pages
operator|++
expr_stmt|;
name|kva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|pages
operator|*
name|UMA_SLAB_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kva
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|zone
operator|->
name|uz_maxpages
argument_list|)
expr_stmt|;
else|else
name|_vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|zone
operator|->
name|uz_maxpages
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_kva
operator|=
name|kva
expr_stmt|;
name|zone
operator|->
name|uz_obj
operator|=
name|obj
expr_stmt|;
name|zone
operator|->
name|uz_maxpages
operator|=
name|pages
expr_stmt|;
name|zone
operator|->
name|uz_allocf
operator|=
name|obj_alloc
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_NOFREE
operator||
name|UMA_ZFLAG_PRIVALLOC
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* See uma.h */
name|void
name|uma_prealloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|items
parameter_list|)
block|{
name|int
name|slabs
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|slabs
operator|=
name|items
operator|/
name|zone
operator|->
name|uz_ipers
expr_stmt|;
if|if
condition|(
name|slabs
operator|*
name|zone
operator|->
name|uz_ipers
operator|<
name|items
condition|)
name|slabs
operator|++
expr_stmt|;
while|while
condition|(
name|slabs
operator|>
literal|0
condition|)
block|{
name|slab
operator|=
name|slab_zalloc
argument_list|(
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|slabs
operator|--
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* See uma.h */
name|void
name|uma_reclaim
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * You might think that the delay below would improve performance since 	 * the allocator will give away memory that it may ask for immediately. 	 * Really, it makes things worse, since cpu cycles are so much cheaper 	 * than disk activity. 	 */
if|#
directive|if
literal|0
block|static struct timeval tv = {0}; 	struct timeval now; 	getmicrouptime(&now); 	if (now.tv_sec> tv.tv_sec + 30) 		tv = now; 	else 		return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA: vm asked us to release pages!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_drain
argument_list|)
expr_stmt|;
comment|/* 	 * Some slabs may have been freed but this zone will be visited early 	 * we visit again so that we can free pages that are empty once other 	 * zones are drained.  We have to do the same for buckets. 	 */
name|zone_drain
argument_list|(
name|slabzone
argument_list|)
expr_stmt|;
name|zone_drain
argument_list|(
name|bucketzone
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|uma_large_malloc
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|slab
operator|=
name|uma_zalloc_internal
argument_list|(
name|slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mem
operator|=
name|page_alloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
operator||
name|UMA_SLAB_MALLOC
expr_stmt|;
name|slab
operator|->
name|us_size
operator|=
name|size
expr_stmt|;
name|UMA_HASH_INSERT
argument_list|(
name|mallochash
argument_list|,
name|slab
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uma_zfree_internal
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mem
operator|)
return|;
block|}
name|void
name|uma_large_free
parameter_list|(
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|UMA_HASH_REMOVE
argument_list|(
name|mallochash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|page_free
argument_list|(
name|slab
operator|->
name|us_data
argument_list|,
name|slab
operator|->
name|us_size
argument_list|,
name|slab
operator|->
name|us_flags
argument_list|)
expr_stmt|;
name|uma_zfree_internal
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|zone_foreach
argument_list|(
name|uma_print_zone
argument_list|)
expr_stmt|;
block|}
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s(%p) size %d(%d) flags %d ipers %d ppera %d out %d free %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|zone
operator|->
name|uz_rsize
argument_list|,
name|zone
operator|->
name|uz_flags
argument_list|,
name|zone
operator|->
name|uz_ipers
argument_list|,
name|zone
operator|->
name|uz_ppera
argument_list|,
operator|(
name|zone
operator|->
name|uz_ipers
operator|*
name|zone
operator|->
name|uz_pages
operator|)
operator|-
name|zone
operator|->
name|uz_free
argument_list|,
name|zone
operator|->
name|uz_free
argument_list|)
expr_stmt|;
block|}
comment|/*  * Sysctl handler for vm.zone   *  * stolen from vm_zone.c  */
specifier|static
name|int
name|sysctl_vm_zone
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|cnt
decl_stmt|;
specifier|const
name|int
name|linesize
init|=
literal|128
decl_stmt|;
comment|/* conservative */
name|int
name|totalfree
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|,
modifier|*
name|offset
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&uma_zones
argument_list|,
argument|uz_link
argument_list|)
name|cnt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|tmpbuf
argument_list|,
name|char
operator|*
argument_list|,
operator|(
name|cnt
operator|==
literal|0
condition|?
literal|1
else|:
name|cnt
operator|)
operator|*
name|linesize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|tmpbuf
argument_list|,
name|linesize
argument_list|,
literal|"\nITEM            SIZE     LIMIT     USED    FREE  REQUESTS\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|tmpbuf
argument_list|,
name|cnt
operator|==
literal|0
condition|?
name|len
operator|-
literal|1
else|:
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|cnt
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|offset
operator|=
name|tmpbuf
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&uma_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
comment|/* list may have changed size */
break|break;
name|ZONE_LOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|totalfree
operator|=
name|z
operator|->
name|uz_free
operator|+
name|z
operator|->
name|uz_cachefree
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|offset
argument_list|,
name|linesize
argument_list|,
literal|"%-12.12s  %6.6u, %8.8u, %6.6u, %6.6u, %8.8llu\n"
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
name|z
operator|->
name|uz_size
argument_list|,
name|z
operator|->
name|uz_maxpages
operator|*
name|z
operator|->
name|uz_ipers
argument_list|,
operator|(
name|z
operator|->
name|uz_ipers
operator|*
operator|(
name|z
operator|->
name|uz_pages
operator|/
name|z
operator|->
name|uz_ppera
operator|)
operator|)
operator|-
name|totalfree
argument_list|,
name|totalfree
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|z
operator|->
name|uz_allocs
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|offset
operator|+
literal|12
init|;
name|p
operator|>
name|offset
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|;
operator|--
name|p
control|)
comment|/* nothing */
empty_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|tmpbuf
argument_list|,
name|offset
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|out
label|:
name|FREE
argument_list|(
name|tmpbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

