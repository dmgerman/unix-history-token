begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2005, 2009 Jeffrey Roberson<jeff@FreeBSD.org>  * Copyright (c) 2004, 2005 Bosko Milekic<bmilekic@FreeBSD.org>  * Copyright (c) 2004-2006 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * uma_core.c  Implementation of the Universal Memory allocator  *  * This allocator is intended to replace the multitude of similar object caches  * in the standard FreeBSD kernel.  The intent is to be flexible as well as  * effecient.  A primary design goal is to return unused memory to the rest of  * the system.  This will make the system as a whole more flexible due to the  * ability to move memory to subsystems which most need it instead of leaving  * pools of reserved memory unused.  *  * The basic ideas stem from similar slab/zone based allocators whose algorithms  * are well known.  *  */
end_comment

begin_comment
comment|/*  * TODO:  *	- Improve memory usage for large allocations  *	- Investigate cache size adjustments  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* I should really use ktr.. */
end_comment

begin_comment
comment|/* #define UMA_DEBUG 1 #define UMA_DEBUG_ALLOC 1 #define UMA_DEBUG_ALLOC_1 1 */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_dbg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_comment
comment|/*  * This is the zone and keg from which all zones are spawned.  The idea is that  * even the zone& keg heads are allocated from the allocator, so we use the  * bss section to bootstrap us.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uma_keg
name|masterkeg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uma_zone
name|masterzone_k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uma_zone
name|masterzone_z
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kegs
init|=
operator|&
name|masterzone_k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|zones
init|=
operator|&
name|masterzone_z
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the zone from which all of uma_slab_t's are allocated. */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|slabzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|slabrefzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* With refcounters (for UMA_ZONE_REFCNT) */
end_comment

begin_comment
comment|/*  * The initial hash tables come out of this zone so they can be allocated  * prior to malloc coming up.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|hashzone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The boot-time adjusted value for cache line alignment. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uma_align_cache
init|=
literal|64
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMAHASH
argument_list|,
literal|"UMAHash"
argument_list|,
literal|"UMA Hash Buckets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Are we allowed to allocate buckets?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bucketdisable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all kegs in the system */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_keg
argument_list|)
name|uma_kegs
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|uma_kegs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This mutex protects the keg list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|uma_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of boot time pages */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_slab
argument_list|)
name|uma_boot_pages
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|uma_boot_pages
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This mutex protects the boot time pages list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|uma_boot_pages_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is the VM done starting up? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|booted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of allowed items-per-slab if the slab header is OFFPAGE */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|uma_max_ipers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|uma_max_ipers_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the handle used to schedule events that need to happen  * outside of the allocation fast path.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|uma_callout
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UMA_TIMEOUT
value|20
end_define

begin_comment
comment|/* Seconds for callout interval. */
end_comment

begin_comment
comment|/*  * This structure is passed as the zone ctor arg so that I don't have to create  * a special allocation function just for zones.  */
end_comment

begin_struct
struct|struct
name|uma_zctor_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uma_ctor
name|ctor
decl_stmt|;
name|uma_dtor
name|dtor
decl_stmt|;
name|uma_init
name|uminit
decl_stmt|;
name|uma_fini
name|fini
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|align
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uma_kctor_args
block|{
name|uma_zone_t
name|zone
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uma_init
name|uminit
decl_stmt|;
name|uma_fini
name|fini
decl_stmt|;
name|int
name|align
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uma_bucket_zone
block|{
name|uma_zone_t
name|ubz_zone
decl_stmt|;
name|char
modifier|*
name|ubz_name
decl_stmt|;
name|int
name|ubz_entries
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BUCKET_MAX
value|128
end_define

begin_decl_stmt
name|struct
name|uma_bucket_zone
name|bucket_zones
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|"16 Bucket"
block|,
literal|16
block|}
block|,
block|{
name|NULL
block|,
literal|"32 Bucket"
block|,
literal|32
block|}
block|,
block|{
name|NULL
block|,
literal|"64 Bucket"
block|,
literal|64
block|}
block|,
block|{
name|NULL
block|,
literal|"128 Bucket"
block|,
literal|128
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUCKET_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|BUCKET_ZONES
value|((BUCKET_MAX>> BUCKET_SHIFT) + 1)
end_define

begin_comment
comment|/*  * bucket_size[] maps requested bucket sizes to zones that allocate a bucket  * of approximately the right size.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|bucket_size
index|[
name|BUCKET_ZONES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags and enumerations to be passed to internal functions.  */
end_comment

begin_enum
enum|enum
name|zfreeskip
block|{
name|SKIP_NONE
block|,
name|SKIP_DTOR
block|,
name|SKIP_FINI
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ZFREE_STATFAIL
value|0x00000001
end_define

begin_comment
comment|/* Update zone failure statistic. */
end_comment

begin_define
define|#
directive|define
name|ZFREE_STATFREE
value|0x00000002
end_define

begin_comment
comment|/* Update zone free statistic. */
end_comment

begin_comment
comment|/* Prototypes.. */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|obj_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|startup_alloc
parameter_list|(
name|uma_zone_t
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|keg_alloc_slab
parameter_list|(
name|uma_keg_t
parameter_list|,
name|uma_zone_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
parameter_list|,
name|uma_bucket_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|keg_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zone_ctor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zero_init
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_small_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keg_large_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash_alloc
parameter_list|(
name|struct
name|uma_hash
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
parameter_list|,
name|struct
name|uma_hash
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|zone_alloc_item
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zone_free_item
parameter_list|(
name|uma_zone_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|enum
name|zfreeskip
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_bucket_t
name|bucket_alloc
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_free
parameter_list|(
name|uma_bucket_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bucket_zone_drain
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zone_alloc_bucket
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|zone_fetch_slab
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_slab_t
name|zone_fetch_slab_multi
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|slab_alloc_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uma_keg_t
name|uma_kcreate
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|zone_relock
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|keg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|keg_relock
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vm_zone_count
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vm_zone_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|uma_startup3
argument_list|,
name|SI_SUB_VM_CONF
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|uma_startup3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_count
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_INT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone_count
argument_list|,
literal|"I"
argument_list|,
literal|"Number of UMA zones"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_stats
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone_stats
argument_list|,
literal|"s,struct uma_type_header"
argument_list|,
literal|"Zone Stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine checks to see whether or not it's safe to enable buckets.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_enable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_min
condition|)
name|bucketdisable
operator|=
literal|1
expr_stmt|;
else|else
name|bucketdisable
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize bucket_zones, the array of zones of buckets of various sizes.  *  * For each zone, calculate the memory required for each bucket, consisting  * of the header and an array of pointers.  Initialize bucket_size[] to point  * the range of appropriate bucket sizes at the zone.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|bucket_zones
index|[
name|j
index|]
operator|.
name|ubz_entries
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|int
name|size
decl_stmt|;
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
name|j
index|]
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uma_bucket
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ubz
operator|->
name|ubz_entries
expr_stmt|;
name|ubz
operator|->
name|ubz_zone
operator|=
name|uma_zcreate
argument_list|(
name|ubz
operator|->
name|ubz_name
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
operator||
name|UMA_ZFLAG_BUCKET
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|ubz
operator|->
name|ubz_entries
condition|;
name|i
operator|+=
operator|(
literal|1
operator|<<
name|BUCKET_SHIFT
operator|)
control|)
name|bucket_size
index|[
name|i
operator|>>
name|BUCKET_SHIFT
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a desired number of entries for a bucket, return the zone from which  * to allocate the bucket.  */
end_comment

begin_function
specifier|static
name|struct
name|uma_bucket_zone
modifier|*
name|bucket_zone_lookup
parameter_list|(
name|int
name|entries
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|howmany
argument_list|(
name|entries
argument_list|,
literal|1
operator|<<
name|BUCKET_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|bucket_zones
index|[
name|bucket_size
index|[
name|idx
index|]
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uma_bucket_t
name|bucket_alloc
parameter_list|(
name|int
name|entries
parameter_list|,
name|int
name|bflags
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
comment|/* 	 * This is to stop us from allocating per cpu buckets while we're 	 * running out of vm.boot_pages.  Otherwise, we would exhaust the 	 * boot pages.  This also prevents us from allocating buckets in 	 * low memory situations. 	 */
if|if
condition|(
name|bucketdisable
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ubz
operator|=
name|bucket_zone_lookup
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|zone_alloc_item
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|,
name|NULL
argument_list|,
name|bflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
name|bucket
operator|->
name|ub_bucket
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ubz
operator|->
name|ubz_entries
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|->
name|ub_cnt
operator|=
literal|0
expr_stmt|;
name|bucket
operator|->
name|ub_entries
operator|=
name|ubz
operator|->
name|ubz_entries
expr_stmt|;
block|}
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bucket_free
parameter_list|(
name|uma_bucket_t
name|bucket
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
name|ubz
operator|=
name|bucket_zone_lookup
argument_list|(
name|bucket
operator|->
name|ub_entries
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bucket_zone_drain
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uma_bucket_zone
modifier|*
name|ubz
decl_stmt|;
for|for
control|(
name|ubz
operator|=
operator|&
name|bucket_zones
index|[
literal|0
index|]
init|;
name|ubz
operator|->
name|ubz_entries
operator|!=
literal|0
condition|;
name|ubz
operator|++
control|)
name|zone_drain
argument_list|(
name|ubz
operator|->
name|ubz_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uma_keg_t
name|zone_first_keg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
return|return
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|)
operator|->
name|kl_keg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_foreach_keg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
function_decl|(
modifier|*
name|kegfn
function_decl|)
parameter_list|(
name|uma_keg_t
parameter_list|)
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|klink
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
name|kegfn
argument_list|(
name|klink
operator|->
name|kl_keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine called by timeout which is used to fire off some time interval  * based calculations.  (stats, hash size, etc.)  *  * Arguments:  *	arg   Unused  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|uma_timeout
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_timeout
argument_list|)
expr_stmt|;
comment|/* Reschedule this event */
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_TIMEOUT
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to perform timeout driven calculations.  This expands the  * hashes and does per cpu statistics aggregation.  *  *  Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|keg_timeout
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
comment|/* 	 * Expand the keg hash table. 	 * 	 * This is done if the number of slabs is larger than the hash size. 	 * What I'm trying to do here is completely reduce collisions.  This 	 * may be a little aggressive.  Should I allow for two collisions max? 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
operator|&&
name|keg
operator|->
name|uk_pages
operator|/
name|keg
operator|->
name|uk_ppera
operator|>=
name|keg
operator|->
name|uk_hash
operator|.
name|uh_hashsize
condition|)
block|{
name|struct
name|uma_hash
name|newhash
decl_stmt|;
name|struct
name|uma_hash
name|oldhash
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 		 * This is so involved because allocating and freeing 		 * while the keg lock is held will lead to deadlock. 		 * I have to do everything in stages and check for 		 * races. 		 */
name|newhash
operator|=
name|keg
operator|->
name|uk_hash
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hash_alloc
argument_list|(
operator|&
name|newhash
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|hash_expand
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
operator|&
name|newhash
argument_list|)
condition|)
block|{
name|oldhash
operator|=
name|keg
operator|->
name|uk_hash
expr_stmt|;
name|keg
operator|->
name|uk_hash
operator|=
name|newhash
expr_stmt|;
block|}
else|else
name|oldhash
operator|=
name|newhash
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
operator|&
name|oldhash
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_timeout
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|zone_foreach_keg
argument_list|(
name|zone
argument_list|,
operator|&
name|keg_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and zero fill the next sized hash table from the appropriate  * backing store.  *  * Arguments:  *	hash  A new hash structure with the old hash size in uh_hashsize  *  * Returns:  *	1 on sucess and 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hash_alloc
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
name|int
name|oldsize
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|oldsize
operator|=
name|hash
operator|->
name|uh_hashsize
expr_stmt|;
comment|/* We're just going to go to a power of two greater */
if|if
condition|(
name|oldsize
condition|)
block|{
name|hash
operator|->
name|uh_hashsize
operator|=
name|oldsize
operator|*
literal|2
expr_stmt|;
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|hash
operator|->
name|uh_hashsize
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
operator|(
expr|struct
name|slabhead
operator|*
operator|)
name|malloc
argument_list|(
name|alloc
argument_list|,
name|M_UMAHASH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|uh_slab_hash
index|[
literal|0
index|]
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
expr_stmt|;
name|hash
operator|->
name|uh_slab_hash
operator|=
name|zone_alloc_item
argument_list|(
name|hashzone
argument_list|,
name|NULL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_hashsize
operator|=
name|UMA_HASH_SIZE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|->
name|uh_slab_hash
condition|)
block|{
name|bzero
argument_list|(
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|hash
operator|->
name|uh_hashmask
operator|=
name|hash
operator|->
name|uh_hashsize
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expands the hash table for HASH zones.  This is done from zone_timeout  * to reduce collisions.  This must not be done in the regular allocation  * path, otherwise, we can recurse on the vm while allocating pages.  *  * Arguments:  *	oldhash  The hash you want to expand  *	newhash  The hash structure for the new table  *  * Returns:  *	Nothing  *  * Discussion:  */
end_comment

begin_function
specifier|static
name|int
name|hash_expand
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|oldhash
parameter_list|,
name|struct
name|uma_hash
modifier|*
name|newhash
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|int
name|hval
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|newhash
operator|->
name|uh_slab_hash
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|oldhash
operator|->
name|uh_hashsize
operator|>=
name|newhash
operator|->
name|uh_hashsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * I need to investigate hash algorithms for resizing without a 	 * full rehash. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldhash
operator|->
name|uh_hashsize
condition|;
name|i
operator|++
control|)
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slab
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|oldhash
operator|->
name|uh_slab_hash
index|[
name|i
index|]
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
name|hval
operator|=
name|UMA_HASH
argument_list|(
name|newhash
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|newhash
operator|->
name|uh_slab_hash
index|[
name|hval
index|]
argument_list|,
name|slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the hash bucket to the appropriate backing store.  *  * Arguments:  *	slab_hash  The hash bucket we're freeing  *	hashsize   The number of entries in that hash bucket  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|hash_free
parameter_list|(
name|struct
name|uma_hash
modifier|*
name|hash
parameter_list|)
block|{
if|if
condition|(
name|hash
operator|->
name|uh_slab_hash
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|hash
operator|->
name|uh_hashsize
operator|==
name|UMA_HASH_SIZE_INIT
condition|)
name|zone_free_item
argument_list|(
name|hashzone
argument_list|,
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|hash
operator|->
name|uh_slab_hash
argument_list|,
name|M_UMAHASH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Frees all outstanding items in a bucket  *  * Arguments:  *	zone   The zone to free to, must be unlocked.  *	bucket The free/alloc bucket with items, cpu queue must be locked.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|bucket_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_bucket_t
name|bucket
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|bucket
operator|->
name|ub_cnt
operator|--
expr_stmt|;
name|item
operator|=
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bucket_drain: botched ptr, item is NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|NULL
argument_list|,
name|SKIP_DTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drains the per cpu caches for a zone.  *  * NOTE: This may only be called while the zone is being turn down, and not  * during normal operation.  This is necessary in order that we do not have  * to migrate CPUs to drain the per-CPU caches.  *  * Arguments:  *	zone     The zone to drain, must be unlocked.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* 	 * XXX: It is safe to not lock the per-CPU caches, because we're 	 * tearing down the zone anyway.  I.e., there will be no further use 	 * of the caches at this point. 	 * 	 * XXX: It would good to be able to assert that the zone is being 	 * torn down to prevent improper use of cache_drain(). 	 * 	 * XXX: We lock the zone before passing into bucket_cache_drain() as 	 * it is used elsewhere.  Should the tear-down path be made special 	 * there in some form? 	 */
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|bucket_free
argument_list|(
name|cache
operator|->
name|uc_allocbucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|bucket_free
argument_list|(
name|cache
operator|->
name|uc_freebucket
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket_cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain the cached buckets from a zone.  Expects a locked zone on entry.  */
end_comment

begin_function
specifier|static
name|void
name|bucket_cache_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_bucket_t
name|bucket
decl_stmt|;
comment|/* 	 * Drain the bucket queues and free the buckets, we just keep two per 	 * cpu (alloc/free). 	 */
while|while
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket_drain
argument_list|(
name|zone
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|bucket_free
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
comment|/* Now we do the free queue.. */
while|while
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|bucket_free
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Frees pages from a keg back to the system.  This is done on demand from  * the pageout daemon.  *  * Returns nothing.  */
end_comment

begin_function
specifier|static
name|void
name|keg_drain
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|struct
name|slabhead
name|freeslabs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_slab_t
name|n
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We don't want to take pages from statically allocated kegs at this 	 * time 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_NOFREE
operator|||
name|keg
operator|->
name|uk_freef
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"%s free items: %u\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|==
literal|0
condition|)
goto|goto
name|finished
goto|;
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|)
expr_stmt|;
while|while
condition|(
name|slab
condition|)
block|{
name|n
operator|=
name|LIST_NEXT
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
comment|/* We have no where to free these to */
if|if
condition|(
name|slab
operator|->
name|us_flags
operator|&
name|UMA_SLAB_BOOT
condition|)
block|{
name|slab
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|-=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|-=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|UMA_HASH_REMOVE
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|slab
argument_list|,
name|slab
operator|->
name|us_data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|freeslabs
argument_list|,
name|slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
name|slab
operator|=
name|n
expr_stmt|;
block|}
name|finished
label|:
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|slab
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|freeslabs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|freeslabs
argument_list|,
name|slab
argument_list|,
name|uma_slab
argument_list|,
name|us_hlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_fini
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ipers
condition|;
name|i
operator|++
control|)
name|keg
operator|->
name|uk_fini
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|i
operator|)
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|)
expr_stmt|;
name|flags
operator|=
name|slab
operator|->
name|us_flags
expr_stmt|;
name|mem
operator|=
name|slab
operator|->
name|us_data
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMEM
condition|)
name|obj
operator|=
name|kmem_object
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KERNEL
condition|)
name|obj
operator|=
name|kernel_object
expr_stmt|;
else|else
name|obj
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ppera
condition|;
name|i
operator|++
control|)
name|vsetobj
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|zone_free_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"%s: Returning %d bytes.\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|UMA_SLAB_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|keg
operator|->
name|uk_freef
argument_list|(
name|mem
argument_list|,
name|UMA_SLAB_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_drain_wait
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
comment|/* 	 * Set draining to interlock with zone_dtor() so we can release our 	 * locks as we go.  Only dtor() should do a WAITOK call since it 	 * is the only call that knows the structure will still be available 	 * when it wakes up. 	 */
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
while|while
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_DRAINING
condition|)
block|{
if|if
condition|(
name|waitok
operator|==
name|M_NOWAIT
condition|)
goto|goto
name|out
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|uz_lock
argument_list|,
name|PVM
argument_list|,
literal|"zonedrain"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_DRAINING
expr_stmt|;
name|bucket_cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * The DRAINING flag protects us from being freed while 	 * we're running.  Normally the uma_mtx would protect us but we 	 * must be able to release and acquire the right lock for each keg. 	 */
name|zone_foreach_keg
argument_list|(
name|zone
argument_list|,
operator|&
name|keg_drain
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_DRAINING
expr_stmt|;
name|wakeup
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|out
label|:
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zone_drain
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|zone_drain_wait
argument_list|(
name|zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new slab for a keg.  This does not insert the slab onto a list.  *  * Arguments:  *	wait  Shall we wait?  *  * Returns:  *	The slab that was allocated or NULL if there is no memory and the  *	caller specified M_NOWAIT.  */
end_comment

begin_function
specifier|static
name|uma_slab_t
name|keg_alloc_slab
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uma_slabrefcnt_t
name|slabref
decl_stmt|;
name|uma_alloc
name|allocf
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"slab_zalloc:  Allocating a new slab for %s\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|allocf
operator|=
name|keg
operator|->
name|uk_allocf
expr_stmt|;
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
block|{
name|slab
operator|=
name|zone_alloc_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* 	 * This reproduces the old vm_zone behavior of zero filling pages the 	 * first time they are added to a zone. 	 * 	 * Malloced items are zeroed in uma_zalloc. 	 */
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_MALLOC
operator|)
operator|==
literal|0
condition|)
name|wait
operator||=
name|M_ZERO
expr_stmt|;
else|else
name|wait
operator|&=
operator|~
name|M_ZERO
expr_stmt|;
comment|/* zone is passed for legacy reasons. */
name|mem
operator|=
name|allocf
argument_list|(
name|zone
argument_list|,
name|keg
operator|->
name|uk_ppera
operator|*
name|UMA_SLAB_SIZE
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|zone_free_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Point the slab into the allocated memory */
if|if
condition|(
operator|!
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
condition|)
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
name|mem
operator|+
name|keg
operator|->
name|uk_pgoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ppera
condition|;
name|i
operator|++
control|)
name|vsetslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_keg
operator|=
name|keg
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
name|slab
operator|->
name|us_firstfree
operator|=
literal|0
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
block|{
name|slabref
operator|=
operator|(
name|uma_slabrefcnt_t
operator|)
name|slab
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ipers
condition|;
name|i
operator|++
control|)
block|{
name|slabref
operator|->
name|us_freelist
index|[
name|i
index|]
operator|.
name|us_refcnt
operator|=
literal|0
expr_stmt|;
name|slabref
operator|->
name|us_freelist
index|[
name|i
index|]
operator|.
name|us_item
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ipers
condition|;
name|i
operator|++
control|)
name|slab
operator|->
name|us_freelist
index|[
name|i
index|]
operator|.
name|us_item
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_init
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ipers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|keg
operator|->
name|uk_init
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|i
operator|)
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|,
name|wait
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|keg
operator|->
name|uk_ipers
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_fini
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
name|keg
operator|->
name|uk_fini
argument_list|(
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|i
operator|)
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMEM
condition|)
name|obj
operator|=
name|kmem_object
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KERNEL
condition|)
name|obj
operator|=
name|kernel_object
expr_stmt|;
else|else
name|obj
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keg
operator|->
name|uk_ppera
condition|;
name|i
operator|++
control|)
name|vsetobj
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
name|zone_free_item
argument_list|(
name|keg
operator|->
name|uk_slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_freef
argument_list|(
name|mem
argument_list|,
name|UMA_SLAB_SIZE
operator|*
name|keg
operator|->
name|uk_ppera
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|UMA_HASH_INSERT
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|slab
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|+=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|+=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is intended to be used early on in place of page_alloc() so  * that we may use the boot time page cache to satisfy allocations before  * the VM is ready.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|startup_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|uma_slab_t
name|tmps
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * Check our small startup cache to see if it has pages remaining. 	 */
name|mtx_lock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmps
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uma_boot_pages
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|tmps
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
operator|*
name|pflag
operator|=
name|tmps
operator|->
name|us_flags
expr_stmt|;
return|return
operator|(
name|tmps
operator|->
name|us_data
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|booted
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"UMA: Increase vm.boot_pages"
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've booted reset these users to their real allocator. 	 */
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
name|keg
operator|->
name|uk_allocf
operator|=
name|uma_small_alloc
expr_stmt|;
else|#
directive|else
name|keg
operator|->
name|uk_allocf
operator|=
name|page_alloc
expr_stmt|;
endif|#
directive|endif
return|return
name|keg
operator|->
name|uk_allocf
argument_list|(
name|zone
argument_list|,
name|bytes
argument_list|,
name|pflag
argument_list|,
name|wait
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from the system  *  * Arguments:  *	bytes  The number of bytes requested  *	wait  Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly  *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|page_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|pflag
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Returned page */
operator|*
name|pflag
operator|=
name|UMA_SLAB_KMEM
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kmem_map
argument_list|,
name|bytes
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a number of pages from within an object  *  * Arguments:  *	bytes  The number of bytes requested  *	wait   Shall we wait?  *  * Returns:  *	A pointer to the alloced memory or possibly  *	NULL if M_NOWAIT is set.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|obj_alloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|bytes
parameter_list|,
name|u_int8_t
modifier|*
name|flags
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|retkva
decl_stmt|,
name|zkva
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|pages
decl_stmt|,
name|startpages
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|object
operator|=
name|keg
operator|->
name|uk_obj
expr_stmt|;
name|retkva
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This looks a little weird since we're getting one page at a time. 	 */
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|p
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|pglist
argument_list|)
expr_stmt|;
name|pages
operator|=
name|p
operator|!=
name|NULL
condition|?
name|p
operator|->
name|pindex
operator|+
literal|1
else|:
literal|0
expr_stmt|;
name|startpages
operator|=
name|pages
expr_stmt|;
name|zkva
operator|=
name|keg
operator|->
name|uk_kva
operator|+
name|pages
operator|*
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
init|;
name|bytes
operator|>
literal|0
condition|;
name|bytes
operator|-=
name|PAGE_SIZE
control|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|pages
argument_list|,
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pages
operator|!=
name|startpages
condition|)
name|pmap_qremove
argument_list|(
name|retkva
argument_list|,
name|pages
operator|-
name|startpages
argument_list|)
expr_stmt|;
while|while
condition|(
name|pages
operator|!=
name|startpages
condition|)
block|{
name|pages
operator|--
expr_stmt|;
name|p
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|pglist
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|retkva
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pmap_qenter
argument_list|(
name|zkva
argument_list|,
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retkva
operator|==
literal|0
condition|)
name|retkva
operator|=
name|zkva
expr_stmt|;
name|zkva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pages
operator|+=
literal|1
expr_stmt|;
block|}
name|done
label|:
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
operator|*
name|flags
operator|=
name|UMA_SLAB_PRIV
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|retkva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees a number of pages to the system  *  * Arguments:  *	mem   A pointer to the memory to be freed  *	size  The size of the memory being freed  *	flags The original p->us_flags field  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|page_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|u_int8_t
name|flags
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KMEM
condition|)
name|map
operator|=
name|kmem_map
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|UMA_SLAB_KERNEL
condition|)
name|map
operator|=
name|kernel_map
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"UMA: page_free used with invalid flags %d"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero fill initializer  *  * Arguments/Returns follow uma_init specifications  */
end_comment

begin_function
specifier|static
name|int
name|zero_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bzero
argument_list|(
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish creating a small uma keg.  This calculates ipers, and the keg size.  *  * Arguments  *	keg  The zone we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|keg_small_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|u_int
name|rsize
decl_stmt|;
name|u_int
name|memused
decl_stmt|;
name|u_int
name|wastedspace
decl_stmt|;
name|u_int
name|shsize
decl_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Keg is null in keg_small_init"
operator|)
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|UMA_SMALLEST_UNIT
condition|)
name|rsize
operator|=
name|UMA_SMALLEST_UNIT
expr_stmt|;
if|if
condition|(
name|rsize
operator|&
name|keg
operator|->
name|uk_align
condition|)
name|rsize
operator|=
operator|(
name|rsize
operator|&
operator|~
name|keg
operator|->
name|uk_align
operator|)
operator|+
operator|(
name|keg
operator|->
name|uk_align
operator|+
literal|1
operator|)
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|rsize
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
block|{
name|rsize
operator|+=
name|UMA_FRITMREF_SZ
expr_stmt|;
comment|/* linkage& refcnt */
name|shsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsize
operator|+=
name|UMA_FRITM_SZ
expr_stmt|;
comment|/* Account for linkage */
name|shsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
block|}
name|keg
operator|->
name|uk_ipers
operator|=
operator|(
name|UMA_SLAB_SIZE
operator|-
name|shsize
operator|)
operator|/
name|rsize
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|!=
literal|0
argument_list|,
operator|(
literal|"keg_small_init: ipers is 0"
operator|)
argument_list|)
expr_stmt|;
name|memused
operator|=
name|keg
operator|->
name|uk_ipers
operator|*
name|rsize
operator|+
name|shsize
expr_stmt|;
name|wastedspace
operator|=
name|UMA_SLAB_SIZE
operator|-
name|memused
expr_stmt|;
comment|/* 	 * We can't do OFFPAGE if we're internal or if we've been 	 * asked to not go to the VM for buckets.  If we do this we 	 * may end up going to the VM (kmem_map) for slabs which we 	 * do not want to do if we're UMA_ZFLAG_CACHEONLY as a 	 * result of UMA_ZONE_VM, which clearly forbids it. 	 */
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
operator|||
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|wastedspace
operator|>=
name|UMA_MAX_WASTE
operator|)
operator|&&
operator|(
name|keg
operator|->
name|uk_ipers
operator|<
operator|(
name|UMA_SLAB_SIZE
operator|/
name|keg
operator|->
name|uk_rsize
operator|)
operator|)
condition|)
block|{
name|keg
operator|->
name|uk_ipers
operator|=
name|UMA_SLAB_SIZE
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|<=
literal|255
argument_list|,
operator|(
literal|"keg_small_init: keg->uk_ipers too high!"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA decided we need offpage slab headers for "
literal|"keg: %s, calculated wastedspace = %d, "
literal|"maximum wasted space allowed = %d, "
literal|"calculated ipers = %d, "
literal|"new wasted space = %d\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|wastedspace
argument_list|,
name|UMA_MAX_WASTE
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|UMA_SLAB_SIZE
operator|-
name|keg
operator|->
name|uk_ipers
operator|*
name|keg
operator|->
name|uk_rsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
expr_stmt|;
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|==
literal|0
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_HASH
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Finish creating a large (> UMA_SLAB_SIZE) uma kegs.  Just give in and do  * OFFPAGE for now.  When I can allow for more dynamic slab sizes this will be  * more complicated.  *  * Arguments  *	keg  The keg we should initialize  *  * Returns  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|keg_large_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|int
name|pages
decl_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Keg is null in keg_large_init"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"keg_large_init: Cannot large-init a UMA_ZFLAG_CACHEONLY keg"
operator|)
argument_list|)
expr_stmt|;
name|pages
operator|=
name|keg
operator|->
name|uk_size
operator|/
name|UMA_SLAB_SIZE
expr_stmt|;
comment|/* Account for remainder */
if|if
condition|(
operator|(
name|pages
operator|*
name|UMA_SLAB_SIZE
operator|)
operator|<
name|keg
operator|->
name|uk_size
condition|)
name|pages
operator|++
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
name|pages
expr_stmt|;
name|keg
operator|->
name|uk_ipers
operator|=
literal|1
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
expr_stmt|;
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|==
literal|0
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_HASH
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keg_cachespread_init
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|int
name|alignsize
decl_stmt|;
name|int
name|trailer
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|int
name|rsize
decl_stmt|;
name|alignsize
operator|=
name|keg
operator|->
name|uk_align
operator|+
literal|1
expr_stmt|;
name|rsize
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
comment|/* 	 * We want one item to start on every align boundary in a page.  To 	 * do this we will span pages.  We will also extend the item by the 	 * size of align if it is an even multiple of align.  Otherwise, it 	 * would fall on the same boundary every time. 	 */
if|if
condition|(
name|rsize
operator|&
name|keg
operator|->
name|uk_align
condition|)
name|rsize
operator|=
operator|(
name|rsize
operator|&
operator|~
name|keg
operator|->
name|uk_align
operator|)
operator|+
name|alignsize
expr_stmt|;
if|if
condition|(
operator|(
name|rsize
operator|&
name|alignsize
operator|)
operator|==
literal|0
condition|)
name|rsize
operator|+=
name|alignsize
expr_stmt|;
name|trailer
operator|=
name|rsize
operator|-
name|keg
operator|->
name|uk_size
expr_stmt|;
name|pages
operator|=
operator|(
name|rsize
operator|*
operator|(
name|PAGE_SIZE
operator|/
name|alignsize
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
name|pages
operator|=
name|MIN
argument_list|(
name|pages
argument_list|,
operator|(
literal|128
operator|*
literal|1024
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_rsize
operator|=
name|rsize
expr_stmt|;
name|keg
operator|->
name|uk_ppera
operator|=
name|pages
expr_stmt|;
name|keg
operator|->
name|uk_ipers
operator|=
operator|(
operator|(
name|pages
operator|*
name|PAGE_SIZE
operator|)
operator|+
name|trailer
operator|)
operator|/
name|rsize
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_OFFPAGE
operator||
name|UMA_ZONE_VTOSLAB
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_ipers
operator|<=
name|uma_max_ipers
argument_list|,
operator|(
literal|"keg_small_init: keg->uk_ipers too high(%d) increase max_ipers"
operator|,
name|keg
operator|->
name|uk_ipers
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keg header ctor.  This initializes all fields, locks, etc.  And inserts  * the keg onto the global keg list.  *  * Arguments/Returns follow uma_ctor specifications  *	udata  Actually uma_kctor_args  */
end_comment

begin_function
specifier|static
name|int
name|keg_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_kctor_args
modifier|*
name|arg
init|=
name|udata
decl_stmt|;
name|uma_keg_t
name|keg
init|=
name|mem
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|bzero
argument_list|(
name|keg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|keg
operator|->
name|uk_init
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|keg
operator|->
name|uk_fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|keg
operator|->
name|uk_align
operator|=
name|arg
operator|->
name|align
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_pages
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator|=
name|arg
operator|->
name|flags
expr_stmt|;
name|keg
operator|->
name|uk_allocf
operator|=
name|page_alloc
expr_stmt|;
name|keg
operator|->
name|uk_freef
operator|=
name|page_free
expr_stmt|;
name|keg
operator|->
name|uk_recurse
operator|=
literal|0
expr_stmt|;
name|keg
operator|->
name|uk_slabzone
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The master zone is passed to us at keg-creation time. 	 */
name|zone
operator|=
name|arg
operator|->
name|zone
expr_stmt|;
name|keg
operator|->
name|uk_name
operator|=
name|zone
operator|->
name|uz_name
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_VM
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZFLAG_CACHEONLY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_ZINIT
condition|)
name|keg
operator|->
name|uk_init
operator|=
name|zero_init
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_REFCNT
operator|||
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_VTOSLAB
expr_stmt|;
comment|/* 	 * The +UMA_FRITM_SZ added to uk_size is to account for the 	 * linkage that is added to the size in keg_small_init().  If 	 * we don't account for this here then we may end up in 	 * keg_small_init() with a calculated 'ipers' of 0. 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_CACHESPREAD
condition|)
name|keg_cachespread_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_size
operator|+
name|UMA_FRITMREF_SZ
operator|)
operator|>
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
operator|)
condition|)
name|keg_large_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
else|else
name|keg_small_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_CACHESPREAD
condition|)
name|keg_cachespread_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_size
operator|+
name|UMA_FRITM_SZ
operator|)
operator|>
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|)
condition|)
name|keg_large_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
else|else
name|keg_small_init
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
name|keg
operator|->
name|uk_slabzone
operator|=
name|slabrefzone
expr_stmt|;
else|else
name|keg
operator|->
name|uk_slabzone
operator|=
name|slabzone
expr_stmt|;
block|}
comment|/* 	 * If we haven't booted yet we need allocations to go through the 	 * startup cache until the vm is ready. 	 */
if|if
condition|(
name|keg
operator|->
name|uk_ppera
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_MD_SMALL_ALLOC
name|keg
operator|->
name|uk_allocf
operator|=
name|uma_small_alloc
expr_stmt|;
name|keg
operator|->
name|uk_freef
operator|=
name|uma_small_free
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|booted
operator|==
literal|0
condition|)
name|keg
operator|->
name|uk_allocf
operator|=
name|startup_alloc
expr_stmt|;
block|}
comment|/* 	 * Initialize keg's lock (shared among zones). 	 */
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_MTXCLASS
condition|)
name|KEG_LOCK_INIT
argument_list|(
name|keg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|KEG_LOCK_INIT
argument_list|(
name|keg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If we're putting the slab header in the actual page we need to 	 * figure out where in each page it goes.  This calculates a right 	 * justified offset into the memory on an ALIGN_PTR boundary. 	 */
if|if
condition|(
operator|!
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_OFFPAGE
operator|)
condition|)
block|{
name|u_int
name|totsize
decl_stmt|;
comment|/* Size of the slab struct and free list */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
name|totsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
operator|+
name|keg
operator|->
name|uk_ipers
operator|*
name|UMA_FRITMREF_SZ
expr_stmt|;
else|else
name|totsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|+
name|keg
operator|->
name|uk_ipers
operator|*
name|UMA_FRITM_SZ
expr_stmt|;
if|if
condition|(
name|totsize
operator|&
name|UMA_ALIGN_PTR
condition|)
name|totsize
operator|=
operator|(
name|totsize
operator|&
operator|~
name|UMA_ALIGN_PTR
operator|)
operator|+
operator|(
name|UMA_ALIGN_PTR
operator|+
literal|1
operator|)
expr_stmt|;
name|keg
operator|->
name|uk_pgoff
operator|=
name|UMA_SLAB_SIZE
operator|-
name|totsize
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
name|totsize
operator|=
name|keg
operator|->
name|uk_pgoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
operator|+
name|keg
operator|->
name|uk_ipers
operator|*
name|UMA_FRITMREF_SZ
expr_stmt|;
else|else
name|totsize
operator|=
name|keg
operator|->
name|uk_pgoff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|+
name|keg
operator|->
name|uk_ipers
operator|*
name|UMA_FRITM_SZ
expr_stmt|;
comment|/* 		 * The only way the following is possible is if with our 		 * UMA_ALIGN_PTR adjustments we are now bigger than 		 * UMA_SLAB_SIZE.  I haven't checked whether this is 		 * mathematically possible for all cases, so we make 		 * sure here anyway. 		 */
if|if
condition|(
name|totsize
operator|>
name|UMA_SLAB_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"zone %s ipers %d rsize %d size %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|keg
operator|->
name|uk_rsize
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"UMA slab won't fit."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_HASH
condition|)
name|hash_alloc
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA: %s(%p) size %d(%d) flags %d ipers %d ppera %d out %d free %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|,
name|keg
operator|->
name|uk_rsize
argument_list|,
name|keg
operator|->
name|uk_flags
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|keg
operator|->
name|uk_ppera
argument_list|,
operator|(
name|keg
operator|->
name|uk_ipers
operator|*
name|keg
operator|->
name|uk_pages
operator|)
operator|-
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_zones
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_kegs
argument_list|,
name|keg
argument_list|,
name|uk_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zone header ctor.  This initializes all fields, locks, etc.  *  * Arguments/Returns follow uma_ctor specifications  *	udata  Actually uma_zctor_args  */
end_comment

begin_function
specifier|static
name|int
name|zone_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
modifier|*
name|arg
init|=
name|udata
decl_stmt|;
name|uma_zone_t
name|zone
init|=
name|mem
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|bzero
argument_list|(
name|zone
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_name
operator|=
name|arg
operator|->
name|name
expr_stmt|;
name|zone
operator|->
name|uz_ctor
operator|=
name|arg
operator|->
name|ctor
expr_stmt|;
name|zone
operator|->
name|uz_dtor
operator|=
name|arg
operator|->
name|dtor
expr_stmt|;
name|zone
operator|->
name|uz_slab
operator|=
name|zone_fetch_slab
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_allocs
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_frees
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_fails
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_sleeps
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_fills
operator|=
name|zone
operator|->
name|uz_count
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|=
literal|0
expr_stmt|;
name|keg
operator|=
name|arg
operator|->
name|keg
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|UMA_ZONE_SECONDARY
condition|)
block|{
name|KASSERT
argument_list|(
name|arg
operator|->
name|keg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Secondary zone on zero'd keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|zone
operator|->
name|uz_lock
operator|=
operator|&
name|keg
operator|->
name|uk_lock
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZONE_SECONDARY
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&keg->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|z
argument_list|,
name|uz_link
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|z
argument_list|,
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|keg
operator|=
name|uma_kcreate
argument_list|(
name|zone
argument_list|,
name|arg
operator|->
name|size
argument_list|,
name|arg
operator|->
name|uminit
argument_list|,
name|arg
operator|->
name|fini
argument_list|,
name|arg
operator|->
name|align
argument_list|,
name|arg
operator|->
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|else
block|{
name|struct
name|uma_kctor_args
name|karg
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* We should only be here from uma_startup() */
name|karg
operator|.
name|size
operator|=
name|arg
operator|->
name|size
expr_stmt|;
name|karg
operator|.
name|uminit
operator|=
name|arg
operator|->
name|uminit
expr_stmt|;
name|karg
operator|.
name|fini
operator|=
name|arg
operator|->
name|fini
expr_stmt|;
name|karg
operator|.
name|align
operator|=
name|arg
operator|->
name|align
expr_stmt|;
name|karg
operator|.
name|flags
operator|=
name|arg
operator|->
name|flags
expr_stmt|;
name|karg
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|error
operator|=
name|keg_ctor
argument_list|(
name|arg
operator|->
name|keg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_keg
argument_list|)
argument_list|,
operator|&
name|karg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Link in the first keg. 	 */
name|zone
operator|->
name|uz_klink
operator|.
name|kl_keg
operator|=
name|keg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|,
operator|&
name|zone
operator|->
name|uz_klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_lock
operator|=
operator|&
name|keg
operator|->
name|uk_lock
expr_stmt|;
name|zone
operator|->
name|uz_size
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
operator|(
name|keg
operator|->
name|uk_flags
operator|&
operator|(
name|UMA_ZONE_INHERIT
operator||
name|UMA_ZFLAG_INHERIT
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Some internal zones don't have room allocated for the per cpu 	 * caches.  If we're internal, bail out here. 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Secondary zone requested UMA_ZFLAG_INTERNAL"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_MAXBUCKET
condition|)
name|zone
operator|->
name|uz_count
operator|=
name|BUCKET_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|keg
operator|->
name|uk_ipers
operator|<=
name|BUCKET_MAX
condition|)
name|zone
operator|->
name|uz_count
operator|=
name|keg
operator|->
name|uk_ipers
expr_stmt|;
else|else
name|zone
operator|->
name|uz_count
operator|=
name|BUCKET_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Keg header dtor.  This frees all data, destroys locks, frees the hash  * table and removes the keg from the global list.  *  * Arguments/Returns follow uma_dtor specifications  *	udata  unused  */
end_comment

begin_function
specifier|static
name|void
name|keg_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
operator|(
name|uma_keg_t
operator|)
name|arg
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Freed UMA keg was not empty (%d items). "
literal|" Lost %d pages of memory.\n"
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_pages
argument_list|)
expr_stmt|;
block|}
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|)
expr_stmt|;
name|KEG_LOCK_FINI
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zone header dtor.  *  * Arguments/Returns follow uma_dtor specifications  *	udata  unused  */
end_comment

begin_function
specifier|static
name|void
name|zone_dtor
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|zone
operator|=
operator|(
name|uma_zone_t
operator|)
name|arg
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
name|cache_drain
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|zone
argument_list|,
name|uz_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * XXX there are some races here where 	 * the zone can be drained but zone lock 	 * released and then refilled before we 	 * remove it... we dont care for now 	 */
name|zone_drain_wait
argument_list|(
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Unlink all of our kegs. 	 */
while|while
condition|(
operator|(
name|klink
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_kegs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|klink
operator|->
name|kl_keg
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|klink
operator|==
operator|&
name|zone
operator|->
name|uz_klink
condition|)
continue|continue;
name|free
argument_list|(
name|klink
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only destroy kegs from non secondary zones. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|keg
argument_list|,
name|uk_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|kegs
argument_list|,
name|keg
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Traverses every zone in the system and calls a callback  *  * Arguments:  *	zfunc  A pointer to a function which accepts a zone  *		as an argument.  *  * Returns:  *	Nothing  */
end_comment

begin_function
specifier|static
name|void
name|zone_foreach
parameter_list|(
name|void
function_decl|(
modifier|*
name|zfunc
function_decl|)
parameter_list|(
name|uma_zone_t
parameter_list|)
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|keg
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|zone
argument_list|,
argument|&keg->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|zfunc
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public functions */
end_comment

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_startup
parameter_list|(
name|void
modifier|*
name|bootmem
parameter_list|,
name|int
name|boot_pages
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int
name|slabsize
decl_stmt|;
name|u_int
name|objsize
decl_stmt|,
name|totsize
decl_stmt|,
name|wsize
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Creating uma keg headers zone and keg.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|uma_mtx
argument_list|,
literal|"UMA lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the maximum number of items-per-slab we'll have if 	 * we're using the OFFPAGE slab header to track free items, given 	 * all possible object sizes and the maximum desired wastage 	 * (UMA_MAX_WASTE). 	 * 	 * We iterate until we find an object size for 	 * which the calculated wastage in keg_small_init() will be 	 * enough to warrant OFFPAGE.  Since wastedspace versus objsize 	 * is an overall increasing see-saw function, we find the smallest 	 * objsize such that the wastage is always acceptable for objects 	 * with that objsize or smaller.  Since a smaller objsize always 	 * generates a larger possible uma_max_ipers, we use this computed 	 * objsize to calculate the largest ipers possible.  Since the 	 * ipers calculated for OFFPAGE slab headers is always larger than 	 * the ipers initially calculated in keg_small_init(), we use 	 * the former's equation (UMA_SLAB_SIZE / keg->uk_rsize) to 	 * obtain the maximum ipers possible for offpage slab headers. 	 * 	 * It should be noted that ipers versus objsize is an inversly 	 * proportional function which drops off rather quickly so as 	 * long as our UMA_MAX_WASTE is such that the objsize we calculate 	 * falls into the portion of the inverse relation AFTER the steep 	 * falloff, then uma_max_ipers shouldn't be too high (~10 on i386). 	 * 	 * Note that we have 8-bits (1 byte) to use as a freelist index 	 * inside the actual slab header itself and this is enough to 	 * accomodate us.  In the worst case, a UMA_SMALLEST_UNIT sized 	 * object with offpage slab header would have ipers = 	 * UMA_SLAB_SIZE / UMA_SMALLEST_UNIT (currently = 256), which is 	 * 1 greater than what our byte-integer freelist index can 	 * accomodate, but we know that this situation never occurs as 	 * for UMA_SMALLEST_UNIT-sized objects, we will never calculate 	 * that we need to go to offpage slab headers.  Or, if we do, 	 * then we trap that condition below and panic in the INVARIANTS case. 	 */
name|wsize
operator|=
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|-
name|UMA_MAX_WASTE
expr_stmt|;
name|totsize
operator|=
name|wsize
expr_stmt|;
name|objsize
operator|=
name|UMA_SMALLEST_UNIT
expr_stmt|;
while|while
condition|(
name|totsize
operator|>=
name|wsize
condition|)
block|{
name|totsize
operator|=
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
operator|)
operator|/
operator|(
name|objsize
operator|+
name|UMA_FRITM_SZ
operator|)
expr_stmt|;
name|totsize
operator|*=
operator|(
name|UMA_FRITM_SZ
operator|+
name|objsize
operator|)
expr_stmt|;
name|objsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|objsize
operator|>
name|UMA_SMALLEST_UNIT
condition|)
name|objsize
operator|--
expr_stmt|;
name|uma_max_ipers
operator|=
name|MAX
argument_list|(
name|UMA_SLAB_SIZE
operator|/
name|objsize
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|wsize
operator|=
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
operator|-
name|UMA_MAX_WASTE
expr_stmt|;
name|totsize
operator|=
name|wsize
expr_stmt|;
name|objsize
operator|=
name|UMA_SMALLEST_UNIT
expr_stmt|;
while|while
condition|(
name|totsize
operator|>=
name|wsize
condition|)
block|{
name|totsize
operator|=
operator|(
name|UMA_SLAB_SIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
operator|)
operator|/
operator|(
name|objsize
operator|+
name|UMA_FRITMREF_SZ
operator|)
expr_stmt|;
name|totsize
operator|*=
operator|(
name|UMA_FRITMREF_SZ
operator|+
name|objsize
operator|)
expr_stmt|;
name|objsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|objsize
operator|>
name|UMA_SMALLEST_UNIT
condition|)
name|objsize
operator|--
expr_stmt|;
name|uma_max_ipers_ref
operator|=
name|MAX
argument_list|(
name|UMA_SLAB_SIZE
operator|/
name|objsize
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|uma_max_ipers_ref
operator|<=
literal|255
operator|)
operator|&&
operator|(
name|uma_max_ipers
operator|<=
literal|255
operator|)
argument_list|,
operator|(
literal|"uma_startup: calculated uma_max_ipers values too large!"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Calculated uma_max_ipers (for OFFPAGE) is %d\n"
argument_list|,
name|uma_max_ipers
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Calculated uma_max_ipers_slab (for OFFPAGE) is %d\n"
argument_list|,
name|uma_max_ipers_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* "manually" create the initial zone */
name|args
operator|.
name|name
operator|=
literal|"UMA Kegs"
expr_stmt|;
name|args
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_keg
argument_list|)
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|keg_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|keg_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zero_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|keg
operator|=
operator|&
name|masterkeg
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|32
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|UMA_ZFLAG_INTERNAL
expr_stmt|;
comment|/* The initial zone has no Per cpu queues so it's smaller */
name|zone_ctor
argument_list|(
name|kegs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Filling boot free list.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|boot_pages
condition|;
name|i
operator|++
control|)
block|{
name|slab
operator|=
call|(
name|uma_slab_t
call|)
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|bootmem
operator|+
operator|(
name|i
operator|*
name|UMA_SLAB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|slab
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|UMA_SLAB_BOOT
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uma_boot_pages
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|uma_boot_pages_mtx
argument_list|,
literal|"UMA boot pages"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Creating uma zone headers zone and keg.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|.
name|name
operator|=
literal|"UMA Zones"
expr_stmt|;
name|args
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|uma_cache
argument_list|)
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|zone_ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|zone_dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zero_init
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|align
operator|=
literal|32
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|UMA_ZFLAG_INTERNAL
expr_stmt|;
comment|/* The initial zone has no Per cpu queues so it's smaller */
name|zone_ctor
argument_list|(
name|zones
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Initializing pcpu cache locks.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Creating slab and hash zones.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is the max number of free list items we'll have with 	 * offpage slabs. 	 */
name|slabsize
operator|=
name|uma_max_ipers
operator|*
name|UMA_FRITM_SZ
expr_stmt|;
name|slabsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab
argument_list|)
expr_stmt|;
comment|/* Now make a zone for slab headers */
name|slabzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Slabs"
argument_list|,
name|slabsize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
argument_list|)
expr_stmt|;
comment|/* 	 * We also create a zone for the bigger slabs with reference 	 * counts in them, to accomodate UMA_ZONE_REFCNT zones. 	 */
name|slabsize
operator|=
name|uma_max_ipers_ref
operator|*
name|UMA_FRITMREF_SZ
expr_stmt|;
name|slabsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_slab_refcnt
argument_list|)
expr_stmt|;
name|slabrefzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA RCntSlabs"
argument_list|,
name|slabsize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
argument_list|)
expr_stmt|;
name|hashzone
operator|=
name|uma_zcreate
argument_list|(
literal|"UMA Hash"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slabhead
operator|*
argument_list|)
operator|*
name|UMA_HASH_SIZE_INIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZFLAG_INTERNAL
argument_list|)
expr_stmt|;
name|bucket_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UMA_MD_SMALL_ALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UMA_MD_SMALL_ALLOC_NEEDS_VM
argument_list|)
name|booted
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* see uma.h */
end_comment

begin_function
name|void
name|uma_startup2
parameter_list|(
name|void
parameter_list|)
block|{
name|booted
operator|=
literal|1
expr_stmt|;
name|bucket_enable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup2 complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize our callout handle  *  */
end_comment

begin_function
specifier|static
name|void
name|uma_startup3
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"Starting callout.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|uma_callout
argument_list|,
name|UMA_TIMEOUT
operator|*
name|hz
argument_list|,
name|uma_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA startup3 complete.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|uma_keg_t
name|uma_kcreate
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|struct
name|uma_kctor_args
name|args
decl_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|uminit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|fini
expr_stmt|;
name|args
operator|.
name|align
operator|=
operator|(
name|align
operator|==
name|UMA_ALIGN_CACHE
operator|)
condition|?
name|uma_align_cache
else|:
name|align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
return|return
operator|(
name|zone_alloc_item
argument_list|(
name|kegs
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_set_align
parameter_list|(
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|!=
name|UMA_ALIGN_CACHE
condition|)
name|uma_align_cache
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zcreate
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|uminit
parameter_list|,
name|uma_fini
name|fini
parameter_list|,
name|int
name|align
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
comment|/* This stuff is essential for the zone ctor */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|uminit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|fini
expr_stmt|;
name|args
operator|.
name|align
operator|=
name|align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|zone_alloc_item
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|uma_zone_t
name|uma_zsecond_create
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|uma_ctor
name|ctor
parameter_list|,
name|uma_dtor
name|dtor
parameter_list|,
name|uma_init
name|zinit
parameter_list|,
name|uma_fini
name|zfini
parameter_list|,
name|uma_zone_t
name|master
parameter_list|)
block|{
name|struct
name|uma_zctor_args
name|args
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|size
operator|=
name|keg
operator|->
name|uk_size
expr_stmt|;
name|args
operator|.
name|ctor
operator|=
name|ctor
expr_stmt|;
name|args
operator|.
name|dtor
operator|=
name|dtor
expr_stmt|;
name|args
operator|.
name|uminit
operator|=
name|zinit
expr_stmt|;
name|args
operator|.
name|fini
operator|=
name|zfini
expr_stmt|;
name|args
operator|.
name|align
operator|=
name|keg
operator|->
name|uk_align
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|keg
operator|->
name|uk_flags
operator||
name|UMA_ZONE_SECONDARY
expr_stmt|;
name|args
operator|.
name|keg
operator|=
name|keg
expr_stmt|;
comment|/* XXX Attaches only one keg of potentially many. */
return|return
operator|(
name|zone_alloc_item
argument_list|(
name|zones
argument_list|,
operator|&
name|args
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zone_lock_pair
parameter_list|(
name|uma_zone_t
name|a
parameter_list|,
name|uma_zone_t
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
name|b
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|mtx_lock_flags
argument_list|(
name|b
operator|->
name|uz_lock
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZONE_LOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|mtx_lock_flags
argument_list|(
name|a
operator|->
name|uz_lock
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zone_unlock_pair
parameter_list|(
name|uma_zone_t
name|a
parameter_list|,
name|uma_zone_t
name|b
parameter_list|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uma_zsecond_add
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_zone_t
name|master
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|klink
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|klink
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|zone_lock_pair
argument_list|(
name|zone
argument_list|,
name|master
argument_list|)
expr_stmt|;
comment|/* 	 * zone must use vtoslab() to resolve objects and must already be 	 * a secondary. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
operator|(
name|UMA_ZONE_VTOSLAB
operator||
name|UMA_ZONE_SECONDARY
operator|)
operator|)
operator|!=
operator|(
name|UMA_ZONE_VTOSLAB
operator||
name|UMA_ZONE_SECONDARY
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The new master must also use vtoslab(). 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
operator|!=
name|UMA_ZONE_VTOSLAB
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Both must either be refcnt, or not be refcnt. 	 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_REFCNT
operator|)
operator|!=
operator|(
name|master
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_REFCNT
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The underlying object must be the same size.  rsize 	 * may be different. 	 */
if|if
condition|(
name|master
operator|->
name|uz_size
operator|!=
name|zone
operator|->
name|uz_size
condition|)
block|{
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Put it at the end of the list. 	 */
name|klink
operator|->
name|kl_keg
operator|=
name|zone_first_keg
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|kl
argument_list|,
name|kl_link
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|kl
argument_list|,
name|klink
argument_list|,
name|kl_link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|klink
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_MULTI
expr_stmt|;
name|zone
operator|->
name|uz_slab
operator|=
name|zone_fetch_slab_multi
expr_stmt|;
name|out
label|:
name|zone_unlock_pair
argument_list|(
name|zone
argument_list|,
name|master
argument_list|)
expr_stmt|;
if|if
condition|(
name|klink
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|klink
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zdestroy
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|zone_free_item
argument_list|(
name|zones
argument_list|,
name|zone
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
modifier|*
name|uma_zalloc_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* This is the fast path allocation */
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC_1
name|printf
argument_list|(
literal|"Allocating one item from %s(%p)\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR3
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zalloc_arg thread %x zone %s flags %d"
argument_list|,
name|curthread
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"uma_zalloc_arg: zone \"%s\""
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If possible, allocate from the per-CPU cache.  There are two 	 * requirements for safe access to the per-CPU cache: (1) the thread 	 * accessing the cache must not be preempted or yield during access, 	 * and (2) the thread must not migrate CPUs without switching which 	 * cache it accesses.  We rely on a critical section to prevent 	 * preemption and migration.  We release the critical section in 	 * order to acquire the zone mutex if we are unable to allocate from 	 * the current cache; when we re-acquire the critical section, we 	 * must detect and handle migration if it has occurred. 	 */
name|zalloc_restart
label|:
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zalloc_start
label|:
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|bucket
operator|->
name|ub_cnt
operator|--
expr_stmt|;
name|item
operator|=
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uma_zalloc: Bucket pointer mangled."
operator|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|++
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|uma_dbg_alloc
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|,
name|ZFREE_STATFAIL
operator||
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|M_ZERO
condition|)
name|bzero
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
condition|)
block|{
comment|/* 			 * We have run out of items in our allocbucket. 			 * See if we can switch with our free bucket. 			 */
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zalloc: Swapping empty with"
literal|" alloc.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
block|}
block|}
comment|/* 	 * Attempt to retrieve the item from the per-CPU cache has failed, so 	 * we must go back to the zone.  This requires the zone lock, so we 	 * must drop the critical section, then re-acquire it when we go back 	 * to the cache.  Since the critical section is released, we may be 	 * preempted or migrate.  As such, make sure not to maintain any 	 * thread-local state specific to the cache from prior to releasing 	 * the critical section. 	 */
name|critical_exit
argument_list|()
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|bucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|>
literal|0
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
block|}
comment|/* Since we have locked the zone we may as well send back our stats */
name|zone
operator|->
name|uz_allocs
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_frees
operator|+=
name|cache
operator|->
name|uc_frees
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|=
literal|0
expr_stmt|;
comment|/* Our old one is now a free bucket */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
block|{
name|KASSERT
argument_list|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zalloc_arg: Freeing a non free bucket."
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check the free list for a new alloc bucket */
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
argument_list|,
operator|(
literal|"uma_zalloc_arg: Returning an empty bucket."
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_start
goto|;
block|}
comment|/* We are no longer associated with this CPU. */
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* Bump up our uz_count so we get here less */
if|if
condition|(
name|zone
operator|->
name|uz_count
operator|<
name|BUCKET_MAX
condition|)
name|zone
operator|->
name|uz_count
operator|++
expr_stmt|;
comment|/* 	 * Now lets just fill a bucket and put it on the free list.  If that 	 * works we'll restart the allocation from the begining. 	 */
if|if
condition|(
name|zone_alloc_bucket
argument_list|(
name|zone
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zalloc_restart
goto|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * We may not be able to get a bucket so return an actual item. 	 */
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"uma_zalloc_arg: Bucketzone returned NULL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|item
operator|=
name|zone_alloc_item
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uma_slab_t
name|keg_fetch_slab
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Find a slab with some space.  Prefer slabs that are partially 		 * used over those that are totally full.  This helps to reduce 		 * fragmentation. 		 */
if|if
condition|(
name|keg
operator|->
name|uk_free
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|)
condition|)
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slab
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
comment|/* 		 * M_NOVM means don't ask at all! 		 */
if|if
condition|(
name|flags
operator|&
name|M_NOVM
condition|)
break|break;
if|if
condition|(
name|keg
operator|->
name|uk_maxpages
operator|&&
name|keg
operator|->
name|uk_pages
operator|>=
name|keg
operator|->
name|uk_maxpages
condition|)
block|{
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
comment|/* 			 * If this is not a multi-zone, set the FULL bit. 			 * Otherwise slab_multi() takes care of it. 			 */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_MULTI
operator|)
operator|==
literal|0
condition|)
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|M_NOWAIT
condition|)
break|break;
name|msleep
argument_list|(
name|keg
argument_list|,
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|PVM
argument_list|,
literal|"keglimit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|keg
operator|->
name|uk_recurse
operator|++
expr_stmt|;
name|slab
operator|=
name|keg_alloc_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_recurse
operator|--
expr_stmt|;
comment|/* 		 * If we got a slab here it's safe to mark it partially used 		 * and return.  We assume that the caller is going to remove 		 * at least one item. 		 */
if|if
condition|(
name|slab
condition|)
block|{
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|slab
operator|)
return|;
block|}
comment|/* 		 * We might not have been able to get a slab but another cpu 		 * could have while we were unlocked.  Check again before we 		 * fail. 		 */
name|flags
operator||=
name|M_NOVM
expr_stmt|;
block|}
return|return
operator|(
name|slab
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|zone_relock
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|keg
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_lock
operator|!=
operator|&
name|keg
operator|->
name|uk_lock
condition|)
block|{
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|keg_relock
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_lock
operator|!=
operator|&
name|keg
operator|->
name|uk_lock
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KEG_LOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uma_slab_t
name|zone_fetch_slab
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|keg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
if|if
condition|(
name|keg
operator|==
name|NULL
condition|)
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * This is to prevent us from recursively trying to allocate 	 * buckets.  The problem is that if an allocation forces us to 	 * grab a new bucket we will call page_alloc, which will go off 	 * and cause the vm to allocate vm_map_entries.  If we need new 	 * buckets there too we will recurse in kmem_alloc and bad 	 * things happen.  So instead we return a NULL bucket, and make 	 * the code that allocates buckets smart enough to deal with it 	 */
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_BUCKET
operator|&&
name|keg
operator|->
name|uk_recurse
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_NOVM
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * uma_zone_fetch_slab_multi:  Fetches a slab from one available keg.  Returns  * with the keg locked.  Caller must call zone_relock() afterwards if the  * zone lock is required.  On NULL the zone lock is held.  *  * The last pointer is used to seed the search.  It is not required.  */
end_comment

begin_function
specifier|static
name|uma_slab_t
name|zone_fetch_slab_multi
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_keg_t
name|last
parameter_list|,
name|int
name|rflags
parameter_list|)
block|{
name|uma_klink_t
name|klink
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|full
decl_stmt|;
comment|/* 	 * Don't wait on the first pass.  This will skip limit tests 	 * as well.  We don't want to block if we can find a provider 	 * without blocking. 	 */
name|flags
operator|=
operator|(
name|rflags
operator|&
operator|~
name|M_WAITOK
operator|)
operator||
name|M_NOWAIT
expr_stmt|;
comment|/* 	 * Use the last slab allocated as a hint for where to start 	 * the search. 	 */
if|if
condition|(
name|last
condition|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|last
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
name|zone_relock
argument_list|(
name|zone
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Loop until we have a slab incase of transient failures 	 * while M_WAITOK is specified.  I'm not sure this is 100% 	 * required but we've done it for so long now. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Search the available kegs for slabs.  Be careful to hold the 		 * correct lock while calling into the keg layer. 		 */
name|LIST_FOREACH
argument_list|(
argument|klink
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
name|keg
operator|=
name|klink
operator|->
name|kl_keg
expr_stmt|;
name|keg_relock
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
operator|==
literal|0
condition|)
block|{
name|slab
operator|=
name|keg_fetch_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
condition|)
return|return
operator|(
name|slab
operator|)
return|;
block|}
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
name|full
operator|++
expr_stmt|;
else|else
name|empty
operator|++
expr_stmt|;
name|zone_relock
argument_list|(
name|zone
argument_list|,
name|keg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rflags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_NOVM
operator|)
condition|)
break|break;
name|flags
operator|=
name|rflags
expr_stmt|;
comment|/* 		 * All kegs are full.  XXX We can't atomically check all kegs 		 * and sleep so just sleep for a short period and retry. 		 */
if|if
condition|(
name|full
operator|&&
operator|!
name|empty
condition|)
block|{
name|zone
operator|->
name|uz_flags
operator||=
name|UMA_ZFLAG_FULL
expr_stmt|;
name|zone
operator|->
name|uz_sleeps
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|uz_lock
argument_list|,
name|PVM
argument_list|,
literal|"zonelimit"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|slab_alloc_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|uma_slabrefcnt_t
name|slabref
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
name|u_int8_t
name|freei
decl_stmt|;
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|keg
operator|->
name|uk_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|freei
operator|=
name|slab
operator|->
name|us_firstfree
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
block|{
name|slabref
operator|=
operator|(
name|uma_slabrefcnt_t
operator|)
name|slab
expr_stmt|;
name|slab
operator|->
name|us_firstfree
operator|=
name|slabref
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|.
name|us_item
expr_stmt|;
block|}
else|else
block|{
name|slab
operator|->
name|us_firstfree
operator|=
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|.
name|us_item
expr_stmt|;
block|}
name|item
operator|=
name|slab
operator|->
name|us_data
operator|+
operator|(
name|keg
operator|->
name|uk_rsize
operator|*
name|freei
operator|)
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|--
expr_stmt|;
name|keg
operator|->
name|uk_free
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|uma_dbg_alloc
argument_list|(
name|zone
argument_list|,
name|slab
argument_list|,
name|item
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Move this slab to the full list */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_full_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zone_alloc_bucket
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_bucket_t
name|bucket
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|int16_t
name|saved
decl_stmt|;
name|int
name|max
decl_stmt|,
name|origflags
init|=
name|flags
decl_stmt|;
comment|/* 	 * Try this zone's free list first so we don't allocate extra buckets. 	 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"zone_alloc_bucket: Bucket on free list is not empty."
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|bflags
decl_stmt|;
name|bflags
operator|=
operator|(
name|flags
operator|&
operator|~
name|M_ZERO
operator|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
condition|)
name|bflags
operator||=
name|M_NOVM
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|bucket_alloc
argument_list|(
name|zone
operator|->
name|uz_count
argument_list|,
name|bflags
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * This code is here to limit the number of simultaneous bucket fills 	 * for any given zone to the number of per cpu caches in this zone. This 	 * is done so that we don't allocate more memory than we really need. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_fills
operator|>=
name|mp_ncpus
condition|)
goto|goto
name|done
goto|;
endif|#
directive|endif
name|zone
operator|->
name|uz_fills
operator|++
expr_stmt|;
name|max
operator|=
name|MIN
argument_list|(
name|bucket
operator|->
name|ub_entries
argument_list|,
name|zone
operator|->
name|uz_count
argument_list|)
expr_stmt|;
comment|/* Try to keep the buckets totally full */
name|saved
operator|=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|slab
operator|=
name|NULL
expr_stmt|;
name|keg
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|bucket
operator|->
name|ub_cnt
operator|<
name|max
operator|&&
operator|(
name|slab
operator|=
name|zone
operator|->
name|uz_slab
argument_list|(
name|zone
argument_list|,
name|keg
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
while|while
condition|(
name|slab
operator|->
name|us_freecount
operator|&&
name|bucket
operator|->
name|ub_cnt
operator|<
name|max
condition|)
block|{
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
operator|++
index|]
operator|=
name|slab_alloc_item
argument_list|(
name|zone
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
comment|/* Don't block on the next fill */
name|flags
operator||=
name|M_NOWAIT
expr_stmt|;
block|}
if|if
condition|(
name|slab
condition|)
name|zone_relock
argument_list|(
name|zone
argument_list|,
name|keg
argument_list|)
expr_stmt|;
comment|/* 	 * We unlock here because we need to call the zone's init. 	 * It should be safe to unlock because the slab dealt with 	 * above is already on the appropriate list within the keg 	 * and the bucket we filled is not yet on any list, so we 	 * own it. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_init
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|saved
init|;
name|i
operator|<
name|bucket
operator|->
name|ub_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|zone
operator|->
name|uz_init
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|i
index|]
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|origflags
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * If we couldn't initialize the whole bucket, put the 		 * rest back onto the freelist. 		 */
if|if
condition|(
name|i
operator|!=
name|bucket
operator|->
name|ub_cnt
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|bucket
operator|->
name|ub_cnt
condition|;
name|j
operator|++
control|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|bucket
operator|->
name|ub_bucket
index|[
name|j
index|]
argument_list|,
name|NULL
argument_list|,
name|SKIP_FINI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bucket
operator|->
name|ub_bucket
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|bucket
operator|->
name|ub_cnt
operator|=
name|i
expr_stmt|;
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|uz_fills
operator|--
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMP
name|done
label|:
endif|#
directive|endif
name|bucket_free
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates an item for an internal zone  *  * Arguments  *	zone   The zone to alloc for.  *	udata  The data to be passed to the constructor.  *	flags  M_WAITOK, M_NOWAIT, M_ZERO.  *  * Returns  *	NULL if there is no memory and M_NOWAIT is set  *	An item if successful  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zone_alloc_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"INTERNAL: Allocating one item from %s(%p)\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|slab
operator|=
name|zone
operator|->
name|uz_slab
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|zone
operator|->
name|uz_fails
operator|++
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|item
operator|=
name|slab_alloc_item
argument_list|(
name|zone
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|zone_relock
argument_list|(
name|zone
argument_list|,
name|slab
operator|->
name|us_keg
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_allocs
operator|++
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* 	 * We have to call both the zone's init (not the keg's init) 	 * and the zone's ctor.  This is because the item is going from 	 * a keg slab directly to the user, and the user is expecting it 	 * to be both zone-init'd as well as zone-ctor'd. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_init
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_init
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_FINI
argument_list|,
name|ZFREE_STATFAIL
operator||
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zone
operator|->
name|uz_ctor
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|uz_ctor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|,
name|ZFREE_STATFAIL
operator||
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|M_ZERO
condition|)
name|bzero
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zfree_arg
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|int
name|bflags
decl_stmt|;
name|int
name|cpu
decl_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC_1
name|printf
argument_list|(
literal|"Freeing item %p to %s(%p)\n"
argument_list|,
name|item
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CTR2
argument_list|(
name|KTR_UMA
argument_list|,
literal|"uma_zfree_arg thread %x zone %s"
argument_list|,
name|curthread
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_dtor
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_MALLOC
condition|)
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|udata
argument_list|,
name|item
argument_list|)
expr_stmt|;
else|else
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The race here is acceptable.  If we miss it we'll just have to wait 	 * a little longer for the limits to be reset. 	 */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
goto|goto
name|zfree_internal
goto|;
comment|/* 	 * If possible, free to the per-CPU cache.  There are two 	 * requirements for safe access to the per-CPU cache: (1) the thread 	 * accessing the cache must not be preempted or yield during access, 	 * and (2) the thread must not migrate CPUs without switching which 	 * cache it accesses.  We rely on a critical section to prevent 	 * preemption and migration.  We release the critical section in 	 * order to acquire the zone mutex if we are unable to free to the 	 * current cache; when we re-acquire the critical section, we must 	 * detect and handle migration if it has occurred. 	 */
name|zfree_restart
label|:
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|zfree_start
label|:
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
comment|/* 		 * Do we have room in our bucket? It is OK for this uz count 		 * check to be slightly out of sync. 		 */
if|if
condition|(
name|bucket
operator|->
name|ub_cnt
operator|<
name|bucket
operator|->
name|ub_entries
condition|)
block|{
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"uma_zfree: Freeing to non free bucket index."
operator|)
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|ub_bucket
index|[
name|bucket
operator|->
name|ub_cnt
index|]
operator|=
name|item
expr_stmt|;
name|bucket
operator|->
name|ub_cnt
operator|++
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|++
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Swapping buckets.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * We have run out of space in our freebucket. 			 * See if we can switch with our alloc bucket. 			 */
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
operator|<
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
condition|)
block|{
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|cache
operator|->
name|uc_allocbucket
expr_stmt|;
name|cache
operator|->
name|uc_allocbucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
block|}
block|}
comment|/* 	 * We can get here for two reasons: 	 * 	 * 1) The buckets are NULL 	 * 2) The alloc and free buckets are both somewhat full. 	 * 	 * We must go back the zone, which requires acquiring the zone lock, 	 * which in turn means we must release and re-acquire the critical 	 * section.  Since the critical section is released, we may be 	 * preempted or migrate.  As such, make sure not to maintain any 	 * thread-local state specific to the cache from prior to releasing 	 * the critical section. 	 */
name|critical_exit
argument_list|()
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
operator|<
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_entries
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
operator|&&
operator|(
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
operator|<
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
operator|)
condition|)
block|{
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
block|}
comment|/* Since we have locked the zone we may as well send back our stats */
name|zone
operator|->
name|uz_allocs
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|cache
operator|->
name|uc_allocs
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|uz_frees
operator|+=
name|cache
operator|->
name|uc_frees
expr_stmt|;
name|cache
operator|->
name|uc_frees
operator|=
literal|0
expr_stmt|;
name|bucket
operator|=
name|cache
operator|->
name|uc_freebucket
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|NULL
expr_stmt|;
comment|/* Can we throw this on the zone full list? */
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Putting old bucket on the free list.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ub_cnt is pointing to the last free item */
name|KASSERT
argument_list|(
name|bucket
operator|->
name|ub_cnt
operator|!=
literal|0
argument_list|,
operator|(
literal|"uma_zfree: Attempting to insert an empty bucket onto the full list.\n"
operator|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_full_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bucket
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|cache
operator|->
name|uc_freebucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|zfree_start
goto|;
block|}
comment|/* We are no longer associated with this CPU. */
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* And the zone.. */
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMA_DEBUG_ALLOC
name|printf
argument_list|(
literal|"uma_zfree: Allocating new free bucket.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bflags
operator|=
name|M_NOWAIT
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_CACHEONLY
condition|)
name|bflags
operator||=
name|M_NOVM
expr_stmt|;
name|bucket
operator|=
name|bucket_alloc
argument_list|(
name|zone
operator|->
name|uz_count
argument_list|,
name|bflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zone
operator|->
name|uz_free_bucket
argument_list|,
name|bucket
argument_list|,
name|ub_link
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|zfree_restart
goto|;
block|}
comment|/* 	 * If nothing else caught this, we'll just do an internal free. 	 */
name|zfree_internal
label|:
name|zone_free_item
argument_list|(
name|zone
argument_list|,
name|item
argument_list|,
name|udata
argument_list|,
name|SKIP_DTOR
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Frees an item to an INTERNAL zone or allocates a free bucket  *  * Arguments:  *	zone   The zone to free to  *	item   The item we're freeing  *	udata  User supplied data for the dtor  *	skip   Skip dtors and finis  */
end_comment

begin_function
specifier|static
name|void
name|zone_free_item
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|enum
name|zfreeskip
name|skip
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_slabrefcnt_t
name|slabref
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|u_int8_t
modifier|*
name|mem
decl_stmt|;
name|u_int8_t
name|freei
decl_stmt|;
name|int
name|clearfull
decl_stmt|;
if|if
condition|(
name|skip
operator|<
name|SKIP_DTOR
operator|&&
name|zone
operator|->
name|uz_dtor
condition|)
name|zone
operator|->
name|uz_dtor
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|udata
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
name|SKIP_FINI
operator|&&
name|zone
operator|->
name|uz_fini
condition|)
name|zone
operator|->
name|uz_fini
argument_list|(
name|item
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZFREE_STATFAIL
condition|)
name|zone
operator|->
name|uz_fails
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZFREE_STATFREE
condition|)
name|zone
operator|->
name|uz_frees
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_VTOSLAB
operator|)
condition|)
block|{
name|mem
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
operator|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Must only be one. */
if|if
condition|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_HASH
condition|)
block|{
name|slab
operator|=
name|hash_sfind
argument_list|(
operator|&
name|keg
operator|->
name|uk_hash
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mem
operator|+=
name|keg
operator|->
name|uk_pgoff
expr_stmt|;
name|slab
operator|=
operator|(
name|uma_slab_t
operator|)
name|mem
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This prevents redundant lookups via free(). */
if|if
condition|(
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_MALLOC
operator|)
operator|&&
name|udata
operator|!=
name|NULL
condition|)
name|slab
operator|=
operator|(
name|uma_slab_t
operator|)
name|udata
expr_stmt|;
else|else
name|slab
operator|=
name|vtoslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|item
argument_list|)
expr_stmt|;
name|keg
operator|=
name|slab
operator|->
name|us_keg
expr_stmt|;
name|keg_relock
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|keg
operator|==
name|slab
operator|->
name|us_keg
argument_list|)
expr_stmt|;
comment|/* Do we need to remove from any lists? */
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|+
literal|1
operator|==
name|keg
operator|->
name|uk_ipers
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slab
operator|->
name|us_freecount
operator|==
literal|0
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_part_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
block|}
comment|/* Slab management stuff */
name|freei
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|-
operator|(
name|unsigned
name|long
operator|)
name|slab
operator|->
name|us_data
operator|)
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|!
name|skip
condition|)
name|uma_dbg_free
argument_list|(
name|zone
argument_list|,
name|slab
argument_list|,
name|item
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
condition|)
block|{
name|slabref
operator|=
operator|(
name|uma_slabrefcnt_t
operator|)
name|slab
expr_stmt|;
name|slabref
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|.
name|us_item
operator|=
name|slab
operator|->
name|us_firstfree
expr_stmt|;
block|}
else|else
block|{
name|slab
operator|->
name|us_freelist
index|[
name|freei
index|]
operator|.
name|us_item
operator|=
name|slab
operator|->
name|us_firstfree
expr_stmt|;
block|}
name|slab
operator|->
name|us_firstfree
operator|=
name|freei
expr_stmt|;
name|slab
operator|->
name|us_freecount
operator|++
expr_stmt|;
comment|/* Zone statistics */
name|keg
operator|->
name|uk_free
operator|++
expr_stmt|;
name|clearfull
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_FULL
condition|)
block|{
if|if
condition|(
name|keg
operator|->
name|uk_pages
operator|<
name|keg
operator|->
name|uk_maxpages
condition|)
block|{
name|keg
operator|->
name|uk_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
name|clearfull
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  		 * We can handle one more allocation. Since we're clearing ZFLAG_FULL, 		 * wake up all procs blocked on pages. This should be uncommon, so  		 * keeping this simple for now (rather than adding count of blocked  		 * threads etc). 		 */
name|wakeup
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clearfull
condition|)
block|{
name|zone_relock
argument_list|(
name|zone
argument_list|,
name|keg
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_flags
operator|&=
operator|~
name|UMA_ZFLAG_FULL
expr_stmt|;
name|wakeup
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
name|KEG_UNLOCK
argument_list|(
name|keg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_max
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|nitems
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_maxpages
operator|=
operator|(
name|nitems
operator|/
name|keg
operator|->
name|uk_ipers
operator|)
operator|*
name|keg
operator|->
name|uk_ppera
expr_stmt|;
if|if
condition|(
name|keg
operator|->
name|uk_maxpages
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|nitems
condition|)
name|keg
operator|->
name|uk_maxpages
operator|+=
name|keg
operator|->
name|uk_ppera
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_get_max
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|nitems
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|keg
operator|->
name|uk_maxpages
operator|*
name|keg
operator|->
name|uk_ipers
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|nitems
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_get_cur
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int64_t
name|nitems
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|zone
operator|->
name|uz_allocs
operator|-
name|zone
operator|->
name|uz_frees
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
comment|/* 		 * See the comment in sysctl_vm_zone_stats() regarding the 		 * safety of accessing the per-cpu caches. With the zone lock 		 * held, it is safe, but can potentially result in stale data. 		 */
name|nitems
operator|+=
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
operator|.
name|uc_allocs
operator|-
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
operator|.
name|uc_frees
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|nitems
operator|<
literal|0
condition|?
literal|0
else|:
name|nitems
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_init
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_init
name|uminit
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_init on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_init
operator|=
name|uminit
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_fini
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_fini
name|fini
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|keg
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_fini on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_fini
operator|=
name|fini
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_zinit
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_init
name|zinit
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_zinit on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_init
operator|=
name|zinit
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_zone_set_zfini
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_fini
name|zfini
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|->
name|uk_pages
operator|==
literal|0
argument_list|,
operator|(
literal|"uma_zone_set_zfini on non-empty keg"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|uz_fini
operator|=
name|zfini
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_comment
comment|/* XXX uk_freef is not actually used with the zone locked */
end_comment

begin_function
name|void
name|uma_zone_set_freef
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_free
name|freef
parameter_list|)
block|{
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
operator|->
name|uk_freef
operator|=
name|freef
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_comment
comment|/* XXX uk_allocf is not actually used with the zone locked */
end_comment

begin_function
name|void
name|uma_zone_set_allocf
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|uma_alloc
name|allocf
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZFLAG_PRIVALLOC
expr_stmt|;
name|keg
operator|->
name|uk_allocf
operator|=
name|allocf
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_set_obj
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|struct
name|vm_object
modifier|*
name|obj
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uma_keg_t
name|keg
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|int
name|pages
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|pages
operator|=
name|count
operator|/
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|pages
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|count
condition|)
name|pages
operator|++
expr_stmt|;
name|kva
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|pages
operator|*
name|UMA_SLAB_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kva
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|pages
argument_list|)
expr_stmt|;
else|else
block|{
name|VM_OBJECT_LOCK_INIT
argument_list|(
name|obj
argument_list|,
literal|"uma object"
argument_list|)
expr_stmt|;
name|_vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|pages
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|keg
operator|->
name|uk_kva
operator|=
name|kva
expr_stmt|;
name|keg
operator|->
name|uk_obj
operator|=
name|obj
expr_stmt|;
name|keg
operator|->
name|uk_maxpages
operator|=
name|pages
expr_stmt|;
name|keg
operator|->
name|uk_allocf
operator|=
name|obj_alloc
expr_stmt|;
name|keg
operator|->
name|uk_flags
operator||=
name|UMA_ZONE_NOFREE
operator||
name|UMA_ZFLAG_PRIVALLOC
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_prealloc
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|int
name|items
parameter_list|)
block|{
name|int
name|slabs
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|keg
operator|=
name|zone_first_keg
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|slabs
operator|=
name|items
operator|/
name|keg
operator|->
name|uk_ipers
expr_stmt|;
if|if
condition|(
name|slabs
operator|*
name|keg
operator|->
name|uk_ipers
operator|<
name|items
condition|)
name|slabs
operator|++
expr_stmt|;
while|while
condition|(
name|slabs
operator|>
literal|0
condition|)
block|{
name|slab
operator|=
name|keg_alloc_slab
argument_list|(
name|keg
argument_list|,
name|zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
break|break;
name|MPASS
argument_list|(
name|slab
operator|->
name|us_keg
operator|==
name|keg
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|keg
operator|->
name|uk_free_slab
argument_list|,
name|slab
argument_list|,
name|us_link
argument_list|)
expr_stmt|;
name|slabs
operator|--
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|u_int32_t
modifier|*
name|uma_find_refcnt
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|uma_slabrefcnt_t
name|slabref
decl_stmt|;
name|uma_keg_t
name|keg
decl_stmt|;
name|u_int32_t
modifier|*
name|refcnt
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|slabref
operator|=
operator|(
name|uma_slabrefcnt_t
operator|)
name|vtoslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|item
operator|&
operator|(
operator|~
name|UMA_SLAB_MASK
operator|)
argument_list|)
expr_stmt|;
name|keg
operator|=
name|slabref
operator|->
name|us_keg
expr_stmt|;
name|KASSERT
argument_list|(
name|slabref
operator|!=
name|NULL
operator|&&
name|slabref
operator|->
name|us_keg
operator|->
name|uk_flags
operator|&
name|UMA_ZONE_REFCNT
argument_list|,
operator|(
literal|"uma_find_refcnt(): zone possibly not UMA_ZONE_REFCNT"
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|item
operator|-
operator|(
name|unsigned
name|long
operator|)
name|slabref
operator|->
name|us_data
operator|)
operator|/
name|keg
operator|->
name|uk_rsize
expr_stmt|;
name|refcnt
operator|=
operator|&
name|slabref
operator|->
name|us_freelist
index|[
name|idx
index|]
operator|.
name|us_refcnt
expr_stmt|;
return|return
name|refcnt
return|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|void
name|uma_reclaim
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UMA_DEBUG
name|printf
argument_list|(
literal|"UMA: vm asked us to release pages!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket_enable
argument_list|()
expr_stmt|;
name|zone_foreach
argument_list|(
name|zone_drain
argument_list|)
expr_stmt|;
comment|/* 	 * Some slabs may have been freed but this zone will be visited early 	 * we visit again so that we can free pages that are empty once other 	 * zones are drained.  We have to do the same for buckets. 	 */
name|zone_drain
argument_list|(
name|slabzone
argument_list|)
expr_stmt|;
name|zone_drain
argument_list|(
name|slabrefzone
argument_list|)
expr_stmt|;
name|bucket_zone_drain
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See uma.h */
end_comment

begin_function
name|int
name|uma_zone_exhausted
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|int
name|full
decl_stmt|;
name|ZONE_LOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|full
operator|=
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
expr_stmt|;
name|ZONE_UNLOCK
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|full
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uma_zone_exhausted_nolock
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
return|return
operator|(
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZFLAG_FULL
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|uma_large_malloc
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|uma_slab_t
name|slab
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|slab
operator|=
name|zone_alloc_item
argument_list|(
name|slabzone
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mem
operator|=
name|page_alloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
operator|&
name|flags
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
condition|)
block|{
name|vsetslab
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mem
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|slab
operator|->
name|us_data
operator|=
name|mem
expr_stmt|;
name|slab
operator|->
name|us_flags
operator|=
name|flags
operator||
name|UMA_SLAB_MALLOC
expr_stmt|;
name|slab
operator|->
name|us_size
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|zone_free_item
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFAIL
operator||
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uma_large_free
parameter_list|(
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|vsetobj
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|slab
operator|->
name|us_data
argument_list|,
name|kmem_object
argument_list|)
expr_stmt|;
name|page_free
argument_list|(
name|slab
operator|->
name|us_data
argument_list|,
name|slab
operator|->
name|us_size
argument_list|,
name|slab
operator|->
name|us_flags
argument_list|)
expr_stmt|;
name|zone_free_item
argument_list|(
name|slabzone
argument_list|,
name|slab
argument_list|,
name|NULL
argument_list|,
name|SKIP_NONE
argument_list|,
name|ZFREE_STATFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uma_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|zone_foreach
argument_list|(
name|uma_print_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|slab_print
parameter_list|(
name|uma_slab_t
name|slab
parameter_list|)
block|{
name|printf
argument_list|(
literal|"slab: keg %p, data %p, freecount %d, firstfree %d\n"
argument_list|,
name|slab
operator|->
name|us_keg
argument_list|,
name|slab
operator|->
name|us_data
argument_list|,
name|slab
operator|->
name|us_freecount
argument_list|,
name|slab
operator|->
name|us_firstfree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_print
parameter_list|(
name|uma_cache_t
name|cache
parameter_list|)
block|{
name|printf
argument_list|(
literal|"alloc: %p(%d), free: %p(%d)\n"
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
name|cache
operator|->
name|uc_allocbucket
condition|?
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
else|:
literal|0
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|,
name|cache
operator|->
name|uc_freebucket
condition|?
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uma_print_keg
parameter_list|(
name|uma_keg_t
name|keg
parameter_list|)
block|{
name|uma_slab_t
name|slab
decl_stmt|;
name|printf
argument_list|(
literal|"keg: %s(%p) size %d(%d) flags %d ipers %d ppera %d "
literal|"out %d free %d limit %d\n"
argument_list|,
name|keg
operator|->
name|uk_name
argument_list|,
name|keg
argument_list|,
name|keg
operator|->
name|uk_size
argument_list|,
name|keg
operator|->
name|uk_rsize
argument_list|,
name|keg
operator|->
name|uk_flags
argument_list|,
name|keg
operator|->
name|uk_ipers
argument_list|,
name|keg
operator|->
name|uk_ppera
argument_list|,
operator|(
name|keg
operator|->
name|uk_ipers
operator|*
name|keg
operator|->
name|uk_pages
operator|)
operator|-
name|keg
operator|->
name|uk_free
argument_list|,
name|keg
operator|->
name|uk_free
argument_list|,
operator|(
name|keg
operator|->
name|uk_maxpages
operator|/
name|keg
operator|->
name|uk_ppera
operator|)
operator|*
name|keg
operator|->
name|uk_ipers
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Part slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_part_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Free slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_free_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Full slabs:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|slab
argument_list|,
argument|&keg->uk_full_slab
argument_list|,
argument|us_link
argument_list|)
name|slab_print
argument_list|(
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uma_print_zone
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"zone: %s(%p) size %d flags %d\n"
argument_list|,
name|zone
operator|->
name|uz_name
argument_list|,
name|zone
argument_list|,
name|zone
operator|->
name|uz_size
argument_list|,
name|zone
operator|->
name|uz_flags
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&zone->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
name|uma_print_keg
argument_list|(
name|kl
operator|->
name|kl_keg
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|cache
operator|=
operator|&
name|zone
operator|->
name|uz_cpu
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"CPU %d Cache:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cache_print
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * Generate statistics across both the zone and its per-cpu cache's.  Return  * desired statistics if the pointer is non-NULL for that statistic.  *  * Note: does not update the zone statistics, as it can't safely clear the  * per-CPU cache statistic.  *  * XXXRW: Following the uc_allocbucket and uc_freebucket pointers here isn't  * safe from off-CPU; we should modify the caches to track this information  * directly so that we don't have to.  */
end_comment

begin_function
specifier|static
name|void
name|uma_zone_sumstat
parameter_list|(
name|uma_zone_t
name|z
parameter_list|,
name|int
modifier|*
name|cachefreep
parameter_list|,
name|u_int64_t
modifier|*
name|allocsp
parameter_list|,
name|u_int64_t
modifier|*
name|freesp
parameter_list|,
name|u_int64_t
modifier|*
name|sleepsp
parameter_list|)
block|{
name|uma_cache_t
name|cache
decl_stmt|;
name|u_int64_t
name|allocs
decl_stmt|,
name|frees
decl_stmt|,
name|sleeps
decl_stmt|;
name|int
name|cachefree
decl_stmt|,
name|cpu
decl_stmt|;
name|allocs
operator|=
name|frees
operator|=
name|sleeps
operator|=
literal|0
expr_stmt|;
name|cachefree
operator|=
literal|0
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|cache
operator|=
operator|&
name|z
operator|->
name|uz_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|cachefree
operator|+=
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|cachefree
operator|+=
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
expr_stmt|;
name|allocs
operator|+=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|frees
operator|+=
name|cache
operator|->
name|uc_frees
expr_stmt|;
block|}
name|allocs
operator|+=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|frees
operator|+=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|sleeps
operator|+=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
if|if
condition|(
name|cachefreep
operator|!=
name|NULL
condition|)
operator|*
name|cachefreep
operator|=
name|cachefree
expr_stmt|;
if|if
condition|(
name|allocsp
operator|!=
name|NULL
condition|)
operator|*
name|allocsp
operator|=
name|allocs
expr_stmt|;
if|if
condition|(
name|freesp
operator|!=
name|NULL
condition|)
operator|*
name|freesp
operator|=
name|frees
expr_stmt|;
if|if
condition|(
name|sleepsp
operator|!=
name|NULL
condition|)
operator|*
name|sleepsp
operator|=
name|sleeps
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
specifier|static
name|int
name|sysctl_vm_zone_count
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|count
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_vm_zone_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|uma_stream_header
name|ush
decl_stmt|;
name|struct
name|uma_type_header
name|uth
decl_stmt|;
name|struct
name|uma_percpu_stat
name|ups
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|uma_cache_t
name|cache
decl_stmt|;
name|uma_klink_t
name|kl
decl_stmt|;
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|uma_keg_t
name|k
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
name|count
operator|++
expr_stmt|;
block|}
comment|/* 	 * Insert stream header. 	 */
name|bzero
argument_list|(
operator|&
name|ush
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
name|ush
operator|.
name|ush_version
operator|=
name|UMA_STREAM_VERSION
expr_stmt|;
name|ush
operator|.
name|ush_maxcpus
operator|=
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
expr_stmt|;
name|ush
operator|.
name|ush_count
operator|=
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|ush
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
name|bzero
argument_list|(
operator|&
name|uth
argument_list|,
sizeof|sizeof
argument_list|(
name|uth
argument_list|)
argument_list|)
expr_stmt|;
name|ZONE_LOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uth
operator|.
name|uth_name
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
name|UTH_MAX_NAME
argument_list|)
expr_stmt|;
name|uth
operator|.
name|uth_align
operator|=
name|kz
operator|->
name|uk_align
expr_stmt|;
name|uth
operator|.
name|uth_size
operator|=
name|kz
operator|->
name|uk_size
expr_stmt|;
name|uth
operator|.
name|uth_rsize
operator|=
name|kz
operator|->
name|uk_rsize
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kl
argument_list|,
argument|&z->uz_kegs
argument_list|,
argument|kl_link
argument_list|)
block|{
name|k
operator|=
name|kl
operator|->
name|kl_keg
expr_stmt|;
name|uth
operator|.
name|uth_maxpages
operator|+=
name|k
operator|->
name|uk_maxpages
expr_stmt|;
name|uth
operator|.
name|uth_pages
operator|+=
name|k
operator|->
name|uk_pages
expr_stmt|;
name|uth
operator|.
name|uth_keg_free
operator|+=
name|k
operator|->
name|uk_free
expr_stmt|;
name|uth
operator|.
name|uth_limit
operator|=
operator|(
name|k
operator|->
name|uk_maxpages
operator|/
name|k
operator|->
name|uk_ppera
operator|)
operator|*
name|k
operator|->
name|uk_ipers
expr_stmt|;
block|}
comment|/* 			 * A zone is secondary is it is not the first entry 			 * on the keg's zone list. 			 */
if|if
condition|(
operator|(
name|z
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|->
name|uk_zones
argument_list|)
operator|!=
name|z
operator|)
condition|)
name|uth
operator|.
name|uth_zone_flags
operator|=
name|UTH_ZONE_SECONDARY
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bucket
argument_list|,
argument|&z->uz_full_bucket
argument_list|,
argument|ub_link
argument_list|)
name|uth
operator|.
name|uth_zone_free
operator|+=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|uth
operator|.
name|uth_allocs
operator|=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|uth
operator|.
name|uth_frees
operator|=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|uth
operator|.
name|uth_fails
operator|=
name|z
operator|->
name|uz_fails
expr_stmt|;
name|uth
operator|.
name|uth_sleeps
operator|=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|uth
argument_list|,
sizeof|sizeof
argument_list|(
name|uth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * While it is not normally safe to access the cache 			 * bucket pointers while not on the CPU that owns the 			 * cache, we only allow the pointers to be exchanged 			 * without the zone lock held, not invalidated, so 			 * accept the possible race associated with bucket 			 * exchange during monitoring. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|ups
argument_list|,
sizeof|sizeof
argument_list|(
name|ups
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kz
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|cache
operator|=
operator|&
name|z
operator|->
name|uz_cpu
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
name|ups
operator|.
name|ups_cache_free
operator|+=
name|cache
operator|->
name|uc_allocbucket
operator|->
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
name|ups
operator|.
name|ups_cache_free
operator|+=
name|cache
operator|->
name|uc_freebucket
operator|->
name|ub_cnt
expr_stmt|;
name|ups
operator|.
name|ups_allocs
operator|=
name|cache
operator|->
name|uc_allocs
expr_stmt|;
name|ups
operator|.
name|ups_frees
operator|=
name|cache
operator|->
name|uc_frees
expr_stmt|;
name|skip
label|:
operator|(
name|void
operator|)
name|sbuf_bcat
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|ups
argument_list|,
sizeof|sizeof
argument_list|(
name|ups
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZONE_UNLOCK
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|uma_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|uma
argument_list|,
argument|db_show_uma
argument_list|)
end_macro

begin_block
block|{
name|u_int64_t
name|allocs
decl_stmt|,
name|frees
decl_stmt|,
name|sleeps
decl_stmt|;
name|uma_bucket_t
name|bucket
decl_stmt|;
name|uma_keg_t
name|kz
decl_stmt|;
name|uma_zone_t
name|z
decl_stmt|;
name|int
name|cachefree
decl_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8s %8s %8s %12s %8s\n"
argument_list|,
literal|"Zone"
argument_list|,
literal|"Size"
argument_list|,
literal|"Used"
argument_list|,
literal|"Free"
argument_list|,
literal|"Requests"
argument_list|,
literal|"Sleeps"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kz
argument_list|,
argument|&uma_kegs
argument_list|,
argument|uk_link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&kz->uk_zones
argument_list|,
argument|uz_link
argument_list|)
block|{
if|if
condition|(
name|kz
operator|->
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
condition|)
block|{
name|allocs
operator|=
name|z
operator|->
name|uz_allocs
expr_stmt|;
name|frees
operator|=
name|z
operator|->
name|uz_frees
expr_stmt|;
name|sleeps
operator|=
name|z
operator|->
name|uz_sleeps
expr_stmt|;
name|cachefree
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|uma_zone_sumstat
argument_list|(
name|z
argument_list|,
operator|&
name|cachefree
argument_list|,
operator|&
name|allocs
argument_list|,
operator|&
name|frees
argument_list|,
operator|&
name|sleeps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|z
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_SECONDARY
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|->
name|uk_zones
argument_list|)
operator|!=
name|z
operator|)
operator|)
condition|)
name|cachefree
operator|+=
name|kz
operator|->
name|uk_free
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bucket
argument_list|,
argument|&z->uz_full_bucket
argument_list|,
argument|ub_link
argument_list|)
name|cachefree
operator|+=
name|bucket
operator|->
name|ub_cnt
expr_stmt|;
name|db_printf
argument_list|(
literal|"%18s %8ju %8jd %8d %12ju %8ju\n"
argument_list|,
name|z
operator|->
name|uz_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|kz
operator|->
name|uk_size
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|allocs
operator|-
name|frees
argument_list|)
argument_list|,
name|cachefree
argument_list|,
operator|(
name|uintmax_t
operator|)
name|allocs
argument_list|,
name|sleeps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

