begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *	notice immediately at the beginning of the file, without modification,  *	this list of conditions, and the following disclaimer.  * 2. Absolutely no warranty of function or purpose is made by the author  *	John S. Dyson.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ZONE
argument_list|,
literal|"ZONE"
argument_list|,
literal|"Zone header"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ZENTRY_FREE
value|(void*)0x12342378
end_define

begin_define
define|#
directive|define
name|ZONE_ROUNDING
value|32
end_define

begin_comment
comment|/*  * This file comprises a very simple zone allocator.  This is used  * in lieu of the malloc allocator, where needed or more optimal.  *  * Note that the initial implementation of this had coloring, and  * absolutely no improvement (actually perf degradation) occurred.  *  * Note also that the zones are type stable.  The only restriction is  * that the first two longwords of a data structure can be changed  * between allocations.  Any data that must be stable between allocations  * must reside in areas after the first two longwords.  *  * zinitna, zinit, zbootinit are the initialization routines.  * zalloc, zfree, are the allocation/free routines.  */
end_comment

begin_comment
comment|/*  * Subsystem lock.  Never grab it while holding a zone lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|zone_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Singly-linked list of zones, for book-keeping purposes  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|vm_zone_list
argument_list|,
argument|vm_zone
argument_list|)
name|zlist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Statistics  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zone_kmem_pages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of interrupt-safe pages allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zone_kern_pages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of KVA pages allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zone_kmem_kvaspace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of non-intsafe pages allocated */
end_comment

begin_comment
comment|/*  * Subsystem initialization, called from vm_mem_init()  */
end_comment

begin_function
name|void
name|vm_zone_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|zone_mtx
argument_list|,
literal|"zone subsystem"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|zlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_zone_init2
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * LATER: traverse zlist looking for partially initialized 	 * LATER: zones and finish initializing them. 	 */
block|}
end_function

begin_comment
comment|/*  * Create a zone, but don't allocate the zone structure.  If the  * zone had been previously created by the zone boot code, initialize  * various parts of the zone code.  *  * If waits are not allowed during allocation (e.g. during interrupt  * code), a-priori allocate the kernel virtual space, and allocate  * only pages when needed.  *  * Arguments:  * z		pointer to zone structure.  * obj		pointer to VM object (opt).  * name		name of zone.  * size		size of zone entries.  * nentries	number of zone entries allocated (only ZONE_INTERRUPT.)  * flags	ZONE_INTERRUPT -- items can be allocated at interrupt time.  * zalloc	number of pages allocated when memory is needed.  *  * Note that when using ZONE_INTERRUPT, the size of the zone is limited  * by the nentries argument.  The size of the memory allocatable is  * unlimited if ZONE_INTERRUPT is not set.  *  */
end_comment

begin_function
name|int
name|zinitna
parameter_list|(
name|vm_zone_t
name|z
parameter_list|,
name|vm_object_t
name|obj
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|nentries
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|zalloc
parameter_list|)
block|{
name|int
name|totsize
decl_stmt|,
name|oldzflags
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|oldzflags
operator|=
name|z
operator|->
name|zflags
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_BOOT
operator|)
operator|==
literal|0
condition|)
block|{
name|z
operator|->
name|zsize
operator|=
operator|(
name|size
operator|+
name|ZONE_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|ZONE_ROUNDING
operator|-
literal|1
operator|)
expr_stmt|;
name|z
operator|->
name|zfreecnt
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|ztotal
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zmax
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zname
operator|=
name|name
expr_stmt|;
name|z
operator|->
name|znalloc
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zitems
operator|=
name|NULL
expr_stmt|;
block|}
name|z
operator|->
name|zflags
operator||=
name|flags
expr_stmt|;
comment|/* 	 * If we cannot wait, allocate KVA space up front, and we will fill 	 * in pages as needed. 	 */
if|if
condition|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_INTERRUPT
condition|)
block|{
name|totsize
operator|=
name|round_page
argument_list|(
name|z
operator|->
name|zsize
operator|*
name|nentries
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|zone_kmem_kvaspace
argument_list|,
name|totsize
argument_list|)
expr_stmt|;
name|z
operator|->
name|zkva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|totsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zkva
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|z
operator|->
name|zpagemax
operator|=
name|totsize
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|z
operator|->
name|zobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|z
operator|->
name|zpagemax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|z
operator|->
name|zobj
operator|=
name|obj
expr_stmt|;
name|_vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|z
operator|->
name|zpagemax
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|z
operator|->
name|zallocflag
operator|=
name|VM_ALLOC_INTERRUPT
expr_stmt|;
name|z
operator|->
name|zmax
operator|+=
name|nentries
expr_stmt|;
block|}
else|else
block|{
name|z
operator|->
name|zallocflag
operator|=
name|VM_ALLOC_SYSTEM
expr_stmt|;
name|z
operator|->
name|zmax
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|->
name|zsize
operator|>
name|PAGE_SIZE
condition|)
name|z
operator|->
name|zfreemin
operator|=
literal|1
expr_stmt|;
else|else
name|z
operator|->
name|zfreemin
operator|=
name|PAGE_SIZE
operator|/
name|z
operator|->
name|zsize
expr_stmt|;
name|z
operator|->
name|zpagecount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zalloc
condition|)
name|z
operator|->
name|zalloc
operator|=
name|zalloc
expr_stmt|;
else|else
name|z
operator|->
name|zalloc
operator|=
literal|1
expr_stmt|;
comment|/* our zone is good and ready, add it to the list */
if|if
condition|(
operator|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_BOOT
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_init
argument_list|(
operator|&
operator|(
name|z
operator|)
operator|->
name|zmtx
argument_list|,
literal|"zone"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|zlist
argument_list|,
name|z
argument_list|,
name|zent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Subroutine same as zinitna, except zone data structure is allocated  * automatically by malloc.  This routine should normally be used, except  * in certain tricky startup conditions in the VM system -- then  * zbootinit and zinitna can be used.  Zinit is the standard zone  * initialization call.  */
end_comment

begin_function
name|vm_zone_t
name|zinit
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|nentries
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|zalloc
parameter_list|)
block|{
name|vm_zone_t
name|z
decl_stmt|;
name|z
operator|=
operator|(
name|vm_zone_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_zone
argument_list|)
argument_list|,
name|M_ZONE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|zinitna
argument_list|(
name|z
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|nentries
argument_list|,
name|flags
argument_list|,
name|zalloc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|z
argument_list|,
name|M_ZONE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a zone before the system is fully up.  *  * We can't rely on being able to allocate items dynamically, so we  * kickstart the zone with a number of static items provided by the  * caller.  *  * This routine should only be called before full VM startup.  */
end_comment

begin_function
name|void
name|zbootinit
parameter_list|(
name|vm_zone_t
name|z
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|int
name|nitems
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|z
operator|->
name|zname
operator|=
name|name
expr_stmt|;
name|z
operator|->
name|zsize
operator|=
name|size
expr_stmt|;
name|z
operator|->
name|zpagemax
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zobj
operator|=
name|NULL
expr_stmt|;
name|z
operator|->
name|zflags
operator|=
name|ZONE_BOOT
expr_stmt|;
name|z
operator|->
name|zfreemin
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zallocflag
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zpagecount
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|zalloc
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|znalloc
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
name|z
operator|)
operator|->
name|zmtx
argument_list|,
literal|"zone"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|item
argument_list|,
name|nitems
operator|*
name|z
operator|->
name|zsize
argument_list|)
expr_stmt|;
name|z
operator|->
name|zitems
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|=
name|ZENTRY_FREE
expr_stmt|;
endif|#
directive|endif
name|z
operator|->
name|zitems
operator|=
name|item
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|item
operator|+=
name|z
operator|->
name|zsize
expr_stmt|;
block|}
name|z
operator|->
name|zfreecnt
operator|=
name|nitems
expr_stmt|;
name|z
operator|->
name|zmax
operator|=
name|nitems
expr_stmt|;
name|z
operator|->
name|ztotal
operator|=
name|nitems
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|zlist
argument_list|,
name|z
argument_list|,
name|zent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy a zone, freeing the allocated memory.  * This does not do any locking for the zone; make sure it is not used  * any more before calling. All zalloc()'ated memory in the zone must have  * been zfree()'d.  * zdestroy() may not be used with zbootinit()'ed zones.  */
end_comment

begin_function
name|void
name|zdestroy
parameter_list|(
name|vm_zone_t
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nitems
decl_stmt|,
name|nbytes
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|,
modifier|*
name|min
decl_stmt|,
modifier|*
modifier|*
name|itp
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|KASSERT
argument_list|(
name|z
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid zone"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed, or the algorithm used for non-interrupt zones will 	 * blow up badly. 	 */
name|KASSERT
argument_list|(
name|z
operator|->
name|ztotal
operator|==
name|z
operator|->
name|zfreecnt
argument_list|,
operator|(
literal|"zdestroy() used with an active zone"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_BOOT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"zdestroy() used with a zbootinit()'ed zone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_INTERRUPT
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|z
operator|->
name|zkva
argument_list|,
name|z
operator|->
name|zpagemax
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|z
operator|->
name|zobj
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|zone_kmem_kvaspace
argument_list|,
name|z
operator|->
name|zpagemax
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|zone_kmem_pages
argument_list|,
name|z
operator|->
name|zpagecount
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|-=
name|z
operator|->
name|zpagecount
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is evil h0h0 magic: 		 * The items may be in z->zitems in a random oder; we have to 		 * free the start of an allocated area, but do not want to save 		 * extra information. Additionally, we may not access items that 		 * were in a freed area. 		 * This is achieved in the following way: the smallest address 		 * is selected, and, after removing all items that are in a 		 * range of z->zalloc * PAGE_SIZE (one allocation unit) from 		 * it, kmem_free is called on it (since it is the smallest one, 		 * it must be the start of an area). This is repeated until all 		 * items are gone. 		 */
name|nbytes
operator|=
name|z
operator|->
name|zalloc
operator|*
name|PAGE_SIZE
expr_stmt|;
name|nitems
operator|=
name|nbytes
operator|/
name|z
operator|->
name|zsize
expr_stmt|;
while|while
condition|(
name|z
operator|->
name|zitems
operator|!=
name|NULL
condition|)
block|{
comment|/* Find minimal element. */
name|item
operator|=
name|min
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|item
operator|<
name|min
condition|)
name|min
operator|=
name|item
expr_stmt|;
name|item
operator|=
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Free. */
name|itp
operator|=
operator|&
name|z
operator|->
name|zitems
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|itp
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|nitems
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
operator|*
name|itp
operator|>=
operator|(
name|char
operator|*
operator|)
name|min
operator|&&
operator|(
name|char
operator|*
operator|)
operator|*
name|itp
operator|<
operator|(
name|char
operator|*
operator|)
name|min
operator|+
name|nbytes
condition|)
block|{
operator|*
name|itp
operator|=
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|*
name|itp
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|itp
operator|=
operator|&
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|*
name|itp
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|i
operator|==
name|nitems
argument_list|,
operator|(
literal|"zdestroy(): corrupt zone"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * We can allocate from kmem_map (kmem_malloc) or 			 * kernel_map (kmem_alloc). 			 * kmem_map is a submap of kernel_map, so we can use 			 * vm_map_lookup to retrieve the map we need to use. 			 */
name|map
operator|=
name|kernel_map
expr_stmt|;
if|if
condition|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|min
argument_list|,
name|VM_PROT_NONE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"zalloc mapping lost"
argument_list|)
expr_stmt|;
comment|/* Need to unlock. */
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|zone_kmem_pages
argument_list|,
name|z
operator|->
name|zalloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|==
name|kernel_map
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|zone_kern_pages
argument_list|,
name|z
operator|->
name|zalloc
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"zdestroy(): bad map"
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|min
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|zlist
argument_list|,
name|z
argument_list|,
name|vm_zone
argument_list|,
name|zent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
argument_list|,
name|M_ZONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the specified zone to accomodate more items.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|_zget
parameter_list|(
name|vm_zone_t
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|nitems
decl_stmt|,
name|nbytes
decl_stmt|;
name|void
modifier|*
name|item
decl_stmt|;
name|KASSERT
argument_list|(
name|z
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid zone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zflags
operator|&
name|ZONE_INTERRUPT
condition|)
block|{
name|nbytes
operator|=
name|z
operator|->
name|zpagecount
operator|*
name|PAGE_SIZE
expr_stmt|;
name|nbytes
operator|-=
name|nbytes
operator|%
name|z
operator|->
name|zsize
expr_stmt|;
name|item
operator|=
operator|(
name|char
operator|*
operator|)
name|z
operator|->
name|zkva
operator|+
name|nbytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|z
operator|->
name|zalloc
operator|)
operator|&&
operator|(
name|z
operator|->
name|zpagecount
operator|<
name|z
operator|->
name|zpagemax
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|zkva
decl_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|z
operator|->
name|zobj
argument_list|,
name|z
operator|->
name|zpagecount
argument_list|,
name|z
operator|->
name|zallocflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|zkva
operator|=
name|z
operator|->
name|zkva
operator|+
name|z
operator|->
name|zpagecount
operator|*
name|PAGE_SIZE
expr_stmt|;
name|pmap_qenter
argument_list|(
name|zkva
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|zkva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|z
operator|->
name|zpagecount
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|zone_kmem_pages
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
block|}
name|nitems
operator|=
operator|(
operator|(
name|z
operator|->
name|zpagecount
operator|*
name|PAGE_SIZE
operator|)
operator|-
name|nbytes
operator|)
operator|/
name|z
operator|->
name|zsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Please check zdestroy() when changing this! */
name|nbytes
operator|=
name|z
operator|->
name|zalloc
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 		 * Check to see if the kernel map is already locked.  We could allow 		 * for recursive locks, but that eliminates a valuable debugging 		 * mechanism, and opens up the kernel map for potential corruption 		 * by inconsistent data structure manipulation.  We could also use 		 * the interrupt allocation mechanism, but that has size limitations. 		 * Luckily, we have kmem_map that is a submap of kernel map available 		 * for memory allocation, and manipulation of that map doesn't affect 		 * the kernel map structures themselves. 		 * 		 * We can wait, so just do normal map allocation in the appropriate 		 * map. 		 */
name|mtx_unlock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockstatus
argument_list|(
operator|&
name|kernel_map
operator|->
name|lock
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|item
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kmem_map
argument_list|,
name|nbytes
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|zone_kmem_pages
argument_list|,
name|z
operator|->
name|zalloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|zone_kern_pages
argument_list|,
name|z
operator|->
name|zalloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|item
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
name|nitems
operator|=
name|nbytes
operator|/
name|z
operator|->
name|zsize
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
block|}
name|z
operator|->
name|ztotal
operator|+=
name|nitems
expr_stmt|;
comment|/* 	 * Save one for immediate allocation 	 */
if|if
condition|(
name|nitems
operator|!=
literal|0
condition|)
block|{
name|nitems
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|=
name|ZENTRY_FREE
expr_stmt|;
endif|#
directive|endif
name|z
operator|->
name|zitems
operator|=
name|item
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|item
operator|+=
name|z
operator|->
name|zsize
expr_stmt|;
block|}
name|z
operator|->
name|zfreecnt
operator|+=
name|nitems
expr_stmt|;
name|z
operator|->
name|znalloc
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|->
name|zfreecnt
operator|>
literal|0
condition|)
block|{
name|item
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
name|z
operator|->
name|zitems
operator|=
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|==
name|ZENTRY_FREE
argument_list|,
operator|(
literal|"item is not free"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|z
operator|->
name|zfreecnt
operator|--
expr_stmt|;
name|z
operator|->
name|znalloc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_assert
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates an item from the specified zone.  */
end_comment

begin_function
name|void
modifier|*
name|zalloc
parameter_list|(
name|vm_zone_t
name|z
parameter_list|)
block|{
name|void
modifier|*
name|item
decl_stmt|;
name|KASSERT
argument_list|(
name|z
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid zone"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zfreecnt
operator|<=
name|z
operator|->
name|zfreemin
condition|)
block|{
name|item
operator|=
name|_zget
argument_list|(
name|z
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|item
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
name|z
operator|->
name|zitems
operator|=
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|==
name|ZENTRY_FREE
argument_list|,
operator|(
literal|"item is not free"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|z
operator|->
name|zfreecnt
operator|--
expr_stmt|;
name|z
operator|->
name|znalloc
operator|++
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/*  * Frees an item back to the specified zone.  */
end_comment

begin_function
name|void
name|zfree
parameter_list|(
name|vm_zone_t
name|z
parameter_list|,
name|void
modifier|*
name|item
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|z
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid zone"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|item
operator|!=
name|NULL
argument_list|,
operator|(
literal|"invalid item"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|0
index|]
operator|=
name|z
operator|->
name|zitems
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|!=
name|ZENTRY_FREE
argument_list|,
operator|(
literal|"item is already free"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|item
operator|)
index|[
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ZENTRY_FREE
expr_stmt|;
endif|#
directive|endif
name|z
operator|->
name|zitems
operator|=
name|item
expr_stmt|;
name|z
operator|->
name|zfreecnt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler for vm.zone   */
end_comment

begin_function
specifier|static
name|int
name|sysctl_vm_zone
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|cnt
decl_stmt|;
specifier|const
name|int
name|linesize
init|=
literal|128
decl_stmt|;
comment|/* conservative */
name|char
modifier|*
name|tmpbuf
decl_stmt|,
modifier|*
name|offset
decl_stmt|;
name|vm_zone_t
name|z
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&zlist
argument_list|,
argument|zent
argument_list|)
name|cnt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|tmpbuf
argument_list|,
name|char
operator|*
argument_list|,
operator|(
name|cnt
operator|==
literal|0
condition|?
literal|1
else|:
name|cnt
operator|)
operator|*
name|linesize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|tmpbuf
argument_list|,
name|linesize
argument_list|,
literal|"\nITEM            SIZE     LIMIT    USED    FREE  REQUESTS\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|tmpbuf
argument_list|,
name|cnt
operator|==
literal|0
condition|?
name|len
operator|-
literal|1
else|:
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|cnt
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|offset
operator|=
name|tmpbuf
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|z
argument_list|,
argument|&zlist
argument_list|,
argument|zent
argument_list|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
comment|/* list may have changed size */
break|break;
name|mtx_lock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|offset
argument_list|,
name|linesize
argument_list|,
literal|"%-12.12s  %6.6u, %8.8u, %6.6u, %6.6u, %8.8u\n"
argument_list|,
name|z
operator|->
name|zname
argument_list|,
name|z
operator|->
name|zsize
argument_list|,
name|z
operator|->
name|zmax
argument_list|,
operator|(
name|z
operator|->
name|ztotal
operator|-
name|z
operator|->
name|zfreecnt
operator|)
argument_list|,
name|z
operator|->
name|zfreecnt
argument_list|,
name|z
operator|->
name|znalloc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|z
operator|->
name|zmtx
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|offset
operator|+
literal|12
init|;
name|p
operator|>
name|offset
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|;
operator|--
name|p
control|)
comment|/* nothing */
empty_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|zone_mtx
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|tmpbuf
argument_list|,
name|offset
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|out
label|:
name|FREE
argument_list|(
name|tmpbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_OID
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_zone
argument_list|,
literal|"A"
argument_list|,
literal|"Zone Info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_kmem_pages
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zone_kmem_pages
argument_list|,
literal|0
argument_list|,
literal|"Number of interrupt safe pages allocated by zone"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_kmem_kvaspace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zone_kmem_kvaspace
argument_list|,
literal|0
argument_list|,
literal|"KVA space allocated by zone"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|zone_kern_pages
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zone_kern_pages
argument_list|,
literal|0
argument_list|,
literal|"Number of non-interrupt safe pages allocated by zone"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

