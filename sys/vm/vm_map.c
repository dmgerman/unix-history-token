begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_map.c	8.3 (Berkeley) 1/12/94  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Virtual memory mapping module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  *	Virtual memory maps provide for the mapping, protection,  *	and sharing of virtual memory objects.  In addition,  *	this module provides for an efficient virtual copy of  *	memory from one map to another.  *  *	Synchronization is required prior to most operations.  *  *	Maps consist of an ordered doubly-linked list of simple  *	entries; a self-adjusting binary search tree of these  *	entries is used to speed up lookups.  *  *	Since portions of maps are specified by start/end addresses,  *	which may not align with existing map entries, all  *	routines merely "clip" entries to these start/end values.  *	[That is, an entry is split into two, bordering at a  *	start or end value.]  Note that these clippings may not  *	always be necessary (as the two resulting entries are then  *	not changed); however, the clipping is done for convenience.  *  *	As mentioned above, virtual copy operations are performed  *	by copying VM object references from one map to  *	another, and then marking both regions as copy-on-write.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|map_sleep_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mapentzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kmapentzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mapzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|vmspace_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vmspace_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vm_map_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|ize
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_entry_deallocate
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|boolean_t
name|system_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_entry_dispose
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_entry_unwire
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vm_map_growstack
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_map_entry_t
name|gap_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_pmap_enter
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|vm_map_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmspace_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vm_map_stack_locked
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addrbos
parameter_list|,
name|vm_size_t
name|max_ssize
parameter_list|,
name|vm_size_t
name|growsize
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_wire_entry_failure
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|failed_addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ENTRY_CHARGED
parameter_list|(
name|e
parameter_list|)
value|((e)->cred != NULL || \     ((e)->object.vm_object != NULL&& (e)->object.vm_object->cred != NULL&& \      !((e)->eflags& MAP_ENTRY_NEEDS_COPY)))
end_define

begin_comment
comment|/*   * PROC_VMSPACE_{UN,}LOCK() can be a noop as long as vmspaces are type  * stable.  */
end_comment

begin_define
define|#
directive|define
name|PROC_VMSPACE_LOCK
parameter_list|(
name|p
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|PROC_VMSPACE_UNLOCK
parameter_list|(
name|p
parameter_list|)
value|do { } while (0)
end_define

begin_comment
comment|/*  *	VM_MAP_RANGE_CHECK:	[ internal use only ]  *  *	Asserts that the starting and ending region  *	addresses fall within the valid range of the map.  */
end_comment

begin_define
define|#
directive|define
name|VM_MAP_RANGE_CHECK
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
define|\
value|{					\ 		if (start< vm_map_min(map))		\ 			start = vm_map_min(map);	\ 		if (end> vm_map_max(map))		\ 			end = vm_map_max(map);		\ 		if (start> end)			\ 			start = end;			\ 		}
end_define

begin_comment
comment|/*  *	vm_map_startup:  *  *	Initialize the vm_map module.  Must be called before  *	any other vm_map routines.  *  *	Map and entry structures are allocated from the general  *	purpose memory pool with some exceptions:  *  *	- The kernel map and kmem submap are allocated statically.  *	- Kernel map entries are allocated out of a static pool.  *  *	These restrictions are necessary since malloc() uses the  *	maps and requires map entries.  */
end_comment

begin_function
name|void
name|vm_map_startup
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|map_sleep_mtx
argument_list|,
literal|"vm map sleep mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mapzone
operator|=
name|uma_zcreate
argument_list|(
literal|"MAP"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
argument_list|,
name|NULL
argument_list|,
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_map_zdtor
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|vm_map_zinit
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|mapzone
argument_list|,
name|MAX_KMAP
argument_list|)
expr_stmt|;
name|kmapentzone
operator|=
name|uma_zcreate
argument_list|(
literal|"KMAP ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_MTXCLASS
operator||
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
name|mapentzone
operator|=
name|uma_zcreate
argument_list|(
literal|"MAP ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmspace_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"VMSPACE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmspace
argument_list|)
argument_list|,
name|NULL
argument_list|,
ifdef|#
directive|ifdef
name|INVARIANTS
name|vmspace_zdtor
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|vmspace_zinit
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vmspace_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
operator|(
expr|struct
name|vmspace
operator|*
operator|)
name|mem
expr_stmt|;
name|vm
operator|->
name|vm_map
operator|.
name|pmap
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_zinit
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_map
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vm_map_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|map
operator|=
operator|(
name|vm_map_t
operator|)
name|mem
expr_stmt|;
name|memset
argument_list|(
name|map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|"vm map (system)"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
literal|"vm map (user)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function
specifier|static
name|void
name|vmspace_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
operator|(
expr|struct
name|vmspace
operator|*
operator|)
name|mem
expr_stmt|;
name|vm_map_zdtor
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_map
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|map
operator|=
operator|(
name|vm_map_t
operator|)
name|mem
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|nentries
operator|==
literal|0
argument_list|,
operator|(
literal|"map %p nentries == %d on free."
operator|,
name|map
operator|,
name|map
operator|->
name|nentries
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|size
operator|==
literal|0
argument_list|,
operator|(
literal|"map %p size == %lu on free."
operator|,
name|map
operator|,
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANTS */
end_comment

begin_comment
comment|/*  * Allocate a vmspace structure, including a vm_map and pmap,  * and initialize those structures.  The refcnt is set to 1.  *  * If 'pinit' is NULL then the embedded pmap is initialized via pmap_pinit().  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_alloc
parameter_list|(
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|,
name|pmap_pinit_t
name|pinit
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
name|uma_zalloc
argument_list|(
name|vmspace_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vm
operator|->
name|vm_map
operator|.
name|pmap
operator|==
name|NULL
argument_list|,
operator|(
literal|"vm_map.pmap must be NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinit
operator|==
name|NULL
condition|)
name|pinit
operator|=
operator|&
name|pmap_pinit
expr_stmt|;
if|if
condition|(
operator|!
name|pinit
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|vmspace_zone
argument_list|,
name|vm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vmspace_alloc: %p"
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|_vm_map_init
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_refcnt
operator|=
literal|1
expr_stmt|;
name|vm
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
name|vm
operator|->
name|vm_swrss
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_tsize
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_dsize
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_ssize
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_taddr
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_daddr
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|vm_maxsaddr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|vm
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RACCT
end_ifdef

begin_function
specifier|static
name|void
name|vmspace_container_reset
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_STACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_RSS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_MEMLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_VMEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|vmspace_dofree
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vmspace_free: %p"
argument_list|,
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure any SysV shm is freed, it might not have been in 	 * exit1(). 	 */
name|shmexit
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the map, to wait out all other references to it. 	 * Delete all of the mappings and pages they hold, then call 	 * the pmap module to reclaim anything left. 	 */
operator|(
name|void
operator|)
name|vm_map_remove
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|min_offset
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|max_offset
argument_list|)
expr_stmt|;
name|pmap_release
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_map
operator|.
name|pmap
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|vmspace_zone
argument_list|,
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmspace_free
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"vmspace_free() called"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_refcnt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vmspace_free: attempt to free already freed vmspace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|vm
operator|->
name|vm_refcnt
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|vmspace_dofree
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmspace_exitfree
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
name|NULL
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vm
operator|==
operator|&
name|vmspace0
argument_list|,
operator|(
literal|"vmspace_exitfree: wrong vmspace"
operator|)
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmspace_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|refcnt
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Release user portion of address space. 	 * This releases references to vnodes, 	 * which could cause I/O if the file has been unlinked. 	 * Need to do this early enough that we can still sleep. 	 * 	 * The last exiting process to reach this point releases as 	 * much of the environment as it can. vmspace_dofree() is the 	 * slower fallback in case another process had a temporary 	 * reference to the vmspace. 	 */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|vmspace0
operator|.
name|vm_refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|refcnt
operator|=
name|vm
operator|->
name|vm_refcnt
expr_stmt|;
if|if
condition|(
name|refcnt
operator|>
literal|1
operator|&&
name|p
operator|->
name|p_vmspace
operator|!=
operator|&
name|vmspace0
condition|)
block|{
comment|/* Switch now since other proc might free vmspace */
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
operator|&
name|vmspace0
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pmap_activate
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|vm
operator|->
name|vm_refcnt
argument_list|,
name|refcnt
argument_list|,
name|refcnt
operator|-
literal|1
argument_list|)
condition|)
do|;
if|if
condition|(
name|refcnt
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_vmspace
operator|!=
name|vm
condition|)
block|{
comment|/* vmspace not yet freed, switch back */
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
name|vm
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pmap_activate
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|pmap_remove_pages
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switch now since this proc will free vmspace */
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
operator|&
name|vmspace0
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pmap_activate
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|vmspace_dofree
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
name|vmspace_container_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Acquire reference to vmspace owned by another process. */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_acquire_ref
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|int
name|refcnt
decl_stmt|;
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|vm
operator|==
name|NULL
condition|)
block|{
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
do|do
block|{
name|refcnt
operator|=
name|vm
operator|->
name|vm_refcnt
expr_stmt|;
if|if
condition|(
name|refcnt
operator|<=
literal|0
condition|)
block|{
comment|/* Avoid 0->1 transition */
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|vm
operator|->
name|vm_refcnt
argument_list|,
name|refcnt
argument_list|,
name|refcnt
operator|+
literal|1
argument_list|)
condition|)
do|;
if|if
condition|(
name|vm
operator|!=
name|p
operator|->
name|p_vmspace
condition|)
block|{
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|vm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Switch between vmspaces in an AIO kernel process.  *  * The AIO kernel processes switch to and from a user process's  * vmspace while performing an I/O operation on behalf of a user  * process.  The new vmspace is either the vmspace of a user process  * obtained from an active AIO request or the initial vmspace of the  * AIO kernel process (when it is idling).  Because user processes  * will block to drain any active AIO requests before proceeding in  * exit() or execve(), the vmspace reference count for these vmspaces  * can never be 0.  This allows for a much simpler implementation than  * the loop in vmspace_acquire_ref() above.  Similarly, AIO kernel  * processes hold an extra reference on their initial vmspace for the  * life of the process so that this guarantee is true for any vmspace  * passed as 'newvm'.  */
end_comment

begin_function
name|void
name|vmspace_switch_aio
parameter_list|(
name|struct
name|vmspace
modifier|*
name|newvm
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|oldvm
decl_stmt|;
comment|/* XXX: Need some way to assert that this is an aio daemon. */
name|KASSERT
argument_list|(
name|newvm
operator|->
name|vm_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"vmspace_switch_aio: newvm unreferenced"
operator|)
argument_list|)
expr_stmt|;
name|oldvm
operator|=
name|curproc
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
name|oldvm
operator|==
name|newvm
condition|)
return|return;
comment|/* 	 * Point to the new address space and refer to it. 	 */
name|curproc
operator|->
name|p_vmspace
operator|=
name|newvm
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|newvm
operator|->
name|vm_refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Activate the new mapping. */
name|pmap_activate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Remove the daemon's reference to the old address space. */
name|KASSERT
argument_list|(
name|oldvm
operator|->
name|vm_refcnt
operator|>
literal|1
argument_list|,
operator|(
literal|"vmspace_switch_aio: oldvm dropping last reference"
operator|)
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|oldvm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_vm_map_lock
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_lock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|sx_xlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_process_deferred
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|,
name|next
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|entry
operator|=
name|td
operator|->
name|td_map_def_user
expr_stmt|;
name|td
operator|->
name|td_map_def_user
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_VN_WRITECNT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Decrement the object's writemappings and 			 * possibly the vnode's v_writecount. 			 */
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Submap with writecount"
operator|)
argument_list|)
expr_stmt|;
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No object for writecount"
operator|)
argument_list|)
expr_stmt|;
name|vnode_pager_release_writecount
argument_list|(
name|object
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|vm_map_entry_deallocate
argument_list|(
name|entry
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_vm_map_unlock
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_unlock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
name|sx_xunlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|vm_map_process_deferred
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_vm_map_lock_read
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_lock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|sx_slock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_vm_map_unlock_read
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_unlock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
name|sx_sunlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|vm_map_process_deferred
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|_vm_map_trylock
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|map
operator|->
name|system_map
condition|?
operator|!
name|mtx_trylock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
else|:
operator|!
name|sx_try_xlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_vm_map_trylock_read
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|map
operator|->
name|system_map
condition|?
operator|!
name|mtx_trylock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
else|:
operator|!
name|sx_try_slock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_vm_map_lock_upgrade:	[ internal use only ]  *  *	Tries to upgrade a read (shared) lock on the specified map to a write  *	(exclusive) lock.  Returns the value "0" if the upgrade succeeds and a  *	non-zero value if the upgrade fails.  If the upgrade fails, the map is  *	returned without a read or write lock held.  *  *	Requires that the map be read locked.  */
end_comment

begin_function
name|int
name|_vm_map_lock_upgrade
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|unsigned
name|int
name|last_timestamp
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
block|{
name|mtx_assert_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sx_try_upgrade_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
name|sx_sunlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|vm_map_process_deferred
argument_list|()
expr_stmt|;
comment|/* 			 * If the map's timestamp does not change while the 			 * map is unlocked, then the upgrade succeeds. 			 */
name|sx_xlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|!=
name|map
operator|->
name|timestamp
condition|)
block|{
name|sx_xunlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_vm_map_lock_downgrade
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
block|{
name|mtx_assert_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|sx_downgrade_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_locked:  *  *	Returns a non-zero value if the caller holds a write (exclusive) lock  *	on the specified map and the value "0" otherwise.  */
end_comment

begin_function
name|int
name|vm_map_locked
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
return|return
operator|(
name|mtx_owned
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|sx_xlocked
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function
specifier|static
name|void
name|_vm_map_assert_locked
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_assert_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|sx_assert_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|SA_XLOCKED
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|VM_MAP_ASSERT_LOCKED
parameter_list|(
name|map
parameter_list|)
define|\
value|_vm_map_assert_locked(map, LOCK_FILE, LOCK_LINE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VM_MAP_ASSERT_LOCKED
parameter_list|(
name|map
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	_vm_map_unlock_and_wait:  *  *	Atomically releases the lock on the specified map and puts the calling  *	thread to sleep.  The calling thread will remain asleep until either  *	vm_map_wakeup() is performed on the map or the specified timeout is  *	exceeded.  *  *	WARNING!  This function does not perform deferred deallocations of  *	objects and map	entries.  Therefore, the calling thread is expected to  *	reacquire the map lock after reawakening and later perform an ordinary  *	unlock operation, such as vm_map_unlock(), before completing its  *	operation on the map.  */
end_comment

begin_function
name|int
name|_vm_map_unlock_and_wait
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|int
name|timo
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|map_sleep_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|mtx_unlock_flags_
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|sx_xunlock_
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|msleep
argument_list|(
operator|&
name|map
operator|->
name|root
argument_list|,
operator|&
name|map_sleep_mtx
argument_list|,
name|PDROP
operator||
name|PVM
argument_list|,
literal|"vmmaps"
argument_list|,
name|timo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_wakeup:  *  *	Awaken any threads that have slept on the map using  *	vm_map_unlock_and_wait().  */
end_comment

begin_function
name|void
name|vm_map_wakeup
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
comment|/* 	 * Acquire and release map_sleep_mtx to prevent a wakeup() 	 * from being performed (and lost) between the map unlock 	 * and the msleep() in _vm_map_unlock_and_wait(). 	 */
name|mtx_lock
argument_list|(
operator|&
name|map_sleep_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|map_sleep_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|map
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_busy
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|->
name|busy
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_unbusy
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|busy
argument_list|,
operator|(
literal|"vm_map_unbusy: not busy"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|map
operator|->
name|busy
operator|==
literal|0
operator|&&
operator|(
name|map
operator|->
name|flags
operator|&
name|MAP_BUSY_WAKEUP
operator|)
condition|)
block|{
name|vm_map_modflags
argument_list|(
name|map
argument_list|,
literal|0
argument_list|,
name|MAP_BUSY_WAKEUP
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|map
operator|->
name|busy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vm_map_wait_busy
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
while|while
condition|(
name|map
operator|->
name|busy
condition|)
block|{
name|vm_map_modflags
argument_list|(
name|map
argument_list|,
name|MAP_BUSY_WAKEUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|msleep
argument_list|(
operator|&
name|map
operator|->
name|busy
argument_list|,
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|0
argument_list|,
literal|"mbusy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sx_sleep
argument_list|(
operator|&
name|map
operator|->
name|busy
argument_list|,
operator|&
name|map
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"mbusy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|long
name|vmspace_resident_count
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
return|return
name|pmap_resident_count
argument_list|(
name|vmspace_pmap
argument_list|(
name|vmspace
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_create:  *  *	Creates and returns a new empty VM map with  *	the given physical map structure, and having  *	the given lower and upper address bounds.  */
end_comment

begin_function
name|vm_map_t
name|vm_map_create
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|vm_map_t
name|result
decl_stmt|;
name|result
operator|=
name|uma_zalloc
argument_list|(
name|mapzone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_create: %p"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|_vm_map_init
argument_list|(
name|result
argument_list|,
name|pmap
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an existing vm_map structure  * such as that in the vmspace structure.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|map
operator|->
name|header
operator|.
name|next
operator|=
name|map
operator|->
name|header
operator|.
name|prev
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|needs_wakeup
operator|=
name|FALSE
expr_stmt|;
name|map
operator|->
name|system_map
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|pmap
operator|=
name|pmap
expr_stmt|;
name|map
operator|->
name|min_offset
operator|=
name|min
expr_stmt|;
name|map
operator|->
name|max_offset
operator|=
name|max
expr_stmt|;
name|map
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|_vm_map_init
argument_list|(
name|map
argument_list|,
name|pmap
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|map
operator|->
name|system_mtx
argument_list|,
literal|"system map"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
literal|"user map"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_dispose:	[ internal use only ]  *  *	Inverse of vm_map_entry_create.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_dispose
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|map
operator|->
name|system_map
condition|?
name|kmapentzone
else|:
name|mapentzone
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_create:	[ internal use only ]  *  *	Allocates a VM map entry for insertion.  *	No entry fields are filled in.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|vm_map_entry_create
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|new_entry
operator|=
name|uma_zalloc
argument_list|(
name|kmapentzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
else|else
name|new_entry
operator|=
name|uma_zalloc
argument_list|(
name|mapentzone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_entry
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_map_entry_create: kernel resources exhausted"
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_set_behavior:  *  *	Set the expected access behavior, either normal, random, or  *	sequential.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vm_map_entry_set_behavior
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|u_char
name|behavior
parameter_list|)
block|{
name|entry
operator|->
name|eflags
operator|=
operator|(
name|entry
operator|->
name|eflags
operator|&
operator|~
name|MAP_ENTRY_BEHAV_MASK
operator|)
operator||
operator|(
name|behavior
operator|&
name|MAP_ENTRY_BEHAV_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_set_max_free:  *  *	Set the max_free field in a vm_map_entry.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vm_map_entry_set_max_free
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|max_free
operator|=
name|entry
operator|->
name|adj_free
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|left
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|left
operator|->
name|max_free
operator|>
name|entry
operator|->
name|max_free
condition|)
name|entry
operator|->
name|max_free
operator|=
name|entry
operator|->
name|left
operator|->
name|max_free
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|right
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|right
operator|->
name|max_free
operator|>
name|entry
operator|->
name|max_free
condition|)
name|entry
operator|->
name|max_free
operator|=
name|entry
operator|->
name|right
operator|->
name|max_free
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_splay:  *  *	The Sleator and Tarjan top-down splay algorithm with the  *	following variation.  Max_free must be computed bottom-up, so  *	on the downward pass, maintain the left and right spines in  *	reverse order.  Then, make a second pass up each side to fix  *	the pointers and compute max_free.  The time bound is O(log n)  *	amortized.  *  *	The new root is the vm_map_entry containing "addr", or else an  *	adjacent entry (lower or higher) if addr is not in the tree.  *  *	The map must be locked, and leaves it so.  *  *	Returns: the new root.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|vm_map_entry_splay
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|vm_map_entry_t
name|root
parameter_list|)
block|{
name|vm_map_entry_t
name|llist
decl_stmt|,
name|rlist
decl_stmt|;
name|vm_map_entry_t
name|ltree
decl_stmt|,
name|rtree
decl_stmt|;
name|vm_map_entry_t
name|y
decl_stmt|;
comment|/* Special case of empty tree. */
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
return|return
operator|(
name|root
operator|)
return|;
comment|/* 	 * Pass One: Splay down the tree until we find addr or a NULL 	 * pointer where addr would go.  llist and rlist are the two 	 * sides in reverse order (bottom-up), with llist linked by 	 * the right pointer and rlist linked by the left pointer in 	 * the vm_map_entry.  Wait until Pass Two to set max_free on 	 * the two spines. 	 */
name|llist
operator|=
name|NULL
expr_stmt|;
name|rlist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* root is never NULL in here. */
if|if
condition|(
name|addr
operator|<
name|root
operator|->
name|start
condition|)
block|{
name|y
operator|=
name|root
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|addr
operator|<
name|y
operator|->
name|start
operator|&&
name|y
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
comment|/* Rotate right and put y on rlist. */
name|root
operator|->
name|left
operator|=
name|y
operator|->
name|right
expr_stmt|;
name|y
operator|->
name|right
operator|=
name|root
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|y
operator|->
name|left
expr_stmt|;
name|y
operator|->
name|left
operator|=
name|rlist
expr_stmt|;
name|rlist
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* Put root on rlist. */
name|root
operator|->
name|left
operator|=
name|rlist
expr_stmt|;
name|rlist
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|y
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|>=
name|root
operator|->
name|end
condition|)
block|{
name|y
operator|=
name|root
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|addr
operator|>=
name|y
operator|->
name|end
operator|&&
name|y
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
comment|/* Rotate left and put y on llist. */
name|root
operator|->
name|right
operator|=
name|y
operator|->
name|left
expr_stmt|;
name|y
operator|->
name|left
operator|=
name|root
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|y
operator|->
name|right
expr_stmt|;
name|y
operator|->
name|right
operator|=
name|llist
expr_stmt|;
name|llist
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* Put root on llist. */
name|root
operator|->
name|right
operator|=
name|llist
expr_stmt|;
name|llist
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|y
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
comment|/* 	 * Pass Two: Walk back up the two spines, flip the pointers 	 * and set max_free.  The subtrees of the root go at the 	 * bottom of llist and rlist. 	 */
name|ltree
operator|=
name|root
operator|->
name|left
expr_stmt|;
while|while
condition|(
name|llist
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|llist
operator|->
name|right
expr_stmt|;
name|llist
operator|->
name|right
operator|=
name|ltree
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|llist
argument_list|)
expr_stmt|;
name|ltree
operator|=
name|llist
expr_stmt|;
name|llist
operator|=
name|y
expr_stmt|;
block|}
name|rtree
operator|=
name|root
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|rlist
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|rlist
operator|->
name|left
expr_stmt|;
name|rlist
operator|->
name|left
operator|=
name|rtree
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|rlist
argument_list|)
expr_stmt|;
name|rtree
operator|=
name|rlist
expr_stmt|;
name|rlist
operator|=
name|y
expr_stmt|;
block|}
comment|/* 	 * Final assembly: add ltree and rtree as subtrees of root. 	 */
name|root
operator|->
name|left
operator|=
name|ltree
expr_stmt|;
name|root
operator|->
name|right
operator|=
name|rtree
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
operator|(
name|root
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_{un,}link:  *  *	Insert/remove entries from maps.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_link
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|after_where
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_entry_link: map %p, nentries %d, entry %p, after %p"
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|entry
argument_list|,
name|after_where
argument_list|)
expr_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|after_where
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|after_where
operator|->
name|end
operator|<=
name|entry
operator|->
name|start
argument_list|,
operator|(
literal|"vm_map_entry_link: prev end %jx new start %jx overlap"
operator|,
operator|(
name|uintmax_t
operator|)
name|after_where
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|after_where
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|entry
operator|->
name|end
operator|<=
name|after_where
operator|->
name|next
operator|->
name|start
argument_list|,
operator|(
literal|"vm_map_entry_link: new end %jx next start %jx overlap"
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|after_where
operator|->
name|next
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|nentries
operator|++
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|after_where
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|after_where
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|after_where
operator|->
name|next
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|after_where
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|after_where
operator|!=
name|map
operator|->
name|root
condition|)
name|vm_map_entry_splay
argument_list|(
name|after_where
operator|->
name|start
argument_list|,
name|map
operator|->
name|root
argument_list|)
expr_stmt|;
name|entry
operator|->
name|right
operator|=
name|after_where
operator|->
name|right
expr_stmt|;
name|entry
operator|->
name|left
operator|=
name|after_where
expr_stmt|;
name|after_where
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|after_where
operator|->
name|adj_free
operator|=
name|entry
operator|->
name|start
operator|-
name|after_where
operator|->
name|end
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|after_where
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|right
operator|=
name|map
operator|->
name|root
expr_stmt|;
name|entry
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
block|}
name|entry
operator|->
name|adj_free
operator|=
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
condition|?
name|map
operator|->
name|max_offset
else|:
name|entry
operator|->
name|next
operator|->
name|start
operator|)
operator|-
name|entry
operator|->
name|end
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|map
operator|->
name|root
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_entry_unlink
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|,
name|prev
decl_stmt|,
name|root
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|map
operator|->
name|root
condition|)
name|vm_map_entry_splay
argument_list|(
name|entry
operator|->
name|start
argument_list|,
name|map
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|left
operator|==
name|NULL
condition|)
name|root
operator|=
name|entry
operator|->
name|right
expr_stmt|;
else|else
block|{
name|root
operator|=
name|vm_map_entry_splay
argument_list|(
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|left
argument_list|)
expr_stmt|;
name|root
operator|->
name|right
operator|=
name|entry
operator|->
name|right
expr_stmt|;
name|root
operator|->
name|adj_free
operator|=
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
condition|?
name|map
operator|->
name|max_offset
else|:
name|entry
operator|->
name|next
operator|->
name|start
operator|)
operator|-
name|root
operator|->
name|end
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|map
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|prev
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|map
operator|->
name|nentries
operator|--
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_entry_unlink: map %p, nentries %d, entry %p"
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_resize_free:  *  *	Recompute the amount of free space following a vm_map_entry  *	and propagate that value up the tree.  Call this function after  *	resizing a map entry in-place, that is, without a call to  *	vm_map_entry_link() or _unlink().  *  *	The map must be locked, and leaves it so.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_resize_free
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
comment|/* 	 * Using splay trees without parent pointers, propagating 	 * max_free up the tree is done by moving the entry to the 	 * root and making the change there. 	 */
if|if
condition|(
name|entry
operator|!=
name|map
operator|->
name|root
condition|)
name|map
operator|->
name|root
operator|=
name|vm_map_entry_splay
argument_list|(
name|entry
operator|->
name|start
argument_list|,
name|map
operator|->
name|root
argument_list|)
expr_stmt|;
name|entry
operator|->
name|adj_free
operator|=
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
condition|?
name|map
operator|->
name|max_offset
else|:
name|entry
operator|->
name|next
operator|->
name|start
operator|)
operator|-
name|entry
operator|->
name|end
expr_stmt|;
name|vm_map_entry_set_max_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup_entry:	[ internal use only ]  *  *	Finds the map entry containing (or  *	immediately preceding) the specified address  *	in the given map; the entry is returned  *	in the "entry" parameter.  The boolean  *	result indicates whether the address is  *	actually contained in the map.  */
end_comment

begin_function
name|boolean_t
name|vm_map_lookup_entry
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|address
parameter_list|,
name|vm_map_entry_t
modifier|*
name|entry
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|cur
decl_stmt|;
name|boolean_t
name|locked
decl_stmt|;
comment|/* 	 * If the map is empty, then the map entry immediately preceding 	 * "address" is the map's header. 	 */
name|cur
operator|=
name|map
operator|->
name|root
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
operator|*
name|entry
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
operator|&&
name|cur
operator|->
name|end
operator|>
name|address
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|locked
operator|=
name|vm_map_locked
argument_list|(
name|map
argument_list|)
operator|)
operator|||
name|sx_try_upgrade
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
condition|)
block|{
comment|/* 		 * Splay requires a write lock on the map.  However, it only 		 * restructures the binary search tree; it does not otherwise 		 * change the map.  Thus, the map's timestamp need not change 		 * on a temporary upgrade. 		 */
name|map
operator|->
name|root
operator|=
name|cur
operator|=
name|vm_map_entry_splay
argument_list|(
name|address
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|sx_downgrade
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * If "address" is contained within a map entry, the new root 		 * is that map entry.  Otherwise, the new root is a map entry 		 * immediately before or after "address". 		 */
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|end
operator|>
name|address
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
operator|*
name|entry
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
block|}
else|else
comment|/* 		 * Since the map is only locked for read access, perform a 		 * standard binary search tree lookup for "address". 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|address
operator|<
name|cur
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|left
operator|==
name|NULL
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|->
name|end
operator|>
name|address
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|cur
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_insert:  *  *	Inserts the given whole VM object into the target  *	map at the specified address range.  The object's  *	size should match that of the address range.  *  *	Requires that the map be locked, and leaves it so.  *  *	If object is non-NULL, ref count must be bumped by caller  *	prior to making call to account for the new entry.  */
end_comment

begin_function
name|int
name|vm_map_insert
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|,
name|prev_entry
decl_stmt|,
name|temp_entry
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|vm_eflags_t
name|protoeflags
decl_stmt|;
name|vm_inherit_t
name|inheritance
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|object
operator|!=
name|kmem_object
operator|&&
name|object
operator|!=
name|kernel_object
operator|)
operator|||
operator|(
name|cow
operator|&
name|MAP_COPY_ON_WRITE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_map_insert: kmem or kernel object and COW"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|==
name|NULL
operator|||
operator|(
name|cow
operator|&
name|MAP_NOFAULT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_map_insert: paradoxical MAP_NOFAULT request"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|prot
operator|&
operator|~
name|max
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"prot %#x is not subset of max_prot %#x"
operator|,
name|prot
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the start and end points are not bogus. 	 */
if|if
condition|(
name|start
operator|<
name|map
operator|->
name|min_offset
operator|||
name|end
operator|>
name|map
operator|->
name|max_offset
operator|||
name|start
operator|>=
name|end
condition|)
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
comment|/* 	 * Find the entry prior to the proposed starting address; if it's part 	 * of an existing entry, this range is bogus. 	 */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|prev_entry
operator|=
name|temp_entry
expr_stmt|;
comment|/* 	 * Assert that the next entry doesn't overlap the end point. 	 */
if|if
condition|(
name|prev_entry
operator|->
name|next
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|prev_entry
operator|->
name|next
operator|->
name|start
operator|<
name|end
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_CREATE_GUARD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|object
operator|!=
name|NULL
operator|||
name|max
operator|!=
name|VM_PROT_NONE
operator|)
condition|)
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
name|protoeflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_COPY_ON_WRITE
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_NOFAULT
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_NOFAULT
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_DISABLE_SYNCER
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_NOSYNC
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_DISABLE_COREDUMP
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_STACK_GROWS_DOWN
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_GROWS_DOWN
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_STACK_GROWS_UP
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_GROWS_UP
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_VN_WRITECOUNT
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_VN_WRITECNT
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_CREATE_GUARD
operator|)
operator|!=
literal|0
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_GUARD
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_CREATE_STACK_GAP_DN
operator|)
operator|!=
literal|0
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_STACK_GAP_DN
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_CREATE_STACK_GAP_UP
operator|)
operator|!=
literal|0
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_STACK_GAP_UP
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_INHERIT_SHARE
condition|)
name|inheritance
operator|=
name|VM_INHERIT_SHARE
expr_stmt|;
else|else
name|inheritance
operator|=
name|VM_INHERIT_DEFAULT
expr_stmt|;
name|cred
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
operator|(
name|MAP_ACC_NO_CHARGE
operator||
name|MAP_NOFAULT
operator||
name|MAP_CREATE_GUARD
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|charged
goto|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_ACC_CHARGED
operator|)
operator|||
operator|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|(
operator|(
name|protoeflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|||
name|object
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cow
operator|&
name|MAP_ACC_CHARGED
operator|)
operator|&&
operator|!
name|swap_reserve
argument_list|(
name|end
operator|-
name|start
argument_list|)
condition|)
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
name|KASSERT
argument_list|(
name|object
operator|==
name|NULL
operator|||
operator|(
name|protoeflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|!=
literal|0
operator|||
name|object
operator|->
name|cred
operator|==
name|NULL
argument_list|,
operator|(
literal|"overcommit: vm_map_insert o %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
block|}
name|charged
label|:
comment|/* Expand the kernel pmap, if necessary. */
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|&&
name|end
operator|>
name|kernel_vm_end
condition|)
name|pmap_growkernel
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * OBJ_ONEMAPPING must be cleared unless this mapping 		 * is trivially proven to be the only mapping for any 		 * of the object's pages.  (Object granularity 		 * reference counting is insufficient to recognize 		 * aliases with precision.) 		 */
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|ref_count
operator|>
literal|1
operator|||
name|object
operator|->
name|shadow_count
operator|!=
literal|0
condition|)
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|prev_entry
operator|->
name|eflags
operator|==
name|protoeflags
operator|&&
operator|(
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
operator|)
operator|==
literal|0
operator|&&
name|prev_entry
operator|->
name|end
operator|==
name|start
operator|&&
name|prev_entry
operator|->
name|wired_count
operator|==
literal|0
operator|&&
operator|(
name|prev_entry
operator|->
name|cred
operator|==
name|cred
operator|||
operator|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|NULL
operator|&&
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|==
name|cred
operator|)
operator|)
operator|&&
name|vm_object_coalesce
argument_list|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|prev_entry
operator|->
name|offset
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
argument_list|)
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|end
operator|-
name|prev_entry
operator|->
name|end
argument_list|)
argument_list|,
name|cred
operator|!=
name|NULL
operator|&&
operator|(
name|protoeflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * We were able to extend the object.  Determine if we 		 * can extend the previous map entry to include the 		 * new range as well. 		 */
if|if
condition|(
name|prev_entry
operator|->
name|inheritance
operator|==
name|inheritance
operator|&&
name|prev_entry
operator|->
name|protection
operator|==
name|prot
operator|&&
name|prev_entry
operator|->
name|max_protection
operator|==
name|max
condition|)
block|{
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
condition|)
name|map
operator|->
name|size
operator|+=
name|end
operator|-
name|prev_entry
operator|->
name|end
expr_stmt|;
name|prev_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|)
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
comment|/* 		 * If we can extend the object but cannot extend the 		 * map entry, we have to create a new map entry.  We 		 * must bump the ref count on the extended object to 		 * account for it.  object may be NULL. 		 */
name|object
operator|=
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|offset
operator|=
name|prev_entry
operator|->
name|offset
operator|+
operator|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
operator|&&
name|object
operator|!=
name|NULL
operator|&&
name|object
operator|->
name|cred
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|prev_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|)
block|{
comment|/* Object already accounts for this uid. */
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|=
name|protoeflags
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|new_entry
operator|->
name|inheritance
operator|=
name|inheritance
expr_stmt|;
name|new_entry
operator|->
name|protection
operator|=
name|prot
expr_stmt|;
name|new_entry
operator|->
name|max_protection
operator|=
name|max
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
name|new_entry
operator|->
name|wiring_thread
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|read_ahead
operator|=
name|VM_FAULT_READ_AHEAD_INIT
expr_stmt|;
name|new_entry
operator|->
name|next_read
operator|=
name|start
expr_stmt|;
name|KASSERT
argument_list|(
name|cred
operator|==
name|NULL
operator|||
operator|!
name|ENTRY_CHARGED
argument_list|(
name|new_entry
argument_list|)
argument_list|,
operator|(
literal|"overcommit: vm_map_insert leaks vm_map %p"
operator|,
name|new_entry
operator|)
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
comment|/* 	 * Insert the new entry into the list 	 */
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
condition|)
name|map
operator|->
name|size
operator|+=
name|new_entry
operator|->
name|end
operator|-
name|new_entry
operator|->
name|start
expr_stmt|;
comment|/* 	 * Try to coalesce the new entry with both the previous and next 	 * entries in the list.  Previously, we only attempted to coalesce 	 * with the previous entry when object is NULL.  Here, we handle the 	 * other cases, which are less common. 	 */
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
operator|(
name|MAP_PREFAULT
operator||
name|MAP_PREFAULT_PARTIAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_map_pmap_enter
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|prot
argument_list|,
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|cow
operator|&
name|MAP_PREFAULT_PARTIAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_findspace:  *  *	Find the first fit (lowest VM address) for "length" free bytes  *	beginning at address>= start in the given map.  *  *	In a vm_map_entry, "adj_free" is the amount of free space  *	adjacent (higher address) to this entry, and "max_free" is the  *	maximum amount of contiguous free space in its subtree.  This  *	allows finding a free region in one path down the tree, so  *	O(log n) amortized with splay trees.  *  *	The map must be locked, and leaves it so.  *  *	Returns: 0 on success, and starting address in *addr,  *		 1 if insufficient space.  */
end_comment

begin_function
name|int
name|vm_map_findspace
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_size_t
name|length
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_offset_t
name|st
decl_stmt|;
comment|/* 	 * Request must fit within min/max VM address and must avoid 	 * address wrap. 	 */
if|if
condition|(
name|start
operator|<
name|map
operator|->
name|min_offset
condition|)
name|start
operator|=
name|map
operator|->
name|min_offset
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|length
operator|>
name|map
operator|->
name|max_offset
operator|||
name|start
operator|+
name|length
operator|<
name|start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Empty tree means wide open address space. */
if|if
condition|(
name|map
operator|->
name|root
operator|==
name|NULL
condition|)
block|{
operator|*
name|addr
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * After splay, if start comes before root node, then there 	 * must be a gap from start to the root. 	 */
name|map
operator|->
name|root
operator|=
name|vm_map_entry_splay
argument_list|(
name|start
argument_list|,
name|map
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|length
operator|<=
name|map
operator|->
name|root
operator|->
name|start
condition|)
block|{
operator|*
name|addr
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Root is the last node that might begin its gap before 	 * start, and this is the last comparison where address 	 * wrap might be a problem. 	 */
name|st
operator|=
operator|(
name|start
operator|>
name|map
operator|->
name|root
operator|->
name|end
operator|)
condition|?
name|start
else|:
name|map
operator|->
name|root
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|map
operator|->
name|root
operator|->
name|end
operator|+
name|map
operator|->
name|root
operator|->
name|adj_free
operator|-
name|st
condition|)
block|{
operator|*
name|addr
operator|=
name|st
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* With max_free, can immediately tell if no solution. */
name|entry
operator|=
name|map
operator|->
name|root
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
operator|||
name|length
operator|>
name|entry
operator|->
name|max_free
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Search the right subtree in the order: left subtree, root, 	 * right subtree (first fit).  The previous splay implies that 	 * all regions in the right subtree have addresses> start. 	 */
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|left
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|left
operator|->
name|max_free
operator|>=
name|length
condition|)
name|entry
operator|=
name|entry
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|adj_free
operator|>=
name|length
condition|)
block|{
operator|*
name|addr
operator|=
name|entry
operator|->
name|end
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|entry
operator|=
name|entry
operator|->
name|right
expr_stmt|;
block|}
comment|/* Can't get here, so panic if we do. */
name|panic
argument_list|(
literal|"vm_map_findspace: max_free corrupt"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vm_map_fixed
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_size_t
name|length
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|result
decl_stmt|;
name|end
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
operator|)
operator|==
literal|0
operator|||
name|object
operator|==
name|NULL
argument_list|,
operator|(
literal|"vm_map_fixed: non-NULL backing object for stack"
operator|)
argument_list|)
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
name|MAP_CHECK_EXCL
operator|)
operator|==
literal|0
condition|)
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|vm_map_stack_locked
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|sgrowsiz
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_find finds an unallocated region in the target address  *	map with the given length.  The search is defined to be  *	first-fit from the specified address; the region found is  *	returned in the same parameter.  *  *	If object is non-NULL, ref count must be bumped by caller  *	prior to making call to account for the new entry.  */
end_comment

begin_function
name|int
name|vm_map_find
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
comment|/* IN/OUT */
name|vm_size_t
name|length
parameter_list|,
name|vm_offset_t
name|max_addr
parameter_list|,
name|int
name|find_space
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_offset_t
name|alignment
decl_stmt|,
name|initial_addr
decl_stmt|,
name|start
decl_stmt|;
name|int
name|result
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
operator|)
operator|==
literal|0
operator|||
name|object
operator|==
name|NULL
argument_list|,
operator|(
literal|"vm_map_find: non-NULL backing object for stack"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_space
operator|==
name|VMFS_OPTIMAL_SPACE
operator|&&
operator|(
name|object
operator|==
name|NULL
operator|||
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_COLORED
operator|)
operator|==
literal|0
operator|)
condition|)
name|find_space
operator|=
name|VMFS_ANY_SPACE
expr_stmt|;
if|if
condition|(
name|find_space
operator|>>
literal|8
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|find_space
operator|&
literal|0xff
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bad VMFS flags"
operator|)
argument_list|)
expr_stmt|;
name|alignment
operator|=
operator|(
name|vm_offset_t
operator|)
literal|1
operator|<<
operator|(
name|find_space
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
else|else
name|alignment
operator|=
literal|0
expr_stmt|;
name|initial_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|again
label|:
name|start
operator|=
name|initial_addr
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|find_space
operator|!=
name|VMFS_NO_SPACE
condition|)
block|{
if|if
condition|(
name|vm_map_findspace
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|addr
argument_list|)
operator|||
operator|(
name|max_addr
operator|!=
literal|0
operator|&&
operator|*
name|addr
operator|+
name|length
operator|>
name|max_addr
operator|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_space
operator|==
name|VMFS_OPTIMAL_SPACE
condition|)
block|{
name|find_space
operator|=
name|VMFS_ANY_SPACE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
switch|switch
condition|(
name|find_space
condition|)
block|{
case|case
name|VMFS_SUPER_SPACE
case|:
case|case
name|VMFS_OPTIMAL_SPACE
case|:
name|pmap_align_superpage
argument_list|(
name|object
argument_list|,
name|offset
argument_list|,
name|addr
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMFS_ANY_SPACE
case|:
break|break;
default|default:
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|addr
operator|&=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|addr
operator|+=
name|alignment
expr_stmt|;
block|}
break|break;
block|}
name|start
operator|=
operator|*
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|vm_map_stack_locked
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|sgrowsiz
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|result
operator|==
name|KERN_NO_SPACE
operator|&&
name|find_space
operator|!=
name|VMFS_NO_SPACE
operator|&&
name|find_space
operator|!=
name|VMFS_ANY_SPACE
condition|)
do|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_map_find_min
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|length
parameter_list|,
name|vm_offset_t
name|min_addr
parameter_list|,
name|vm_offset_t
name|max_addr
parameter_list|,
name|int
name|find_space
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_offset_t
name|hint
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|hint
operator|=
operator|*
name|addr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rv
operator|=
name|vm_map_find
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|addr
argument_list|,
name|length
argument_list|,
name|max_addr
argument_list|,
name|find_space
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
operator|||
name|min_addr
operator|>=
name|hint
condition|)
return|return
operator|(
name|rv
operator|)
return|;
operator|*
name|addr
operator|=
name|hint
operator|=
name|min_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_simplify_entry:  *  *	Simplify the given map entry by merging with either neighbor.  This  *	routine also has the ability to merge with both neighbors.  *  *	The map must be locked.  *  *	This routine guarantees that the passed entry remains valid (though  *	possibly extended).  When merging, this routine may delete one or  *	both neighbors.  */
end_comment

begin_function
name|void
name|vm_map_simplify_entry
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|vm_size_t
name|prevsize
decl_stmt|,
name|esize
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_GROWS_DOWN
operator||
name|MAP_ENTRY_GROWS_UP
operator||
name|MAP_ENTRY_IN_TRANSITION
operator||
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
name|prev
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|prevsize
operator|=
name|prev
operator|->
name|end
operator|-
name|prev
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|prev
operator|->
name|end
operator|==
name|entry
operator|->
name|start
operator|)
operator|&&
operator|(
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|==
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|&&
operator|(
operator|!
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|||
operator|(
name|prev
operator|->
name|offset
operator|+
name|prevsize
operator|==
name|entry
operator|->
name|offset
operator|)
operator|)
operator|&&
operator|(
name|prev
operator|->
name|eflags
operator|==
name|entry
operator|->
name|eflags
operator|)
operator|&&
operator|(
name|prev
operator|->
name|protection
operator|==
name|entry
operator|->
name|protection
operator|)
operator|&&
operator|(
name|prev
operator|->
name|max_protection
operator|==
name|entry
operator|->
name|max_protection
operator|)
operator|&&
operator|(
name|prev
operator|->
name|inheritance
operator|==
name|entry
operator|->
name|inheritance
operator|)
operator|&&
operator|(
name|prev
operator|->
name|wired_count
operator|==
name|entry
operator|->
name|wired_count
operator|)
operator|&&
operator|(
name|prev
operator|->
name|cred
operator|==
name|entry
operator|->
name|cred
operator|)
condition|)
block|{
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|prev
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
name|prev
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|prev
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|)
expr_stmt|;
comment|/* 			 * If the backing object is a vnode object, 			 * vm_object_deallocate() calls vrele(). 			 * However, vrele() does not lock the vnode 			 * because the vnode has additional 			 * references.  Thus, the map lock can be kept 			 * without causing a lock-order reversal with 			 * the vnode lock. 			 * 			 * Since we count the number of virtual page 			 * mappings in object->un_pager.vnp.writemappings, 			 * the writemappings value should not be adjusted 			 * when the entry is disposed of. 			 */
if|if
condition|(
name|prev
operator|->
name|object
operator|.
name|vm_object
condition|)
name|vm_object_deallocate
argument_list|(
name|prev
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|prev
operator|->
name|cred
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|esize
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|end
operator|==
name|next
operator|->
name|start
operator|)
operator|&&
operator|(
name|next
operator|->
name|object
operator|.
name|vm_object
operator|==
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|||
operator|(
name|entry
operator|->
name|offset
operator|+
name|esize
operator|==
name|next
operator|->
name|offset
operator|)
operator|)
operator|&&
operator|(
name|next
operator|->
name|eflags
operator|==
name|entry
operator|->
name|eflags
operator|)
operator|&&
operator|(
name|next
operator|->
name|protection
operator|==
name|entry
operator|->
name|protection
operator|)
operator|&&
operator|(
name|next
operator|->
name|max_protection
operator|==
name|entry
operator|->
name|max_protection
operator|)
operator|&&
operator|(
name|next
operator|->
name|inheritance
operator|==
name|entry
operator|->
name|inheritance
operator|)
operator|&&
operator|(
name|next
operator|->
name|wired_count
operator|==
name|entry
operator|->
name|wired_count
operator|)
operator|&&
operator|(
name|next
operator|->
name|cred
operator|==
name|entry
operator|->
name|cred
operator|)
condition|)
block|{
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|next
operator|->
name|end
expr_stmt|;
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 			 * See comment above. 			 */
if|if
condition|(
name|next
operator|->
name|object
operator|.
name|vm_object
condition|)
name|vm_object_deallocate
argument_list|(
name|next
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|next
operator|->
name|cred
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_start:	[ internal use only ]  *  *	Asserts that the given entry begins at or after  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_clip_start
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|startaddr
parameter_list|)
define|\
value|{ \ 	if (startaddr> entry->start) \ 		_vm_map_clip_start(map, entry, startaddr); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_clip_start
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|start
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|>
name|start
operator|&&
name|entry
operator|->
name|start
operator|<
name|start
argument_list|,
operator|(
literal|"_vm_map_clip_start: invalid clip of entry %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Split off the front portion -- note that we must insert the new 	 * entry BEFORE this one, so that this entry has the specified 	 * starting address. 	 */
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no object backing this entry, we might as well create 	 * one now.  If we defer it, an object can get created after the map 	 * is clipped, and individual objects will be created for the split-up 	 * map.  This is a bit of a hack, but is also about the best place to 	 * put this improvement. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|object
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|object
operator|->
name|charge
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|==
literal|0
operator|)
operator|&&
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|==
name|NULL
argument_list|,
operator|(
literal|"OVERCOMMIT: vm_entry_clip_start: both cred e %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|charge
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|offset
operator|+=
operator|(
name|start
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|new_entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|crhold
argument_list|(
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
comment|/* 		 * The object->un_pager.vnp.writemappings for the 		 * object of MAP_ENTRY_VN_WRITECNT type entry shall be 		 * kept as is here.  The virtual pages are 		 * re-distributed among the clipped entries, so the sum is 		 * left the same. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_end:	[ internal use only ]  *  *	Asserts that the given entry ends at or before  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_clip_end
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|endaddr
parameter_list|)
define|\
value|{ \ 	if ((endaddr)< (entry->end)) \ 		_vm_map_clip_end((map), (entry), (endaddr)); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_clip_end
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|start
operator|<
name|end
operator|&&
name|entry
operator|->
name|end
operator|>
name|end
argument_list|,
operator|(
literal|"_vm_map_clip_end: invalid clip of entry %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no object backing this entry, we might as well create 	 * one now.  If we defer it, an object can get created after the map 	 * is clipped, and individual objects will be created for the split-up 	 * map.  This is a bit of a hack, but is also about the best place to 	 * put this improvement. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|object
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|object
operator|->
name|charge
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|==
literal|0
operator|)
operator|&&
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|==
name|NULL
argument_list|,
operator|(
literal|"OVERCOMMIT: vm_entry_clip_end: both cred e %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|charge
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Create a new entry and insert it AFTER the specified entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|+=
operator|(
name|end
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|new_entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|crhold
argument_list|(
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_submap:		[ kernel use only ]  *  *	Mark the given range as handled by a subordinate map.  *  *	This range must have been created with vm_map_find,  *	and no other operations may have been performed on this  *	range prior to calling vm_map_submap.  *  *	Only a limited number of operations can be performed  *	within this rage after calling vm_map_submap:  *		vm_fault  *	[Don't try vm_map_copy!]  *  *	To remove a submapping, one must first remove the  *	range from the superior map, and then destroy the  *	submap (if desired).  [Better yet, don't try it.]  */
end_comment

begin_function
name|int
name|vm_map_submap
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_map_t
name|submap
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|int
name|result
init|=
name|KERN_INVALID_ARGUMENT
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|start
operator|==
name|start
operator|)
operator|&&
operator|(
name|entry
operator|->
name|end
operator|==
name|end
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|)
condition|)
block|{
name|entry
operator|->
name|object
operator|.
name|sub_map
operator|=
name|submap
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_IS_SUB_MAP
expr_stmt|;
name|result
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The maximum number of pages to map if MAP_PREFAULT_PARTIAL is specified  */
end_comment

begin_define
define|#
directive|define
name|MAX_INIT_PT
value|96
end_define

begin_comment
comment|/*  *	vm_map_pmap_enter:  *  *	Preload the specified map's pmap with mappings to the specified  *	object's memory-resident pages.  No further physical pages are  *	allocated, and no further virtual pages are retrieved from secondary  *	storage.  If the specified flags include MAP_PREFAULT_PARTIAL, then a  *	limited number of page mappings are created at the low-end of the  *	specified address range.  (For this purpose, a superpage mapping  *	counts as one page mapping.)  Otherwise, all resident pages within  *	the specified address range are mapped.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_pmap_enter
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_offset_t
name|start
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|p_start
decl_stmt|;
name|vm_pindex_t
name|mask
decl_stmt|,
name|psize
decl_stmt|,
name|threshold
decl_stmt|,
name|tmpidx
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
operator|)
operator|==
literal|0
operator|||
name|object
operator|==
name|NULL
condition|)
return|return;
name|VM_OBJECT_RLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
condition|)
block|{
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
condition|)
block|{
name|pmap_object_init_pt
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|addr
argument_list|,
name|object
argument_list|,
name|pindex
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
name|VM_OBJECT_LOCK_DOWNGRADE
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|psize
operator|=
name|atop
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|+
name|pindex
operator|>
name|object
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|size
operator|<
name|pindex
condition|)
block|{
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
name|psize
operator|=
name|object
operator|->
name|size
operator|-
name|pindex
expr_stmt|;
block|}
name|start
operator|=
literal|0
expr_stmt|;
name|p_start
operator|=
name|NULL
expr_stmt|;
name|threshold
operator|=
name|MAX_INIT_PT
expr_stmt|;
name|p
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
comment|/* 	 * Assert: the variable p is either (1) the page with the 	 * least pindex greater than or equal to the parameter pindex 	 * or (2) NULL. 	 */
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|tmpidx
operator|=
name|p
operator|->
name|pindex
operator|-
name|pindex
operator|)
operator|<
name|psize
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
control|)
block|{
comment|/* 		 * don't allow an madvise to blow away our really 		 * free pages allocating pv entries. 		 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|MAP_PREFAULT_MADVISE
operator|)
operator|!=
literal|0
operator|&&
name|vm_cnt
operator|.
name|v_free_count
operator|<
name|vm_cnt
operator|.
name|v_free_reserved
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|MAP_PREFAULT_PARTIAL
operator|)
operator|!=
literal|0
operator|&&
name|tmpidx
operator|>=
name|threshold
operator|)
condition|)
block|{
name|psize
operator|=
name|tmpidx
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
condition|)
block|{
if|if
condition|(
name|p_start
operator|==
name|NULL
condition|)
block|{
name|start
operator|=
name|addr
operator|+
name|ptoa
argument_list|(
name|tmpidx
argument_list|)
expr_stmt|;
name|p_start
operator|=
name|p
expr_stmt|;
block|}
comment|/* Jump ahead if a superpage mapping is possible. */
if|if
condition|(
name|p
operator|->
name|psind
operator|>
literal|0
operator|&&
operator|(
operator|(
name|addr
operator|+
name|ptoa
argument_list|(
name|tmpidx
argument_list|)
operator|)
operator|&
operator|(
name|pagesizes
index|[
name|p
operator|->
name|psind
index|]
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|atop
argument_list|(
name|pagesizes
index|[
name|p
operator|->
name|psind
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmpidx
operator|+
name|mask
operator|<
name|psize
operator|&&
name|vm_page_ps_is_valid
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|+=
name|mask
expr_stmt|;
name|threshold
operator|+=
name|mask
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|p_start
operator|!=
name|NULL
condition|)
block|{
name|pmap_enter_object
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|start
argument_list|,
name|addr
operator|+
name|ptoa
argument_list|(
name|tmpidx
argument_list|)
argument_list|,
name|p_start
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|p_start
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_start
operator|!=
name|NULL
condition|)
name|pmap_enter_object
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|start
argument_list|,
name|addr
operator|+
name|ptoa
argument_list|(
name|psize
argument_list|)
argument_list|,
name|p_start
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_protect:  *  *	Sets the protection of the specified address  *	region in the target map.  If "set_max" is  *	specified, the maximum protection is to be set;  *	otherwise, only the current protection is affected.  */
end_comment

begin_function
name|int
name|vm_map_protect
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|new_prot
parameter_list|,
name|boolean_t
name|set_max
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|,
name|entry
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|vm_prot_t
name|old_prot
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that we are not concurrently wiring pages.  vm_map_wire() may 	 * need to fault pages into the map and will drop the map lock while 	 * doing so, and the VM object may end up in an inconsistent state if we 	 * update the protection on the map entry in between faults. 	 */
name|vm_map_wait_busy
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Make a first pass to check for protection violations. 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|new_prot
operator|&
name|current
operator|->
name|max_protection
operator|)
operator|!=
name|new_prot
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
block|}
block|}
comment|/* 	 * Do an accounting pass for private read-only mappings that 	 * now will do cow due to allowed write (e.g. debugger sets 	 * breakpoint on text segment) 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|current
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_max
operator|||
operator|(
operator|(
name|new_prot
operator|&
operator|~
operator|(
name|current
operator|->
name|protection
operator|)
operator|)
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|||
name|ENTRY_CHARGED
argument_list|(
name|current
argument_list|)
operator|||
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|obj
operator|=
name|current
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
operator|||
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|swap_reserve
argument_list|(
name|current
operator|->
name|end
operator|-
name|current
operator|->
name|start
argument_list|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
block|}
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|current
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
continue|continue;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|obj
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Charge for the whole object allocation now, since 		 * we cannot distinguish between non-charged and 		 * charged clipped mapping of the same object later. 		 */
name|KASSERT
argument_list|(
name|obj
operator|->
name|charge
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_map_protect: object %p overcharged (entry %p)"
operator|,
name|obj
operator|,
name|current
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|swap_reserve
argument_list|(
name|ptoa
argument_list|(
name|obj
operator|->
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
block|}
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|obj
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
name|obj
operator|->
name|charge
operator|=
name|ptoa
argument_list|(
name|obj
operator|->
name|size
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Go back and fix up protections. [Note that clipping is not 	 * necessary the second time.] 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|old_prot
operator|=
name|current
operator|->
name|protection
expr_stmt|;
if|if
condition|(
name|set_max
condition|)
name|current
operator|->
name|protection
operator|=
operator|(
name|current
operator|->
name|max_protection
operator|=
name|new_prot
operator|)
operator|&
name|old_prot
expr_stmt|;
else|else
name|current
operator|->
name|protection
operator|=
name|new_prot
expr_stmt|;
comment|/* 		 * For user wired map entries, the normal lazy evaluation of 		 * write access upgrades through soft page faults is 		 * undesirable.  Instead, immediately copy any pages that are 		 * copy-on-write and enable write access in the physical map. 		 */
if|if
condition|(
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|current
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|vm_fault_copy_entry
argument_list|(
name|map
argument_list|,
name|map
argument_list|,
name|current
argument_list|,
name|current
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * When restricting access, update the physical map.  Worry 		 * about copy-on-write here. 		 */
if|if
condition|(
operator|(
name|old_prot
operator|&
operator|~
name|current
operator|->
name|protection
operator|)
operator|!=
literal|0
condition|)
block|{
define|#
directive|define
name|MASK
parameter_list|(
name|entry
parameter_list|)
value|(((entry)->eflags& MAP_ENTRY_COW) ? ~VM_PROT_WRITE : \ 							VM_PROT_ALL)
name|pmap_protect
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|current
operator|->
name|start
argument_list|,
name|current
operator|->
name|end
argument_list|,
name|current
operator|->
name|protection
operator|&
name|MASK
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MASK
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_madvise:  *  *	This routine traverses a processes map handling the madvise  *	system call.  Advisories are classified as either those effecting  *	the vm_map_entry structure, or those effecting the underlying  *	objects.  */
end_comment

begin_function
name|int
name|vm_map_madvise
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|behav
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|,
name|entry
decl_stmt|;
name|int
name|modify_map
init|=
literal|0
decl_stmt|;
comment|/* 	 * Some madvise calls directly modify the vm_map_entry, in which case 	 * we need to use an exclusive lock on the map and we need to perform 	 * various clipping operations.  Otherwise we only need a read-lock 	 * on the map. 	 */
switch|switch
condition|(
name|behav
condition|)
block|{
case|case
name|MADV_NORMAL
case|:
case|case
name|MADV_SEQUENTIAL
case|:
case|case
name|MADV_RANDOM
case|:
case|case
name|MADV_NOSYNC
case|:
case|case
name|MADV_AUTOSYNC
case|:
case|case
name|MADV_NOCORE
case|:
case|case
name|MADV_CORE
case|:
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|modify_map
operator|=
literal|1
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_WILLNEED
case|:
case|case
name|MADV_DONTNEED
case|:
case|case
name|MADV_FREE
case|:
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
comment|/* 	 * Locate starting entry and clip if necessary. 	 */
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|modify_map
condition|)
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|modify_map
condition|)
block|{
comment|/* 		 * madvise behaviors that are implemented in the vm_map_entry. 		 * 		 * We clip the vm_map_entry so that behavioral changes are 		 * limited to the specified address range. 		 */
for|for
control|(
name|current
operator|=
name|entry
init|;
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
continue|continue;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|current
argument_list|,
name|end
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|behav
condition|)
block|{
case|case
name|MADV_NORMAL
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_SEQUENTIAL
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_SEQUENTIAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_RANDOM
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_RANDOM
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_NOSYNC
case|:
name|current
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NOSYNC
expr_stmt|;
break|break;
case|case
name|MADV_AUTOSYNC
case|:
name|current
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NOSYNC
expr_stmt|;
break|break;
case|case
name|MADV_NOCORE
case|:
name|current
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
break|break;
case|case
name|MADV_CORE
case|:
name|current
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_pindex_t
name|pstart
decl_stmt|,
name|pend
decl_stmt|;
comment|/* 		 * madvise behaviors that are implemented in the underlying 		 * vm_object. 		 * 		 * Since we don't clip the vm_map_entry, we have to clip 		 * the vm_object pindex and count. 		 */
for|for
control|(
name|current
operator|=
name|entry
init|;
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|vm_offset_t
name|useEnd
decl_stmt|,
name|useStart
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
continue|continue;
name|pstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|current
operator|->
name|offset
argument_list|)
expr_stmt|;
name|pend
operator|=
name|pstart
operator|+
name|atop
argument_list|(
name|current
operator|->
name|end
operator|-
name|current
operator|->
name|start
argument_list|)
expr_stmt|;
name|useStart
operator|=
name|current
operator|->
name|start
expr_stmt|;
name|useEnd
operator|=
name|current
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|start
operator|<
name|start
condition|)
block|{
name|pstart
operator|+=
name|atop
argument_list|(
name|start
operator|-
name|current
operator|->
name|start
argument_list|)
expr_stmt|;
name|useStart
operator|=
name|start
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|end
operator|>
name|end
condition|)
block|{
name|pend
operator|-=
name|atop
argument_list|(
name|current
operator|->
name|end
operator|-
name|end
argument_list|)
expr_stmt|;
name|useEnd
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|pstart
operator|>=
name|pend
condition|)
continue|continue;
comment|/* 			 * Perform the pmap_advise() before clearing 			 * PGA_REFERENCED in vm_page_advise().  Otherwise, a 			 * concurrent pmap operation, such as pmap_remove(), 			 * could clear a reference in the pmap and set 			 * PGA_REFERENCED on the page before the pmap_advise() 			 * had completed.  Consequently, the page would appear 			 * referenced based upon an old reference that 			 * occurred before this pmap_advise() ran. 			 */
if|if
condition|(
name|behav
operator|==
name|MADV_DONTNEED
operator|||
name|behav
operator|==
name|MADV_FREE
condition|)
name|pmap_advise
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|useStart
argument_list|,
name|useEnd
argument_list|,
name|behav
argument_list|)
expr_stmt|;
name|vm_object_madvise
argument_list|(
name|current
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|pstart
argument_list|,
name|pend
argument_list|,
name|behav
argument_list|)
expr_stmt|;
comment|/* 			 * Pre-populate paging structures in the 			 * WILLNEED case.  For wired entries, the 			 * paging structures are already populated. 			 */
if|if
condition|(
name|behav
operator|==
name|MADV_WILLNEED
operator|&&
name|current
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
name|vm_map_pmap_enter
argument_list|(
name|map
argument_list|,
name|useStart
argument_list|,
name|current
operator|->
name|protection
argument_list|,
name|current
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|pstart
argument_list|,
name|ptoa
argument_list|(
name|pend
operator|-
name|pstart
argument_list|)
argument_list|,
name|MAP_PREFAULT_MADVISE
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_inherit:  *  *	Sets the inheritance of the specified address  *	range in the target map.  Inheritance  *	affects how the map will be shared with  *	child maps at the time of vmspace_fork.  */
end_comment

begin_function
name|int
name|vm_map_inherit
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_inherit_t
name|new_inheritance
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
switch|switch
condition|(
name|new_inheritance
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
case|case
name|VM_INHERIT_COPY
case|:
case|case
name|VM_INHERIT_SHARE
case|:
case|case
name|VM_INHERIT_ZERO
case|:
break|break;
default|default:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
block|{
name|entry
operator|=
name|temp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|temp_entry
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
operator|||
name|new_inheritance
operator|!=
name|VM_INHERIT_ZERO
condition|)
name|entry
operator|->
name|inheritance
operator|=
name|new_inheritance
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_unwire:  *  *	Implements both kernel and user unwiring.  */
end_comment

begin_function
name|int
name|vm_map_unwire
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|,
name|first_entry
decl_stmt|,
name|tmp_entry
decl_stmt|;
name|vm_offset_t
name|saved_start
decl_stmt|;
name|unsigned
name|int
name|last_timestamp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|boolean_t
name|need_wakeup
decl_stmt|,
name|result
decl_stmt|,
name|user_unwire
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|user_unwire
operator|=
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_USER
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
condition|)
name|first_entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
block|}
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
name|entry
operator|=
name|first_entry
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
condition|)
block|{
comment|/* 			 * We have not yet clipped the entry. 			 */
name|saved_start
operator|=
operator|(
name|start
operator|>=
name|entry
operator|->
name|start
operator|)
condition|?
name|start
else|:
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NEEDS_WAKEUP
expr_stmt|;
if|if
condition|(
name|vm_map_unlock_and_wait
argument_list|(
name|map
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 				 * Allow interruption of user unwiring? 				 */
block|}
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|+
literal|1
operator|!=
name|map
operator|->
name|timestamp
condition|)
block|{
comment|/* 				 * Look again for the entry because the map was 				 * modified while it was unlocked. 				 * Specifically, the entry may have been 				 * clipped, merged, or deleted. 				 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|saved_start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
condition|)
name|tmp_entry
operator|=
name|tmp_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|saved_start
operator|==
name|start
condition|)
block|{
comment|/* 							 * First_entry has been deleted. 							 */
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
name|end
operator|=
name|saved_start
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|entry
operator|==
name|first_entry
condition|)
name|first_entry
operator|=
name|tmp_entry
expr_stmt|;
else|else
name|first_entry
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
block|}
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
continue|continue;
block|}
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 		 * Mark the entry in case the map lock is released.  (See 		 * above.) 		 */
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|==
literal|0
operator|&&
name|entry
operator|->
name|wiring_thread
operator|==
name|NULL
argument_list|,
operator|(
literal|"owned map entry %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_IN_TRANSITION
expr_stmt|;
name|entry
operator|->
name|wiring_thread
operator|=
name|curthread
expr_stmt|;
comment|/* 		 * Check the map for holes in the specified region. 		 * If VM_MAP_WIRE_HOLESOK was specified, skip this check. 		 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|entry
operator|->
name|end
operator|<
name|end
operator|&&
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|entry
operator|->
name|next
operator|->
name|start
operator|>
name|entry
operator|->
name|end
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * If system unwiring, require that the entry is system wired. 		 */
if|if
condition|(
operator|!
name|user_unwire
operator|&&
name|vm_map_entry_system_wired_count
argument_list|(
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|rv
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|done
label|:
name|need_wakeup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|first_entry
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|&&
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
condition|)
name|first_entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|result
argument_list|,
operator|(
literal|"vm_map_unwire: lookup failed"
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|entry
operator|=
name|first_entry
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
comment|/* 		 * If VM_MAP_WIRE_HOLESOK was specified, an empty 		 * space in the unwired region could have been mapped 		 * while the map lock was dropped for draining 		 * MAP_ENTRY_IN_TRANSITION.  Moreover, another thread 		 * could be simultaneously wiring this new mapping 		 * entry.  Detect these cases and skip any entries 		 * marked as in transition by us. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|==
literal|0
operator|||
name|entry
operator|->
name|wiring_thread
operator|!=
name|curthread
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"vm_map_unwire: !HOLESOK and new/changed entry"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
operator|&&
operator|(
operator|!
name|user_unwire
operator|||
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|user_unwire
condition|)
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|1
condition|)
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"vm_map_unwire: in-transition flag missing %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|wiring_thread
operator|==
name|curthread
argument_list|,
operator|(
literal|"vm_map_unwire: alien wire %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_IN_TRANSITION
expr_stmt|;
name|entry
operator|->
name|wiring_thread
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_WAKEUP
condition|)
block|{
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_WAKEUP
expr_stmt|;
name|need_wakeup
operator|=
name|TRUE
expr_stmt|;
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_wakeup
condition|)
name|vm_map_wakeup
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_wire_entry_failure:  *  *	Handle a wiring failure on the given entry.  *  *	The map should be locked.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_wire_entry_failure
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|failed_addr
parameter_list|)
block|{
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|!=
literal|0
operator|&&
name|entry
operator|->
name|wired_count
operator|==
literal|1
argument_list|,
operator|(
literal|"vm_map_wire_entry_failure: entry %p isn't being wired"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|failed_addr
operator|<
name|entry
operator|->
name|end
argument_list|,
operator|(
literal|"vm_map_wire_entry_failure: entry %p was fully wired"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If any pages at the start of this entry were successfully wired, 	 * then unwire them. 	 */
if|if
condition|(
name|failed_addr
operator|>
name|entry
operator|->
name|start
condition|)
block|{
name|pmap_unwire
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|failed_addr
argument_list|)
expr_stmt|;
name|vm_object_unwire
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|failed_addr
operator|-
name|entry
operator|->
name|start
argument_list|,
name|PQ_ACTIVE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Assign an out-of-range value to represent the failure to wire this 	 * entry. 	 */
name|entry
operator|->
name|wired_count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_wire:  *  *	Implements both kernel and user wiring.  */
end_comment

begin_function
name|int
name|vm_map_wire
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|,
name|first_entry
decl_stmt|,
name|tmp_entry
decl_stmt|;
name|vm_offset_t
name|faddr
decl_stmt|,
name|saved_end
decl_stmt|,
name|saved_start
decl_stmt|;
name|unsigned
name|int
name|last_timestamp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|boolean_t
name|need_wakeup
decl_stmt|,
name|result
decl_stmt|,
name|user_wire
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
name|prot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_MAP_WIRE_WRITE
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|user_wire
operator|=
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_USER
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
condition|)
name|first_entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
block|}
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
name|entry
operator|=
name|first_entry
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
condition|)
block|{
comment|/* 			 * We have not yet clipped the entry. 			 */
name|saved_start
operator|=
operator|(
name|start
operator|>=
name|entry
operator|->
name|start
operator|)
condition|?
name|start
else|:
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NEEDS_WAKEUP
expr_stmt|;
if|if
condition|(
name|vm_map_unlock_and_wait
argument_list|(
name|map
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 				 * Allow interruption of user wiring? 				 */
block|}
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|+
literal|1
operator|!=
name|map
operator|->
name|timestamp
condition|)
block|{
comment|/* 				 * Look again for the entry because the map was 				 * modified while it was unlocked. 				 * Specifically, the entry may have been 				 * clipped, merged, or deleted. 				 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|saved_start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
condition|)
name|tmp_entry
operator|=
name|tmp_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|saved_start
operator|==
name|start
condition|)
block|{
comment|/* 							 * first_entry has been deleted. 							 */
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
name|end
operator|=
name|saved_start
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|entry
operator|==
name|first_entry
condition|)
name|first_entry
operator|=
name|tmp_entry
expr_stmt|;
else|else
name|first_entry
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
block|}
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
continue|continue;
block|}
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 		 * Mark the entry in case the map lock is released.  (See 		 * above.) 		 */
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|==
literal|0
operator|&&
name|entry
operator|->
name|wiring_thread
operator|==
name|NULL
argument_list|,
operator|(
literal|"owned map entry %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_IN_TRANSITION
expr_stmt|;
name|entry
operator|->
name|wiring_thread
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|entry
operator|->
name|protection
operator|&
name|prot
operator|)
operator|!=
name|prot
condition|)
block|{
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_WIRE_SKIPPED
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|next_entry
goto|;
block|}
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
name|saved_start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|saved_end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
comment|/* 			 * Release the map lock, relying on the in-transition 			 * mark.  Mark the map busy for fork. 			 */
name|vm_map_busy
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|faddr
operator|=
name|saved_start
expr_stmt|;
do|do
block|{
comment|/* 				 * Simulate a fault to get the page and enter 				 * it into the physical map. 				 */
if|if
condition|(
operator|(
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|faddr
argument_list|,
name|VM_PROT_NONE
argument_list|,
name|VM_FAULT_WIRE
argument_list|)
operator|)
operator|!=
name|KERN_SUCCESS
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|faddr
operator|+=
name|PAGE_SIZE
operator|)
operator|<
name|saved_end
condition|)
do|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_map_unbusy
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|+
literal|1
operator|!=
name|map
operator|->
name|timestamp
condition|)
block|{
comment|/* 				 * Look again for the entry because the map was 				 * modified while it was unlocked.  The entry 				 * may have been clipped, but NOT merged or 				 * deleted. 				 */
name|result
operator|=
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|saved_start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|result
argument_list|,
operator|(
literal|"vm_map_wire: lookup failed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|first_entry
condition|)
name|first_entry
operator|=
name|tmp_entry
expr_stmt|;
else|else
name|first_entry
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
while|while
condition|(
name|entry
operator|->
name|end
operator|<
name|saved_end
condition|)
block|{
comment|/* 					 * In case of failure, handle entries 					 * that were not fully wired here; 					 * fully wired entries are handled 					 * later. 					 */
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
operator|&&
name|faddr
operator|<
name|entry
operator|->
name|end
condition|)
name|vm_map_wire_entry_failure
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
block|}
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vm_map_wire_entry_failure
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|user_wire
operator|||
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
block|}
comment|/* 		 * Check the map for holes in the specified region. 		 * If VM_MAP_WIRE_HOLESOK was specified, skip this check. 		 */
name|next_entry
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
operator|==
literal|0
operator|&&
name|entry
operator|->
name|end
operator|<
name|end
operator|&&
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|entry
operator|->
name|next
operator|->
name|start
operator|>
name|entry
operator|->
name|end
operator|)
condition|)
block|{
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|rv
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|done
label|:
name|need_wakeup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|first_entry
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|&&
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
condition|)
name|first_entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|result
argument_list|,
operator|(
literal|"vm_map_wire: lookup failed"
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|entry
operator|=
name|first_entry
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
comment|/* 		 * If VM_MAP_WIRE_HOLESOK was specified, an empty 		 * space in the unwired region could have been mapped 		 * while the map lock was dropped for faulting in the 		 * pages or draining MAP_ENTRY_IN_TRANSITION. 		 * Moreover, another thread could be simultaneously 		 * wiring this new mapping entry.  Detect these cases 		 * and skip any entries marked as in transition not by us. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|==
literal|0
operator|||
name|entry
operator|->
name|wiring_thread
operator|!=
name|curthread
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|VM_MAP_WIRE_HOLESOK
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"vm_map_wire: !HOLESOK and new/changed entry"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_WIRE_SKIPPED
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|next_entry_done
goto|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|user_wire
condition|)
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Wiring failed on this entry.  Thus, unwiring is 			 * unnecessary. 			 */
name|entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|user_wire
operator|||
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Undo the wiring.  Wiring succeeded on this entry 			 * but failed on a later entry.   			 */
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|1
condition|)
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
block|}
name|next_entry_done
label|:
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"vm_map_wire: in-transition flag missing %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|wiring_thread
operator|==
name|curthread
argument_list|,
operator|(
literal|"vm_map_wire: alien wire %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
operator|(
name|MAP_ENTRY_IN_TRANSITION
operator||
name|MAP_ENTRY_WIRE_SKIPPED
operator|)
expr_stmt|;
name|entry
operator|->
name|wiring_thread
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_WAKEUP
condition|)
block|{
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_WAKEUP
expr_stmt|;
name|need_wakeup
operator|=
name|TRUE
expr_stmt|;
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_wakeup
condition|)
name|vm_map_wakeup
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vm_map_sync  *  * Push any dirty cached pages in the address range to their pager.  * If syncio is TRUE, dirty pages are written synchronously.  * If invalidate is TRUE, any cached pages are freed as well.  *  * If the size of the region from start to end is zero, we are  * supposed to flush all modified pages within the region containing  * start.  Unfortunately, a region can be split or coalesced with  * neighboring regions, making it difficult to determine what the  * original region was.  Therefore, we approximate this requirement by  * flushing the current region containing start.  *  * Returns an error if any part of the specified range is not mapped.  */
end_comment

begin_function
name|int
name|vm_map_sync
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|boolean_t
name|syncio
parameter_list|,
name|boolean_t
name|invalidate
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_ooffset_t
name|offset
decl_stmt|;
name|unsigned
name|int
name|last_timestamp
decl_stmt|;
name|boolean_t
name|failed
decl_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
name|start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
block|}
comment|/* 	 * Make a first pass to check for user-wired memory and holes. 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|invalidate
operator|&&
operator|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
if|if
condition|(
name|end
operator|>
name|current
operator|->
name|end
operator|&&
operator|(
name|current
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|current
operator|->
name|end
operator|!=
name|current
operator|->
name|next
operator|->
name|start
operator|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|invalidate
condition|)
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|failed
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Make a second pass, cleaning/uncaching pages from the indicated 	 * objects as we go. 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|current
operator|->
name|start
operator|<
name|end
condition|;
control|)
block|{
name|offset
operator|=
name|current
operator|->
name|offset
operator|+
operator|(
name|start
operator|-
name|current
operator|->
name|start
operator|)
expr_stmt|;
name|size
operator|=
operator|(
name|end
operator|<=
name|current
operator|->
name|end
condition|?
name|end
else|:
name|current
operator|->
name|end
operator|)
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_t
name|smap
decl_stmt|;
name|vm_map_entry_t
name|tentry
decl_stmt|;
name|vm_size_t
name|tsize
decl_stmt|;
name|smap
operator|=
name|current
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|smap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|smap
argument_list|,
name|offset
argument_list|,
operator|&
name|tentry
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|tentry
operator|->
name|end
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|tsize
operator|<
name|size
condition|)
name|size
operator|=
name|tsize
expr_stmt|;
name|object
operator|=
name|tentry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|offset
operator|=
name|tentry
operator|->
name|offset
operator|+
operator|(
name|offset
operator|-
name|tentry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|smap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|current
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_object_sync
argument_list|(
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|syncio
argument_list|,
name|invalidate
argument_list|)
condition|)
name|failed
operator|=
name|TRUE
expr_stmt|;
name|start
operator|+=
name|size
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|==
name|map
operator|->
name|timestamp
operator|||
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|current
argument_list|)
condition|)
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|failed
condition|?
name|KERN_FAILURE
else|:
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_unwire:	[ internal use only ]  *  *	Make the region specified by this entry pageable.  *  *	The map in question should be locked.  *	[This is the reason for this routine's existence.]  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_unwire
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|wired_count
operator|>
literal|0
argument_list|,
operator|(
literal|"vm_map_entry_unwire: entry %p isn't wired"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|pmap_unwire
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|vm_object_unwire
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
name|PQ_ACTIVE
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_entry_deallocate
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|boolean_t
name|system_map
parameter_list|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
name|vm_object_deallocate
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|system_map
condition|?
name|kmapentzone
else|:
name|mapentzone
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_delete:	[ internal use only ]  *  *	Deallocate the given entry from the target map.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_delete
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|offidxstart
decl_stmt|,
name|offidxend
decl_stmt|,
name|count
decl_stmt|,
name|size1
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|cred
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|object
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|vm_map_entry_deallocate
argument_list|(
name|entry
argument_list|,
name|map
operator|->
name|system_map
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|map
operator|->
name|size
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|swap_release_by_cred
argument_list|(
name|size
argument_list|,
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|object
operator|!=
name|NULL
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|entry
operator|->
name|cred
operator|==
name|NULL
operator|||
name|object
operator|->
name|cred
operator|==
name|NULL
operator|||
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
argument_list|,
operator|(
literal|"OVERCOMMIT vm_map_entry_delete: both cred %p"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|atop
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|offidxstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
name|offidxend
operator|=
name|offidxstart
operator|+
name|count
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|ref_count
operator|!=
literal|1
operator|&&
operator|(
operator|(
name|object
operator|->
name|flags
operator|&
operator|(
name|OBJ_NOSPLIT
operator||
name|OBJ_ONEMAPPING
operator|)
operator|)
operator|==
name|OBJ_ONEMAPPING
operator|||
name|object
operator|==
name|kernel_object
operator|||
name|object
operator|==
name|kmem_object
operator|)
condition|)
block|{
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 			 * The option OBJPR_NOTMAPPED can be passed here 			 * because vm_map_delete() already performed 			 * pmap_remove() on the only mapping to this range 			 * of pages.  			 */
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|offidxstart
argument_list|,
name|offidxend
argument_list|,
name|OBJPR_NOTMAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|object
argument_list|,
name|offidxstart
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|offidxend
operator|>=
name|object
operator|->
name|size
operator|&&
name|offidxstart
operator|<
name|object
operator|->
name|size
condition|)
block|{
name|size1
operator|=
name|object
operator|->
name|size
expr_stmt|;
name|object
operator|->
name|size
operator|=
name|offidxstart
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|size1
operator|-=
name|object
operator|->
name|size
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|charge
operator|>=
name|ptoa
argument_list|(
name|size1
argument_list|)
argument_list|,
operator|(
literal|"object %p charge< 0"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
name|swap_release_by_cred
argument_list|(
name|ptoa
argument_list|(
name|size1
argument_list|)
argument_list|,
name|object
operator|->
name|cred
argument_list|)
expr_stmt|;
name|object
operator|->
name|charge
operator|-=
name|ptoa
argument_list|(
name|size1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|system_map
condition|)
name|vm_map_entry_deallocate
argument_list|(
name|entry
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
name|entry
operator|->
name|next
operator|=
name|curthread
operator|->
name|td_map_def_user
expr_stmt|;
name|curthread
operator|->
name|td_map_def_user
operator|=
name|entry
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_delete:	[ internal use only ]  *  *	Deallocates the given address range from the target  *	map.  */
end_comment

begin_function
name|int
name|vm_map_delete
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|first_entry
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
comment|/* 	 * Find the start of the region, and clip it 	 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
condition|)
name|entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|entry
operator|=
name|first_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step through all entries in this region 	 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|;
comment|/* 		 * Wait for wiring or unwiring of an entry to complete. 		 * Also wait for any system wirings to disappear on 		 * user maps. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IN_TRANSITION
operator|)
operator|!=
literal|0
operator|||
operator|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|!=
name|kernel_pmap
operator|&&
name|vm_map_entry_system_wired_count
argument_list|(
name|entry
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|unsigned
name|int
name|last_timestamp
decl_stmt|;
name|vm_offset_t
name|saved_start
decl_stmt|;
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
name|saved_start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NEEDS_WAKEUP
expr_stmt|;
name|last_timestamp
operator|=
name|map
operator|->
name|timestamp
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_unlock_and_wait
argument_list|(
name|map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_timestamp
operator|+
literal|1
operator|!=
name|map
operator|->
name|timestamp
condition|)
block|{
comment|/* 				 * Look again for the entry because the map was 				 * modified while it was unlocked. 				 * Specifically, the entry may have been 				 * clipped, merged, or deleted. 				 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|saved_start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
name|entry
operator|=
name|tmp_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|entry
operator|=
name|tmp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|saved_start
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
comment|/* 		 * Unwire before removing addresses from the pmap; otherwise, 		 * unwiring will put the entries back in the pmap. 		 */
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
block|{
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* 		 * Delete the entry only after removing all pmap 		 * entries pointing to its pages.  (Otherwise, its 		 * page frames may be reallocated, and any modify bits 		 * will be set in the wrong object!) 		 */
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_remove:  *  *	Remove the given address range from the target map.  *	This is the exported form of vm_map_delete.  */
end_comment

begin_function
name|int
name|vm_map_remove
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_check_protection:  *  *	Assert that the target map allows the specified privilege on the  *	entire address region given.  The entire region must be allocated.  *  *	WARNING!  This code does not and should not check whether the  *	contents of the region is accessible.  For example a smaller file  *	might be mapped into a larger address space.  *  *	NOTE!  This code is also called by munmap().  *  *	The map must be locked.  A read lock is sufficient.  */
end_comment

begin_function
name|boolean_t
name|vm_map_check_protection
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|protection
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 		 * No holes allowed! 		 */
if|if
condition|(
name|start
operator|<
name|entry
operator|->
name|start
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 		 * Check protection associated with entry. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|protection
operator|)
operator|!=
name|protection
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* go to next entry */
name|start
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_copy_entry:  *  *	Copies the contents of the source entry to the destination  *	entry.  The entries *must* be aligned properly.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_copy_entry
parameter_list|(
name|vm_map_t
name|src_map
parameter_list|,
name|vm_map_t
name|dst_map
parameter_list|,
name|vm_map_entry_t
name|src_entry
parameter_list|,
name|vm_map_entry_t
name|dst_entry
parameter_list|,
name|vm_ooffset_t
modifier|*
name|fork_charge
parameter_list|)
block|{
name|vm_object_t
name|src_object
decl_stmt|;
name|vm_map_entry_t
name|fake_entry
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|charged
decl_stmt|;
name|VM_MAP_ASSERT_LOCKED
argument_list|(
name|dst_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_entry
operator|->
name|eflags
operator||
name|src_entry
operator|->
name|eflags
operator|)
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
return|return;
if|if
condition|(
name|src_entry
operator|->
name|wired_count
operator|==
literal|0
operator|||
operator|(
name|src_entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the source entry is marked needs_copy, it is already 		 * write-protected. 		 */
if|if
condition|(
operator|(
name|src_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|src_entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap_protect
argument_list|(
name|src_map
operator|->
name|pmap
argument_list|,
name|src_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|end
argument_list|,
name|src_entry
operator|->
name|protection
operator|&
operator|~
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Make a copy of the object. 		 */
name|size
operator|=
name|src_entry
operator|->
name|end
operator|-
name|src_entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|src_object
operator|=
name|src_entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
name|charged
operator|=
name|ENTRY_CHARGED
argument_list|(
name|src_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_object
operator|->
name|handle
operator|==
name|NULL
operator|&&
operator|(
name|src_object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|src_object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|vm_object_collapse
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src_object
operator|->
name|flags
operator|&
operator|(
name|OBJ_NOSPLIT
operator||
name|OBJ_ONEMAPPING
operator|)
operator|)
operator|==
name|OBJ_ONEMAPPING
condition|)
block|{
name|vm_object_split
argument_list|(
name|src_entry
argument_list|)
expr_stmt|;
name|src_object
operator|=
name|src_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
block|}
name|vm_object_reference_locked
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
name|vm_object_clear_flag
argument_list|(
name|src_object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|cred
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|src_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|src_object
operator|->
name|cred
operator|==
name|NULL
argument_list|,
operator|(
literal|"OVERCOMMIT: vm_map_copy_entry: cred %p"
operator|,
name|src_object
operator|)
argument_list|)
expr_stmt|;
name|src_object
operator|->
name|cred
operator|=
name|src_entry
operator|->
name|cred
expr_stmt|;
name|src_object
operator|->
name|charge
operator|=
name|size
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|src_object
expr_stmt|;
if|if
condition|(
name|charged
condition|)
block|{
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|dst_entry
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
operator|*
name|fork_charge
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|)
block|{
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|src_entry
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
operator|*
name|fork_charge
operator|+=
name|size
expr_stmt|;
block|}
block|}
name|src_entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
name|dst_entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
name|dst_entry
operator|->
name|offset
operator|=
name|src_entry
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_VN_WRITECNT
condition|)
block|{
comment|/* 				 * MAP_ENTRY_VN_WRITECNT cannot 				 * indicate write reference from 				 * src_entry, since the entry is 				 * marked as needs copy.  Allocate a 				 * fake entry that is used to 				 * decrement object->un_pager.vnp.writecount 				 * at the appropriate time.  Attach 				 * fake_entry to the deferred list. 				 */
name|fake_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|dst_map
argument_list|)
expr_stmt|;
name|fake_entry
operator|->
name|eflags
operator|=
name|MAP_ENTRY_VN_WRITECNT
expr_stmt|;
name|src_entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_VN_WRITECNT
expr_stmt|;
name|vm_object_reference
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
name|fake_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|src_object
expr_stmt|;
name|fake_entry
operator|->
name|start
operator|=
name|src_entry
operator|->
name|start
expr_stmt|;
name|fake_entry
operator|->
name|end
operator|=
name|src_entry
operator|->
name|end
expr_stmt|;
name|fake_entry
operator|->
name|next
operator|=
name|curthread
operator|->
name|td_map_def_user
expr_stmt|;
name|curthread
operator|->
name|td_map_def_user
operator|=
name|fake_entry
expr_stmt|;
block|}
name|pmap_copy
argument_list|(
name|dst_map
operator|->
name|pmap
argument_list|,
name|src_map
operator|->
name|pmap
argument_list|,
name|dst_entry
operator|->
name|start
argument_list|,
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
name|dst_entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|dst_entry
operator|->
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|crhold
argument_list|(
name|dst_entry
operator|->
name|cred
argument_list|)
expr_stmt|;
operator|*
name|fork_charge
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * We don't want to make writeable wired pages copy-on-write. 		 * Immediately copy these pages into the new map by simulating 		 * page faults.  The new pages are pageable. 		 */
name|vm_fault_copy_entry
argument_list|(
name|dst_map
argument_list|,
name|src_map
argument_list|,
name|dst_entry
argument_list|,
name|src_entry
argument_list|,
name|fork_charge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vmspace_map_entry_forked:  * Update the newly-forked vmspace each time a map entry is inherited  * or copied.  The values for vm_dsize and vm_tsize are approximate  * (and mostly-obsolete ideas in the face of mmap(2) et al.)  */
end_comment

begin_function
specifier|static
name|void
name|vmspace_map_entry_forked
parameter_list|(
specifier|const
name|struct
name|vmspace
modifier|*
name|vm1
parameter_list|,
name|struct
name|vmspace
modifier|*
name|vm2
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_size_t
name|entrysize
decl_stmt|;
name|vm_offset_t
name|newend
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
condition|)
return|return;
name|entrysize
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|vm2
operator|->
name|vm_map
operator|.
name|size
operator|+=
name|entrysize
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_GROWS_DOWN
operator||
name|MAP_ENTRY_GROWS_UP
operator|)
condition|)
block|{
name|vm2
operator|->
name|vm_ssize
operator|+=
name|btoc
argument_list|(
name|entrysize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|start
operator|>=
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_daddr
operator|&&
name|entry
operator|->
name|start
operator|<
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_daddr
operator|+
name|ctob
argument_list|(
name|vm1
operator|->
name|vm_dsize
argument_list|)
condition|)
block|{
name|newend
operator|=
name|MIN
argument_list|(
name|entry
operator|->
name|end
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_daddr
operator|+
name|ctob
argument_list|(
name|vm1
operator|->
name|vm_dsize
argument_list|)
argument_list|)
expr_stmt|;
name|vm2
operator|->
name|vm_dsize
operator|+=
name|btoc
argument_list|(
name|newend
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|start
operator|>=
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_taddr
operator|&&
name|entry
operator|->
name|start
operator|<
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_taddr
operator|+
name|ctob
argument_list|(
name|vm1
operator|->
name|vm_tsize
argument_list|)
condition|)
block|{
name|newend
operator|=
name|MIN
argument_list|(
name|entry
operator|->
name|end
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vm1
operator|->
name|vm_taddr
operator|+
name|ctob
argument_list|(
name|vm1
operator|->
name|vm_tsize
argument_list|)
argument_list|)
expr_stmt|;
name|vm2
operator|->
name|vm_tsize
operator|+=
name|btoc
argument_list|(
name|newend
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vmspace_fork:  * Create a new process vmspace structure and vm_map  * based on those of an existing process.  The new map  * is based on the old map, according to the inheritance  * values on the regions in that map.  *  * XXX It might be worth coalescing the entries added to the new vmspace.  *  * The source map must not be locked.  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_fork
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm1
parameter_list|,
name|vm_ooffset_t
modifier|*
name|fork_charge
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm2
decl_stmt|;
name|vm_map_t
name|new_map
decl_stmt|,
name|old_map
decl_stmt|;
name|vm_map_entry_t
name|new_entry
decl_stmt|,
name|old_entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|vm_inherit_t
name|inh
decl_stmt|;
name|old_map
operator|=
operator|&
name|vm1
operator|->
name|vm_map
expr_stmt|;
comment|/* Copy immutable fields of vm1 to vm2. */
name|vm2
operator|=
name|vmspace_alloc
argument_list|(
name|old_map
operator|->
name|min_offset
argument_list|,
name|old_map
operator|->
name|max_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vm2
operator|->
name|vm_taddr
operator|=
name|vm1
operator|->
name|vm_taddr
expr_stmt|;
name|vm2
operator|->
name|vm_daddr
operator|=
name|vm1
operator|->
name|vm_daddr
expr_stmt|;
name|vm2
operator|->
name|vm_maxsaddr
operator|=
name|vm1
operator|->
name|vm_maxsaddr
expr_stmt|;
name|vm_map_lock
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_map
operator|->
name|busy
condition|)
name|vm_map_wait_busy
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
name|new_map
operator|=
operator|&
name|vm2
operator|->
name|vm_map
expr_stmt|;
name|locked
operator|=
name|vm_map_trylock
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
comment|/* trylock to silence WITNESS */
name|KASSERT
argument_list|(
name|locked
argument_list|,
operator|(
literal|"vmspace_fork: lock failed"
operator|)
argument_list|)
expr_stmt|;
name|old_entry
operator|=
name|old_map
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|old_entry
operator|!=
operator|&
name|old_map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
name|panic
argument_list|(
literal|"vm_map_fork: encountered a submap"
argument_list|)
expr_stmt|;
name|inh
operator|=
name|old_entry
operator|->
name|inheritance
expr_stmt|;
if|if
condition|(
operator|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
operator|&&
name|inh
operator|!=
name|VM_INHERIT_NONE
condition|)
name|inh
operator|=
name|VM_INHERIT_COPY
expr_stmt|;
switch|switch
condition|(
name|inh
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
break|break;
case|case
name|VM_INHERIT_SHARE
case|:
comment|/* 			 * Clone the entry, creating the shared object if necessary. 			 */
name|object
operator|=
name|old_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|old_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|old_entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|object
operator|->
name|cred
operator|=
name|old_entry
operator|->
name|cred
expr_stmt|;
name|object
operator|->
name|charge
operator|=
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
expr_stmt|;
name|old_entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 			 * Add the reference before calling vm_object_shadow 			 * to insure that a shadow object is created. 			 */
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
condition|)
block|{
name|vm_object_shadow
argument_list|(
operator|&
name|old_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|old_entry
operator|->
name|offset
argument_list|,
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
argument_list|)
expr_stmt|;
name|old_entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
comment|/* Transfer the second reference too. */
name|vm_object_reference
argument_list|(
name|old_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
comment|/* 				 * As in vm_map_simplify_entry(), the 				 * vnode lock will not be acquired in 				 * this call to vm_object_deallocate(). 				 */
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|old_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|object
operator|->
name|cred
operator|==
name|NULL
argument_list|,
operator|(
literal|"vmspace_fork both cred"
operator|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|cred
operator|=
name|old_entry
operator|->
name|cred
expr_stmt|;
name|object
operator|->
name|charge
operator|=
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
expr_stmt|;
name|old_entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * Assert the correct state of the vnode 			 * v_writecount while the object is locked, to 			 * not relock it later for the assertion 			 * correctness. 			 */
if|if
condition|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_VN_WRITECNT
operator|&&
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|object
operator|->
name|handle
operator|)
operator|->
name|v_writecount
operator|>
literal|0
argument_list|,
operator|(
literal|"vmspace_fork: v_writecount %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|writemappings
operator|>
literal|0
argument_list|,
operator|(
literal|"vmspace_fork: vnp.writecount %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 			 * Clone the entry, referencing the shared object. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|&=
operator|~
operator|(
name|MAP_ENTRY_USER_WIRED
operator||
name|MAP_ENTRY_IN_TRANSITION
operator|)
expr_stmt|;
name|new_entry
operator|->
name|wiring_thread
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_VN_WRITECNT
condition|)
block|{
name|vnode_pager_update_writecount
argument_list|(
name|object
argument_list|,
name|new_entry
operator|->
name|start
argument_list|,
name|new_entry
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Insert the entry into the new map -- we know we're 			 * inserting at the end of the new map. 			 */
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|vmspace_map_entry_forked
argument_list|(
name|vm1
argument_list|,
name|vm2
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
comment|/* 			 * Update the physical map 			 */
name|pmap_copy
argument_list|(
name|new_map
operator|->
name|pmap
argument_list|,
name|old_map
operator|->
name|pmap
argument_list|,
name|new_entry
operator|->
name|start
argument_list|,
operator|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
operator|)
argument_list|,
name|old_entry
operator|->
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INHERIT_COPY
case|:
comment|/* 			 * Clone the entry and link into the map. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
comment|/* 			 * Copied entry is COW over the old object. 			 */
name|new_entry
operator|->
name|eflags
operator|&=
operator|~
operator|(
name|MAP_ENTRY_USER_WIRED
operator||
name|MAP_ENTRY_IN_TRANSITION
operator||
name|MAP_ENTRY_VN_WRITECNT
operator|)
expr_stmt|;
name|new_entry
operator|->
name|wiring_thread
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|vmspace_map_entry_forked
argument_list|(
name|vm1
argument_list|,
name|vm2
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|vm_map_copy_entry
argument_list|(
name|old_map
argument_list|,
name|new_map
argument_list|,
name|old_entry
argument_list|,
name|new_entry
argument_list|,
name|fork_charge
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INHERIT_ZERO
case|:
comment|/* 			 * Create a new anonymous mapping entry modelled from 			 * the old one. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|old_entry
operator|->
name|start
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|old_entry
operator|->
name|end
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|=
name|old_entry
operator|->
name|eflags
operator|&
operator|~
operator|(
name|MAP_ENTRY_USER_WIRED
operator||
name|MAP_ENTRY_IN_TRANSITION
operator||
name|MAP_ENTRY_VN_WRITECNT
operator|)
expr_stmt|;
name|new_entry
operator|->
name|protection
operator|=
name|old_entry
operator|->
name|protection
expr_stmt|;
name|new_entry
operator|->
name|max_protection
operator|=
name|old_entry
operator|->
name|max_protection
expr_stmt|;
name|new_entry
operator|->
name|inheritance
operator|=
name|VM_INHERIT_ZERO
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|vmspace_map_entry_forked
argument_list|(
name|vm1
argument_list|,
name|vm2
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|crhold
argument_list|(
name|new_entry
operator|->
name|cred
argument_list|)
expr_stmt|;
operator|*
name|fork_charge
operator|+=
operator|(
name|new_entry
operator|->
name|end
operator|-
name|new_entry
operator|->
name|start
operator|)
expr_stmt|;
break|break;
block|}
name|old_entry
operator|=
name|old_entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Use inlined vm_map_unlock() to postpone handling the deferred 	 * map entries, which cannot be done until both old_map and 	 * new_map locks are released. 	 */
name|sx_xunlock
argument_list|(
operator|&
name|old_map
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|new_map
operator|->
name|lock
argument_list|)
expr_stmt|;
name|vm_map_process_deferred
argument_list|()
expr_stmt|;
return|return
operator|(
name|vm2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_map_stack
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addrbos
parameter_list|,
name|vm_size_t
name|max_ssize
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_size_t
name|growsize
decl_stmt|,
name|init_ssize
decl_stmt|;
name|rlim_t
name|lmemlim
decl_stmt|,
name|vmemlim
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|growsize
operator|=
name|sgrowsiz
expr_stmt|;
name|init_ssize
operator|=
operator|(
name|max_ssize
operator|<
name|growsize
operator|)
condition|?
name|max_ssize
else|:
name|growsize
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|lmemlim
operator|=
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_MEMLOCK
argument_list|)
expr_stmt|;
name|vmemlim
operator|=
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_VMEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_mlock
operator|&&
name|map
operator|->
name|flags
operator|&
name|MAP_WIREFUTURE
condition|)
block|{
if|if
condition|(
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
argument_list|)
operator|+
name|init_ssize
operator|>
name|lmemlim
condition|)
block|{
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* If we would blow our VMEM resource limit, no go */
if|if
condition|(
name|map
operator|->
name|size
operator|+
name|init_ssize
operator|>
name|vmemlim
condition|)
block|{
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rv
operator|=
name|vm_map_stack_locked
argument_list|(
name|map
argument_list|,
name|addrbos
argument_list|,
name|max_ssize
argument_list|,
name|growsize
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
name|out
label|:
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|stack_guard_page
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|stack_guard_page
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|stack_guard_page
argument_list|,
literal|0
argument_list|,
literal|"Specifies the number of guard pages for a stack that grows"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|vm_map_stack_locked
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addrbos
parameter_list|,
name|vm_size_t
name|max_ssize
parameter_list|,
name|vm_size_t
name|growsize
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|,
name|prev_entry
decl_stmt|;
name|vm_offset_t
name|bot
decl_stmt|,
name|gap_bot
decl_stmt|,
name|gap_top
decl_stmt|,
name|top
decl_stmt|;
name|vm_size_t
name|init_ssize
decl_stmt|,
name|sgp
decl_stmt|;
name|int
name|orient
decl_stmt|,
name|rv
decl_stmt|;
comment|/* 	 * The stack orientation is piggybacked with the cow argument. 	 * Extract it into orient and mask the cow argument so that we 	 * don't pass it around further. 	 */
name|orient
operator|=
name|cow
operator|&
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|orient
operator|!=
literal|0
argument_list|,
operator|(
literal|"No stack grow direction"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|orient
operator|!=
operator|(
name|MAP_STACK_GROWS_DOWN
operator||
name|MAP_STACK_GROWS_UP
operator|)
argument_list|,
operator|(
literal|"bi-dir stack"
operator|)
argument_list|)
expr_stmt|;
name|sgp
operator|=
operator|(
name|vm_size_t
operator|)
name|stack_guard_page
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|addrbos
operator|<
name|vm_map_min
argument_list|(
name|map
argument_list|)
operator|||
name|addrbos
operator|>
name|vm_map_max
argument_list|(
name|map
argument_list|)
operator|||
name|addrbos
operator|+
name|max_ssize
operator|<
name|addrbos
operator|||
name|sgp
operator|>=
name|max_ssize
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|init_ssize
operator|=
name|growsize
expr_stmt|;
if|if
condition|(
name|max_ssize
operator|<
name|init_ssize
operator|+
name|sgp
condition|)
name|init_ssize
operator|=
name|max_ssize
operator|-
name|sgp
expr_stmt|;
comment|/* If addr is already mapped, no go */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addrbos
argument_list|,
operator|&
name|prev_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
comment|/* 	 * If we can't accommodate max_ssize in the current mapping, no go. 	 */
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|next
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|next
operator|->
name|start
operator|<
name|addrbos
operator|+
name|max_ssize
operator|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
comment|/* 	 * We initially map a stack of only init_ssize.  We will grow as 	 * needed later.  Depending on the orientation of the stack (i.e. 	 * the grow direction) we either map at the top of the range, the 	 * bottom of the range or in the middle. 	 * 	 * Note: we would normally expect prot and max to be VM_PROT_ALL, 	 * and cow to be 0.  Possibly we should eliminate these as input 	 * parameters, and just pass these values here in the insert call. 	 */
if|if
condition|(
name|orient
operator|==
name|MAP_STACK_GROWS_DOWN
condition|)
block|{
name|bot
operator|=
name|addrbos
operator|+
name|max_ssize
operator|-
name|init_ssize
expr_stmt|;
name|top
operator|=
name|bot
operator|+
name|init_ssize
expr_stmt|;
name|gap_bot
operator|=
name|addrbos
expr_stmt|;
name|gap_top
operator|=
name|bot
expr_stmt|;
block|}
else|else
comment|/* if (orient == MAP_STACK_GROWS_UP) */
block|{
name|bot
operator|=
name|addrbos
expr_stmt|;
name|top
operator|=
name|bot
operator|+
name|init_ssize
expr_stmt|;
name|gap_bot
operator|=
name|top
expr_stmt|;
name|gap_top
operator|=
name|addrbos
operator|+
name|max_ssize
expr_stmt|;
block|}
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bot
argument_list|,
name|top
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|new_entry
operator|=
name|prev_entry
operator|->
name|next
expr_stmt|;
name|KASSERT
argument_list|(
name|new_entry
operator|->
name|end
operator|==
name|top
operator|||
name|new_entry
operator|->
name|start
operator|==
name|bot
argument_list|,
operator|(
literal|"Bad entry start/end for new stack entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|orient
operator|&
name|MAP_STACK_GROWS_DOWN
operator|)
operator|==
literal|0
operator|||
operator|(
name|new_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GROWS_DOWN
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"new entry lacks MAP_ENTRY_GROWS_DOWN"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|orient
operator|&
name|MAP_STACK_GROWS_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|new_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GROWS_UP
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"new entry lacks MAP_ENTRY_GROWS_UP"
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gap_bot
argument_list|,
name|gap_top
argument_list|,
name|VM_PROT_NONE
argument_list|,
name|VM_PROT_NONE
argument_list|,
name|MAP_CREATE_GUARD
operator||
operator|(
name|orient
operator|==
name|MAP_STACK_GROWS_DOWN
condition|?
name|MAP_CREATE_STACK_GAP_DN
else|:
name|MAP_CREATE_STACK_GAP_UP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
operator|(
name|void
operator|)
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|bot
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempts to grow a vm stack entry.  Returns KERN_SUCCESS if we  * successfully grow the stack.  */
end_comment

begin_function
specifier|static
name|int
name|vm_map_growstack
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_map_entry_t
name|gap_entry
parameter_list|)
block|{
name|vm_map_entry_t
name|stack_entry
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|vm_offset_t
name|gap_end
decl_stmt|,
name|gap_start
decl_stmt|,
name|grow_start
decl_stmt|;
name|size_t
name|grow_amount
decl_stmt|,
name|guard
decl_stmt|,
name|max_grow
decl_stmt|;
name|rlim_t
name|lmemlim
decl_stmt|,
name|stacklim
decl_stmt|,
name|vmemlim
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|rv1
decl_stmt|;
name|bool
name|gap_deleted
decl_stmt|,
name|grow_down
decl_stmt|,
name|is_procstack
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|uint64_t
name|limit
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RACCT
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|p
operator|=
name|curproc
expr_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
comment|/* 	 * Disallow stack growth when the access is performed by a 	 * debugger or AIO daemon.  The reason is that the wrong 	 * resource limits are applied. 	 */
if|if
condition|(
name|map
operator|!=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|||
name|p
operator|->
name|p_textvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|MPASS
argument_list|(
operator|!
name|map
operator|->
name|system_map
argument_list|)
expr_stmt|;
name|guard
operator|=
name|stack_guard_page
operator|*
name|PAGE_SIZE
expr_stmt|;
name|lmemlim
operator|=
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_MEMLOCK
argument_list|)
expr_stmt|;
name|stacklim
operator|=
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_STACK
argument_list|)
expr_stmt|;
name|vmemlim
operator|=
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_VMEM
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* If addr is not in a hole for a stack grow area, no need to grow. */
if|if
condition|(
name|gap_entry
operator|==
name|NULL
operator|&&
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
operator|&
name|gap_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
if|if
condition|(
operator|(
name|gap_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
if|if
condition|(
operator|(
name|gap_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_STACK_GAP_DN
operator|)
operator|!=
literal|0
condition|)
block|{
name|stack_entry
operator|=
name|gap_entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|stack_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GROWS_DOWN
operator|)
operator|==
literal|0
operator|||
name|stack_entry
operator|->
name|start
operator|!=
name|gap_entry
operator|->
name|end
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|grow_amount
operator|=
name|round_page
argument_list|(
name|stack_entry
operator|->
name|start
operator|-
name|addr
argument_list|)
expr_stmt|;
name|grow_down
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gap_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_STACK_GAP_UP
operator|)
operator|!=
literal|0
condition|)
block|{
name|stack_entry
operator|=
name|gap_entry
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|(
name|stack_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GROWS_UP
operator|)
operator|==
literal|0
operator|||
name|stack_entry
operator|->
name|end
operator|!=
name|gap_entry
operator|->
name|start
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|grow_amount
operator|=
name|round_page
argument_list|(
name|addr
operator|+
literal|1
operator|-
name|stack_entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|grow_down
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
block|}
name|max_grow
operator|=
name|gap_entry
operator|->
name|end
operator|-
name|gap_entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|guard
operator|>
name|max_grow
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|max_grow
operator|-=
name|guard
expr_stmt|;
if|if
condition|(
name|grow_amount
operator|>
name|max_grow
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
comment|/* 	 * If this is the main process stack, see if we're over the stack 	 * limit. 	 */
name|is_procstack
operator|=
name|addr
operator|>=
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_maxsaddr
operator|&&
name|addr
operator|<
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_sysent
operator|->
name|sv_usrstack
expr_stmt|;
if|if
condition|(
name|is_procstack
operator|&&
operator|(
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
operator|>
name|stacklim
operator|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_procstack
operator|&&
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_STACK
argument_list|,
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|grow_amount
operator|=
name|roundup
argument_list|(
name|grow_amount
argument_list|,
name|sgrowsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|grow_amount
operator|>
name|max_grow
condition|)
name|grow_amount
operator|=
name|max_grow
expr_stmt|;
if|if
condition|(
name|is_procstack
operator|&&
operator|(
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
operator|>
name|stacklim
operator|)
condition|)
block|{
name|grow_amount
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_size_t
operator|)
name|stacklim
argument_list|)
operator|-
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|limit
operator|=
name|racct_get_available
argument_list|(
name|p
argument_list|,
name|RACCT_STACK
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_procstack
operator|&&
operator|(
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
operator|>
name|limit
operator|)
condition|)
name|grow_amount
operator|=
name|limit
operator|-
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|old_mlock
operator|&&
operator|(
name|map
operator|->
name|flags
operator|&
name|MAP_WIREFUTURE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
argument_list|)
operator|+
name|grow_amount
operator|>
name|lmemlim
condition|)
block|{
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_MEMLOCK
argument_list|,
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
argument_list|)
operator|+
name|grow_amount
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If we would blow our VMEM resource limit, no go */
if|if
condition|(
name|map
operator|->
name|size
operator|+
name|grow_amount
operator|>
name|vmemlim
condition|)
block|{
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_VMEM
argument_list|,
name|map
operator|->
name|size
operator|+
name|grow_amount
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|gap_entry
operator|=
name|NULL
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|grow_down
condition|)
block|{
name|grow_start
operator|=
name|gap_entry
operator|->
name|end
operator|-
name|grow_amount
expr_stmt|;
if|if
condition|(
name|gap_entry
operator|->
name|start
operator|+
name|grow_amount
operator|==
name|gap_entry
operator|->
name|end
condition|)
block|{
name|gap_start
operator|=
name|gap_entry
operator|->
name|start
expr_stmt|;
name|gap_end
operator|=
name|gap_entry
operator|->
name|end
expr_stmt|;
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|gap_entry
argument_list|)
expr_stmt|;
name|gap_deleted
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|gap_entry
operator|->
name|start
operator|<
name|gap_entry
operator|->
name|end
operator|-
name|grow_amount
argument_list|)
expr_stmt|;
name|gap_entry
operator|->
name|end
operator|-=
name|grow_amount
expr_stmt|;
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|gap_entry
argument_list|)
expr_stmt|;
name|gap_deleted
operator|=
name|false
expr_stmt|;
block|}
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|grow_start
argument_list|,
name|grow_start
operator|+
name|grow_amount
argument_list|,
name|stack_entry
operator|->
name|protection
argument_list|,
name|stack_entry
operator|->
name|max_protection
argument_list|,
name|MAP_STACK_GROWS_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|gap_deleted
condition|)
block|{
name|rv1
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|gap_start
argument_list|,
name|gap_end
argument_list|,
name|VM_PROT_NONE
argument_list|,
name|VM_PROT_NONE
argument_list|,
name|MAP_CREATE_GUARD
operator||
name|MAP_CREATE_STACK_GAP_DN
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|rv1
operator|==
name|KERN_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gap_entry
operator|->
name|end
operator|+=
name|grow_amount
expr_stmt|;
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|gap_entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|grow_start
operator|=
name|stack_entry
operator|->
name|end
expr_stmt|;
name|cred
operator|=
name|stack_entry
operator|->
name|cred
expr_stmt|;
if|if
condition|(
name|cred
operator|==
name|NULL
operator|&&
name|stack_entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|NULL
condition|)
name|cred
operator|=
name|stack_entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
expr_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
operator|&&
operator|!
name|swap_reserve_by_cred
argument_list|(
name|grow_amount
argument_list|,
name|cred
argument_list|)
condition|)
name|rv
operator|=
name|KERN_NO_SPACE
expr_stmt|;
comment|/* Grow the underlying object if applicable. */
elseif|else
if|if
condition|(
name|stack_entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|||
name|vm_object_coalesce
argument_list|(
name|stack_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|stack_entry
operator|->
name|offset
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|stack_entry
operator|->
name|end
operator|-
name|stack_entry
operator|->
name|start
argument_list|)
argument_list|,
operator|(
name|vm_size_t
operator|)
name|grow_amount
argument_list|,
name|cred
operator|!=
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|gap_entry
operator|->
name|start
operator|+
name|grow_amount
operator|==
name|gap_entry
operator|->
name|end
condition|)
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|gap_entry
argument_list|)
expr_stmt|;
else|else
name|gap_entry
operator|->
name|start
operator|+=
name|grow_amount
expr_stmt|;
name|stack_entry
operator|->
name|end
operator|+=
name|grow_amount
expr_stmt|;
name|map
operator|->
name|size
operator|+=
name|grow_amount
expr_stmt|;
name|vm_map_entry_resize_free
argument_list|(
name|map
argument_list|,
name|stack_entry
argument_list|)
expr_stmt|;
name|rv
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
else|else
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
operator|&&
name|is_procstack
condition|)
name|vm
operator|->
name|vm_ssize
operator|+=
name|btoc
argument_list|(
name|grow_amount
argument_list|)
expr_stmt|;
comment|/* 	 * Heed the MAP_WIREFUTURE flag if it was set for this process. 	 */
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
operator|&&
operator|(
name|map
operator|->
name|flags
operator|&
name|MAP_WIREFUTURE
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_map_wire
argument_list|(
name|map
argument_list|,
name|grow_start
argument_list|,
name|grow_start
operator|+
name|grow_amount
argument_list|,
name|VM_MAP_WIRE_USER
operator||
name|VM_MAP_WIRE_NOHOLES
argument_list|)
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|out
label|:
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
operator|&&
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_VMEM
argument_list|,
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"decreasing RACCT_VMEM failed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_mlock
condition|)
block|{
name|error
operator|=
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_MEMLOCK
argument_list|,
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"decreasing RACCT_MEMLOCK failed"
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|racct_set
argument_list|(
name|p
argument_list|,
name|RACCT_STACK
argument_list|,
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"decreasing RACCT_STACK failed"
operator|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unshare the specified VM space for exec.  If other processes are  * mapped to it, then create a new one.  The new vmspace is null.  */
end_comment

begin_function
name|int
name|vmspace_exec
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|vm_offset_t
name|minuser
parameter_list|,
name|vm_offset_t
name|maxuser
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|oldvmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|newvmspace
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_EXECVMSPC
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vmspace_exec recursed"
operator|)
argument_list|)
expr_stmt|;
name|newvmspace
operator|=
name|vmspace_alloc
argument_list|(
name|minuser
argument_list|,
name|maxuser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvmspace
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|newvmspace
operator|->
name|vm_swrss
operator|=
name|oldvmspace
operator|->
name|vm_swrss
expr_stmt|;
comment|/* 	 * This code is written like this for prototype purposes.  The 	 * goal is to avoid running down the vmspace here, but let the 	 * other process's that are still using the vmspace to finally 	 * run it down.  Even though there is little or no chance of blocking 	 * here, it is a good idea to keep this form for future mods. 	 */
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
name|newvmspace
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curthread
operator|->
name|td_proc
condition|)
name|pmap_activate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_pflags
operator||=
name|TDP_EXECVMSPC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unshare the specified VM space for forcing COW.  This  * is called by rfork, for the (RFMEM|RFPROC) == 0 case.  */
end_comment

begin_function
name|int
name|vmspace_unshare
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|oldvmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|newvmspace
decl_stmt|;
name|vm_ooffset_t
name|fork_charge
decl_stmt|;
if|if
condition|(
name|oldvmspace
operator|->
name|vm_refcnt
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fork_charge
operator|=
literal|0
expr_stmt|;
name|newvmspace
operator|=
name|vmspace_fork
argument_list|(
name|oldvmspace
argument_list|,
operator|&
name|fork_charge
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvmspace
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|!
name|swap_reserve_by_cred
argument_list|(
name|fork_charge
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
block|{
name|vmspace_free
argument_list|(
name|newvmspace
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|PROC_VMSPACE_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
name|newvmspace
expr_stmt|;
name|PROC_VMSPACE_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curthread
operator|->
name|td_proc
condition|)
name|pmap_activate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|oldvmspace
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup:  *  *	Finds the VM object, offset, and  *	protection for a given virtual address in the  *	specified map, assuming a page fault of the  *	type specified.  *  *	Leaves the map in question locked for read; return  *	values are guaranteed until a vm_map_lookup_done  *	call is performed.  Note that the map argument  *	is in/out; the returned map must be used in  *	the call to vm_map_lookup_done.  *  *	A handle (out_entry) is returned for use in  *	vm_map_lookup_done, to make that fast.  *  *	If a lookup is requested with "write protection"  *	specified, the map may be changed to perform virtual  *	copying operations, although the data referenced will  *	remain the same.  */
end_comment

begin_function
name|int
name|vm_map_lookup
parameter_list|(
name|vm_map_t
modifier|*
name|var_map
parameter_list|,
comment|/* IN/OUT */
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_prot_t
name|fault_typea
parameter_list|,
name|vm_map_entry_t
modifier|*
name|out_entry
parameter_list|,
comment|/* OUT */
name|vm_object_t
modifier|*
name|object
parameter_list|,
comment|/* OUT */
name|vm_pindex_t
modifier|*
name|pindex
parameter_list|,
comment|/* OUT */
name|vm_prot_t
modifier|*
name|out_prot
parameter_list|,
comment|/* OUT */
name|boolean_t
modifier|*
name|wired
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|*
name|var_map
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_prot_t
name|fault_type
init|=
name|fault_typea
decl_stmt|;
name|vm_object_t
name|eobject
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|RetryLookup
label|:
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|RetryLookupLocked
label|:
comment|/* 	 * Lookup the faulting address. 	 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|vaddr
argument_list|,
name|out_entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
name|entry
operator|=
operator|*
name|out_entry
expr_stmt|;
comment|/* 	 * Handle submaps. 	 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_t
name|old_map
init|=
name|map
decl_stmt|;
operator|*
name|var_map
operator|=
name|map
operator|=
name|entry
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
goto|goto
name|RetryLookup
goto|;
block|}
comment|/* 	 * Check whether this task is allowed to have this page. 	 */
name|prot
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
if|if
condition|(
operator|(
name|fault_typea
operator|&
name|VM_PROT_FAULT_LOOKUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fault_typea
operator|&=
operator|~
name|VM_PROT_FAULT_LOOKUP
expr_stmt|;
if|if
condition|(
name|prot
operator|==
name|VM_PROT_NONE
operator|&&
name|map
operator|!=
name|kernel_map
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_GUARD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_STACK_GAP_DN
operator||
name|MAP_ENTRY_STACK_GAP_UP
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|vm_map_growstack
argument_list|(
name|map
argument_list|,
name|vaddr
argument_list|,
name|entry
argument_list|)
operator|==
name|KERN_SUCCESS
condition|)
goto|goto
name|RetryLookupLocked
goto|;
block|}
name|fault_type
operator|&=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
operator|(
name|fault_type
operator|&
name|prot
operator|)
operator|!=
name|fault_type
operator|||
name|prot
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|||
operator|(
name|entry
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_USER_WIRED
operator||
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|)
operator|!=
operator|(
name|MAP_ENTRY_USER_WIRED
operator||
name|MAP_ENTRY_NEEDS_COPY
operator|)
argument_list|,
operator|(
literal|"entry %p flags %x"
operator|,
name|entry
operator|,
name|entry
operator|->
name|eflags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fault_typea
operator|&
name|VM_PROT_COPY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|entry
operator|->
name|max_protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
block|}
comment|/* 	 * If this page is not pageable, we have to get it for all possible 	 * accesses. 	 */
operator|*
name|wired
operator|=
operator|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|wired
condition|)
name|fault_type
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
name|size
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
comment|/* 	 * If the entry was copy-on-write, we either ... 	 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
condition|)
block|{
comment|/* 		 * If we want to write the page, we may as well handle that 		 * now since we've got the map locked. 		 * 		 * If we don't need to write the page, we just demote the 		 * permissions allowed. 		 */
if|if
condition|(
operator|(
name|fault_type
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fault_typea
operator|&
name|VM_PROT_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Make a new object, and place it in the object 			 * chain.  Note that no new references have appeared 			 * -- one just moved from the map to the new 			 * object. 			 */
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|RetryLookup
goto|;
if|if
condition|(
name|entry
operator|->
name|cred
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * The debugger owner is charged for 				 * the memory. 				 */
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|swap_reserve_by_cred
argument_list|(
name|size
argument_list|,
name|cred
argument_list|)
condition|)
block|{
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
block|}
name|entry
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
block|}
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
name|eobject
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|eobject
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * The object was not shadowed. 				 */
name|swap_release_by_cred
argument_list|(
name|size
argument_list|,
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|entry
operator|->
name|cred
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|eobject
argument_list|)
expr_stmt|;
name|eobject
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|eobject
operator|->
name|charge
operator|=
name|size
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|eobject
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're attempting to read a copy-on-write page -- 			 * don't allow writes. 			 */
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
block|}
block|}
comment|/* 	 * Create an object if necessary. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|RetryLookup
goto|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|=
name|entry
operator|->
name|cred
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|charge
operator|=
name|size
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the object/offset from this entry.  If the entry was 	 * copy-on-write or empty, it has been fixed up. 	 */
operator|*
name|pindex
operator|=
name|UOFF_TO_IDX
argument_list|(
operator|(
name|vaddr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
operator|*
name|out_prot
operator|=
name|prot
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup_locked:  *  *	Lookup the faulting address.  A version of vm_map_lookup that returns   *      KERN_FAILURE instead of blocking on map lock or memory allocation.  */
end_comment

begin_function
name|int
name|vm_map_lookup_locked
parameter_list|(
name|vm_map_t
modifier|*
name|var_map
parameter_list|,
comment|/* IN/OUT */
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_prot_t
name|fault_typea
parameter_list|,
name|vm_map_entry_t
modifier|*
name|out_entry
parameter_list|,
comment|/* OUT */
name|vm_object_t
modifier|*
name|object
parameter_list|,
comment|/* OUT */
name|vm_pindex_t
modifier|*
name|pindex
parameter_list|,
comment|/* OUT */
name|vm_prot_t
modifier|*
name|out_prot
parameter_list|,
comment|/* OUT */
name|boolean_t
modifier|*
name|wired
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|*
name|var_map
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_prot_t
name|fault_type
init|=
name|fault_typea
decl_stmt|;
comment|/* 	 * Lookup the faulting address. 	 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|vaddr
argument_list|,
name|out_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
name|entry
operator|=
operator|*
name|out_entry
expr_stmt|;
comment|/* 	 * Fail if the entry refers to a submap. 	 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
comment|/* 	 * Check whether this task is allowed to have this page. 	 */
name|prot
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
name|fault_type
operator|&=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
operator|(
name|fault_type
operator|&
name|prot
operator|)
operator|!=
name|fault_type
condition|)
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
comment|/* 	 * If this page is not pageable, we have to get it for all possible 	 * accesses. 	 */
operator|*
name|wired
operator|=
operator|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|wired
condition|)
name|fault_type
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
condition|)
block|{
comment|/* 		 * Fail if the entry was copy-on-write for a write fault. 		 */
if|if
condition|(
name|fault_type
operator|&
name|VM_PROT_WRITE
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
comment|/* 		 * We're attempting to read a copy-on-write page -- 		 * don't allow writes. 		 */
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
block|}
comment|/* 	 * Fail if an object should be created. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
comment|/* 	 * Return the object/offset from this entry.  If the entry was 	 * copy-on-write or empty, it has been fixed up. 	 */
operator|*
name|pindex
operator|=
name|UOFF_TO_IDX
argument_list|(
operator|(
name|vaddr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
operator|*
name|out_prot
operator|=
name|prot
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup_done:  *  *	Releases locks acquired by a vm_map_lookup  *	(according to the handle returned by that lookup).  */
end_comment

begin_function
name|void
name|vm_map_lookup_done
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
comment|/* 	 * Unlock the main-level map 	 */
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_function
specifier|static
name|void
name|vm_map_print
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|db_iprintf
argument_list|(
literal|"Task map %p: pmap=%p, nentries=%d, version=%u\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|map
operator|->
name|pmap
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|map
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|db_indent
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|db_iprintf
argument_list|(
literal|"map entry %p: start=%p, end=%p, eflags=%#x, \n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|end
argument_list|,
name|entry
operator|->
name|eflags
argument_list|)
expr_stmt|;
block|{
specifier|static
name|char
modifier|*
name|inheritance_name
index|[
literal|4
index|]
init|=
block|{
literal|"share"
block|,
literal|"copy"
block|,
literal|"none"
block|,
literal|"donate_copy"
block|}
decl_stmt|;
name|db_iprintf
argument_list|(
literal|" prot=%x/%x/%s"
argument_list|,
name|entry
operator|->
name|protection
argument_list|,
name|entry
operator|->
name|max_protection
argument_list|,
name|inheritance_name
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|entry
operator|->
name|inheritance
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|", wired"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|db_printf
argument_list|(
literal|", share=%p, offset=0x%jx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|object
operator|.
name|sub_map
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|sub_map
operator|!=
name|entry
operator|->
name|object
operator|.
name|sub_map
operator|)
condition|)
block|{
name|db_indent
operator|+=
literal|2
expr_stmt|;
name|vm_map_print
argument_list|(
operator|(
name|vm_map_t
operator|)
name|entry
operator|->
name|object
operator|.
name|sub_map
argument_list|)
expr_stmt|;
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|", ruid %d"
argument_list|,
name|entry
operator|->
name|cred
operator|->
name|cr_ruid
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|", object=%p, offset=0x%jx"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|&&
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
condition|)
name|db_printf
argument_list|(
literal|", obj ruid %d charge %jx"
argument_list|,
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|cred
operator|->
name|cr_ruid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|charge
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
condition|)
name|db_printf
argument_list|(
literal|", copy (%s)"
argument_list|,
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|?
literal|"needed"
else|:
literal|"done"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
condition|)
block|{
name|db_indent
operator|+=
literal|2
expr_stmt|;
name|vm_object_print
argument_list|(
operator|(
name|db_expr_t
operator|)
operator|(
name|intptr_t
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|map
argument_list|,
argument|map
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show map<addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vm_map_print
argument_list|(
operator|(
name|vm_map_t
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|procvm
argument_list|,
argument|procvm
argument_list|)
end_macro

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|have_addr
condition|)
block|{
name|p
operator|=
name|db_lookup_proc
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|curproc
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"p = %p, vmspace = %p, map = %p, pmap = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
operator|->
name|p_vmspace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vmspace_pmap
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
argument_list|)
expr_stmt|;
name|vm_map_print
argument_list|(
operator|(
name|vm_map_t
operator|)
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

