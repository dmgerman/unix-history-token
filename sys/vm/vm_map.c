begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_map.c	8.3 (Berkeley) 1/12/94  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *	Virtual memory mapping module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  *	Virtual memory maps provide for the mapping, protection,  *	and sharing of virtual memory objects.  In addition,  *	this module provides for an efficient virtual copy of  *	memory from one map to another.  *  *	Synchronization is required prior to most operations.  *  *	Maps consist of an ordered doubly-linked list of simple  *	entries; a single hint is used to speed up lookups.  *  *	Since portions of maps are specified by start/end addresses,  *	which may not align with existing map entries, all  *	routines merely "clip" entries to these start/end values.  *	[That is, an entry is split into two, bordering at a  *	start or end value.]  Note that these clippings may not  *	always be necessary (as the two resulting entries are then  *	not changed); however, the clipping is done for convenience.  *  *	As mentioned above, virtual copy operations are performed  *	by copying VM object references from one map to  *	another, and then marking both regions as copy-on-write.  */
end_comment

begin_comment
comment|/*  *	vm_map_startup:  *  *	Initialize the vm_map module.  Must be called before  *	any other vm_map routines.  *  *	Map and entry structures are allocated from the general  *	purpose memory pool with some exceptions:  *  *	- The kernel map and kmem submap are allocated statically.  *	- Kernel map entries are allocated out of a static pool.  *  *	These restrictions are necessary since malloc() uses the  *	maps and requires map entries.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mapentzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kmapentzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mapzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|vmspace_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|kmapentobj
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vmspace_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmspace_zfini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_map_zfini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|vm_map_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmspace_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|vm_map_startup
parameter_list|(
name|void
parameter_list|)
block|{
name|mapzone
operator|=
name|uma_zcreate
argument_list|(
literal|"MAP"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
argument_list|,
name|NULL
argument_list|,
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_map_zdtor
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|vm_map_zinit
argument_list|,
name|vm_map_zfini
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|mapzone
argument_list|,
name|MAX_KMAP
argument_list|)
expr_stmt|;
name|kmapentzone
operator|=
name|uma_zcreate
argument_list|(
literal|"KMAP ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|kmapentzone
argument_list|,
name|MAX_KMAPENT
argument_list|)
expr_stmt|;
name|mapentzone
operator|=
name|uma_zcreate
argument_list|(
literal|"MAP ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|mapentzone
argument_list|,
name|MAX_MAPENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmspace_zfini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
operator|(
expr|struct
name|vmspace
operator|*
operator|)
name|mem
expr_stmt|;
name|vm_map_zfini
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_map
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vmspace_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
operator|(
expr|struct
name|vmspace
operator|*
operator|)
name|mem
expr_stmt|;
name|vm_map_zinit
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_map
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_zfini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|map
operator|=
operator|(
name|vm_map_t
operator|)
name|mem
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|map
operator|=
operator|(
name|vm_map_t
operator|)
name|mem
expr_stmt|;
name|map
operator|->
name|nentries
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|infork
operator|=
literal|0
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|PVM
argument_list|,
literal|"thrd_sleep"
argument_list|,
literal|0
argument_list|,
name|LK_NOPAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function
specifier|static
name|void
name|vmspace_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm
operator|=
operator|(
expr|struct
name|vmspace
operator|*
operator|)
name|mem
expr_stmt|;
name|vm_map_zdtor
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
sizeof|sizeof
argument_list|(
name|vm
operator|->
name|vm_map
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_map_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|map
operator|=
operator|(
name|vm_map_t
operator|)
name|mem
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|nentries
operator|==
literal|0
argument_list|,
operator|(
literal|"map %p nentries == %d on free."
operator|,
name|map
operator|,
name|map
operator|->
name|nentries
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|size
operator|==
literal|0
argument_list|,
operator|(
literal|"map %p size == %lu on free."
operator|,
name|map
operator|,
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|map
operator|->
name|infork
operator|==
literal|0
argument_list|,
operator|(
literal|"map %p infork == %d on free."
operator|,
name|map
operator|,
name|map
operator|->
name|infork
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANTS */
end_comment

begin_comment
comment|/*  * Allocate a vmspace structure, including a vm_map and pmap,  * and initialize those structures.  The refcnt is set to 1.  * The remaining fields must be initialized by the caller.  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_alloc
parameter_list|(
name|min
parameter_list|,
name|max
parameter_list|)
name|vm_offset_t
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm
operator|=
name|uma_zalloc
argument_list|(
name|vmspace_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vmspace_alloc: %p"
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|_vm_map_init
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_map
operator|.
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* XXX */
name|vm
operator|->
name|vm_refcnt
operator|=
literal|1
expr_stmt|;
name|vm
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
name|vm
operator|->
name|vm_freer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|vm
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_init2
parameter_list|(
name|void
parameter_list|)
block|{
name|uma_zone_set_obj
argument_list|(
name|kmapentzone
argument_list|,
operator|&
name|kmapentobj
argument_list|,
name|cnt
operator|.
name|v_page_count
operator|/
literal|4
argument_list|)
expr_stmt|;
name|vmspace_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"VMSPACE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmspace
argument_list|)
argument_list|,
name|NULL
argument_list|,
ifdef|#
directive|ifdef
name|INVARIANTS
name|vmspace_zdtor
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|vmspace_zinit
argument_list|,
name|vmspace_zfini
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|pmap_init2
argument_list|()
expr_stmt|;
name|vm_object_init2
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vmspace_dofree
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vmspace_free: %p"
argument_list|,
name|vm
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the map, to wait out all other references to it. 	 * Delete all of the mappings and pages they hold, then call 	 * the pmap module to reclaim anything left. 	 */
name|vm_map_lock
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_delete
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|min_offset
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|max_offset
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|)
expr_stmt|;
name|pmap_release
argument_list|(
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vmspace_zone
argument_list|,
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmspace_free
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_refcnt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vmspace_free: attempt to free already freed vmspace"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|vm
operator|->
name|vm_refcnt
operator|==
literal|0
condition|)
name|vmspace_dofree
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmspace_exitfree
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|p
operator|->
name|p_vmspace
operator|->
name|vm_freer
condition|)
name|vmspace_dofree
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vmspace_swap_count() - count the approximate swap useage in pages for a  *			  vmspace.  *  *	Swap useage is determined by taking the proportional swap used by  *	VM objects backing the VM map.  To make up for fractional losses,  *	if the VM object has any swap use at all the associated map entries  *	count for at least 1 swap page.  */
end_comment

begin_function
name|int
name|vmspace_swap_count
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
name|vm_map_t
name|map
init|=
operator|&
name|vmspace
operator|->
name|vm_map
decl_stmt|;
name|vm_map_entry_t
name|cur
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|cur
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
operator|(
name|cur
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|object
operator|=
name|cur
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|!=
name|NULL
operator|&&
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|int
name|n
init|=
operator|(
name|cur
operator|->
name|end
operator|-
name|cur
operator|->
name|start
operator|)
operator|/
name|PAGE_SIZE
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
condition|)
block|{
name|count
operator|+=
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
operator|*
name|SWAP_META_PAGES
operator|*
name|n
operator|/
name|object
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|u_char
name|vm_map_entry_behavior
parameter_list|(
name|struct
name|vm_map_entry
modifier|*
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_BEHAV_MASK
return|;
block|}
end_function

begin_function
name|void
name|vm_map_entry_set_behavior
parameter_list|(
name|struct
name|vm_map_entry
modifier|*
name|entry
parameter_list|,
name|u_char
name|behavior
parameter_list|)
block|{
name|entry
operator|->
name|eflags
operator|=
operator|(
name|entry
operator|->
name|eflags
operator|&
operator|~
name|MAP_ENTRY_BEHAV_MASK
operator|)
operator||
operator|(
name|behavior
operator|&
name|MAP_ENTRY_BEHAV_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_lock
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_printf
argument_list|(
literal|"locking map LK_EXCLUSIVE: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockmgr
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vm_map_lock: failed to get lock"
argument_list|)
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_unlock
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_printf
argument_list|(
literal|"locking map LK_RELEASE: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
operator|(
name|map
operator|)
operator|->
name|lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_lock_read
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_printf
argument_list|(
literal|"locking map LK_SHARED: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
operator|(
name|map
operator|)
operator|->
name|lock
argument_list|,
name|LK_SHARED
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_unlock_read
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_printf
argument_list|(
literal|"locking map LK_RELEASE: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
operator|(
name|map
operator|)
operator|->
name|lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|_vm_map_lock_upgrade
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vm_map_printf
argument_list|(
literal|"locking map LK_EXCLUPGRADE: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|lockmgr
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|LK_EXCLUPGRADE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|vm_map_lock_upgrade
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|_vm_map_lock_upgrade
argument_list|(
name|map
argument_list|,
name|curthread
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_map_lock_downgrade
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_printf
argument_list|(
literal|"locking map LK_DOWNGRADE: %p\n"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_set_recursive
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|(
name|map
operator|)
operator|->
name|lock
operator|.
name|lk_interlock
argument_list|)
expr_stmt|;
name|map
operator|->
name|lock
operator|.
name|lk_flags
operator||=
name|LK_CANRECURSE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|(
name|map
operator|)
operator|->
name|lock
operator|.
name|lk_interlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_clear_recursive
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|(
name|map
operator|)
operator|->
name|lock
operator|.
name|lk_interlock
argument_list|)
expr_stmt|;
name|map
operator|->
name|lock
operator|.
name|lk_flags
operator|&=
operator|~
name|LK_CANRECURSE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|(
name|map
operator|)
operator|->
name|lock
operator|.
name|lk_interlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|vm_map_min
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|map
operator|->
name|min_offset
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|vm_map_max
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|map
operator|->
name|max_offset
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pmap
modifier|*
name|vm_map_pmap
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
return|return
operator|(
name|map
operator|->
name|pmap
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pmap
modifier|*
name|vmspace_pmap
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
return|return
operator|&
name|vmspace
operator|->
name|vm_pmap
return|;
block|}
end_function

begin_function
name|long
name|vmspace_resident_count
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
return|return
name|pmap_resident_count
argument_list|(
name|vmspace_pmap
argument_list|(
name|vmspace
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_create:  *  *	Creates and returns a new empty VM map with  *	the given physical map structure, and having  *	the given lower and upper address bounds.  */
end_comment

begin_function
name|vm_map_t
name|vm_map_create
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|vm_map_t
name|result
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|result
operator|=
name|uma_zalloc
argument_list|(
name|mapzone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_create: %p"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|_vm_map_init
argument_list|(
name|result
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|result
operator|->
name|pmap
operator|=
name|pmap
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an existing vm_map structure  * such as that in the vmspace structure.  * The pmap is set elsewhere.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
name|map
operator|->
name|header
operator|.
name|next
operator|=
name|map
operator|->
name|header
operator|.
name|prev
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|system_map
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|min_offset
operator|=
name|min
expr_stmt|;
name|map
operator|->
name|max_offset
operator|=
name|max
expr_stmt|;
name|map
operator|->
name|first_free
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|hint
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_map_init
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|min
parameter_list|,
name|vm_offset_t
name|max
parameter_list|)
block|{
name|_vm_map_init
argument_list|(
name|map
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|PVM
argument_list|,
literal|"thrd_sleep"
argument_list|,
literal|0
argument_list|,
name|LK_NOPAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_dispose:	[ internal use only ]  *  *	Inverse of vm_map_entry_create.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_dispose
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|uma_zfree
argument_list|(
operator|(
name|map
operator|->
name|system_map
operator|||
operator|!
name|mapentzone
operator|)
condition|?
name|kmapentzone
else|:
name|mapentzone
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_create:	[ internal use only ]  *  *	Allocates a VM map entry for insertion.  *	No entry fields are filled in.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|vm_map_entry_create
parameter_list|(
name|vm_map_t
name|map
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|new_entry
operator|=
name|uma_zalloc
argument_list|(
operator|(
name|map
operator|->
name|system_map
operator|||
operator|!
name|mapentzone
operator|)
condition|?
name|kmapentzone
else|:
name|mapentzone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_entry
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_map_entry_create: kernel resources exhausted"
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_{un,}link:  *  *	Insert/remove entries from maps.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|vm_map_entry_link
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|after_where
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_entry_link: map %p, nentries %d, entry %p, after %p"
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|entry
argument_list|,
name|after_where
argument_list|)
expr_stmt|;
name|map
operator|->
name|nentries
operator|++
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|after_where
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|after_where
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|after_where
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|vm_map_entry_unlink
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_entry_t
name|prev
init|=
name|entry
operator|->
name|prev
decl_stmt|;
name|vm_map_entry_t
name|next
init|=
name|entry
operator|->
name|next
decl_stmt|;
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|map
operator|->
name|nentries
operator|--
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_VM
argument_list|,
literal|"vm_map_entry_unlink: map %p, nentries %d, entry %p"
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	SAVE_HINT:  *  *	Saves the specified entry as the hint for  *	future lookups.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_HINT
parameter_list|(
name|map
parameter_list|,
name|value
parameter_list|)
define|\
value|(map)->hint = (value);
end_define

begin_comment
comment|/*  *	vm_map_lookup_entry:	[ internal use only ]  *  *	Finds the map entry containing (or  *	immediately preceding) the specified address  *	in the given map; the entry is returned  *	in the "entry" parameter.  The boolean  *	result indicates whether the address is  *	actually contained in the map.  */
end_comment

begin_function
name|boolean_t
name|vm_map_lookup_entry
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|address
parameter_list|,
name|vm_map_entry_t
modifier|*
name|entry
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|cur
decl_stmt|;
name|vm_map_entry_t
name|last
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Start looking either from the head of the list, or from the hint. 	 */
name|cur
operator|=
name|map
operator|->
name|hint
expr_stmt|;
if|if
condition|(
name|cur
operator|==
operator|&
name|map
operator|->
name|header
condition|)
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
condition|)
block|{
comment|/* 		 * Go from hint to end of list. 		 * 		 * But first, make a quick check to see if we are already looking 		 * at the entry we want (which is usually the case). Note also 		 * that we don't need to save the hint here... it is the same 		 * hint (unless we are at the header, in which case the hint 		 * didn't buy us anything anyway). 		 */
name|last
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|cur
operator|!=
name|last
operator|)
operator|&&
operator|(
name|cur
operator|->
name|end
operator|>
name|address
operator|)
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Go from start to hint, *inclusively* 		 */
name|last
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|=
name|map
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
comment|/* 	 * Search linearly 	 */
while|while
condition|(
name|cur
operator|!=
name|last
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|end
operator|>
name|address
condition|)
block|{
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
condition|)
block|{
comment|/* 				 * Save this lookup for future hints, and 				 * return 				 */
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entry
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
operator|*
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_insert:  *  *	Inserts the given whole VM object into the target  *	map at the specified address range.  The object's  *	size should match that of the address range.  *  *	Requires that the map be locked, and leaves it so.  *  *	If object is non-NULL, ref count must be bumped by caller  *	prior to making call to account for the new entry.  */
end_comment

begin_function
name|int
name|vm_map_insert
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|vm_map_entry_t
name|prev_entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
name|vm_eflags_t
name|protoeflags
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Check that the start and end points are not bogus. 	 */
if|if
condition|(
operator|(
name|start
operator|<
name|map
operator|->
name|min_offset
operator|)
operator|||
operator|(
name|end
operator|>
name|map
operator|->
name|max_offset
operator|)
operator|||
operator|(
name|start
operator|>=
name|end
operator|)
condition|)
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
comment|/* 	 * Find the entry prior to the proposed starting address; if it's part 	 * of an existing entry, this range is bogus. 	 */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|prev_entry
operator|=
name|temp_entry
expr_stmt|;
comment|/* 	 * Assert that the next entry doesn't overlap the end point. 	 */
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|next
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|next
operator|->
name|start
operator|<
name|end
operator|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|protoeflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_COPY_ON_WRITE
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_NOFAULT
condition|)
block|{
name|protoeflags
operator||=
name|MAP_ENTRY_NOFAULT
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|==
name|NULL
argument_list|,
operator|(
literal|"vm_map_insert: paradoxical MAP_NOFAULT request"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cow
operator|&
name|MAP_DISABLE_SYNCER
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_NOSYNC
expr_stmt|;
if|if
condition|(
name|cow
operator|&
name|MAP_DISABLE_COREDUMP
condition|)
name|protoeflags
operator||=
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
if|if
condition|(
name|object
condition|)
block|{
comment|/* 		 * When object is non-NULL, it could be shared with another 		 * process.  We have to set or clear OBJ_ONEMAPPING  		 * appropriately. 		 */
if|if
condition|(
operator|(
name|object
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|||
operator|(
name|object
operator|->
name|shadow_count
operator|!=
literal|0
operator|)
condition|)
block|{
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|prev_entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|eflags
operator|==
name|protoeflags
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|end
operator|==
name|start
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|wired_count
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|)
operator|||
name|vm_object_coalesce
argument_list|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|prev_entry
operator|->
name|offset
argument_list|)
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
argument_list|)
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|end
operator|-
name|prev_entry
operator|->
name|end
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We were able to extend the object.  Determine if we 		 * can extend the previous map entry to include the  		 * new range as well. 		 */
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|inheritance
operator|==
name|VM_INHERIT_DEFAULT
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|protection
operator|==
name|prot
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|max_protection
operator|==
name|max
operator|)
condition|)
block|{
name|map
operator|->
name|size
operator|+=
operator|(
name|end
operator|-
name|prev_entry
operator|->
name|end
operator|)
expr_stmt|;
name|prev_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
comment|/* 		 * If we can extend the object but cannot extend the 		 * map entry, we have to create a new map entry.  We 		 * must bump the ref count on the extended object to 		 * account for it.  object may be NULL. 		 */
name|object
operator|=
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|offset
operator|=
name|prev_entry
operator|->
name|offset
operator|+
operator|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NOTE: if conditionals fail, object can be NULL here.  This occurs 	 * in things like the buffer map where we manage kva but do not manage 	 * backing objects. 	 */
comment|/* 	 * Create a new entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|=
name|protoeflags
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|new_entry
operator|->
name|avail_ssize
operator|=
literal|0
expr_stmt|;
name|new_entry
operator|->
name|inheritance
operator|=
name|VM_INHERIT_DEFAULT
expr_stmt|;
name|new_entry
operator|->
name|protection
operator|=
name|prot
expr_stmt|;
name|new_entry
operator|->
name|max_protection
operator|=
name|max
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Insert the new entry into the list 	 */
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|map
operator|->
name|size
operator|+=
name|new_entry
operator|->
name|end
operator|-
name|new_entry
operator|->
name|start
expr_stmt|;
comment|/* 	 * Update the free space hint 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|first_free
operator|==
name|prev_entry
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|end
operator|>=
name|new_entry
operator|->
name|start
operator|)
condition|)
block|{
name|map
operator|->
name|first_free
operator|=
name|new_entry
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Temporarily removed to avoid MAP_STACK panic, due to 	 * MAP_STACK being a huge hack.  Will be added back in 	 * when MAP_STACK (and the user stack mapping) is fixed. 	 */
comment|/* 	 * It may be possible to simplify the entry 	 */
block|vm_map_simplify_entry(map, new_entry);
endif|#
directive|endif
if|if
condition|(
name|cow
operator|&
operator|(
name|MAP_PREFAULT
operator||
name|MAP_PREFAULT_PARTIAL
operator|)
condition|)
block|{
name|pmap_object_init_pt
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|start
argument_list|,
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|cow
operator|&
name|MAP_PREFAULT_PARTIAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find sufficient space for `length' bytes in the given map, starting at  * `start'.  The map must be locked.  Returns 0 on success, 1 on no space.  */
end_comment

begin_function
name|int
name|vm_map_findspace
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_size_t
name|length
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|,
name|next
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|map
operator|->
name|min_offset
condition|)
name|start
operator|=
name|map
operator|->
name|min_offset
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|map
operator|->
name|max_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Look for the first possible address; if there's already something 	 * at this address, we have to start after it. 	 */
if|if
condition|(
name|start
operator|==
name|map
operator|->
name|min_offset
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|map
operator|->
name|first_free
operator|)
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
name|start
operator|=
name|entry
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
name|vm_map_entry_t
name|tmp
decl_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|start
operator|=
name|tmp
operator|->
name|end
expr_stmt|;
name|entry
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * Look through the rest of the map, trying to fit a new region in the 	 * gap between existing regions, or after the very last region. 	 */
for|for
control|(
init|;
condition|;
name|start
operator|=
operator|(
name|entry
operator|=
name|next
operator|)
operator|->
name|end
control|)
block|{
comment|/* 		 * Find the end of the proposed new region.  Be sure we didn't 		 * go beyond the end of the map, or wrap around the address; 		 * if so, we lose.  Otherwise, if this is the last entry, or 		 * if the proposed new region fits before the next entry, we 		 * win. 		 */
name|end
operator|=
name|start
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|map
operator|->
name|max_offset
operator|||
name|end
operator|<
name|start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|next
operator|->
name|start
operator|>=
name|end
condition|)
break|break;
block|}
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kernel_map
condition|)
block|{
name|vm_offset_t
name|ksize
decl_stmt|;
if|if
condition|(
operator|(
name|ksize
operator|=
name|round_page
argument_list|(
name|start
operator|+
name|length
argument_list|)
operator|)
operator|>
name|kernel_vm_end
condition|)
block|{
name|pmap_growkernel
argument_list|(
name|ksize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_find finds an unallocated region in the target address  *	map with the given length.  The search is defined to be  *	first-fit from the specified address; the region found is  *	returned in the same parameter.  *  *	If object is non-NULL, ref count must be bumped by caller  *	prior to making call to account for the new entry.  */
end_comment

begin_function
name|int
name|vm_map_find
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
comment|/* IN/OUT */
name|vm_size_t
name|length
parameter_list|,
name|boolean_t
name|find_space
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_offset_t
name|start
decl_stmt|;
name|int
name|result
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|start
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_space
condition|)
block|{
if|if
condition|(
name|vm_map_findspace
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
name|start
operator|=
operator|*
name|addr
expr_stmt|;
block|}
name|result
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_simplify_entry:  *  *	Simplify the given map entry by merging with either neighbor.  This  *	routine also has the ability to merge with both neighbors.  *  *	The map must be locked.  *  *	This routine guarentees that the passed entry remains valid (though  *	possibly extended).  When merging, this routine may delete one or  *	both neighbors.  */
end_comment

begin_function
name|void
name|vm_map_simplify_entry
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|vm_size_t
name|prevsize
decl_stmt|,
name|esize
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
return|return;
name|prev
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|prevsize
operator|=
name|prev
operator|->
name|end
operator|-
name|prev
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|prev
operator|->
name|end
operator|==
name|entry
operator|->
name|start
operator|)
operator|&&
operator|(
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|==
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|&&
operator|(
operator|!
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|||
operator|(
name|prev
operator|->
name|offset
operator|+
name|prevsize
operator|==
name|entry
operator|->
name|offset
operator|)
operator|)
operator|&&
operator|(
name|prev
operator|->
name|eflags
operator|==
name|entry
operator|->
name|eflags
operator|)
operator|&&
operator|(
name|prev
operator|->
name|protection
operator|==
name|entry
operator|->
name|protection
operator|)
operator|&&
operator|(
name|prev
operator|->
name|max_protection
operator|==
name|entry
operator|->
name|max_protection
operator|)
operator|&&
operator|(
name|prev
operator|->
name|inheritance
operator|==
name|entry
operator|->
name|inheritance
operator|)
operator|&&
operator|(
name|prev
operator|->
name|wired_count
operator|==
name|entry
operator|->
name|wired_count
operator|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|first_free
operator|==
name|prev
condition|)
name|map
operator|->
name|first_free
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|hint
operator|==
name|prev
condition|)
name|map
operator|->
name|hint
operator|=
name|entry
expr_stmt|;
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|prev
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
name|prev
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|object
operator|.
name|vm_object
condition|)
name|vm_object_deallocate
argument_list|(
name|prev
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|esize
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|end
operator|==
name|next
operator|->
name|start
operator|)
operator|&&
operator|(
name|next
operator|->
name|object
operator|.
name|vm_object
operator|==
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|||
operator|(
name|entry
operator|->
name|offset
operator|+
name|esize
operator|==
name|next
operator|->
name|offset
operator|)
operator|)
operator|&&
operator|(
name|next
operator|->
name|eflags
operator|==
name|entry
operator|->
name|eflags
operator|)
operator|&&
operator|(
name|next
operator|->
name|protection
operator|==
name|entry
operator|->
name|protection
operator|)
operator|&&
operator|(
name|next
operator|->
name|max_protection
operator|==
name|entry
operator|->
name|max_protection
operator|)
operator|&&
operator|(
name|next
operator|->
name|inheritance
operator|==
name|entry
operator|->
name|inheritance
operator|)
operator|&&
operator|(
name|next
operator|->
name|wired_count
operator|==
name|entry
operator|->
name|wired_count
operator|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|first_free
operator|==
name|next
condition|)
name|map
operator|->
name|first_free
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|hint
operator|==
name|next
condition|)
name|map
operator|->
name|hint
operator|=
name|entry
expr_stmt|;
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|next
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|object
operator|.
name|vm_object
condition|)
name|vm_object_deallocate
argument_list|(
name|next
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_start:	[ internal use only ]  *  *	Asserts that the given entry begins at or after  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_clip_start
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|startaddr
parameter_list|)
define|\
value|{ \ 	if (startaddr> entry->start) \ 		_vm_map_clip_start(map, entry, startaddr); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_clip_start
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|start
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
comment|/* 	 * Split off the front portion -- note that we must insert the new 	 * entry BEFORE this one, so that this entry has the specified 	 * starting address. 	 */
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no object backing this entry, we might as well create 	 * one now.  If we defer it, an object can get created after the map 	 * is clipped, and individual objects will be created for the split-up 	 * map.  This is a bit of a hack, but is also about the best place to 	 * put this improvement. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|offset
operator|+=
operator|(
name|start
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_end:	[ internal use only ]  *  *	Asserts that the given entry ends at or before  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_clip_end
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|endaddr
parameter_list|)
define|\
value|{ \ 	if (endaddr< entry->end) \ 		_vm_map_clip_end(map, entry, endaddr); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
specifier|static
name|void
name|_vm_map_clip_end
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_map_entry_t
name|new_entry
decl_stmt|;
comment|/* 	 * If there is no object backing this entry, we might as well create 	 * one now.  If we defer it, an object can get created after the map 	 * is clipped, and individual objects will be created for the split-up 	 * map.  This is a bit of a hack, but is also about the best place to 	 * put this improvement. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Create a new entry and insert it AFTER the specified entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|+=
operator|(
name|end
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	VM_MAP_RANGE_CHECK:	[ internal use only ]  *  *	Asserts that the starting and ending region  *	addresses fall within the valid range of the map.  */
end_comment

begin_define
define|#
directive|define
name|VM_MAP_RANGE_CHECK
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
define|\
value|{					\ 		if (start< vm_map_min(map))		\ 			start = vm_map_min(map);	\ 		if (end> vm_map_max(map))		\ 			end = vm_map_max(map);		\ 		if (start> end)			\ 			start = end;			\ 		}
end_define

begin_comment
comment|/*  *	vm_map_submap:		[ kernel use only ]  *  *	Mark the given range as handled by a subordinate map.  *  *	This range must have been created with vm_map_find,  *	and no other operations may have been performed on this  *	range prior to calling vm_map_submap.  *  *	Only a limited number of operations can be performed  *	within this rage after calling vm_map_submap:  *		vm_fault  *	[Don't try vm_map_copy!]  *  *	To remove a submapping, one must first remove the  *	range from the superior map, and then destroy the  *	submap (if desired).  [Better yet, don't try it.]  */
end_comment

begin_function
name|int
name|vm_map_submap
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_map_t
name|submap
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|int
name|result
init|=
name|KERN_INVALID_ARGUMENT
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|start
operator|==
name|start
operator|)
operator|&&
operator|(
name|entry
operator|->
name|end
operator|==
name|end
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|)
condition|)
block|{
name|entry
operator|->
name|object
operator|.
name|sub_map
operator|=
name|submap
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_IS_SUB_MAP
expr_stmt|;
name|result
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_protect:  *  *	Sets the protection of the specified address  *	region in the target map.  If "set_max" is  *	specified, the maximum protection is to be set;  *	otherwise, only the current protection is affected.  */
end_comment

begin_function
name|int
name|vm_map_protect
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|new_prot
parameter_list|,
name|boolean_t
name|set_max
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Make a first pass to check for protection violations. 	 */
name|current
operator|=
name|entry
expr_stmt|;
while|while
condition|(
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|new_prot
operator|&
name|current
operator|->
name|max_protection
operator|)
operator|!=
name|new_prot
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
block|}
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Go back and fix up protections. [Note that clipping is not 	 * necessary the second time.] 	 */
name|current
operator|=
name|entry
expr_stmt|;
while|while
condition|(
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_prot_t
name|old_prot
decl_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|current
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|old_prot
operator|=
name|current
operator|->
name|protection
expr_stmt|;
if|if
condition|(
name|set_max
condition|)
name|current
operator|->
name|protection
operator|=
operator|(
name|current
operator|->
name|max_protection
operator|=
name|new_prot
operator|)
operator|&
name|old_prot
expr_stmt|;
else|else
name|current
operator|->
name|protection
operator|=
name|new_prot
expr_stmt|;
comment|/* 		 * Update physical map if necessary. Worry about copy-on-write 		 * here -- CHECK THIS XXX 		 */
if|if
condition|(
name|current
operator|->
name|protection
operator|!=
name|old_prot
condition|)
block|{
define|#
directive|define
name|MASK
parameter_list|(
name|entry
parameter_list|)
value|(((entry)->eflags& MAP_ENTRY_COW) ? ~VM_PROT_WRITE : \ 							VM_PROT_ALL)
name|pmap_protect
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|current
operator|->
name|start
argument_list|,
name|current
operator|->
name|end
argument_list|,
name|current
operator|->
name|protection
operator|&
name|MASK
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MASK
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_madvise:  *  * 	This routine traverses a processes map handling the madvise  *	system call.  Advisories are classified as either those effecting  *	the vm_map_entry structure, or those effecting the underlying   *	objects.  */
end_comment

begin_function
name|int
name|vm_map_madvise
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|behav
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|,
name|entry
decl_stmt|;
name|int
name|modify_map
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Some madvise calls directly modify the vm_map_entry, in which case 	 * we need to use an exclusive lock on the map and we need to perform  	 * various clipping operations.  Otherwise we only need a read-lock 	 * on the map. 	 */
switch|switch
condition|(
name|behav
condition|)
block|{
case|case
name|MADV_NORMAL
case|:
case|case
name|MADV_SEQUENTIAL
case|:
case|case
name|MADV_RANDOM
case|:
case|case
name|MADV_NOSYNC
case|:
case|case
name|MADV_AUTOSYNC
case|:
case|case
name|MADV_NOCORE
case|:
case|case
name|MADV_CORE
case|:
name|modify_map
operator|=
literal|1
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_WILLNEED
case|:
case|case
name|MADV_DONTNEED
case|:
case|case
name|MADV_FREE
case|:
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
comment|/* 	 * Locate starting entry and clip if necessary. 	 */
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|modify_map
condition|)
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|modify_map
condition|)
block|{
comment|/* 		 * madvise behaviors that are implemented in the vm_map_entry. 		 * 		 * We clip the vm_map_entry so that behavioral changes are 		 * limited to the specified address range. 		 */
for|for
control|(
name|current
operator|=
name|entry
init|;
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
continue|continue;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|current
argument_list|,
name|end
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|behav
condition|)
block|{
case|case
name|MADV_NORMAL
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_SEQUENTIAL
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_SEQUENTIAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_RANDOM
case|:
name|vm_map_entry_set_behavior
argument_list|(
name|current
argument_list|,
name|MAP_ENTRY_BEHAV_RANDOM
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADV_NOSYNC
case|:
name|current
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NOSYNC
expr_stmt|;
break|break;
case|case
name|MADV_AUTOSYNC
case|:
name|current
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NOSYNC
expr_stmt|;
break|break;
case|case
name|MADV_NOCORE
case|:
name|current
operator|->
name|eflags
operator||=
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
break|break;
case|case
name|MADV_CORE
case|:
name|current
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NOCOREDUMP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 		 * madvise behaviors that are implemented in the underlying 		 * vm_object. 		 * 		 * Since we don't clip the vm_map_entry, we have to clip 		 * the vm_object pindex and count. 		 */
for|for
control|(
name|current
operator|=
name|entry
init|;
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|vm_offset_t
name|useStart
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
continue|continue;
name|pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|current
operator|->
name|offset
argument_list|)
expr_stmt|;
name|count
operator|=
name|atop
argument_list|(
name|current
operator|->
name|end
operator|-
name|current
operator|->
name|start
argument_list|)
expr_stmt|;
name|useStart
operator|=
name|current
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|start
operator|<
name|start
condition|)
block|{
name|pindex
operator|+=
name|atop
argument_list|(
name|start
operator|-
name|current
operator|->
name|start
argument_list|)
expr_stmt|;
name|count
operator|-=
name|atop
argument_list|(
name|start
operator|-
name|current
operator|->
name|start
argument_list|)
expr_stmt|;
name|useStart
operator|=
name|start
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|end
operator|>
name|end
condition|)
name|count
operator|-=
name|atop
argument_list|(
name|current
operator|->
name|end
operator|-
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
continue|continue;
name|vm_object_madvise
argument_list|(
name|current
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|pindex
argument_list|,
name|count
argument_list|,
name|behav
argument_list|)
expr_stmt|;
if|if
condition|(
name|behav
operator|==
name|MADV_WILLNEED
condition|)
block|{
name|pmap_object_init_pt
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|useStart
argument_list|,
name|current
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|pindex
argument_list|,
operator|(
name|count
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|,
name|MAP_PREFAULT_MADVISE
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_inherit:  *  *	Sets the inheritance of the specified address  *	range in the target map.  Inheritance  *	affects how the map will be shared with  *	child maps at the time of vm_map_fork.  */
end_comment

begin_function
name|int
name|vm_map_inherit
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_inherit_t
name|new_inheritance
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
switch|switch
condition|(
name|new_inheritance
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
case|case
name|VM_INHERIT_COPY
case|:
case|case
name|VM_INHERIT_SHARE
case|:
break|break;
default|default:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
block|{
name|entry
operator|=
name|temp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|temp_entry
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|inheritance
operator|=
name|new_inheritance
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the semantics of mlock  */
end_comment

begin_function
name|int
name|vm_map_user_pageable
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|boolean_t
name|new_pageable
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|start_entry
decl_stmt|;
name|vm_offset_t
name|estart
decl_stmt|;
name|vm_offset_t
name|eend
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|start_entry
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
if|if
condition|(
name|new_pageable
condition|)
block|{
name|entry
operator|=
name|start_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 		 * Now decrement the wiring count for each region. If a region 		 * becomes completely unwired, unwire its physical pages and 		 * mappings. 		 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
name|vm_fault_unwire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|entry
operator|=
name|start_entry
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
condition|)
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
block|{
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Here on entry being newly wired */
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|copyflag
init|=
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
decl_stmt|;
if|if
condition|(
name|copyflag
operator|&&
operator|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
operator|(
name|vm_offset_t
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
name|entry
operator|->
name|eflags
operator||=
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|estart
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|eend
operator|=
name|entry
operator|->
name|end
expr_stmt|;
comment|/* First we need to allow map modifications */
name|vm_map_set_recursive
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
name|rv
operator|=
name|vm_fault_user_wire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|vm_map_clear_recursive
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* 				 * At this point, the map is unlocked, and 				 * entry might no longer be valid.  Use copy 				 * of entry start value obtained while entry 				 * was valid. 				 */
operator|(
name|void
operator|)
name|vm_map_user_pageable
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|estart
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|vm_map_clear_recursive
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|estart
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/*  					 * vm_fault_user_wire succeded, thus 					 * the area between start and eend 					 * is wired and has to be unwired 					 * here as part of the cleanup. 					 */
operator|(
name|void
operator|)
name|vm_map_user_pageable
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|eend
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_pageable:  *  *	Sets the pageability of the specified address  *	range in the target map.  Regions specified  *	as not pageable require locked-down physical  *	memory and physical page maps.  *  *	The map must not be locked, but a reference  *	must remain to the map throughout the call.  */
end_comment

begin_function
name|int
name|vm_map_pageable
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|boolean_t
name|new_pageable
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|start_entry
decl_stmt|;
name|vm_offset_t
name|failed
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 	 * Only one pageability change may take place at one time, since 	 * vm_fault assumes it will be called only once for each 	 * wiring/unwiring.  Therefore, we have to make sure we're actually 	 * changing the pageability for the entire region.  We do so before 	 * making any changes. 	 */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|start_entry
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
name|entry
operator|=
name|start_entry
expr_stmt|;
comment|/* 	 * Actions are rather different for wiring and unwiring, so we have 	 * two separate cases. 	 */
if|if
condition|(
name|new_pageable
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 		 * Unwiring.  First ensure that the range to be unwired is 		 * really wired down and that there are no holes. 		 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
operator|||
operator|(
name|entry
operator|->
name|end
operator|<
name|end
operator|&&
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|entry
operator|->
name|next
operator|->
name|start
operator|>
name|entry
operator|->
name|end
operator|)
operator|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 		 * Now decrement the wiring count for each region. If a region 		 * becomes completely unwired, unwire its physical pages and 		 * mappings. 		 */
name|entry
operator|=
name|start_entry
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
name|vm_fault_unwire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Wiring.  We must do this in two passes: 		 * 		 * 1.  Holding the write lock, we create any shadow or zero-fill 		 * objects that need to be created. Then we clip each map 		 * entry to the region to be wired and increment its wiring 		 * count.  We create objects before clipping the map entries 		 * to avoid object proliferation. 		 * 		 * 2.  We downgrade to a read lock, and call vm_fault_wire to 		 * fault in the pages for any newly wired area (wired_count is 		 * 1). 		 * 		 * Downgrading to a read lock for vm_fault_wire avoids a possible 		 * deadlock with another process that may have faulted on one 		 * of the pages to be wired (it would mark the page busy, 		 * blocking us, then in turn block on the map lock that we 		 * hold).  Because of problems in the recursive lock package, 		 * we cannot upgrade to a write lock in vm_map_lookup.  Thus, 		 * any actions that require the write lock must be done 		 * beforehand.  Because we keep the read lock on the map, the 		 * copy-on-write status of the entries we modify here cannot 		 * change. 		 */
comment|/* 		 * Pass 1. 		 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Perform actions of vm_map_lookup that need 				 * the write lock on the map: create a shadow 				 * object for a copy-on-write region, or an 				 * object for a zero-fill region. 				 * 				 * We don't have to do this for entries that 				 * point to sub maps, because we won't 				 * hold the lock on the sub map. 				 */
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|copyflag
init|=
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
decl_stmt|;
if|if
condition|(
name|copyflag
operator|&&
operator|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
operator|(
name|vm_offset_t
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
comment|/* 			 * Check for holes 			 */
if|if
condition|(
name|entry
operator|->
name|end
operator|<
name|end
operator|&&
operator|(
name|entry
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|entry
operator|->
name|next
operator|->
name|start
operator|>
name|entry
operator|->
name|end
operator|)
condition|)
block|{
comment|/* 				 * Found one.  Object creation actions do not 				 * need to be undone, but the wired counts 				 * need to be restored. 				 */
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|end
operator|>
name|start
condition|)
block|{
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 		 * Pass 2. 		 */
comment|/* 		 * HACK HACK HACK HACK 		 * 		 * If we are wiring in the kernel map or a submap of it, 		 * unlock the map to avoid deadlocks.  We trust that the 		 * kernel is well-behaved, and therefore will not do 		 * anything destructive to this region of the map while 		 * we have it unlocked.  We cannot trust user processes 		 * to do the same. 		 * 		 * HACK HACK HACK HACK 		 */
if|if
condition|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|==
name|kernel_pmap
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* trust me ... */
block|}
else|else
block|{
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|start_entry
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|)
block|{
comment|/* 			 * If vm_fault_wire fails for any page we need to undo 			 * what has been done.  We decrement the wiring count 			 * for those pages which have not yet been wired (now) 			 * and unwire those that have (later). 			 * 			 * XXX this violates the locking protocol on the map, 			 * needs to be fixed. 			 */
if|if
condition|(
name|rv
condition|)
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|1
condition|)
block|{
name|rv
operator|=
name|vm_fault_wire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|failed
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|==
name|kernel_pmap
condition|)
block|{
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|failed
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* 		 * An exclusive lock on the map is needed in order to call 		 * vm_map_simplify_entry().  If the current lock on the map 		 * is only a shared lock, an upgrade is needed. 		 */
if|if
condition|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|!=
name|kernel_pmap
operator|&&
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|start_entry
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|KERN_SUCCESS
return|;
block|}
block|}
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|start_entry
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vm_map_clean  *  * Push any dirty cached pages in the address range to their pager.  * If syncio is TRUE, dirty pages are written synchronously.  * If invalidate is TRUE, any cached pages are freed as well.  *  * Returns an error if any part of the specified range is not mapped.  */
end_comment

begin_function
name|int
name|vm_map_clean
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|boolean_t
name|syncio
parameter_list|,
name|boolean_t
name|invalidate
parameter_list|)
block|{
name|vm_map_entry_t
name|current
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_ooffset_t
name|offset
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
comment|/* 	 * Make a first pass to check for holes. 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
if|if
condition|(
name|end
operator|>
name|current
operator|->
name|end
operator|&&
operator|(
name|current
operator|->
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|current
operator|->
name|end
operator|!=
name|current
operator|->
name|next
operator|->
name|start
operator|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|invalidate
condition|)
name|pmap_remove
argument_list|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 	 * Make a second pass, cleaning/uncaching pages from the indicated 	 * objects as we go. 	 */
for|for
control|(
name|current
operator|=
name|entry
init|;
name|current
operator|->
name|start
operator|<
name|end
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|offset
operator|=
name|current
operator|->
name|offset
operator|+
operator|(
name|start
operator|-
name|current
operator|->
name|start
operator|)
expr_stmt|;
name|size
operator|=
operator|(
name|end
operator|<=
name|current
operator|->
name|end
condition|?
name|end
else|:
name|current
operator|->
name|end
operator|)
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_t
name|smap
decl_stmt|;
name|vm_map_entry_t
name|tentry
decl_stmt|;
name|vm_size_t
name|tsize
decl_stmt|;
name|smap
operator|=
name|current
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|smap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|smap
argument_list|,
name|offset
argument_list|,
operator|&
name|tentry
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|tentry
operator|->
name|end
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|tsize
operator|<
name|size
condition|)
name|size
operator|=
name|tsize
expr_stmt|;
name|object
operator|=
name|tentry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|offset
operator|=
name|tentry
operator|->
name|offset
operator|+
operator|(
name|offset
operator|-
name|tentry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|smap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|current
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
comment|/* 		 * Note that there is absolutely no sense in writing out 		 * anonymous objects, so we track down the vnode object 		 * to write out. 		 * We invalidate (remove) all pages from the address space 		 * anyway, for semantic correctness. 		 * 		 * note: certain anonymous maps, such as MAP_NOSYNC maps, 		 * may start out with a NULL object. 		 */
while|while
condition|(
name|object
operator|&&
name|object
operator|->
name|backing_object
condition|)
block|{
name|object
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
name|offset
operator|+=
name|object
operator|->
name|backing_object_offset
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|size
operator|<
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|size
argument_list|)
condition|)
name|size
operator|=
name|IDX_TO_OFF
argument_list|(
name|object
operator|->
name|size
argument_list|)
operator|-
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|)
operator|&&
operator|(
name|current
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
comment|/* 			 * Flush pages if writing is allowed, invalidate them 			 * if invalidation requested.  Pages undergoing I/O 			 * will be ignored by vm_object_page_remove(). 			 * 			 * We cannot lock the vnode and then wait for paging 			 * to complete without deadlocking against vm_fault. 			 * Instead we simply call vm_object_page_remove() and 			 * allow it to block internally on a page-by-page  			 * basis when it encounters pages undergoing async  			 * I/O. 			 */
name|int
name|flags
decl_stmt|;
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|object
operator|->
name|handle
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|syncio
operator|||
name|invalidate
operator|)
condition|?
name|OBJPC_SYNC
else|:
literal|0
expr_stmt|;
name|flags
operator||=
name|invalidate
condition|?
name|OBJPC_INVAL
else|:
literal|0
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|size
operator|+
name|PAGE_MASK
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalidate
condition|)
block|{
comment|/*vm_object_pip_wait(object, "objmcl");*/
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|size
operator|+
name|PAGE_MASK
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|object
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|size
expr_stmt|;
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_unwire:	[ internal use only ]  *  *	Make the region specified by this entry pageable.  *  *	The map in question should be locked.  *	[This is the reason for this routine's existence.]  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_unwire
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_fault_unwire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_delete:	[ internal use only ]  *  *	Deallocate the given entry from the target map.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_entry_delete
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|map
operator|->
name|size
operator|-=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_delete:	[ internal use only ]  *  *	Deallocates the given address range from the target  *	map.  */
end_comment

begin_function
name|int
name|vm_map_delete
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|first_entry
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Find the start of the region, and clip it 	 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
condition|)
name|entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|entry
operator|=
name|first_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 		 * Fix the lookup hint now, rather than each time though the 		 * loop. 		 */
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save the free space hint 	 */
if|if
condition|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|map
operator|->
name|first_free
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|->
name|first_free
operator|->
name|start
operator|>=
name|start
condition|)
block|{
name|map
operator|->
name|first_free
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
block|}
comment|/* 	 * Step through all entries in this region 	 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|;
name|vm_offset_t
name|s
decl_stmt|,
name|e
decl_stmt|;
name|vm_pindex_t
name|offidxstart
decl_stmt|,
name|offidxend
decl_stmt|,
name|count
decl_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|s
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|offidxstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
name|count
operator|=
name|OFF_TO_IDX
argument_list|(
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
comment|/* 		 * Unwire before removing addresses from the pmap; otherwise, 		 * unwiring will put the entries back in the pmap. 		 */
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
block|{
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|offidxend
operator|=
name|offidxstart
operator|+
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|==
name|kernel_object
operator|)
operator|||
operator|(
name|object
operator|==
name|kmem_object
operator|)
condition|)
block|{
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|offidxstart
argument_list|,
name|offidxend
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
operator|&&
name|object
operator|->
name|ref_count
operator|!=
literal|1
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
operator|(
name|OBJ_NOSPLIT
operator||
name|OBJ_ONEMAPPING
operator|)
operator|)
operator|==
name|OBJ_ONEMAPPING
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|offidxstart
argument_list|,
name|offidxend
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|swap_pager_freespace
argument_list|(
name|object
argument_list|,
name|offidxstart
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offidxend
operator|>=
name|object
operator|->
name|size
operator|&&
name|offidxstart
operator|<
name|object
operator|->
name|size
condition|)
block|{
name|object
operator|->
name|size
operator|=
name|offidxstart
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Delete the entry (which may delete the object) only after 		 * removing all pmap entries pointing to its pages. 		 * (Otherwise, its page frames may be reallocated, and any 		 * modify bits will be set in the wrong object!) 		 */
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_remove:  *  *	Remove the given address range from the target map.  *	This is the exported form of vm_map_delete.  */
end_comment

begin_function
name|int
name|vm_map_remove
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|kmem_map
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_check_protection:  *  *	Assert that the target map allows the specified  *	privilege on the entire address region given.  *	The entire region must be allocated.  */
end_comment

begin_function
name|boolean_t
name|vm_map_check_protection
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|protection
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|entry
operator|=
name|tmp_entry
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * No holes allowed! 		 */
if|if
condition|(
name|start
operator|<
name|entry
operator|->
name|start
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Check protection associated with entry. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|protection
operator|)
operator|!=
name|protection
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* go to next entry */
name|start
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split the pages in a map entry into a new object.  This affords  * easier removal of unused pages, and keeps object inheritance from  * being a negative impact on memory usage.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_split
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|orig_object
decl_stmt|,
name|new_object
decl_stmt|,
name|source
decl_stmt|;
name|vm_offset_t
name|s
decl_stmt|,
name|e
decl_stmt|;
name|vm_pindex_t
name|offidxstart
decl_stmt|,
name|offidxend
decl_stmt|,
name|idx
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_ooffset_t
name|offset
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|orig_object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|orig_object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|orig_object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
if|if
condition|(
name|orig_object
operator|->
name|ref_count
operator|<=
literal|1
condition|)
return|return;
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
name|s
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|offidxstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offidxend
operator|=
name|offidxstart
operator|+
name|OFF_TO_IDX
argument_list|(
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
name|size
operator|=
name|offidxend
operator|-
name|offidxstart
expr_stmt|;
name|new_object
operator|=
name|vm_pager_allocate
argument_list|(
name|orig_object
operator|->
name|type
argument_list|,
name|NULL
argument_list|,
name|IDX_TO_OFF
argument_list|(
name|size
argument_list|)
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0LL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_object
operator|==
name|NULL
condition|)
return|return;
name|source
operator|=
name|orig_object
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
name|vm_object_reference
argument_list|(
name|source
argument_list|)
expr_stmt|;
comment|/* Referenced by new_object */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|source
operator|->
name|shadow_head
argument_list|,
name|new_object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|vm_object_clear_flag
argument_list|(
name|source
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
name|new_object
operator|->
name|backing_object_offset
operator|=
name|orig_object
operator|->
name|backing_object_offset
operator|+
name|IDX_TO_OFF
argument_list|(
name|offidxstart
argument_list|)
expr_stmt|;
name|new_object
operator|->
name|backing_object
operator|=
name|source
expr_stmt|;
name|source
operator|->
name|shadow_count
operator|++
expr_stmt|;
name|source
operator|->
name|generation
operator|++
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|size
condition|;
name|idx
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|retry
label|:
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|orig_object
argument_list|,
name|offidxstart
operator|+
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * We must wait for pending I/O to complete before we can 		 * rename the page. 		 * 		 * We do not have to VM_PROT_NONE the page as mappings should 		 * not be changed by this operation. 		 */
if|if
condition|(
name|vm_page_sleep_busy
argument_list|(
name|m
argument_list|,
name|TRUE
argument_list|,
literal|"spltwt"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_rename
argument_list|(
name|m
argument_list|,
name|new_object
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* page automatically made dirty by rename and cache handled */
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|orig_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|vm_object_pip_add
argument_list|(
name|orig_object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * copy orig_object pages into new_object 		 * and destroy unneeded pages in 		 * shadow object. 		 */
name|swap_pager_copy
argument_list|(
name|orig_object
argument_list|,
name|new_object
argument_list|,
name|offidxstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|size
condition|;
name|idx
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|new_object
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|new_object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0LL
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_copy_entry:  *  *	Copies the contents of the source entry to the destination  *	entry.  The entries *must* be aligned properly.  */
end_comment

begin_function
specifier|static
name|void
name|vm_map_copy_entry
parameter_list|(
name|vm_map_t
name|src_map
parameter_list|,
name|vm_map_t
name|dst_map
parameter_list|,
name|vm_map_entry_t
name|src_entry
parameter_list|,
name|vm_map_entry_t
name|dst_entry
parameter_list|)
block|{
name|vm_object_t
name|src_object
decl_stmt|;
if|if
condition|(
operator|(
name|dst_entry
operator|->
name|eflags
operator||
name|src_entry
operator|->
name|eflags
operator|)
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
return|return;
if|if
condition|(
name|src_entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the source entry is marked needs_copy, it is already 		 * write-protected. 		 */
if|if
condition|(
operator|(
name|src_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_protect
argument_list|(
name|src_map
operator|->
name|pmap
argument_list|,
name|src_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|end
argument_list|,
name|src_entry
operator|->
name|protection
operator|&
operator|~
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Make a copy of the object. 		 */
if|if
condition|(
operator|(
name|src_object
operator|=
name|src_entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|src_object
operator|->
name|handle
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|src_object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|src_object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|vm_object_collapse
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src_object
operator|->
name|flags
operator|&
operator|(
name|OBJ_NOSPLIT
operator||
name|OBJ_ONEMAPPING
operator|)
operator|)
operator|==
name|OBJ_ONEMAPPING
condition|)
block|{
name|vm_map_split
argument_list|(
name|src_entry
argument_list|)
expr_stmt|;
name|src_object
operator|=
name|src_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
block|}
name|vm_object_reference
argument_list|(
name|src_object
argument_list|)
expr_stmt|;
name|vm_object_clear_flag
argument_list|(
name|src_object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|src_object
expr_stmt|;
name|src_entry
operator|->
name|eflags
operator||=
operator|(
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
operator|)
expr_stmt|;
name|dst_entry
operator|->
name|eflags
operator||=
operator|(
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
operator|)
expr_stmt|;
name|dst_entry
operator|->
name|offset
operator|=
name|src_entry
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
name|dst_entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|pmap_copy
argument_list|(
name|dst_map
operator|->
name|pmap
argument_list|,
name|src_map
operator|->
name|pmap
argument_list|,
name|dst_entry
operator|->
name|start
argument_list|,
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Of course, wired down pages can't be set copy-on-write. 		 * Cause wired pages to be copied into the new map by 		 * simulating faults (the new pages are pageable) 		 */
name|vm_fault_copy_entry
argument_list|(
name|dst_map
argument_list|,
name|src_map
argument_list|,
name|dst_entry
argument_list|,
name|src_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vmspace_fork:  * Create a new process vmspace structure and vm_map  * based on those of an existing process.  The new map  * is based on the old map, according to the inheritance  * values on the regions in that map.  *  * The source map must not be locked.  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_fork
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm1
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm2
decl_stmt|;
name|vm_map_t
name|old_map
init|=
operator|&
name|vm1
operator|->
name|vm_map
decl_stmt|;
name|vm_map_t
name|new_map
decl_stmt|;
name|vm_map_entry_t
name|old_entry
decl_stmt|;
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_lock
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
name|old_map
operator|->
name|infork
operator|=
literal|1
expr_stmt|;
name|vm2
operator|=
name|vmspace_alloc
argument_list|(
name|old_map
operator|->
name|min_offset
argument_list|,
name|old_map
operator|->
name|max_offset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|vm1
operator|->
name|vm_startcopy
argument_list|,
operator|&
name|vm2
operator|->
name|vm_startcopy
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vm1
operator|->
name|vm_endcopy
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|vm1
operator|->
name|vm_startcopy
argument_list|)
expr_stmt|;
name|new_map
operator|=
operator|&
name|vm2
operator|->
name|vm_map
expr_stmt|;
comment|/* XXX */
name|new_map
operator|->
name|timestamp
operator|=
literal|1
expr_stmt|;
name|old_entry
operator|=
name|old_map
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|old_entry
operator|!=
operator|&
name|old_map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
name|panic
argument_list|(
literal|"vm_map_fork: encountered a submap"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|old_entry
operator|->
name|inheritance
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
break|break;
case|case
name|VM_INHERIT_SHARE
case|:
comment|/* 			 * Clone the entry, creating the shared object if necessary. 			 */
name|object
operator|=
name|old_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|old_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|old_entry
operator|->
name|offset
operator|=
operator|(
name|vm_offset_t
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 			 * Add the reference before calling vm_object_shadow 			 * to insure that a shadow object is created. 			 */
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
condition|)
block|{
name|vm_object_shadow
argument_list|(
operator|&
name|old_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|old_entry
operator|->
name|offset
argument_list|,
name|atop
argument_list|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|old_entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
comment|/* Transfer the second reference too. */
name|vm_object_reference
argument_list|(
name|old_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|old_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
block|}
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
comment|/* 			 * Clone the entry, referencing the shared object. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Insert the entry into the new map -- we know we're 			 * inserting at the end of the new map. 			 */
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
comment|/* 			 * Update the physical map 			 */
name|pmap_copy
argument_list|(
name|new_map
operator|->
name|pmap
argument_list|,
name|old_map
operator|->
name|pmap
argument_list|,
name|new_entry
operator|->
name|start
argument_list|,
operator|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
operator|)
argument_list|,
name|old_entry
operator|->
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INHERIT_COPY
case|:
comment|/* 			 * Clone the entry and link into the map. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
name|new_entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_USER_WIRED
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|vm_map_copy_entry
argument_list|(
name|old_map
argument_list|,
name|new_map
argument_list|,
name|old_entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
break|break;
block|}
name|old_entry
operator|=
name|old_entry
operator|->
name|next
expr_stmt|;
block|}
name|new_map
operator|->
name|size
operator|=
name|old_map
operator|->
name|size
expr_stmt|;
name|old_map
operator|->
name|infork
operator|=
literal|0
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_map_stack
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
name|addrbos
parameter_list|,
name|vm_size_t
name|max_ssize
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|max
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|vm_map_entry_t
name|prev_entry
decl_stmt|;
name|vm_map_entry_t
name|new_stack_entry
decl_stmt|;
name|vm_size_t
name|init_ssize
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|VM_MIN_ADDRESS
operator|>
literal|0
operator|&&
name|addrbos
operator|<
name|VM_MIN_ADDRESS
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
if|if
condition|(
name|max_ssize
operator|<
name|sgrowsiz
condition|)
name|init_ssize
operator|=
name|max_ssize
expr_stmt|;
else|else
name|init_ssize
operator|=
name|sgrowsiz
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* If addr is already mapped, no go */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addrbos
argument_list|,
operator|&
name|prev_entry
argument_list|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
comment|/* If we can't accomodate max_ssize in the current mapping, 	 * no go.  However, we need to be aware that subsequent user 	 * mappings might map into the space we have reserved for 	 * stack, and currently this space is not protected.   	 *  	 * Hopefully we will at least detect this condition  	 * when we try to grow the stack. 	 */
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|next
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|next
operator|->
name|start
operator|<
name|addrbos
operator|+
name|max_ssize
operator|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
comment|/* We initially map a stack of only init_ssize.  We will 	 * grow as needed later.  Since this is to be a grow  	 * down stack, we map at the top of the range. 	 * 	 * Note: we would normally expect prot and max to be 	 * VM_PROT_ALL, and cow to be 0.  Possibly we should 	 * eliminate these as input parameters, and just 	 * pass these values here in the insert call. 	 */
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|addrbos
operator|+
name|max_ssize
operator|-
name|init_ssize
argument_list|,
name|addrbos
operator|+
name|max_ssize
argument_list|,
name|prot
argument_list|,
name|max
argument_list|,
name|cow
argument_list|)
expr_stmt|;
comment|/* Now set the avail_ssize amount */
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|prev_entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|,
name|addrbos
operator|+
name|max_ssize
operator|-
name|init_ssize
argument_list|)
expr_stmt|;
name|new_stack_entry
operator|=
name|prev_entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new_stack_entry
operator|->
name|end
operator|!=
name|addrbos
operator|+
name|max_ssize
operator|||
name|new_stack_entry
operator|->
name|start
operator|!=
name|addrbos
operator|+
name|max_ssize
operator|-
name|init_ssize
condition|)
name|panic
argument_list|(
literal|"Bad entry start/end for new stack entry"
argument_list|)
expr_stmt|;
else|else
name|new_stack_entry
operator|->
name|avail_ssize
operator|=
name|max_ssize
operator|-
name|init_ssize
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attempts to grow a vm stack entry.  Returns KERN_SUCCESS if the  * desired address is already mapped, or if we successfully grow  * the stack.  Also returns KERN_SUCCESS if addr is outside the  * stack range (this is strange, but preserves compatibility with  * the grow function in vm_machdep.c).  */
end_comment

begin_function
name|int
name|vm_map_growstack
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_map_entry_t
name|prev_entry
decl_stmt|;
name|vm_map_entry_t
name|stack_entry
decl_stmt|;
name|vm_map_entry_t
name|new_stack_entry
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|&
name|vm
operator|->
name|vm_map
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|grow_amount
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|is_procstack
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|Retry
label|:
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* If addr is already in the entry range, no need to grow.*/
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
operator|&
name|prev_entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stack_entry
operator|=
name|prev_entry
operator|->
name|next
operator|)
operator|==
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|prev_entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
name|end
operator|=
name|stack_entry
operator|->
name|start
operator|-
name|stack_entry
operator|->
name|avail_ssize
expr_stmt|;
else|else
name|end
operator|=
name|prev_entry
operator|->
name|end
expr_stmt|;
comment|/* This next test mimics the old grow function in vm_machdep.c. 	 * It really doesn't quite make sense, but we do it anyway 	 * for compatibility. 	 * 	 * If not growable stack, return success.  This signals the 	 * caller to proceed as he would normally with normal vm. 	 */
if|if
condition|(
name|stack_entry
operator|->
name|avail_ssize
operator|<
literal|1
operator|||
name|addr
operator|>=
name|stack_entry
operator|->
name|start
operator|||
name|addr
operator|<
name|stack_entry
operator|->
name|start
operator|-
name|stack_entry
operator|->
name|avail_ssize
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
comment|/* Find the minimum grow amount */
name|grow_amount
operator|=
name|roundup
argument_list|(
name|stack_entry
operator|->
name|start
operator|-
name|addr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|grow_amount
operator|>
name|stack_entry
operator|->
name|avail_ssize
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
comment|/* If there is no longer enough space between the entries 	 * nogo, and adjust the available space.  Note: this  	 * should only happen if the user has mapped into the 	 * stack area after the stack was created, and is 	 * probably an error. 	 * 	 * This also effectively destroys any guard page the user 	 * might have intended by limiting the stack size. 	 */
if|if
condition|(
name|grow_amount
operator|>
name|stack_entry
operator|->
name|start
operator|-
name|end
condition|)
block|{
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|Retry
goto|;
name|stack_entry
operator|->
name|avail_ssize
operator|=
name|stack_entry
operator|->
name|start
operator|-
name|end
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
name|is_procstack
operator|=
name|addr
operator|>=
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_maxsaddr
expr_stmt|;
comment|/* If this is the main process stack, see if we're over the  	 * stack limit. 	 */
if|if
condition|(
name|is_procstack
operator|&&
operator|(
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
comment|/* Round up the grow amount modulo SGROWSIZ */
name|grow_amount
operator|=
name|roundup
argument_list|(
name|grow_amount
argument_list|,
name|sgrowsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|grow_amount
operator|>
name|stack_entry
operator|->
name|avail_ssize
condition|)
block|{
name|grow_amount
operator|=
name|stack_entry
operator|->
name|avail_ssize
expr_stmt|;
block|}
if|if
condition|(
name|is_procstack
operator|&&
operator|(
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
operator|+
name|grow_amount
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|)
condition|)
block|{
name|grow_amount
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|-
name|ctob
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|Retry
goto|;
comment|/* Get the preliminary new entry start value */
name|addr
operator|=
name|stack_entry
operator|->
name|start
operator|-
name|grow_amount
expr_stmt|;
comment|/* If this puts us into the previous entry, cut back our growth 	 * to the available space.  Also, see the note above. 	 */
if|if
condition|(
name|addr
operator|<
name|end
condition|)
block|{
name|stack_entry
operator|->
name|avail_ssize
operator|=
name|stack_entry
operator|->
name|start
operator|-
name|end
expr_stmt|;
name|addr
operator|=
name|end
expr_stmt|;
block|}
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|stack_entry
operator|->
name|start
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Adjust the available stack space by the amount we grew. */
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|prev_entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new_stack_entry
operator|=
name|prev_entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new_stack_entry
operator|->
name|end
operator|!=
name|stack_entry
operator|->
name|start
operator|||
name|new_stack_entry
operator|->
name|start
operator|!=
name|addr
condition|)
name|panic
argument_list|(
literal|"Bad stack grow start/end in new stack entry"
argument_list|)
expr_stmt|;
else|else
block|{
name|new_stack_entry
operator|->
name|avail_ssize
operator|=
name|stack_entry
operator|->
name|avail_ssize
operator|-
operator|(
name|new_stack_entry
operator|->
name|end
operator|-
name|new_stack_entry
operator|->
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|is_procstack
condition|)
name|vm
operator|->
name|vm_ssize
operator|+=
name|btoc
argument_list|(
name|new_stack_entry
operator|->
name|end
operator|-
name|new_stack_entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unshare the specified VM space for exec.  If other processes are  * mapped to it, then create a new one.  The new vmspace is null.  */
end_comment

begin_function
name|void
name|vmspace_exec
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|oldvmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|newvmspace
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|newvmspace
operator|=
name|vmspace_alloc
argument_list|(
name|map
operator|->
name|min_offset
argument_list|,
name|map
operator|->
name|max_offset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|oldvmspace
operator|->
name|vm_startcopy
argument_list|,
operator|&
name|newvmspace
operator|->
name|vm_startcopy
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|newvmspace
operator|+
literal|1
argument_list|)
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|newvmspace
operator|->
name|vm_startcopy
argument_list|)
expr_stmt|;
comment|/* 	 * This code is written like this for prototype purposes.  The 	 * goal is to avoid running down the vmspace here, but let the 	 * other process's that are still using the vmspace to finally 	 * run it down.  Even though there is little or no chance of blocking 	 * here, it is a good idea to keep this form for future mods. 	 */
name|p
operator|->
name|p_vmspace
operator|=
name|newvmspace
expr_stmt|;
name|pmap_pinit2
argument_list|(
name|vmspace_pmap
argument_list|(
name|newvmspace
argument_list|)
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|oldvmspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curthread
operator|->
name|td_proc
condition|)
comment|/* XXXKSE ? */
name|pmap_activate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unshare the specified VM space for forcing COW.  This  * is called by rfork, for the (RFMEM|RFPROC) == 0 case.  */
end_comment

begin_function
name|void
name|vmspace_unshare
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|oldvmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|newvmspace
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|oldvmspace
operator|->
name|vm_refcnt
operator|==
literal|1
condition|)
return|return;
name|newvmspace
operator|=
name|vmspace_fork
argument_list|(
name|oldvmspace
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|=
name|newvmspace
expr_stmt|;
name|pmap_pinit2
argument_list|(
name|vmspace_pmap
argument_list|(
name|newvmspace
argument_list|)
argument_list|)
expr_stmt|;
name|vmspace_free
argument_list|(
name|oldvmspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curthread
operator|->
name|td_proc
condition|)
comment|/* XXXKSE ? */
name|pmap_activate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup:  *  *	Finds the VM object, offset, and  *	protection for a given virtual address in the  *	specified map, assuming a page fault of the  *	type specified.  *  *	Leaves the map in question locked for read; return  *	values are guaranteed until a vm_map_lookup_done  *	call is performed.  Note that the map argument  *	is in/out; the returned map must be used in  *	the call to vm_map_lookup_done.  *  *	A handle (out_entry) is returned for use in  *	vm_map_lookup_done, to make that fast.  *  *	If a lookup is requested with "write protection"  *	specified, the map may be changed to perform virtual  *	copying operations, although the data referenced will  *	remain the same.  */
end_comment

begin_function
name|int
name|vm_map_lookup
parameter_list|(
name|vm_map_t
modifier|*
name|var_map
parameter_list|,
comment|/* IN/OUT */
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_prot_t
name|fault_typea
parameter_list|,
name|vm_map_entry_t
modifier|*
name|out_entry
parameter_list|,
comment|/* OUT */
name|vm_object_t
modifier|*
name|object
parameter_list|,
comment|/* OUT */
name|vm_pindex_t
modifier|*
name|pindex
parameter_list|,
comment|/* OUT */
name|vm_prot_t
modifier|*
name|out_prot
parameter_list|,
comment|/* OUT */
name|boolean_t
modifier|*
name|wired
parameter_list|)
comment|/* OUT */
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|*
name|var_map
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_prot_t
name|fault_type
init|=
name|fault_typea
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|RetryLookup
label|:
empty_stmt|;
comment|/* 	 * Lookup the faulting address. 	 */
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
define|#
directive|define
name|RETURN
parameter_list|(
name|why
parameter_list|)
define|\
value|{ \ 		vm_map_unlock_read(map); \ 		return (why); \ 		}
comment|/* 	 * If the map has an interesting hint, try it before calling full 	 * blown lookup routine. 	 */
name|entry
operator|=
name|map
operator|->
name|hint
expr_stmt|;
operator|*
name|out_entry
operator|=
name|entry
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|vaddr
operator|<
name|entry
operator|->
name|start
operator|)
operator|||
operator|(
name|vaddr
operator|>=
name|entry
operator|->
name|end
operator|)
condition|)
block|{
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
comment|/* 		 * Entry was either not a valid hint, or the vaddr was not 		 * contained in the entry, so do a full lookup. 		 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|vaddr
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
name|RETURN
argument_list|(
name|KERN_INVALID_ADDRESS
argument_list|)
expr_stmt|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
operator|*
name|out_entry
operator|=
name|entry
expr_stmt|;
block|}
comment|/* 	 * Handle submaps. 	 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_t
name|old_map
init|=
name|map
decl_stmt|;
operator|*
name|var_map
operator|=
name|map
operator|=
name|entry
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
goto|goto
name|RetryLookup
goto|;
block|}
comment|/* 	 * Check whether this task is allowed to have this page. 	 * Note the special case for MAP_ENTRY_COW 	 * pages with an override.  This is to implement a forced 	 * COW for debuggers. 	 */
if|if
condition|(
name|fault_type
operator|&
name|VM_PROT_OVERRIDE_WRITE
condition|)
name|prot
operator|=
name|entry
operator|->
name|max_protection
expr_stmt|;
else|else
name|prot
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
name|fault_type
operator|&=
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fault_type
operator|&
name|prot
operator|)
operator|!=
name|fault_type
condition|)
block|{
name|RETURN
argument_list|(
name|KERN_PROTECTION_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_USER_WIRED
operator|)
operator|&&
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
operator|)
operator|&&
operator|(
name|fault_type
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|(
name|fault_typea
operator|&
name|VM_PROT_OVERRIDE_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|RETURN
argument_list|(
name|KERN_PROTECTION_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this page is not pageable, we have to get it for all possible 	 * accesses. 	 */
operator|*
name|wired
operator|=
operator|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|wired
condition|)
name|prot
operator|=
name|fault_type
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
comment|/* 	 * If the entry was copy-on-write, we either ... 	 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
condition|)
block|{
comment|/* 		 * If we want to write the page, we may as well handle that 		 * now since we've got the map locked. 		 * 		 * If we don't need to write the page, we just demote the 		 * permissions allowed. 		 */
if|if
condition|(
name|fault_type
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* 			 * Make a new object, and place it in the object 			 * chain.  Note that no new references have appeared 			 * -- one just moved from the map to the new 			 * object. 			 */
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|RetryLookup
goto|;
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|eflags
operator|&=
operator|~
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're attempting to read a copy-on-write page -- 			 * don't allow writes. 			 */
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
block|}
block|}
comment|/* 	 * Create an object if necessary. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|&&
operator|!
name|map
operator|->
name|system_map
condition|)
block|{
if|if
condition|(
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
condition|)
goto|goto
name|RetryLookup
goto|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the object/offset from this entry.  If the entry was 	 * copy-on-write or empty, it has been fixed up. 	 */
operator|*
name|pindex
operator|=
name|OFF_TO_IDX
argument_list|(
operator|(
name|vaddr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
comment|/* 	 * Return whether this is the only map sharing this data. 	 */
operator|*
name|out_prot
operator|=
name|prot
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
undef|#
directive|undef
name|RETURN
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup_done:  *  *	Releases locks acquired by a vm_map_lookup  *	(according to the handle returned by that lookup).  */
end_comment

begin_function
name|void
name|vm_map_lookup_done
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
comment|/* 	 * Unlock the main-level map 	 */
name|GIANT_REQUIRED
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement uiomove with VM operations.  This handles (and collateral changes)  * support every combination of source object modification, and COW type  * operations.  */
end_comment

begin_function
name|int
name|vm_uiomove
parameter_list|(
name|vm_map_t
name|mapa
parameter_list|,
name|vm_object_t
name|srcobject
parameter_list|,
name|off_t
name|cp
parameter_list|,
name|int
name|cnta
parameter_list|,
name|vm_offset_t
name|uaddra
parameter_list|,
name|int
modifier|*
name|npages
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|vm_object_t
name|first_object
decl_stmt|,
name|oldobject
decl_stmt|,
name|object
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|int
name|tcnt
decl_stmt|,
name|rv
decl_stmt|;
name|vm_offset_t
name|uaddr
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|tend
decl_stmt|;
name|vm_pindex_t
name|first_pindex
decl_stmt|,
name|osize
decl_stmt|,
name|oindex
decl_stmt|;
name|off_t
name|ooffset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|npages
condition|)
operator|*
name|npages
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|cnta
expr_stmt|;
name|uaddr
operator|=
name|uaddra
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|map
operator|=
name|mapa
expr_stmt|;
if|if
condition|(
operator|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
name|uaddr
argument_list|,
name|VM_PROT_READ
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|first_object
argument_list|,
operator|&
name|first_pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
name|tcnt
operator|=
name|cnt
expr_stmt|;
name|tend
operator|=
name|uaddr
operator|+
name|tcnt
expr_stmt|;
if|if
condition|(
name|tend
operator|>
name|entry
operator|->
name|end
condition|)
block|{
name|tcnt
operator|=
name|entry
operator|->
name|end
operator|-
name|uaddr
expr_stmt|;
name|tend
operator|=
name|entry
operator|->
name|end
expr_stmt|;
block|}
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|tend
argument_list|)
expr_stmt|;
name|start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|osize
operator|=
name|atop
argument_list|(
name|tcnt
argument_list|)
expr_stmt|;
name|oindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|npages
condition|)
block|{
name|vm_pindex_t
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|osize
condition|;
name|idx
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|srcobject
argument_list|,
name|oindex
operator|+
name|idx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 				 * disallow busy or invalid pages, but allow 				 * m->busy pages if they are entirely valid. 				 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
operator|(
name|m
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|!=
name|VM_PAGE_BITS_ALL
operator|)
condition|)
block|{
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/*  * If we are changing an existing map entry, just redirect  * the object, and change mappings.  */
if|if
condition|(
operator|(
name|first_object
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|)
operator|&&
operator|(
operator|(
name|oldobject
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|==
name|first_object
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|offset
operator|!=
name|cp
operator|)
operator|||
operator|(
name|oldobject
operator|!=
name|srcobject
operator|)
condition|)
block|{
comment|/*    				* Remove old window into the file    				*/
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|tend
argument_list|)
expr_stmt|;
comment|/*    				* Force copy on write for mmaped regions    				*/
name|vm_object_pmap_copy_1
argument_list|(
name|srcobject
argument_list|,
name|oindex
argument_list|,
name|oindex
operator|+
name|osize
argument_list|)
expr_stmt|;
comment|/*    				* Point the object appropriately    				*/
if|if
condition|(
name|oldobject
operator|!=
name|srcobject
condition|)
block|{
comment|/*    				* Set the object optimization hint flag    				*/
name|vm_object_set_flag
argument_list|(
name|srcobject
argument_list|,
name|OBJ_OPT
argument_list|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|srcobject
expr_stmt|;
if|if
condition|(
name|oldobject
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|oldobject
argument_list|)
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|offset
operator|=
name|cp
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|tend
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|first_object
operator|->
name|ref_count
operator|==
literal|1
operator|)
operator|&&
operator|(
name|first_object
operator|->
name|size
operator|==
name|osize
operator|)
operator|&&
operator|(
operator|(
name|first_object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|)
operator|||
operator|(
name|first_object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
operator|)
condition|)
block|{
name|oldobject
operator|=
name|first_object
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
operator|(
name|first_object
operator|->
name|backing_object_offset
operator|!=
name|cp
operator|)
operator|||
operator|(
name|oldobject
operator|!=
name|srcobject
operator|)
condition|)
block|{
comment|/*    				* Remove old window into the file    				*/
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|tend
argument_list|)
expr_stmt|;
comment|/* 				 * Remove unneeded old pages 				 */
name|vm_object_page_remove
argument_list|(
name|first_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * Invalidate swap space 				 */
if|if
condition|(
name|first_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|swap_pager_freespace
argument_list|(
name|first_object
argument_list|,
literal|0
argument_list|,
name|first_object
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
comment|/*    				 * Force copy on write for mmaped regions    				 */
name|vm_object_pmap_copy_1
argument_list|(
name|srcobject
argument_list|,
name|oindex
argument_list|,
name|oindex
operator|+
name|osize
argument_list|)
expr_stmt|;
comment|/*    				 * Point the object appropriately    				 */
if|if
condition|(
name|oldobject
operator|!=
name|srcobject
condition|)
block|{
comment|/*    					 * Set the object optimization hint flag    					 */
name|vm_object_set_flag
argument_list|(
name|srcobject
argument_list|,
name|OBJ_OPT
argument_list|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldobject
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|oldobject
operator|->
name|shadow_head
argument_list|,
name|first_object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|oldobject
operator|->
name|shadow_count
operator|--
expr_stmt|;
comment|/* XXX bump generation? */
name|vm_object_deallocate
argument_list|(
name|oldobject
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|srcobject
operator|->
name|shadow_head
argument_list|,
name|first_object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|srcobject
operator|->
name|shadow_count
operator|++
expr_stmt|;
comment|/* XXX bump generation? */
name|first_object
operator|->
name|backing_object
operator|=
name|srcobject
expr_stmt|;
block|}
name|first_object
operator|->
name|backing_object_offset
operator|=
name|cp
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|tend
argument_list|)
expr_stmt|;
block|}
comment|/*  * Otherwise, we have to do a logical mmap.  */
block|}
else|else
block|{
name|vm_object_set_flag
argument_list|(
name|srcobject
argument_list|,
name|OBJ_OPT
argument_list|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|tend
argument_list|)
expr_stmt|;
name|vm_object_pmap_copy_1
argument_list|(
name|srcobject
argument_list|,
name|oindex
argument_list|,
name|oindex
operator|+
name|osize
argument_list|)
expr_stmt|;
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
block|{
name|map
operator|->
name|first_free
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|->
name|first_free
operator|->
name|start
operator|>=
name|start
condition|)
block|{
name|map
operator|->
name|first_free
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
block|}
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|)
expr_stmt|;
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|object
operator|=
name|srcobject
expr_stmt|;
name|ooffset
operator|=
name|cp
expr_stmt|;
name|rv
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|ooffset
argument_list|,
name|start
argument_list|,
name|tend
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_COPY_ON_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"vm_uiomove: could not insert new entry: %d"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
comment|/*  * Map the window directly, if it is already in memory  */
name|pmap_object_init_pt
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|uaddr
argument_list|,
name|srcobject
argument_list|,
name|oindex
argument_list|,
name|tcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|->
name|timestamp
operator|++
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|cnt
operator|-=
name|tcnt
expr_stmt|;
name|uaddr
operator|+=
name|tcnt
expr_stmt|;
name|cp
operator|+=
name|tcnt
expr_stmt|;
if|if
condition|(
name|npages
condition|)
operator|*
name|npages
operator|+=
name|osize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Performs the copy_on_write operations necessary to allow the virtual copies  * into user space to work.  This has to be called for write(2) system calls  * from other processes, file unlinking, and file size shrinkage.  */
end_comment

begin_function
name|void
name|vm_freeze_copyopts
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|froma
parameter_list|,
name|vm_pindex_t
name|toa
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|vm_object_t
name|robject
decl_stmt|;
name|vm_pindex_t
name|idx
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_OPT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|object
operator|->
name|shadow_count
operator|>
name|object
operator|->
name|ref_count
condition|)
name|panic
argument_list|(
literal|"vm_freeze_copyopts: sc> rc"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|robject
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|object
operator|->
name|shadow_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vm_pindex_t
name|bo_pindex
decl_stmt|;
name|vm_page_t
name|m_in
decl_stmt|,
name|m_out
decl_stmt|;
name|bo_pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|robject
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|robject
argument_list|)
expr_stmt|;
name|vm_object_pip_wait
argument_list|(
name|robject
argument_list|,
literal|"objfrz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|robject
operator|->
name|ref_count
operator|==
literal|1
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|robject
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vm_object_pip_add
argument_list|(
name|robject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|robject
operator|->
name|size
condition|;
name|idx
operator|++
control|)
block|{
name|m_out
operator|=
name|vm_page_grab
argument_list|(
name|robject
argument_list|,
name|idx
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_out
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|m_in
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|bo_pindex
operator|+
name|idx
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_in
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
operator|&
name|m_in
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|printf
argument_list|(
literal|"vm_freeze_copyopts: cannot read page from file: %lx\n"
argument_list|,
operator|(
name|long
operator|)
name|m_in
operator|->
name|pindex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vm_page_deactivate
argument_list|(
name|m_in
argument_list|)
expr_stmt|;
block|}
name|vm_page_protect
argument_list|(
name|m_in
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|pmap_copy_page
argument_list|(
name|m_in
argument_list|,
name|m_out
argument_list|)
expr_stmt|;
name|m_out
operator|->
name|valid
operator|=
name|m_in
operator|->
name|valid
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m_in
argument_list|)
expr_stmt|;
block|}
name|vm_page_wakeup
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
block|}
name|object
operator|->
name|shadow_count
operator|--
expr_stmt|;
name|object
operator|->
name|ref_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|shadow_head
argument_list|,
name|robject
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|robject
operator|->
name|backing_object
operator|=
name|NULL
expr_stmt|;
name|robject
operator|->
name|backing_object_offset
operator|=
literal|0
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|robject
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|robject
argument_list|)
expr_stmt|;
block|}
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_OPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_comment
comment|/*  *	vm_map_print:	[ debug ]  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|map
argument_list|,
argument|vm_map_print
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|int
name|nlines
decl_stmt|;
comment|/* XXX convert args. */
name|vm_map_t
name|map
init|=
operator|(
name|vm_map_t
operator|)
name|addr
decl_stmt|;
name|boolean_t
name|full
init|=
name|have_addr
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|db_iprintf
argument_list|(
literal|"Task map %p: pmap=%p, nentries=%d, version=%u\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|map
operator|->
name|pmap
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|map
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|full
operator|&&
name|db_indent
condition|)
return|return;
name|db_indent
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|db_iprintf
argument_list|(
literal|"map entry %p: start=%p, end=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
block|{
specifier|static
name|char
modifier|*
name|inheritance_name
index|[
literal|4
index|]
init|=
block|{
literal|"share"
block|,
literal|"copy"
block|,
literal|"none"
block|,
literal|"donate_copy"
block|}
decl_stmt|;
name|db_iprintf
argument_list|(
literal|" prot=%x/%x/%s"
argument_list|,
name|entry
operator|->
name|protection
argument_list|,
name|entry
operator|->
name|max_protection
argument_list|,
name|inheritance_name
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|entry
operator|->
name|inheritance
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|", wired"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
comment|/* XXX no %qd in kernel.  Truncate entry->offset. */
name|db_printf
argument_list|(
literal|", share=%p, offset=0x%lx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|object
operator|.
name|sub_map
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|sub_map
operator|!=
name|entry
operator|->
name|object
operator|.
name|sub_map
operator|)
condition|)
block|{
name|db_indent
operator|+=
literal|2
expr_stmt|;
name|vm_map_print
argument_list|(
operator|(
name|db_expr_t
operator|)
operator|(
name|intptr_t
operator|)
name|entry
operator|->
name|object
operator|.
name|sub_map
argument_list|,
name|full
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* XXX no %qd in kernel.  Truncate entry->offset. */
name|db_printf
argument_list|(
literal|", object=%p, offset=0x%lx"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_COW
condition|)
name|db_printf
argument_list|(
literal|", copy (%s)"
argument_list|,
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NEEDS_COPY
operator|)
condition|?
literal|"needed"
else|:
literal|"done"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
condition|)
block|{
name|db_indent
operator|+=
literal|2
expr_stmt|;
name|vm_object_print
argument_list|(
operator|(
name|db_expr_t
operator|)
operator|(
name|intptr_t
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|full
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nlines
operator|+=
literal|4
expr_stmt|;
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
name|db_indent
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|db_indent
operator|==
literal|0
condition|)
name|nlines
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|procvm
argument_list|,
argument|procvm
argument_list|)
end_macro

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|have_addr
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|addr
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|curproc
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"p = %p, vmspace = %p, map = %p, pmap = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
operator|->
name|p_vmspace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vmspace_pmap
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|)
argument_list|)
expr_stmt|;
name|vm_map_print
argument_list|(
call|(
name|db_expr_t
call|)
argument_list|(
name|intptr_t
argument_list|)
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

