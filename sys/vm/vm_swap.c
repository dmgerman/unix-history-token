begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)vm_swap.c	8.5 (Berkeley) 2/17/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_swap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmap.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * Indirect driver for multi-controller paging.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NSWAPDEV
end_ifndef

begin_define
define|#
directive|define
name|NSWAPDEV
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|swdevt
name|should_be_malloced
index|[
name|NSWAPDEV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|swdevt
modifier|*
name|swdevt
init|=
name|should_be_malloced
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first block after the interleaved devs */
end_comment

begin_decl_stmt
name|int
name|nswdev
init|=
name|NSWAPDEV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_swap_size
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|swapdev_strategy
parameter_list|(
name|struct
name|vop_strategy_args
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|swapdev_vp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	swapdev_strategy:  *  *	VOP_STRATEGY() for swapdev_vp.  *	Perform swap strategy interleave device selection.  *  *	The bp is expected to be locked and *not* B_DONE on call.  */
end_comment

begin_function
specifier|static
name|int
name|swapdev_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|sz
decl_stmt|,
name|off
decl_stmt|,
name|seg
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|ap
operator|->
name|a_bp
expr_stmt|;
name|sz
operator|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Convert interleaved swap into per-device swap.  Note that 	 * the block size is left in PAGE_SIZE'd chunks (for the newswap) 	 * here. 	 */
if|if
condition|(
name|nswdev
operator|>
literal|1
condition|)
block|{
name|off
operator|=
name|bp
operator|->
name|b_blkno
operator|%
name|dmmax
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|sz
operator|>
name|dmmax
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|seg
operator|=
name|bp
operator|->
name|b_blkno
operator|/
name|dmmax
expr_stmt|;
name|index
operator|=
name|seg
operator|%
name|nswdev
expr_stmt|;
name|seg
operator|/=
name|nswdev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|seg
operator|*
name|dmmax
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|=
operator|&
name|swdevt
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|+
name|sz
operator|>
name|sp
operator|->
name|sw_nblks
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bp
operator|->
name|b_dev
operator|=
name|sp
operator|->
name|sw_device
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sw_vp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Convert from PAGE_SIZE'd to DEV_BSIZE'd chunks for the actual I/O 	 */
name|bp
operator|->
name|b_blkno
operator|=
name|ctodb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|vhold
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|vp
operator|->
name|v_numoutput
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VBWAIT
operator|)
operator|&&
name|vp
operator|->
name|v_numoutput
operator|<=
literal|0
condition|)
block|{
name|vp
operator|->
name|v_flag
operator|&=
operator|~
name|VBWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vp
operator|->
name|v_numoutput
argument_list|)
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|sw_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
block|}
name|pbreassignbuf
argument_list|(
name|bp
argument_list|,
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|BUF_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Create a special vnode op vector for swapdev_vp - we only use  * VOP_STRATEGY(), everything else returns an error.  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|swapdev_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|swapdev_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_defaultop
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|swapdev_strategy
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|swapdev_vnodeop_opv_desc
init|=
block|{
operator|&
name|swapdev_vnodeop_p
block|,
name|swapdev_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|swapdev_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * System call swapon(name) enables swapping on device name,  * which must be in the swdevsw.  Return EBUSY  * if already swapping on this device.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|swapon_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|swapon
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|swapon_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|suser_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
comment|/* 	 * Swap metadata may not fit in the KVM if we have physical 	 * memory of>1GB. 	 */
if|if
condition|(
name|swap_zone
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
name|error
operator|=
name|swaponvp
argument_list|(
name|td
argument_list|,
name|vp
argument_list|,
name|vp
operator|->
name|v_rdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
name|vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Allow direct swapping to NFS regular files in the same 		 * way that nfs_mountroot() sets up diskless swapping. 		 */
name|error
operator|=
name|swaponvp
argument_list|(
name|td
argument_list|,
name|vp
argument_list|,
name|NODEV
argument_list|,
name|attr
operator|.
name|va_size
operator|/
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Swfree(index) frees the index'th portion of the swap map.  * Each of the nswdev devices provides 1/nswdev'th of the swap  * space, which is laid out with blocks of dmmax pages circularly  * among the devices.  *  * The new swap code uses page-sized blocks.  The old swap code used  * DEV_BSIZE'd chunks.  *  * XXX locking when multiple swapon's run in parallel  */
end_comment

begin_function
name|int
name|swaponvp
parameter_list|(
name|td
parameter_list|,
name|vp
parameter_list|,
name|dev
parameter_list|,
name|nblks
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|nblks
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|swblk_t
name|vsbase
decl_stmt|;
name|long
name|blk
decl_stmt|;
name|swblk_t
name|dvbase
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|aligned_nblks
decl_stmt|;
if|if
condition|(
operator|!
name|swapdev_vp
condition|)
block|{
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_NON
argument_list|,
name|NULL
argument_list|,
name|swapdev_vnodeop_p
argument_list|,
operator|&
name|swapdev_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Cannot get vnode for swapdev"
argument_list|)
expr_stmt|;
name|swapdev_vp
operator|->
name|v_type
operator|=
name|VNON
expr_stmt|;
comment|/* Untyped */
block|}
name|ASSERT_VOP_UNLOCKED
argument_list|(
name|vp
argument_list|,
literal|"swaponvp"
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|swdevt
operator|,
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nswdev
condition|;
name|index
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_vp
operator|==
name|vp
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|sp
operator|->
name|sw_vp
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|EINVAL
return|;
name|found
label|:
operator|(
name|void
operator|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nblks
operator|==
literal|0
operator|&&
name|dev
operator|!=
name|NODEV
operator|&&
operator|(
name|devsw
argument_list|(
name|dev
argument_list|)
operator|->
name|d_psize
operator|==
literal|0
operator|||
operator|(
name|nblks
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|dev
argument_list|)
operator|->
name|d_psize
operator|)
operator|(
name|dev
operator|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|nblks
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * If we go beyond this, we get overflows in the radix 	 * tree bitmap code. 	 */
if|if
condition|(
name|nblks
operator|>
literal|0x40000000
operator|/
name|BLIST_META_RADIX
operator|/
name|nswdev
condition|)
block|{
name|printf
argument_list|(
literal|"exceeded maximum of %d blocks per swap unit\n"
argument_list|,
literal|0x40000000
operator|/
name|BLIST_META_RADIX
operator|/
name|nswdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * nblks is in DEV_BSIZE'd chunks, convert to PAGE_SIZE'd chunks. 	 * First chop nblks off to page-align it, then convert. 	 *  	 * sw->sw_nblks is in page-sized chunks now too. 	 */
name|nblks
operator|&=
operator|~
operator|(
name|ctodb
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|nblks
operator|=
name|dbtoc
argument_list|(
name|nblks
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_vp
operator|=
name|vp
expr_stmt|;
name|sp
operator|->
name|sw_dev
operator|=
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_device
operator|=
name|dev
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator||=
name|SW_FREED
expr_stmt|;
name|sp
operator|->
name|sw_nblks
operator|=
name|nblks
expr_stmt|;
name|sp
operator|->
name|sw_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * nblks, nswap, and dmmax are PAGE_SIZE'd parameters now, not 	 * DEV_BSIZE'd.   aligned_nblks is used to calculate the 	 * size of the swap bitmap, taking into account the stripe size. 	 */
name|aligned_nblks
operator|=
operator|(
name|nblks
operator|+
operator|(
name|dmmax
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
call|(
name|u_long
call|)
argument_list|(
name|dmmax
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|aligned_nblks
operator|*
name|nswdev
operator|>
name|nswap
condition|)
name|nswap
operator|=
name|aligned_nblks
operator|*
name|nswdev
expr_stmt|;
if|if
condition|(
name|swapblist
operator|==
name|NULL
condition|)
name|swapblist
operator|=
name|blist_create
argument_list|(
name|nswap
argument_list|)
expr_stmt|;
else|else
name|blist_resize
argument_list|(
operator|&
name|swapblist
argument_list|,
name|nswap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|dvbase
operator|=
name|dmmax
init|;
name|dvbase
operator|<
name|nblks
condition|;
name|dvbase
operator|+=
name|dmmax
control|)
block|{
name|blk
operator|=
name|min
argument_list|(
name|nblks
operator|-
name|dvbase
argument_list|,
name|dmmax
argument_list|)
expr_stmt|;
name|vsbase
operator|=
name|index
operator|*
name|dmmax
operator|+
name|dvbase
operator|*
name|nswdev
expr_stmt|;
name|blist_free
argument_list|(
name|swapblist
argument_list|,
name|vsbase
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|vm_swap_size
operator|+=
name|blk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_vm_swap_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
modifier|*
name|name
init|=
operator|(
name|int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|xswdev
name|xs
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|arg2
operator|!=
literal|1
condition|)
comment|/* name length */
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|swdevt
operator|,
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|nswdev
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_vp
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|*
name|name
condition|)
block|{
name|xs
operator|.
name|xsw_version
operator|=
name|XSWDEV_VERSION
expr_stmt|;
name|xs
operator|.
name|xsw_dev
operator|=
name|sp
operator|->
name|sw_dev
expr_stmt|;
name|xs
operator|.
name|xsw_flags
operator|=
name|sp
operator|->
name|sw_flags
expr_stmt|;
name|xs
operator|.
name|xsw_nblks
operator|=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
name|xs
operator|.
name|xsw_used
operator|=
name|sp
operator|->
name|sw_used
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xs
argument_list|,
sizeof|sizeof
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|n
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_info
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sysctl_vm_swap_info
argument_list|,
literal|"Swap statistics by device"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

