begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Adrian Chadd<adrian@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/seq.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_phys.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_domain.h>
end_include

begin_function
specifier|static
name|__inline
name|int
name|vm_domain_rr_selectdomain
parameter_list|(
name|int
name|skip_domain
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_dom_rr_idx
operator|++
expr_stmt|;
name|td
operator|->
name|td_dom_rr_idx
operator|%=
name|vm_ndomains
expr_stmt|;
comment|/* 	 * If skip_domain is provided then skip over that 	 * domain.  This is intended for round robin variants 	 * which first try a fixed domain. 	 */
if|if
condition|(
operator|(
name|skip_domain
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_dom_rr_idx
operator|==
name|skip_domain
operator|)
condition|)
block|{
name|td
operator|->
name|td_dom_rr_idx
operator|++
expr_stmt|;
name|td
operator|->
name|td_dom_rr_idx
operator|%=
name|vm_ndomains
expr_stmt|;
block|}
return|return
operator|(
name|td
operator|->
name|td_dom_rr_idx
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This implements a very simple set of VM domain memory allocation  * policies and iterators.  */
end_comment

begin_comment
comment|/*  * A VM domain policy represents a desired VM domain policy.  * Iterators implement searching through VM domains in a specific  * order.  */
end_comment

begin_comment
comment|/*  * When setting a policy, the caller must establish their own  * exclusive write protection for the contents of the domain  * policy.  */
end_comment

begin_function
name|int
name|vm_domain_policy_init
parameter_list|(
name|struct
name|vm_domain_policy
modifier|*
name|vp
parameter_list|)
block|{
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|p
operator|.
name|policy
operator|=
name|VM_POLICY_NONE
expr_stmt|;
name|vp
operator|->
name|p
operator|.
name|domain
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_domain_policy_set
parameter_list|(
name|struct
name|vm_domain_policy
modifier|*
name|vp
parameter_list|,
name|vm_domain_policy_type_t
name|vt
parameter_list|,
name|int
name|domain
parameter_list|)
block|{
name|seq_write_begin
argument_list|(
operator|&
name|vp
operator|->
name|seq
argument_list|)
expr_stmt|;
name|vp
operator|->
name|p
operator|.
name|policy
operator|=
name|vt
expr_stmt|;
name|vp
operator|->
name|p
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
name|seq_write_end
argument_list|(
operator|&
name|vp
operator|->
name|seq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a local copy of a policy.  *  * The destination policy isn't write-barriered; this is used  * for doing local copies into something that isn't shared.  */
end_comment

begin_function
name|void
name|vm_domain_policy_localcopy
parameter_list|(
name|struct
name|vm_domain_policy
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|vm_domain_policy
modifier|*
name|src
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|seq
operator|=
name|seq_read
argument_list|(
operator|&
name|src
operator|->
name|seq
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
if|if
condition|(
name|seq_consistent
argument_list|(
operator|&
name|src
operator|->
name|seq
argument_list|,
name|seq
argument_list|)
condition|)
return|return;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take a write-barrier copy of a policy.  *  * The destination policy is write -barriered; this is used  * for doing copies into policies that may be read by other  * threads.  */
end_comment

begin_function
name|void
name|vm_domain_policy_copy
parameter_list|(
name|struct
name|vm_domain_policy
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|vm_domain_policy
modifier|*
name|src
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
name|struct
name|vm_domain_policy
name|d
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|seq
operator|=
name|seq_read
argument_list|(
operator|&
name|src
operator|->
name|seq
argument_list|)
expr_stmt|;
name|d
operator|=
operator|*
name|src
expr_stmt|;
if|if
condition|(
name|seq_consistent
argument_list|(
operator|&
name|src
operator|->
name|seq
argument_list|,
name|seq
argument_list|)
condition|)
block|{
name|seq_write_begin
argument_list|(
operator|&
name|dst
operator|->
name|seq
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p
operator|.
name|domain
operator|=
name|d
operator|.
name|p
operator|.
name|domain
expr_stmt|;
name|dst
operator|->
name|p
operator|.
name|policy
operator|=
name|d
operator|.
name|p
operator|.
name|policy
expr_stmt|;
name|seq_write_end
argument_list|(
operator|&
name|dst
operator|->
name|seq
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|vm_domain_policy_validate
parameter_list|(
specifier|const
name|struct
name|vm_domain_policy
modifier|*
name|vp
parameter_list|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|p
operator|.
name|policy
condition|)
block|{
case|case
name|VM_POLICY_NONE
case|:
case|case
name|VM_POLICY_ROUND_ROBIN
case|:
case|case
name|VM_POLICY_FIRST_TOUCH
case|:
case|case
name|VM_POLICY_FIRST_TOUCH_ROUND_ROBIN
case|:
if|if
condition|(
name|vp
operator|->
name|p
operator|.
name|domain
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|VM_POLICY_FIXED_DOMAIN
case|:
case|case
name|VM_POLICY_FIXED_DOMAIN_ROUND_ROBIN
case|:
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
if|if
condition|(
name|vp
operator|->
name|p
operator|.
name|domain
operator|>=
literal|0
operator|&&
name|vp
operator|->
name|p
operator|.
name|domain
operator|<
name|vm_ndomains
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|vp
operator|->
name|p
operator|.
name|domain
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_domain_policy_cleanup
parameter_list|(
name|struct
name|vm_domain_policy
modifier|*
name|vp
parameter_list|)
block|{
comment|/* For now, empty */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_domain_iterator_init
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|)
block|{
comment|/* Nothing to do for now */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manually setup an iterator with the given details.  */
end_comment

begin_function
name|int
name|vm_domain_iterator_set
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|,
name|vm_domain_policy_type_t
name|vt
parameter_list|,
name|int
name|domain
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
switch|switch
condition|(
name|vt
condition|)
block|{
case|case
name|VM_POLICY_FIXED_DOMAIN
case|:
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_FIXED_DOMAIN
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIXED_DOMAIN_ROUND_ROBIN
case|:
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_FIXED_DOMAIN_ROUND_ROBIN
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIRST_TOUCH
case|:
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_FIRST_TOUCH
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|PCPU_GET
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIRST_TOUCH_ROUND_ROBIN
case|:
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_FIRST_TOUCH_ROUND_ROBIN
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|PCPU_GET
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
case|case
name|VM_POLICY_ROUND_ROBIN
case|:
default|default:
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_ROUND_ROBIN
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
operator|-
literal|1
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|vi
operator|->
name|domain
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup an iterator based on the given policy.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_vm_domain_iterator_set_policy
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|,
specifier|const
name|struct
name|vm_domain_policy
modifier|*
name|vt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
comment|/* 	 * Initialise the iterator. 	 * 	 * For first-touch, the initial domain is set 	 * via the current thread CPU domain. 	 * 	 * For fixed-domain, it's assumed that the 	 * caller has initialised the specific domain 	 * it is after. 	 */
switch|switch
condition|(
name|vt
operator|->
name|p
operator|.
name|policy
condition|)
block|{
case|case
name|VM_POLICY_FIXED_DOMAIN
case|:
name|vi
operator|->
name|policy
operator|=
name|vt
operator|->
name|p
operator|.
name|policy
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|vt
operator|->
name|p
operator|.
name|domain
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIXED_DOMAIN_ROUND_ROBIN
case|:
name|vi
operator|->
name|policy
operator|=
name|vt
operator|->
name|p
operator|.
name|policy
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|vt
operator|->
name|p
operator|.
name|domain
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIRST_TOUCH
case|:
name|vi
operator|->
name|policy
operator|=
name|vt
operator|->
name|p
operator|.
name|policy
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|PCPU_GET
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIRST_TOUCH_ROUND_ROBIN
case|:
name|vi
operator|->
name|policy
operator|=
name|vt
operator|->
name|p
operator|.
name|policy
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
name|PCPU_GET
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
case|case
name|VM_POLICY_ROUND_ROBIN
case|:
default|default:
comment|/* 		 * Default to round-robin policy. 		 */
name|vi
operator|->
name|policy
operator|=
name|VM_POLICY_ROUND_ROBIN
expr_stmt|;
name|vi
operator|->
name|domain
operator|=
operator|-
literal|1
expr_stmt|;
name|vi
operator|->
name|n
operator|=
name|vm_ndomains
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|vi
operator|->
name|domain
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|n
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|vm_domain_iterator_set_policy
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|,
specifier|const
name|struct
name|vm_domain_policy
modifier|*
name|vt
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
name|struct
name|vm_domain_policy
name|vt_lcl
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|seq
operator|=
name|seq_read
argument_list|(
operator|&
name|vt
operator|->
name|seq
argument_list|)
expr_stmt|;
name|vt_lcl
operator|=
operator|*
name|vt
expr_stmt|;
if|if
condition|(
name|seq_consistent
argument_list|(
operator|&
name|vt
operator|->
name|seq
argument_list|,
name|seq
argument_list|)
condition|)
block|{
name|_vm_domain_iterator_set_policy
argument_list|(
name|vi
argument_list|,
operator|&
name|vt_lcl
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next VM domain to use.  *  * Returns 0 w/ domain set to the next domain to use, or  * -1 to indicate no more domains are available.  */
end_comment

begin_function
name|int
name|vm_domain_iterator_run
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|,
name|int
modifier|*
name|domain
parameter_list|)
block|{
comment|/* General catch-all */
if|if
condition|(
name|vi
operator|->
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|VM_NUMA_ALLOC
switch|switch
condition|(
name|vi
operator|->
name|policy
condition|)
block|{
case|case
name|VM_POLICY_FIXED_DOMAIN
case|:
case|case
name|VM_POLICY_FIRST_TOUCH
case|:
operator|*
name|domain
operator|=
name|vi
operator|->
name|domain
expr_stmt|;
name|vi
operator|->
name|n
operator|--
expr_stmt|;
break|break;
case|case
name|VM_POLICY_FIXED_DOMAIN_ROUND_ROBIN
case|:
case|case
name|VM_POLICY_FIRST_TOUCH_ROUND_ROBIN
case|:
comment|/* 		 * XXX TODO: skip over the rr'ed domain 		 * if it equals the one we started with. 		 */
if|if
condition|(
name|vi
operator|->
name|n
operator|==
name|vm_ndomains
condition|)
operator|*
name|domain
operator|=
name|vi
operator|->
name|domain
expr_stmt|;
else|else
operator|*
name|domain
operator|=
name|vm_domain_rr_selectdomain
argument_list|(
name|vi
operator|->
name|domain
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|--
expr_stmt|;
break|break;
case|case
name|VM_POLICY_ROUND_ROBIN
case|:
default|default:
operator|*
name|domain
operator|=
name|vm_domain_rr_selectdomain
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vi
operator|->
name|n
operator|--
expr_stmt|;
break|break;
block|}
else|#
directive|else
operator|*
name|domain
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|n
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the iteration is done, or 0 if it has not.   * This can only be called after at least one loop through  * the iterator.  Ie, it's designed to be used as a tail  * check of a loop, not the head check of a loop.  */
end_comment

begin_function
name|int
name|vm_domain_iterator_isdone
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|)
block|{
return|return
operator|(
name|vi
operator|->
name|n
operator|<=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vm_domain_iterator_cleanup
parameter_list|(
name|struct
name|vm_domain_iterator
modifier|*
name|vi
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

