begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_object.c	8.5 (Berkeley) 3/22/94  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Virtual memory object module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for curproc, pageproc */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_radix.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_reserv.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|old_msync
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|old_msync
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|old_msync
argument_list|,
literal|0
argument_list|,
literal|"Use old (insecure) msync behavior"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|vm_object_page_collect_flush
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
name|p
parameter_list|,
name|int
name|pagerflags
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
modifier|*
name|clearobjflags
parameter_list|,
name|boolean_t
modifier|*
name|eio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|vm_object_page_remove_write
parameter_list|(
name|vm_page_t
name|p
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
modifier|*
name|clearobjflags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_object_qcollapse
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_object_vndeallocate
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *	Virtual memory objects maintain the actual data  *	associated with allocated virtual memory.  A given  *	page of memory exists within exactly one object.  *  *	An object is only deallocated when all "references"  *	are given up.  Only one "reference" to a given  *	region of an object should be writeable.  *  *	Associated with each object is a list of all resident  *	memory pages belonging to that object; this list is  *	maintained by the "vm_page" module, and locked by the object's  *	lock.  *  *	Each object also records a "pager" routine which is  *	used to retrieve (and store) pages to the proper backing  *	storage.  In addition, objects may be backed by other  *	objects from which they were virtual-copied.  *  *	The only items within the object structure which are  *	modified after time of creation are:  *		reference count		locked by object's lock  *		pager routine		locked by object's lock  *  */
end_comment

begin_decl_stmt
name|struct
name|object_q
name|vm_object_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|vm_object_list_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock for object list and count */
end_comment

begin_decl_stmt
name|struct
name|vm_object
name|kernel_object_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vm_object
name|kmem_object_store
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|object
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM object stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|object_collapses
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_stats_object
argument_list|,
name|OID_AUTO
argument_list|,
name|collapses
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|object_collapses
argument_list|,
literal|0
argument_list|,
literal|"VM object collapses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|object_bypasses
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_stats_object
argument_list|,
name|OID_AUTO
argument_list|,
name|bypasses
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|object_bypasses
argument_list|,
literal|0
argument_list|,
literal|"VM object bypasses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|obj_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vm_object_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|vm_object_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|vm_object_zdtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
operator|(
name|vm_object_t
operator|)
name|mem
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|ref_count
operator|==
literal|0
argument_list|,
operator|(
literal|"object %p ref_count = %d"
operator|,
name|object
operator|,
name|object
operator|->
name|ref_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
argument_list|,
operator|(
literal|"object %p has resident pages in its memq"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vm_radix_is_empty
argument_list|(
operator|&
name|object
operator|->
name|rtree
argument_list|)
argument_list|,
operator|(
literal|"object %p has resident pages in its trie"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|object
operator|->
name|rvq
argument_list|)
argument_list|,
operator|(
literal|"object %p has reservations"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
argument_list|,
operator|(
literal|"object %p paging_in_progress = %d"
operator|,
name|object
operator|,
name|object
operator|->
name|paging_in_progress
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|resident_page_count
operator|==
literal|0
argument_list|,
operator|(
literal|"object %p resident_page_count = %d"
operator|,
name|object
operator|,
name|object
operator|->
name|resident_page_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|shadow_count
operator|==
literal|0
argument_list|,
operator|(
literal|"object %p shadow_count = %d"
operator|,
name|object
operator|,
name|object
operator|->
name|shadow_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEAD
argument_list|,
operator|(
literal|"object %p has non-dead type %d"
operator|,
name|object
operator|,
name|object
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vm_object_zinit
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
operator|(
name|vm_object_t
operator|)
name|mem
expr_stmt|;
name|rw_init_flags
argument_list|(
operator|&
name|object
operator|->
name|lock
argument_list|,
literal|"vm object"
argument_list|,
name|RW_DUPOK
operator||
name|RW_NEW
argument_list|)
expr_stmt|;
comment|/* These are true for any object that has been freed */
name|object
operator|->
name|type
operator|=
name|OBJT_DEAD
expr_stmt|;
name|object
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|object
operator|->
name|rtree
operator|.
name|rt_root
operator|=
literal|0
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|=
literal|0
expr_stmt|;
name|object
operator|->
name|resident_page_count
operator|=
literal|0
expr_stmt|;
name|object
operator|->
name|shadow_count
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_object_list
argument_list|,
name|object
argument_list|,
name|object_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_vm_object_allocate
parameter_list|(
name|objtype_t
name|type
parameter_list|,
name|vm_pindex_t
name|size
parameter_list|,
name|vm_object_t
name|object
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|object
operator|->
name|shadow_head
argument_list|)
expr_stmt|;
name|object
operator|->
name|type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OBJT_DEAD
case|:
name|panic
argument_list|(
literal|"_vm_object_allocate: can't create OBJT_DEAD"
argument_list|)
expr_stmt|;
case|case
name|OBJT_DEFAULT
case|:
case|case
name|OBJT_SWAP
case|:
name|object
operator|->
name|flags
operator|=
name|OBJ_ONEMAPPING
expr_stmt|;
break|break;
case|case
name|OBJT_DEVICE
case|:
case|case
name|OBJT_SG
case|:
name|object
operator|->
name|flags
operator|=
name|OBJ_FICTITIOUS
operator||
name|OBJ_UNMANAGED
expr_stmt|;
break|break;
case|case
name|OBJT_MGTDEVICE
case|:
name|object
operator|->
name|flags
operator|=
name|OBJ_FICTITIOUS
expr_stmt|;
break|break;
case|case
name|OBJT_PHYS
case|:
name|object
operator|->
name|flags
operator|=
name|OBJ_UNMANAGED
expr_stmt|;
break|break;
case|case
name|OBJT_VNODE
case|:
name|object
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"_vm_object_allocate: type %d is undefined"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|object
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|object
operator|->
name|generation
operator|=
literal|1
expr_stmt|;
name|object
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|object
operator|->
name|memattr
operator|=
name|VM_MEMATTR_DEFAULT
expr_stmt|;
name|object
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
name|object
operator|->
name|charge
operator|=
literal|0
expr_stmt|;
name|object
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
name|object
operator|->
name|backing_object
operator|=
name|NULL
expr_stmt|;
name|object
operator|->
name|backing_object_offset
operator|=
operator|(
name|vm_ooffset_t
operator|)
literal|0
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
name|LIST_INIT
argument_list|(
operator|&
name|object
operator|->
name|rvq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|umtx_shm_object_init
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_init:  *  *	Initialize the VM objects module.  */
end_comment

begin_function
name|void
name|vm_object_init
parameter_list|(
name|void
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_object_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|,
literal|"vm object_list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|kernel_object
operator|->
name|lock
argument_list|,
literal|"kernel vm object"
argument_list|)
expr_stmt|;
name|_vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|atop
argument_list|(
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
argument_list|,
name|kernel_object
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
name|kernel_object
operator|->
name|flags
operator||=
name|OBJ_COLORED
expr_stmt|;
name|kernel_object
operator|->
name|pg_color
operator|=
operator|(
name|u_short
operator|)
name|atop
argument_list|(
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rw_init
argument_list|(
operator|&
name|kmem_object
operator|->
name|lock
argument_list|,
literal|"kmem vm object"
argument_list|)
expr_stmt|;
name|_vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|atop
argument_list|(
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
argument_list|,
name|kmem_object
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
name|kmem_object
operator|->
name|flags
operator||=
name|OBJ_COLORED
expr_stmt|;
name|kmem_object
operator|->
name|pg_color
operator|=
operator|(
name|u_short
operator|)
name|atop
argument_list|(
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The lock portion of struct vm_object must be type stable due 	 * to vm_pageout_fallback_object_lock locking a vm object 	 * without holding any references to it. 	 */
name|obj_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"VM OBJECT"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_object
argument_list|)
argument_list|,
name|NULL
argument_list|,
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_object_zdtor
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|vm_object_zinit
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|vm_radix_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_object_clear_flag
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|u_short
name|bits
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator|&=
operator|~
name|bits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Sets the default memory attribute for the specified object.  Pages  *	that are allocated to this object are by default assigned this memory  *	attribute.  *  *	Presently, this function must be called before any pages are allocated  *	to the object.  In the future, this requirement may be relaxed for  *	"default" and "swap" objects.  */
end_comment

begin_function
name|int
name|vm_object_set_memattr
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_memattr_t
name|memattr
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|object
operator|->
name|type
condition|)
block|{
case|case
name|OBJT_DEFAULT
case|:
case|case
name|OBJT_DEVICE
case|:
case|case
name|OBJT_MGTDEVICE
case|:
case|case
name|OBJT_PHYS
case|:
case|case
name|OBJT_SG
case|:
case|case
name|OBJT_SWAP
case|:
case|case
name|OBJT_VNODE
case|:
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
break|break;
case|case
name|OBJT_DEAD
case|:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"vm_object_set_memattr: object %p is of undefined type"
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
name|object
operator|->
name|memattr
operator|=
name|memattr
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_object_pip_add
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|short
name|i
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|+=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_object_pip_subtract
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|short
name|i
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|-=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_object_pip_wakeup
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
operator|&&
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
condition|)
block|{
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_PIPWNT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vm_object_pip_wakeupn
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|short
name|i
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|object
operator|->
name|paging_in_progress
operator|-=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
operator|&&
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
condition|)
block|{
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_PIPWNT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vm_object_pip_wait
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|char
modifier|*
name|waitid
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
name|object
operator|->
name|paging_in_progress
condition|)
block|{
name|object
operator|->
name|flags
operator||=
name|OBJ_PIPWNT
expr_stmt|;
name|VM_OBJECT_SLEEP
argument_list|(
name|object
argument_list|,
name|object
argument_list|,
name|PVM
argument_list|,
name|waitid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_object_allocate:  *  *	Returns a new object with the given size.  */
end_comment

begin_function
name|vm_object_t
name|vm_object_allocate
parameter_list|(
name|objtype_t
name|type
parameter_list|,
name|vm_pindex_t
name|size
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
operator|(
name|vm_object_t
operator|)
name|uma_zalloc
argument_list|(
name|obj_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|_vm_object_allocate
argument_list|(
name|type
argument_list|,
name|size
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_reference:  *  *	Gets another reference to the given object.  Note: OBJ_DEAD  *	objects can be referenced during final cleaning.  */
end_comment

begin_function
name|void
name|vm_object_reference
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_reference_locked
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_reference_locked:  *  *	Gets another reference to the given object.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_object_reference_locked
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|ref_count
operator|++
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|vp
operator|=
name|object
operator|->
name|handle
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle deallocating an object of type OBJT_VNODE.  */
end_comment

begin_function
specifier|static
name|void
name|vm_object_vndeallocate
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|object
operator|->
name|handle
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
argument_list|,
operator|(
literal|"vm_object_vndeallocate: not a vnode object"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vm_object_vndeallocate: missing vp"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|object
operator|->
name|ref_count
operator|==
literal|0
condition|)
block|{
name|vn_printf
argument_list|(
name|vp
argument_list|,
literal|"vm_object_vndeallocate "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"vm_object_vndeallocate: bad object reference count"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|umtx_shm_vnobj_persistent
operator|&&
name|object
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|umtx_shm_object_terminated
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * The test for text of vp vnode does not need a bypass to 	 * reach right VV_TEXT there, since it is obtained from 	 * object->handle. 	 */
if|if
condition|(
name|object
operator|->
name|ref_count
operator|>
literal|1
operator|||
operator|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_TEXT
operator|)
operator|==
literal|0
condition|)
block|{
name|object
operator|->
name|ref_count
operator|--
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* vrele may need the vnode lock. */
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhold
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEAD
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object
operator|->
name|ref_count
operator|==
literal|0
condition|)
name|VOP_UNSET_TEXT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_object_deallocate:  *  *	Release a reference to the specified object,  *	gained either through a vm_object_allocate  *	or a vm_object_reference call.  When all references  *	are gone, storage associated with this object  *	may be relinquished.  *  *	No object may be locked.  */
end_comment

begin_function
name|void
name|vm_object_deallocate
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|vm_object_t
name|temp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
while|while
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|vm_object_vndeallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|object
operator|->
name|ref_count
operator|!=
literal|0
argument_list|,
operator|(
literal|"vm_object_deallocate: object deallocated too many times: %d"
operator|,
name|object
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the reference count goes to 0 we start calling 		 * vm_object_terminate() on the object chain. 		 * A ref count of 1 may be a special case depending on the 		 * shadow count being 0 or 1. 		 */
name|object
operator|->
name|ref_count
operator|--
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|ref_count
operator|>
literal|1
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|object
operator|->
name|ref_count
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS
operator|)
operator|!=
literal|0
condition|)
block|{
name|vp
operator|=
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_tmpfs
expr_stmt|;
name|vhold
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEAD
operator|||
name|object
operator|->
name|ref_count
operator|!=
literal|1
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS
operator|)
operator|!=
literal|0
condition|)
name|VOP_UNSET_TEXT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|->
name|shadow_count
operator|==
literal|0
operator|&&
name|object
operator|->
name|handle
operator|==
name|NULL
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS_NODE
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|vm_object_set_flag
argument_list|(
name|object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|object
operator|->
name|shadow_count
operator|==
literal|1
operator|)
operator|&&
operator|(
name|object
operator|->
name|handle
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|vm_object_t
name|robject
decl_stmt|;
name|robject
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|object
operator|->
name|shadow_head
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|robject
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vm_object_deallocate: ref_count: %d, shadow_count: %d"
operator|,
name|object
operator|->
name|ref_count
operator|,
name|object
operator|->
name|shadow_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|robject
operator|->
name|flags
operator|&
name|OBJ_TMPFS_NODE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"shadowed tmpfs v_object %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VM_OBJECT_TRYWLOCK
argument_list|(
name|robject
argument_list|)
condition|)
block|{
comment|/* 					 * Avoid a potential deadlock. 					 */
name|object
operator|->
name|ref_count
operator|++
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 					 * More likely than not the thread 					 * holding robject's lock has lower 					 * priority than the current thread. 					 * Let the lower priority thread run. 					 */
name|pause
argument_list|(
literal|"vmo_de"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * Collapse object into its shadow unless its 				 * shadow is dead.  In that case, object will 				 * be deallocated by the thread that is 				 * deallocating its shadow. 				 */
if|if
condition|(
operator|(
name|robject
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|robject
operator|->
name|handle
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|robject
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|robject
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|robject
operator|->
name|ref_count
operator|++
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|robject
operator|->
name|paging_in_progress
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_pip_wait
argument_list|(
name|robject
argument_list|,
literal|"objde1"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|robject
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|temp
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|object
operator|->
name|paging_in_progress
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|robject
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator||=
name|OBJ_PIPWNT
expr_stmt|;
name|VM_OBJECT_SLEEP
argument_list|(
name|object
argument_list|,
name|object
argument_list|,
name|PDROP
operator||
name|PVM
argument_list|,
literal|"objde2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|robject
argument_list|)
expr_stmt|;
name|temp
operator|=
name|robject
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|temp
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|robject
operator|->
name|ref_count
operator|==
literal|1
condition|)
block|{
name|robject
operator|->
name|ref_count
operator|--
expr_stmt|;
name|object
operator|=
name|robject
expr_stmt|;
goto|goto
name|doterm
goto|;
block|}
name|object
operator|=
name|robject
expr_stmt|;
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|robject
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
name|doterm
label|:
name|umtx_shm_object_terminated
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|temp
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS_NODE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"shadowed tmpfs v_object 2 %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|temp
operator|->
name|shadow_count
operator|--
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|object
operator|->
name|backing_object
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Don't double-terminate, we could be in a termination 		 * recursion due to the terminate having to sync data 		 * to disk. 		 */
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|==
literal|0
condition|)
name|vm_object_terminate
argument_list|(
name|object
argument_list|)
expr_stmt|;
else|else
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_object_destroy removes the object from the global object list  *      and frees the space for the object.  */
end_comment

begin_function
name|void
name|vm_object_destroy
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
comment|/* 	 * Release the allocation charge. 	 */
if|if
condition|(
name|object
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|swap_release_by_cred
argument_list|(
name|object
operator|->
name|charge
argument_list|,
name|object
operator|->
name|cred
argument_list|)
expr_stmt|;
name|object
operator|->
name|charge
operator|=
literal|0
expr_stmt|;
name|crfree
argument_list|(
name|object
operator|->
name|cred
argument_list|)
expr_stmt|;
name|object
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Free the space for the object. 	 */
name|uma_zfree
argument_list|(
name|obj_zone
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_terminate actually destroys the specified object, freeing  *	up all previously used resources.  *  *	The object must be locked.  *	This routine may block.  */
end_comment

begin_function
name|void
name|vm_object_terminate
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|,
name|p_next
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure no one uses us. 	 */
name|vm_object_set_flag
argument_list|(
name|object
argument_list|,
name|OBJ_DEAD
argument_list|)
expr_stmt|;
comment|/* 	 * wait for the pageout daemon to be done with the object 	 */
name|vm_object_pip_wait
argument_list|(
name|object
argument_list|,
literal|"objtrm"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|object
operator|->
name|paging_in_progress
argument_list|,
operator|(
literal|"vm_object_terminate: pageout in progress"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean and free the pages, as appropriate. All references to the 	 * object are gone, so we don't need to lock it. 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|object
operator|->
name|handle
decl_stmt|;
comment|/* 		 * Clean pages and flush buffers. 		 */
name|vm_object_page_clean
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_flag
operator||=
name|BO_DEAD
expr_stmt|;
name|BO_UNLOCK
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|object
operator|->
name|ref_count
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_terminate: object with references, ref_count=%d"
operator|,
name|object
operator|->
name|ref_count
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Free any remaining pageable pages.  This also removes them from the 	 * paging queues.  However, don't free wired pages, just remove them 	 * from the object.  Rather than incrementally removing each page from 	 * the object, the page and object are reset to any empty state.  	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&object->memq
argument_list|,
argument|listq
argument_list|,
argument|p_next
argument_list|)
block|{
name|vm_page_assert_unbusied
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Optimize the page's removal from the object by resetting 		 * its "object" field.  Specifically, if the page is not 		 * wired, then the effect of this assignment is that 		 * vm_page_free()'s call to vm_page_remove() will return 		 * immediately without modifying the page or the object. 		 */
name|p
operator|->
name|object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PCPU_INC
argument_list|(
name|cnt
operator|.
name|v_pfree
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the object contained any pages, then reset it to an empty state. 	 * None of the object's fields, including "resident_page_count", were 	 * modified by the preceding loop. 	 */
if|if
condition|(
name|object
operator|->
name|resident_page_count
operator|!=
literal|0
condition|)
block|{
name|vm_radix_reclaim_allnodes
argument_list|(
operator|&
name|object
operator|->
name|rtree
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|)
expr_stmt|;
name|object
operator|->
name|resident_page_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
name|vdrop
argument_list|(
name|object
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|object
operator|->
name|rvq
argument_list|)
argument_list|)
condition|)
name|vm_reserv_break_all
argument_list|(
name|object
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|object
operator|->
name|cred
operator|==
name|NULL
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
argument_list|,
operator|(
literal|"%s: non-swap obj %p has cred"
operator|,
name|__func__
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Let the pager know object is dead. 	 */
name|vm_pager_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_destroy
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make the page read-only so that we can clear the object flags.  However, if  * this is a nosync mmap then the object is likely to stay dirty so do not  * mess with the page and do not clear the object flags.  Returns TRUE if the  * page should be flushed, and FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|vm_object_page_remove_write
parameter_list|(
name|vm_page_t
name|p
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
modifier|*
name|clearobjflags
parameter_list|)
block|{
comment|/* 	 * If we have been asked to skip nosync pages and this is a 	 * nosync page, skip it.  Note that the object flags were not 	 * cleared in this case so we do not have to set them. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|OBJPC_NOSYNC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|oflags
operator|&
name|VPO_NOSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|clearobjflags
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
name|pmap_remove_write
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|dirty
operator|!=
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_object_page_clean  *  *	Clean all dirty pages in the specified range of object.  Leaves page   * 	on whatever queue it is currently on.   If NOSYNC is set then do not  *	write out pages with VPO_NOSYNC set (originally comes from MAP_NOSYNC),  *	leaving the object dirty.  *  *	When stuffing pages asynchronously, allow clustering.  XXX we need a  *	synchronous clustering mode implementation.  *  *	Odd semantics: if start == end, we clean everything.  *  *	The object must be locked.  *  *	Returns FALSE if some page from the range was not written, as  *	reported by the pager, and TRUE otherwise.  */
end_comment

begin_function
name|boolean_t
name|vm_object_page_clean
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|start
parameter_list|,
name|vm_ooffset_t
name|end
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_page_t
name|np
decl_stmt|,
name|p
decl_stmt|;
name|vm_pindex_t
name|pi
decl_stmt|,
name|tend
decl_stmt|,
name|tstart
decl_stmt|;
name|int
name|curgeneration
decl_stmt|,
name|n
decl_stmt|,
name|pagerflags
decl_stmt|;
name|boolean_t
name|clearobjflags
decl_stmt|,
name|eio
decl_stmt|,
name|res
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * The OBJ_MIGHTBEDIRTY flag is only set for OBJT_VNODE 	 * objects.  The check below prevents the function from 	 * operating on non-vnode objects. 	 */
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_MIGHTBEDIRTY
operator|)
operator|==
literal|0
operator|||
name|object
operator|->
name|resident_page_count
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|pagerflags
operator|=
operator|(
name|flags
operator|&
operator|(
name|OBJPC_SYNC
operator||
name|OBJPC_INVAL
operator|)
operator|)
operator|!=
literal|0
condition|?
name|VM_PAGER_PUT_SYNC
else|:
name|VM_PAGER_CLUSTER_OK
expr_stmt|;
name|pagerflags
operator||=
operator|(
name|flags
operator|&
name|OBJPC_INVAL
operator|)
operator|!=
literal|0
condition|?
name|VM_PAGER_PUT_INVAL
else|:
literal|0
expr_stmt|;
name|tstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|tend
operator|=
operator|(
name|end
operator|==
literal|0
operator|)
condition|?
name|object
operator|->
name|size
else|:
name|OFF_TO_IDX
argument_list|(
name|end
operator|+
name|PAGE_MASK
argument_list|)
expr_stmt|;
name|clearobjflags
operator|=
name|tstart
operator|==
literal|0
operator|&&
name|tend
operator|>=
name|object
operator|->
name|size
expr_stmt|;
name|res
operator|=
name|TRUE
expr_stmt|;
name|rescan
label|:
name|curgeneration
operator|=
name|object
operator|->
name|generation
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|tstart
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|np
control|)
block|{
name|pi
operator|=
name|p
operator|->
name|pindex
expr_stmt|;
if|if
condition|(
name|pi
operator|>=
name|tend
condition|)
break|break;
name|np
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|valid
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|p
argument_list|,
literal|"vpcwai"
argument_list|)
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|generation
operator|!=
name|curgeneration
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|OBJPC_SYNC
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|rescan
goto|;
else|else
name|clearobjflags
operator|=
name|FALSE
expr_stmt|;
block|}
name|np
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|pi
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|vm_object_page_remove_write
argument_list|(
name|p
argument_list|,
name|flags
argument_list|,
operator|&
name|clearobjflags
argument_list|)
condition|)
continue|continue;
name|n
operator|=
name|vm_object_page_collect_flush
argument_list|(
name|object
argument_list|,
name|p
argument_list|,
name|pagerflags
argument_list|,
name|flags
argument_list|,
operator|&
name|clearobjflags
argument_list|,
operator|&
name|eio
argument_list|)
expr_stmt|;
if|if
condition|(
name|eio
condition|)
block|{
name|res
operator|=
name|FALSE
expr_stmt|;
name|clearobjflags
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|->
name|generation
operator|!=
name|curgeneration
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|OBJPC_SYNC
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|rescan
goto|;
else|else
name|clearobjflags
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 		 * If the VOP_PUTPAGES() did a truncated write, so 		 * that even the first page of the run is not fully 		 * written, vm_pageout_flush() returns 0 as the run 		 * length.  Since the condition that caused truncated 		 * write may be permanent, e.g. exhausted free space, 		 * accepting n == 0 would cause an infinite loop. 		 * 		 * Forwarding the iterator leaves the unwritten page 		 * behind, but there is not much we can do there if 		 * filesystem refuses to write it. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
name|clearobjflags
operator|=
name|FALSE
expr_stmt|;
block|}
name|np
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|pi
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|VOP_FSYNC(vp, (pagerflags& VM_PAGER_PUT_SYNC) ? MNT_WAIT : 0);
endif|#
directive|endif
if|if
condition|(
name|clearobjflags
condition|)
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_MIGHTBEDIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vm_object_page_collect_flush
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
name|p
parameter_list|,
name|int
name|pagerflags
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
modifier|*
name|clearobjflags
parameter_list|,
name|boolean_t
modifier|*
name|eio
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|vm_pageout_page_count
index|]
decl_stmt|,
name|p_first
decl_stmt|,
name|tp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|mreq
decl_stmt|,
name|runlen
decl_stmt|;
name|vm_page_lock_assert
argument_list|(
name|p
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|mreq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|p
init|;
name|count
operator|<
name|vm_pageout_page_count
condition|;
name|count
operator|++
control|)
block|{
name|tp
operator|=
name|vm_page_next
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
name|vm_page_busied
argument_list|(
name|tp
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|vm_object_page_remove_write
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|,
name|clearobjflags
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
name|p_first
operator|=
name|p
init|;
name|count
operator|<
name|vm_pageout_page_count
condition|;
name|count
operator|++
control|)
block|{
name|tp
operator|=
name|vm_page_prev
argument_list|(
name|p_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
name|vm_page_busied
argument_list|(
name|tp
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|vm_object_page_remove_write
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|,
name|clearobjflags
argument_list|)
condition|)
break|break;
name|p_first
operator|=
name|tp
expr_stmt|;
name|mreq
operator|++
expr_stmt|;
block|}
for|for
control|(
name|tp
operator|=
name|p_first
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|tp
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp
argument_list|,
name|listq
argument_list|)
operator|,
name|i
operator|++
control|)
name|ma
index|[
name|i
index|]
operator|=
name|tp
expr_stmt|;
name|vm_pageout_flush
argument_list|(
name|ma
argument_list|,
name|count
argument_list|,
name|pagerflags
argument_list|,
name|mreq
argument_list|,
operator|&
name|runlen
argument_list|,
name|eio
argument_list|)
expr_stmt|;
return|return
operator|(
name|runlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that there is absolutely no sense in writing out  * anonymous objects, so we track down the vnode object  * to write out.  * We invalidate (remove) all pages from the address space  * for semantic correctness.  *  * If the backing object is a device object with unmanaged pages, then any  * mappings to the specified range of pages must be removed before this  * function is called.  *  * Note: certain anonymous maps, such as MAP_NOSYNC maps,  * may start out with a NULL object.  */
end_comment

begin_function
name|boolean_t
name|vm_object_sync
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|boolean_t
name|syncio
parameter_list|,
name|boolean_t
name|invalidate
parameter_list|)
block|{
name|vm_object_t
name|backing_object
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|fsync_after
decl_stmt|;
name|boolean_t
name|res
decl_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|res
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|backing_object
operator|=
name|object
operator|->
name|backing_object
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|object
operator|->
name|backing_object_offset
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|backing_object
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|size
operator|<
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|size
argument_list|)
condition|)
name|size
operator|=
name|IDX_TO_OFF
argument_list|(
name|object
operator|->
name|size
argument_list|)
operator|-
name|offset
expr_stmt|;
block|}
comment|/* 	 * Flush pages if writing is allowed, invalidate them 	 * if invalidation requested.  Pages undergoing I/O 	 * will be ignored by vm_object_page_remove(). 	 * 	 * We cannot lock the vnode and then wait for paging 	 * to complete without deadlocking against vm_fault. 	 * Instead we simply call vm_object_page_remove() and 	 * allow it to block internally on a page-by-page 	 * basis when it encounters pages undergoing async 	 * I/O. 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_MIGHTBEDIRTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|vp
operator|=
name|object
operator|->
name|handle
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|syncio
operator|&&
operator|!
name|invalidate
operator|&&
name|offset
operator|==
literal|0
operator|&&
name|atop
argument_list|(
name|size
argument_list|)
operator|==
name|object
operator|->
name|size
condition|)
block|{
comment|/* 			 * If syncing the whole mapping of the file, 			 * it is faster to schedule all the writes in 			 * async mode, also allowing the clustering, 			 * and then wait for i/o to complete. 			 */
name|flags
operator|=
literal|0
expr_stmt|;
name|fsync_after
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
operator|(
name|syncio
operator|||
name|invalidate
operator|)
condition|?
name|OBJPC_SYNC
else|:
literal|0
expr_stmt|;
name|flags
operator||=
name|invalidate
condition|?
operator|(
name|OBJPC_SYNC
operator||
name|OBJPC_INVAL
operator|)
else|:
literal|0
expr_stmt|;
name|fsync_after
operator|=
name|FALSE
expr_stmt|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|res
operator|=
name|vm_object_page_clean
argument_list|(
name|object
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsync_after
condition|)
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|res
operator|=
name|FALSE
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|)
operator|&&
name|invalidate
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
condition|)
comment|/* 			 * The option OBJPR_NOTMAPPED must be passed here 			 * because vm_object_page_remove() cannot remove 			 * unmanaged mappings. 			 */
name|flags
operator|=
name|OBJPR_NOTMAPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|old_msync
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|OBJPR_CLEANONLY
expr_stmt|;
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|size
operator|+
name|PAGE_MASK
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_madvise:  *  *	Implements the madvise function at the object/page level.  *  *	MADV_WILLNEED	(any object)  *  *	    Activate the specified pages if they are resident.  *  *	MADV_DONTNEED	(any object)  *  *	    Deactivate the specified pages if they are resident.  *  *	MADV_FREE	(OBJT_DEFAULT/OBJT_SWAP objects,  *			 OBJ_ONEMAPPING only)  *  *	    Deactivate and clean the specified pages if they are  *	    resident.  This permits the process to reuse the pages  *	    without faulting or the kernel to reclaim the pages  *	    without I/O.  */
end_comment

begin_function
name|void
name|vm_object_madvise
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_pindex_t
name|end
parameter_list|,
name|int
name|advise
parameter_list|)
block|{
name|vm_pindex_t
name|tpindex
decl_stmt|;
name|vm_object_t
name|backing_object
decl_stmt|,
name|tobject
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * Locate and adjust resident pages 	 */
for|for
control|(
init|;
name|pindex
operator|<
name|end
condition|;
name|pindex
operator|+=
literal|1
control|)
block|{
name|relookup
label|:
name|tobject
operator|=
name|object
expr_stmt|;
name|tpindex
operator|=
name|pindex
expr_stmt|;
name|shadowlookup
label|:
comment|/* 		 * MADV_FREE only operates on OBJT_DEFAULT or OBJT_SWAP pages 		 * and those pages must be OBJ_ONEMAPPING. 		 */
if|if
condition|(
name|advise
operator|==
name|MADV_FREE
condition|)
block|{
if|if
condition|(
operator|(
name|tobject
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|tobject
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|)
operator|||
operator|(
name|tobject
operator|->
name|flags
operator|&
name|OBJ_ONEMAPPING
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|unlock_tobject
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tobject
operator|->
name|flags
operator|&
name|OBJ_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unlock_tobject
goto|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|tobject
argument_list|,
name|tpindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There may be swap even if there is no backing page 			 */
if|if
condition|(
name|advise
operator|==
name|MADV_FREE
operator|&&
name|tobject
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|tobject
argument_list|,
name|tpindex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * next object 			 */
name|backing_object
operator|=
name|tobject
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|backing_object
operator|==
name|NULL
condition|)
goto|goto
name|unlock_tobject
goto|;
name|VM_OBJECT_WLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|tpindex
operator|+=
name|OFF_TO_IDX
argument_list|(
name|tobject
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tobject
operator|!=
name|object
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|tobject
argument_list|)
expr_stmt|;
name|tobject
operator|=
name|backing_object
expr_stmt|;
goto|goto
name|shadowlookup
goto|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
goto|goto
name|unlock_tobject
goto|;
comment|/* 		 * If the page is not in a normal state, skip it. 		 */
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|hold_count
operator|!=
literal|0
operator|||
name|m
operator|->
name|wire_count
operator|!=
literal|0
condition|)
block|{
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|unlock_tobject
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_madvise: page %p is fictitious"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_madvise: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_busied
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|advise
operator|==
name|MADV_WILLNEED
condition|)
block|{
comment|/* 				 * Reference the page before unlocking and 				 * sleeping so that the page daemon is less 				 * likely to reclaim it.  				 */
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|!=
name|tobject
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|tobject
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|m
argument_list|,
literal|"madvpo"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|relookup
goto|;
block|}
if|if
condition|(
name|advise
operator|==
name|MADV_WILLNEED
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_page_advise
argument_list|(
name|m
argument_list|,
name|advise
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|advise
operator|==
name|MADV_FREE
operator|&&
name|tobject
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|tobject
argument_list|,
name|tpindex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unlock_tobject
label|:
if|if
condition|(
name|tobject
operator|!=
name|object
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|tobject
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_shadow:  *  *	Create a new object which is backed by the  *	specified existing object range.  The source  *	object reference is deallocated.  *  *	The new object and offset into that object  *	are returned in the source parameters.  */
end_comment

begin_function
name|void
name|vm_object_shadow
parameter_list|(
name|vm_object_t
modifier|*
name|object
parameter_list|,
comment|/* IN/OUT */
name|vm_ooffset_t
modifier|*
name|offset
parameter_list|,
comment|/* IN/OUT */
name|vm_size_t
name|length
parameter_list|)
block|{
name|vm_object_t
name|source
decl_stmt|;
name|vm_object_t
name|result
decl_stmt|;
name|source
operator|=
operator|*
name|object
expr_stmt|;
comment|/* 	 * Don't create the new object if the old object isn't shared. 	 */
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|ref_count
operator|==
literal|1
operator|&&
name|source
operator|->
name|handle
operator|==
name|NULL
operator|&&
operator|(
name|source
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|source
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a new object with the given length. 	 */
name|result
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|atop
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The new object shadows the source object, adding a reference to it. 	 * Our caller changes his reference to point to the new object, 	 * removing a reference to the source object.  Net result: no change 	 * of reference count. 	 * 	 * Try to optimize the result object's page color when shadowing 	 * in order to maintain page coloring consistency in the combined  	 * shadowed object. 	 */
name|result
operator|->
name|backing_object
operator|=
name|source
expr_stmt|;
comment|/* 	 * Store the offset into the source object, and fix up the offset into 	 * the new object. 	 */
name|result
operator|->
name|backing_object_offset
operator|=
operator|*
name|offset
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|source
operator|->
name|shadow_head
argument_list|,
name|result
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|source
operator|->
name|shadow_count
operator|++
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
name|result
operator|->
name|flags
operator||=
name|source
operator|->
name|flags
operator|&
name|OBJ_COLORED
expr_stmt|;
name|result
operator|->
name|pg_color
operator|=
operator|(
name|source
operator|->
name|pg_color
operator|+
name|OFF_TO_IDX
argument_list|(
operator|*
name|offset
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|VM_NFREEORDER
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|VM_OBJECT_WUNLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the new things 	 */
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|object
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_split:  *  * Split the pages in a map entry into a new object.  This affords  * easier removal of unused pages, and keeps object inheritance from  * being a negative impact on memory usage.  */
end_comment

begin_function
name|void
name|vm_object_split
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|m_next
decl_stmt|;
name|vm_object_t
name|orig_object
decl_stmt|,
name|new_object
decl_stmt|,
name|source
decl_stmt|;
name|vm_pindex_t
name|idx
decl_stmt|,
name|offidxstart
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|orig_object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|orig_object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|orig_object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
if|if
condition|(
name|orig_object
operator|->
name|ref_count
operator|<=
literal|1
condition|)
return|return;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|offidxstart
operator|=
name|OFF_TO_IDX
argument_list|(
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
name|size
operator|=
name|atop
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * If swap_pager_copy() is later called, it will convert new_object 	 * into a swap object. 	 */
name|new_object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, the new object is still private, so the order in 	 * which the original and new objects are locked does not matter. 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|source
operator|=
name|orig_object
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|source
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|source
operator|->
name|shadow_head
argument_list|,
name|new_object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|source
operator|->
name|shadow_count
operator|++
expr_stmt|;
name|vm_object_reference_locked
argument_list|(
name|source
argument_list|)
expr_stmt|;
comment|/* for new_object */
name|vm_object_clear_flag
argument_list|(
name|source
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|new_object
operator|->
name|backing_object_offset
operator|=
name|orig_object
operator|->
name|backing_object_offset
operator|+
name|entry
operator|->
name|offset
expr_stmt|;
name|new_object
operator|->
name|backing_object
operator|=
name|source
expr_stmt|;
block|}
if|if
condition|(
name|orig_object
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
name|new_object
operator|->
name|cred
operator|=
name|orig_object
operator|->
name|cred
expr_stmt|;
name|crhold
argument_list|(
name|orig_object
operator|->
name|cred
argument_list|)
expr_stmt|;
name|new_object
operator|->
name|charge
operator|=
name|ptoa
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|orig_object
operator|->
name|charge
operator|>=
name|ptoa
argument_list|(
name|size
argument_list|)
argument_list|,
operator|(
literal|"orig_object->charge< 0"
operator|)
argument_list|)
expr_stmt|;
name|orig_object
operator|->
name|charge
operator|-=
name|ptoa
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|retry
label|:
name|m
operator|=
name|vm_page_find_least
argument_list|(
name|orig_object
argument_list|,
name|offidxstart
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|idx
operator|=
name|m
operator|->
name|pindex
operator|-
name|offidxstart
operator|)
operator|<
name|size
condition|;
name|m
operator|=
name|m_next
control|)
block|{
name|m_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 		 * We must wait for pending I/O to complete before we can 		 * rename the page. 		 * 		 * We do not have to VM_PROT_NONE the page as mappings should 		 * not be changed by this operation. 		 */
if|if
condition|(
name|vm_page_busied
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|m
argument_list|,
literal|"spltwt"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* vm_page_rename() will dirty the page. */
if|if
condition|(
name|vm_page_rename
argument_list|(
name|m
argument_list|,
name|new_object
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
comment|/* 		 * If some of the reservation's allocated pages remain with 		 * the original object, then transferring the reservation to 		 * the new object is neither particularly beneficial nor 		 * particularly harmful as compared to leaving the reservation 		 * with the original object.  If, however, all of the 		 * reservation's allocated pages are transferred to the new 		 * object, then transferring the reservation is typically 		 * beneficial.  Determining which of these two cases applies 		 * would be more costly than unconditionally renaming the 		 * reservation. 		 */
name|vm_reserv_rename
argument_list|(
name|m
argument_list|,
name|new_object
argument_list|,
name|orig_object
argument_list|,
name|offidxstart
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|orig_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|vm_page_xbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|orig_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
comment|/* 		 * swap_pager_copy() can sleep, in which case the orig_object's 		 * and new_object's locks are released and reacquired.  		 */
name|swap_pager_copy
argument_list|(
name|orig_object
argument_list|,
name|new_object
argument_list|,
name|offidxstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&new_object->memq
argument_list|,
argument|listq
argument_list|)
name|vm_page_xunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|new_object
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0LL
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|orig_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|new_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OBSC_COLLAPSE_NOWAIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|OBSC_COLLAPSE_WAIT
value|0x0004
end_define

begin_function
specifier|static
name|vm_page_t
name|vm_object_collapse_scan_wait
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
name|p
parameter_list|,
name|vm_page_t
name|next
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|vm_object_t
name|backing_object
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|backing_object
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|==
name|NULL
operator|||
name|vm_page_busied
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"unbusy page %p"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|object
operator|==
name|object
operator|||
name|p
operator|->
name|object
operator|==
name|backing_object
argument_list|,
operator|(
literal|"invalid ownership %p %p %p"
operator|,
name|p
operator|,
name|object
operator|,
name|backing_object
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
name|OBSC_COLLAPSE_NOWAIT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|next
operator|)
return|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|VM_WAIT
expr_stmt|;
else|else
name|vm_page_busy_sleep
argument_list|(
name|p
argument_list|,
literal|"vmocol"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|backing_object
operator|->
name|memq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|vm_object_scan_all_shadowed
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|vm_object_t
name|backing_object
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|pp
decl_stmt|;
name|vm_pindex_t
name|backing_offset_index
decl_stmt|,
name|new_pindex
decl_stmt|,
name|pi
decl_stmt|,
name|ps
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
operator|->
name|backing_object
argument_list|)
expr_stmt|;
name|backing_object
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
comment|/* 	 * Initial conditions: 	 * 	 * We do not want to have to test for the existence of swap 	 * pages in the backing object.  XXX but with the new swapper this 	 * would be pretty easy to do. 	 */
if|if
condition|(
name|backing_object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|backing_object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|pi
operator|=
name|backing_offset_index
operator|=
name|OFF_TO_IDX
argument_list|(
name|object
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
name|p
operator|=
name|vm_page_find_least
argument_list|(
name|backing_object
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|ps
operator|=
name|swap_pager_find_least
argument_list|(
name|backing_object
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* 	 * Only check pages inside the parent object's range and 	 * inside the parent object's mapping of the backing object. 	 */
for|for
control|(
init|;
condition|;
name|pi
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|pindex
operator|<
name|pi
condition|)
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|<
name|pi
condition|)
name|ps
operator|=
name|swap_pager_find_least
argument_list|(
name|backing_object
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|ps
operator|>=
name|backing_object
operator|->
name|size
condition|)
break|break;
elseif|else
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|pi
operator|=
name|ps
expr_stmt|;
else|else
name|pi
operator|=
name|MIN
argument_list|(
name|p
operator|->
name|pindex
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|new_pindex
operator|=
name|pi
operator|-
name|backing_offset_index
expr_stmt|;
if|if
condition|(
name|new_pindex
operator|>=
name|object
operator|->
name|size
condition|)
break|break;
comment|/* 		 * See if the parent has the page or if the parent's object 		 * pager has the page.  If the parent has the page but the page 		 * is not valid, the parent's object pager must have the page. 		 * 		 * If this fails, the parent does not completely shadow the 		 * object and we might as well give up now. 		 */
name|pp
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|new_pindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|==
name|NULL
operator|||
name|pp
operator|->
name|valid
operator|==
literal|0
operator|)
operator|&&
operator|!
name|vm_pager_has_page
argument_list|(
name|object
argument_list|,
name|new_pindex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|vm_object_collapse_scan
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|vm_object_t
name|backing_object
decl_stmt|;
name|vm_page_t
name|next
decl_stmt|,
name|p
decl_stmt|,
name|pp
decl_stmt|;
name|vm_pindex_t
name|backing_offset_index
decl_stmt|,
name|new_pindex
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
operator|->
name|backing_object
argument_list|)
expr_stmt|;
name|backing_object
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
name|backing_offset_index
operator|=
name|OFF_TO_IDX
argument_list|(
name|object
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Initial conditions 	 */
if|if
condition|(
operator|(
name|op
operator|&
name|OBSC_COLLAPSE_WAIT
operator|)
operator|!=
literal|0
condition|)
name|vm_object_set_flag
argument_list|(
name|backing_object
argument_list|,
name|OBJ_DEAD
argument_list|)
expr_stmt|;
comment|/* 	 * Our scan 	 */
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|backing_object
operator|->
name|memq
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|new_pindex
operator|=
name|p
operator|->
name|pindex
operator|-
name|backing_offset_index
expr_stmt|;
comment|/* 		 * Check for busy page 		 */
if|if
condition|(
name|vm_page_busied
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|next
operator|=
name|vm_object_collapse_scan_wait
argument_list|(
name|object
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
name|op
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|p
operator|->
name|object
operator|==
name|backing_object
argument_list|,
operator|(
literal|"vm_object_collapse_scan: object mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pindex
operator|<
name|backing_offset_index
operator|||
name|new_pindex
operator|>=
name|object
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|backing_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|backing_object
argument_list|,
name|p
operator|->
name|pindex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Page is out of the parent object's range, we can 			 * simply destroy it. 			 */
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|pmap_page_is_mapped
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"freeing mapped page %p"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|wire_count
operator|==
literal|0
condition|)
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|vm_page_remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pp
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|new_pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|vm_page_busied
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* 			 * The page in the parent is busy and possibly not 			 * (yet) valid.  Until its state is finalized by the 			 * busy bit owner, we can't tell whether it shadows the 			 * original page.  Therefore, we must either skip it 			 * and the original (backing_object) page or wait for 			 * its state to be finalized. 			 * 			 * This is due to a race with vm_fault() where we must 			 * unbusy the original (backing_obj) page before we can 			 * (re)lock the parent.  Hence we can get here. 			 */
name|next
operator|=
name|vm_object_collapse_scan_wait
argument_list|(
name|object
argument_list|,
name|pp
argument_list|,
name|next
argument_list|,
name|op
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|pp
operator|==
name|NULL
operator|||
name|pp
operator|->
name|valid
operator|!=
literal|0
argument_list|,
operator|(
literal|"unbusy invalid page %p"
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|||
name|vm_pager_has_page
argument_list|(
name|object
argument_list|,
name|new_pindex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* 			 * The page already exists in the parent OR swap exists 			 * for this location in the parent.  Leave the parent's 			 * page alone.  Destroy the original page from the 			 * backing object. 			 */
if|if
condition|(
name|backing_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|backing_object
argument_list|,
name|p
operator|->
name|pindex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|pmap_page_is_mapped
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"freeing mapped page %p"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|wire_count
operator|==
literal|0
condition|)
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|vm_page_remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Page does not exist in parent, rename the page from the 		 * backing object to the main object. 		 * 		 * If the page was mapped to a process, it can remain mapped 		 * through the rename.  vm_page_rename() will dirty the page. 		 */
if|if
condition|(
name|vm_page_rename
argument_list|(
name|p
argument_list|,
name|object
argument_list|,
name|new_pindex
argument_list|)
condition|)
block|{
name|next
operator|=
name|vm_object_collapse_scan_wait
argument_list|(
name|object
argument_list|,
name|NULL
argument_list|,
name|next
argument_list|,
name|op
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Use the old pindex to free the right page. */
if|if
condition|(
name|backing_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|backing_object
argument_list|,
name|new_pindex
operator|+
name|backing_offset_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
comment|/* 		 * Rename the reservation. 		 */
name|vm_reserv_rename
argument_list|(
name|p
argument_list|,
name|object
argument_list|,
name|backing_object
argument_list|,
name|backing_offset_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this version of collapse allows the operation to occur earlier and  * when paging_in_progress is true for an object...  This is not a complete  * operation, but should plug 99.9% of the rest of the leaks.  */
end_comment

begin_function
specifier|static
name|void
name|vm_object_qcollapse
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|vm_object_t
name|backing_object
init|=
name|object
operator|->
name|backing_object
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_object
operator|->
name|ref_count
operator|!=
literal|1
condition|)
return|return;
name|vm_object_collapse_scan
argument_list|(
name|object
argument_list|,
name|OBSC_COLLAPSE_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_collapse:  *  *	Collapse an object with the object backing it.  *	Pages in the backing object are moved into the  *	parent, and the backing object is deallocated.  */
end_comment

begin_function
name|void
name|vm_object_collapse
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|vm_object_t
name|backing_object
decl_stmt|,
name|new_backing_object
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* 		 * Verify that the conditions are right for collapse: 		 * 		 * The object exists and the backing object exists. 		 */
if|if
condition|(
operator|(
name|backing_object
operator|=
name|object
operator|->
name|backing_object
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * we check the backing object first, because it is most likely 		 * not collapsable. 		 */
name|VM_OBJECT_WLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_object
operator|->
name|handle
operator|!=
name|NULL
operator|||
operator|(
name|backing_object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|backing_object
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|)
operator|||
operator|(
name|backing_object
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|||
name|object
operator|->
name|handle
operator|!=
name|NULL
operator|||
operator|(
name|object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|)
operator|||
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|object
operator|->
name|paging_in_progress
operator|!=
literal|0
operator|||
name|backing_object
operator|->
name|paging_in_progress
operator|!=
literal|0
condition|)
block|{
name|vm_object_qcollapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We know that we can either collapse the backing object (if 		 * the parent is the only reference to it) or (perhaps) have 		 * the parent bypass the object if the parent happens to shadow 		 * all the resident pages in the entire backing object. 		 * 		 * This is ignoring pager-backed pages such as swap pages. 		 * vm_object_collapse_scan fails the shadowing test in this 		 * case. 		 */
if|if
condition|(
name|backing_object
operator|->
name|ref_count
operator|==
literal|1
condition|)
block|{
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|backing_object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * If there is exactly one reference to the backing 			 * object, we can collapse it into the parent. 			 */
name|vm_object_collapse_scan
argument_list|(
name|object
argument_list|,
name|OBSC_COLLAPSE_WAIT
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_NRESERVLEVEL
operator|>
literal|0
comment|/* 			 * Break any reservations from backing_object. 			 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|backing_object
operator|->
name|rvq
argument_list|)
argument_list|)
condition|)
name|vm_reserv_break_all
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Move the pager from backing_object to object. 			 */
if|if
condition|(
name|backing_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
comment|/* 				 * swap_pager_copy() can sleep, in which case 				 * the backing_object's and object's locks are 				 * released and reacquired. 				 * Since swap_pager_copy() is being asked to 				 * destroy the source, it will change the 				 * backing_object's type to OBJT_DEFAULT. 				 */
name|swap_pager_copy
argument_list|(
name|backing_object
argument_list|,
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|object
operator|->
name|backing_object_offset
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Object now shadows whatever backing_object did. 			 * Note that the reference to  			 * backing_object->backing_object moves from within  			 * backing_object to within object. 			 */
name|LIST_REMOVE
argument_list|(
name|object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|backing_object
operator|->
name|shadow_count
operator|--
expr_stmt|;
if|if
condition|(
name|backing_object
operator|->
name|backing_object
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|backing_object
operator|->
name|backing_object
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|backing_object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|backing_object
operator|->
name|backing_object
operator|->
name|shadow_head
argument_list|,
name|object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
comment|/* 				 * The shadow_count has not changed. 				 */
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
operator|->
name|backing_object
argument_list|)
expr_stmt|;
block|}
name|object
operator|->
name|backing_object
operator|=
name|backing_object
operator|->
name|backing_object
expr_stmt|;
name|object
operator|->
name|backing_object_offset
operator|+=
name|backing_object
operator|->
name|backing_object_offset
expr_stmt|;
comment|/* 			 * Discard backing_object. 			 * 			 * Since the backing object has no pages, no pager left, 			 * and no object references within it, all that is 			 * necessary is to dispose of it. 			 */
name|KASSERT
argument_list|(
name|backing_object
operator|->
name|ref_count
operator|==
literal|1
argument_list|,
operator|(
literal|"backing_object %p was somehow re-referenced during collapse!"
operator|,
name|backing_object
operator|)
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|backing_object
operator|->
name|type
operator|=
name|OBJT_DEAD
expr_stmt|;
name|backing_object
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|vm_object_destroy
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object_collapses
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we do not entirely shadow the backing object, 			 * there is nothing we can do so we give up. 			 */
if|if
condition|(
name|object
operator|->
name|resident_page_count
operator|!=
name|object
operator|->
name|size
operator|&&
operator|!
name|vm_object_scan_all_shadowed
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Make the parent shadow the next object in the 			 * chain.  Deallocating backing_object will not remove 			 * it, since its reference count is at least 2. 			 */
name|LIST_REMOVE
argument_list|(
name|object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|backing_object
operator|->
name|shadow_count
operator|--
expr_stmt|;
name|new_backing_object
operator|=
name|backing_object
operator|->
name|backing_object
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|backing_object
operator|=
name|new_backing_object
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|new_backing_object
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_backing_object
operator|->
name|shadow_head
argument_list|,
name|object
argument_list|,
name|shadow_list
argument_list|)
expr_stmt|;
name|new_backing_object
operator|->
name|shadow_count
operator|++
expr_stmt|;
name|vm_object_reference_locked
argument_list|(
name|new_backing_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|new_backing_object
argument_list|)
expr_stmt|;
name|object
operator|->
name|backing_object_offset
operator|+=
name|backing_object
operator|->
name|backing_object_offset
expr_stmt|;
block|}
comment|/* 			 * Drop the reference count on backing_object. Since 			 * its ref_count was at least 2, it will not vanish. 			 */
name|backing_object
operator|->
name|ref_count
operator|--
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|object_bypasses
operator|++
expr_stmt|;
block|}
comment|/* 		 * Try again with this object's new backing object. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_object_page_remove:  *  *	For the given object, either frees or invalidates each of the  *	specified pages.  In general, a page is freed.  However, if a page is  *	wired for any reason other than the existence of a managed, wired  *	mapping, then it may be invalidated but not removed from the object.  *	Pages are specified by the given range ["start", "end") and the option  *	OBJPR_CLEANONLY.  As a special case, if "end" is zero, then the range  *	extends from "start" to the end of the object.  If the option  *	OBJPR_CLEANONLY is specified, then only the non-dirty pages within the  *	specified range are affected.  If the option OBJPR_NOTMAPPED is  *	specified, then the pages within the specified range must have no  *	mappings.  Otherwise, if this option is not specified, any mappings to  *	the specified pages are removed before the pages are freed or  *	invalidated.  *  *	In general, this operation should only be performed on objects that  *	contain managed pages.  There are, however, two exceptions.  First, it  *	is performed on the kernel and kmem objects by vm_map_entry_delete().  *	Second, it is used by msync(..., MS_INVALIDATE) to invalidate device-  *	backed pages.  In both of these cases, the option OBJPR_CLEANONLY must  *	not be specified and the option OBJPR_NOTMAPPED must be specified.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_object_page_remove
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_pindex_t
name|end
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|vm_page_t
name|p
decl_stmt|,
name|next
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_UNMANAGED
operator|)
operator|==
literal|0
operator|||
operator|(
name|options
operator|&
operator|(
name|OBJPR_CLEANONLY
operator||
name|OBJPR_NOTMAPPED
operator|)
operator|)
operator|==
name|OBJPR_NOTMAPPED
argument_list|,
operator|(
literal|"vm_object_page_remove: illegal options for object %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|resident_page_count
operator|==
literal|0
condition|)
return|return;
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|again
label|:
name|p
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Here, the variable "p" is either (1) the page with the least pindex 	 * greater than or equal to the parameter "start" or (2) NULL.  	 */
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|pindex
operator|<
name|end
operator|||
name|end
operator|==
literal|0
operator|)
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 		 * If the page is wired for any reason besides the existence 		 * of managed, wired mappings, then it cannot be freed.  For 		 * example, fictitious pages, which represent device memory, 		 * are inherently wired and cannot be freed.  They can, 		 * however, be invalidated if the option OBJPR_CLEANONLY is 		 * not specified. 		 */
name|vm_page_lock
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_xbusied
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|p
argument_list|,
literal|"vmopax"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|wire_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|OBJPR_NOTMAPPED
operator|)
operator|==
literal|0
condition|)
name|pmap_remove_all
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|OBJPR_CLEANONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|vm_page_busied
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|p
argument_list|,
literal|"vmopar"
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|p
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_page_remove: page %p is fictitious"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|OBJPR_CLEANONLY
operator|)
operator|!=
literal|0
operator|&&
name|p
operator|->
name|valid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|OBJPR_NOTMAPPED
operator|)
operator|==
literal|0
condition|)
name|pmap_remove_write
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dirty
condition|)
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|OBJPR_NOTMAPPED
operator|)
operator|==
literal|0
condition|)
name|pmap_remove_all
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|next
label|:
name|vm_page_unlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_page_noreuse:  *  *	For the given object, attempt to move the specified pages to  *	the head of the inactive queue.  This bypasses regular LRU  *	operation and allows the pages to be reused quickly under memory  *	pressure.  If a page is wired for any reason, then it will not  *	be queued.  Pages are specified by the range ["start", "end").  *	As a special case, if "end" is zero, then the range extends from  *	"start" to the end of the object.  *  *	This operation should only be performed on objects that  *	contain non-fictitious, managed pages.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_object_page_noreuse
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_pindex_t
name|end
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|,
modifier|*
name|new_mtx
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|,
name|next
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|object
operator|->
name|flags
operator|&
operator|(
name|OBJ_FICTITIOUS
operator||
name|OBJ_UNMANAGED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_page_noreuse: illegal object %p"
operator|,
name|object
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|resident_page_count
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Here, the variable "p" is either (1) the page with the least pindex 	 * greater than or equal to the parameter "start" or (2) NULL.  	 */
name|mtx
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|pindex
operator|<
name|end
operator|||
name|end
operator|==
literal|0
operator|)
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 		 * Avoid releasing and reacquiring the same page lock. 		 */
name|new_mtx
operator|=
name|vm_page_lockptr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|new_mtx
condition|)
block|{
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|mtx
operator|=
name|new_mtx
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
name|vm_page_deactivate_noreuse
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Populate the specified range of the object with valid pages.  Returns  *	TRUE if the range is successfully populated and FALSE otherwise.  *  *	Note: This function should be optimized to pass a larger array of  *	pages to vm_pager_get_pages() before it is applied to a non-  *	OBJT_DEVICE object.  *  *	The object must be locked.  */
end_comment

begin_function
name|boolean_t
name|vm_object_populate
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_pindex_t
name|end
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|pindex
operator|=
name|start
init|;
name|pindex
operator|<
name|end
condition|;
name|pindex
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|object
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
block|{
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Keep "m" busy because a subsequent iteration may unlock 		 * the object. 		 */
block|}
if|if
condition|(
name|pindex
operator|>
name|start
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|pindex
operator|<
name|pindex
condition|)
block|{
name|vm_page_xunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pindex
operator|==
name|end
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	vm_object_coalesce  *	Function:	Coalesces two objects backing up adjoining  *			regions of memory into a single object.  *  *	returns TRUE if objects were combined.  *  *	NOTE:	Only works at the moment if the second object is NULL -  *		if it's not, which object do we lock first?  *  *	Parameters:  *		prev_object	First object to coalesce  *		prev_offset	Offset into prev_object  *		prev_size	Size of reference to prev_object  *		next_size	Size of reference to the second object  *		reserved	Indicator that extension region has  *				swap accounted for  *  *	Conditions:  *	The object must *not* be locked.  */
end_comment

begin_function
name|boolean_t
name|vm_object_coalesce
parameter_list|(
name|vm_object_t
name|prev_object
parameter_list|,
name|vm_ooffset_t
name|prev_offset
parameter_list|,
name|vm_size_t
name|prev_size
parameter_list|,
name|vm_size_t
name|next_size
parameter_list|,
name|boolean_t
name|reserved
parameter_list|)
block|{
name|vm_pindex_t
name|next_pindex
decl_stmt|;
if|if
condition|(
name|prev_object
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|VM_OBJECT_WLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prev_object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|prev_object
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|)
operator|||
operator|(
name|prev_object
operator|->
name|flags
operator|&
name|OBJ_TMPFS_NODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Try to collapse the object first 	 */
name|vm_object_collapse
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
comment|/* 	 * Can't coalesce if: . more than one reference . paged out . shadows 	 * another object . has a copy elsewhere (any of which mean that the 	 * pages not mapped to prev_entry may be in use anyway) 	 */
if|if
condition|(
name|prev_object
operator|->
name|backing_object
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|prev_size
operator|>>=
name|PAGE_SHIFT
expr_stmt|;
name|next_size
operator|>>=
name|PAGE_SHIFT
expr_stmt|;
name|next_pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|prev_offset
argument_list|)
operator|+
name|prev_size
expr_stmt|;
if|if
condition|(
operator|(
name|prev_object
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|prev_object
operator|->
name|size
operator|!=
name|next_pindex
operator|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Account for the charge. 	 */
if|if
condition|(
name|prev_object
operator|->
name|cred
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If prev_object was charged, then this mapping, 		 * although not charged now, may become writable 		 * later. Non-NULL cred in the object would prevent 		 * swap reservation during enabling of the write 		 * access, so reserve swap now. Failed reservation 		 * cause allocation of the separate object for the map 		 * entry, and swap reservation for this entry is 		 * managed in appropriate time. 		 */
if|if
condition|(
operator|!
name|reserved
operator|&&
operator|!
name|swap_reserve_by_cred
argument_list|(
name|ptoa
argument_list|(
name|next_size
argument_list|)
argument_list|,
name|prev_object
operator|->
name|cred
argument_list|)
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|prev_object
operator|->
name|charge
operator|+=
name|ptoa
argument_list|(
name|next_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove any pages that may still be in the object from a previous 	 * deallocation. 	 */
if|if
condition|(
name|next_pindex
operator|<
name|prev_object
operator|->
name|size
condition|)
block|{
name|vm_object_page_remove
argument_list|(
name|prev_object
argument_list|,
name|next_pindex
argument_list|,
name|next_pindex
operator|+
name|next_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_object
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
name|swap_pager_freespace
argument_list|(
name|prev_object
argument_list|,
name|next_pindex
argument_list|,
name|next_size
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (prev_object->cred != NULL) { 			KASSERT(prev_object->charge>= 			    ptoa(prev_object->size - next_pindex), 			    ("object %p overcharged 1 %jx %jx", prev_object, 				(uintmax_t)next_pindex, (uintmax_t)next_size)); 			prev_object->charge -= ptoa(prev_object->size - 			    next_pindex); 		}
endif|#
directive|endif
block|}
comment|/* 	 * Extend the object if necessary. 	 */
if|if
condition|(
name|next_pindex
operator|+
name|next_size
operator|>
name|prev_object
operator|->
name|size
condition|)
name|prev_object
operator|->
name|size
operator|=
name|next_pindex
operator|+
name|next_size
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|prev_object
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_object_set_writeable_dirty
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
condition|)
block|{
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS_NODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
argument_list|,
operator|(
literal|"non-swap tmpfs"
operator|)
argument_list|)
expr_stmt|;
name|vm_object_set_flag
argument_list|(
name|object
argument_list|,
name|OBJ_TMPFS_DIRTY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|object
operator|->
name|generation
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_MIGHTBEDIRTY
operator|)
operator|!=
literal|0
condition|)
return|return;
name|vm_object_set_flag
argument_list|(
name|object
argument_list|,
name|OBJ_MIGHTBEDIRTY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_object_unwire:  *  *	For each page offset within the specified range of the given object,  *	find the highest-level page in the shadow chain and unwire it.  A page  *	must exist at every page offset, and the highest-level page must be  *	wired.  */
end_comment

begin_function
name|void
name|vm_object_unwire
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_size_t
name|length
parameter_list|,
name|uint8_t
name|queue
parameter_list|)
block|{
name|vm_object_t
name|tobject
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|tm
decl_stmt|;
name|vm_pindex_t
name|end_pindex
decl_stmt|,
name|pindex
decl_stmt|,
name|tpindex
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|locked_depth
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_unwire: offset is not page aligned"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|length
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_object_unwire: length is not a multiple of PAGE_SIZE"
operator|)
argument_list|)
expr_stmt|;
comment|/* The wired count of a fictitious page never changes. */
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
return|return;
name|pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|end_pindex
operator|=
name|pindex
operator|+
name|atop
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|locked_depth
operator|=
literal|1
expr_stmt|;
name|VM_OBJECT_RLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_find_least
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
while|while
condition|(
name|pindex
operator|<
name|end_pindex
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|pindex
operator|<
name|m
operator|->
name|pindex
condition|)
block|{
comment|/* 			 * The first object in the shadow chain doesn't 			 * contain a page at the current index.  Therefore, 			 * the page must exist in a backing object. 			 */
name|tobject
operator|=
name|object
expr_stmt|;
name|tpindex
operator|=
name|pindex
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|tpindex
operator|+=
name|OFF_TO_IDX
argument_list|(
name|tobject
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
name|tobject
operator|=
name|tobject
operator|->
name|backing_object
expr_stmt|;
name|KASSERT
argument_list|(
name|tobject
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vm_object_unwire: missing page"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tobject
operator|->
name|flags
operator|&
name|OBJ_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|next_page
goto|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|locked_depth
condition|)
block|{
name|locked_depth
operator|++
expr_stmt|;
name|VM_OBJECT_RLOCK
argument_list|(
name|tobject
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|tm
operator|=
name|vm_page_lookup
argument_list|(
name|tobject
argument_list|,
name|tpindex
argument_list|)
operator|)
operator|==
name|NULL
condition|)
do|;
block|}
else|else
block|{
name|tm
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|vm_page_lock
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|tm
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|next_page
label|:
name|pindex
operator|++
expr_stmt|;
block|}
comment|/* Release the accumulated object locks. */
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|depth
operator|<
name|locked_depth
condition|;
name|depth
operator|++
control|)
block|{
name|tobject
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|tobject
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|vnode
modifier|*
name|vm_object_vnode
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
return|return
operator|(
name|object
operator|->
name|handle
operator|)
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_TMPFS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_tmpfs
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_vm_object_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|kinfo_vmobject
name|kvo
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|freepath
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If an old buffer has not been provided, generate an 		 * estimate of the space needed for a subsequent call. 		 */
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJT_DEAD
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_vmobject
argument_list|)
operator|*
name|count
operator|*
literal|11
operator|/
literal|10
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * VM objects are type stable and are never removed from the 	 * list once added.  This allows us to safely read obj->object_list 	 * after reacquiring the VM object lock. 	 */
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJT_DEAD
condition|)
continue|continue;
name|VM_OBJECT_RLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJT_DEAD
condition|)
block|{
name|VM_OBJECT_RUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|kvo
operator|.
name|kvo_size
operator|=
name|ptoa
argument_list|(
name|obj
operator|->
name|size
argument_list|)
expr_stmt|;
name|kvo
operator|.
name|kvo_resident
operator|=
name|obj
operator|->
name|resident_page_count
expr_stmt|;
name|kvo
operator|.
name|kvo_ref_count
operator|=
name|obj
operator|->
name|ref_count
expr_stmt|;
name|kvo
operator|.
name|kvo_shadow_count
operator|=
name|obj
operator|->
name|shadow_count
expr_stmt|;
name|kvo
operator|.
name|kvo_memattr
operator|=
name|obj
operator|->
name|memattr
expr_stmt|;
name|kvo
operator|.
name|kvo_active
operator|=
literal|0
expr_stmt|;
name|kvo
operator|.
name|kvo_inactive
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&obj->memq
argument_list|,
argument|listq
argument_list|)
block|{
comment|/* 			 * A page may belong to the object but be 			 * dequeued and set to PQ_NONE while the 			 * object lock is not held.  This makes the 			 * reads of m->queue below racy, and we do not 			 * count pages set to PQ_NONE.  However, this 			 * sysctl is only meant to give an 			 * approximation of the system anyway. 			 */
if|if
condition|(
name|vm_page_active
argument_list|(
name|m
argument_list|)
condition|)
name|kvo
operator|.
name|kvo_active
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|vm_page_inactive
argument_list|(
name|m
argument_list|)
condition|)
name|kvo
operator|.
name|kvo_inactive
operator|++
expr_stmt|;
block|}
name|kvo
operator|.
name|kvo_vn_fileid
operator|=
literal|0
expr_stmt|;
name|kvo
operator|.
name|kvo_vn_fsid
operator|=
literal|0
expr_stmt|;
name|freepath
operator|=
name|NULL
expr_stmt|;
name|fullpath
operator|=
literal|""
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|OBJT_DEFAULT
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_DEFAULT
expr_stmt|;
break|break;
case|case
name|OBJT_VNODE
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_VNODE
expr_stmt|;
name|vp
operator|=
name|obj
operator|->
name|handle
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJT_SWAP
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_SWAP
expr_stmt|;
break|break;
case|case
name|OBJT_DEVICE
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_DEVICE
expr_stmt|;
break|break;
case|case
name|OBJT_PHYS
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_PHYS
expr_stmt|;
break|break;
case|case
name|OBJT_DEAD
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_DEAD
expr_stmt|;
break|break;
case|case
name|OBJT_SG
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_SG
expr_stmt|;
break|break;
case|case
name|OBJT_MGTDEVICE
case|:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_MGTDEVICE
expr_stmt|;
break|break;
default|default:
name|kvo
operator|.
name|kvo_type
operator|=
name|KVME_TYPE_UNKNOWN
expr_stmt|;
break|break;
block|}
name|VM_OBJECT_RUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vn_fullpath
argument_list|(
name|curthread
argument_list|,
name|vp
argument_list|,
operator|&
name|fullpath
argument_list|,
operator|&
name|freepath
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kvo
operator|.
name|kvo_vn_fileid
operator|=
name|va
operator|.
name|va_fileid
expr_stmt|;
name|kvo
operator|.
name|kvo_vn_fsid
operator|=
name|va
operator|.
name|va_fsid
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|kvo
operator|.
name|kvo_path
argument_list|,
name|fullpath
argument_list|,
sizeof|sizeof
argument_list|(
name|kvo
operator|.
name|kvo_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freepath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|freepath
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* Pack record size down */
name|kvo
operator|.
name|kvo_structsize
operator|=
name|offsetof
argument_list|(
expr|struct
name|kinfo_vmobject
argument_list|,
name|kvo_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|kvo
operator|.
name|kvo_path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|kvo
operator|.
name|kvo_structsize
operator|=
name|roundup
argument_list|(
name|kvo
operator|.
name|kvo_structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|kvo
argument_list|,
name|kvo
operator|.
name|kvo_structsize
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|objects
argument_list|,
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SKIP
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vm_object_list
argument_list|,
literal|"S,kinfo_vmobject"
argument_list|,
literal|"List of VM objects"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_function
specifier|static
name|int
name|_vm_object_in_map
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|vm_map_t
name|tmpm
decl_stmt|;
name|vm_map_entry_t
name|tmpe
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|entcount
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
name|tmpe
operator|=
name|map
operator|->
name|header
operator|.
name|next
expr_stmt|;
name|entcount
operator|=
name|map
operator|->
name|nentries
expr_stmt|;
while|while
condition|(
name|entcount
operator|--
operator|&&
operator|(
name|tmpe
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
condition|)
block|{
if|if
condition|(
name|_vm_object_in_map
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|tmpe
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|tmpe
operator|=
name|tmpe
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|tmpm
operator|=
name|entry
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|tmpe
operator|=
name|tmpm
operator|->
name|header
operator|.
name|next
expr_stmt|;
name|entcount
operator|=
name|tmpm
operator|->
name|nentries
expr_stmt|;
while|while
condition|(
name|entcount
operator|--
operator|&&
name|tmpe
operator|!=
operator|&
name|tmpm
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|_vm_object_in_map
argument_list|(
name|tmpm
argument_list|,
name|object
argument_list|,
name|tmpe
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|tmpe
operator|=
name|tmpe
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|obj
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|obj
condition|;
name|obj
operator|=
name|obj
operator|->
name|backing_object
control|)
if|if
condition|(
name|obj
operator|==
name|object
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vm_object_in_map
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* sx_slock(&allproc_lock); */
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|p_vmspace
comment|/* || (p->p_flag& (P_SYSTEM|P_WEXIT)) */
condition|)
continue|continue;
if|if
condition|(
name|_vm_object_in_map
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|object
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* sx_sunlock(&allproc_lock); */
return|return
literal|1
return|;
block|}
block|}
comment|/* sx_sunlock(&allproc_lock); */
if|if
condition|(
name|_vm_object_in_map
argument_list|(
name|kernel_map
argument_list|,
name|object
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vmochk
argument_list|,
argument|vm_object_check
argument_list|)
end_macro

begin_block
block|{
name|vm_object_t
name|object
decl_stmt|;
comment|/* 	 * make sure that internal objs are in a map somewhere 	 * and none have zero ref counts. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|object
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
block|{
if|if
condition|(
name|object
operator|->
name|handle
operator|==
name|NULL
operator|&&
operator|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|)
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|ref_count
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"vmochk: internal obj has zero ref count: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|object
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vm_object_in_map
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"vmochk: internal obj is not in a map: "
literal|"ref: %d, size: %lu: 0x%lx, backing_object: %p\n"
argument_list|,
name|object
operator|->
name|ref_count
argument_list|,
operator|(
name|u_long
operator|)
name|object
operator|->
name|size
argument_list|,
operator|(
name|u_long
operator|)
name|object
operator|->
name|size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|object
operator|->
name|backing_object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	vm_object_print:	[ debug ]  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|object
argument_list|,
argument|vm_object_print_static
argument_list|)
end_macro

begin_block
block|{
comment|/* XXX convert args. */
name|vm_object_t
name|object
init|=
operator|(
name|vm_object_t
operator|)
name|addr
decl_stmt|;
name|boolean_t
name|full
init|=
name|have_addr
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
comment|/* XXX count is an (unused) arg.  Avoid shadowing it. */
define|#
directive|define
name|count
value|was_count
name|int
name|count
decl_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return;
name|db_iprintf
argument_list|(
literal|"Object %p: type=%d, size=0x%jx, res=%d, ref=%d, flags=0x%x ruid %d charge %jx\n"
argument_list|,
name|object
argument_list|,
operator|(
name|int
operator|)
name|object
operator|->
name|type
argument_list|,
operator|(
name|uintmax_t
operator|)
name|object
operator|->
name|size
argument_list|,
name|object
operator|->
name|resident_page_count
argument_list|,
name|object
operator|->
name|ref_count
argument_list|,
name|object
operator|->
name|flags
argument_list|,
name|object
operator|->
name|cred
condition|?
name|object
operator|->
name|cred
operator|->
name|cr_ruid
else|:
operator|-
literal|1
argument_list|,
operator|(
name|uintmax_t
operator|)
name|object
operator|->
name|charge
argument_list|)
expr_stmt|;
name|db_iprintf
argument_list|(
literal|" sref=%d, backing_object(%d)=(%p)+0x%jx\n"
argument_list|,
name|object
operator|->
name|shadow_count
argument_list|,
name|object
operator|->
name|backing_object
condition|?
name|object
operator|->
name|backing_object
operator|->
name|ref_count
else|:
literal|0
argument_list|,
name|object
operator|->
name|backing_object
argument_list|,
operator|(
name|uintmax_t
operator|)
name|object
operator|->
name|backing_object_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full
condition|)
return|return;
name|db_indent
operator|+=
literal|2
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&object->memq
argument_list|,
argument|listq
argument_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|db_iprintf
argument_list|(
literal|"memory:="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|6
condition|)
block|{
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_iprintf
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|db_printf
argument_list|(
literal|"(off=0x%jx,page=0x%jx)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|p
operator|->
name|pindex
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_indent
operator|-=
literal|2
expr_stmt|;
block|}
end_block

begin_comment
comment|/* XXX. */
end_comment

begin_undef
undef|#
directive|undef
name|count
end_undef

begin_comment
comment|/* XXX need this non-static entry for calling from vm_map_print. */
end_comment

begin_function
name|void
name|vm_object_print
parameter_list|(
comment|/* db_expr_t */
name|long
name|addr
parameter_list|,
name|boolean_t
name|have_addr
parameter_list|,
comment|/* db_expr_t */
name|long
name|count
parameter_list|,
name|char
modifier|*
name|modif
parameter_list|)
block|{
name|vm_object_print_static
argument_list|(
name|addr
argument_list|,
name|have_addr
argument_list|,
name|count
argument_list|,
name|modif
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vmopag
argument_list|,
argument|vm_object_print_pages
argument_list|)
end_macro

begin_block
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|fidx
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|prev_m
decl_stmt|;
name|int
name|rcount
decl_stmt|,
name|nl
decl_stmt|,
name|c
decl_stmt|;
name|nl
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|object
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"new object: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>
literal|18
condition|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return;
name|nl
operator|=
literal|0
expr_stmt|;
block|}
name|nl
operator|++
expr_stmt|;
name|rcount
operator|=
literal|0
expr_stmt|;
name|fidx
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
operator|-
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&object->memq
argument_list|,
argument|listq
argument_list|)
block|{
if|if
condition|(
name|m
operator|->
name|pindex
operator|>
literal|128
condition|)
break|break;
if|if
condition|(
operator|(
name|prev_m
operator|=
name|TAILQ_PREV
argument_list|(
name|m
argument_list|,
name|pglist
argument_list|,
name|listq
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|prev_m
operator|->
name|pindex
operator|+
literal|1
operator|!=
name|m
operator|->
name|pindex
condition|)
block|{
if|if
condition|(
name|rcount
condition|)
block|{
name|db_printf
argument_list|(
literal|" index(%ld)run(%d)pa(0x%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|fidx
argument_list|,
name|rcount
argument_list|,
operator|(
name|long
operator|)
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>
literal|18
condition|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return;
name|nl
operator|=
literal|0
expr_stmt|;
block|}
name|nl
operator|++
expr_stmt|;
name|rcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rcount
operator|&&
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|==
name|pa
operator|+
name|rcount
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
operator|++
name|rcount
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rcount
condition|)
block|{
name|db_printf
argument_list|(
literal|" index(%ld)run(%d)pa(0x%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|fidx
argument_list|,
name|rcount
argument_list|,
operator|(
name|long
operator|)
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>
literal|18
condition|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return;
name|nl
operator|=
literal|0
expr_stmt|;
block|}
name|nl
operator|++
expr_stmt|;
block|}
name|fidx
operator|=
name|m
operator|->
name|pindex
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rcount
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rcount
condition|)
block|{
name|db_printf
argument_list|(
literal|" index(%ld)run(%d)pa(0x%lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|fidx
argument_list|,
name|rcount
argument_list|,
operator|(
name|long
operator|)
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>
literal|18
condition|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return;
name|nl
operator|=
literal|0
expr_stmt|;
block|}
name|nl
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

