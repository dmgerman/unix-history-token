begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005, Bosko Milekic<bmilekic@FreeBSD.org>.  * Copyright (c) 2010 Isilon Systems, Inc. (http://www.isilon.com/)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MemGuard is a simple replacement allocator for debugging only  * which provides ElectricFence-style memory barrier protection on  * objects being allocated, and is used to detect tampering-after-free  * scenarios.  *  * See the memguard(9) man page for more information on using MemGuard.  */
end_comment

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_include
include|#
directive|include
file|<vm/memguard.h>
end_include

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|memguard
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"MemGuard data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The vm_memguard_divisor variable controls how much of kmem_map should be  * reserved for MemGuard.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|vm_memguard_divisor
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|divisor
argument_list|,
name|CTLFLAG_RDTUN
operator||
name|CTLFLAG_NOFETCH
argument_list|,
operator|&
name|vm_memguard_divisor
argument_list|,
literal|0
argument_list|,
literal|"(kmem_size/memguard_divisor) == memguard submap size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Short description (ks_shortdesc) of memory type to monitor.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|vm_memguard_desc
index|[
literal|128
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|malloc_type
modifier|*
name|vm_memguard_mtype
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"vm.memguard.desc"
argument_list|,
name|vm_memguard_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_memguard_desc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|memguard_sysctl_desc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|desc
index|[
sizeof|sizeof
argument_list|(
name|vm_memguard_desc
argument_list|)
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|vm_memguard_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|malloc_mtx
argument_list|)
expr_stmt|;
comment|/* If mtp is NULL, it will be initialized in memguard_cmp() */
name|vm_memguard_mtype
operator|=
name|malloc_desc2type
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|vm_memguard_desc
argument_list|,
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_memguard_desc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|malloc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|desc
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|memguard_sysctl_desc
argument_list|,
literal|"A"
argument_list|,
literal|"Short description of memory type to monitor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|memguard_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|memguard_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_size_t
name|memguard_mapsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_size_t
name|memguard_physlimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_wasted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_succ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_fail_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_fail_pgs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|cursor
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_cursor
argument_list|,
literal|0
argument_list|,
literal|"MemGuard cursor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|mapsize
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_mapsize
argument_list|,
literal|0
argument_list|,
literal|"MemGuard private arena size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|phys_limit
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_physlimit
argument_list|,
literal|0
argument_list|,
literal|"Limit on MemGuard memory consumption"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|wasted
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_wasted
argument_list|,
literal|0
argument_list|,
literal|"Excess memory used through page promotion"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|wrapcnt
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_wrap
argument_list|,
literal|0
argument_list|,
literal|"MemGuard cursor wrap count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|numalloc
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_succ
argument_list|,
literal|0
argument_list|,
literal|"Count of successful MemGuard allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|fail_kva
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_fail_kva
argument_list|,
literal|0
argument_list|,
literal|"MemGuard failures due to lack of KVA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|fail_pgs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_fail_pgs
argument_list|,
literal|0
argument_list|,
literal|"MemGuard failures due to lack of pages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MG_GUARD_AROUND
value|0x001
end_define

begin_define
define|#
directive|define
name|MG_GUARD_ALLLARGE
value|0x002
end_define

begin_define
define|#
directive|define
name|MG_GUARD_NOFREE
value|0x004
end_define

begin_decl_stmt
specifier|static
name|int
name|memguard_options
init|=
name|MG_GUARD_AROUND
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|options
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|memguard_options
argument_list|,
literal|0
argument_list|,
literal|"MemGuard options:\n"
literal|"\t0x001 - add guard pages around each allocation\n"
literal|"\t0x002 - always use MemGuard for allocations over a page\n"
literal|"\t0x004 - guard uma(9) zones with UMA_ZONE_NOFREE flag"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|memguard_minsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_minsize_reject
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|minsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|memguard_minsize
argument_list|,
literal|0
argument_list|,
literal|"Minimum size for page promotion"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|minsize_reject
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_minsize_reject
argument_list|,
literal|0
argument_list|,
literal|"# times rejected for size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|memguard_frequency
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|memguard_frequency_hits
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|frequency
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|memguard_frequency
argument_list|,
literal|0
argument_list|,
literal|"Times in 100000 that MemGuard will randomly run"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_memguard
argument_list|,
name|OID_AUTO
argument_list|,
name|frequency_hits
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_frequency_hits
argument_list|,
literal|0
argument_list|,
literal|"# times MemGuard randomly chose"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Return a fudged value to be used for vm_kmem_size for allocating  * the kmem_map.  The memguard memory will be a submap.  */
end_comment

begin_function
name|unsigned
name|long
name|memguard_fudge
parameter_list|(
name|unsigned
name|long
name|km_size
parameter_list|,
specifier|const
name|struct
name|vm_map
modifier|*
name|parent_map
parameter_list|)
block|{
name|u_long
name|mem_pgs
decl_stmt|,
name|parent_size
decl_stmt|;
name|vm_memguard_divisor
operator|=
literal|10
expr_stmt|;
comment|/* CTFLAG_RDTUN doesn't work during the early boot process. */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.memguard.divisor"
argument_list|,
operator|&
name|vm_memguard_divisor
argument_list|)
expr_stmt|;
name|parent_size
operator|=
name|vm_map_max
argument_list|(
name|parent_map
argument_list|)
operator|-
name|vm_map_min
argument_list|(
name|parent_map
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* Pick a conservative value if provided value sucks. */
if|if
condition|(
operator|(
name|vm_memguard_divisor
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|parent_size
operator|/
name|vm_memguard_divisor
operator|)
operator|==
literal|0
operator|)
condition|)
name|vm_memguard_divisor
operator|=
literal|10
expr_stmt|;
comment|/* 	 * Limit consumption of physical pages to 	 * 1/vm_memguard_divisor of system memory.  If the KVA is 	 * smaller than this then the KVA limit comes into play first. 	 * This prevents memguard's page promotions from completely 	 * using up memory, since most malloc(9) calls are sub-page. 	 */
name|mem_pgs
operator|=
name|vm_cnt
operator|.
name|v_page_count
expr_stmt|;
name|memguard_physlimit
operator|=
operator|(
name|mem_pgs
operator|/
name|vm_memguard_divisor
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * We want as much KVA as we can take safely.  Use at most our 	 * allotted fraction of the parent map's size.  Limit this to 	 * twice the physical memory to avoid using too much memory as 	 * pagetable pages (size must be multiple of PAGE_SIZE). 	 */
name|memguard_mapsize
operator|=
name|round_page
argument_list|(
name|parent_size
operator|/
name|vm_memguard_divisor
argument_list|)
expr_stmt|;
if|if
condition|(
name|memguard_mapsize
operator|/
operator|(
literal|2
operator|*
name|PAGE_SIZE
operator|)
operator|>
name|mem_pgs
condition|)
name|memguard_mapsize
operator|=
name|mem_pgs
operator|*
literal|2
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|km_size
operator|+
name|memguard_mapsize
operator|>
name|parent_size
condition|)
name|memguard_mapsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|km_size
operator|+
name|memguard_mapsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the MemGuard mock allocator.  All objects from MemGuard come  * out of a single VM map (contiguous chunk of address space).  */
end_comment

begin_function
name|void
name|memguard_init
parameter_list|(
name|vmem_t
modifier|*
name|parent
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|;
name|vmem_alloc
argument_list|(
name|parent
argument_list|,
name|memguard_mapsize
argument_list|,
name|M_BESTFIT
operator||
name|M_WAITOK
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
name|vmem_init
argument_list|(
name|memguard_arena
argument_list|,
literal|"memguard arena"
argument_list|,
name|base
argument_list|,
name|memguard_mapsize
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memguard_cursor
operator|=
name|base
expr_stmt|;
name|memguard_base
operator|=
name|base
expr_stmt|;
name|printf
argument_list|(
literal|"MEMGUARD DEBUGGING ALLOCATOR INITIALIZED:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tMEMGUARD map base: 0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tMEMGUARD map size: %jd KBytes\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|memguard_mapsize
operator|>>
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Run things that can't be done as early as memguard_init().  */
end_comment

begin_function
specifier|static
name|void
name|memguard_sysinit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sysctl_oid_list
modifier|*
name|parent
decl_stmt|;
name|parent
operator|=
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vm_memguard
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
name|NULL
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mapstart"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_base
argument_list|,
literal|"MemGuard KVA base"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UAUTO
argument_list|(
name|NULL
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"maplimit"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|memguard_mapsize
argument_list|,
literal|"MemGuard KVA size"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|SYSCTL_ADD_ULONG(NULL, parent, OID_AUTO, "mapused", CTLFLAG_RD,&memguard_map->size, "MemGuard KVA used");
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|memguard
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|memguard_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * v2sizep() converts a virtual address of the first page allocated for  * an item to a pointer to u_long recording the size of the original  * allocation request.  *  * This routine is very similar to those defined by UMA in uma_int.h.  * The difference is that this routine stores the originally allocated  * size in one of the page's fields that is unused when the page is  * wired rather than the object field, which is used.  */
end_comment

begin_function
specifier|static
name|u_long
modifier|*
name|v2sizep
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|p
decl_stmt|;
name|pa
operator|=
name|pmap_kextract
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MemGuard detected double-free of %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
name|p
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|wire_count
operator|!=
literal|0
operator|&&
name|p
operator|->
name|queue
operator|==
name|PQ_NONE
argument_list|,
operator|(
literal|"MEMGUARD: Expected wired page %p in vtomgfifo!"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|p
operator|->
name|plinks
operator|.
name|memguard
operator|.
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
modifier|*
name|v2sizev
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|p
decl_stmt|;
name|pa
operator|=
name|pmap_kextract
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MemGuard detected double-free of %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
name|p
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|wire_count
operator|!=
literal|0
operator|&&
name|p
operator|->
name|queue
operator|==
name|PQ_NONE
argument_list|,
operator|(
literal|"MEMGUARD: Expected wired page %p in vtomgfifo!"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|p
operator|->
name|plinks
operator|.
name|memguard
operator|.
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a single object of specified size with specified flags  * (either M_WAITOK or M_NOWAIT).  */
end_comment

begin_function
name|void
modifier|*
name|memguard_alloc
parameter_list|(
name|unsigned
name|long
name|req_size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|u_long
name|size_p
decl_stmt|,
name|size_v
decl_stmt|;
name|int
name|do_guard
decl_stmt|,
name|rv
decl_stmt|;
name|size_p
operator|=
name|round_page
argument_list|(
name|req_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_p
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * To ensure there are holes on both sides of the allocation, 	 * request 2 extra pages of KVA.  We will only actually add a 	 * vm_map_entry and get pages for the original request.  Save 	 * the value of memguard_options so we have a consistent 	 * value. 	 */
name|size_v
operator|=
name|size_p
expr_stmt|;
name|do_guard
operator|=
operator|(
name|memguard_options
operator|&
name|MG_GUARD_AROUND
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|do_guard
condition|)
name|size_v
operator|+=
literal|2
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * When we pass our memory limit, reject sub-page allocations. 	 * Page-size and larger allocations will use the same amount 	 * of physical memory whether we allocate or hand off to 	 * uma_large_alloc(), so keep those. 	 */
if|if
condition|(
name|vmem_size
argument_list|(
name|memguard_arena
argument_list|,
name|VMEM_ALLOC
argument_list|)
operator|>=
name|memguard_physlimit
operator|&&
name|req_size
operator|<
name|PAGE_SIZE
condition|)
block|{
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|NULL
expr_stmt|;
name|memguard_fail_pgs
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Keep a moving cursor so we don't recycle KVA as long as 	 * possible.  It's not perfect, since we don't know in what 	 * order previous allocations will be free'd, but it's simple 	 * and fast, and requires O(1) additional storage if guard 	 * pages are not used. 	 * 	 * XXX This scheme will lead to greater fragmentation of the 	 * map, unless vm_map_findspace() is tweaked. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vmem_xalloc
argument_list|(
name|memguard_arena
argument_list|,
name|size_v
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|memguard_cursor
argument_list|,
name|VMEM_ADDR_MAX
argument_list|,
name|M_BESTFIT
operator||
name|M_NOWAIT
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * The map has no space.  This may be due to 		 * fragmentation, or because the cursor is near the 		 * end of the map. 		 */
if|if
condition|(
name|memguard_cursor
operator|==
name|memguard_base
condition|)
block|{
name|memguard_fail_kva
operator|++
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memguard_wrap
operator|++
expr_stmt|;
name|memguard_cursor
operator|=
name|memguard_base
expr_stmt|;
block|}
if|if
condition|(
name|do_guard
condition|)
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|rv
operator|=
name|kmem_back
argument_list|(
name|kmem_object
argument_list|,
name|addr
argument_list|,
name|size_p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vmem_xfree
argument_list|(
name|memguard_arena
argument_list|,
name|addr
argument_list|,
name|size_v
argument_list|)
expr_stmt|;
name|memguard_fail_pgs
operator|++
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memguard_cursor
operator|=
name|addr
operator|+
name|size_v
expr_stmt|;
operator|*
name|v2sizep
argument_list|(
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|=
name|req_size
expr_stmt|;
operator|*
name|v2sizev
argument_list|(
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|=
name|size_v
expr_stmt|;
name|memguard_succ
operator|++
expr_stmt|;
if|if
condition|(
name|req_size
operator|<
name|PAGE_SIZE
condition|)
block|{
name|memguard_wasted
operator|+=
operator|(
name|PAGE_SIZE
operator|-
name|req_size
operator|)
expr_stmt|;
if|if
condition|(
name|do_guard
condition|)
block|{
comment|/* 			 * Align the request to 16 bytes, and return 			 * an address near the end of the page, to 			 * better detect array overrun. 			 */
name|req_size
operator|=
name|roundup2
argument_list|(
name|req_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|addr
operator|+=
operator|(
name|PAGE_SIZE
operator|-
name|req_size
operator|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_memguard_addr
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|vm_offset_t
name|a
init|=
operator|(
name|vm_offset_t
operator|)
operator|(
name|uintptr_t
operator|)
name|addr
decl_stmt|;
return|return
operator|(
name|a
operator|>=
name|memguard_base
operator|&&
name|a
operator|<
name|memguard_base
operator|+
name|memguard_mapsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free specified single object.  */
end_comment

begin_function
name|void
name|memguard_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|u_long
name|req_size
decl_stmt|,
name|size
decl_stmt|,
name|sizev
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|req_size
operator|=
operator|*
name|v2sizep
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|sizev
operator|=
operator|*
name|v2sizev
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|req_size
argument_list|)
expr_stmt|;
comment|/* 	 * Page should not be guarded right now, so force a write. 	 * The purpose of this is to increase the likelihood of 	 * catching a double-free, but not necessarily a 	 * tamper-after-free (the second thread freeing might not 	 * write before freeing, so this forces it to and, 	 * subsequently, trigger a fault). 	 */
name|temp
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
name|temp
index|[
name|i
index|]
operator|=
literal|'M'
expr_stmt|;
comment|/* 	 * This requires carnal knowledge of the implementation of 	 * kmem_free(), but since we've already replaced kmem_malloc() 	 * above, it's not really any worse.  We want to use the 	 * vm_map lock to serialize updates to memguard_wasted, since 	 * we had the lock at increment. 	 */
name|kmem_unback
argument_list|(
name|kmem_object
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizev
operator|>
name|size
condition|)
name|addr
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|vmem_xfree
argument_list|(
name|memguard_arena
argument_list|,
name|addr
argument_list|,
name|sizev
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_size
operator|<
name|PAGE_SIZE
condition|)
name|memguard_wasted
operator|-=
operator|(
name|PAGE_SIZE
operator|-
name|req_size
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-allocate an allocation that was originally guarded.  */
end_comment

begin_function
name|void
modifier|*
name|memguard_realloc
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|mtp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|newaddr
decl_stmt|;
name|u_long
name|old_size
decl_stmt|;
comment|/* 	 * Allocate the new block.  Force the allocation to be guarded 	 * as the original may have been guarded through random 	 * chance, and that should be preserved. 	 */
if|if
condition|(
operator|(
name|newaddr
operator|=
name|memguard_alloc
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Copy over original contents. */
name|old_size
operator|=
operator|*
name|v2sizep
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|uintptr_t
operator|)
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|newaddr
argument_list|,
name|min
argument_list|(
name|size
argument_list|,
name|old_size
argument_list|)
argument_list|)
expr_stmt|;
name|memguard_free
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|newaddr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|memguard_cmp
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
name|memguard_minsize
condition|)
block|{
name|memguard_minsize_reject
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|memguard_options
operator|&
name|MG_GUARD_ALLLARGE
operator|)
operator|!=
literal|0
operator|&&
name|size
operator|>=
name|PAGE_SIZE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|memguard_frequency
operator|>
literal|0
operator|&&
operator|(
name|random
argument_list|()
operator|%
literal|100000
operator|)
operator|<
name|memguard_frequency
condition|)
block|{
name|memguard_frequency_hits
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|memguard_cmp_mtp
parameter_list|(
name|struct
name|malloc_type
modifier|*
name|mtp
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|memguard_cmp
argument_list|(
name|size
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
literal|1
comment|/* 	 * The safest way of comparsion is to always compare short description 	 * string of memory type, but it is also the slowest way. 	 */
return|return
operator|(
name|strcmp
argument_list|(
name|mtp
operator|->
name|ks_shortdesc
argument_list|,
name|vm_memguard_desc
argument_list|)
operator|==
literal|0
operator|)
return|;
else|#
directive|else
comment|/* 	 * If we compare pointers, there are two possible problems: 	 * 1. Memory type was unloaded and new memory type was allocated at the 	 *    same address. 	 * 2. Memory type was unloaded and loaded again, but allocated at a 	 *    different address. 	 */
if|if
condition|(
name|vm_memguard_mtype
operator|!=
name|NULL
condition|)
return|return
operator|(
name|mtp
operator|==
name|vm_memguard_mtype
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|mtp
operator|->
name|ks_shortdesc
argument_list|,
name|vm_memguard_desc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vm_memguard_mtype
operator|=
name|mtp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|memguard_cmp_zone
parameter_list|(
name|uma_zone_t
name|zone
parameter_list|)
block|{
if|if
condition|(
operator|(
name|memguard_options
operator|&
name|MG_GUARD_NOFREE
operator|)
operator|==
literal|0
operator|&&
name|zone
operator|->
name|uz_flags
operator|&
name|UMA_ZONE_NOFREE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memguard_cmp
argument_list|(
name|zone
operator|->
name|uz_size
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * The safest way of comparsion is to always compare zone name, 	 * but it is also the slowest way. 	 */
return|return
operator|(
name|strcmp
argument_list|(
name|zone
operator|->
name|uz_name
argument_list|,
name|vm_memguard_desc
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

end_unit

