begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008 Mayur Shardul<mayur.shardul@gmail.com>  * Copyright (c) 2011 Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * Radix tree implementation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_radix.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|vm_radix_node
argument_list|)
end_macro

begin_expr_stmt
name|res_rnodes_head
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|res_rnodes_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|rnode_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|rnode_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|rnode_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a radix node.  Initializes all elements to 0.  */
end_comment

begin_function
specifier|static
name|struct
name|vm_radix_node
modifier|*
name|vm_radix_node_get
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|rnode
decl_stmt|;
if|if
condition|(
name|VM_OBJECT_LOCKED
argument_list|(
name|kernel_object
argument_list|)
operator|||
name|VM_OBJECT_LOCKED
argument_list|(
name|kmem_object
argument_list|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|rnode_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|res_rnodes_head
argument_list|)
condition|)
block|{
name|rnode
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|res_rnodes_head
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|res_rnodes_head
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|rnode_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rnode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rnode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|rnode_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"No memory for kernel_object. . ."
argument_list|)
expr_stmt|;
block|}
name|rnode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_radix_node
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"vm_radix_node_get: Can not allocate memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|out
label|:
return|return
name|rnode
return|;
block|}
end_function

begin_comment
comment|/*  * Free radix node.  */
end_comment

begin_function
specifier|static
name|void
name|vm_radix_node_put
parameter_list|(
name|struct
name|vm_radix_node
modifier|*
name|rnode
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|rnode
operator|->
name|rn_count
operator|==
literal|0
argument_list|,
operator|(
literal|"vm_radix_node_put: Freeing a node with %d children\n"
operator|,
name|rnode
operator|->
name|rn_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|rnode
operator|>=
name|rnode_start
operator|&&
operator|(
name|vm_offset_t
operator|)
name|rnode
operator|<
name|rnode_end
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|rnode_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|res_rnodes_head
argument_list|,
name|rnode
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|rnode_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|rnode
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the position in the array for a given level.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|vm_radix_slot
parameter_list|(
name|vm_pindex_t
name|index
parameter_list|,
name|int
name|level
parameter_list|)
block|{
return|return
operator|(
operator|(
name|index
operator|>>
operator|(
name|level
operator|*
name|VM_RADIX_WIDTH
operator|)
operator|)
operator|&
name|VM_RADIX_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inserts the key-value pair in to the radix tree.  Returns errno.  * Panics if the key already exists.  */
end_comment

begin_function
name|int
name|vm_radix_insert
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|void
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|rnode
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|level
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_VM
argument_list|,
literal|"insert: tree %p, index %p, val %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"vm_radix_insert: -1 is not a valid index.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Increase the height by adding nodes at the root until 	 * there is sufficient space. 	 */
while|while
condition|(
name|rtree
operator|->
name|rt_height
operator|==
literal|0
operator|||
name|index
operator|>
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_VM
argument_list|,
literal|"insert: expanding %jd> %jd height %d"
argument_list|,
name|index
argument_list|,
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
argument_list|,
name|rtree
operator|->
name|rt_height
argument_list|)
expr_stmt|;
comment|/* 		 * Only allocate tree nodes if they are needed. 		 */
if|if
condition|(
name|rtree
operator|->
name|rt_root
operator|==
name|NULL
operator|||
name|rtree
operator|->
name|rt_root
operator|->
name|rn_count
operator|!=
literal|0
condition|)
block|{
name|rnode
operator|=
name|vm_radix_node_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|rnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|rtree
operator|->
name|rt_root
condition|)
block|{
name|rnode
operator|->
name|rn_child
index|[
literal|0
index|]
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
name|rnode
operator|->
name|rn_count
operator|=
literal|1
expr_stmt|;
block|}
name|rtree
operator|->
name|rt_root
operator|=
name|rnode
expr_stmt|;
block|}
name|rtree
operator|->
name|rt_height
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|rtree
operator|->
name|rt_height
operator|<=
name|VM_RADIX_LIMIT
argument_list|,
operator|(
literal|"vm_radix_insert: Tree %p height %d too tall"
operator|,
name|rtree
operator|,
name|rtree
operator|->
name|rt_height
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that the tree is tall enough, fill in the path to the index. */
name|rnode
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
for|for
control|(
name|level
operator|=
name|rtree
operator|->
name|rt_height
operator|-
literal|1
init|;
name|level
operator|>
literal|0
condition|;
name|level
operator|--
control|)
block|{
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* Add the required intermidiate nodes. */
if|if
condition|(
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|==
name|NULL
condition|)
block|{
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|=
name|vm_radix_node_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rnode
operator|->
name|rn_count
operator|++
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"insert: tree %p, index %p, level %d, slot %d, child %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|,
name|level
argument_list|,
name|slot
argument_list|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|rnode
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
block|}
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"insert: tree %p, index %p, level %d, slot %d, child %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|,
name|level
argument_list|,
name|slot
argument_list|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"vm_radix_insert: Duplicate value %p at index: %lu\n"
operator|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|,
operator|(
name|u_long
operator|)
name|index
operator|)
argument_list|)
expr_stmt|;
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|=
name|val
expr_stmt|;
name|rnode
operator|->
name|rn_count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the value stored at the index.  If the index is not present  * NULL is returned.  */
end_comment

begin_function
name|void
modifier|*
name|vm_radix_lookup
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|rnode
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
condition|)
return|return
name|NULL
return|;
name|level
operator|=
name|rtree
operator|->
name|rt_height
operator|-
literal|1
expr_stmt|;
name|rnode
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
while|while
condition|(
name|rnode
condition|)
block|{
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"lookup: tree %p, index %p, level %d, slot %d, child %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|,
name|level
argument_list|,
name|slot
argument_list|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
return|;
name|rnode
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_VM
argument_list|,
literal|"lookup: tree %p, index %p failed"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Looks up as many as cnt values between start and end and stores them  * in the caller allocated array out.  The next index can be used to  * restart the scan.  This optimizes forward scans in the tree.  */
end_comment

begin_function
name|int
name|vm_radix_lookupn
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_pindex_t
name|end
parameter_list|,
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|int
name|cnt
parameter_list|,
name|vm_pindex_t
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|rnode
decl_stmt|;
name|struct
name|vm_radix_node
modifier|*
name|child
decl_stmt|;
name|vm_pindex_t
name|max
decl_stmt|;
name|vm_pindex_t
name|inc
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|level
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|int
name|outidx
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_VM
argument_list|,
literal|"lookupn: tree %p, start %p, end %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|end
argument_list|)
expr_stmt|;
name|outidx
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|max
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|end
operator|>
name|max
operator|+
literal|1
condition|)
name|end
operator|=
name|max
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|==
literal|0
condition|)
name|end
operator|=
operator|-
literal|1
expr_stmt|;
name|restart
label|:
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>
literal|1000
condition|)
name|panic
argument_list|(
literal|"vm_radix_lookupn: looping %d\n"
argument_list|,
name|loops
argument_list|)
expr_stmt|;
comment|/* 	 * Search the tree from the top for any leaf node holding an index 	 * between start and end. 	 */
name|level
operator|=
name|rtree
operator|->
name|rt_height
operator|-
literal|1
expr_stmt|;
name|rnode
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
while|while
condition|(
name|rnode
condition|)
block|{
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|start
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"lookupn: tree %p, index %p, level %d, slot %d, child %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
name|level
argument_list|,
name|slot
argument_list|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * If we don't have an exact match we must start our search 		 * from the next leaf and adjust our index appropriately. 		 */
if|if
condition|(
operator|(
name|child
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Calculate how much to increment our index by 			 * based on the tree level.  We must truncate the 			 * lower bits to start from the begnning of the next 			 * leaf. 		 	 */
name|inc
operator|=
literal|1LL
operator|<<
operator|(
name|level
operator|*
name|VM_RADIX_WIDTH
operator|)
expr_stmt|;
name|start
operator|&=
operator|~
name|VM_RADIX_MAX
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|start
operator|+=
name|inc
expr_stmt|;
name|slot
operator|++
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"lookupn: start %p end %p inc %d mask 0x%lX slot %d"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|end
argument_list|,
name|inc
argument_list|,
operator|~
name|VM_RADIX_MAX
argument_list|(
name|level
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|slot
operator|<
name|VM_RADIX_COUNT
operator|&&
name|start
operator|<
name|end
condition|;
name|slot
operator|++
operator|,
name|start
operator|+=
name|inc
control|)
block|{
name|child
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|child
condition|)
break|break;
block|}
block|}
name|rnode
operator|=
name|child
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rnode
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If we still have another range to search, start looking 		 * from the next node.  Otherwise, return what we've already 		 * found.  The loop above has already adjusted start to the 		 * beginning of the next node. 		 * 		 * Detect start wrapping back to 0 and return in this case. 		 */
if|if
condition|(
name|start
operator|<
name|end
operator|&&
name|start
operator|!=
literal|0
condition|)
goto|goto
name|restart
goto|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
name|outidx
operator|<
name|cnt
operator|&&
name|slot
operator|<
name|VM_RADIX_COUNT
operator|&&
name|start
operator|<
name|end
condition|;
name|slot
operator|++
operator|,
name|start
operator|++
control|)
block|{
name|val
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
continue|continue;
name|out
index|[
name|outidx
operator|++
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/* 	 * Go fetch the next page to fill the requested number of pages 	 * otherwise the caller will simply call us again to fulfill the 	 * same request after the structures are pushed out of cache. 	 */
if|if
condition|(
name|outidx
operator|<
name|cnt
operator|&&
name|start
operator|<
name|end
condition|)
goto|goto
name|restart
goto|;
name|out
label|:
operator|*
name|next
operator|=
name|start
expr_stmt|;
return|return
operator|(
name|outidx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up any entry at a position greater or equal to index.  */
end_comment

begin_function
name|void
modifier|*
name|vm_radix_lookup_ge
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
block|{
name|vm_pindex_t
name|max
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
name|max
operator|=
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
expr_stmt|;
name|n
operator|=
name|vm_radix_lookupn
argument_list|(
name|rtree
argument_list|,
name|index
argument_list|,
name|max
operator|+
literal|1
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
name|val
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up any entry at a position less than or equal to index.  */
end_comment

begin_function
name|void
modifier|*
name|vm_radix_lookup_le
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the specified index from the tree.  If possible the height of the  * tree is adjusted after deletion.  The value stored at index is returned  * panics if the key is not present.  */
end_comment

begin_function
name|void
modifier|*
name|vm_radix_remove
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|stack
index|[
name|VM_RADIX_LIMIT
index|]
decl_stmt|;
name|struct
name|vm_radix_node
modifier|*
name|rnode
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|KASSERT
argument_list|(
name|index
operator|<=
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
argument_list|,
operator|(
literal|"vm_radix_remove: %p index %jd out of range %jd."
operator|,
name|rtree
operator|,
name|index
operator|,
name|VM_RADIX_MAX
argument_list|(
name|rtree
operator|->
name|rt_height
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|NULL
expr_stmt|;
name|rnode
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
name|level
operator|=
name|rtree
operator|->
name|rt_height
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Find the node and record the path in stack. 	 */
while|while
condition|(
name|level
operator|&&
name|rnode
condition|)
block|{
name|stack
index|[
name|level
index|]
operator|=
name|rnode
expr_stmt|;
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|rnode
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_VM
argument_list|,
literal|"remove: tree %p, index %p, level %d, slot %d, child %p"
argument_list|,
name|rtree
argument_list|,
operator|(
name|void
operator|*
operator|)
name|index
argument_list|,
name|level
argument_list|,
name|slot
argument_list|,
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rnode
operator|!=
name|NULL
operator|&&
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"vm_radix_remove: index %jd not present in the tree.\n"
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rnode
operator|->
name|rn_child
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
name|rnode
operator|->
name|rn_count
operator|--
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|rn_count
operator|>
literal|0
condition|)
break|break;
name|vm_radix_node_put
argument_list|(
name|rnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|==
name|rtree
operator|->
name|rt_root
condition|)
block|{
name|rtree
operator|->
name|rt_root
operator|=
name|NULL
expr_stmt|;
name|rtree
operator|->
name|rt_height
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|rnode
operator|=
name|stack
index|[
operator|++
name|level
index|]
expr_stmt|;
name|slot
operator|=
name|vm_radix_slot
argument_list|(
name|index
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempts to reduce the height of the tree.  */
end_comment

begin_function
name|void
name|vm_radix_shrink
parameter_list|(
name|struct
name|vm_radix
modifier|*
name|rtree
parameter_list|)
block|{
name|struct
name|vm_radix_node
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|rtree
operator|->
name|rt_root
operator|==
name|NULL
condition|)
return|return;
comment|/* Adjust the height of the tree. */
while|while
condition|(
name|rtree
operator|->
name|rt_root
operator|->
name|rn_count
operator|==
literal|1
operator|&&
name|rtree
operator|->
name|rt_root
operator|->
name|rn_child
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|rtree
operator|->
name|rt_root
expr_stmt|;
name|rtree
operator|->
name|rt_root
operator|=
name|tmp
operator|->
name|rn_child
index|[
literal|0
index|]
expr_stmt|;
name|rtree
operator|->
name|rt_height
operator|--
expr_stmt|;
name|tmp
operator|->
name|rn_count
operator|--
expr_stmt|;
name|vm_radix_node_put
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Finally see if we have an empty tree. */
if|if
condition|(
name|rtree
operator|->
name|rt_root
operator|->
name|rn_count
operator|==
literal|0
condition|)
block|{
name|vm_radix_node_put
argument_list|(
name|rtree
operator|->
name|rt_root
argument_list|)
expr_stmt|;
name|rtree
operator|->
name|rt_root
operator|=
name|NULL
expr_stmt|;
name|rtree
operator|->
name|rt_height
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

