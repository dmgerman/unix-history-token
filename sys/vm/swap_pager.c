begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 John S. Dyson  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: swap_pager.c 1.4 91/04/30$  *  *	@(#)swap_pager.c	8.9 (Berkeley) 3/21/94  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Quick hack to page to dedicated partition(s).  * TODO:  *	Add multiprocessor locks  *	Deal with async writes in a better fashion  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/rlist.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NPENDINGIO
end_ifndef

begin_define
define|#
directive|define
name|NPENDINGIO
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|swap_pager_input
name|__P
argument_list|(
operator|(
name|sw_pager_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_pager_output
name|__P
argument_list|(
operator|(
name|sw_pager_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswiodone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_pager_full
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vm_swap_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_swap_space
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rlist
modifier|*
name|swaplist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswaplist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_PAGEOUT_CLUSTER
value|8
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|swpclean
argument_list|,
name|swpagerclean
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|swpagerclean
modifier|*
name|swp_clean_t
typedef|;
end_typedef

begin_struct
struct|struct
name|swpagerclean
block|{
name|TAILQ_ENTRY
argument_list|(
argument|swpagerclean
argument_list|)
name|spc_list
expr_stmt|;
name|int
name|spc_flags
decl_stmt|;
name|struct
name|buf
modifier|*
name|spc_bp
decl_stmt|;
name|sw_pager_t
name|spc_swp
decl_stmt|;
name|vm_offset_t
name|spc_kva
decl_stmt|;
name|int
name|spc_count
decl_stmt|;
name|vm_page_t
name|spc_m
index|[
name|MAX_PAGEOUT_CLUSTER
index|]
decl_stmt|;
block|}
name|swcleanlist
index|[
name|NPENDINGIO
index|]
struct|;
end_struct

begin_comment
comment|/* spc_flags values */
end_comment

begin_define
define|#
directive|define
name|SPC_ERROR
value|0x01
end_define

begin_define
define|#
directive|define
name|SWB_EMPTY
value|(-1)
end_define

begin_decl_stmt
name|struct
name|swpclean
name|swap_pager_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of completed page cleans */
end_comment

begin_decl_stmt
name|struct
name|swpclean
name|swap_pager_inuse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of pending page cleans */
end_comment

begin_decl_stmt
name|struct
name|swpclean
name|swap_pager_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of free pager clean structs */
end_comment

begin_decl_stmt
name|struct
name|pagerlst
name|swap_pager_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of "named" anon regions */
end_comment

begin_decl_stmt
name|struct
name|pagerlst
name|swap_pager_un_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of "unnamed" anon pagers */
end_comment

begin_define
define|#
directive|define
name|SWAP_FREE_NEEDED
value|0x1
end_define

begin_comment
comment|/* need a swap block */
end_comment

begin_define
define|#
directive|define
name|SWAP_FREE_NEEDED_BY_PAGEOUT
value|0x2
end_define

begin_decl_stmt
name|int
name|swap_pager_needflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pagerlst
modifier|*
name|swp_qs
index|[]
init|=
block|{
operator|&
name|swap_pager_list
block|,
operator|&
name|swap_pager_un_list
block|,
operator|(
expr|struct
name|pagerlst
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|swap_pager_putmulti
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pagerops
name|swappagerops
init|=
block|{
name|swap_pager_init
block|,
name|swap_pager_alloc
block|,
name|swap_pager_dealloc
block|,
name|swap_pager_getpage
block|,
name|swap_pager_getmulti
block|,
name|swap_pager_putpage
block|,
name|swap_pager_putmulti
block|,
name|swap_pager_haspage
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npendingio
init|=
name|NPENDINGIO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|require_swap_init
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|swap_pager_finish
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|swapsizecheck
parameter_list|()
block|{
if|if
condition|(
name|vm_swap_size
operator|<
literal|128
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
condition|)
block|{
if|if
condition|(
name|swap_pager_full
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"swap_pager: out of swap space\n"
argument_list|)
expr_stmt|;
name|swap_pager_full
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm_swap_size
operator|>
literal|192
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
condition|)
name|swap_pager_full
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_pager_init
parameter_list|()
block|{
name|dfltpagerops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_un_list
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize clean lists 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_done
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
name|require_swap_init
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Calculate the swap allocation constants. 	 */
name|dmmin
operator|=
name|CLBYTES
operator|/
name|DEV_BSIZE
expr_stmt|;
name|dmmax
operator|=
name|btodb
argument_list|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a pager structure and associated resources.  * Note that if we are called from the pageout daemon (handle == NULL)  * we should not wait for memory as it could resulting in deadlock.  */
end_comment

begin_function
name|vm_pager_t
name|swap_pager_alloc
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|,
name|prot
parameter_list|,
name|offset
parameter_list|)
name|void
modifier|*
name|handle
decl_stmt|;
specifier|register
name|vm_size_t
name|size
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|vm_pager_t
name|pager
decl_stmt|;
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|int
name|waitok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|require_swap_init
condition|)
block|{
name|swp_clean_t
name|spc
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 		 * kva's are allocated here so that we dont need to keep doing 		 * kmem_alloc pageables at runtime 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|spc
operator|=
name|swcleanlist
init|;
name|i
operator|<
name|npendingio
condition|;
name|i
operator|++
operator|,
name|spc
operator|++
control|)
block|{
name|spc
operator|->
name|spc_kva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|pager_map
argument_list|,
name|PAGE_SIZE
operator|*
name|MAX_PAGEOUT_CLUSTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spc
operator|->
name|spc_kva
condition|)
block|{
break|break;
block|}
name|spc
operator|->
name|spc_bp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spc
operator|->
name|spc_bp
condition|)
block|{
name|kmem_free_wakeup
argument_list|(
name|pager_map
argument_list|,
name|spc
operator|->
name|spc_kva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
name|spc
operator|->
name|spc_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
block|}
name|require_swap_init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If this is a "named" anonymous region, look it up and return the 	 * appropriate pager if it exists. 	 */
if|if
condition|(
name|handle
condition|)
block|{
name|pager
operator|=
name|vm_pager_lookup
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Use vm_object_lookup to gain a reference to the 			 * object and also to remove from the object cache. 			 */
if|if
condition|(
name|vm_object_lookup
argument_list|(
name|pager
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"swap_pager_alloc: bad object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager
operator|)
return|;
block|}
block|}
comment|/* 	 * Pager doesn't exist, allocate swap management resources and 	 * initialize. 	 */
name|waitok
operator|=
name|handle
condition|?
name|M_WAITOK
else|:
name|M_KERNEL
expr_stmt|;
name|pager
operator|=
operator|(
name|vm_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pager
argument_list|,
name|M_VMPAGER
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_osize
operator|=
name|size
expr_stmt|;
name|swp
operator|->
name|sw_nblocks
operator|=
operator|(
name|btodb
argument_list|(
name|size
argument_list|)
operator|+
name|btodb
argument_list|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|btodb
argument_list|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_blocks
operator|=
operator|(
name|sw_blk_t
operator|)
name|malloc
argument_list|(
name|swp
operator|->
name|sw_nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|swp
operator|->
name|sw_blocks
argument_list|)
argument_list|,
name|M_VMPGDATA
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|swp
operator|->
name|sw_nblocks
condition|;
name|i
operator|++
control|)
block|{
name|swp
operator|->
name|sw_blocks
index|[
name|i
index|]
operator|.
name|swb_valid
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|sw_blocks
index|[
name|i
index|]
operator|.
name|swb_locked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SWB_NPAGES
condition|;
name|j
operator|++
control|)
name|swp
operator|->
name|sw_blocks
index|[
name|i
index|]
operator|.
name|swb_block
index|[
name|j
index|]
operator|=
name|SWB_EMPTY
expr_stmt|;
block|}
name|swp
operator|->
name|sw_poip
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|sw_allocsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|swp
operator|->
name|sw_flags
operator|=
name|SW_NAMED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
comment|/* 		 * Consistant with other pagers: return with object 		 * referenced.  Can't do this with handle == NULL since it 		 * might be the pageout daemon calling. 		 */
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|offset
operator|+
name|size
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator|&=
operator|~
name|OBJ_INTERNAL
expr_stmt|;
name|vm_object_enter
argument_list|(
name|object
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|object
operator|->
name|pager
operator|=
name|pager
expr_stmt|;
block|}
else|else
block|{
name|swp
operator|->
name|sw_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_un_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
block|}
name|pager
operator|->
name|pg_handle
operator|=
name|handle
expr_stmt|;
name|pager
operator|->
name|pg_ops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|pager
operator|->
name|pg_type
operator|=
name|PG_SWAP
expr_stmt|;
name|pager
operator|->
name|pg_data
operator|=
operator|(
name|caddr_t
operator|)
name|swp
expr_stmt|;
return|return
operator|(
name|pager
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns disk block associated with pager and offset  * additionally, as a side effect returns a flag indicating  * if the block has been written  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
modifier|*
name|swap_pager_diskaddr
parameter_list|(
name|swp
parameter_list|,
name|offset
parameter_list|,
name|valid
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|int
modifier|*
name|valid
decl_stmt|;
block|{
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|valid
condition|)
operator|*
name|valid
operator|=
literal|0
expr_stmt|;
name|ix
operator|=
name|offset
operator|/
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
operator|)
operator|||
operator|(
name|offset
operator|>=
name|swp
operator|->
name|sw_osize
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|ix
operator|=
operator|(
name|offset
operator|%
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|valid
condition|)
operator|*
name|valid
operator|=
name|swb
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
expr_stmt|;
return|return
operator|&
name|swb
operator|->
name|swb_block
index|[
name|ix
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Utility routine to set the valid (written) bit for  * a block associated with a pager and offset  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_setvalid
parameter_list|(
name|swp
parameter_list|,
name|offset
parameter_list|,
name|valid
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|int
name|valid
decl_stmt|;
block|{
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|ix
operator|=
name|offset
operator|/
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
return|return;
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|ix
operator|=
operator|(
name|offset
operator|%
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|valid
condition|)
name|swb
operator|->
name|swb_valid
operator||=
operator|(
literal|1
operator|<<
name|ix
operator|)
expr_stmt|;
else|else
name|swb
operator|->
name|swb_valid
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ix
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * this routine allocates swap space with a fragmentation  * minimization policy.  */
end_comment

begin_function
name|int
name|swap_pager_getswapspace
parameter_list|(
name|sw_pager_t
name|swp
parameter_list|,
name|unsigned
name|amount
parameter_list|,
name|unsigned
modifier|*
name|rtval
parameter_list|)
block|{
name|vm_swap_size
operator|-=
name|amount
expr_stmt|;
if|if
condition|(
operator|!
name|rlist_alloc
argument_list|(
operator|&
name|swaplist
argument_list|,
name|amount
argument_list|,
name|rtval
argument_list|)
condition|)
block|{
name|vm_swap_size
operator|+=
name|amount
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|swapsizecheck
argument_list|()
expr_stmt|;
name|swp
operator|->
name|sw_allocsize
operator|+=
name|amount
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine frees swap space with a fragmentation  * minimization policy.  */
end_comment

begin_function
name|void
name|swap_pager_freeswapspace
parameter_list|(
name|sw_pager_t
name|swp
parameter_list|,
name|unsigned
name|from
parameter_list|,
name|unsigned
name|to
parameter_list|)
block|{
name|rlist_free
argument_list|(
operator|&
name|swaplist
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|vm_swap_size
operator|+=
operator|(
name|to
operator|-
name|from
operator|)
operator|+
literal|1
expr_stmt|;
name|swp
operator|->
name|sw_allocsize
operator|-=
operator|(
name|to
operator|-
name|from
operator|)
operator|+
literal|1
expr_stmt|;
name|swapsizecheck
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine frees swap blocks from a specified pager  */
end_comment

begin_function
name|void
name|_swap_pager_freespace
parameter_list|(
name|swp
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
block|{
name|vm_offset_t
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|round_page
argument_list|(
name|start
operator|+
name|size
argument_list|)
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
name|int
name|valid
decl_stmt|;
name|int
modifier|*
name|addr
init|=
name|swap_pager_diskaddr
argument_list|(
name|swp
argument_list|,
name|i
argument_list|,
operator|&
name|valid
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|&&
operator|*
name|addr
operator|!=
name|SWB_EMPTY
condition|)
block|{
name|swap_pager_freeswapspace
argument_list|(
name|swp
argument_list|,
operator|*
name|addr
argument_list|,
operator|*
name|addr
operator|+
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|swap_pager_setvalid
argument_list|(
name|swp
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|addr
operator|=
name|SWB_EMPTY
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_pager_freespace
parameter_list|(
name|pager
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
block|{
name|_swap_pager_freespace
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_pager_free_swap
parameter_list|(
name|swp
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|sw_blk_t
name|bp
decl_stmt|;
name|int
name|first_block
init|=
literal|0
decl_stmt|,
name|block_count
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Free left over swap blocks 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|swp
operator|->
name|sw_blocks
init|;
name|i
operator|<
name|swp
operator|->
name|sw_nblocks
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SWB_NPAGES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
operator|!=
name|SWB_EMPTY
condition|)
block|{
comment|/* 				 * initially the length of the run is zero 				 */
if|if
condition|(
name|block_count
operator|==
literal|0
condition|)
block|{
name|first_block
operator|=
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
expr_stmt|;
name|block_count
operator|=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
operator|=
name|SWB_EMPTY
expr_stmt|;
comment|/* 				 * if the new block can be included into the current run 				 */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
operator|==
name|first_block
operator|+
name|block_count
condition|)
block|{
name|block_count
operator|+=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
operator|=
name|SWB_EMPTY
expr_stmt|;
comment|/* 				 * terminate the previous run, and start a new one 				 */
block|}
else|else
block|{
name|swap_pager_freeswapspace
argument_list|(
name|swp
argument_list|,
name|first_block
argument_list|,
operator|(
name|unsigned
operator|)
name|first_block
operator|+
name|block_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first_block
operator|=
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
expr_stmt|;
name|block_count
operator|=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|swb_block
index|[
name|j
index|]
operator|=
name|SWB_EMPTY
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|block_count
condition|)
block|{
name|swap_pager_freeswapspace
argument_list|(
name|swp
argument_list|,
name|first_block
argument_list|,
operator|(
name|unsigned
operator|)
name|first_block
operator|+
name|block_count
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_reclaim frees up over-allocated space from all pagers  * this eliminates internal fragmentation due to allocation of space  * for segments that are never swapped to. It has been written so that  * it does not block until the rlist_free operation occurs; it keeps  * the queues consistant.  */
end_comment

begin_comment
comment|/*  * Maximum number of blocks (pages) to reclaim per pass  */
end_comment

begin_define
define|#
directive|define
name|MAXRECLAIM
value|128
end_define

begin_function
name|void
name|swap_pager_reclaim
parameter_list|()
block|{
name|vm_pager_t
name|p
decl_stmt|;
name|sw_pager_t
name|swp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|reclaimcount
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|address
decl_stmt|;
name|sw_pager_t
name|pager
decl_stmt|;
block|}
name|reclaims
index|[
name|MAXRECLAIM
index|]
struct|;
specifier|static
name|int
name|in_reclaim
decl_stmt|;
comment|/* 	 * allow only one process to be in the swap_pager_reclaim subroutine 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_reclaim
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|in_reclaim
argument_list|,
name|PSWP
argument_list|,
literal|"swrclm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|in_reclaim
operator|=
literal|1
expr_stmt|;
name|reclaimcount
operator|=
literal|0
expr_stmt|;
comment|/* for each pager queue */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|swp_qs
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|=
name|swp_qs
index|[
name|k
index|]
operator|->
name|tqh_first
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|(
name|reclaimcount
operator|<
name|MAXRECLAIM
operator|)
condition|)
block|{
comment|/* 			 * see if any blocks associated with a pager has been 			 * allocated but not used (written) 			 */
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|p
operator|->
name|pg_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|swp
operator|->
name|sw_nblocks
condition|;
name|i
operator|++
control|)
block|{
name|sw_blk_t
name|swb
init|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_locked
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SWB_NPAGES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|swb
operator|->
name|swb_block
index|[
name|j
index|]
operator|!=
name|SWB_EMPTY
operator|&&
operator|(
name|swb
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|reclaims
index|[
name|reclaimcount
index|]
operator|.
name|address
operator|=
name|swb
operator|->
name|swb_block
index|[
name|j
index|]
expr_stmt|;
name|reclaims
index|[
name|reclaimcount
operator|++
index|]
operator|.
name|pager
operator|=
name|swp
expr_stmt|;
name|swb
operator|->
name|swb_block
index|[
name|j
index|]
operator|=
name|SWB_EMPTY
expr_stmt|;
if|if
condition|(
name|reclaimcount
operator|>=
name|MAXRECLAIM
condition|)
goto|goto
name|rfinished
goto|;
block|}
block|}
block|}
name|p
operator|=
name|p
operator|->
name|pg_list
operator|.
name|tqe_next
expr_stmt|;
block|}
block|}
name|rfinished
label|:
comment|/* 	 * free the blocks that have been added to the reclaim list 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reclaimcount
condition|;
name|i
operator|++
control|)
block|{
name|swap_pager_freeswapspace
argument_list|(
name|reclaims
index|[
name|i
index|]
operator|.
name|pager
argument_list|,
name|reclaims
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|reclaims
index|[
name|i
index|]
operator|.
name|address
operator|+
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|in_reclaim
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|in_reclaim
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_copy copies blocks from one pager to another and  * destroys the source pager  */
end_comment

begin_function
name|void
name|swap_pager_copy
parameter_list|(
name|srcpager
parameter_list|,
name|srcoffset
parameter_list|,
name|dstpager
parameter_list|,
name|dstoffset
parameter_list|,
name|offset
parameter_list|)
name|vm_pager_t
name|srcpager
decl_stmt|;
name|vm_offset_t
name|srcoffset
decl_stmt|;
name|vm_pager_t
name|dstpager
decl_stmt|;
name|vm_offset_t
name|dstoffset
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
name|sw_pager_t
name|srcswp
decl_stmt|,
name|dstswp
decl_stmt|;
name|vm_offset_t
name|i
decl_stmt|;
name|int
name|origsize
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vm_swap_size
condition|)
name|no_swap_space
operator|=
literal|0
expr_stmt|;
name|srcswp
operator|=
operator|(
name|sw_pager_t
operator|)
name|srcpager
operator|->
name|pg_data
expr_stmt|;
name|origsize
operator|=
name|srcswp
operator|->
name|sw_allocsize
expr_stmt|;
name|dstswp
operator|=
operator|(
name|sw_pager_t
operator|)
name|dstpager
operator|->
name|pg_data
expr_stmt|;
comment|/* 	 * remove the source pager from the swap_pager internal queue 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcswp
operator|->
name|sw_flags
operator|&
name|SW_NAMED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|srcpager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
name|srcswp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_NAMED
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_un_list
argument_list|,
name|srcpager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|srcswp
operator|->
name|sw_poip
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|srcswp
argument_list|,
name|PVM
argument_list|,
literal|"spgout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * clean all of the pages that are currently active and finished 	 */
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * transfer source to destination 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dstswp
operator|->
name|sw_osize
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
block|{
name|int
name|srcvalid
decl_stmt|,
name|dstvalid
decl_stmt|;
name|int
modifier|*
name|srcaddrp
init|=
name|swap_pager_diskaddr
argument_list|(
name|srcswp
argument_list|,
name|i
operator|+
name|offset
operator|+
name|srcoffset
argument_list|,
operator|&
name|srcvalid
argument_list|)
decl_stmt|;
name|int
modifier|*
name|dstaddrp
decl_stmt|;
comment|/* 		 * see if the source has space allocated 		 */
if|if
condition|(
name|srcaddrp
operator|&&
operator|*
name|srcaddrp
operator|!=
name|SWB_EMPTY
condition|)
block|{
comment|/* 			 * if the source is valid and the dest has no space, 			 * then copy the allocation from the srouce to the 			 * dest. 			 */
if|if
condition|(
name|srcvalid
condition|)
block|{
name|dstaddrp
operator|=
name|swap_pager_diskaddr
argument_list|(
name|dstswp
argument_list|,
name|i
operator|+
name|dstoffset
argument_list|,
operator|&
name|dstvalid
argument_list|)
expr_stmt|;
comment|/* 				 * if the dest already has a valid block, 				 * deallocate the source block without 				 * copying. 				 */
if|if
condition|(
operator|!
name|dstvalid
operator|&&
name|dstaddrp
operator|&&
operator|*
name|dstaddrp
operator|!=
name|SWB_EMPTY
condition|)
block|{
name|swap_pager_freeswapspace
argument_list|(
name|dstswp
argument_list|,
operator|*
name|dstaddrp
argument_list|,
operator|*
name|dstaddrp
operator|+
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dstaddrp
operator|=
name|SWB_EMPTY
expr_stmt|;
block|}
if|if
condition|(
name|dstaddrp
operator|&&
operator|*
name|dstaddrp
operator|==
name|SWB_EMPTY
condition|)
block|{
operator|*
name|dstaddrp
operator|=
operator|*
name|srcaddrp
expr_stmt|;
operator|*
name|srcaddrp
operator|=
name|SWB_EMPTY
expr_stmt|;
name|dstswp
operator|->
name|sw_allocsize
operator|+=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|srcswp
operator|->
name|sw_allocsize
operator|-=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|swap_pager_setvalid
argument_list|(
name|dstswp
argument_list|,
name|i
operator|+
name|dstoffset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * if the source is not empty at this point, then 			 * deallocate the space. 			 */
if|if
condition|(
operator|*
name|srcaddrp
operator|!=
name|SWB_EMPTY
condition|)
block|{
name|swap_pager_freeswapspace
argument_list|(
name|srcswp
argument_list|,
operator|*
name|srcaddrp
argument_list|,
operator|*
name|srcaddrp
operator|+
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|srcaddrp
operator|=
name|SWB_EMPTY
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Free left over swap blocks 	 */
name|swap_pager_free_swap
argument_list|(
name|srcswp
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcswp
operator|->
name|sw_allocsize
condition|)
name|printf
argument_list|(
literal|"swap_pager_copy: *warning* pager with %d blocks (orig: %d)\n"
argument_list|,
name|srcswp
operator|->
name|sw_allocsize
argument_list|,
name|origsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|srcswp
operator|->
name|sw_blocks
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|srcswp
operator|->
name|sw_blocks
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|srcswp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|srcpager
operator|->
name|pg_data
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|srcpager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|swap_pager_dealloc
parameter_list|(
name|pager
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
block|{
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Remove from list right away so lookups will fail if we block for 	 * pageout completion. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_flags
operator|&
name|SW_NAMED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_NAMED
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_un_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for all pageouts to finish and remove all entries from 	 * cleaning list. 	 */
while|while
condition|(
name|swp
operator|->
name|sw_poip
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|PVM
argument_list|,
literal|"swpout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
comment|/* 	 * Free left over swap blocks 	 */
name|swap_pager_free_swap
argument_list|(
name|swp
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_allocsize
condition|)
name|printf
argument_list|(
literal|"swap_pager_dealloc: *warning* freeing pager with %d blocks\n"
argument_list|,
name|swp
operator|->
name|sw_allocsize
argument_list|)
expr_stmt|;
comment|/* 	 * Free swap management resources 	 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
operator|->
name|sw_blocks
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_blocks
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|pager
operator|->
name|pg_data
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_getmulti can get multiple pages.  */
end_comment

begin_function
name|int
name|swap_pager_getmulti
parameter_list|(
name|pager
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|,
name|reqpage
parameter_list|,
name|sync
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|reqpage
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
block|{
if|if
condition|(
name|reqpage
operator|>=
name|count
condition|)
name|panic
argument_list|(
literal|"swap_pager_getmulti: reqpage>= count"
argument_list|)
expr_stmt|;
return|return
name|swap_pager_input
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_getpage gets individual pages  */
end_comment

begin_function
name|int
name|swap_pager_getpage
parameter_list|(
name|pager
parameter_list|,
name|m
parameter_list|,
name|sync
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
block|{
name|vm_page_t
name|marray
index|[
literal|1
index|]
decl_stmt|;
name|marray
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
return|return
name|swap_pager_input
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|marray
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|swap_pager_putmulti
parameter_list|(
name|pager
parameter_list|,
name|m
parameter_list|,
name|c
parameter_list|,
name|sync
parameter_list|,
name|rtvals
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
name|int
modifier|*
name|rtvals
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
return|return
name|VM_PAGER_OK
return|;
block|}
name|flags
operator|=
name|B_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
name|flags
operator||=
name|B_ASYNC
expr_stmt|;
return|return
name|swap_pager_output
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|m
argument_list|,
name|c
argument_list|,
name|flags
argument_list|,
name|rtvals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_putpage writes individual pages  */
end_comment

begin_function
name|int
name|swap_pager_putpage
parameter_list|(
name|pager
parameter_list|,
name|m
parameter_list|,
name|sync
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|vm_page_t
name|marray
index|[
literal|1
index|]
decl_stmt|;
name|int
name|rtvals
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
return|return
name|VM_PAGER_OK
return|;
block|}
name|marray
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|flags
operator|=
name|B_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
name|flags
operator||=
name|B_ASYNC
expr_stmt|;
name|swap_pager_output
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|marray
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|,
name|rtvals
argument_list|)
expr_stmt|;
return|return
name|rtvals
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
specifier|const
name|swap_pager_block_index
parameter_list|(
name|swp
parameter_list|,
name|offset
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
return|return
operator|(
name|offset
operator|/
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
specifier|const
name|swap_pager_block_offset
parameter_list|(
name|swp
parameter_list|,
name|offset
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|offset
operator|%
operator|(
name|PAGE_SIZE
operator|*
name|SWB_NPAGES
operator|)
operator|)
operator|/
name|PAGE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _swap_pager_haspage returns TRUE if the pager has data that has  * been written out.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|_swap_pager_haspage
parameter_list|(
name|swp
parameter_list|,
name|offset
parameter_list|)
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|ix
operator|=
name|offset
operator|/
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|ix
operator|=
operator|(
name|offset
operator|%
operator|(
name|SWB_NPAGES
operator|*
name|PAGE_SIZE
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_block
index|[
name|ix
index|]
operator|!=
name|SWB_EMPTY
condition|)
block|{
if|if
condition|(
name|swb
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_haspage is the externally accessible version of  * _swap_pager_haspage above.  this routine takes a vm_pager_t  * for an argument instead of sw_pager_t.  */
end_comment

begin_function
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|pager
parameter_list|,
name|offset
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
return|return
name|_swap_pager_haspage
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_freepage is a convienience routine that clears the busy  * bit and deallocates a page.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_freepage
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_ridpages is a convienience routine that deallocates all  * but the required page.  this is usually used in error returns that  * need to invalidate the "extra" readahead pages.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_ridpages
parameter_list|(
name|m
parameter_list|,
name|count
parameter_list|,
name|reqpage
parameter_list|)
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|reqpage
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|reqpage
condition|)
name|swap_pager_freepage
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_iodone1 is the completion routine for both reads and async writes  */
end_comment

begin_function
name|void
name|swap_pager_iodone1
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|swap_pager_input
parameter_list|(
name|swp
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|,
name|reqpage
parameter_list|)
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|,
name|reqpage
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|sw_blk_t
name|swb
index|[
name|count
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|,
name|off
index|[
name|count
index|]
decl_stmt|;
name|swp_clean_t
name|spc
decl_stmt|;
name|vm_offset_t
name|paging_offset
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|reqaddr
index|[
name|count
index|]
decl_stmt|;
name|int
name|sequential
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|failed
decl_stmt|;
name|int
name|reqdskregion
decl_stmt|;
name|object
operator|=
name|m
index|[
name|reqpage
index|]
operator|->
name|object
expr_stmt|;
name|paging_offset
operator|=
name|object
operator|->
name|paging_offset
expr_stmt|;
name|sequential
operator|=
operator|(
name|m
index|[
name|reqpage
index|]
operator|->
name|offset
operator|==
operator|(
name|object
operator|->
name|last_read
operator|+
name|PAGE_SIZE
operator|)
operator|)
expr_stmt|;
comment|/* 	 * First determine if the page exists in the pager if this is a sync 	 * read.  This quickly handles cases where we are following shadow 	 * chains looking for the top level object with the page. 	 */
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
condition|)
block|{
name|swap_pager_ridpages
argument_list|(
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|foff
init|=
name|m
index|[
name|i
index|]
operator|->
name|offset
operator|+
name|paging_offset
decl_stmt|;
name|int
name|ix
init|=
name|swap_pager_block_index
argument_list|(
name|swp
argument_list|,
name|foff
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|<=
name|reqpage
condition|)
block|{
name|swap_pager_ridpages
argument_list|(
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|swap_pager_freepage
argument_list|(
name|m
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|swb
index|[
name|i
index|]
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|off
index|[
name|i
index|]
operator|=
name|swap_pager_block_offset
argument_list|(
name|swp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
name|reqaddr
index|[
name|i
index|]
operator|=
name|swb
index|[
name|i
index|]
operator|->
name|swb_block
index|[
name|off
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* make sure that our required input request is existant */
if|if
condition|(
name|reqaddr
index|[
name|reqpage
index|]
operator|==
name|SWB_EMPTY
operator|||
operator|(
name|swb
index|[
name|reqpage
index|]
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|off
index|[
name|reqpage
index|]
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|swap_pager_ridpages
argument_list|(
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
name|reqdskregion
operator|=
name|reqaddr
index|[
name|reqpage
index|]
operator|/
name|dmmax
expr_stmt|;
comment|/* 	 * search backwards for the first contiguous page to transfer 	 */
name|failed
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reqpage
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|sequential
operator|||
name|failed
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|==
name|SWB_EMPTY
operator|)
operator|||
operator|(
name|swb
index|[
name|i
index|]
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|off
index|[
name|i
index|]
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|!=
operator|(
name|reqaddr
index|[
name|reqpage
index|]
operator|+
operator|(
name|i
operator|-
name|reqpage
operator|)
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|reqaddr
index|[
name|i
index|]
operator|/
name|dmmax
operator|)
operator|!=
name|reqdskregion
operator|)
condition|)
block|{
name|failed
operator|=
literal|1
expr_stmt|;
name|swap_pager_freepage
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * search forwards for the last contiguous page to transfer 	 */
name|failed
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reqpage
operator|+
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|failed
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|==
name|SWB_EMPTY
operator|)
operator|||
operator|(
name|swb
index|[
name|i
index|]
operator|->
name|swb_valid
operator|&
operator|(
literal|1
operator|<<
name|off
index|[
name|i
index|]
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|!=
operator|(
name|reqaddr
index|[
name|reqpage
index|]
operator|+
operator|(
name|i
operator|-
name|reqpage
operator|)
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|reqaddr
index|[
name|i
index|]
operator|/
name|dmmax
operator|)
operator|!=
name|reqdskregion
operator|)
condition|)
block|{
name|failed
operator|=
literal|1
expr_stmt|;
name|swap_pager_freepage
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|count
condition|)
name|last
operator|=
name|i
expr_stmt|;
block|}
block|}
name|count
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|first
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
index|[
name|i
operator|-
name|first
index|]
operator|=
name|m
index|[
name|i
index|]
expr_stmt|;
name|reqaddr
index|[
name|i
operator|-
name|first
index|]
operator|=
name|reqaddr
index|[
name|i
index|]
expr_stmt|;
name|off
index|[
name|i
operator|-
name|first
index|]
operator|=
name|off
index|[
name|i
index|]
expr_stmt|;
block|}
name|count
operator|-=
name|first
expr_stmt|;
name|reqpage
operator|-=
name|first
expr_stmt|;
block|}
operator|++
name|swb
index|[
name|reqpage
index|]
operator|->
name|swb_locked
expr_stmt|;
comment|/* 	 * at this point: "m" is a pointer to the array of vm_page_t for 	 * paging I/O "count" is the number of vm_page_t entries represented 	 * by "m" "object" is the vm_object_t for I/O "reqpage" is the index 	 * into "m" for the page actually faulted 	 */
name|spc
operator|=
name|NULL
expr_stmt|;
comment|/* we might not use an spc data structure */
if|if
condition|(
operator|(
name|count
operator|==
literal|1
operator|)
operator|&&
operator|(
name|swap_pager_free
operator|.
name|tqh_first
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * if a kva has not been allocated, we can only do a one page 		 * transfer, so we free the other pages that might have been 		 * allocated by vm_fault. 		 */
name|swap_pager_ridpages
argument_list|(
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
expr_stmt|;
name|m
index|[
literal|0
index|]
operator|=
name|m
index|[
name|reqpage
index|]
expr_stmt|;
name|reqaddr
index|[
literal|0
index|]
operator|=
name|reqaddr
index|[
name|reqpage
index|]
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|reqpage
operator|=
literal|0
expr_stmt|;
comment|/* 		 * get a swap pager clean data structure, block until we get 		 * it 		 */
if|if
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
else|else
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
while|while
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
block|{
name|swap_pager_needflags
operator||=
name|SWAP_FREE_NEEDED
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
name|swap_pager_needflags
operator||=
name|SWAP_FREE_NEEDED_BY_PAGEOUT
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|,
name|PVM
argument_list|,
literal|"swpfre"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
else|else
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|spc
operator|=
name|swap_pager_free
operator|.
name|tqh_first
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|kva
operator|=
name|spc
operator|->
name|spc_kva
expr_stmt|;
name|bp
operator|=
name|spc
operator|->
name|spc_bp
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_spc
operator|=
name|spc
expr_stmt|;
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
operator|=
name|NOLIST
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get a swap buffer header to perform the IO 		 */
name|bp
operator|=
name|getpbuf
argument_list|()
expr_stmt|;
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
block|}
comment|/* 	 * map our page(s) into kva for input 	 */
name|pmap_qenter
argument_list|(
name|kva
argument_list|,
name|m
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
operator||
name|B_CALL
operator||
name|B_PAGING
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swap_pager_iodone1
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
operator|&
name|proc0
expr_stmt|;
comment|/* XXX (but without B_PHYS set this is ok) */
name|bp
operator|->
name|b_rcred
operator|=
name|bp
operator|->
name|b_wcred
operator|=
name|bp
operator|->
name|b_proc
operator|->
name|p_ucred
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|reqaddr
index|[
literal|0
index|]
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|pbgetvp
argument_list|(
name|swapdev_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_swapin
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsin
operator|+=
name|count
expr_stmt|;
comment|/* 	 * perform the I/O 	 */
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * wait for the sync I/O to complete 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: I/O error - pagein failed; blkno %d, size %d, error %d\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
name|rv
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|VM_PAGER_OK
expr_stmt|;
block|}
comment|/* 	 * relpbuf does this, but we maintain our own buffer list also... 	 */
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|pbrelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|--
name|swb
index|[
name|reqpage
index|]
operator|->
name|swb_locked
expr_stmt|;
comment|/* 	 * remove the mapping for kernel virtual 	 */
name|pmap_qremove
argument_list|(
name|kva
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|spc
condition|)
block|{
name|m
index|[
name|reqpage
index|]
operator|->
name|object
operator|->
name|last_read
operator|=
name|m
index|[
name|reqpage
index|]
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * if we have used an spc, we need to free it. 		 */
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED_BY_PAGEOUT
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
name|swap_pager_needflags
operator|&=
operator|~
operator|(
name|SWAP_FREE_NEEDED
operator||
name|SWAP_FREE_NEEDED_BY_PAGEOUT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * release the physical I/O buffer 		 */
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * finish up input if everything is ok 		 */
if|if
condition|(
name|rv
operator|==
name|VM_PAGER_OK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|m
index|[
name|i
index|]
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|reqpage
condition|)
block|{
comment|/* 					 * whether or not to leave the page 					 * activated is up in the air, but we 					 * should put the page on a page queue 					 * somewhere. (it already is in the 					 * object). After some emperical 					 * results, it is best to deactivate 					 * the readahead pages. 					 */
name|vm_page_deactivate
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 					 * just in case someone was asking for 					 * this page we now tell them that it 					 * is ok to use 					 */
name|m
index|[
name|i
index|]
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|m
index|[
name|reqpage
index|]
operator|->
name|object
operator|->
name|last_read
operator|=
name|m
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|offset
expr_stmt|;
comment|/* 			 * If we're out of swap space, then attempt to free 			 * some whenever pages are brought in. We must clear 			 * the clean flag so that the page contents will be 			 * preserved. 			 */
if|if
condition|(
name|swap_pager_full
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
index|[
name|i
index|]
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|_swap_pager_freespace
argument_list|(
name|swp
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|offset
operator|+
name|paging_offset
argument_list|,
name|count
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|swap_pager_ridpages
argument_list|(
name|m
argument_list|,
name|count
argument_list|,
name|reqpage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|swap_pager_output
parameter_list|(
name|swp
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|,
name|flags
parameter_list|,
name|rtvals
parameter_list|)
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
modifier|*
name|rtvals
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|sw_blk_t
name|swb
index|[
name|count
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ix
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|,
name|off
decl_stmt|,
name|foff
decl_stmt|;
name|swp_clean_t
name|spc
decl_stmt|;
name|vm_offset_t
name|paging_offset
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|reqaddr
index|[
name|count
index|]
decl_stmt|;
name|int
name|failed
decl_stmt|;
if|if
condition|(
name|vm_swap_size
condition|)
name|no_swap_space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_swap_space
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|rtvals
index|[
name|i
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
return|return
name|VM_PAGER_FAIL
return|;
block|}
name|spc
operator|=
name|NULL
expr_stmt|;
name|object
operator|=
name|m
index|[
literal|0
index|]
operator|->
name|object
expr_stmt|;
name|paging_offset
operator|=
name|object
operator|->
name|paging_offset
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|foff
operator|=
name|m
index|[
name|j
index|]
operator|->
name|offset
operator|+
name|paging_offset
expr_stmt|;
name|ix
operator|=
name|swap_pager_block_index
argument_list|(
name|swp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
name|swb
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
name|rtvals
index|[
name|j
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rtvals
index|[
name|j
index|]
operator|=
name|VM_PAGER_OK
expr_stmt|;
block|}
name|swb
index|[
name|j
index|]
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
operator|++
name|swb
index|[
name|j
index|]
operator|->
name|swb_locked
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|rtvals
index|[
name|j
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|swap_pager_block_offset
argument_list|(
name|swp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
name|reqaddr
index|[
name|j
index|]
operator|=
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|reqaddr
index|[
name|j
index|]
operator|==
name|SWB_EMPTY
condition|)
block|{
name|int
name|blk
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|ntoget
decl_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 			 * if any other pages have been allocated in this 			 * block, we only try to get one page. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWB_NPAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|i
index|]
operator|!=
name|SWB_EMPTY
condition|)
break|break;
block|}
name|ntoget
operator|=
operator|(
name|i
operator|==
name|SWB_NPAGES
operator|)
condition|?
name|SWB_NPAGES
else|:
literal|1
expr_stmt|;
comment|/* 			 * this code is alittle conservative, but works (the 			 * intent of this code is to allocate small chunks for 			 * small objects) 			 */
if|if
condition|(
operator|(
name|foff
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ntoget
operator|*
name|PAGE_SIZE
operator|)
operator|>
name|object
operator|->
name|size
operator|)
condition|)
block|{
name|ntoget
operator|=
operator|(
name|object
operator|->
name|size
operator|+
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
name|retrygetspace
label|:
if|if
condition|(
operator|!
name|swap_pager_full
operator|&&
name|ntoget
operator|>
literal|1
operator|&&
name|swap_pager_getswapspace
argument_list|(
name|swp
argument_list|,
name|ntoget
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
argument_list|,
operator|&
name|blk
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntoget
condition|;
name|i
operator|++
control|)
block|{
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|i
index|]
operator|=
name|blk
operator|+
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|*
name|i
expr_stmt|;
name|swb
index|[
name|j
index|]
operator|->
name|swb_valid
operator|=
literal|0
expr_stmt|;
block|}
name|reqaddr
index|[
name|j
index|]
operator|=
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|off
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|swap_pager_getswapspace
argument_list|(
name|swp
argument_list|,
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
argument_list|,
operator|&
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|off
index|]
argument_list|)
condition|)
block|{
comment|/* 				 * if the allocation has failed, we try to 				 * reclaim space and retry. 				 */
if|if
condition|(
operator|++
name|tries
operator|==
literal|1
condition|)
block|{
name|swap_pager_reclaim
argument_list|()
expr_stmt|;
goto|goto
name|retrygetspace
goto|;
block|}
name|rtvals
index|[
name|j
index|]
operator|=
name|VM_PAGER_AGAIN
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
name|swap_pager_full
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|reqaddr
index|[
name|j
index|]
operator|=
name|swb
index|[
name|j
index|]
operator|->
name|swb_block
index|[
name|off
index|]
expr_stmt|;
name|swb
index|[
name|j
index|]
operator|->
name|swb_valid
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|off
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * search forwards for the last contiguous page to transfer 	 */
name|failed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|failed
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|!=
name|reqaddr
index|[
literal|0
index|]
operator|+
name|i
operator|*
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|)
operator|||
operator|(
name|reqaddr
index|[
name|i
index|]
operator|/
name|dmmax
operator|)
operator|!=
operator|(
name|reqaddr
index|[
literal|0
index|]
operator|/
name|dmmax
operator|)
operator|||
operator|(
name|rtvals
index|[
name|i
index|]
operator|!=
name|VM_PAGER_OK
operator|)
condition|)
block|{
name|failed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtvals
index|[
name|i
index|]
operator|==
name|VM_PAGER_OK
condition|)
name|rtvals
index|[
name|i
index|]
operator|=
name|VM_PAGER_AGAIN
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rtvals
index|[
name|i
index|]
operator|!=
name|VM_PAGER_OK
condition|)
block|{
if|if
condition|(
name|swb
index|[
name|i
index|]
condition|)
operator|--
name|swb
index|[
name|i
index|]
operator|->
name|swb_locked
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtvals
index|[
name|i
index|]
operator|!=
name|VM_PAGER_OK
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
name|VM_PAGER_AGAIN
return|;
block|}
name|count
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reqaddr
index|[
name|i
index|]
operator|==
name|SWB_EMPTY
condition|)
name|printf
argument_list|(
literal|"I/O to empty block????\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For synchronous writes, we clean up all completed async pageouts. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|swap_pager_clean
argument_list|()
expr_stmt|;
block|}
name|kva
operator|=
literal|0
expr_stmt|;
comment|/* 	 * get a swap pager clean data structure, block until we get it 	 */
if|if
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
operator|||
name|swap_pager_free
operator|.
name|tqh_first
operator|->
name|spc_list
operator|.
name|tqe_next
operator|==
name|NULL
operator|||
name|swap_pager_free
operator|.
name|tqh_first
operator|->
name|spc_list
operator|.
name|tqe_next
operator|->
name|spc_list
operator|.
name|tqe_next
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
block|{
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|splx(s); 			return VM_PAGER_AGAIN;
endif|#
directive|endif
block|}
else|else
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
while|while
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
operator|||
name|swap_pager_free
operator|.
name|tqh_first
operator|->
name|spc_list
operator|.
name|tqe_next
operator|==
name|NULL
operator|||
name|swap_pager_free
operator|.
name|tqh_first
operator|->
name|spc_list
operator|.
name|tqe_next
operator|->
name|spc_list
operator|.
name|tqe_next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
block|{
name|swap_pager_needflags
operator||=
name|SWAP_FREE_NEEDED_BY_PAGEOUT
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|>
name|cnt
operator|.
name|v_free_reserved
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
block|}
name|swap_pager_needflags
operator||=
name|SWAP_FREE_NEEDED
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|,
name|PVM
argument_list|,
literal|"swpfre"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|()
expr_stmt|;
else|else
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|spc
operator|=
name|swap_pager_free
operator|.
name|tqh_first
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|kva
operator|=
name|spc
operator|->
name|spc_kva
expr_stmt|;
comment|/* 	 * map our page(s) into kva for I/O 	 */
name|pmap_qenter
argument_list|(
name|kva
argument_list|,
name|m
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * get the base I/O offset into the swap file 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|foff
operator|=
name|m
index|[
name|i
index|]
operator|->
name|offset
operator|+
name|paging_offset
expr_stmt|;
name|off
operator|=
name|swap_pager_block_offset
argument_list|(
name|swp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
comment|/* 		 * set the valid bit 		 */
name|swb
index|[
name|i
index|]
operator|->
name|swb_valid
operator||=
operator|(
literal|1
operator|<<
name|off
operator|)
expr_stmt|;
comment|/* 		 * and unlock the data structure 		 */
operator|--
name|swb
index|[
name|i
index|]
operator|->
name|swb_locked
expr_stmt|;
block|}
comment|/* 	 * Get a swap buffer header and perform the IO 	 */
name|bp
operator|=
name|spc
operator|->
name|spc_bp
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_spc
operator|=
name|spc
expr_stmt|;
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
operator|=
name|NOLIST
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_PAGING
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
operator|&
name|proc0
expr_stmt|;
comment|/* XXX (but without B_PHYS set this is ok) */
name|bp
operator|->
name|b_rcred
operator|=
name|bp
operator|->
name|b_wcred
operator|=
name|bp
operator|->
name|b_proc
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|reqaddr
index|[
literal|0
index|]
expr_stmt|;
name|pbgetvp
argument_list|(
name|swapdev_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|swapdev_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
comment|/* 	 * If this is an async write we set up additional buffer fields and 	 * place a "cleaning" entry on the inuse queue. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|B_ASYNC
condition|)
block|{
name|spc
operator|->
name|spc_flags
operator|=
literal|0
expr_stmt|;
name|spc
operator|->
name|spc_swp
operator|=
name|swp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
operator|=
name|m
index|[
name|i
index|]
expr_stmt|;
name|spc
operator|->
name|spc_count
operator|=
name|count
expr_stmt|;
comment|/* 		 * the completion routine for async writes 		 */
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swap_pager_iodone
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|swp
operator|->
name|sw_poip
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swp
operator|->
name|sw_poip
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swap_pager_iodone1
expr_stmt|;
block|}
name|cnt
operator|.
name|v_swapout
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsout
operator|+=
name|count
expr_stmt|;
comment|/* 	 * perform the I/O 	 */
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|B_READ
operator||
name|B_ASYNC
operator|)
operator|)
operator|==
name|B_ASYNC
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
name|B_DONE
condition|)
block|{
name|swap_pager_clean
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtvals
index|[
name|i
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
block|}
return|return
name|VM_PAGER_PEND
return|;
block|}
comment|/* 	 * wait for the sync I/O to complete 	 */
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swwrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: I/O error - pageout failed; blkno %d, size %d, error %d\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
name|rv
operator|=
name|VM_PAGER_ERROR
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|VM_PAGER_OK
expr_stmt|;
block|}
operator|--
name|swp
operator|->
name|sw_poip
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_poip
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|pbrelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * remove the mapping for kernel virtual 	 */
name|pmap_qremove
argument_list|(
name|kva
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * if we have written the page, then indicate that the page is clean. 	 */
if|if
condition|(
name|rv
operator|==
name|VM_PAGER_OK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rtvals
index|[
name|i
index|]
operator|==
name|VM_PAGER_OK
condition|)
block|{
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|m
index|[
name|i
index|]
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
comment|/* 				 * optimization, if a page has been read 				 * during the pageout process, we activate it. 				 */
if|if
condition|(
operator|(
name|m
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_ACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|m
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|PG_WANTED
operator||
name|PG_REFERENCED
operator|)
operator|)
operator|||
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtvals
index|[
name|i
index|]
operator|=
name|rv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED_BY_PAGEOUT
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
name|swap_pager_needflags
operator|&=
operator|~
operator|(
name|SWAP_FREE_NEEDED
operator||
name|SWAP_FREE_NEEDED_BY_PAGEOUT
operator|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|swap_pager_clean
parameter_list|()
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|,
name|tspc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|tspc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|swap_pager_done
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 		 * Look up and removal from done list must be done at splbio() 		 * to avoid conflicts with swap_pager_iodone. 		 */
while|while
condition|(
operator|(
name|spc
operator|=
name|swap_pager_done
operator|.
name|tqh_first
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap_qremove
argument_list|(
name|spc
operator|->
name|spc_kva
argument_list|,
name|spc
operator|->
name|spc_count
argument_list|)
expr_stmt|;
name|swap_pager_finish
argument_list|(
name|spc
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_done
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
goto|goto
name|doclean
goto|;
block|}
comment|/* 		 * No operations done, thats all we can do for now. 		 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * The desired page was found to be busy earlier in the scan 		 * but has since completed. 		 */
name|doclean
label|:
if|if
condition|(
name|tspc
operator|&&
name|tspc
operator|==
name|spc
condition|)
block|{
name|tspc
operator|=
name|NULL
expr_stmt|;
block|}
name|spc
operator|->
name|spc_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED_BY_PAGEOUT
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
name|swap_pager_needflags
operator|&=
operator|~
operator|(
name|SWAP_FREE_NEEDED
operator||
name|SWAP_FREE_NEEDED_BY_PAGEOUT
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tspc
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swap_pager_finish
parameter_list|(
name|spc
parameter_list|)
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
block|{
name|vm_object_t
name|object
init|=
name|spc
operator|->
name|spc_m
index|[
literal|0
index|]
operator|->
name|object
decl_stmt|;
name|int
name|i
decl_stmt|;
name|object
operator|->
name|paging_in_progress
operator|-=
name|spc
operator|->
name|spc_count
expr_stmt|;
if|if
condition|(
operator|(
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
operator|)
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
condition|)
block|{
name|object
operator|->
name|flags
operator|&=
operator|~
name|OBJ_PIPWNT
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no error, mark as clean and inform the pmap system. If error, 	 * mark as dirty so we will try again. (XXX could get stuck doing 	 * this, should give up after awhile) 	 */
if|if
condition|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_ERROR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spc
operator|->
name|spc_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"swap_pager_finish: I/O error, clean of page %lx failed\n"
argument_list|,
operator|(
name|u_long
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spc
operator|->
name|spc_count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_ACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_WANTED
operator|)
operator|||
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
condition|)
name|vm_page_activate
argument_list|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spc
operator|->
name|spc_count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * we wakeup any processes that are waiting on these pages. 		 */
name|PAGE_WAKEUP
argument_list|(
name|spc
operator|->
name|spc_m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|nswiodone
operator|-=
name|spc
operator|->
name|spc_count
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * swap_pager_iodone  */
end_comment

begin_function
name|void
name|swap_pager_iodone
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|spc
operator|=
operator|(
name|swp_clean_t
operator|)
name|bp
operator|->
name|b_spc
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_done
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|spc
operator|->
name|spc_flags
operator||=
name|SPC_ERROR
expr_stmt|;
name|printf
argument_list|(
literal|"swap_pager: I/O error - async %s failed; blkno %lu, size %ld, error %d\n"
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"pagein"
else|:
literal|"pageout"
argument_list|,
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|pbrelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|nswiodone
operator|+=
name|spc
operator|->
name|spc_count
expr_stmt|;
if|if
condition|(
operator|--
name|spc
operator|->
name|spc_swp
operator|->
name|sw_poip
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|spc
operator|->
name|spc_swp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED
operator|)
operator|||
name|swap_pager_inuse
operator|.
name|tqh_first
operator|==
literal|0
condition|)
block|{
name|swap_pager_needflags
operator|&=
operator|~
name|SWAP_FREE_NEEDED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_needflags
operator|&
name|SWAP_FREE_NEEDED_BY_PAGEOUT
condition|)
block|{
name|swap_pager_needflags
operator|&=
operator|~
name|SWAP_FREE_NEEDED_BY_PAGEOUT
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|vm_pageout_pages_needed
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_pageout_pages_needed
argument_list|)
expr_stmt|;
name|vm_pageout_pages_needed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|swap_pager_inuse
operator|.
name|tqh_first
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
name|cnt
operator|.
name|v_free_min
operator|&&
name|nswiodone
operator|+
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|>=
name|cnt
operator|.
name|v_free_min
operator|)
condition|)
block|{
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return true if any swap control structures can be allocated  */
end_comment

begin_function
name|int
name|swap_pager_ready
parameter_list|()
block|{
if|if
condition|(
name|swap_pager_free
operator|.
name|tqh_first
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

end_unit

