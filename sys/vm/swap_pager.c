begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Matthew Dillon,  * Copyright (c) 1994 John S. Dyson  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *				New Swap System  *				Matthew Dillon  *  * Radix Bitmap 'blists'.  *  *	- The new swapper uses the new radix bitmap code.  This should scale  *	  to arbitrarily small or arbitrarily large swap spaces and an almost  *	  arbitrary degree of fragmentation.  *  * Features:  *  *	- on the fly reallocation of swap during putpages.  The new system  *	  does not try to keep previously allocated swap blocks for dirty  *	  pages.    *  *	- on the fly deallocation of swap  *  *	- No more garbage collection required.  Unnecessarily allocated swap  *	  blocks only exist for dirty vm_page_t's now and these are already  *	  cycled (in a high-load system) by the pager.  We also do on-the-fly  *	  removal of invalidated swap blocks when a page is destroyed  *	  or renamed.  *  * from: Utah $Hdr: swap_pager.c 1.4 91/04/30$  *  *	@(#)swap_pager.c	8.9 (Berkeley) 3/21/94  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PAGEOUT_CLUSTER
end_ifndef

begin_define
define|#
directive|define
name|MAX_PAGEOUT_CLUSTER
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWB_NPAGES
value|MAX_PAGEOUT_CLUSTER
end_define

begin_include
include|#
directive|include
file|"opt_swap.h"
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_define
define|#
directive|define
name|SWM_FREE
value|0x02
end_define

begin_comment
comment|/* free, period			*/
end_comment

begin_define
define|#
directive|define
name|SWM_POP
value|0x04
end_define

begin_comment
comment|/* pop out			*/
end_comment

begin_comment
comment|/*  * vm_swap_size is in page-sized chunks now.  It was DEV_BSIZE'd chunks  * in the old system.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|vm_swap_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of free swap blocks, in pages */
end_comment

begin_decl_stmt
name|int
name|swap_pager_full
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (task killing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swap_pager_almost_full
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (w/ hysteresis)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_rcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free read buffers			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / synchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / asynchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assigned maximum			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_cluster_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum VOP I/O allowed		*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|sw_alloc_interlock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap pager allocation interlock	*/
end_comment

begin_decl_stmt
name|struct
name|blist
modifier|*
name|swapblist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|swblock
modifier|*
modifier|*
name|swhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swhash_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_async_max
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum in-progress async I/O's	*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|vnode
modifier|*
name|swapdev_vp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from vm_swap.c */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_async_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|swap_async_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum running async swap ops"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * "named" and "unnamed" anon region objects.  Try to reduce the overhead  * of searching a named list by hashing it just a little.  */
end_comment

begin_define
define|#
directive|define
name|NOBJLISTS
value|8
end_define

begin_define
define|#
directive|define
name|NOBJLIST
parameter_list|(
name|handle
parameter_list|)
define|\
value|(&swap_pager_object_list[((int)(intptr_t)handle>> 4)& (NOBJLISTS-1)])
end_define

begin_decl_stmt
specifier|static
name|struct
name|pagerlst
name|swap_pager_object_list
index|[
name|NOBJLISTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pagerlst
name|swap_pager_un_object_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_zone_t
name|swap_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pagerops for OBJT_SWAP - "swap pager".  Some ops are also global procedure  * calls hooked from other parts of the VM system and do not appear here.  * (see vm/swap_pager.h).  */
end_comment

begin_decl_stmt
specifier|static
name|vm_object_t
name|swap_pager_alloc
name|__P
argument_list|(
operator|(
name|void
operator|*
name|handle
operator|,
name|vm_ooffset_t
name|size
operator|,
name|vm_prot_t
name|prot
operator|,
name|vm_ooffset_t
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_dealloc
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_pager_getpages
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_unswapped
name|__P
argument_list|(
operator|(
name|vm_page_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_strategy
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pagerops
name|swappagerops
init|=
block|{
name|swap_pager_init
block|,
comment|/* early system initialization of pager	*/
name|swap_pager_alloc
block|,
comment|/* allocate an OBJT_SWAP object		*/
name|swap_pager_dealloc
block|,
comment|/* deallocate an OBJT_SWAP object	*/
name|swap_pager_getpages
block|,
comment|/* pagein				*/
name|swap_pager_putpages
block|,
comment|/* pageout				*/
name|swap_pager_haspage
block|,
comment|/* get backing store status for page	*/
name|swap_pager_unswapped
block|,
comment|/* remove swap related to page		*/
name|swap_pager_strategy
comment|/* pager strategy call			*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * dmmax is in page-sized chunks with the new swap system.  It was  * dev-bsized chunks in the old.  dmmax is always a power of 2.  *  * swap_*() routines are externally accessible.  swp_*() routines are  * internal.  */
end_comment

begin_decl_stmt
name|int
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dmmax_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswap_lowat
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_decl_stmt
name|int
name|nswap_hiwat
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|swp_sizecheck
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swp_pager_sync_iodone
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swp_pager_async_iodone
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Swap bitmap functions  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|swp_pager_freeswapspace
name|__P
argument_list|(
operator|(
name|daddr_t
name|blk
operator|,
name|int
name|npages
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|daddr_t
name|swp_pager_getswapspace
name|__P
argument_list|(
operator|(
name|int
name|npages
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Metadata functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|swp_pager_meta_build
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
name|vm_pindex_t
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swp_pager_meta_free
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
name|vm_pindex_t
operator|,
name|daddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swp_pager_meta_free_all
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
name|vm_pindex_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SWP_SIZECHECK() -	update swap_pager_full indication  *	  *	update the swap_pager_almost_full indication and warn when we are  *	about to run out of swap space, using lowat/hiwat hysteresis.  *  *	Clear swap_pager_full ( task killing ) indication when lowat is met.  *  *	No restrictions on call  *	This routine may not block.  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|swp_sizecheck
parameter_list|()
block|{
if|if
condition|(
name|vm_swap_size
operator|<
name|nswap_lowat
condition|)
block|{
if|if
condition|(
name|swap_pager_almost_full
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: out of swap space\n"
argument_list|)
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|swap_pager_full
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm_swap_size
operator|>
name|nswap_hiwat
condition|)
name|swap_pager_almost_full
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_INIT() -	initialize the swap pager!  *  *	Expected to be started from system init.  NOTE:  This code is run   *	before much else so be careful what you depend on.  Most of the VM  *	system has yet to be initialized at this point.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_init
parameter_list|()
block|{
comment|/* 	 * Initialize object lists 	 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOBJLISTS
condition|;
operator|++
name|i
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_object_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_un_object_list
argument_list|)
expr_stmt|;
comment|/* 	 * Device Stripe, in PAGE_SIZE'd blocks 	 */
name|dmmax
operator|=
name|SWB_NPAGES
operator|*
literal|2
expr_stmt|;
name|dmmax_mask
operator|=
operator|~
operator|(
name|dmmax
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_SWAP_INIT() - swap pager initialization from pageout process  *  *	Expected to be started from pageout process once, prior to entering  *	its main loop.  */
end_comment

begin_function
name|void
name|swap_pager_swap_init
parameter_list|()
block|{
name|int
name|n
decl_stmt|,
name|n2
decl_stmt|;
comment|/* 	 * Number of in-transit swap bp operations.  Don't 	 * exhaust the pbufs completely.  Make sure we 	 * initialize workable values (0 will work for hysteresis 	 * but it isn't very efficient). 	 * 	 * The nsw_cluster_max is constrained by the bp->b_pages[] 	 * array (MAXPHYS/PAGE_SIZE) and our locally defined 	 * MAX_PAGEOUT_CLUSTER.   Also be aware that swap ops are 	 * constrained by the swap device interleave stripe size. 	 * 	 * Currently we hardwire nsw_wcount_async to 4.  This limit is  	 * designed to prevent other I/O from having high latencies due to 	 * our pageout I/O.  The value 4 works well for one or two active swap 	 * devices but is probably a little low if you have more.  Even so, 	 * a higher value would probably generate only a limited improvement 	 * with three or four active swap devices since the system does not 	 * typically have to pageout at extreme bandwidths.   We will want 	 * at least 2 per swap devices, and 4 is a pretty good value if you 	 * have one NFS swap device due to the command/ack latency over NFS. 	 * So it all works out pretty well. 	 */
name|nsw_cluster_max
operator|=
name|min
argument_list|(
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
argument_list|,
name|MAX_PAGEOUT_CLUSTER
argument_list|)
expr_stmt|;
name|nsw_rcount
operator|=
operator|(
name|nswbuf
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|nsw_wcount_sync
operator|=
operator|(
name|nswbuf
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|nsw_wcount_async
operator|=
literal|4
expr_stmt|;
name|nsw_wcount_async_max
operator|=
name|nsw_wcount_async
expr_stmt|;
comment|/* 	 * Initialize our zone.  Right now I'm just guessing on the number 	 * we need based on the number of pages in the system.  Each swblock 	 * can hold 16 pages, so this is probably overkill.  This reservation 	 * is typically limited to around 32MB by default.  The initial 	 * guess caps the swap space at 8 times the size of RAM. 	 */
name|n
operator|=
name|cnt
operator|.
name|v_page_count
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|maxswzone
operator|&&
name|n
operator|>
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
condition|)
name|n
operator|=
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n
expr_stmt|;
do|do
block|{
name|swap_zone
operator|=
name|zinit
argument_list|(
literal|"SWAPMETA"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
argument_list|,
name|n
argument_list|,
name|ZONE_INTERRUPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_zone
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * if the allocation failed, try a zone two thirds the 		 * size of the previous attempt. 		 */
name|n
operator|-=
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|swap_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"swap_pager_swap_init: swap_zone == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2
operator|!=
name|n
condition|)
name|printf
argument_list|(
literal|"Swap zone entries reduced from %d to %d.\n"
argument_list|,
name|n2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n
expr_stmt|;
comment|/* 	 * Initialize our meta-data hash table.  The swapper does not need to 	 * be quite as efficient as the VM system, so we do not use an  	 * oversized hash table. 	 * 	 * 	n: 		size of hash table, must be power of 2 	 *	swhash_mask:	hash table index mask 	 */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|n2
operator|/
literal|8
condition|;
name|n
operator|*=
literal|2
control|)
empty_stmt|;
name|swhash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
operator|*
argument_list|)
operator|*
name|n
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|swhash
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|swhash_mask
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_ALLOC() -	allocate a new OBJT_SWAP VM object and instantiate  *			its metadata structures.  *  *	This routine is called from the mmap and fork code to create a new  *	OBJT_SWAP object.  We do this by creating an OBJT_DEFAULT object  *	and then converting it with swp_pager_meta_build().  *  *	This routine may block in vm_object_allocate() and create a named  *	object lookup race, so we must interlock.   We must also run at  *	splvm() for the object lookup to handle races with interrupts, but  *	we do not have to maintain splvm() in between the lookup and the  *	add because (I believe) it is not possible to attempt to create  *	a new swap object w/handle when a default object with that handle  *	already exists.  */
end_comment

begin_function
specifier|static
name|vm_object_t
name|swap_pager_alloc
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
comment|/* 		 * Reference existing named region or allocate new one.  There 		 * should not be a race here against swp_pager_meta_build() 		 * as called from vm_page_remove() in regards to the lookup 		 * of the handle. 		 */
while|while
condition|(
name|sw_alloc_interlock
condition|)
block|{
name|sw_alloc_interlock
operator|=
operator|-
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sw_alloc_interlock
argument_list|,
name|PVM
argument_list|,
literal|"swpalc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sw_alloc_interlock
operator|=
literal|1
expr_stmt|;
name|object
operator|=
name|vm_pager_object_lookup
argument_list|(
name|NOBJLIST
argument_list|(
name|handle
argument_list|)
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|PAGE_MASK
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sw_alloc_interlock
operator|<
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|sw_alloc_interlock
argument_list|)
expr_stmt|;
name|sw_alloc_interlock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|PAGE_MASK
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_DEALLOC() -	remove swap metadata from object  *  *	The swap backing for the object is destroyed.  The code is   *	designed such that we can reinstantiate it later, but this  *	routine is typically called only when the entire object is  *	about to be destroyed.  *  *	This routine may block, but no longer does.   *  *	The object must be locked or unreferenceable.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|object
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
comment|/* 	 * Remove from list right away so lookups will fail if we block for 	 * pageout completion. 	 */
if|if
condition|(
name|object
operator|->
name|handle
operator|==
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_un_object_list
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wait
argument_list|(
name|object
argument_list|,
literal|"swpdea"
argument_list|)
expr_stmt|;
comment|/* 	 * Free all remaining metadata.  We only bother to free it from  	 * the swap meta data.  We do not attempt to free swapblk's still 	 * associated with vm_page_t's for this object.  We do not care 	 * if paging is still in progress on some objects. 	 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|swp_pager_meta_free_all
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *			SWAP PAGER BITMAP ROUTINES			*  ************************************************************************/
end_comment

begin_comment
comment|/*  * SWP_PAGER_GETSWAPSPACE() -	allocate raw swap space  *  *	Allocate swap for the requested number of pages.  The starting  *	swap block number (a page index) is returned or SWAPBLK_NONE  *	if the allocation failed.  *  *	Also has the side effect of advising that somebody made a mistake  *	when they configured swap and didn't configure enough.  *  *	Must be called at splvm() to avoid races with bitmap frees from  *	vm_page_remove() aka swap_pager_page_removed().  *  *	This routine may not block  *	This routine must be called at splvm().  */
end_comment

begin_function
specifier|static
name|__inline
name|daddr_t
name|swp_pager_getswapspace
parameter_list|(
name|npages
parameter_list|)
name|int
name|npages
decl_stmt|;
block|{
name|daddr_t
name|blk
decl_stmt|;
if|if
condition|(
operator|(
name|blk
operator|=
name|blist_alloc
argument_list|(
name|swapblist
argument_list|,
name|npages
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
condition|)
block|{
if|if
condition|(
name|swap_pager_full
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager_getswapspace: failed\n"
argument_list|)
expr_stmt|;
name|swap_pager_full
operator|=
literal|2
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm_swap_size
operator|-=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_FREESWAPSPACE() -	free raw swap space   *  *	This routine returns the specified swap blocks back to the bitmap.  *  *	Note:  This routine may not block (it could in the old swap code),  *	and through the use of the new blist routines it does not block.  *  *	We must be called at splvm() to avoid races with bitmap frees from  *	vm_page_remove() aka swap_pager_page_removed().  *  *	This routine may not block  *	This routine must be called at splvm().  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|swp_pager_freeswapspace
parameter_list|(
name|blk
parameter_list|,
name|npages
parameter_list|)
name|daddr_t
name|blk
decl_stmt|;
name|int
name|npages
decl_stmt|;
block|{
name|blist_free
argument_list|(
name|swapblist
argument_list|,
name|blk
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|vm_swap_size
operator|+=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_FREESPACE() -	frees swap blocks associated with a page  *				range within an object.  *  *	This is a globally accessible routine.  *  *	This routine removes swapblk assignments from swap metadata.  *  *	The external callers of this routine typically have already destroyed   *	or renamed vm_page_t's associated with this range in the object so   *	we should be ok.  *  *	This routine may be called at any spl.  We up our spl to splvm temporarily  *	in order to perform the metadata removal.  */
end_comment

begin_function
name|void
name|swap_pager_freespace
parameter_list|(
name|object
parameter_list|,
name|start
parameter_list|,
name|size
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|start
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
block|{
name|int
name|s
init|=
name|splvm
argument_list|()
decl_stmt|;
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_RESERVE() - reserve swap blocks in object  *  *	Assigns swap blocks to the specified range within the object.  The   *	swap blocks are not zerod.  Any previous swap assignment is destroyed.  *  *	Returns 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|swap_pager_reserve
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|daddr_t
name|blk
init|=
name|SWAPBLK_NONE
decl_stmt|;
name|vm_pindex_t
name|beg
init|=
name|start
decl_stmt|;
comment|/* save start index */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|BLIST_MAX_ALLOC
expr_stmt|;
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|beg
argument_list|,
name|start
operator|-
name|beg
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|blk
argument_list|)
expr_stmt|;
operator|--
name|size
expr_stmt|;
operator|++
name|start
expr_stmt|;
operator|++
name|blk
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_COPY() -  copy blocks from source pager to destination pager  *			and destroy the source.  *  *	Copy any valid swapblks from the source to the destination.  In  *	cases where both the source and destination have a valid swapblk,  *	we keep the destination's.  *  *	This routine is allowed to block.  It may block allocating metadata  *	indirectly through swp_pager_meta_build() or if paging is still in  *	progress on the source.   *  *	This routine can be called at any spl  *  *	XXX vm_page_collapse() kinda expects us not to block because we   *	supposedly do not need to allocate memory, but for the moment we  *	*may* have to get a little memory from the zone allocator, but  *	it is taken from the interrupt memory.  We should be ok.   *  *	The source object contains no vm_page_t's (which is just as well)  *  *	The source object is of type OBJT_SWAP.  *  *	The source and destination objects must be locked or   *	inaccessible (XXX are they ?)  */
end_comment

begin_function
name|void
name|swap_pager_copy
parameter_list|(
name|srcobject
parameter_list|,
name|dstobject
parameter_list|,
name|offset
parameter_list|,
name|destroysource
parameter_list|)
name|vm_object_t
name|srcobject
decl_stmt|;
name|vm_object_t
name|dstobject
decl_stmt|;
name|vm_pindex_t
name|offset
decl_stmt|;
name|int
name|destroysource
decl_stmt|;
block|{
name|vm_pindex_t
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 	 * If destroysource is set, we remove the source object from the  	 * swap_pager internal queue now.  	 */
if|if
condition|(
name|destroysource
condition|)
block|{
if|if
condition|(
name|srcobject
operator|->
name|handle
operator|==
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_un_object_list
argument_list|,
name|srcobject
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|srcobject
operator|->
name|handle
argument_list|)
argument_list|,
name|srcobject
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * transfer source to destination. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dstobject
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|dstaddr
decl_stmt|;
comment|/* 		 * Locate (without changing) the swapblk on the destination, 		 * unless it is invalid in which case free it silently, or 		 * if the destination is a resident page, in which case the 		 * source is thrown away. 		 */
name|dstaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstaddr
operator|==
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 			 * Destination has no swapblk and is not resident, 			 * copy source. 			 */
name|daddr_t
name|srcaddr
decl_stmt|;
name|srcaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcaddr
operator|!=
name|SWAPBLK_NONE
condition|)
name|swp_pager_meta_build
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
name|srcaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Destination has valid swapblk or it is represented 			 * by a resident page.  We destroy the sourceblock. 			 */
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free left over swap blocks in source. 	 * 	 * We have to revert the type to OBJT_DEFAULT so we do not accidently 	 * double-remove the object from the swap queues. 	 */
if|if
condition|(
name|destroysource
condition|)
block|{
name|swp_pager_meta_free_all
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
comment|/* 		 * Reverting the type is not necessary, the caller is going 		 * to destroy srcobject directly, but I'm doing it here 		 * for consistency since we've removed the object from its 		 * queues. 		 */
name|srcobject
operator|->
name|type
operator|=
name|OBJT_DEFAULT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_HASPAGE() -	determine if we have good backing store for  *				the requested page.  *  *	We determine whether good backing store exists for the requested  *	page and return TRUE if it does, FALSE if it doesn't.  *  *	If TRUE, we also try to determine how much valid, contiguous backing  *	store exists before and after the requested page within a reasonable  *	distance.  We do not try to restrict it to the swap device stripe  *	(that is handled in getpages/putpages).  It probably isn't worth  *	doing here.  */
end_comment

begin_function
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|before
parameter_list|,
name|after
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
modifier|*
name|before
decl_stmt|;
name|int
modifier|*
name|after
decl_stmt|;
block|{
name|daddr_t
name|blk0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * do we have good backing store at the requested index ? 	 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|blk0
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk0
operator|==
name|SWAPBLK_NONE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
condition|)
operator|*
name|before
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after
condition|)
operator|*
name|after
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * find backwards-looking contiguous good backing store 	 */
if|if
condition|(
name|before
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|SWB_NPAGES
operator|/
literal|2
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|blk
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|pindex
condition|)
break|break;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|-
name|i
condition|)
break|break;
block|}
operator|*
name|before
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * find forward-looking contiguous good backing store 	 */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|SWB_NPAGES
operator|/
literal|2
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|blk
decl_stmt|;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|+
name|i
condition|)
break|break;
block|}
operator|*
name|after
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_PAGE_UNSWAPPED() - remove swap backing store related to page  *  *	This removes any associated swap backing store, whether valid or  *	not, from the page.    *  *	This routine is typically called when a page is made dirty, at  *	which point any associated swap can be freed.  MADV_FREE also  *	calls us in a special-case situation  *  *	NOTE!!!  If the page is clean and the swap was valid, the caller  *	should make the page dirty before calling this routine.  This routine  *	does NOT change the m->dirty status of the page.  Also: MADV_FREE  *	depends on it.  *  *	This routine may not block  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_unswapped
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|swp_pager_meta_ctl
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_STRATEGY() - read, write, free blocks  *  *	This implements the vm_pager_strategy() interface to swap and allows  *	other parts of the system to directly access swap as backing store  *	through vm_objects of type OBJT_SWAP.  This is intended to be a   *	cacheless interface ( i.e. caching occurs at higher levels ).  *	Therefore we do not maintain any resident pages.  All I/O goes  *	directly to and from the swap device.  *	  *	Note that b_blkno is scaled for PAGE_SIZE  *  *	We currently attempt to run I/O synchronously or asynchronously as  *	the caller requests.  This isn't perfect because we loose error  *	sequencing when we run multiple ops in parallel to satisfy a request.  *	But this is swap, so we let it all hang out.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_strategy
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|vm_pindex_t
name|start
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|&
name|PAGE_MASK
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
operator||
name|B_INVAL
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"swap_pager_strategy: bp %p b_vp %p blk %d size %d, not page bounded\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_pblkno
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clear error indication, initialize page index, count, data pointer. 	 */
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|start
operator|=
name|bp
operator|->
name|b_pblkno
expr_stmt|;
name|count
operator|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 	 * Deal with B_FREEBUF 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FREEBUF
condition|)
block|{
comment|/* 		 * FREE PAGE(s) - destroy underlying swap that is no longer 		 *		  needed. 		 */
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Execute read or write 	 */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|daddr_t
name|blk
decl_stmt|;
comment|/* 		 * Obtain block.  If block not found and writing, allocate a 		 * new block and build it into the object. 		 */
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|blk
operator|==
name|SWAPBLK_NONE
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
break|break;
block|}
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Do we have to flush our current collection?  Yes if: 		 * 		 *	- no swap block at this index 		 *	- swap block is not contiguous 		 *	- we cross a physical disk boundry in the 		 *	  stripe. 		 */
if|if
condition|(
name|nbp
operator|&&
operator|(
name|nbp
operator|->
name|b_blkno
operator|+
name|btoc
argument_list|(
name|nbp
operator|->
name|b_bcount
argument_list|)
operator|!=
name|blk
operator|||
operator|(
operator|(
name|nbp
operator|->
name|b_blkno
operator|^
name|blk
operator|)
operator|&
name|dmmax_mask
operator|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
operator|++
name|cnt
operator|.
name|v_swapin
expr_stmt|;
name|cnt
operator|.
name|v_swappgsin
operator|+=
name|btoc
argument_list|(
name|nbp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|cnt
operator|.
name|v_swapout
expr_stmt|;
name|cnt
operator|.
name|v_swappgsout
operator|+=
name|btoc
argument_list|(
name|nbp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_dirtyend
operator|=
name|nbp
operator|->
name|b_bcount
expr_stmt|;
block|}
name|flushchainbuf
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|nbp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Add new swapblk to nbp, instantiating nbp if necessary. 		 * Zero-fill reads are able to take a shortcut. 		 */
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 			 * We can only get here if we are reading.  Since 			 * we are at splvm() we can safely modify b_resid, 			 * even if chain ops are in progress. 			 */
name|bzero
argument_list|(
name|data
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nbp
operator|==
name|NULL
condition|)
block|{
name|nbp
operator|=
name|getchainbuf
argument_list|(
name|bp
argument_list|,
name|swapdev_vp
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator||
name|B_ASYNC
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_blkno
operator|=
name|blk
expr_stmt|;
name|nbp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|nbp
operator|->
name|b_data
operator|=
name|data
expr_stmt|;
block|}
name|nbp
operator|->
name|b_bcount
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
operator|++
name|start
expr_stmt|;
name|data
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 *  Flush out last buffer 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbp
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
name|nbp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
if|if
condition|(
name|nbp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
operator|++
name|cnt
operator|.
name|v_swapin
expr_stmt|;
name|cnt
operator|.
name|v_swappgsin
operator|+=
name|btoc
argument_list|(
name|nbp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|cnt
operator|.
name|v_swapout
expr_stmt|;
name|cnt
operator|.
name|v_swappgsout
operator|+=
name|btoc
argument_list|(
name|nbp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|b_dirtyend
operator|=
name|nbp
operator|->
name|b_bcount
expr_stmt|;
block|}
name|flushchainbuf
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
comment|/* nbp = NULL; */
block|}
comment|/* 	 * Wait for completion. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
block|{
name|autochaindone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waitchainbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_GETPAGES() - bring pages in from swap  *  *	Attempt to retrieve (m, count) pages from backing store, but make  *	sure we retrieve at least m[reqpage].  We try to load in as large  *	a chunk surrounding m[reqpage] as is contiguous in swap and which  *	belongs to the same object.  *  *	The code is designed for asynchronous operation and   *	immediate-notification of 'reqpage' but tends not to be  *	used that way.  Please do not optimize-out this algorithmic  *	feature, I intend to improve on it in the future.  *  *	The parent has a single vm_object_pip_add() reference prior to  *	calling us and we should return with the same.  *  *	The parent has BUSY'd the pages.  We should return with 'm'  *	left busy, but the others adjusted.  */
end_comment

begin_function
specifier|static
name|int
name|swap_pager_getpages
parameter_list|(
name|object
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|,
name|reqpage
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|,
name|reqpage
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|vm_page_t
name|mreq
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|vm_pindex_t
name|lastpindex
decl_stmt|;
name|mreq
operator|=
name|m
index|[
name|reqpage
index|]
expr_stmt|;
if|if
condition|(
name|mreq
operator|->
name|object
operator|!=
name|object
condition|)
block|{
name|panic
argument_list|(
literal|"swap_pager_getpages: object mismatch %p/%p"
argument_list|,
name|object
argument_list|,
name|mreq
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate range to retrieve.  The pages have already been assigned 	 * their swapblks.  We require a *contiguous* range that falls entirely 	 * within a single device stripe.   If we do not supply it, bad things 	 * happen.  Note that blk, iblk& jblk can be SWAPBLK_NONE, but the  	 * loops are set up such that the case(s) are handled implicitly. 	 * 	 * The swp_*() calls must be made at splvm().  vm_page_free() does 	 * not need to be, but it will go a little faster if it is. 	 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|mreq
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reqpage
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|daddr_t
name|iblk
decl_stmt|;
name|iblk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|m
index|[
name|i
index|]
operator|->
name|object
argument_list|,
name|m
index|[
name|i
index|]
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|iblk
operator|+
operator|(
name|reqpage
operator|-
name|i
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|blk
operator|^
name|iblk
operator|)
operator|&
name|dmmax_mask
condition|)
break|break;
block|}
operator|++
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|reqpage
operator|+
literal|1
init|;
name|j
operator|<
name|count
condition|;
operator|++
name|j
control|)
block|{
name|daddr_t
name|jblk
decl_stmt|;
name|jblk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|m
index|[
name|j
index|]
operator|->
name|object
argument_list|,
name|m
index|[
name|j
index|]
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|jblk
operator|-
operator|(
name|j
operator|-
name|reqpage
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|blk
operator|^
name|jblk
operator|)
operator|&
name|dmmax_mask
condition|)
break|break;
block|}
comment|/* 	 * free pages outside our collection range.   Note: we never free 	 * mreq, it must remain busy throughout. 	 */
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
operator|++
name|k
control|)
name|vm_page_free
argument_list|(
name|m
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|count
condition|;
operator|++
name|k
control|)
name|vm_page_free
argument_list|(
name|m
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Return VM_PAGER_FAIL if we have nothing to do.  Return mreq  	 * still busy, but the others unbusied. 	 */
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
comment|/* 	 * Get a swap buffer header to perform the IO 	 */
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_rcount
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
comment|/* 	 * map our page(s) into kva for input 	 * 	 * NOTE: B_PAGING is set by pbgetvp() 	 */
name|pmap_qenter
argument_list|(
name|kva
argument_list|,
name|m
operator|+
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_READ
operator||
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|bp
operator|->
name|b_wcred
operator|=
name|proc0
operator|.
name|p_ucred
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
operator|-
operator|(
name|reqpage
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
operator|(
name|j
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
operator|(
name|j
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
operator|=
name|reqpage
operator|-
name|i
expr_stmt|;
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
name|bp
operator|->
name|b_pages
index|[
name|k
operator|-
name|i
index|]
operator|=
name|m
index|[
name|k
index|]
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
index|[
name|k
index|]
argument_list|,
name|PG_SWAPINPROG
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_npages
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|pbgetvp
argument_list|(
name|swapdev_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_swapin
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsin
operator|+=
name|bp
operator|->
name|b_npages
expr_stmt|;
comment|/* 	 * We still hold the lock on mreq, and our automatic completion routine 	 * does not remove it. 	 */
name|vm_object_pip_add
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|lastpindex
operator|=
name|m
index|[
name|j
operator|-
literal|1
index|]
operator|->
name|pindex
expr_stmt|;
comment|/* 	 * perform the I/O.  NOTE!!!  bp cannot be considered valid after 	 * this point because we automatically release it on completion. 	 * Instead, we look at the one page we are interested in which we 	 * still hold a lock on even through the I/O completion. 	 * 	 * The other pages in our m[] array are also released on completion, 	 * so we cannot assume they are valid anymore either. 	 * 	 * NOTE: b_blkno is destroyed by the call to VOP_STRATEGY 	 */
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * wait for the page we want to complete.  PG_SWAPINPROG is always 	 * cleared on completion.  If an I/O error occurs, SWAPBLK_NONE 	 * is set in the meta-data. 	 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|mreq
operator|->
name|flags
operator|&
name|PG_SWAPINPROG
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_page_flag_set
argument_list|(
name|mreq
argument_list|,
name|PG_WANTED
operator||
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_intrans
operator|++
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
name|mreq
argument_list|,
name|PSWP
argument_list|,
literal|"swread"
argument_list|,
name|hz
operator|*
literal|20
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: indefinite wait buffer: device:"
literal|" %s, blkno: %ld, size: %ld\n"
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * mreq is left bussied after completion, but all the other pages 	 * are freed.  If we had an unrecoverable read error the page will 	 * not be valid. 	 */
if|if
condition|(
name|mreq
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
block|}
comment|/* 	 * A final note: in a low swap situation, we cannot deallocate swap 	 * and mark a page dirty here because the caller is likely to mark 	 * the page clean when we return, causing the page to possibly revert  	 * to all-zero's later. 	 */
block|}
end_function

begin_comment
comment|/*  *	swap_pager_putpages:   *  *	Assign swap (if necessary) and initiate I/O on the specified pages.  *  *	We support both OBJT_DEFAULT and OBJT_SWAP objects.  DEFAULT objects  *	are automatically converted to SWAP objects.  *  *	In a low memory situation we may block in VOP_STRATEGY(), but the new   *	vm_page reservation system coupled with properly written VFS devices   *	should ensure that no low-memory deadlock occurs.  This is an area  *	which needs work.  *  *	The parent has N vm_object_pip_add() references prior to  *	calling us and will remove references for rtvals[] that are  *	not set to VM_PAGER_PEND.  We need to remove the rest on I/O  *	completion.  *  *	The parent has soft-busy'd the pages it passes us and will unbusy  *	those whos rtvals[] entry is not set to VM_PAGER_PEND on return.  *	We need to unbusy the rest on I/O completion.  */
end_comment

begin_function
name|void
name|swap_pager_putpages
parameter_list|(
name|object
parameter_list|,
name|m
parameter_list|,
name|count
parameter_list|,
name|sync
parameter_list|,
name|rtvals
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
name|int
modifier|*
name|rtvals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|&&
name|m
index|[
literal|0
index|]
operator|->
name|object
operator|!=
name|object
condition|)
block|{
name|panic
argument_list|(
literal|"swap_pager_getpages: object mismatch %p/%p"
argument_list|,
name|object
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step 1 	 * 	 * Turn object into OBJT_SWAP 	 * check for bogus sysops 	 * force sync if not pageout process 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|pageproc
condition|)
name|sync
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Step 2 	 * 	 * Update nsw parameters from swap_async_max sysctl values.   	 * Do not let the sysop crash the machine with bogus numbers. 	 */
if|if
condition|(
name|swap_async_max
operator|!=
name|nsw_wcount_async_max
condition|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 		 * limit range 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|swap_async_max
operator|)
operator|>
name|nswbuf
operator|/
literal|2
condition|)
name|n
operator|=
name|nswbuf
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|swap_async_max
operator|=
name|n
expr_stmt|;
comment|/* 		 * Adjust difference ( if possible ).  If the current async 		 * count is too low, we may not be able to make the adjustment 		 * at this time. 		 */
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|n
operator|-=
name|nsw_wcount_async_max
expr_stmt|;
if|if
condition|(
name|nsw_wcount_async
operator|+
name|n
operator|>=
literal|0
condition|)
block|{
name|nsw_wcount_async
operator|+=
name|n
expr_stmt|;
name|nsw_wcount_async_max
operator|+=
name|n
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step 3 	 * 	 * Assign swap blocks and issue I/O.  We reallocate swap on the fly. 	 * The page is left dirty until the pageout operation completes 	 * successfully. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
name|n
control|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
comment|/* 		 * Maximum I/O size is limited by a number of factors. 		 */
name|n
operator|=
name|min
argument_list|(
name|BLIST_MAX_ALLOC
argument_list|,
name|count
operator|-
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nsw_cluster_max
argument_list|)
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 		 * Get biggest block of swap we can.  If we fail, fall 		 * back and try to allocate a smaller block.  Don't go 		 * overboard trying to allocate space if it would overly 		 * fragment swap. 		 */
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
operator|&&
name|n
operator|>
literal|4
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The I/O we are constructing cannot cross a physical 		 * disk boundry in the swap stripe.  Note: we are still 		 * at splvm(). 		 */
if|if
condition|(
operator|(
name|blk
operator|^
operator|(
name|blk
operator|+
name|n
operator|)
operator|)
operator|&
name|dmmax_mask
condition|)
block|{
name|j
operator|=
operator|(
operator|(
name|blk
operator|+
name|dmmax
operator|)
operator|&
name|dmmax_mask
operator|)
operator|-
name|blk
expr_stmt|;
name|swp_pager_freeswapspace
argument_list|(
name|blk
operator|+
name|j
argument_list|,
name|n
operator|-
name|j
argument_list|)
expr_stmt|;
name|n
operator|=
name|j
expr_stmt|;
block|}
comment|/* 		 * All I/O parameters have been satisfied, build the I/O 		 * request and assign the swap space. 		 * 		 * NOTE: B_PAGING is set by pbgetvp() 		 */
if|if
condition|(
name|sync
operator|==
name|TRUE
condition|)
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_sync
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_CALL
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_CALL
operator||
name|B_ASYNC
expr_stmt|;
block|}
name|bp
operator|->
name|b_spc
operator|=
name|NULL
expr_stmt|;
comment|/* not used, but NULL-out anyway */
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|m
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|bp
operator|->
name|b_wcred
operator|=
name|proc0
operator|.
name|p_ucred
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|pbgetvp
argument_list|(
name|swapdev_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|vm_page_t
name|mreq
init|=
name|m
index|[
name|i
operator|+
name|j
index|]
decl_stmt|;
name|swp_pager_meta_build
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|mreq
operator|->
name|pindex
argument_list|,
name|blk
operator|+
name|j
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_OK
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|mreq
argument_list|,
name|PG_SWAPINPROG
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
operator|=
name|mreq
expr_stmt|;
block|}
name|bp
operator|->
name|b_npages
operator|=
name|n
expr_stmt|;
comment|/* 		 * Must set dirty range for NFS to work. 		 */
name|bp
operator|->
name|b_dirtyoff
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|cnt
operator|.
name|v_swapout
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsout
operator|+=
name|bp
operator|->
name|b_npages
expr_stmt|;
name|swapdev_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * asynchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to VOP_STRATEGY 		 */
if|if
condition|(
name|sync
operator|==
name|FALSE
condition|)
block|{
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * synchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to VOP_STRATEGY 		 */
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_sync_iodone
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the sync I/O to complete, then update rtvals. 		 * We just set the rtvals[] to VM_PAGER_PEND so we can call 		 * our async completion routine at the end, thus avoiding a 		 * double-free. 		 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swwrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
comment|/* 		 * Now that we are through with the bp, we can call the 		 * normal async completion, which frees everything up. 		 */
name|swp_pager_async_iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	swap_pager_sync_iodone:  *  *	Completion routine for synchronous reads and writes from/to swap.  *	We just mark the bp is complete and wake up anyone waiting on it.  *  *	This routine may not block.  This routine is called at splbio() or better.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_sync_iodone
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swp_pager_async_iodone:  *  *	Completion routine for asynchronous reads and writes from/to swap.  *	Also called manually by synchronous code to finish up a bp.  *  *	For READ operations, the pages are PG_BUSY'd.  For WRITE operations,   *	the pages are vm_page_t->busy'd.  For READ operations, we PG_BUSY   *	unbusy all pages except the 'main' request page.  For WRITE   *	operations, we vm_page_t->busy'd unbusy all pages ( we can do this   *	because we marked them all VM_PAGER_PEND on return from putpages ).  *  *	This routine may not block.  *	This routine is called at splbio() or better  *  *	We up ourselves to splvm() as required for various vm_page related  *	calls.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_async_iodone
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
init|=
name|NULL
decl_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
comment|/* 	 * report error 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: I/O error - %s failed; blkno %ld,"
literal|"size %ld, error %d\n"
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"pagein"
else|:
literal|"pageout"
operator|)
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * set object, raise to splvm(). 	 */
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 	 * remove the mapping for kernel virtual 	 */
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
comment|/* 	 * cleanup pages.  If an error occurs writing to swap, we are in 	 * very serious trouble.  If it happens to be a disk error, though, 	 * we may be able to recover by reassigning the swap later on.  So 	 * in this case we remove the m->swapblk assignment for the page  	 * but do not free it in the rlist.  The errornous block(s) are thus 	 * never reallocated as swap.  Redirty the page and continue. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
operator|++
name|i
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_SWAPINPROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
comment|/* 			 * If an error occurs I'd love to throw the swapblk 			 * away without freeing it back to swapspace, so it 			 * can never be used again.  But I can't from an  			 * interrupt. 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 				 * When reading, reqpage needs to stay 				 * locked for the parent, but all other 				 * pages can be freed.  We still want to 				 * wakeup the parent waiting on the page, 				 * though.  ( also: pg_reqpage can be -1 and  				 * not match anything ). 				 * 				 * We have to wake specifically requested pages 				 * up too because we cleared PG_SWAPINPROG and 				 * someone may be waiting for that. 				 * 				 * NOTE: for reads, m->dirty will probably 				 * be overridden by the original caller of 				 * getpages so don't play cute tricks here. 				 * 				 * XXX IT IS NOT LEGAL TO FREE THE PAGE HERE 				 * AS THIS MESSES WITH object->memq, and it is 				 * not legal to mess with object->memq from an 				 * interrupt. 				 */
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
condition|)
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|vm_page_flash
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * If i == bp->b_pager.pg_reqpage, do not wake  				 * the page up.  The caller needs to. 				 */
block|}
else|else
block|{
comment|/* 				 * If a write error occurs, reactivate page 				 * so it doesn't clog the inactive list, 				 * then finish the I/O. 				 */
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 			 * For read success, clear dirty bits.  Nobody should 			 * have this page mapped but don't take any chances, 			 * make sure the pmap modify bits are also cleared. 			 * 			 * NOTE: for reads, m->dirty will probably be  			 * overridden by the original caller of getpages so 			 * we cannot set them in order to free the underlying 			 * swap in a low-swap situation.  I don't think we'd 			 * want to do that anyway, but it was an optimization 			 * that existed in the old swapper for a time before 			 * it got ripped out due to precisely this problem. 			 * 			 * clear PG_ZERO in page. 			 * 			 * If not the requested page then deactivate it. 			 * 			 * Note that the requested page, reqpage, is left 			 * busied, but we still have to wake it up.  The 			 * other pages are released (unbusied) by  			 * vm_page_wakeup().  We do not set reqpage's 			 * valid bits here, it is up to the caller. 			 */
name|pmap_clear_modify
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
comment|/* 			 * We have to wake specifically requested pages 			 * up too because we cleared PG_SWAPINPROG and 			 * could be waiting for it in getpages.  However, 			 * be sure to not unbusy getpages specifically 			 * requested page - getpages expects it to be  			 * left busy. 			 */
if|if
condition|(
name|i
operator|!=
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
condition|)
block|{
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_page_flash
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * For write success, clear the modify and dirty  			 * status, then finish the I/O ( which decrements the  			 * busy count and possibly wakes waiter's up ). 			 */
name|pmap_clear_modify
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_count_severe
argument_list|()
operator|||
operator|!
name|vm_page_try_to_cache
argument_list|(
name|m
argument_list|)
condition|)
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_READ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * adjust pip.  NOTE: the original parent may still have its own 	 * pip refs on the object. 	 */
if|if
condition|(
name|object
condition|)
name|vm_object_pip_wakeupn
argument_list|(
name|object
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
comment|/* 	 * release the physical I/O buffer 	 */
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
operator|&
name|nsw_rcount
else|:
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
condition|?
operator|&
name|nsw_wcount_async
else|:
operator|&
name|nsw_wcount_sync
operator|)
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *				SWAP META DATA 				*  ************************************************************************  *  *	These routines manipulate the swap metadata stored in the   *	OBJT_SWAP object.  All swp_*() routines must be called at  *	splvm() because swap can be freed up by the low level vm_page  *	code which might be called from interrupts beyond what splbio() covers.  *  *	Swap metadata is implemented with a global hash and not directly  *	linked into the object.  Instead the object simply contains  *	appropriate tracking counters.  */
end_comment

begin_comment
comment|/*  * SWP_PAGER_HASH() -	hash swap meta data  *  *	This is an inline helper function which hashes the swapblk given  *	the object and page index.  It returns a pointer to a pointer  *	to the object, or a pointer to a NULL pointer if it could not  *	find a swapblk.  *  *	This routine must be called at splvm().  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|swblock
operator|*
operator|*
name|swp_pager_hash
argument_list|(
argument|vm_object_t object
argument_list|,
argument|vm_pindex_t index
argument_list|)
block|{ 	struct
name|swblock
operator|*
operator|*
name|pswap
block|; 	struct
name|swblock
operator|*
name|swap
block|;
name|index
operator|&=
operator|~
name|SWAP_META_MASK
block|;
name|pswap
operator|=
operator|&
name|swhash
index|[
operator|(
name|index
operator|^
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|object
operator|)
operator|&
name|swhash_mask
index|]
block|;
while|while
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|swap
operator|->
name|swb_object
operator|==
name|object
operator|&&
name|swap
operator|->
name|swb_index
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|pswap
operator|=
operator|&
name|swap
operator|->
name|swb_hnext
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	return
operator|(
name|pswap
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * SWP_PAGER_META_BUILD() -	add swap block to swap meta data for object  *  *	We first convert the object to a swap object if it is a default  *	object.  *  *	The specified swapblk is added to the object's swap metadata.  If  *	the swapblk is not valid, it is freed instead.  Any previously  *	assigned swapblk is freed.  *  *	This routine must be called at splvm(), except when used to convert  *	an OBJT_DEFAULT object into an OBJT_SWAP object.   */
end_comment

begin_function
unit|static
name|void
name|swp_pager_meta_build
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|daddr_t
name|swapblk
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
comment|/* 	 * Convert default object to swap object if necessary 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
block|{
name|object
operator|->
name|type
operator|=
name|OBJT_SWAP
expr_stmt|;
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_un_object_list
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Locate hash entry.  If not found create, but if we aren't adding 	 * anything just return.  If we run out of space in the map we wait 	 * and, since the hash table may have changed, retry. 	 */
name|retry
label|:
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|swapblk
operator|==
name|SWAPBLK_NONE
condition|)
return|return;
name|swap
operator|=
operator|*
name|pswap
operator|=
name|zalloc
argument_list|(
name|swap_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|swap_zone
operator|->
name|zpagecount
operator|>=
name|swap_zone
operator|->
name|zpagemax
condition|)
name|printf
argument_list|(
literal|"swap zone exhausted, increase kern.maxswzone\n"
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|swap
operator|->
name|swb_hnext
operator|=
name|NULL
expr_stmt|;
name|swap
operator|->
name|swb_object
operator|=
name|object
expr_stmt|;
name|swap
operator|->
name|swb_index
operator|=
name|index
operator|&
operator|~
name|SWAP_META_MASK
expr_stmt|;
name|swap
operator|->
name|swb_count
operator|=
literal|0
expr_stmt|;
operator|++
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|i
control|)
name|swap
operator|->
name|swb_pages
index|[
name|i
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
comment|/* 	 * Delete prior contents of metadata 	 */
name|index
operator|&=
name|SWAP_META_MASK
expr_stmt|;
if|if
condition|(
name|swap
operator|->
name|swb_pages
index|[
name|index
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|swap
operator|->
name|swb_pages
index|[
name|index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|swap
operator|->
name|swb_count
expr_stmt|;
block|}
comment|/* 	 * Enter block into metadata 	 */
name|swap
operator|->
name|swb_pages
index|[
name|index
index|]
operator|=
name|swapblk
expr_stmt|;
if|if
condition|(
name|swapblk
operator|!=
name|SWAPBLK_NONE
condition|)
operator|++
name|swap
operator|->
name|swb_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE() - free a range of blocks in the object's swap metadata  *  *	The requested range of blocks is freed, with any associated swap   *	returned to the swap bitmap.  *  *	This routine will free swap metadata structures as they are cleaned   *	out.  This routine does *NOT* operate on swap metadata associated  *	with resident pages.  *  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|daddr_t
name|v
init|=
name|swap
operator|->
name|swb_pages
index|[
name|index
operator|&
name|SWAP_META_MASK
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|swap
operator|->
name|swb_pages
index|[
name|index
operator|&
name|SWAP_META_MASK
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
operator|--
name|swap
operator|->
name|swb_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
block|}
operator|--
name|count
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
init|=
name|SWAP_META_PAGES
operator|-
operator|(
name|index
operator|&
name|SWAP_META_MASK
operator|)
decl_stmt|;
name|count
operator|-=
name|n
expr_stmt|;
name|index
operator|+=
name|n
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE_ALL() - destroy all swap metadata associated with object  *  *	This routine locates and destroys all swap metadata associated with  *	an object.  *  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free_all
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|daddr_t
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
while|while
condition|(
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
condition|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|v
init|=
name|swap
operator|->
name|swb_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
operator|--
name|swap
operator|->
name|swb_count
expr_stmt|;
name|swp_pager_freeswapspace
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|swap
operator|->
name|swb_count
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"swap_pager_meta_free_all: swb_count != 0"
argument_list|)
expr_stmt|;
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
name|index
operator|+=
name|SWAP_META_PAGES
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0x20000000
condition|)
name|panic
argument_list|(
literal|"swp_pager_meta_free_all: failed to locate all swap meta blocks"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_METACTL() -  misc control of swap and vm_page_t meta data.  *  *	This routine is capable of looking up, popping, or freeing  *	swapblk assignments in the swap meta data or in the vm_page_t.  *	The routine typically returns the swapblk being looked-up, or popped,  *	or SWAPBLK_NONE if the block was freed, or SWAPBLK_NONE if the block  *	was invalid.  This routine will automatically free any invalid   *	meta-data swapblks.  *  *	It is not possible to store invalid swapblks in the swap meta data  *	(other then a literal 'SWAPBLK_NONE'), so we don't bother checking.  *  *	When acting on a busy resident page and paging is in progress, we   *	have to wait until paging is complete but otherwise can act on the   *	busy page.  *  *	This routine must be called at splvm().  *  *	SWM_FREE	remove and free swap block from metadata  *	SWM_POP		remove from meta data but do not free.. pop it out  */
end_comment

begin_function
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|daddr_t
name|r1
decl_stmt|;
comment|/* 	 * The meta data only exists of the object is OBJT_SWAP  	 * and even then might not be allocated yet. 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
name|r1
operator|=
name|SWAPBLK_NONE
expr_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|index
operator|&=
name|SWAP_META_MASK
expr_stmt|;
name|r1
operator|=
name|swap
operator|->
name|swb_pages
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SWM_FREE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|r1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|SWM_FREE
operator||
name|SWM_POP
operator|)
condition|)
block|{
name|swap
operator|->
name|swb_pages
index|[
name|index
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
operator|--
name|swap
operator|->
name|swb_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|r1
operator|)
return|;
block|}
end_function

end_unit

