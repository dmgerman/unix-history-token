begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Matthew Dillon,  * Copyright (c) 1994 John S. Dyson  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *				New Swap System  *				Matthew Dillon  *  * Radix Bitmap 'blists'.  *  *	- The new swapper uses the new radix bitmap code.  This should scale  *	  to arbitrarily small or arbitrarily large swap spaces and an almost  *	  arbitrary degree of fragmentation.  *  * Features:  *  *	- on the fly reallocation of swap during putpages.  The new system  *	  does not try to keep previously allocated swap blocks for dirty  *	  pages.    *  *	- on the fly deallocation of swap  *  *	- No more garbage collection required.  Unnecessarily allocated swap  *	  blocks only exist for dirty vm_page_t's now and these are already  *	  cycled (in a high-load system) by the pager.  We also do on-the-fly  *	  removal of invalidated swap blocks when a page is destroyed  *	  or renamed.  *  * from: Utah $Hdr: swap_pager.c 1.4 91/04/30$  *  *	@(#)swap_pager.c	8.9 (Berkeley) 3/21/94  *	@(#)vm_swap.c	8.5 (Berkeley) 2/17/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|"opt_swap.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_comment
comment|/*  * SWB_NPAGES must be a power of 2.  It may be set to 1, 2, 4, 8, or 16  * pages per allocation.  We recommend you stick with the default of 8.  * The 16-page limit is due to the radix code (kern/subr_blist.c).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PAGEOUT_CLUSTER
end_ifndef

begin_define
define|#
directive|define
name|MAX_PAGEOUT_CLUSTER
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SWB_NPAGES
argument_list|)
end_if

begin_define
define|#
directive|define
name|SWB_NPAGES
value|MAX_PAGEOUT_CLUSTER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Piecemeal swap metadata structure.  Swap is stored in a radix tree.  *  * If SWB_NPAGES is 8 and sizeof(char *) == sizeof(daddr_t), our radix  * is basically 8.  Assuming PAGE_SIZE == 4096, one tree level represents  * 32K worth of data, two levels represent 256K, three levels represent  * 2 MBytes.   This is acceptable.  *  * Overall memory utilization is about the same as the old swap structure.  */
end_comment

begin_define
define|#
directive|define
name|SWCORRECT
parameter_list|(
name|n
parameter_list|)
value|(sizeof(void *) * (n) / sizeof(daddr_t))
end_define

begin_define
define|#
directive|define
name|SWAP_META_PAGES
value|(SWB_NPAGES * 2)
end_define

begin_define
define|#
directive|define
name|SWAP_META_MASK
value|(SWAP_META_PAGES - 1)
end_define

begin_struct
struct|struct
name|swblock
block|{
name|struct
name|swblock
modifier|*
name|swb_hnext
decl_stmt|;
name|vm_object_t
name|swb_object
decl_stmt|;
name|vm_pindex_t
name|swb_index
decl_stmt|;
name|int
name|swb_count
decl_stmt|;
name|daddr_t
name|swb_pages
index|[
name|SWAP_META_PAGES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sw_dev_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|swdevt
argument_list|)
name|swtailq
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|swtailq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|swdevt
modifier|*
name|swdevhd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate from here next */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswapdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of swap devices */
end_comment

begin_decl_stmt
name|int
name|swap_pager_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swdev_syscall_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* serialize swap(on|off) */
end_comment

begin_function_decl
specifier|static
name|void
name|swapdev_strategy
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sw
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SWM_FREE
value|0x02
end_define

begin_comment
comment|/* free, period			*/
end_comment

begin_define
define|#
directive|define
name|SWM_POP
value|0x04
end_define

begin_comment
comment|/* pop out			*/
end_comment

begin_decl_stmt
name|int
name|swap_pager_full
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (task killing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swap_pager_almost_full
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (w/hysteresis)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_rcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free read buffers			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / synchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / asynchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assigned maximum			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_cluster_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum VOP I/O allowed		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swblock
modifier|*
modifier|*
name|swhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swhash_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|swhash_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_async_max
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum in-progress async I/O's	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|sw_alloc_sx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_async_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|swap_async_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum running async swap ops"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * "named" and "unnamed" anon region objects.  Try to reduce the overhead  * of searching a named list by hashing it just a little.  */
end_comment

begin_define
define|#
directive|define
name|NOBJLISTS
value|8
end_define

begin_define
define|#
directive|define
name|NOBJLIST
parameter_list|(
name|handle
parameter_list|)
define|\
value|(&swap_pager_object_list[((int)(intptr_t)handle>> 4)& (NOBJLISTS-1)])
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sw_alloc_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protect list manipulation */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pagerlst
name|swap_pager_object_list
index|[
name|NOBJLISTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|swap_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|swap_zone_obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pagerops for OBJT_SWAP - "swap pager".  Some ops are also global procedure  * calls hooked from other parts of the VM system and do not appear here.  * (see vm/swap_pager.h).  */
end_comment

begin_function_decl
specifier|static
name|vm_object_t
name|swap_pager_alloc
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swap_pager_getpages
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_putpages
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|boolean_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
modifier|*
name|before
parameter_list|,
name|int
modifier|*
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_unswapped
parameter_list|(
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_swapoff
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pagerops
name|swappagerops
init|=
block|{
operator|.
name|pgo_init
operator|=
name|swap_pager_init
block|,
comment|/* early system initialization of pager	*/
operator|.
name|pgo_alloc
operator|=
name|swap_pager_alloc
block|,
comment|/* allocate an OBJT_SWAP object		*/
operator|.
name|pgo_dealloc
operator|=
name|swap_pager_dealloc
block|,
comment|/* deallocate an OBJT_SWAP object	*/
operator|.
name|pgo_getpages
operator|=
name|swap_pager_getpages
block|,
comment|/* pagein				*/
operator|.
name|pgo_putpages
operator|=
name|swap_pager_putpages
block|,
comment|/* pageout				*/
operator|.
name|pgo_haspage
operator|=
name|swap_pager_haspage
block|,
comment|/* get backing store status for page	*/
operator|.
name|pgo_pageunswapped
operator|=
name|swap_pager_unswapped
block|,
comment|/* remove swap related to page		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * dmmax is in page-sized chunks with the new swap system.  It was  * dev-bsized chunks in the old.  dmmax is always a power of 2.  *  * swap_*() routines are externally accessible.  swp_*() routines are  * internal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nswap_lowat
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswap_hiwat
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|dmmax
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dmmax
argument_list|,
literal|0
argument_list|,
literal|"Maximum size of a swap block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|swp_sizecheck
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_async_iodone
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swapongeom
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swaponvp
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swapoff_one
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Swap bitmap functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|swp_pager_freeswapspace
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|int
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|swp_pager_getswapspace
parameter_list|(
name|int
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Metadata functions  */
end_comment

begin_function_decl
specifier|static
name|struct
name|swblock
modifier|*
modifier|*
name|swp_pager_hash
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_build
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_free
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_free_all
parameter_list|(
name|vm_object_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SWP_SIZECHECK() -	update swap_pager_full indication  *	  *	update the swap_pager_almost_full indication and warn when we are  *	about to run out of swap space, using lowat/hiwat hysteresis.  *  *	Clear swap_pager_full ( task killing ) indication when lowat is met.  *  *	No restrictions on call  *	This routine may not block.  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swp_sizecheck
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|swap_pager_avail
operator|<
name|nswap_lowat
condition|)
block|{
if|if
condition|(
name|swap_pager_almost_full
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: out of swap space\n"
argument_list|)
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|swap_pager_full
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swap_pager_avail
operator|>
name|nswap_hiwat
condition|)
name|swap_pager_almost_full
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_HASH() -	hash swap meta data  *  *	This is an helper function which hashes the swapblk given  *	the object and page index.  It returns a pointer to a pointer  *	to the object, or a pointer to a NULL pointer if it could not  *	find a swapblk.  *  *	This routine must be called at splvm().  */
end_comment

begin_function
specifier|static
name|struct
name|swblock
modifier|*
modifier|*
name|swp_pager_hash
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|index
operator|&=
operator|~
operator|(
name|vm_pindex_t
operator|)
name|SWAP_META_MASK
expr_stmt|;
name|pswap
operator|=
operator|&
name|swhash
index|[
operator|(
name|index
operator|^
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|object
operator|)
operator|&
name|swhash_mask
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|swap
operator|->
name|swb_object
operator|==
name|object
operator|&&
name|swap
operator|->
name|swb_index
operator|==
name|index
condition|)
block|{
break|break;
block|}
name|pswap
operator|=
operator|&
name|swap
operator|->
name|swb_hnext
expr_stmt|;
block|}
return|return
operator|(
name|pswap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_INIT() -	initialize the swap pager!  *  *	Expected to be started from system init.  NOTE:  This code is run   *	before much else so be careful what you depend on.  Most of the VM  *	system has yet to be initialized at this point.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize object lists 	 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOBJLISTS
condition|;
operator|++
name|i
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_object_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|,
literal|"swap_pager list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|,
literal|"swapdev"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Device Stripe, in PAGE_SIZE'd blocks 	 */
name|dmmax
operator|=
name|SWB_NPAGES
operator|*
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_SWAP_INIT() - swap pager initialization from pageout process  *  *	Expected to be started from pageout process once, prior to entering  *	its main loop.  */
end_comment

begin_function
name|void
name|swap_pager_swap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|n2
decl_stmt|;
comment|/* 	 * Number of in-transit swap bp operations.  Don't 	 * exhaust the pbufs completely.  Make sure we 	 * initialize workable values (0 will work for hysteresis 	 * but it isn't very efficient). 	 * 	 * The nsw_cluster_max is constrained by the bp->b_pages[] 	 * array (MAXPHYS/PAGE_SIZE) and our locally defined 	 * MAX_PAGEOUT_CLUSTER.   Also be aware that swap ops are 	 * constrained by the swap device interleave stripe size. 	 * 	 * Currently we hardwire nsw_wcount_async to 4.  This limit is  	 * designed to prevent other I/O from having high latencies due to 	 * our pageout I/O.  The value 4 works well for one or two active swap 	 * devices but is probably a little low if you have more.  Even so, 	 * a higher value would probably generate only a limited improvement 	 * with three or four active swap devices since the system does not 	 * typically have to pageout at extreme bandwidths.   We will want 	 * at least 2 per swap devices, and 4 is a pretty good value if you 	 * have one NFS swap device due to the command/ack latency over NFS. 	 * So it all works out pretty well. 	 */
name|nsw_cluster_max
operator|=
name|min
argument_list|(
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
argument_list|,
name|MAX_PAGEOUT_CLUSTER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
name|nsw_rcount
operator|=
operator|(
name|nswbuf
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|nsw_wcount_sync
operator|=
operator|(
name|nswbuf
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|nsw_wcount_async
operator|=
literal|4
expr_stmt|;
name|nsw_wcount_async_max
operator|=
name|nsw_wcount_async
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize our zone.  Right now I'm just guessing on the number 	 * we need based on the number of pages in the system.  Each swblock 	 * can hold 16 pages, so this is probably overkill.  This reservation 	 * is typically limited to around 32MB by default. 	 */
name|n
operator|=
name|cnt
operator|.
name|v_page_count
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|maxswzone
operator|&&
name|n
operator|>
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
condition|)
name|n
operator|=
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n
expr_stmt|;
name|swap_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"SWAPMETA"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
operator||
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"failed to create swap_zone."
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uma_zone_set_obj
argument_list|(
name|swap_zone
argument_list|,
operator|&
name|swap_zone_obj
argument_list|,
name|n
argument_list|)
condition|)
break|break;
comment|/* 		 * if the allocation failed, try a zone two thirds the 		 * size of the previous attempt. 		 */
name|n
operator|-=
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|n2
operator|!=
name|n
condition|)
name|printf
argument_list|(
literal|"Swap zone entries reduced from %d to %d.\n"
argument_list|,
name|n2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n
expr_stmt|;
comment|/* 	 * Initialize our meta-data hash table.  The swapper does not need to 	 * be quite as efficient as the VM system, so we do not use an  	 * oversized hash table. 	 * 	 * 	n: 		size of hash table, must be power of 2 	 *	swhash_mask:	hash table index mask 	 */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|n2
operator|/
literal|8
condition|;
name|n
operator|*=
literal|2
control|)
empty_stmt|;
name|swhash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|swblock
operator|*
argument_list|)
operator|*
name|n
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|swhash_mask
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|swhash_mtx
argument_list|,
literal|"swap_pager swhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_ALLOC() -	allocate a new OBJT_SWAP VM object and instantiate  *			its metadata structures.  *  *	This routine is called from the mmap and fork code to create a new  *	OBJT_SWAP object.  We do this by creating an OBJT_DEFAULT object  *	and then converting it with swp_pager_meta_build().  *  *	This routine may block in vm_object_allocate() and create a named  *	object lookup race, so we must interlock.   We must also run at  *	splvm() for the object lookup to handle races with interrupts, but  *	we do not have to maintain splvm() in between the lookup and the  *	add because (I believe) it is not possible to attempt to create  *	a new swap object w/handle when a default object with that handle  *	already exists.  *  * MPSAFE  */
end_comment

begin_function
specifier|static
name|vm_object_t
name|swap_pager_alloc
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|PAGE_MASK
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 		 * Reference existing named region or allocate new one.  There 		 * should not be a race here against swp_pager_meta_build() 		 * as called from vm_page_remove() in regards to the lookup 		 * of the handle. 		 */
name|sx_xlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|object
operator|=
name|vm_pager_object_lookup
argument_list|(
name|NOBJLIST
argument_list|(
name|handle
argument_list|)
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|object
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_DEALLOC() -	remove swap metadata from object  *  *	The swap backing for the object is destroyed.  The code is   *	designed such that we can reinstantiate it later, but this  *	routine is typically called only when the entire object is  *	about to be destroyed.  *  *	This routine may block, but no longer does.   *  *	The object must be locked or unreferenceable.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
comment|/* 	 * Remove from list right away so lookups will fail if we block for 	 * pageout completion. 	 */
if|if
condition|(
name|object
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|vm_object_pip_wait
argument_list|(
name|object
argument_list|,
literal|"swpdea"
argument_list|)
expr_stmt|;
comment|/* 	 * Free all remaining metadata.  We only bother to free it from  	 * the swap meta data.  We do not attempt to free swapblk's still 	 * associated with vm_page_t's for this object.  We do not care 	 * if paging is still in progress on some objects. 	 */
name|swp_pager_meta_free_all
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *			SWAP PAGER BITMAP ROUTINES			*  ************************************************************************/
end_comment

begin_comment
comment|/*  * SWP_PAGER_GETSWAPSPACE() -	allocate raw swap space  *  *	Allocate swap for the requested number of pages.  The starting  *	swap block number (a page index) is returned or SWAPBLK_NONE  *	if the allocation failed.  *  *	Also has the side effect of advising that somebody made a mistake  *	when they configured swap and didn't configure enough.  *  *	Must be called at splvm() to avoid races with bitmap frees from  *	vm_page_remove() aka swap_pager_page_removed().  *  *	This routine may not block  *	This routine must be called at splvm().  *  *	We allocate in round-robin fashion from the configured devices.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|swp_pager_getswapspace
parameter_list|(
name|int
name|npages
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blk
operator|=
name|SWAPBLK_NONE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|=
name|swdevhd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nswapdev
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|swtailq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|sw_flags
operator|&
name|SW_CLOSING
operator|)
condition|)
block|{
name|blk
operator|=
name|blist_alloc
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|blk
operator|+=
name|sp
operator|->
name|sw_first
expr_stmt|;
name|sp
operator|->
name|sw_used
operator|+=
name|npages
expr_stmt|;
name|swap_pager_avail
operator|-=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
name|swdevhd
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|sp
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_full
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager_getswapspace(%d): failed\n"
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|swap_pager_full
operator|=
literal|2
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
name|swdevhd
operator|=
name|NULL
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swp_pager_isondev
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
return|return
operator|(
name|blk
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|blk
operator|<
name|sp
operator|->
name|sw_end
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swp_pager_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|bp
operator|->
name|b_blkno
operator|<
name|sp
operator|->
name|sw_end
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_strategy
argument_list|(
name|bp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"Swapdev not found"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_FREESWAPSPACE() -	free raw swap space   *  *	This routine returns the specified swap blocks back to the bitmap.  *  *	Note:  This routine may not block (it could in the old swap code),  *	and through the use of the new blist routines it does not block.  *  *	We must be called at splvm() to avoid races with bitmap frees from  *	vm_page_remove() aka swap_pager_page_removed().  *  *	This routine may not block  *	This routine must be called at splvm().  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_freeswapspace
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|blk
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|blk
operator|<
name|sp
operator|->
name|sw_end
condition|)
block|{
name|sp
operator|->
name|sw_used
operator|-=
name|npages
expr_stmt|;
comment|/* 			 * If we are attempting to stop swapping on 			 * this device, we don't want to mark any 			 * blocks free lest they be reused.   			 */
if|if
condition|(
operator|(
name|sp
operator|->
name|sw_flags
operator|&
name|SW_CLOSING
operator|)
operator|==
literal|0
condition|)
block|{
name|blist_free
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
name|blk
operator|-
name|sp
operator|->
name|sw_first
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|swap_pager_avail
operator|+=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"Swapdev not found"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_FREESPACE() -	frees swap blocks associated with a page  *				range within an object.  *  *	This is a globally accessible routine.  *  *	This routine removes swapblk assignments from swap metadata.  *  *	The external callers of this routine typically have already destroyed   *	or renamed vm_page_t's associated with this range in the object so   *	we should be ok.  *  *	This routine may be called at any spl.  We up our spl to splvm temporarily  *	in order to perform the metadata removal.  */
end_comment

begin_function
name|void
name|swap_pager_freespace
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_RESERVE() - reserve swap blocks in object  *  *	Assigns swap blocks to the specified range within the object.  The   *	swap blocks are not zerod.  Any previous swap assignment is destroyed.  *  *	Returns 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|swap_pager_reserve
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|daddr_t
name|blk
init|=
name|SWAPBLK_NONE
decl_stmt|;
name|vm_pindex_t
name|beg
init|=
name|start
decl_stmt|;
comment|/* save start index */
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|BLIST_MAX_ALLOC
expr_stmt|;
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|beg
argument_list|,
name|start
operator|-
name|beg
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|blk
argument_list|)
expr_stmt|;
operator|--
name|size
expr_stmt|;
operator|++
name|start
expr_stmt|;
operator|++
name|blk
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_COPY() -  copy blocks from source pager to destination pager  *			and destroy the source.  *  *	Copy any valid swapblks from the source to the destination.  In  *	cases where both the source and destination have a valid swapblk,  *	we keep the destination's.  *  *	This routine is allowed to block.  It may block allocating metadata  *	indirectly through swp_pager_meta_build() or if paging is still in  *	progress on the source.   *  *	This routine can be called at any spl  *  *	XXX vm_page_collapse() kinda expects us not to block because we   *	supposedly do not need to allocate memory, but for the moment we  *	*may* have to get a little memory from the zone allocator, but  *	it is taken from the interrupt memory.  We should be ok.   *  *	The source object contains no vm_page_t's (which is just as well)  *  *	The source object is of type OBJT_SWAP.  *  *	The source and destination objects must be locked or   *	inaccessible (XXX are they ?)  */
end_comment

begin_function
name|void
name|swap_pager_copy
parameter_list|(
name|vm_object_t
name|srcobject
parameter_list|,
name|vm_object_t
name|dstobject
parameter_list|,
name|vm_pindex_t
name|offset
parameter_list|,
name|int
name|destroysource
parameter_list|)
block|{
name|vm_pindex_t
name|i
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|srcobject
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|dstobject
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If destroysource is set, we remove the source object from the  	 * swap_pager internal queue now.  	 */
if|if
condition|(
name|destroysource
condition|)
block|{
if|if
condition|(
name|srcobject
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|srcobject
operator|->
name|handle
argument_list|)
argument_list|,
name|srcobject
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * transfer source to destination. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dstobject
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|dstaddr
decl_stmt|;
comment|/* 		 * Locate (without changing) the swapblk on the destination, 		 * unless it is invalid in which case free it silently, or 		 * if the destination is a resident page, in which case the 		 * source is thrown away. 		 */
name|dstaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstaddr
operator|==
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 			 * Destination has no swapblk and is not resident, 			 * copy source. 			 */
name|daddr_t
name|srcaddr
decl_stmt|;
name|srcaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcaddr
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 				 * swp_pager_meta_build() can sleep. 				 */
name|vm_object_pip_add
argument_list|(
name|srcobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|dstobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
name|srcaddr
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Destination has valid swapblk or it is represented 			 * by a resident page.  We destroy the sourceblock. 			 */
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free left over swap blocks in source. 	 * 	 * We have to revert the type to OBJT_DEFAULT so we do not accidently 	 * double-remove the object from the swap queues. 	 */
if|if
condition|(
name|destroysource
condition|)
block|{
name|swp_pager_meta_free_all
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
comment|/* 		 * Reverting the type is not necessary, the caller is going 		 * to destroy srcobject directly, but I'm doing it here 		 * for consistency since we've removed the object from its 		 * queues. 		 */
name|srcobject
operator|->
name|type
operator|=
name|OBJT_DEFAULT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_HASPAGE() -	determine if we have good backing store for  *				the requested page.  *  *	We determine whether good backing store exists for the requested  *	page and return TRUE if it does, FALSE if it doesn't.  *  *	If TRUE, we also try to determine how much valid, contiguous backing  *	store exists before and after the requested page within a reasonable  *	distance.  We do not try to restrict it to the swap device stripe  *	(that is handled in getpages/putpages).  It probably isn't worth  *	doing here.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
modifier|*
name|before
parameter_list|,
name|int
modifier|*
name|after
parameter_list|)
block|{
name|daddr_t
name|blk0
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * do we have good backing store at the requested index ? 	 */
name|blk0
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk0
operator|==
name|SWAPBLK_NONE
condition|)
block|{
if|if
condition|(
name|before
condition|)
operator|*
name|before
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after
condition|)
operator|*
name|after
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * find backwards-looking contiguous good backing store 	 */
if|if
condition|(
name|before
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|SWB_NPAGES
operator|/
literal|2
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|blk
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|pindex
condition|)
break|break;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|-
name|i
condition|)
break|break;
block|}
operator|*
name|before
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * find forward-looking contiguous good backing store 	 */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|SWB_NPAGES
operator|/
literal|2
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|blk
decl_stmt|;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|+
name|i
condition|)
break|break;
block|}
operator|*
name|after
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_PAGE_UNSWAPPED() - remove swap backing store related to page  *  *	This removes any associated swap backing store, whether valid or  *	not, from the page.    *  *	This routine is typically called when a page is made dirty, at  *	which point any associated swap can be freed.  MADV_FREE also  *	calls us in a special-case situation  *  *	NOTE!!!  If the page is clean and the swap was valid, the caller  *	should make the page dirty before calling this routine.  This routine  *	does NOT change the m->dirty status of the page.  Also: MADV_FREE  *	depends on it.  *  *	This routine may not block  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_unswapped
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|swp_pager_meta_ctl
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_GETPAGES() - bring pages in from swap  *  *	Attempt to retrieve (m, count) pages from backing store, but make  *	sure we retrieve at least m[reqpage].  We try to load in as large  *	a chunk surrounding m[reqpage] as is contiguous in swap and which  *	belongs to the same object.  *  *	The code is designed for asynchronous operation and   *	immediate-notification of 'reqpage' but tends not to be  *	used that way.  Please do not optimize-out this algorithmic  *	feature, I intend to improve on it in the future.  *  *	The parent has a single vm_object_pip_add() reference prior to  *	calling us and we should return with the same.  *  *	The parent has BUSY'd the pages.  We should return with 'm'  *	left busy, but the others adjusted.  */
end_comment

begin_function
specifier|static
name|int
name|swap_pager_getpages
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|reqpage
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|vm_page_t
name|mreq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|mreq
operator|=
name|m
index|[
name|reqpage
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|mreq
operator|->
name|object
operator|==
name|object
argument_list|,
operator|(
literal|"swap_pager_getpages: object mismatch %p/%p"
operator|,
name|object
operator|,
name|mreq
operator|->
name|object
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate range to retrieve.  The pages have already been assigned 	 * their swapblks.  We require a *contiguous* range but we know it to 	 * not span devices.   If we do not supply it, bad things 	 * happen.  Note that blk, iblk& jblk can be SWAPBLK_NONE, but the  	 * loops are set up such that the case(s) are handled implicitly. 	 * 	 * The swp_*() calls must be made at splvm().  vm_page_free() does 	 * not need to be, but it will go a little faster if it is. 	 */
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|mreq
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reqpage
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|daddr_t
name|iblk
decl_stmt|;
name|iblk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|m
index|[
name|i
index|]
operator|->
name|object
argument_list|,
name|m
index|[
name|i
index|]
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|iblk
operator|+
operator|(
name|reqpage
operator|-
name|i
operator|)
condition|)
break|break;
block|}
operator|++
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|reqpage
operator|+
literal|1
init|;
name|j
operator|<
name|count
condition|;
operator|++
name|j
control|)
block|{
name|daddr_t
name|jblk
decl_stmt|;
name|jblk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|m
index|[
name|j
index|]
operator|->
name|object
argument_list|,
name|m
index|[
name|j
index|]
operator|->
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|jblk
operator|-
operator|(
name|j
operator|-
name|reqpage
operator|)
condition|)
break|break;
block|}
comment|/* 	 * free pages outside our collection range.   Note: we never free 	 * mreq, it must remain busy throughout. 	 */
if|if
condition|(
literal|0
operator|<
name|i
operator|||
name|j
operator|<
name|count
condition|)
block|{
name|int
name|k
decl_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
operator|++
name|k
control|)
name|vm_page_free
argument_list|(
name|m
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|count
condition|;
operator|++
name|k
control|)
name|vm_page_free
argument_list|(
name|m
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Return VM_PAGER_FAIL if we have nothing to do.  Return mreq  	 * still busy, but the others unbusied. 	 */
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
comment|/* 	 * Getpbuf() can sleep. 	 */
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * Get a swap buffer header to perform the IO 	 */
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_rcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_PAGING
expr_stmt|;
comment|/* 	 * map our page(s) into kva for input 	 */
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|m
operator|+
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
operator|-
operator|(
name|reqpage
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
operator|(
name|j
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
operator|(
name|j
operator|-
name|i
operator|)
expr_stmt|;
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
operator|=
name|reqpage
operator|-
name|i
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
name|bp
operator|->
name|b_pages
index|[
name|k
operator|-
name|i
index|]
operator|=
name|m
index|[
name|k
index|]
expr_stmt|;
name|m
index|[
name|k
index|]
operator|->
name|oflags
operator||=
name|VPO_SWAPINPROG
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_npages
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|cnt
operator|.
name|v_swapin
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsin
operator|+=
name|bp
operator|->
name|b_npages
expr_stmt|;
comment|/* 	 * We still hold the lock on mreq, and our automatic completion routine 	 * does not remove it. 	 */
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * perform the I/O.  NOTE!!!  bp cannot be considered valid after 	 * this point because we automatically release it on completion. 	 * Instead, we look at the one page we are interested in which we 	 * still hold a lock on even through the I/O completion. 	 * 	 * The other pages in our m[] array are also released on completion, 	 * so we cannot assume they are valid anymore either. 	 * 	 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 	 */
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * wait for the page we want to complete.  VPO_SWAPINPROG is always 	 * cleared on completion.  If an I/O error occurs, SWAPBLK_NONE 	 * is set in the meta-data. 	 */
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|mreq
operator|->
name|oflags
operator|&
name|VPO_SWAPINPROG
operator|)
operator|!=
literal|0
condition|)
block|{
name|mreq
operator|->
name|oflags
operator||=
name|VPO_WANTED
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|mreq
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_intrans
operator|++
expr_stmt|;
if|if
condition|(
name|msleep
argument_list|(
name|mreq
argument_list|,
name|VM_OBJECT_MTX
argument_list|(
name|object
argument_list|)
argument_list|,
name|PSWP
argument_list|,
literal|"swread"
argument_list|,
name|hz
operator|*
literal|20
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: indefinite wait buffer: bufobj: %p, blkno: %jd, size: %ld\n"
argument_list|,
name|bp
operator|->
name|b_bufobj
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * mreq is left busied after completion, but all the other pages 	 * are freed.  If we had an unrecoverable read error the page will 	 * not be valid. 	 */
if|if
condition|(
name|mreq
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
block|}
comment|/* 	 * A final note: in a low swap situation, we cannot deallocate swap 	 * and mark a page dirty here because the caller is likely to mark 	 * the page clean when we return, causing the page to possibly revert  	 * to all-zero's later. 	 */
block|}
end_function

begin_comment
comment|/*  *	swap_pager_putpages:   *  *	Assign swap (if necessary) and initiate I/O on the specified pages.  *  *	We support both OBJT_DEFAULT and OBJT_SWAP objects.  DEFAULT objects  *	are automatically converted to SWAP objects.  *  *	In a low memory situation we may block in VOP_STRATEGY(), but the new   *	vm_page reservation system coupled with properly written VFS devices   *	should ensure that no low-memory deadlock occurs.  This is an area  *	which needs work.  *  *	The parent has N vm_object_pip_add() references prior to  *	calling us and will remove references for rtvals[] that are  *	not set to VM_PAGER_PEND.  We need to remove the rest on I/O  *	completion.  *  *	The parent has soft-busy'd the pages it passes us and will unbusy  *	those whos rtvals[] entry is not set to VM_PAGER_PEND on return.  *	We need to unbusy the rest on I/O completion.  */
end_comment

begin_function
name|void
name|swap_pager_putpages
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
name|int
modifier|*
name|rtvals
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|count
operator|&&
name|m
index|[
literal|0
index|]
operator|->
name|object
operator|!=
name|object
condition|)
block|{
name|panic
argument_list|(
literal|"swap_pager_getpages: object mismatch %p/%p"
argument_list|,
name|object
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step 1 	 * 	 * Turn object into OBJT_SWAP 	 * check for bogus sysops 	 * force sync if not pageout process 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|pageproc
condition|)
name|sync
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Step 2 	 * 	 * Update nsw parameters from swap_async_max sysctl values.   	 * Do not let the sysop crash the machine with bogus numbers. 	 */
name|mtx_lock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_async_max
operator|!=
name|nsw_wcount_async_max
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* 		 * limit range 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|swap_async_max
operator|)
operator|>
name|nswbuf
operator|/
literal|2
condition|)
name|n
operator|=
name|nswbuf
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|swap_async_max
operator|=
name|n
expr_stmt|;
comment|/* 		 * Adjust difference ( if possible ).  If the current async 		 * count is too low, we may not be able to make the adjustment 		 * at this time. 		 */
name|n
operator|-=
name|nsw_wcount_async_max
expr_stmt|;
if|if
condition|(
name|nsw_wcount_async
operator|+
name|n
operator|>=
literal|0
condition|)
block|{
name|nsw_wcount_async
operator|+=
name|n
expr_stmt|;
name|nsw_wcount_async_max
operator|+=
name|n
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Step 3 	 * 	 * Assign swap blocks and issue I/O.  We reallocate swap on the fly. 	 * The page is left dirty until the pageout operation completes 	 * successfully. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
name|n
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
comment|/* 		 * Maximum I/O size is limited by a number of factors. 		 */
name|n
operator|=
name|min
argument_list|(
name|BLIST_MAX_ALLOC
argument_list|,
name|count
operator|-
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nsw_cluster_max
argument_list|)
expr_stmt|;
comment|/* 		 * Get biggest block of swap we can.  If we fail, fall 		 * back and try to allocate a smaller block.  Don't go 		 * overboard trying to allocate space if it would overly 		 * fragment swap. 		 */
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
operator|&&
name|n
operator|>
literal|4
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * All I/O parameters have been satisfied, build the I/O 		 * request and assign the swap space. 		 */
if|if
condition|(
name|sync
operator|==
name|TRUE
condition|)
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_sync
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_ASYNC
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_PAGING
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|m
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|vm_page_t
name|mreq
init|=
name|m
index|[
name|i
operator|+
name|j
index|]
decl_stmt|;
name|swp_pager_meta_build
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|mreq
operator|->
name|pindex
argument_list|,
name|blk
operator|+
name|j
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_OK
expr_stmt|;
name|mreq
operator|->
name|oflags
operator||=
name|VPO_SWAPINPROG
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
operator|=
name|mreq
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|n
expr_stmt|;
comment|/* 		 * Must set dirty range for NFS to work. 		 */
name|bp
operator|->
name|b_dirtyoff
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|cnt
operator|.
name|v_swapout
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swappgsout
operator|+=
name|bp
operator|->
name|b_npages
expr_stmt|;
comment|/* 		 * asynchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 		 */
if|if
condition|(
name|sync
operator|==
name|FALSE
condition|)
block|{
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
comment|/* restart outter loop */
continue|continue;
block|}
comment|/* 		 * synchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 		 */
name|bp
operator|->
name|b_iodone
operator|=
name|bdone
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the sync I/O to complete, then update rtvals. 		 * We just set the rtvals[] to VM_PAGER_PEND so we can call 		 * our async completion routine at the end, thus avoiding a 		 * double-free. 		 */
name|bwait
argument_list|(
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swwrt"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
comment|/* 		 * Now that we are through with the bp, we can call the 		 * normal async completion, which frees everything up. 		 */
name|swp_pager_async_iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swp_pager_async_iodone:  *  *	Completion routine for asynchronous reads and writes from/to swap.  *	Also called manually by synchronous code to finish up a bp.  *  *	For READ operations, the pages are PG_BUSY'd.  For WRITE operations,   *	the pages are vm_page_t->busy'd.  For READ operations, we PG_BUSY   *	unbusy all pages except the 'main' request page.  For WRITE   *	operations, we vm_page_t->busy'd unbusy all pages ( we can do this   *	because we marked them all VM_PAGER_PEND on return from putpages ).  *  *	This routine may not block.  *	This routine is called at splbio() or better  *  *	We up ourselves to splvm() as required for various vm_page related  *	calls.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_async_iodone
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
init|=
name|NULL
decl_stmt|;
comment|/* 	 * report error 	 */
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: I/O error - %s failed; blkno %ld,"
literal|"size %ld, error %d\n"
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|)
condition|?
literal|"pagein"
else|:
literal|"pageout"
operator|)
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * remove the mapping for kernel virtual 	 */
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* 	 * cleanup pages.  If an error occurs writing to swap, we are in 	 * very serious trouble.  If it happens to be a disk error, though, 	 * we may be able to recover by reassigning the swap later on.  So 	 * in this case we remove the m->swapblk assignment for the page  	 * but do not free it in the rlist.  The errornous block(s) are thus 	 * never reallocated as swap.  Redirty the page and continue. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
operator|++
name|i
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|m
operator|->
name|oflags
operator|&=
operator|~
name|VPO_SWAPINPROG
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
block|{
comment|/* 			 * If an error occurs I'd love to throw the swapblk 			 * away without freeing it back to swapspace, so it 			 * can never be used again.  But I can't from an  			 * interrupt. 			 */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* 				 * When reading, reqpage needs to stay 				 * locked for the parent, but all other 				 * pages can be freed.  We still want to 				 * wakeup the parent waiting on the page, 				 * though.  ( also: pg_reqpage can be -1 and  				 * not match anything ). 				 * 				 * We have to wake specifically requested pages 				 * up too because we cleared VPO_SWAPINPROG and 				 * someone may be waiting for that. 				 * 				 * NOTE: for reads, m->dirty will probably 				 * be overridden by the original caller of 				 * getpages so don't play cute tricks here. 				 */
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
condition|)
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|vm_page_flash
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * If i == bp->b_pager.pg_reqpage, do not wake  				 * the page up.  The caller needs to. 				 */
block|}
else|else
block|{
comment|/* 				 * If a write error occurs, reactivate page 				 * so it doesn't clog the inactive list, 				 * then finish the I/O. 				 */
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* 			 * For read success, clear dirty bits.  Nobody should 			 * have this page mapped but don't take any chances, 			 * make sure the pmap modify bits are also cleared. 			 * 			 * NOTE: for reads, m->dirty will probably be  			 * overridden by the original caller of getpages so 			 * we cannot set them in order to free the underlying 			 * swap in a low-swap situation.  I don't think we'd 			 * want to do that anyway, but it was an optimization 			 * that existed in the old swapper for a time before 			 * it got ripped out due to precisely this problem. 			 * 			 * If not the requested page then deactivate it. 			 * 			 * Note that the requested page, reqpage, is left 			 * busied, but we still have to wake it up.  The 			 * other pages are released (unbusied) by  			 * vm_page_wakeup().  We do not set reqpage's 			 * valid bits here, it is up to the caller. 			 */
name|pmap_clear_modify
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * We have to wake specifically requested pages 			 * up too because we cleared VPO_SWAPINPROG and 			 * could be waiting for it in getpages.  However, 			 * be sure to not unbusy getpages specifically 			 * requested page - getpages expects it to be  			 * left busy. 			 */
if|if
condition|(
name|i
operator|!=
name|bp
operator|->
name|b_pager
operator|.
name|pg_reqpage
condition|)
block|{
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_page_flash
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * For write success, clear the modify and dirty  			 * status, then finish the I/O ( which decrements the  			 * busy count and possibly wakes waiter's up ). 			 */
name|pmap_clear_modify
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_count_severe
argument_list|()
condition|)
name|vm_page_try_to_cache
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
comment|/* 	 * adjust pip.  NOTE: the original parent may still have its own 	 * pip refs on the object. 	 */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|vm_object_pip_wakeupn
argument_list|(
name|object
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * swapdev_strategy() manually sets b_vp and b_bufobj before calling  	 * bstrategy(). Set them back to NULL now we're done with it, or we'll 	 * trigger a KASSERT in relpbuf(). 	 */
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
block|{
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * release the physical I/O buffer 	 */
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|)
condition|?
operator|&
name|nsw_rcount
else|:
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
condition|?
operator|&
name|nsw_wcount_async
else|:
operator|&
name|nsw_wcount_sync
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swap_pager_isswapped:  *  *	Return 1 if at least one page in the given object is paged  *	out to the given swap device.  *  *	This routine may not block.  */
end_comment

begin_function
name|int
name|swap_pager_isswapped
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|daddr_t
name|index
init|=
literal|0
decl_stmt|;
name|int
name|bcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|bcount
operator|=
literal|0
init|;
name|bcount
operator|<
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
condition|;
name|bcount
operator|++
control|)
block|{
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|swp_pager_isondev
argument_list|(
name|swap
operator|->
name|swb_pages
index|[
name|i
index|]
argument_list|,
name|sp
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|index
operator|+=
name|SWAP_META_PAGES
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0x20000000
condition|)
name|panic
argument_list|(
literal|"swap_pager_isswapped: failed to locate all swap meta blocks"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_FORCE_PAGEIN() - force a swap block to be paged in  *  *	This routine dissociates the page at the given index within a  *	swap block from its backing store, paging it in if necessary.  *	If the page is paged in, it is placed in the inactive queue,  *	since it had its backing store ripped out from under it.  *	We also attempt to swap in all other pages in the swap block,  *	we only guarantee that the one at the specified index is  *	paged in.  *  *	XXX - The code to page the whole block in doesn't work, so we  *	      revert to the one-by-one behavior for now.  Sigh.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|swp_pager_force_pagein
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|vm_object_pip_subtract
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_pager_page_unswapped
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swap_pager_getpages
argument_list|(
name|object
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"swap_pager_force_pagein: read from swap failed"
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|vm_object_pip_subtract
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_dontneed
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_pager_page_unswapped
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swap_pager_swapoff:  *  *	Page in all of the pages that have been paged out to the  *	given device.  The corresponding blocks in the bitmap must be  *	marked as allocated and the device must be flagged SW_CLOSING.  *	There may be no processes swapped out to the device.  *  *	This routine may block.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_swapoff
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|retries
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|full_rescan
label|:
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|swhash_mask
condition|;
name|i
operator|++
control|)
block|{
comment|/* '<=' is correct here */
name|restart
label|:
for|for
control|(
name|swap
operator|=
name|swhash
index|[
name|i
index|]
init|;
name|swap
operator|!=
name|NULL
condition|;
name|swap
operator|=
name|swap
operator|->
name|swb_hnext
control|)
block|{
name|vm_object_t
name|object
init|=
name|swap
operator|->
name|swb_object
decl_stmt|;
name|vm_pindex_t
name|pindex
init|=
name|swap
operator|->
name|swb_index
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|swp_pager_isondev
argument_list|(
name|swap
operator|->
name|swb_pages
index|[
name|j
index|]
argument_list|,
name|sp
argument_list|)
condition|)
block|{
comment|/* avoid deadlock */
if|if
condition|(
operator|!
name|VM_OBJECT_TRYLOCK
argument_list|(
name|object
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|swp_pager_force_pagein
argument_list|(
name|object
argument_list|,
name|pindex
operator|+
name|j
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sw_used
condition|)
block|{
comment|/* 		 * Objects may be locked or paging to the device being 		 * removed, so we will miss their pages and need to 		 * make another pass.  We have marked this device as 		 * SW_CLOSING, so the activity should finish soon. 		 */
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|retries
operator|>
literal|100
condition|)
block|{
name|panic
argument_list|(
literal|"swapoff: failed to locate %d swap blocks"
argument_list|,
name|sp
operator|->
name|sw_used
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"swpoff"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
goto|goto
name|full_rescan
goto|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  *				SWAP META DATA 				*  ************************************************************************  *  *	These routines manipulate the swap metadata stored in the   *	OBJT_SWAP object.  All swp_*() routines must be called at  *	splvm() because swap can be freed up by the low level vm_page  *	code which might be called from interrupts beyond what splbio() covers.  *  *	Swap metadata is implemented with a global hash and not directly  *	linked into the object.  Instead the object simply contains  *	appropriate tracking counters.  */
end_comment

begin_comment
comment|/*  * SWP_PAGER_META_BUILD() -	add swap block to swap meta data for object  *  *	We first convert the object to a swap object if it is a default  *	object.  *  *	The specified swapblk is added to the object's swap metadata.  If  *	the swapblk is not valid, it is freed instead.  Any previously  *	assigned swapblk is freed.  *  *	This routine must be called at splvm(), except when used to convert  *	an OBJT_DEFAULT object into an OBJT_SWAP object.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_build
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|daddr_t
name|swapblk
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Convert default object to swap object if necessary 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
block|{
name|object
operator|->
name|type
operator|=
name|OBJT_SWAP
expr_stmt|;
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_alloc_mtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Locate hash entry.  If not found create, but if we aren't adding 	 * anything just return.  If we run out of space in the map we wait 	 * and, since the hash table may have changed, retry. 	 */
name|retry
label|:
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|swapblk
operator|==
name|SWAPBLK_NONE
condition|)
goto|goto
name|done
goto|;
name|swap
operator|=
operator|*
name|pswap
operator|=
name|uma_zalloc
argument_list|(
name|swap_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|uma_zone_exhausted
argument_list|(
name|swap_zone
argument_list|)
condition|)
name|printf
argument_list|(
literal|"swap zone exhausted, increase kern.maxswzone\n"
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|swap
operator|->
name|swb_hnext
operator|=
name|NULL
expr_stmt|;
name|swap
operator|->
name|swb_object
operator|=
name|object
expr_stmt|;
name|swap
operator|->
name|swb_index
operator|=
name|pindex
operator|&
operator|~
operator|(
name|vm_pindex_t
operator|)
name|SWAP_META_MASK
expr_stmt|;
name|swap
operator|->
name|swb_count
operator|=
literal|0
expr_stmt|;
operator|++
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|i
control|)
name|swap
operator|->
name|swb_pages
index|[
name|i
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
comment|/* 	 * Delete prior contents of metadata 	 */
name|idx
operator|=
name|pindex
operator|&
name|SWAP_META_MASK
expr_stmt|;
if|if
condition|(
name|swap
operator|->
name|swb_pages
index|[
name|idx
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|swap
operator|->
name|swb_pages
index|[
name|idx
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|swap
operator|->
name|swb_count
expr_stmt|;
block|}
comment|/* 	 * Enter block into metadata 	 */
name|swap
operator|->
name|swb_pages
index|[
name|idx
index|]
operator|=
name|swapblk
expr_stmt|;
if|if
condition|(
name|swapblk
operator|!=
name|SWAPBLK_NONE
condition|)
operator|++
name|swap
operator|->
name|swb_count
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE() - free a range of blocks in the object's swap metadata  *  *	The requested range of blocks is freed, with any associated swap   *	returned to the swap bitmap.  *  *	This routine will free swap metadata structures as they are cleaned   *	out.  This routine does *NOT* operate on swap metadata associated  *	with resident pages.  *  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|daddr_t
name|count
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|daddr_t
name|v
init|=
name|swap
operator|->
name|swb_pages
index|[
name|index
operator|&
name|SWAP_META_MASK
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|swap
operator|->
name|swb_pages
index|[
name|index
operator|&
name|SWAP_META_MASK
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
operator|--
name|swap
operator|->
name|swb_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|uma_zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
block|}
operator|--
name|count
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
init|=
name|SWAP_META_PAGES
operator|-
operator|(
name|index
operator|&
name|SWAP_META_MASK
operator|)
decl_stmt|;
name|count
operator|-=
name|n
expr_stmt|;
name|index
operator|+=
name|n
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE_ALL() - destroy all swap metadata associated with object  *  *	This routine locates and destroys all swap metadata associated with  *	an object.  *  *	This routine must be called at splvm()  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free_all
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|daddr_t
name|index
init|=
literal|0
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
while|while
condition|(
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
condition|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|v
init|=
name|swap
operator|->
name|swb_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
operator|--
name|swap
operator|->
name|swb_count
expr_stmt|;
name|swp_pager_freeswapspace
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|swap
operator|->
name|swb_count
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"swap_pager_meta_free_all: swb_count != 0"
argument_list|)
expr_stmt|;
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|uma_zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|index
operator|+=
name|SWAP_META_PAGES
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0x20000000
condition|)
name|panic
argument_list|(
literal|"swp_pager_meta_free_all: failed to locate all swap meta blocks"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_METACTL() -  misc control of swap and vm_page_t meta data.  *  *	This routine is capable of looking up, popping, or freeing  *	swapblk assignments in the swap meta data or in the vm_page_t.  *	The routine typically returns the swapblk being looked-up, or popped,  *	or SWAPBLK_NONE if the block was freed, or SWAPBLK_NONE if the block  *	was invalid.  This routine will automatically free any invalid   *	meta-data swapblks.  *  *	It is not possible to store invalid swapblks in the swap meta data  *	(other then a literal 'SWAPBLK_NONE'), so we don't bother checking.  *  *	When acting on a busy resident page and paging is in progress, we   *	have to wait until paging is complete but otherwise can act on the   *	busy page.  *  *	This routine must be called at splvm().  *  *	SWM_FREE	remove and free swap block from metadata  *	SWM_POP		remove from meta data but do not free.. pop it out  */
end_comment

begin_function
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|swblock
modifier|*
modifier|*
name|pswap
decl_stmt|;
name|struct
name|swblock
modifier|*
name|swap
decl_stmt|;
name|daddr_t
name|r1
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * The meta data only exists of the object is OBJT_SWAP  	 * and even then might not be allocated yet. 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
name|r1
operator|=
name|SWAPBLK_NONE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
name|pswap
operator|=
name|swp_pager_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swap
operator|=
operator|*
name|pswap
operator|)
operator|!=
name|NULL
condition|)
block|{
name|idx
operator|=
name|pindex
operator|&
name|SWAP_META_MASK
expr_stmt|;
name|r1
operator|=
name|swap
operator|->
name|swb_pages
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SWM_FREE
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|r1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|SWM_FREE
operator||
name|SWM_POP
operator|)
condition|)
block|{
name|swap
operator|->
name|swb_pages
index|[
name|idx
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
operator|--
name|swap
operator|->
name|swb_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pswap
operator|=
name|swap
operator|->
name|swb_hnext
expr_stmt|;
name|uma_zfree
argument_list|(
name|swap_zone
argument_list|,
name|swap
argument_list|)
expr_stmt|;
operator|--
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
expr_stmt|;
block|}
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|swhash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|r1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * System call swapon(name) enables swapping on device name,  * which must be in the swdevsw.  Return EBUSY  * if already swapping on this device.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|swapon_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|swapon
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swapon_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SWAPON
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
while|while
condition|(
name|swdev_syscall_active
condition|)
name|tsleep
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|,
name|PUSER
operator|-
literal|1
argument_list|,
literal|"swpon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|swdev_syscall_active
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Swap metadata may not fit in the KVM if we have physical 	 * memory of>1GB. 	 */
if|if
condition|(
name|swap_zone
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|ISOPEN
operator||
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|swapongeom
argument_list|(
name|td
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_vfc
operator|->
name|vfc_flags
operator|&
name|VFCF_NETWORK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Allow direct swapping to NFS regular files in the same 		 * way that nfs_mountroot() sets up diskless swapping. 		 */
name|error
operator|=
name|swaponvp
argument_list|(
name|td
argument_list|,
name|vp
argument_list|,
name|attr
operator|.
name|va_size
operator|/
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|done
label|:
name|swdev_syscall_active
operator|=
literal|0
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swaponsomething
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|u_long
name|nblks
parameter_list|,
name|sw_strategy_t
modifier|*
name|strategy
parameter_list|,
name|sw_close_t
modifier|*
name|close
parameter_list|,
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|swblk_t
name|dvbase
decl_stmt|;
name|u_long
name|mblocks
decl_stmt|;
comment|/* 	 * If we go beyond this, we get overflows in the radix 	 * tree bitmap code. 	 */
name|mblocks
operator|=
literal|0x40000000
operator|/
name|BLIST_META_RADIX
expr_stmt|;
if|if
condition|(
name|nblks
operator|>
name|mblocks
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: reducing size to maximum of %lu blocks per swap unit\n"
argument_list|,
name|mblocks
argument_list|)
expr_stmt|;
name|nblks
operator|=
name|mblocks
expr_stmt|;
block|}
comment|/* 	 * nblks is in DEV_BSIZE'd chunks, convert to PAGE_SIZE'd chunks. 	 * First chop nblks off to page-align it, then convert. 	 *  	 * sw->sw_nblks is in page-sized chunks now too. 	 */
name|nblks
operator|&=
operator|~
operator|(
name|ctodb
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|nblks
operator|=
name|dbtoc
argument_list|(
name|nblks
argument_list|)
expr_stmt|;
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sp
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_vp
operator|=
name|vp
expr_stmt|;
name|sp
operator|->
name|sw_id
operator|=
name|id
expr_stmt|;
name|sp
operator|->
name|sw_dev
operator|=
name|dev
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sw_nblks
operator|=
name|nblks
expr_stmt|;
name|sp
operator|->
name|sw_used
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sw_strategy
operator|=
name|strategy
expr_stmt|;
name|sp
operator|->
name|sw_close
operator|=
name|close
expr_stmt|;
name|sp
operator|->
name|sw_blist
operator|=
name|blist_create
argument_list|(
name|nblks
argument_list|)
expr_stmt|;
comment|/* 	 * Do not free the first two block in order to avoid overwriting 	 * any bsd label at the front of the partition 	 */
name|blist_free
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
literal|2
argument_list|,
name|nblks
operator|-
literal|2
argument_list|)
expr_stmt|;
name|dvbase
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tsp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|tsp
operator|->
name|sw_end
operator|>=
name|dvbase
condition|)
block|{
comment|/* 			 * We put one uncovered page between the devices 			 * in order to definitively prevent any cross-device 			 * I/O requests 			 */
name|dvbase
operator|=
name|tsp
operator|->
name|sw_end
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|sw_first
operator|=
name|dvbase
expr_stmt|;
name|sp
operator|->
name|sw_end
operator|=
name|dvbase
operator|+
name|nblks
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swtailq
argument_list|,
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
name|nswapdev
operator|++
expr_stmt|;
name|swap_pager_avail
operator|+=
name|nblks
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SYSCALL: swapoff(devname)  *  * Disable swapping on the given device.  *  * XXX: Badly designed system call: it should use a device index  * rather than filename as specification.  We keep sw_vp around  * only to make this work.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|swapoff_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|swapoff
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swapoff_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SWAPOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
while|while
condition|(
name|swdev_syscall_active
condition|)
name|tsleep
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|,
name|PUSER
operator|-
literal|1
argument_list|,
literal|"swpoff"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|swdev_syscall_active
operator|=
literal|1
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_vp
operator|==
name|vp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|swapoff_one
argument_list|(
name|sp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|done
label|:
name|swdev_syscall_active
operator|=
literal|0
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swapoff_one
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|u_long
name|nblks
decl_stmt|,
name|dvbase
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
operator|(
name|void
operator|)
name|vn_lock
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|mac_check_system_swapoff
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|nblks
operator|=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
comment|/* 	 * We can turn off this swap device safely only if the 	 * available virtual memory in the system will fit the amount 	 * of data we will have to page back in, plus an epsilon so 	 * the system doesn't become critically low on swap space. 	 */
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|+
name|swap_pager_avail
operator|<
name|nblks
operator|+
name|nswap_lowat
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Prevent further allocations on this device. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator||=
name|SW_CLOSING
expr_stmt|;
for|for
control|(
name|dvbase
operator|=
literal|0
init|;
name|dvbase
operator|<
name|sp
operator|->
name|sw_end
condition|;
name|dvbase
operator|+=
name|dmmax
control|)
block|{
name|swap_pager_avail
operator|-=
name|blist_fill
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
name|dvbase
argument_list|,
name|dmmax
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Page in the contents of the device and close it. 	 */
name|swap_pager_swapoff
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_close
argument_list|(
name|td
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swtailq
argument_list|,
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
name|nswapdev
operator|--
expr_stmt|;
if|if
condition|(
name|nswapdev
operator|==
literal|0
condition|)
block|{
name|swap_pager_full
operator|=
literal|2
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|swdevhd
operator|==
name|sp
condition|)
name|swdevhd
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|blist_destroy
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swapoff_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spt
decl_stmt|;
specifier|const
name|char
modifier|*
name|devname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
while|while
condition|(
name|swdev_syscall_active
condition|)
name|tsleep
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|,
name|PUSER
operator|-
literal|1
argument_list|,
literal|"swpoff"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|swdev_syscall_active
operator|=
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|,
argument|spt
argument_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|devname
operator|=
name|sp
operator|->
name|sw_vp
operator|->
name|v_rdev
operator|->
name|si_name
expr_stmt|;
else|else
name|devname
operator|=
literal|"[file]"
expr_stmt|;
name|error
operator|=
name|swapoff_one
argument_list|(
name|sp
argument_list|,
operator|&
name|thread0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot remove swap device %s (error=%d), "
literal|"skipping.\n"
argument_list|,
name|devname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Swap device %s removed.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swdev_syscall_active
operator|=
literal|0
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|swdev_syscall_active
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_pager_status
parameter_list|(
name|int
modifier|*
name|total
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
operator|*
name|total
operator|=
literal|0
expr_stmt|;
operator|*
name|used
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
operator|*
name|total
operator|+=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
operator|*
name|used
operator|+=
name|sp
operator|->
name|sw_used
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_vm_swap_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
modifier|*
name|name
init|=
operator|(
name|int
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|xswdev
name|xs
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|arg2
operator|!=
literal|1
condition|)
comment|/* name length */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|n
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|n
operator|==
operator|*
name|name
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|xs
operator|.
name|xsw_version
operator|=
name|XSWDEV_VERSION
expr_stmt|;
name|xs
operator|.
name|xsw_dev
operator|=
name|sp
operator|->
name|sw_dev
expr_stmt|;
name|xs
operator|.
name|xsw_flags
operator|=
name|sp
operator|->
name|sw_flags
expr_stmt|;
name|xs
operator|.
name|xsw_nblks
operator|=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
name|xs
operator|.
name|xsw_used
operator|=
name|sp
operator|->
name|sw_used
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xs
argument_list|,
sizeof|sizeof
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|n
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|nswapdev
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nswapdev
argument_list|,
literal|0
argument_list|,
literal|"Number of swap devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_info
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sysctl_vm_swap_info
argument_list|,
literal|"Swap statistics by device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * vmspace_swap_count() - count the approximate swap useage in pages for a  *			  vmspace.  *  *	The map must be locked.  *  *	Swap useage is determined by taking the proportional swap used by  *	VM objects backing the VM map.  To make up for fractional losses,  *	if the VM object has any swap use at all the associated map entries  *	count for at least 1 swap page.  */
end_comment

begin_function
name|int
name|vmspace_swap_count
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
name|vm_map_t
name|map
init|=
operator|&
name|vmspace
operator|->
name|vm_map
decl_stmt|;
name|vm_map_entry_t
name|cur
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|cur
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
operator|(
name|cur
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|object
operator|=
name|cur
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_LOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|&&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
operator|(
name|cur
operator|->
name|end
operator|-
name|cur
operator|->
name|start
operator|)
operator|/
name|PAGE_SIZE
decl_stmt|;
name|count
operator|+=
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_bcount
operator|*
name|SWAP_META_PAGES
operator|*
name|n
operator|/
name|object
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GEOM backend  *  * Swapping onto disk devices.  *  */
end_comment

begin_decl_stmt
specifier|static
name|g_orphan_t
name|swapgeom_orphan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_swap_class
init|=
block|{
operator|.
name|name
operator|=
literal|"SWAP"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|orphan
operator|=
name|swapgeom_orphan
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_swap_class
argument_list|,
name|g_class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|swapgeom_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp2
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bp2
operator|->
name|bio_caller2
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|=
name|bp2
operator|->
name|bio_flags
expr_stmt|;
if|if
condition|(
name|bp2
operator|->
name|bio_error
condition|)
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|bp2
operator|->
name|bio_completed
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|bp2
operator|->
name|bio_error
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX: We shouldn't really sleep here when we run out of buffers 	 * XXX: but the alternative is worse right now. 	 */
block|if (bio == NULL) { 		bp->b_error = ENOMEM; 		bp->b_ioflags |= BIO_ERROR; 		bufdone(bp); 		return; 	}
endif|#
directive|endif
name|bio
operator|->
name|bio_caller2
operator|=
name|bp
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|bp
operator|->
name|b_iocmd
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|-
name|sp
operator|->
name|sw_first
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|swapgeom_done
expr_stmt|;
name|g_io_request
argument_list|(
name|bio
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
if|if
condition|(
name|sp
operator|->
name|sw_id
operator|==
name|cp
condition|)
name|sp
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_close_ev
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_close
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sw
parameter_list|)
block|{
comment|/* XXX: direct call when Giant untangled */
name|g_waitfor_event
argument_list|(
name|swapgeom_close_ev
argument_list|,
name|sw
operator|->
name|sw_id
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|swh0h0
block|{
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|swapongeom_ev
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|swh0h0
modifier|*
name|swh
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|u_long
name|nblks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|swh
operator|=
name|arg
expr_stmt|;
name|swh
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|g_dev_getprovider
argument_list|(
name|swh
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|swh
operator|->
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
name|cp
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|cp
operator|->
name|provider
operator|==
name|pp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swh
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
return|return;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|g_swap_class
argument_list|,
literal|"swap"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Everytime you think you can improve the margin for 	 * footshooting, somebody depends on the ability to do so: 	 * savecore(8) wants to write to our swapdev so we cannot 	 * set an exclusive count :-( 	 */
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|swh
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|nblks
operator|=
name|pp
operator|->
name|mediasize
operator|/
name|DEV_BSIZE
expr_stmt|;
name|swaponsomething
argument_list|(
name|swh
operator|->
name|vp
argument_list|,
name|cp
argument_list|,
name|nblks
argument_list|,
name|swapgeom_strategy
argument_list|,
name|swapgeom_close
argument_list|,
name|dev2udev
argument_list|(
name|swh
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|swh
operator|->
name|error
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|swapongeom
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|swh0h0
name|swh
decl_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|swh
operator|.
name|dev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
name|swh
operator|.
name|vp
operator|=
name|vp
expr_stmt|;
name|swh
operator|.
name|error
operator|=
literal|0
expr_stmt|;
comment|/* XXX: direct call when Giant untangled */
name|error
operator|=
name|g_waitfor_event
argument_list|(
name|swapongeom_ev
argument_list|,
operator|&
name|swh
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|swh
operator|.
name|error
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VNODE backend  *  * This is used mainly for network filesystem (read: probably only tested  * with NFS) swapfiles.  *  */
end_comment

begin_function
specifier|static
name|void
name|swapdev_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp2
decl_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|ctodb
argument_list|(
name|bp
operator|->
name|b_blkno
operator|-
name|sp
operator|->
name|sw_first
argument_list|)
expr_stmt|;
name|vp2
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
name|vhold
argument_list|(
name|vp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bufobj
condition|)
name|bufobj_wdrop
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|bufobj_wref
argument_list|(
operator|&
name|vp2
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bufobj
operator|!=
operator|&
name|vp2
operator|->
name|v_bufobj
condition|)
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|vp2
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|vp2
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swapdev_close
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|VOP_CLOSE
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swaponvp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|u_long
name|nblks
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nblks
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_id
operator|==
name|vp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_system_swapon
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
endif|#
directive|endif
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|swaponsomething
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|nblks
argument_list|,
name|swapdev_strategy
argument_list|,
name|swapdev_close
argument_list|,
name|NODEV
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

