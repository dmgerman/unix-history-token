begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Matthew Dillon,  * Copyright (c) 1994 John S. Dyson  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *				New Swap System  *				Matthew Dillon  *  * Radix Bitmap 'blists'.  *  *	- The new swapper uses the new radix bitmap code.  This should scale  *	  to arbitrarily small or arbitrarily large swap spaces and an almost  *	  arbitrary degree of fragmentation.  *  * Features:  *  *	- on the fly reallocation of swap during putpages.  The new system  *	  does not try to keep previously allocated swap blocks for dirty  *	  pages.  *  *	- on the fly deallocation of swap  *  *	- No more garbage collection required.  Unnecessarily allocated swap  *	  blocks only exist for dirty vm_page_t's now and these are already  *	  cycled (in a high-load system) by the pager.  We also do on-the-fly  *	  removal of invalidated swap blocks when a page is destroyed  *	  or renamed.  *  * from: Utah $Hdr: swap_pager.c 1.4 91/04/30$  *  *	@(#)swap_pager.c	8.9 (Berkeley) 3/21/94  *	@(#)vm_swap.c	8.5 (Berkeley) 2/17/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_swap.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pctrie.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_comment
comment|/*  * MAX_PAGEOUT_CLUSTER must be a power of 2 between 1 and 64.  * The 64-page limit is due to the radix code (kern/subr_blist.c).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PAGEOUT_CLUSTER
end_ifndef

begin_define
define|#
directive|define
name|MAX_PAGEOUT_CLUSTER
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SWB_NPAGES
argument_list|)
end_if

begin_define
define|#
directive|define
name|SWB_NPAGES
value|MAX_PAGEOUT_CLUSTER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWAP_META_PAGES
value|PCTRIE_COUNT
end_define

begin_comment
comment|/*  * A swblk structure maps each page index within a  * SWAP_META_PAGES-aligned and sized range to the address of an  * on-disk swap block (or SWAPBLK_NONE). The collection of these  * mappings for an entire vm object is implemented as a pc-trie.  */
end_comment

begin_struct
struct|struct
name|swblk
block|{
name|vm_pindex_t
name|p
decl_stmt|;
name|daddr_t
name|d
index|[
name|SWAP_META_PAGES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMPGDATA
argument_list|,
literal|"vm_pgdata"
argument_list|,
literal|"swap pager private data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sw_dev_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|swdevt
argument_list|)
name|swtailq
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|swtailq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|swdevt
modifier|*
name|swdevhd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate from here next */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswapdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of swap devices */
end_comment

begin_decl_stmt
name|int
name|swap_pager_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|swdev_syscall_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* serialize swap(on|off) */
end_comment

begin_decl_stmt
specifier|static
name|vm_ooffset_t
name|swap_total
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_total
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|swap_total
argument_list|,
literal|0
argument_list|,
literal|"Total amount of available swap storage."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vm_ooffset_t
name|swap_reserved
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_reserved
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|swap_reserved
argument_list|,
literal|0
argument_list|,
literal|"Amount of swap storage needed to back all allocated anonymous memory."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|overcommit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|VM_OVERCOMMIT
argument_list|,
name|overcommit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|overcommit
argument_list|,
literal|0
argument_list|,
literal|"Configure virtual memory overcommit behavior. See tuning(7) "
literal|"for details."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|swzone
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swzone
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|swzone
argument_list|,
literal|0
argument_list|,
literal|"Actual size of swap metadata zone"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|swap_maxpages
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_maxpages
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|swap_maxpages
argument_list|,
literal|0
argument_list|,
literal|"Maximum amount of swap supported"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* bits from overcommit */
end_comment

begin_define
define|#
directive|define
name|SWAP_RESERVE_FORCE_ON
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SWAP_RESERVE_RLIMIT_ON
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SWAP_RESERVE_ALLOW_NONWIRED
value|(1<< 2)
end_define

begin_function
name|int
name|swap_reserve
parameter_list|(
name|vm_ooffset_t
name|incr
parameter_list|)
block|{
return|return
operator|(
name|swap_reserve_by_cred
argument_list|(
name|incr
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|swap_reserve_by_cred
parameter_list|(
name|vm_ooffset_t
name|incr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|vm_ooffset_t
name|r
decl_stmt|,
name|s
decl_stmt|;
name|int
name|res
decl_stmt|,
name|error
decl_stmt|;
specifier|static
name|int
name|curfail
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastfail
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|uip
operator|=
name|cred
operator|->
name|cr_ruidinfo
expr_stmt|;
if|if
condition|(
name|incr
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"swap_reserve:& PAGE_MASK"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_add
argument_list|(
name|curproc
argument_list|,
name|RACCT_SWAP
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|res
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|r
operator|=
name|swap_reserved
operator|+
name|incr
expr_stmt|;
if|if
condition|(
name|overcommit
operator|&
name|SWAP_RESERVE_ALLOW_NONWIRED
condition|)
block|{
name|s
operator|=
name|vm_cnt
operator|.
name|v_page_count
operator|-
name|vm_cnt
operator|.
name|v_free_reserved
operator|-
name|vm_cnt
operator|.
name|v_wire_count
expr_stmt|;
name|s
operator|*=
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
name|s
operator|=
literal|0
expr_stmt|;
name|s
operator|+=
name|swap_total
expr_stmt|;
if|if
condition|(
operator|(
name|overcommit
operator|&
name|SWAP_RESERVE_FORCE_ON
operator|)
operator|==
literal|0
operator|||
name|r
operator|<=
name|s
operator|||
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_VM_SWAP_NOQUOTA
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
name|swap_reserved
operator|=
name|r
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|UIDINFO_VMSIZE_LOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|overcommit
operator|&
name|SWAP_RESERVE_RLIMIT_ON
operator|)
operator|!=
literal|0
operator|&&
name|uip
operator|->
name|ui_vmsize
operator|+
name|incr
operator|>
name|lim_cur
argument_list|(
name|curthread
argument_list|,
name|RLIMIT_SWAP
argument_list|)
operator|&&
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_VM_SWAP_NORLIMIT
argument_list|)
condition|)
name|res
operator|=
literal|0
expr_stmt|;
else|else
name|uip
operator|->
name|ui_vmsize
operator|+=
name|incr
expr_stmt|;
name|UIDINFO_VMSIZE_UNLOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swap_reserved
operator|-=
name|incr
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|res
operator|&&
name|ppsratecheck
argument_list|(
operator|&
name|lastfail
argument_list|,
operator|&
name|curfail
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"uid %d, pid %d: swap reservation for %jd bytes failed\n"
argument_list|,
name|uip
operator|->
name|ui_uid
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|racct_sub
argument_list|(
name|curproc
argument_list|,
name|RACCT_SWAP
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swap_reserve_force
parameter_list|(
name|vm_ooffset_t
name|incr
parameter_list|)
block|{
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swap_reserved
operator|+=
name|incr
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RACCT
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|racct_add_force
argument_list|(
name|curproc
argument_list|,
name|RACCT_SWAP
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uip
operator|=
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_ruidinfo
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|UIDINFO_VMSIZE_LOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|uip
operator|->
name|ui_vmsize
operator|+=
name|incr
expr_stmt|;
name|UIDINFO_VMSIZE_UNLOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_release
parameter_list|(
name|vm_ooffset_t
name|decr
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
name|swap_release_by_cred
argument_list|(
name|decr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_release_by_cred
parameter_list|(
name|vm_ooffset_t
name|decr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|uip
operator|=
name|cred
operator|->
name|cr_ruidinfo
expr_stmt|;
if|if
condition|(
name|decr
operator|&
name|PAGE_MASK
condition|)
name|panic
argument_list|(
literal|"swap_release:& PAGE_MASK"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_reserved
operator|<
name|decr
condition|)
name|panic
argument_list|(
literal|"swap_reserved< decr"
argument_list|)
expr_stmt|;
name|swap_reserved
operator|-=
name|decr
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|UIDINFO_VMSIZE_LOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
if|if
condition|(
name|uip
operator|->
name|ui_vmsize
operator|<
name|decr
condition|)
name|printf
argument_list|(
literal|"negative vmsize for uid = %d\n"
argument_list|,
name|uip
operator|->
name|ui_uid
argument_list|)
expr_stmt|;
name|uip
operator|->
name|ui_vmsize
operator|-=
name|decr
expr_stmt|;
name|UIDINFO_VMSIZE_UNLOCK
argument_list|(
name|uip
argument_list|)
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|cred
argument_list|,
name|RACCT_SWAP
argument_list|,
name|decr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SWM_FREE
value|0x02
end_define

begin_comment
comment|/* free, period			*/
end_comment

begin_define
define|#
directive|define
name|SWM_POP
value|0x04
end_define

begin_comment
comment|/* pop out			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|swap_pager_full
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (task killing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swap_pager_almost_full
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap space exhaustion (w/hysteresis)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_rcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free read buffers			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / synchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit write buffers / asynchronous	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_wcount_async_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assigned maximum			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsw_cluster_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum VOP I/O allowed		*/
end_comment

begin_function_decl
specifier|static
name|int
name|sysctl_swap_async_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_async_max
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_swap_async_max
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum running async swap ops"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_swap_fragmentation
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_fragmentation
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_swap_fragmentation
argument_list|,
literal|"A"
argument_list|,
literal|"Swap Fragmentation Info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|sw_alloc_sx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "named" and "unnamed" anon region objects.  Try to reduce the overhead  * of searching a named list by hashing it just a little.  */
end_comment

begin_define
define|#
directive|define
name|NOBJLISTS
value|8
end_define

begin_define
define|#
directive|define
name|NOBJLIST
parameter_list|(
name|handle
parameter_list|)
define|\
value|(&swap_pager_object_list[((int)(intptr_t)handle>> 4)& (NOBJLISTS-1)])
end_define

begin_decl_stmt
specifier|static
name|struct
name|pagerlst
name|swap_pager_object_list
index|[
name|NOBJLISTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|swblk_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|swpctrie_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pagerops for OBJT_SWAP - "swap pager".  Some ops are also global procedure  * calls hooked from other parts of the VM system and do not appear here.  * (see vm/swap_pager.h).  */
end_comment

begin_function_decl
specifier|static
name|vm_object_t
name|swap_pager_alloc
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swap_pager_getpages
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swap_pager_getpages_async
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|pgo_getpages_iodone_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_putpages
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_page_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|boolean_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
modifier|*
name|before
parameter_list|,
name|int
modifier|*
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_unswapped
parameter_list|(
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_pager_swapoff
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pagerops
name|swappagerops
init|=
block|{
operator|.
name|pgo_init
operator|=
name|swap_pager_init
block|,
comment|/* early system initialization of pager	*/
operator|.
name|pgo_alloc
operator|=
name|swap_pager_alloc
block|,
comment|/* allocate an OBJT_SWAP object		*/
operator|.
name|pgo_dealloc
operator|=
name|swap_pager_dealloc
block|,
comment|/* deallocate an OBJT_SWAP object	*/
operator|.
name|pgo_getpages
operator|=
name|swap_pager_getpages
block|,
comment|/* pagein				*/
operator|.
name|pgo_getpages_async
operator|=
name|swap_pager_getpages_async
block|,
comment|/* pagein (async)		*/
operator|.
name|pgo_putpages
operator|=
name|swap_pager_putpages
block|,
comment|/* pageout				*/
operator|.
name|pgo_haspage
operator|=
name|swap_pager_haspage
block|,
comment|/* get backing store status for page	*/
operator|.
name|pgo_pageunswapped
operator|=
name|swap_pager_unswapped
block|,
comment|/* remove swap related to page		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * swap_*() routines are externally accessible.  swp_*() routines are  * internal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswap_lowat
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswap_hiwat
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in pages, swap_pager_almost_full warn */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|dmmax
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nsw_cluster_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum size of a swap block in pages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|swp_sizecheck
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_async_iodone
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swapongeom
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swaponvp
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swapoff_one
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Swap bitmap functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|swp_pager_freeswapspace
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|int
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|swp_pager_getswapspace
parameter_list|(
name|int
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Metadata functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_build
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_free
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|vm_pindex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swp_pager_meta_free_all
parameter_list|(
name|vm_object_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
parameter_list|(
name|vm_object_t
parameter_list|,
name|vm_pindex_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|swblk_trie_alloc
parameter_list|(
name|struct
name|pctrie
modifier|*
name|ptree
parameter_list|)
block|{
return|return
operator|(
name|uma_zalloc
argument_list|(
name|swpctrie_zone
argument_list|,
name|M_NOWAIT
operator||
operator|(
name|curproc
operator|==
name|pageproc
condition|?
name|M_USE_RESERVE
else|:
literal|0
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swblk_trie_free
parameter_list|(
name|struct
name|pctrie
modifier|*
name|ptree
parameter_list|,
name|void
modifier|*
name|node
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|swpctrie_zone
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|PCTRIE_DEFINE
argument_list|(
name|SWAP
argument_list|,
name|swblk
argument_list|,
name|p
argument_list|,
name|swblk_trie_alloc
argument_list|,
name|swblk_trie_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SWP_SIZECHECK() -	update swap_pager_full indication  *  *	update the swap_pager_almost_full indication and warn when we are  *	about to run out of swap space, using lowat/hiwat hysteresis.  *  *	Clear swap_pager_full ( task killing ) indication when lowat is met.  *  *	No restrictions on call  *	This routine may not block.  */
end_comment

begin_function
specifier|static
name|void
name|swp_sizecheck
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|swap_pager_avail
operator|<
name|nswap_lowat
condition|)
block|{
if|if
condition|(
name|swap_pager_almost_full
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: out of swap space\n"
argument_list|)
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|swap_pager_full
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swap_pager_avail
operator|>
name|nswap_hiwat
condition|)
name|swap_pager_almost_full
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_INIT() -	initialize the swap pager!  *  *	Expected to be started from system init.  NOTE:  This code is run  *	before much else so be careful what you depend on.  Most of the VM  *	system has yet to be initialized at this point.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize object lists 	 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOBJLISTS
condition|;
operator|++
name|i
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_object_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|,
literal|"swapdev"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|,
literal|"swspsx"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|,
literal|"swsysc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_SWAP_INIT() - swap pager initialization from pageout process  *  *	Expected to be started from pageout process once, prior to entering  *	its main loop.  */
end_comment

begin_function
name|void
name|swap_pager_swap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|n
decl_stmt|,
name|n2
decl_stmt|;
comment|/* 	 * Number of in-transit swap bp operations.  Don't 	 * exhaust the pbufs completely.  Make sure we 	 * initialize workable values (0 will work for hysteresis 	 * but it isn't very efficient). 	 * 	 * The nsw_cluster_max is constrained by the bp->b_pages[] 	 * array (MAXPHYS/PAGE_SIZE) and our locally defined 	 * MAX_PAGEOUT_CLUSTER.   Also be aware that swap ops are 	 * constrained by the swap device interleave stripe size. 	 * 	 * Currently we hardwire nsw_wcount_async to 4.  This limit is 	 * designed to prevent other I/O from having high latencies due to 	 * our pageout I/O.  The value 4 works well for one or two active swap 	 * devices but is probably a little low if you have more.  Even so, 	 * a higher value would probably generate only a limited improvement 	 * with three or four active swap devices since the system does not 	 * typically have to pageout at extreme bandwidths.   We will want 	 * at least 2 per swap devices, and 4 is a pretty good value if you 	 * have one NFS swap device due to the command/ack latency over NFS. 	 * So it all works out pretty well. 	 */
name|nsw_cluster_max
operator|=
name|min
argument_list|(
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
argument_list|,
name|MAX_PAGEOUT_CLUSTER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
name|nsw_rcount
operator|=
operator|(
name|nswbuf
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|nsw_wcount_sync
operator|=
operator|(
name|nswbuf
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|nsw_wcount_async
operator|=
literal|4
expr_stmt|;
name|nsw_wcount_async_max
operator|=
name|nsw_wcount_async
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize our zone, guessing on the number we need based 	 * on the number of pages in the system. 	 */
name|n
operator|=
name|vm_cnt
operator|.
name|v_page_count
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|maxswzone
operator|&&
name|n
operator|>
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblk
argument_list|)
condition|)
name|n
operator|=
name|maxswzone
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|swblk
argument_list|)
expr_stmt|;
name|swpctrie_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"swpctrie"
argument_list|,
name|pctrie_node_size
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pctrie_zone_init
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
operator||
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swpctrie_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"failed to create swap pctrie zone."
argument_list|)
expr_stmt|;
name|swblk_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"swblk"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|swblk
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
alignof|_Alignof
argument_list|(
expr|struct
name|swblk
argument_list|)
operator|-
literal|1
argument_list|,
name|UMA_ZONE_NOFREE
operator||
name|UMA_ZONE_VM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swblk_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"failed to create swap blk zone."
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uma_zone_reserve_kva
argument_list|(
name|swblk_zone
argument_list|,
name|n
argument_list|)
condition|)
break|break;
comment|/* 		 * if the allocation failed, try a zone two thirds the 		 * size of the previous attempt. 		 */
name|n
operator|-=
operator|(
operator|(
name|n
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
comment|/* 	 * Often uma_zone_reserve_kva() cannot reserve exactly the 	 * requested size.  Account for the difference when 	 * calculating swap_maxpages. 	 */
name|n
operator|=
name|uma_zone_get_max
argument_list|(
name|swblk_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|n2
condition|)
name|printf
argument_list|(
literal|"Swap blk zone entries reduced from %lu to %lu.\n"
argument_list|,
name|n2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|swap_maxpages
operator|=
name|n
operator|*
name|SWAP_META_PAGES
expr_stmt|;
name|swzone
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|swblk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uma_zone_reserve_kva
argument_list|(
name|swpctrie_zone
argument_list|,
name|n
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Cannot reserve swap pctrie zone, "
literal|"reduce kern.maxswzone.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_object_t
name|swap_pager_alloc_init
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|swap_reserve_by_cred
argument_list|(
name|size
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The un_pager.swp.swp_blks trie is initialized by 	 * vm_object_allocate() to ensure the correct order of 	 * visibility to other threads. 	 */
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_SWAP
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|PAGE_MASK
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
name|object
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
name|object
operator|->
name|charge
operator|=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_ALLOC() -	allocate a new OBJT_SWAP VM object and instantiate  *			its metadata structures.  *  *	This routine is called from the mmap and fork code to create a new  *	OBJT_SWAP object.  *  *	This routine must ensure that no live duplicate is created for  *	the named object request, which is protected against by  *	holding the sw_alloc_sx lock in case handle != NULL.  */
end_comment

begin_function
specifier|static
name|vm_object_t
name|swap_pager_alloc
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Reference existing named region or allocate new one.  There 		 * should not be a race here against swp_pager_meta_build() 		 * as called from vm_page_remove() in regards to the lookup 		 * of the handle. 		 */
name|sx_xlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|object
operator|=
name|vm_pager_object_lookup
argument_list|(
name|NOBJLIST
argument_list|(
name|handle
argument_list|)
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
name|object
operator|=
name|swap_pager_alloc_init
argument_list|(
name|handle
argument_list|,
name|cred
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|swap_pager_alloc_init
argument_list|(
name|handle
argument_list|,
name|cred
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_DEALLOC() -	remove swap metadata from object  *  *	The swap backing for the object is destroyed.  The code is  *	designed such that we can reinstantiate it later, but this  *	routine is typically called only when the entire object is  *	about to be destroyed.  *  *	The object must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"dealloc of reachable obj"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from list right away so lookups will fail if we block for 	 * pageout completion. 	 */
if|if
condition|(
name|object
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|object
operator|->
name|handle
argument_list|)
argument_list|,
name|object
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wait
argument_list|(
name|object
argument_list|,
literal|"swpdea"
argument_list|)
expr_stmt|;
comment|/* 	 * Free all remaining metadata.  We only bother to free it from 	 * the swap meta data.  We do not attempt to free swapblk's still 	 * associated with vm_page_t's for this object.  We do not care 	 * if paging is still in progress on some objects. 	 */
name|swp_pager_meta_free_all
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
name|object
operator|->
name|type
operator|=
name|OBJT_DEAD
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *			SWAP PAGER BITMAP ROUTINES			*  ************************************************************************/
end_comment

begin_comment
comment|/*  * SWP_PAGER_GETSWAPSPACE() -	allocate raw swap space  *  *	Allocate swap for the requested number of pages.  The starting  *	swap block number (a page index) is returned or SWAPBLK_NONE  *	if the allocation failed.  *  *	Also has the side effect of advising that somebody made a mistake  *	when they configured swap and didn't configure enough.  *  *	This routine may not sleep.  *  *	We allocate in round-robin fashion from the configured devices.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|swp_pager_getswapspace
parameter_list|(
name|int
name|npages
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blk
operator|=
name|SWAPBLK_NONE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|=
name|swdevhd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nswapdev
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|swtailq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|sw_flags
operator|&
name|SW_CLOSING
operator|)
condition|)
block|{
name|blk
operator|=
name|blist_alloc
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
name|blk
operator|+=
name|sp
operator|->
name|sw_first
expr_stmt|;
name|sp
operator|->
name|sw_used
operator|+=
name|npages
expr_stmt|;
name|swap_pager_avail
operator|-=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
name|swdevhd
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|sp
operator|=
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_pager_full
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager_getswapspace(%d): failed\n"
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|swap_pager_full
operator|=
literal|2
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
name|swdevhd
operator|=
name|NULL
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swp_pager_isondev
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
return|return
operator|(
name|blk
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|blk
operator|<
name|sp
operator|->
name|sw_end
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swp_pager_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|bp
operator|->
name|b_blkno
operator|<
name|sp
operator|->
name|sw_end
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|sw_flags
operator|&
name|SW_UNMAPPED
operator|)
operator|!=
literal|0
operator|&&
name|unmapped_buf_allowed
condition|)
block|{
name|bp
operator|->
name|b_data
operator|=
name|unmapped_buf
expr_stmt|;
name|bp
operator|->
name|b_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
argument_list|,
name|bp
operator|->
name|b_bcount
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|sw_strategy
argument_list|(
name|bp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"Swapdev not found"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_FREESWAPSPACE() -	free raw swap space  *  *	This routine returns the specified swap blocks back to the bitmap.  *  *	This routine may not sleep.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_freeswapspace
parameter_list|(
name|daddr_t
name|blk
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|blk
operator|>=
name|sp
operator|->
name|sw_first
operator|&&
name|blk
operator|<
name|sp
operator|->
name|sw_end
condition|)
block|{
name|sp
operator|->
name|sw_used
operator|-=
name|npages
expr_stmt|;
comment|/* 			 * If we are attempting to stop swapping on 			 * this device, we don't want to mark any 			 * blocks free lest they be reused. 			 */
if|if
condition|(
operator|(
name|sp
operator|->
name|sw_flags
operator|&
name|SW_CLOSING
operator|)
operator|==
literal|0
condition|)
block|{
name|blist_free
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
name|blk
operator|-
name|sp
operator|->
name|sw_first
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|swap_pager_avail
operator|+=
name|npages
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"Swapdev not found"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SYSCTL_SWAP_FRAGMENTATION() -	produce raw swap space stats  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_swap_fragmentation
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|devname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|vn_isdisk
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|devname
operator|=
name|devtoname
argument_list|(
name|sp
operator|->
name|sw_vp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
else|else
name|devname
operator|=
literal|"[file]"
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"\nFree space on device %s:\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|blist_stats
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_FREESPACE() -	frees swap blocks associated with a page  *				range within an object.  *  *	This is a globally accessible routine.  *  *	This routine removes swapblk assignments from swap metadata.  *  *	The external callers of this routine typically have already destroyed  *	or renamed vm_page_t's associated with this range in the object so  *	we should be ok.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|swap_pager_freespace
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_RESERVE() - reserve swap blocks in object  *  *	Assigns swap blocks to the specified range within the object.  The  *	swap blocks are not zeroed.  Any previous swap assignment is destroyed.  *  *	Returns 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|swap_pager_reserve
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|start
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|daddr_t
name|blk
init|=
name|SWAPBLK_NONE
decl_stmt|;
name|vm_pindex_t
name|beg
init|=
name|start
decl_stmt|;
comment|/* save start index */
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|BLIST_MAX_ALLOC
expr_stmt|;
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|beg
argument_list|,
name|start
operator|-
name|beg
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|blk
argument_list|)
expr_stmt|;
operator|--
name|size
expr_stmt|;
operator|++
name|start
expr_stmt|;
operator|++
name|blk
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
name|swp_pager_meta_free
argument_list|(
name|object
argument_list|,
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_COPY() -  copy blocks from source pager to destination pager  *			and destroy the source.  *  *	Copy any valid swapblks from the source to the destination.  In  *	cases where both the source and destination have a valid swapblk,  *	we keep the destination's.  *  *	This routine is allowed to sleep.  It may sleep allocating metadata  *	indirectly through swp_pager_meta_build() or if paging is still in  *	progress on the source.  *  *	The source object contains no vm_page_t's (which is just as well)  *  *	The source object is of type OBJT_SWAP.  *  *	The source and destination objects must be locked.  *	Both object locks may temporarily be released.  */
end_comment

begin_function
name|void
name|swap_pager_copy
parameter_list|(
name|vm_object_t
name|srcobject
parameter_list|,
name|vm_object_t
name|dstobject
parameter_list|,
name|vm_pindex_t
name|offset
parameter_list|,
name|int
name|destroysource
parameter_list|)
block|{
name|vm_pindex_t
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
comment|/* 	 * If destroysource is set, we remove the source object from the 	 * swap_pager internal queue now. 	 */
if|if
condition|(
name|destroysource
operator|&&
name|srcobject
operator|->
name|handle
operator|!=
name|NULL
condition|)
block|{
name|vm_object_pip_add
argument_list|(
name|srcobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|dstobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|NOBJLIST
argument_list|(
name|srcobject
operator|->
name|handle
argument_list|)
argument_list|,
name|srcobject
argument_list|,
name|pager_object_list
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sw_alloc_sx
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * transfer source to destination. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dstobject
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|daddr_t
name|dstaddr
decl_stmt|;
comment|/* 		 * Locate (without changing) the swapblk on the destination, 		 * unless it is invalid in which case free it silently, or 		 * if the destination is a resident page, in which case the 		 * source is thrown away. 		 */
name|dstaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstaddr
operator|==
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 			 * Destination has no swapblk and is not resident, 			 * copy source. 			 */
name|daddr_t
name|srcaddr
decl_stmt|;
name|srcaddr
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcaddr
operator|!=
name|SWAPBLK_NONE
condition|)
block|{
comment|/* 				 * swp_pager_meta_build() can sleep. 				 */
name|vm_object_pip_add
argument_list|(
name|srcobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|dstobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|swp_pager_meta_build
argument_list|(
name|dstobject
argument_list|,
name|i
argument_list|,
name|srcaddr
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|dstobject
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
name|vm_object_pip_wakeup
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Destination has valid swapblk or it is represented 			 * by a resident page.  We destroy the sourceblock. 			 */
name|swp_pager_meta_ctl
argument_list|(
name|srcobject
argument_list|,
name|i
operator|+
name|offset
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free left over swap blocks in source. 	 * 	 * We have to revert the type to OBJT_DEFAULT so we do not accidentally 	 * double-remove the object from the swap queues. 	 */
if|if
condition|(
name|destroysource
condition|)
block|{
name|swp_pager_meta_free_all
argument_list|(
name|srcobject
argument_list|)
expr_stmt|;
comment|/* 		 * Reverting the type is not necessary, the caller is going 		 * to destroy srcobject directly, but I'm doing it here 		 * for consistency since we've removed the object from its 		 * queues. 		 */
name|srcobject
operator|->
name|type
operator|=
name|OBJT_DEFAULT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_HASPAGE() -	determine if we have good backing store for  *				the requested page.  *  *	We determine whether good backing store exists for the requested  *	page and return TRUE if it does, FALSE if it doesn't.  *  *	If TRUE, we also try to determine how much valid, contiguous backing  *	store exists before and after the requested page.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
modifier|*
name|before
parameter_list|,
name|int
modifier|*
name|after
parameter_list|)
block|{
name|daddr_t
name|blk
decl_stmt|,
name|blk0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * do we have good backing store at the requested index ? 	 */
name|blk0
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk0
operator|==
name|SWAPBLK_NONE
condition|)
block|{
if|if
condition|(
name|before
condition|)
operator|*
name|before
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after
condition|)
operator|*
name|after
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * find backwards-looking contiguous good backing store 	 */
if|if
condition|(
name|before
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SWB_NPAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|pindex
condition|)
break|break;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|-
name|i
condition|)
break|break;
block|}
operator|*
name|before
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * find forward-looking contiguous good backing store 	 */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SWB_NPAGES
condition|;
name|i
operator|++
control|)
block|{
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
name|blk0
operator|+
name|i
condition|)
break|break;
block|}
operator|*
name|after
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWAP_PAGER_PAGE_UNSWAPPED() - remove swap backing store related to page  *  *	This removes any associated swap backing store, whether valid or  *	not, from the page.  *  *	This routine is typically called when a page is made dirty, at  *	which point any associated swap can be freed.  MADV_FREE also  *	calls us in a special-case situation  *  *	NOTE!!!  If the page is clean and the swap was valid, the caller  *	should make the page dirty before calling this routine.  This routine  *	does NOT change the m->dirty status of the page.  Also: MADV_FREE  *	depends on it.  *  *	This routine may not sleep.  *  *	The object containing the page must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_unswapped
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|swp_pager_meta_ctl
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|SWM_FREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * swap_pager_getpages() - bring pages in from swap  *  *	Attempt to page in the pages in array "m" of length "count".  The caller  *	may optionally specify that additional pages preceding and succeeding  *	the specified range be paged in.  The number of such pages is returned  *	in the "rbehind" and "rahead" parameters, and they will be in the  *	inactive queue upon return.  *  *	The pages in "m" must be busied and will remain busied upon return.  */
end_comment

begin_function
specifier|static
name|int
name|swap_pager_getpages
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|rbehind
parameter_list|,
name|int
modifier|*
name|rahead
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|vm_page_t
name|mpred
decl_stmt|,
name|msucc
decl_stmt|,
name|p
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|maxahead
decl_stmt|,
name|maxbehind
decl_stmt|,
name|reqcount
decl_stmt|,
name|shift
decl_stmt|;
name|reqcount
operator|=
name|count
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_rcount
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|swap_pager_haspage
argument_list|(
name|object
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|pindex
argument_list|,
operator|&
name|maxbehind
argument_list|,
operator|&
name|maxahead
argument_list|)
condition|)
block|{
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|&
name|nsw_rcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
comment|/* 	 * Clip the readahead and readbehind ranges to exclude resident pages. 	 */
if|if
condition|(
name|rahead
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|reqcount
operator|-
literal|1
operator|<=
name|maxahead
argument_list|,
operator|(
literal|"page count %d extends beyond swap block"
operator|,
name|reqcount
operator|)
argument_list|)
expr_stmt|;
operator|*
name|rahead
operator|=
name|imin
argument_list|(
operator|*
name|rahead
argument_list|,
name|maxahead
operator|-
operator|(
name|reqcount
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pindex
operator|=
name|m
index|[
name|reqcount
operator|-
literal|1
index|]
operator|->
name|pindex
expr_stmt|;
name|msucc
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
index|[
name|reqcount
operator|-
literal|1
index|]
argument_list|,
name|listq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msucc
operator|!=
name|NULL
operator|&&
name|msucc
operator|->
name|pindex
operator|-
name|pindex
operator|-
literal|1
operator|<
operator|*
name|rahead
condition|)
operator|*
name|rahead
operator|=
name|msucc
operator|->
name|pindex
operator|-
name|pindex
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rbehind
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rbehind
operator|=
name|imin
argument_list|(
operator|*
name|rbehind
argument_list|,
name|maxbehind
argument_list|)
expr_stmt|;
name|pindex
operator|=
name|m
index|[
literal|0
index|]
operator|->
name|pindex
expr_stmt|;
name|mpred
operator|=
name|TAILQ_PREV
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|,
name|pglist
argument_list|,
name|listq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpred
operator|!=
name|NULL
operator|&&
name|pindex
operator|-
name|mpred
operator|->
name|pindex
operator|-
literal|1
operator|<
operator|*
name|rbehind
condition|)
operator|*
name|rbehind
operator|=
name|pindex
operator|-
name|mpred
operator|->
name|pindex
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Allocate readahead and readbehind pages. 	 */
name|shift
operator|=
name|rbehind
operator|!=
name|NULL
condition|?
operator|*
name|rbehind
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|shift
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|pindex
operator|-
name|i
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Shift allocated pages to the left. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
operator|=
name|bp
operator|->
name|b_pages
index|[
name|j
operator|+
name|shift
operator|-
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|b_pages
index|[
name|shift
operator|-
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
name|shift
operator|=
name|i
operator|-
literal|1
expr_stmt|;
operator|*
name|rbehind
operator|=
name|shift
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reqcount
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|b_pages
index|[
name|i
operator|+
name|shift
index|]
operator|=
name|m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rahead
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|rahead
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|m
index|[
name|reqcount
operator|-
literal|1
index|]
operator|->
name|pindex
operator|+
name|i
operator|+
literal|1
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|bp
operator|->
name|b_pages
index|[
name|shift
operator|+
name|reqcount
operator|+
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|rahead
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|rbehind
operator|!=
name|NULL
condition|)
name|count
operator|+=
operator|*
name|rbehind
expr_stmt|;
if|if
condition|(
name|rahead
operator|!=
name|NULL
condition|)
name|count
operator|+=
operator|*
name|rahead
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|oflags
operator||=
name|VPO_SWAPINPROG
expr_stmt|;
name|pindex
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|pindex
expr_stmt|;
name|blk
operator|=
name|swp_pager_meta_ctl
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|blk
operator|!=
name|SWAPBLK_NONE
argument_list|,
operator|(
literal|"no swap blocking containing %p(%jx)"
operator|,
name|object
operator|,
operator|(
name|uintmax_t
operator|)
name|pindex
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_PAGING
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|count
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_pgbefore
operator|=
name|rbehind
operator|!=
name|NULL
condition|?
operator|*
name|rbehind
else|:
literal|0
expr_stmt|;
name|bp
operator|->
name|b_pgafter
operator|=
name|rahead
operator|!=
name|NULL
condition|?
operator|*
name|rahead
else|:
literal|0
expr_stmt|;
name|VM_CNT_INC
argument_list|(
name|v_swapin
argument_list|)
expr_stmt|;
name|VM_CNT_ADD
argument_list|(
name|v_swappgsin
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * perform the I/O.  NOTE!!!  bp cannot be considered valid after 	 * this point because we automatically release it on completion. 	 * Instead, we look at the one page we are interested in which we 	 * still hold a lock on even through the I/O completion. 	 * 	 * The other pages in our m[] array are also released on completion, 	 * so we cannot assume they are valid anymore either. 	 * 	 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 	 */
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the pages we want to complete.  VPO_SWAPINPROG is always 	 * cleared on completion.  If an I/O error occurs, SWAPBLK_NONE 	 * is set in the metadata for each page in the request. 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
index|[
literal|0
index|]
operator|->
name|oflags
operator|&
name|VPO_SWAPINPROG
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
index|[
literal|0
index|]
operator|->
name|oflags
operator||=
name|VPO_SWAPSLEEP
expr_stmt|;
name|VM_CNT_INC
argument_list|(
name|v_intrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|VM_OBJECT_SLEEP
argument_list|(
name|object
argument_list|,
operator|&
name|object
operator|->
name|paging_in_progress
argument_list|,
name|PSWP
argument_list|,
literal|"swread"
argument_list|,
name|hz
operator|*
literal|20
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: indefinite wait buffer: bufobj: %p, blkno: %jd, size: %ld\n"
argument_list|,
name|bp
operator|->
name|b_bufobj
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we had an unrecoverable read error pages will not be valid. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reqcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
index|[
name|i
index|]
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
comment|/* 	 * A final note: in a low swap situation, we cannot deallocate swap 	 * and mark a page dirty here because the caller is likely to mark 	 * the page clean when we return, causing the page to possibly revert 	 * to all-zero's later. 	 */
block|}
end_function

begin_comment
comment|/*  * 	swap_pager_getpages_async():  *  *	Right now this is emulation of asynchronous operation on top of  *	swap_pager_getpages().  */
end_comment

begin_function
specifier|static
name|int
name|swap_pager_getpages_async
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|rbehind
parameter_list|,
name|int
modifier|*
name|rahead
parameter_list|,
name|pgo_getpages_iodone_t
name|iodone
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|error
decl_stmt|;
name|r
operator|=
name|swap_pager_getpages
argument_list|(
name|object
argument_list|,
name|m
argument_list|,
name|count
argument_list|,
name|rbehind
argument_list|,
name|rahead
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|VM_PAGER_OK
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_PAGER_ERROR
case|:
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|VM_PAGER_FAIL
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unhandled swap_pager_getpages() error %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
call|(
name|iodone
call|)
argument_list|(
name|arg
argument_list|,
name|m
argument_list|,
name|count
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	swap_pager_putpages:  *  *	Assign swap (if necessary) and initiate I/O on the specified pages.  *  *	We support both OBJT_DEFAULT and OBJT_SWAP objects.  DEFAULT objects  *	are automatically converted to SWAP objects.  *  *	In a low memory situation we may block in VOP_STRATEGY(), but the new  *	vm_page reservation system coupled with properly written VFS devices  *	should ensure that no low-memory deadlock occurs.  This is an area  *	which needs work.  *  *	The parent has N vm_object_pip_add() references prior to  *	calling us and will remove references for rtvals[] that are  *	not set to VM_PAGER_PEND.  We need to remove the rest on I/O  *	completion.  *  *	The parent has soft-busy'd the pages it passes us and will unbusy  *	those whos rtvals[] entry is not set to VM_PAGER_PEND on return.  *	We need to unbusy the rest on I/O completion.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_putpages
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rtvals
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
if|if
condition|(
name|count
operator|&&
name|m
index|[
literal|0
index|]
operator|->
name|object
operator|!=
name|object
condition|)
block|{
name|panic
argument_list|(
literal|"swap_pager_putpages: object mismatch %p/%p"
argument_list|,
name|object
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Step 1 	 * 	 * Turn object into OBJT_SWAP 	 * check for bogus sysops 	 * force sync if not pageout process 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
name|swp_pager_meta_build
argument_list|(
name|object
argument_list|,
literal|0
argument_list|,
name|SWAPBLK_NONE
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|pageproc
condition|)
name|sync
operator|=
name|TRUE
expr_stmt|;
else|else
name|sync
operator|=
operator|(
name|flags
operator|&
name|VM_PAGER_PUT_SYNC
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Step 2 	 * 	 * Assign swap blocks and issue I/O.  We reallocate swap on the fly. 	 * The page is left dirty until the pageout operation completes 	 * successfully. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
name|n
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
comment|/* 		 * Maximum I/O size is limited by a number of factors. 		 */
name|n
operator|=
name|min
argument_list|(
name|BLIST_MAX_ALLOC
argument_list|,
name|count
operator|-
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|nsw_cluster_max
argument_list|)
expr_stmt|;
comment|/* 		 * Get biggest block of swap we can.  If we fail, fall 		 * back and try to allocate a smaller block.  Don't go 		 * overboard trying to allocate space if it would overly 		 * fragment swap. 		 */
while|while
condition|(
operator|(
name|blk
operator|=
name|swp_pager_getswapspace
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|SWAPBLK_NONE
operator|&&
name|n
operator|>
literal|4
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_FAIL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * All I/O parameters have been satisfied, build the I/O 		 * request and assign the swap space. 		 */
if|if
condition|(
name|sync
operator|==
name|TRUE
condition|)
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_sync
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_ASYNC
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_PAGING
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|crhold
argument_list|(
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|PAGE_SIZE
operator|*
name|n
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blk
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|vm_page_t
name|mreq
init|=
name|m
index|[
name|i
operator|+
name|j
index|]
decl_stmt|;
name|swp_pager_meta_build
argument_list|(
name|mreq
operator|->
name|object
argument_list|,
name|mreq
operator|->
name|pindex
argument_list|,
name|blk
operator|+
name|j
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|mreq
operator|->
name|dirty
operator|==
name|VM_PAGE_BITS_ALL
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|oflags
operator||=
name|VPO_SWAPINPROG
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
operator|=
name|mreq
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|n
expr_stmt|;
comment|/* 		 * Must set dirty range for NFS to work. 		 */
name|bp
operator|->
name|b_dirtyoff
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|VM_CNT_INC
argument_list|(
name|v_swapout
argument_list|)
expr_stmt|;
name|VM_CNT_ADD
argument_list|(
name|v_swappgsout
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
comment|/* 		 * We unconditionally set rtvals[] to VM_PAGER_PEND so that we 		 * can call the async completion routine at the end of a 		 * synchronous I/O operation.  Otherwise, our caller would 		 * perform duplicate unbusy and wakeup operations on the page 		 * and object, respectively. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
name|rtvals
index|[
name|i
operator|+
name|j
index|]
operator|=
name|VM_PAGER_PEND
expr_stmt|;
comment|/* 		 * asynchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 		 */
if|if
condition|(
name|sync
operator|==
name|FALSE
condition|)
block|{
name|bp
operator|->
name|b_iodone
operator|=
name|swp_pager_async_iodone
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * synchronous 		 * 		 * NOTE: b_blkno is destroyed by the call to swapdev_strategy 		 */
name|bp
operator|->
name|b_iodone
operator|=
name|bdone
expr_stmt|;
name|swp_pager_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the sync I/O to complete. 		 */
name|bwait
argument_list|(
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swwrt"
argument_list|)
expr_stmt|;
comment|/* 		 * Now that we are through with the bp, we can call the 		 * normal async completion, which frees everything up. 		 */
name|swp_pager_async_iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swp_pager_async_iodone:  *  *	Completion routine for asynchronous reads and writes from/to swap.  *	Also called manually by synchronous code to finish up a bp.  *  *	This routine may not sleep.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_async_iodone
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
init|=
name|NULL
decl_stmt|;
comment|/* 	 * report error 	 */
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: I/O error - %s failed; blkno %ld,"
literal|"size %ld, error %d\n"
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|)
condition|?
literal|"pagein"
else|:
literal|"pageout"
operator|)
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * remove the mapping for kernel virtual 	 */
if|if
condition|(
name|buf_mapped
argument_list|(
name|bp
argument_list|)
condition|)
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
else|else
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * cleanup pages.  If an error occurs writing to swap, we are in 	 * very serious trouble.  If it happens to be a disk error, though, 	 * we may be able to recover by reassigning the swap later on.  So 	 * in this case we remove the m->swapblk assignment for the page 	 * but do not free it in the rlist.  The errornous block(s) are thus 	 * never reallocated as swap.  Redirty the page and continue. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
operator|++
name|i
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|m
operator|->
name|oflags
operator|&=
operator|~
name|VPO_SWAPINPROG
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|oflags
operator|&
name|VPO_SWAPSLEEP
condition|)
block|{
name|m
operator|->
name|oflags
operator|&=
operator|~
name|VPO_SWAPSLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|object
operator|->
name|paging_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_ioflags
operator|&
name|BIO_ERROR
condition|)
block|{
comment|/* 			 * If an error occurs I'd love to throw the swapblk 			 * away without freeing it back to swapspace, so it 			 * can never be used again.  But I can't from an 			 * interrupt. 			 */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* 				 * NOTE: for reads, m->dirty will probably 				 * be overridden by the original caller of 				 * getpages so don't play cute tricks here. 				 */
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If a write error occurs, reactivate page 				 * so it doesn't clog the inactive list, 				 * then finish the I/O. 				 */
name|MPASS
argument_list|(
name|m
operator|->
name|dirty
operator|==
name|VM_PAGE_BITS_ALL
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_sunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* 			 * NOTE: for reads, m->dirty will probably be 			 * overridden by the original caller of getpages so 			 * we cannot set them in order to free the underlying 			 * swap in a low-swap situation.  I don't think we'd 			 * want to do that anyway, but it was an optimization 			 * that existed in the old swapper for a time before 			 * it got ripped out due to precisely this problem. 			 */
name|KASSERT
argument_list|(
operator|!
name|pmap_page_is_mapped
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"swp_pager_async_iodone: page %p is mapped"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|dirty
operator|==
literal|0
argument_list|,
operator|(
literal|"swp_pager_async_iodone: page %p is dirty"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|bp
operator|->
name|b_pgbefore
operator|||
name|i
operator|>=
name|bp
operator|->
name|b_npages
operator|-
name|bp
operator|->
name|b_pgafter
condition|)
name|vm_page_readahead_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * For write success, clear the dirty 			 * status, then finish the I/O ( which decrements the 			 * busy count and possibly wakes waiter's up ). 			 * A page is only written to swap after a period of 			 * inactivity.  Therefore, we do not expect it to be 			 * reused. 			 */
name|KASSERT
argument_list|(
operator|!
name|pmap_page_is_write_mapped
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"swp_pager_async_iodone: page %p is not write"
literal|" protected"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_deactivate_noreuse
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_sunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * adjust pip.  NOTE: the original parent may still have its own 	 * pip refs on the object. 	 */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|vm_object_pip_wakeupn
argument_list|(
name|object
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * swapdev_strategy() manually sets b_vp and b_bufobj before calling 	 * bstrategy(). Set them back to NULL now we're done with it, or we'll 	 * trigger a KASSERT in relpbuf(). 	 */
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
block|{
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * release the physical I/O buffer 	 */
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|)
condition|?
operator|&
name|nsw_rcount
else|:
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
condition|?
operator|&
name|nsw_wcount_async
else|:
operator|&
name|nsw_wcount_sync
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|swap_pager_nswapdev
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|nswapdev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_FORCE_PAGEIN() - force a swap block to be paged in  *  *	This routine dissociates the page at the given index within an object  *	from its backing store, paging it in if it does not reside in memory.  *	If the page is paged in, it is marked dirty and placed in the laundry  *	queue.  The page is marked dirty because it no longer has backing  *	store.  It is placed in the laundry queue because it has not been  *	accessed recently.  Otherwise, it would already reside in memory.  *  *	We also attempt to swap in all other pages in the swap block.  *	However, we only guarantee that the one at the specified index is  *	paged in.  *  *	XXX - The code to page the whole block in doesn't work, so we  *	      revert to the one-by-one behavior for now.  Sigh.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|swp_pager_force_pagein
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_pip_add
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_grab
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|vm_object_pip_wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
operator|&&
name|m
operator|->
name|queue
operator|==
name|PQ_NONE
condition|)
name|panic
argument_list|(
literal|"page %p is neither wired nor queued"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_page_xunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_pager_page_unswapped
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swap_pager_getpages
argument_list|(
name|object
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"swap_pager_force_pagein: read from swap failed"
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|vm_object_pip_wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_launder
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_xunbusy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_pager_page_unswapped
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	swap_pager_swapoff:  *  *	Page in all of the pages that have been paged out to the  *	given device.  The corresponding blocks in the bitmap must be  *	marked as allocated and the device must be flagged SW_CLOSING.  *	There may be no processes swapped out to the device.  *  *	This routine may block.  */
end_comment

begin_function
specifier|static
name|void
name|swap_pager_swapoff
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retries
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|full_rescan
label|:
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|object
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
block|{
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
continue|continue;
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
comment|/* Depends on type-stability. */
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 		 * Dead objects are eventually terminated on their own. 		 */
if|if
condition|(
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|next_obj
goto|;
comment|/* 		 * Sync with fences placed after pctrie 		 * initialization.  We must not access pctrie below 		 * unless we checked that our object is swap and not 		 * dead. 		 */
name|atomic_thread_fence_acq
argument_list|()
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
goto|goto
name|next_obj
goto|;
for|for
control|(
name|pi
operator|=
literal|0
init|;
operator|(
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|pi
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|pi
operator|=
name|sb
operator|->
name|p
operator|+
name|SWAP_META_PAGES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|==
name|SWAPBLK_NONE
condition|)
continue|continue;
if|if
condition|(
name|swp_pager_isondev
argument_list|(
name|sb
operator|->
name|d
index|[
name|i
index|]
argument_list|,
name|sp
argument_list|)
condition|)
name|swp_pager_force_pagein
argument_list|(
name|object
argument_list|,
name|sb
operator|->
name|p
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|next_obj
label|:
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sw_used
condition|)
block|{
comment|/* 		 * Objects may be locked or paging to the device being 		 * removed, so we will miss their pages and need to 		 * make another pass.  We have marked this device as 		 * SW_CLOSING, so the activity should finish soon. 		 */
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|retries
operator|>
literal|100
condition|)
block|{
name|panic
argument_list|(
literal|"swapoff: failed to locate %d swap blocks"
argument_list|,
name|sp
operator|->
name|sw_used
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"swpoff"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
goto|goto
name|full_rescan
goto|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|swapoff
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *				SWAP META DATA 				*  ************************************************************************  *  *	These routines manipulate the swap metadata stored in the  *	OBJT_SWAP object.  *  *	Swap metadata is implemented with a global hash and not directly  *	linked into the object.  Instead the object simply contains  *	appropriate tracking counters.  */
end_comment

begin_comment
comment|/*  * SWP_PAGER_META_BUILD() -	add swap block to swap meta data for object  *  *	We first convert the object to a swap object if it is a default  *	object.  *  *	The specified swapblk is added to the object's swap metadata.  If  *	the swapblk is not valid, it is freed instead.  Any previously  *	assigned swapblk is freed.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_build
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|daddr_t
name|swapblk
parameter_list|)
block|{
specifier|static
specifier|volatile
name|int
name|swblk_zone_exhausted
decl_stmt|,
name|swpctrie_zone_exhausted
decl_stmt|;
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|,
modifier|*
name|sb1
decl_stmt|;
name|vm_pindex_t
name|modpi
decl_stmt|,
name|rdpi
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * Convert default object to swap object if necessary 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
block|{
name|pctrie_init
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that swap_pager_swapoff()'s iteration over 		 * object_list does not see a garbage pctrie. 		 */
name|atomic_thread_fence_rel
argument_list|()
expr_stmt|;
name|object
operator|->
name|type
operator|=
name|OBJT_SWAP
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|handle
operator|==
name|NULL
argument_list|,
operator|(
literal|"default pager with handle"
operator|)
argument_list|)
expr_stmt|;
block|}
name|rdpi
operator|=
name|rounddown
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
expr_stmt|;
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rdpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|swapblk
operator|==
name|SWAPBLK_NONE
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sb
operator|=
name|uma_zalloc
argument_list|(
name|swblk_zone
argument_list|,
name|M_NOWAIT
operator||
operator|(
name|curproc
operator|==
name|pageproc
condition|?
name|M_USE_RESERVE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|sb
operator|->
name|p
operator|=
name|rdpi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|swblk_zone_exhausted
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"swblk zone ok\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|uma_zone_exhausted
argument_list|(
name|swblk_zone
argument_list|)
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|swblk_zone_exhausted
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"swap blk zone exhausted, "
literal|"increase kern.maxswzone\n"
argument_list|)
expr_stmt|;
name|vm_pageout_oom
argument_list|(
name|VM_OOM_SWAPZ
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"swzonxb"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|uma_zwait
argument_list|(
name|swblk_zone
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rdpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
comment|/* 				 * Somebody swapped out a nearby page, 				 * allocating swblk at the rdpi index, 				 * while we dropped the object lock. 				 */
goto|goto
name|allocated
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|SWAP_PCTRIE_INSERT
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|swpctrie_zone_exhausted
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"swpctrie zone ok\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|uma_zone_exhausted
argument_list|(
name|swpctrie_zone
argument_list|)
condition|)
block|{
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|swpctrie_zone_exhausted
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"swap pctrie zone exhausted, "
literal|"increase kern.maxswzone\n"
argument_list|)
expr_stmt|;
name|vm_pageout_oom
argument_list|(
name|VM_OOM_SWAPZ
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"swzonxp"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|uma_zwait
argument_list|(
name|swpctrie_zone
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|sb1
operator|=
name|SWAP_PCTRIE_LOOKUP
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rdpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb1
operator|!=
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|swblk_zone
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
name|sb1
expr_stmt|;
goto|goto
name|allocated
goto|;
block|}
block|}
block|}
name|allocated
label|:
name|MPASS
argument_list|(
name|sb
operator|->
name|p
operator|==
name|rdpi
argument_list|)
expr_stmt|;
name|modpi
operator|=
name|pindex
operator|%
name|SWAP_META_PAGES
expr_stmt|;
comment|/* Delete prior contents of metadata. */
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|modpi
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
name|swp_pager_freeswapspace
argument_list|(
name|sb
operator|->
name|d
index|[
name|modpi
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enter block into metadata. */
name|sb
operator|->
name|d
index|[
name|modpi
index|]
operator|=
name|swapblk
expr_stmt|;
comment|/* 	 * Free the swblk if we end up with the empty page run. 	 */
if|if
condition|(
name|swapblk
operator|==
name|SWAPBLK_NONE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|SWAP_META_PAGES
condition|)
block|{
name|SWAP_PCTRIE_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rdpi
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|swblk_zone
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE() - free a range of blocks in the object's swap metadata  *  *	The requested range of blocks is freed, with any associated swap  *	returned to the swap bitmap.  *  *	This routine will free swap metadata structures as they are cleaned  *	out.  This routine does *NOT* operate on swap metadata associated  *	with resident pages.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_pindex_t
name|count
parameter_list|)
block|{
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|vm_pindex_t
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|empty
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|||
name|count
operator|==
literal|0
condition|)
return|return;
name|last
operator|=
name|pindex
operator|+
name|count
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rounddown
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
operator|||
name|sb
operator|->
name|p
operator|>
name|last
condition|)
break|break;
name|empty
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|==
name|SWAPBLK_NONE
condition|)
continue|continue;
if|if
condition|(
name|pindex
operator|<=
name|sb
operator|->
name|p
operator|+
name|i
operator|&&
name|sb
operator|->
name|p
operator|+
name|i
operator|<=
name|last
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|sb
operator|->
name|d
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
else|else
name|empty
operator|=
name|false
expr_stmt|;
block|}
name|pindex
operator|=
name|sb
operator|->
name|p
operator|+
name|SWAP_META_PAGES
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
name|SWAP_PCTRIE_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|sb
operator|->
name|p
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|swblk_zone
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_META_FREE_ALL() - destroy all swap metadata associated with object  *  *	This routine locates and destroys all swap metadata associated with  *	an object.  */
end_comment

begin_function
specifier|static
name|void
name|swp_pager_meta_free_all
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return;
for|for
control|(
name|pindex
operator|=
literal|0
init|;
operator|(
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|pindex
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|pindex
operator|=
name|sb
operator|->
name|p
operator|+
name|SWAP_META_PAGES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
name|swp_pager_freeswapspace
argument_list|(
name|sb
operator|->
name|d
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SWAP_PCTRIE_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|sb
operator|->
name|p
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|swblk_zone
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * SWP_PAGER_METACTL() -  misc control of swap and vm_page_t meta data.  *  *	This routine is capable of looking up, popping, or freeing  *	swapblk assignments in the swap meta data or in the vm_page_t.  *	The routine typically returns the swapblk being looked-up, or popped,  *	or SWAPBLK_NONE if the block was freed, or SWAPBLK_NONE if the block  *	was invalid.  This routine will automatically free any invalid  *	meta-data swapblks.  *  *	When acting on a busy resident page and paging is in progress, we  *	have to wait until paging is complete but otherwise can act on the  *	busy page.  *  *	SWM_FREE	remove and free swap block from metadata  *	SWM_POP		remove from meta data but do not free.. pop it out  */
end_comment

begin_function
specifier|static
name|daddr_t
name|swp_pager_meta_ctl
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|daddr_t
name|r1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SWM_FREE
operator||
name|SWM_POP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
else|else
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * The meta data only exists if the object is OBJT_SWAP 	 * and even then might not be allocated yet. 	 */
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rounddown
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
name|r1
operator|=
name|sb
operator|->
name|d
index|[
name|pindex
operator|%
name|SWAP_META_PAGES
index|]
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|SWAPBLK_NONE
condition|)
return|return
operator|(
name|SWAPBLK_NONE
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SWM_FREE
operator||
name|SWM_POP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sb
operator|->
name|d
index|[
name|pindex
operator|%
name|SWAP_META_PAGES
index|]
operator|=
name|SWAPBLK_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|SWAP_META_PAGES
condition|)
block|{
name|SWAP_PCTRIE_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rounddown
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|swblk_zone
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SWM_FREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|swp_pager_freeswapspace
argument_list|(
name|r1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SWAPBLK_NONE
expr_stmt|;
block|}
return|return
operator|(
name|r1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the least page index which is greater than or equal to the  * parameter pindex and for which there is a swap block allocated.  * Returns object's size if the object's type is not swap or if there  * are no allocated swap blocks for the object after the requested  * pindex.  */
end_comment

begin_function
name|vm_pindex_t
name|swap_pager_find_least
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|)
block|{
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
return|return
operator|(
name|object
operator|->
name|size
operator|)
return|;
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|rounddown
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|object
operator|->
name|size
operator|)
return|;
if|if
condition|(
name|sb
operator|->
name|p
operator|<
name|pindex
condition|)
block|{
for|for
control|(
name|i
operator|=
name|pindex
operator|%
name|SWAP_META_PAGES
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
return|return
operator|(
name|sb
operator|->
name|p
operator|+
name|i
operator|)
return|;
block|}
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|roundup
argument_list|(
name|pindex
argument_list|,
name|SWAP_META_PAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|object
operator|->
name|size
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
return|return
operator|(
name|sb
operator|->
name|p
operator|+
name|i
operator|)
return|;
block|}
comment|/* 	 * We get here if a swblk is present in the trie but it 	 * doesn't map any blocks. 	 */
name|MPASS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|object
operator|->
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * System call swapon(name) enables swapping on device name,  * which must be in the swdevsw.  Return EBUSY  * if already swapping on this device.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|swapon_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sys_swapon
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swapon_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SWAPON
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Swap metadata may not fit in the KVM if we have physical 	 * memory of>1GB. 	 */
if|if
condition|(
name|swblk_zone
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|ISOPEN
operator||
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|vp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|swapongeom
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_vfc
operator|->
name|vfc_flags
operator|&
name|VFCF_NETWORK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Allow direct swapping to NFS regular files in the same 		 * way that nfs_mountroot() sets up diskless swapping. 		 */
name|error
operator|=
name|swaponvp
argument_list|(
name|td
argument_list|,
name|vp
argument_list|,
name|attr
operator|.
name|va_size
operator|/
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that the total amount of swap currently configured does not  * exceed half the theoretical maximum.  If it does, print a warning  * message.  */
end_comment

begin_function
specifier|static
name|void
name|swapon_check_swzone
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|maxpages
decl_stmt|,
name|npages
decl_stmt|;
name|npages
operator|=
name|swap_total
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* absolute maximum we can handle assuming 100% efficiency */
name|maxpages
operator|=
name|uma_zone_get_max
argument_list|(
name|swblk_zone
argument_list|)
operator|*
name|SWAP_META_PAGES
expr_stmt|;
comment|/* recommend using no more than half that amount */
if|if
condition|(
name|npages
operator|>
name|maxpages
operator|/
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"warning: total configured swap (%lu pages) "
literal|"exceeds maximum recommended amount (%lu pages).\n"
argument_list|,
name|npages
argument_list|,
name|maxpages
operator|/
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"warning: increase kern.maxswzone "
literal|"or reduce amount of swap.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|swaponsomething
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|u_long
name|nblks
parameter_list|,
name|sw_strategy_t
modifier|*
name|strategy
parameter_list|,
name|sw_close_t
modifier|*
name|close
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|swblk_t
name|dvbase
decl_stmt|;
name|u_long
name|mblocks
decl_stmt|;
comment|/* 	 * nblks is in DEV_BSIZE'd chunks, convert to PAGE_SIZE'd chunks. 	 * First chop nblks off to page-align it, then convert. 	 * 	 * sw->sw_nblks is in page-sized chunks now too. 	 */
name|nblks
operator|&=
operator|~
operator|(
name|ctodb
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|nblks
operator|=
name|dbtoc
argument_list|(
name|nblks
argument_list|)
expr_stmt|;
comment|/* 	 * If we go beyond this, we get overflows in the radix 	 * tree bitmap code. 	 */
name|mblocks
operator|=
literal|0x40000000
operator|/
name|BLIST_META_RADIX
expr_stmt|;
if|if
condition|(
name|nblks
operator|>
name|mblocks
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: reducing swap size to maximum of %luMB per unit\n"
argument_list|,
name|mblocks
operator|/
literal|1024
operator|/
literal|1024
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|nblks
operator|=
name|mblocks
expr_stmt|;
block|}
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sp
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_vp
operator|=
name|vp
expr_stmt|;
name|sp
operator|->
name|sw_id
operator|=
name|id
expr_stmt|;
name|sp
operator|->
name|sw_dev
operator|=
name|dev
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sw_nblks
operator|=
name|nblks
expr_stmt|;
name|sp
operator|->
name|sw_used
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sw_strategy
operator|=
name|strategy
expr_stmt|;
name|sp
operator|->
name|sw_close
operator|=
name|close
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator|=
name|flags
expr_stmt|;
name|sp
operator|->
name|sw_blist
operator|=
name|blist_create
argument_list|(
name|nblks
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Do not free the first two block in order to avoid overwriting 	 * any bsd label at the front of the partition 	 */
name|blist_free
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
literal|2
argument_list|,
name|nblks
operator|-
literal|2
argument_list|)
expr_stmt|;
name|dvbase
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tsp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|tsp
operator|->
name|sw_end
operator|>=
name|dvbase
condition|)
block|{
comment|/* 			 * We put one uncovered page between the devices 			 * in order to definitively prevent any cross-device 			 * I/O requests 			 */
name|dvbase
operator|=
name|tsp
operator|->
name|sw_end
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|sw_first
operator|=
name|dvbase
expr_stmt|;
name|sp
operator|->
name|sw_end
operator|=
name|dvbase
operator|+
name|nblks
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swtailq
argument_list|,
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
name|nswapdev
operator|++
expr_stmt|;
name|swap_pager_avail
operator|+=
name|nblks
operator|-
literal|2
expr_stmt|;
name|swap_total
operator|+=
operator|(
name|vm_ooffset_t
operator|)
name|nblks
operator|*
name|PAGE_SIZE
expr_stmt|;
name|swapon_check_swzone
argument_list|()
expr_stmt|;
name|swp_sizecheck
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|swapon
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SYSCALL: swapoff(devname)  *  * Disable swapping on the given device.  *  * XXX: Badly designed system call: it should use a device index  * rather than filename as specification.  We keep sw_vp around  * only to make this work.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|swapoff_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sys_swapoff
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swapoff_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SWAPOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_vp
operator|==
name|vp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|swapoff_one
argument_list|(
name|sp
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|done
label|:
name|sx_xunlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swapoff_one
parameter_list|(
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|u_long
name|nblks
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|sx_assert
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
operator|(
name|void
operator|)
name|vn_lock
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|mac_system_check_swapoff
argument_list|(
name|cred
argument_list|,
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|nblks
operator|=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
comment|/* 	 * We can turn off this swap device safely only if the 	 * available virtual memory in the system will fit the amount 	 * of data we will have to page back in, plus an epsilon so 	 * the system doesn't become critically low on swap space. 	 */
if|if
condition|(
name|vm_cnt
operator|.
name|v_free_count
operator|+
name|swap_pager_avail
operator|<
name|nblks
operator|+
name|nswap_lowat
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Prevent further allocations on this device. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_flags
operator||=
name|SW_CLOSING
expr_stmt|;
name|swap_pager_avail
operator|-=
name|blist_fill
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|,
literal|0
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
name|swap_total
operator|-=
operator|(
name|vm_ooffset_t
operator|)
name|nblks
operator|*
name|PAGE_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Page in the contents of the device and close it. 	 */
name|swap_pager_swapoff
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_close
argument_list|(
name|curthread
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swtailq
argument_list|,
name|sp
argument_list|,
name|sw_list
argument_list|)
expr_stmt|;
name|nswapdev
operator|--
expr_stmt|;
if|if
condition|(
name|nswapdev
operator|==
literal|0
condition|)
block|{
name|swap_pager_full
operator|=
literal|2
expr_stmt|;
name|swap_pager_almost_full
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|swdevhd
operator|==
name|sp
condition|)
name|swdevhd
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|blist_destroy
argument_list|(
name|sp
operator|->
name|sw_blist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swapoff_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spt
decl_stmt|;
specifier|const
name|char
modifier|*
name|devname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|,
argument|spt
argument_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|devname
operator|=
name|devtoname
argument_list|(
name|sp
operator|->
name|sw_vp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
else|else
name|devname
operator|=
literal|"[file]"
expr_stmt|;
name|error
operator|=
name|swapoff_one
argument_list|(
name|sp
argument_list|,
name|thread0
operator|.
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot remove swap device %s (error=%d), "
literal|"skipping.\n"
argument_list|,
name|devname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Swap device %s removed.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|swdev_syscall_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap_pager_status
parameter_list|(
name|int
modifier|*
name|total
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
operator|*
name|total
operator|=
literal|0
expr_stmt|;
operator|*
name|used
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
operator|*
name|total
operator|+=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
operator|*
name|used
operator|+=
name|sp
operator|->
name|sw_used
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|swap_dev_info
parameter_list|(
name|int
name|name
parameter_list|,
name|struct
name|xswdev
modifier|*
name|xs
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_devname
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|n
operator|!=
name|name
condition|)
block|{
name|n
operator|++
expr_stmt|;
continue|continue;
block|}
name|xs
operator|->
name|xsw_version
operator|=
name|XSWDEV_VERSION
expr_stmt|;
name|xs
operator|->
name|xsw_dev
operator|=
name|sp
operator|->
name|sw_dev
expr_stmt|;
name|xs
operator|->
name|xsw_flags
operator|=
name|sp
operator|->
name|sw_flags
expr_stmt|;
name|xs
operator|->
name|xsw_nblks
operator|=
name|sp
operator|->
name|sw_nblks
expr_stmt|;
name|xs
operator|->
name|xsw_used
operator|=
name|sp
operator|->
name|sw_used
expr_stmt|;
if|if
condition|(
name|devname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vn_isdisk
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp_devname
operator|=
name|devtoname
argument_list|(
name|sp
operator|->
name|sw_vp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
else|else
name|tmp_devname
operator|=
literal|"[file]"
expr_stmt|;
name|strncpy
argument_list|(
name|devname
argument_list|,
name|tmp_devname
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD11
argument_list|)
end_if

begin_define
define|#
directive|define
name|XSWDEV_VERSION_11
value|1
end_define

begin_struct
struct|struct
name|xswdev11
block|{
name|u_int
name|xsw_version
decl_stmt|;
name|uint32_t
name|xsw_dev
decl_stmt|;
name|int
name|xsw_flags
decl_stmt|;
name|int
name|xsw_nblks
decl_stmt|;
name|int
name|xsw_used
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sysctl_vm_swap_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xswdev
name|xs
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD11
argument_list|)
name|struct
name|xswdev11
name|xs11
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
if|if
condition|(
name|arg2
operator|!=
literal|1
condition|)
comment|/* name length */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|swap_dev_info
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
argument_list|,
operator|&
name|xs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD11
argument_list|)
if|if
condition|(
name|req
operator|->
name|oldlen
operator|==
sizeof|sizeof
argument_list|(
name|xs11
argument_list|)
condition|)
block|{
name|xs11
operator|.
name|xsw_version
operator|=
name|XSWDEV_VERSION_11
expr_stmt|;
name|xs11
operator|.
name|xsw_dev
operator|=
name|xs
operator|.
name|xsw_dev
expr_stmt|;
comment|/* truncation */
name|xs11
operator|.
name|xsw_flags
operator|=
name|xs
operator|.
name|xsw_flags
expr_stmt|;
name|xs11
operator|.
name|xsw_nblks
operator|=
name|xs
operator|.
name|xsw_nblks
expr_stmt|;
name|xs11
operator|.
name|xsw_used
operator|=
name|xs
operator|.
name|xsw_used
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xs11
argument_list|,
sizeof|sizeof
argument_list|(
name|xs11
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xs
argument_list|,
sizeof|sizeof
argument_list|(
name|xs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|nswapdev
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nswapdev
argument_list|,
literal|0
argument_list|,
literal|"Number of swap devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|swap_info
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sysctl_vm_swap_info
argument_list|,
literal|"Swap statistics by device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Count the approximate swap usage in pages for a vmspace.  The  * shadowed or not yet copied on write swap blocks are not accounted.  * The map must be locked.  */
end_comment

begin_function
name|long
name|vmspace_swap_count
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|cur
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|struct
name|swblk
modifier|*
name|sb
decl_stmt|;
name|vm_pindex_t
name|e
decl_stmt|,
name|pi
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|map
operator|=
operator|&
name|vmspace
operator|->
name|vm_map
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|cur
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|cur
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|object
operator|=
name|cur
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
operator|||
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
continue|continue;
name|VM_OBJECT_RLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
condition|)
goto|goto
name|unlock
goto|;
name|pi
operator|=
name|OFF_TO_IDX
argument_list|(
name|cur
operator|->
name|offset
argument_list|)
expr_stmt|;
name|e
operator|=
name|pi
operator|+
name|OFF_TO_IDX
argument_list|(
name|cur
operator|->
name|end
operator|-
name|cur
operator|->
name|start
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
name|pi
operator|=
name|sb
operator|->
name|p
operator|+
name|SWAP_META_PAGES
control|)
block|{
name|sb
operator|=
name|SWAP_PCTRIE_LOOKUP_GE
argument_list|(
operator|&
name|object
operator|->
name|un_pager
operator|.
name|swp
operator|.
name|swp_blks
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
operator|||
name|sb
operator|->
name|p
operator|>=
name|e
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SWAP_META_PAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|p
operator|+
name|i
operator|<
name|e
operator|&&
name|sb
operator|->
name|d
index|[
name|i
index|]
operator|!=
name|SWAPBLK_NONE
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
name|unlock
label|:
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GEOM backend  *  * Swapping onto disk devices.  *  */
end_comment

begin_decl_stmt
specifier|static
name|g_orphan_t
name|swapgeom_orphan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_swap_class
init|=
block|{
operator|.
name|name
operator|=
literal|"SWAP"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|orphan
operator|=
name|swapgeom_orphan
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_swap_class
argument_list|,
name|g_class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|swapgeom_close_ev
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a reference to the g_consumer for an inflight transaction.  */
end_comment

begin_function
specifier|static
name|void
name|swapgeom_acquire
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference from the g_consumer.  Post a close event if all  * references go away, since the function might be called from the  * biodone context.  */
end_comment

begin_function
specifier|static
name|void
name|swapgeom_release
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|index
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_post_event
argument_list|(
name|swapgeom_close_ev
argument_list|,
name|cp
argument_list|,
name|M_NOWAIT
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp2
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|bp
operator|=
name|bp2
operator|->
name|bio_caller2
expr_stmt|;
name|cp
operator|=
name|bp2
operator|->
name|bio_from
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|=
name|bp2
operator|->
name|bio_flags
expr_stmt|;
if|if
condition|(
name|bp2
operator|->
name|bio_error
condition|)
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|bp2
operator|->
name|bio_completed
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|bp2
operator|->
name|bio_error
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|bp2
operator|->
name|bio_caller1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swapgeom_release
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|swapgeom_acquire
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
condition|)
name|bio
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
else|else
name|bio
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bio
operator|==
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|swapgeom_release
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bio
operator|->
name|bio_caller1
operator|=
name|sp
expr_stmt|;
name|bio
operator|->
name|bio_caller2
operator|=
name|bp
expr_stmt|;
name|bio
operator|->
name|bio_cmd
operator|=
name|bp
operator|->
name|b_iocmd
expr_stmt|;
name|bio
operator|->
name|bio_offset
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|-
name|sp
operator|->
name|sw_first
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|bio
operator|->
name|bio_length
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bio
operator|->
name|bio_done
operator|=
name|swapgeom_done
expr_stmt|;
if|if
condition|(
operator|!
name|buf_mapped
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|bio
operator|->
name|bio_ma
operator|=
name|bp
operator|->
name|b_pages
expr_stmt|;
name|bio
operator|->
name|bio_data
operator|=
name|unmapped_buf
expr_stmt|;
name|bio
operator|->
name|bio_ma_offset
operator|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|bio
operator|->
name|bio_ma_n
operator|=
name|bp
operator|->
name|b_npages
expr_stmt|;
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_UNMAPPED
expr_stmt|;
block|}
else|else
block|{
name|bio
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bio
operator|->
name|bio_ma
operator|=
name|NULL
expr_stmt|;
block|}
name|g_io_request
argument_list|(
name|bio
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|destroy
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_id
operator|==
name|cp
condition|)
block|{
name|sp
operator|->
name|sw_flags
operator||=
name|SW_CLOSING
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Drop reference we were created with. Do directly since we're in a 	 * special context where we don't have to queue the call to 	 * swapgeom_close_ev(). 	 */
name|cp
operator|->
name|index
operator|--
expr_stmt|;
name|destroy
operator|=
operator|(
operator|(
name|sp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cp
operator|->
name|index
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|destroy
condition|)
name|sp
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy
condition|)
name|swapgeom_close_ev
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapgeom_close
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sw
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sw
operator|->
name|sw_id
expr_stmt|;
name|sw
operator|->
name|sw_id
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * swapgeom_close() may be called from the biodone context, 	 * where we cannot perform topology changes.  Delegate the 	 * work to the events thread. 	 */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|g_waitfor_event
argument_list|(
name|swapgeom_close_ev
argument_list|,
name|cp
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swapongeom_locked
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|u_long
name|nblks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pp
operator|=
name|g_dev_getprovider
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
name|cp
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|cp
operator|->
name|provider
operator|==
name|pp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|g_swap_class
argument_list|,
literal|"swap"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|=
literal|1
expr_stmt|;
comment|/* Number of active I/Os, plus one for being active. */
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_SEND
operator||
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Every time you think you can improve the margin for 	 * footshooting, somebody depends on the ability to do so: 	 * savecore(8) wants to write to our swapdev so we cannot 	 * set an exclusive count :-( 	 */
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nblks
operator|=
name|pp
operator|->
name|mediasize
operator|/
name|DEV_BSIZE
expr_stmt|;
name|swaponsomething
argument_list|(
name|vp
argument_list|,
name|cp
argument_list|,
name|nblks
argument_list|,
name|swapgeom_strategy
argument_list|,
name|swapgeom_close
argument_list|,
name|dev2udev
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
name|pp
operator|->
name|flags
operator|&
name|G_PF_ACCEPT_UNMAPPED
operator|)
operator|!=
literal|0
condition|?
name|SW_UNMAPPED
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swapongeom
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
operator|||
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|swapongeom_locked
argument_list|(
name|vp
operator|->
name|v_rdev
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VNODE backend  *  * This is used mainly for network filesystem (read: probably only tested  * with NFS) swapfiles.  *  */
end_comment

begin_function
specifier|static
name|void
name|swapdev_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp2
decl_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|ctodb
argument_list|(
name|bp
operator|->
name|b_blkno
operator|-
name|sp
operator|->
name|sw_first
argument_list|)
expr_stmt|;
name|vp2
operator|=
name|sp
operator|->
name|sw_id
expr_stmt|;
name|vhold
argument_list|(
name|vp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bufobj
condition|)
name|bufobj_wdrop
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|bufobj_wref
argument_list|(
operator|&
name|vp2
operator|->
name|v_bufobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bufobj
operator|!=
operator|&
name|vp2
operator|->
name|v_bufobj
condition|)
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|vp2
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|vp2
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swapdev_close
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|swdevt
modifier|*
name|sp
parameter_list|)
block|{
name|VOP_CLOSE
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|sp
operator|->
name|sw_vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swaponvp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|u_long
name|nblks
parameter_list|)
block|{
name|struct
name|swdevt
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nblks
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&swtailq
argument_list|,
argument|sw_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|sw_id
operator|==
name|vp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sw_dev_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_system_check_swapon
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
endif|#
directive|endif
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|swaponsomething
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|nblks
argument_list|,
name|swapdev_strategy
argument_list|,
name|swapdev_close
argument_list|,
name|NODEV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_swap_async_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|new
decl_stmt|,
name|n
decl_stmt|;
name|new
operator|=
name|nsw_wcount_async_max
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|new
operator|>
name|nswbuf
operator|/
literal|2
operator|||
name|new
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|nsw_wcount_async_max
operator|!=
name|new
condition|)
block|{
comment|/* 		 * Adjust difference.  If the current async count is too low, 		 * we will need to sqeeze our update slowly in.  Sleep with a 		 * higher priority than getpbuf() to finish faster. 		 */
name|n
operator|=
name|new
operator|-
name|nsw_wcount_async_max
expr_stmt|;
if|if
condition|(
name|nsw_wcount_async
operator|+
name|n
operator|>=
literal|0
condition|)
block|{
name|nsw_wcount_async
operator|+=
name|n
expr_stmt|;
name|nsw_wcount_async_max
operator|+=
name|n
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsw_wcount_async_max
operator|-=
name|nsw_wcount_async
expr_stmt|;
name|nsw_wcount_async
operator|=
literal|0
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|nsw_wcount_async
argument_list|,
operator|&
name|pbuf_mtx
argument_list|,
name|PSWP
argument_list|,
literal|"swpsysctl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pbuf_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

