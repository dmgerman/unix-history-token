begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: vm_mmap.c 1.6 91/10/21$  *  *	@(#)vm_mmap.c	8.4 (Berkeley) 1/12/94  * $Id: vm_mmap.c,v 1.76 1998/05/18 18:26:27 guido Exp $  */
end_comment

begin_comment
comment|/*  * Mapped file (mmap) interface to VM  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_rlimit.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_inherit.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|sbrk_args
block|{
name|int
name|incr
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sbrk
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sbrk_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|sstk_args
block|{
name|int
name|incr
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sstk
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sstk_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* Not yet implemented */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|getpagesize_args
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ogetpagesize
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|getpagesize_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|PAGE_SIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 || COMPAT_SUNOS */
end_comment

begin_comment
comment|/*   * Memory Map (mmap) system call.  Note that the file offset  * and address are allowed to be NOT page aligned, though if  * the MAP_FIXED flag it set, both must have the same remainder  * modulo the PAGE_SIZE (POSIX 1003.1b).  If the address is not  * page-aligned, the actual mapping starts at trunc_page(addr)  * and the return value is adjusted up by the page offset.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mmap_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|pad
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mmap
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|mmap_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|,
name|maxprot
decl_stmt|;
name|void
modifier|*
name|handle
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
name|int
name|disablexworkaround
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|prot
operator|=
name|uap
operator|->
name|prot
operator|&
name|VM_PROT_ALL
expr_stmt|;
name|flags
operator|=
name|uap
operator|->
name|flags
expr_stmt|;
name|pos
operator|=
name|uap
operator|->
name|pos
expr_stmt|;
comment|/* make sure mapping fits into numeric range etc */
if|if
condition|(
operator|(
name|pos
operator|+
name|size
operator|>
operator|(
name|vm_offset_t
operator|)
operator|-
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|ssize_t
operator|)
name|uap
operator|->
name|len
operator|<
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
name|MAP_ANON
operator|)
operator|&&
name|uap
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Align the file position to a page boundary, 	 * and save its page offset component. 	 */
name|pageoff
operator|=
operator|(
name|pos
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|pos
operator|-=
name|pageoff
expr_stmt|;
comment|/* Adjust size for rounding (on both ends). */
name|size
operator|+=
name|pageoff
expr_stmt|;
comment|/* low end... */
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* hi end */
comment|/* 	 * Check for illegal addresses.  Watch out for address wrap... Note 	 * that VM_*_ADDRESS are not constants due to casts (argh). 	 */
if|if
condition|(
name|flags
operator|&
name|MAP_FIXED
condition|)
block|{
comment|/* 		 * The specified address must have the same remainder 		 * as the file offset taken modulo PAGE_SIZE, so it 		 * should be aligned after adjustment by pageoff. 		 */
name|addr
operator|-=
name|pageoff
expr_stmt|;
if|if
condition|(
name|addr
operator|&
name|PAGE_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Address range must be all in user VM space. */
if|if
condition|(
name|VM_MAXUSER_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|+
name|size
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifndef|#
directive|ifndef
name|i386
if|if
condition|(
name|VM_MIN_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|<
name|VM_MIN_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * XXX for non-fixed mappings where no hint is provided or 	 * the hint would fall in the potential heap space, 	 * place it after the end of the largest possible heap. 	 * 	 * There should really be a pmap call to determine a reasonable 	 * location. 	 */
elseif|else
if|if
condition|(
name|addr
operator|<
name|round_page
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
condition|)
name|addr
operator|=
name|round_page
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MAP_ANON
condition|)
block|{
comment|/* 		 * Mapping blank space is trivial. 		 */
name|handle
operator|=
name|NULL
expr_stmt|;
name|maxprot
operator|=
name|VM_PROT_ALL
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Mapping file, get fp for validation. Obtain vnode and make 		 * sure it is of appropriate type. 		 */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fd
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * XXX hack to handle use of /dev/zero to map anon memory (ala 		 * SunOS). 		 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
name|iszerodev
argument_list|(
name|vp
operator|->
name|v_rdev
argument_list|)
condition|)
block|{
name|handle
operator|=
name|NULL
expr_stmt|;
name|maxprot
operator|=
name|VM_PROT_ALL
expr_stmt|;
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * cdevs does not provide private mappings of any kind. 			 */
comment|/* 			 * However, for XIG X server to continue to work, 			 * we should allow the superuser to do it anyway. 			 * We only allow it at securelevel< 1. 			 * (Because the XIG X server writes directly to video 			 * memory via /dev/mem, it should never work at any 			 * other securelevel. 			 * XXX this will have to go 			 */
if|if
condition|(
name|securelevel
operator|>=
literal|1
condition|)
name|disablexworkaround
operator|=
literal|1
expr_stmt|;
else|else
name|disablexworkaround
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
name|disablexworkaround
operator|&&
operator|(
name|flags
operator|&
operator|(
name|MAP_PRIVATE
operator||
name|MAP_COPY
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * Ensure that file and memory protections are 			 * compatible.  Note that we only worry about 			 * writability if mapping is shared; in this case, 			 * current and max prot are dictated by the open file. 			 * XXX use the vnode instead?  Problem is: what 			 * credentials do we use for determination? What if 			 * proc does a setuid? 			 */
name|maxprot
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
comment|/* ??? */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
condition|)
name|maxprot
operator||=
name|VM_PROT_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|&
name|PROT_READ
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* 			 * If we are sharing potential changes (either via 			 * MAP_SHARED or via the implicit sharing of character 			 * device mappings), and we are trying to get write 			 * permission although we opened it without asking 			 * for it, bail out.  Check for superuser, only if 			 * we're at securelevel< 1, to allow the XIG X server 			 * to continue to work. 			 */
if|if
condition|(
operator|(
name|flags
operator|&
name|MAP_SHARED
operator|)
operator|!=
literal|0
operator|||
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
name|disablexworkaround
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|vattr
name|va
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|va
operator|.
name|va_flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|APPEND
operator|)
operator|)
operator|==
literal|0
condition|)
name|maxprot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|&
name|PROT_WRITE
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
else|else
name|maxprot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|vp
expr_stmt|;
block|}
block|}
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|size
argument_list|,
name|prot
argument_list|,
name|maxprot
argument_list|,
name|flags
argument_list|,
name|handle
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|+
name|pageoff
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ommap_args
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ommap
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|ommap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
name|nargs
decl_stmt|;
specifier|static
specifier|const
name|char
name|cvtbsdprot
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|PROT_EXEC
block|,
name|PROT_WRITE
block|,
name|PROT_EXEC
operator||
name|PROT_WRITE
block|,
name|PROT_READ
block|,
name|PROT_EXEC
operator||
name|PROT_READ
block|,
name|PROT_WRITE
operator||
name|PROT_READ
block|,
name|PROT_EXEC
operator||
name|PROT_WRITE
operator||
name|PROT_READ
block|, 	}
decl_stmt|;
define|#
directive|define
name|OMAP_ANON
value|0x0002
define|#
directive|define
name|OMAP_COPY
value|0x0020
define|#
directive|define
name|OMAP_SHARED
value|0x0010
define|#
directive|define
name|OMAP_FIXED
value|0x0100
define|#
directive|define
name|OMAP_INHERIT
value|0x0800
name|nargs
operator|.
name|addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|nargs
operator|.
name|len
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|nargs
operator|.
name|prot
operator|=
name|cvtbsdprot
index|[
name|uap
operator|->
name|prot
operator|&
literal|0x7
index|]
expr_stmt|;
name|nargs
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|OMAP_ANON
condition|)
name|nargs
operator|.
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|OMAP_COPY
condition|)
name|nargs
operator|.
name|flags
operator||=
name|MAP_COPY
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|OMAP_SHARED
condition|)
name|nargs
operator|.
name|flags
operator||=
name|MAP_SHARED
expr_stmt|;
else|else
name|nargs
operator|.
name|flags
operator||=
name|MAP_PRIVATE
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|OMAP_FIXED
condition|)
name|nargs
operator|.
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|OMAP_INHERIT
condition|)
name|nargs
operator|.
name|flags
operator||=
name|MAP_INHERIT
expr_stmt|;
name|nargs
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|nargs
operator|.
name|pos
operator|=
name|uap
operator|->
name|pos
expr_stmt|;
return|return
operator|(
name|mmap
argument_list|(
name|p
argument_list|,
operator|&
name|nargs
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msync_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|msync
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|msync_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|flags
operator|=
name|uap
operator|->
name|flags
expr_stmt|;
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|MS_ASYNC
operator||
name|MS_INVALIDATE
operator|)
operator|)
operator|==
operator|(
name|MS_ASYNC
operator||
name|MS_INVALIDATE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
comment|/* 	 * XXX Gak!  If size is zero we are supposed to sync "all modified 	 * pages with the region containing addr".  Unfortunately, we don't 	 * really keep track of individual mmaps so we approximate by flushing 	 * the range of the map entry containing addr. This can be incorrect 	 * if the region splits or is coalesced with a neighbor. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|FALSE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|addr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|size
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
comment|/* 	 * Clean the pages and interpret the return value. 	 */
name|rv
operator|=
name|vm_map_clean
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
operator|(
name|flags
operator|&
name|MS_ASYNC
operator|)
operator|==
literal|0
argument_list|,
operator|(
name|flags
operator|&
name|MS_INVALIDATE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
name|KERN_SUCCESS
case|:
break|break;
case|case
name|KERN_INVALID_ADDRESS
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Sun returns ENOMEM? */
case|case
name|KERN_FAILURE
case|:
return|return
operator|(
name|EIO
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|munmap_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|munmap
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|munmap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Check for illegal addresses.  Watch out for address wrap... Note 	 * that VM_*_ADDRESS are not constants due to casts (argh). 	 */
if|if
condition|(
name|VM_MAXUSER_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|+
name|size
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifndef|#
directive|ifndef
name|i386
if|if
condition|(
name|VM_MIN_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|<
name|VM_MIN_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
comment|/* 	 * Make sure entire range is allocated. 	 */
if|if
condition|(
operator|!
name|vm_map_check_protection
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
name|VM_PROT_NONE
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* returns nothing but KERN_SUCCESS anyway */
operator|(
name|void
operator|)
name|vm_map_remove
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|munmapfd
parameter_list|(
name|p
parameter_list|,
name|fd
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
comment|/* 	 * XXX should unmap any regions mapped to this file 	 */
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|fd
index|]
operator|&=
operator|~
name|UF_MAPPED
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mprotect_args
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mprotect
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|mprotect_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
specifier|register
name|vm_prot_t
name|prot
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|prot
operator|=
name|uap
operator|->
name|prot
operator|&
name|VM_PROT_ALL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VM_PROT_READ_IS_EXEC
argument_list|)
if|if
condition|(
name|prot
operator|&
name|VM_PROT_READ
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
endif|#
directive|endif
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
case|case
name|KERN_SUCCESS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KERN_PROTECTION_FAILURE
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|minherit_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|inherit
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|minherit
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|minherit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
specifier|register
name|vm_inherit_t
name|inherit
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|inherit
operator|=
name|uap
operator|->
name|inherit
expr_stmt|;
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|vm_map_inherit
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
name|inherit
argument_list|)
condition|)
block|{
case|case
name|KERN_SUCCESS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KERN_PROTECTION_FAILURE
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|madvise_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|behav
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|madvise
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|madvise_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_map_t
name|map
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* 	 * Check for illegal addresses.  Watch out for address wrap... Note 	 * that VM_*_ADDRESS are not constants due to casts (argh). 	 */
if|if
condition|(
name|VM_MAXUSER_ADDRESS
operator|>
literal|0
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
operator|)
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifndef|#
directive|ifndef
name|i386
if|if
condition|(
name|VM_MIN_ADDRESS
operator|>
literal|0
operator|&&
name|uap
operator|->
name|addr
operator|<
name|VM_MIN_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
operator|)
operator|<
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Since this routine is only advisory, we default to conservative 	 * behavior. 	 */
name|start
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|end
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
operator|+
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|vm_map_madvise
argument_list|(
name|map
argument_list|,
name|pmap
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|uap
operator|->
name|behav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mincore_args
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|vec
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|mincore
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|mincore_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|first_addr
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|,
name|cend
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|char
modifier|*
name|vec
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|vecindex
decl_stmt|,
name|lastvecindex
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|current
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|int
name|mincoreinfo
decl_stmt|;
comment|/* 	 * Make sure that the addresses presented are valid for user 	 * mode. 	 */
name|first_addr
operator|=
name|addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|end
operator|=
name|addr
operator|+
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|VM_MAXUSER_ADDRESS
operator|>
literal|0
operator|&&
name|end
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|end
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Address of byte vector 	 */
name|vec
operator|=
name|uap
operator|->
name|vec
expr_stmt|;
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|pmap
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
comment|/* 	 * Do this on a map entry basis so that if the pages are not 	 * in the current processes address space, we can easily look 	 * up the pages elsewhere. 	 */
name|lastvecindex
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|current
operator|=
name|entry
init|;
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
comment|/* 		 * ignore submaps (for now) or null objects 		 */
if|if
condition|(
operator|(
name|current
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_IS_A_MAP
operator||
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|)
operator|||
name|current
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * limit this scan to the current map entry and the 		 * limits for the mincore call 		 */
if|if
condition|(
name|addr
operator|<
name|current
operator|->
name|start
condition|)
name|addr
operator|=
name|current
operator|->
name|start
expr_stmt|;
name|cend
operator|=
name|current
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|cend
operator|>
name|end
condition|)
name|cend
operator|=
name|end
expr_stmt|;
comment|/* 		 * scan this entry one page at a time 		 */
while|while
condition|(
name|addr
operator|<
name|cend
condition|)
block|{
comment|/* 			 * Check pmap first, it is likely faster, also 			 * it can provide info as to whether we are the 			 * one referencing or modifying the page. 			 */
name|mincoreinfo
operator|=
name|pmap_mincore
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mincoreinfo
condition|)
block|{
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_ooffset_t
name|offset
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
comment|/* 				 * calculate the page index into the object 				 */
name|offset
operator|=
name|current
operator|->
name|offset
operator|+
operator|(
name|addr
operator|-
name|current
operator|->
name|start
operator|)
expr_stmt|;
name|pindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|current
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
comment|/* 				 * if the page is resident, then gather information about 				 * it. 				 */
if|if
condition|(
name|m
condition|)
block|{
name|mincoreinfo
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
operator|||
name|pmap_is_modified
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|mincoreinfo
operator||=
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_REFERENCED
operator|)
operator|||
name|pmap_ts_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_REFERENCED
expr_stmt|;
name|mincoreinfo
operator||=
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
block|}
block|}
block|}
comment|/* 			 * calculate index into user supplied byte vector 			 */
name|vecindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|addr
operator|-
name|first_addr
argument_list|)
expr_stmt|;
comment|/* 			 * If we have skipped map entries, we need to make sure that 			 * the byte vector is zeroed for those skipped entries. 			 */
while|while
condition|(
operator|(
name|lastvecindex
operator|+
literal|1
operator|)
operator|<
name|vecindex
condition|)
block|{
name|error
operator|=
name|subyte
argument_list|(
name|vec
operator|+
name|lastvecindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
operator|++
name|lastvecindex
expr_stmt|;
block|}
comment|/* 			 * Pass the page information to the user 			 */
name|error
operator|=
name|subyte
argument_list|(
name|vec
operator|+
name|vecindex
argument_list|,
name|mincoreinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|lastvecindex
operator|=
name|vecindex
expr_stmt|;
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Zero the last entries in the byte vector. 	 */
name|vecindex
operator|=
name|OFF_TO_IDX
argument_list|(
name|end
operator|-
name|first_addr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lastvecindex
operator|+
literal|1
operator|)
operator|<
name|vecindex
condition|)
block|{
name|error
operator|=
name|subyte
argument_list|(
name|vec
operator|+
name|lastvecindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
operator|++
name|lastvecindex
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mlock_args
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mlock
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|mlock_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|int
name|error
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* disable wrap around */
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|atop
argument_list|(
name|size
argument_list|)
operator|+
name|cnt
operator|.
name|v_wire_count
operator|>
name|vm_page_max_wired
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
ifdef|#
directive|ifdef
name|pmap_wired_count
if|if
condition|(
name|size
operator|+
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|vm_map_pmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
argument_list|)
argument_list|)
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_MEMLOCK
index|]
operator|.
name|rlim_cur
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|error
operator|=
name|vm_map_user_pageable
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
name|KERN_SUCCESS
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mlockall_args
block|{
name|int
name|how
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mlockall
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|mlockall_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mlockall_args
block|{
name|int
name|how
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|munlockall
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|munlockall_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|munlock_args
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|munlock
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|munlock_args
modifier|*
name|uap
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|int
name|error
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|pageoff
operator|=
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|addr
operator|-=
name|pageoff
expr_stmt|;
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* disable wrap around */
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifndef|#
directive|ifndef
name|pmap_wired_count
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|error
operator|=
name|vm_map_user_pageable
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
name|KERN_SUCCESS
condition|?
literal|0
else|:
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal version of mmap.  * Currently used by mmap, exec, and sys5 shared memory.  * Handle is either a vnode pointer or NULL for MAP_ANON.  */
end_comment

begin_function
name|int
name|vm_mmap
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_prot_t
name|maxprot
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|)
block|{
name|boolean_t
name|fitit
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|objtype_t
name|type
decl_stmt|;
name|int
name|rv
init|=
name|KERN_SUCCESS
decl_stmt|;
name|vm_ooffset_t
name|objsize
decl_stmt|;
name|int
name|docow
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|objsize
operator|=
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * We currently can only deal with page aligned file offsets. 	 * The check is here rather than in the syscall because the 	 * kernel calls this function internally for other mmaping 	 * operations (such as in exec) and non-aligned offsets will 	 * cause pmap inconsistencies...so we want to be sure to 	 * disallow this in all cases. 	 */
if|if
condition|(
name|foff
operator|&
name|PAGE_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MAP_FIXED
operator|)
operator|==
literal|0
condition|)
block|{
name|fitit
operator|=
name|TRUE
expr_stmt|;
operator|*
name|addr
operator|=
name|round_page
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|addr
operator|!=
name|trunc_page
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fitit
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_remove
argument_list|(
name|map
argument_list|,
operator|*
name|addr
argument_list|,
operator|*
name|addr
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Lookup/allocate object. 	 */
if|if
condition|(
name|flags
operator|&
name|MAP_ANON
condition|)
block|{
name|type
operator|=
name|OBJT_DEFAULT
expr_stmt|;
comment|/* 		 * Unnamed anonymous regions always start at 0. 		 */
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
name|foff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|handle
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
block|{
name|type
operator|=
name|OBJT_DEVICE
expr_stmt|;
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|vp
operator|->
name|v_rdev
expr_stmt|;
block|}
else|else
block|{
name|struct
name|vattr
name|vat
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vat
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|objsize
operator|=
name|round_page
argument_list|(
name|vat
operator|.
name|va_size
argument_list|)
expr_stmt|;
name|type
operator|=
name|OBJT_VNODE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|object
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|vm_pager_allocate
argument_list|(
name|type
argument_list|,
name|handle
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|objsize
argument_list|)
argument_list|,
name|prot
argument_list|,
name|foff
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
operator|(
name|type
operator|==
name|OBJT_DEVICE
condition|?
name|EINVAL
else|:
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Force device mappings to be shared. 	 */
if|if
condition|(
name|type
operator|==
name|OBJT_DEVICE
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|MAP_PRIVATE
operator||
name|MAP_COPY
operator|)
expr_stmt|;
name|flags
operator||=
name|MAP_SHARED
expr_stmt|;
block|}
name|docow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|MAP_ANON
operator||
name|MAP_SHARED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|docow
operator|=
name|MAP_COPY_ON_WRITE
operator||
name|MAP_COPY_NEEDED
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VM_PROT_READ_IS_EXEC
argument_list|)
if|if
condition|(
name|prot
operator|&
name|VM_PROT_READ
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|maxprot
operator|&
name|VM_PROT_READ
condition|)
name|maxprot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fitit
condition|)
block|{
operator|*
name|addr
operator|=
name|pmap_addr_hint
argument_list|(
name|object
argument_list|,
operator|*
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|vm_map_find
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|foff
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|fitit
argument_list|,
name|prot
argument_list|,
name|maxprot
argument_list|,
name|docow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
comment|/* 		 * Lose the object reference. Will destroy the 		 * object if it's an unnamed anonymous mapping 		 * or named anonymous without other references. 		 */
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * "Pre-fault" resident pages. 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|pmap
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|object
operator|!=
name|NULL
operator|)
condition|)
block|{
name|pmap_object_init_pt
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
operator|*
name|addr
argument_list|,
name|object
argument_list|,
operator|(
name|vm_pindex_t
operator|)
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shared memory is also shared with children. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|MAP_SHARED
operator||
name|MAP_INHERIT
operator|)
condition|)
block|{
name|rv
operator|=
name|vm_map_inherit
argument_list|(
name|map
argument_list|,
operator|*
name|addr
argument_list|,
operator|*
name|addr
operator|+
name|size
argument_list|,
name|VM_INHERIT_SHARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|vm_map_remove
argument_list|(
name|map
argument_list|,
operator|*
name|addr
argument_list|,
operator|*
name|addr
operator|+
name|size
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
name|KERN_SUCCESS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KERN_INVALID_ADDRESS
case|:
case|case
name|KERN_NO_SPACE
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|KERN_PROTECTION_FAILURE
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

end_unit

