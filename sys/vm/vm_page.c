begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_page.c	7.4 (Berkeley) 5/7/91  *	$Id: vm_page.c,v 1.45 1996/01/04 21:13:23 wollman Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Resident memory management module.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|DDB_print_page_info
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Associated with page of user-allocatable memory is a  *	page structure.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pglist
modifier|*
name|vm_page_buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of buckets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vm_page_bucket_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is array? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vm_page_hash_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask for hash function */
end_comment

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_zero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_queue
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|struct
name|pglist
modifier|*
name|pl
decl_stmt|;
name|int
modifier|*
name|cnt
decl_stmt|;
block|}
name|vm_page_queues
index|[
name|PQ_CACHE
operator|+
literal|1
index|]
init|=
block|{
block|{
name|NULL
block|,
operator|&
name|no_queue
block|}
block|,
block|{
operator|&
name|vm_page_queue_free
block|,
operator|&
name|cnt
operator|.
name|v_free_count
block|}
block|,
block|{
operator|&
name|vm_page_queue_zero
block|,
operator|&
name|cnt
operator|.
name|v_free_count
block|}
block|,
block|{
operator|&
name|vm_page_queue_inactive
block|,
operator|&
name|cnt
operator|.
name|v_inactive_count
block|}
block|,
block|{
operator|&
name|vm_page_queue_active
block|,
operator|&
name|cnt
operator|.
name|v_active_count
block|}
block|,
block|{
operator|&
name|vm_page_queue_cache
block|,
operator|&
name|cnt
operator|.
name|v_cache_count
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|vm_page_t
name|vm_page_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vm_page_array_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|first_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|last_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_size_t
name|page_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|page_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_zero_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * map of contiguous valid DEV_BSIZE chunks in a page  * (this list is valid for page sizes upto 16*DEV_BSIZE)  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|vm_page_dev_bsize_chunks
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x1
block|,
literal|0x3
block|,
literal|0x7
block|,
literal|0xf
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0x1ff
block|,
literal|0x3ff
block|,
literal|0x7ff
block|,
literal|0xfff
block|,
literal|0x1fff
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|__pure
name|int
name|vm_page_hash
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|,
name|vm_pindex_t
name|pindex
operator|)
argument_list|)
name|__pure2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vm_page_unqueue
name|__P
argument_list|(
operator|(
name|vm_page_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	vm_set_page_size:  *  *	Sets the page size, perhaps based upon the memory  *	size.  Must be called before any use of page-size  *	dependent functions.  *  *	Sets page_shift and page_mask from cnt.v_page_size.  */
end_comment

begin_function
name|void
name|vm_set_page_size
parameter_list|()
block|{
if|if
condition|(
name|cnt
operator|.
name|v_page_size
operator|==
literal|0
condition|)
name|cnt
operator|.
name|v_page_size
operator|=
name|DEFAULT_PAGE_SIZE
expr_stmt|;
name|page_mask
operator|=
name|cnt
operator|.
name|v_page_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|page_mask
operator|&
name|cnt
operator|.
name|v_page_size
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vm_set_page_size: page size not a power of two"
argument_list|)
expr_stmt|;
for|for
control|(
name|page_shift
operator|=
literal|0
init|;
condition|;
name|page_shift
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|page_shift
operator|)
operator|==
name|cnt
operator|.
name|v_page_size
condition|)
break|break;
block|}
end_function

begin_comment
comment|/*  *	vm_page_startup:  *  *	Initializes the resident memory module.  *  *	Allocates memory for the page cells, and  *	for the object/offset-to-page hash table headers.  *	Each page cell is initialized and placed on the free list.  */
end_comment

begin_function
name|vm_offset_t
name|vm_page_startup
parameter_list|(
name|starta
parameter_list|,
name|enda
parameter_list|,
name|vaddr
parameter_list|)
specifier|register
name|vm_offset_t
name|starta
decl_stmt|;
name|vm_offset_t
name|enda
decl_stmt|;
specifier|register
name|vm_offset_t
name|vaddr
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|mapped
decl_stmt|;
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
name|vm_size_t
name|npages
decl_stmt|,
name|page_range
decl_stmt|;
specifier|register
name|vm_offset_t
name|new_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|vm_offset_t
name|first_managed_page
decl_stmt|;
comment|/* the biggest memory array is the second group of pages */
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|biggestone
decl_stmt|,
name|biggestsize
decl_stmt|;
name|vm_offset_t
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|biggestsize
operator|=
literal|0
expr_stmt|;
name|biggestone
operator|=
literal|0
expr_stmt|;
name|nblocks
operator|=
literal|0
expr_stmt|;
name|vaddr
operator|=
name|round_page
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|round_page
argument_list|(
name|phys_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|trunc_page
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|size
init|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|biggestsize
condition|)
block|{
name|biggestone
operator|=
name|i
expr_stmt|;
name|biggestsize
operator|=
name|size
expr_stmt|;
block|}
operator|++
name|nblocks
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|start
operator|=
name|phys_avail
index|[
name|biggestone
index|]
expr_stmt|;
comment|/* 	 * Initialize the queue headers for the free queue, the active queue 	 * and the inactive queue. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queue_zero
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queue_cache
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate (and initialize) the hash table buckets. 	 * 	 * The number of buckets MUST BE a power of 2, and the actual value is 	 * the next power of 2 greater than the number of physical pages in 	 * the system. 	 * 	 * Note: This computation can be tweaked if desired. 	 */
name|vm_page_buckets
operator|=
operator|(
expr|struct
name|pglist
operator|*
operator|)
name|vaddr
expr_stmt|;
name|bucket
operator|=
name|vm_page_buckets
expr_stmt|;
if|if
condition|(
name|vm_page_bucket_count
operator|==
literal|0
condition|)
block|{
name|vm_page_bucket_count
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|vm_page_bucket_count
operator|<
name|atop
argument_list|(
name|total
argument_list|)
condition|)
name|vm_page_bucket_count
operator|<<=
literal|1
expr_stmt|;
block|}
name|vm_page_hash_mask
operator|=
name|vm_page_bucket_count
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Validate these addresses. 	 */
name|new_start
operator|=
name|start
operator|+
name|vm_page_bucket_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pglist
argument_list|)
expr_stmt|;
name|new_start
operator|=
name|round_page
argument_list|(
name|new_start
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
name|vaddr
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
name|vaddr
operator|-
name|mapped
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_bucket_count
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
block|}
comment|/* 	 * round (or truncate) the addresses to our page size. 	 */
comment|/* 	 * Pre-allocate maps and map entries that cannot be dynamically 	 * allocated via malloc().  The maps include the kernel_map and 	 * kmem_map which must be initialized before malloc() will work 	 * (obviously).  Also could include pager maps which would be 	 * allocated before kmeminit. 	 * 	 * Allow some kernel map entries... this should be plenty since people 	 * shouldn't be cluttering up the kernel map (they should use their 	 * own maps). 	 */
name|kentry_data_size
operator|=
name|MAX_KMAP
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
operator|+
name|MAX_KMAPENT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
expr_stmt|;
name|kentry_data_size
operator|=
name|round_page
argument_list|(
name|kentry_data_size
argument_list|)
expr_stmt|;
name|kentry_data
operator|=
operator|(
name|vm_offset_t
operator|)
name|vaddr
expr_stmt|;
name|vaddr
operator|+=
name|kentry_data_size
expr_stmt|;
comment|/* 	 * Validate these zone addresses. 	 */
name|new_start
operator|=
name|start
operator|+
operator|(
name|vaddr
operator|-
name|mapped
operator|)
expr_stmt|;
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
operator|(
name|vaddr
operator|-
name|mapped
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|round_page
argument_list|(
name|new_start
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the number of pages of memory that will be available for 	 * use (taking into account the overhead of a page structure per 	 * page). 	 */
name|first_page
operator|=
name|phys_avail
index|[
literal|0
index|]
operator|/
name|PAGE_SIZE
expr_stmt|;
name|last_page
operator|=
name|phys_avail
index|[
operator|(
name|nblocks
operator|-
literal|1
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|/
name|PAGE_SIZE
expr_stmt|;
name|page_range
operator|=
name|last_page
operator|-
operator|(
name|phys_avail
index|[
literal|0
index|]
operator|/
name|PAGE_SIZE
operator|)
expr_stmt|;
name|npages
operator|=
operator|(
name|total
operator|-
operator|(
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|)
operator|-
operator|(
name|start
operator|-
name|phys_avail
index|[
name|biggestone
index|]
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Initialize the mem entry structures now, and put them in the free 	 * queue. 	 */
name|vm_page_array
operator|=
operator|(
name|vm_page_t
operator|)
name|vaddr
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
comment|/* 	 * Validate these addresses. 	 */
name|new_start
operator|=
name|round_page
argument_list|(
name|start
operator|+
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|first_managed_page
operator|=
name|start
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Clear all of the page structures 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vm_page_array
argument_list|,
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_array_size
operator|=
name|page_range
expr_stmt|;
name|cnt
operator|.
name|v_page_count
operator|=
literal|0
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|>
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|==
name|biggestone
condition|)
name|pa
operator|=
name|ptoa
argument_list|(
name|first_managed_page
argument_list|)
expr_stmt|;
else|else
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pa
operator|<
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|--
operator|>
literal|0
condition|)
block|{
operator|++
name|cnt
operator|.
name|v_page_count
expr_stmt|;
operator|++
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_FREE
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mapped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_hash:  *  *	Distributes the object/offset key pair among hash buckets.  *  *	NOTE:  This macro depends on vm_page_bucket_count being a power of 2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|__pure
name|int
name|vm_page_hash
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|object
operator|+
name|pindex
operator|)
operator|&
name|vm_page_hash_mask
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_insert:		[ internal use only ]  *  *	Inserts the given mem entry into the object/object-page  *	table and object list.  *  *	The object and page must be locked, and must be splhigh.  */
end_comment

begin_function
specifier|inline
name|void
name|vm_page_insert
parameter_list|(
name|m
parameter_list|,
name|object
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_TABLED
condition|)
name|panic
argument_list|(
literal|"vm_page_insert: already inserted"
argument_list|)
expr_stmt|;
comment|/* 	 * Record the object/offset pair in this page 	 */
name|m
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|m
operator|->
name|pindex
operator|=
name|pindex
expr_stmt|;
comment|/* 	 * Insert it into the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bucket
argument_list|,
name|m
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
comment|/* 	 * Now link into the object's list of backed pages. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_TABLED
expr_stmt|;
comment|/* 	 * And show that the object has one more resident page. 	 */
name|object
operator|->
name|resident_page_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_remove:		[ internal use only ]  *				NOTE: used by device pager as well -wfj  *  *	Removes the given mem entry from the object/offset-page  *	table and the object page list.  *  *	The object and page must be locked, and at splhigh.  */
end_comment

begin_function
specifier|inline
name|void
name|vm_page_remove
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_TABLED
operator|)
condition|)
return|return;
comment|/* 	 * Remove from the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|bucket
argument_list|,
name|m
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
comment|/* 	 * Now remove from the object's list of backed pages. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 	 * And show that the object has one fewer resident page. 	 */
name|m
operator|->
name|object
operator|->
name|resident_page_count
operator|--
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_TABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_lookup:  *  *	Returns the page associated with the object/offset  *	pair specified; if none is found, NULL is returned.  *  *	The object must be locked.  No side effects.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_lookup
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Search the hash table for this object/offset pair 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
name|m
operator|=
name|bucket
operator|->
name|tqh_first
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|hashq
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|object
operator|==
name|object
operator|)
operator|&&
operator|(
name|m
operator|->
name|pindex
operator|==
name|pindex
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_rename:  *  *	Move the given memory entry from its  *	current object to the specified target object/offset.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_page_rename
parameter_list|(
name|m
parameter_list|,
name|new_object
parameter_list|,
name|new_pindex
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|vm_object_t
name|new_object
decl_stmt|;
name|vm_pindex_t
name|new_pindex
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|new_object
argument_list|,
name|new_pindex
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vm_page_unqueue must be called at splhigh();  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vm_page_unqueue
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|queue
init|=
name|m
operator|->
name|queue
decl_stmt|;
if|if
condition|(
name|queue
operator|==
name|PQ_NONE
condition|)
return|return;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|vm_page_queues
index|[
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|vm_page_queues
index|[
name|queue
index|]
operator|.
name|cnt
operator|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|PQ_CACHE
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_cache_count
operator|+
name|cnt
operator|.
name|v_free_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_min
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  *	vm_page_alloc:  *  *	Allocate and return a memory cell associated  *	with this VM object/offset pair.  *  *	page_req classes:  *	VM_ALLOC_NORMAL		normal process request  *	VM_ALLOC_SYSTEM		system *really* needs a page  *	VM_ALLOC_INTERRUPT	interrupt time request  *	VM_ALLOC_ZERO		zero page  *  *	Object must be locked.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_alloc
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|page_req
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|page_req
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
name|int
name|queue
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc: page already allocated"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|curproc
operator|==
name|pageproc
operator|)
operator|&&
operator|(
name|page_req
operator|!=
name|VM_ALLOC_INTERRUPT
operator|)
condition|)
block|{
name|page_req
operator|=
name|VM_ALLOC_SYSTEM
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|page_req
condition|)
block|{
case|case
name|VM_ALLOC_NORMAL
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
name|m
operator|=
name|vm_page_queue_free
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|--
name|vm_page_zero_count
expr_stmt|;
name|m
operator|=
name|vm_page_queue_zero
operator|.
name|tqh_first
expr_stmt|;
block|}
block|}
else|else
block|{
name|m
operator|=
name|vm_page_queue_cache
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_ZERO
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
name|m
operator|=
name|vm_page_queue_zero
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
operator|--
name|vm_page_zero_count
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|vm_page_queue_free
operator|.
name|tqh_first
expr_stmt|;
block|}
block|}
else|else
block|{
name|m
operator|=
name|vm_page_queue_cache
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_SYSTEM
case|:
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
operator|)
operator|||
operator|(
operator|(
name|cnt
operator|.
name|v_cache_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_interrupt_free_min
operator|)
operator|)
condition|)
block|{
name|m
operator|=
name|vm_page_queue_free
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|--
name|vm_page_zero_count
expr_stmt|;
name|m
operator|=
name|vm_page_queue_zero
operator|.
name|tqh_first
expr_stmt|;
block|}
block|}
else|else
block|{
name|m
operator|=
name|vm_page_queue_cache
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_INTERRUPT
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|vm_page_queue_free
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|--
name|vm_page_zero_count
expr_stmt|;
name|m
operator|=
name|vm_page_queue_zero
operator|.
name|tqh_first
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"vm_page_alloc: invalid allocation class"
argument_list|)
expr_stmt|;
block|}
name|queue
operator|=
name|m
operator|->
name|queue
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|vm_page_queues
index|[
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|vm_page_queues
index|[
name|queue
index|]
operator|.
name|cnt
operator|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|PQ_ZERO
condition|)
block|{
name|m
operator|->
name|flags
operator|=
name|PG_ZERO
operator||
name|PG_BUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|==
name|PQ_CACHE
condition|)
block|{
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|=
name|PG_BUSY
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|flags
operator|=
name|PG_BUSY
expr_stmt|;
block|}
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|hold_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
comment|/* XXX before splx until vm_page_insert is safe */
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Don't wakeup too often - wakeup the pageout daemon when 	 * we would be nearly out of memory. 	 */
if|if
condition|(
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_min
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
operator|)
operator|||
operator|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_pageout_free_min
operator|)
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|vm_page_alloc_contig
parameter_list|(
name|size
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|alignment
parameter_list|)
name|vm_offset_t
name|size
decl_stmt|;
name|vm_offset_t
name|low
decl_stmt|;
name|vm_offset_t
name|high
decl_stmt|;
name|vm_offset_t
name|alignment
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|start
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|,
name|phys
decl_stmt|,
name|tmp_addr
decl_stmt|;
name|vm_page_t
name|pga
init|=
name|vm_page_array
decl_stmt|;
if|if
condition|(
operator|(
name|alignment
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc_contig: alignment must be a power of 2"
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|again
label|:
comment|/* 	 * Find first page in array that is free, within range, and aligned. 	 */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|cnt
operator|.
name|v_page_count
condition|;
name|i
operator|++
control|)
block|{
name|phys
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pga
index|[
name|i
index|]
operator|.
name|queue
operator|==
name|PQ_FREE
operator|)
operator|&&
operator|(
name|phys
operator|>=
name|low
operator|)
operator|&&
operator|(
name|phys
operator|<
name|high
operator|)
operator|&&
operator|(
operator|(
name|phys
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
comment|/* 	 * If the above failed or we will exceed the upper bound, fail. 	 */
if|if
condition|(
operator|(
name|i
operator|==
name|cnt
operator|.
name|v_page_count
operator|)
operator|||
operator|(
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
operator|+
name|size
operator|)
operator|>
name|high
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
name|i
expr_stmt|;
comment|/* 	 * Check successive pages for contiguous and free. 	 */
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|/
name|PAGE_SIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
operator|!=
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|+
name|PAGE_SIZE
operator|)
operator|)
operator|||
operator|(
name|pga
index|[
name|i
index|]
operator|.
name|queue
operator|!=
name|PQ_FREE
operator|)
condition|)
block|{
name|start
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 	 * We've found a contiguous chunk that meets are requirements. 	 * Allocate kernel VM, unfree and assign the physical pages to it and 	 * return kernel VM pointer. 	 */
name|tmp_addr
operator|=
name|addr
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|/
name|PAGE_SIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
operator|&
name|pga
index|[
name|i
index|]
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|--
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|kernel_object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|tmp_addr
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|tmp_addr
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_free:  *  *	Returns the given page to the free list,  *	disassociating it with any VM object.  *  *	Object and page must be locked prior to entry.  */
end_comment

begin_function
name|void
name|vm_page_free
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|flags
init|=
name|m
operator|->
name|flags
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|busy
operator|||
operator|(
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
name|m
operator|->
name|queue
operator|==
name|PQ_FREE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"vm_page_free: pindex(%ld), busy(%d), PG_BUSY(%d)\n"
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|m
operator|->
name|busy
argument_list|,
operator|(
name|flags
operator|&
name|PG_BUSY
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_FREE
condition|)
name|panic
argument_list|(
literal|"vm_page_free: freeing free page"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"vm_page_free: freeing busy page"
argument_list|)
expr_stmt|;
block|}
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	if ((flags& PG_WANTED) != 0) 		wakeup(m); */
if|if
condition|(
operator|(
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|wire_count
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|wire_count
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"vm_page_free: wire count> 1 (%d)"
argument_list|,
name|m
operator|->
name|wire_count
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"vm_page_free: invalid wire count"
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|.
name|v_wire_count
operator|--
expr_stmt|;
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|queue
operator|=
name|PQ_FREE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * if pageout daemon needs pages, then tell it that there are 		 * some free. 		 */
if|if
condition|(
name|vm_pageout_pages_needed
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|vm_pageout_pages_needed
argument_list|)
expr_stmt|;
name|vm_pageout_pages_needed
operator|=
literal|0
expr_stmt|;
block|}
name|cnt
operator|.
name|v_free_count
operator|++
expr_stmt|;
comment|/* 		 * wakeup processes that are waiting on memory if we hit a 		 * high water mark. And wakeup scheduler process if we have 		 * lots of memory. this process will swapin processes. 		 */
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|==
name|cnt
operator|.
name|v_free_min
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|.
name|v_tfree
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_wire:  *  *	Mark this page as wired down by yet  *	another map, removing it from paging queues  *	as necessary.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_wire
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_unwire:  *  *	Release one wiring of this page, potentially  *	enabling it to be paged again.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_unwire
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|>
literal|0
condition|)
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|cnt
operator|.
name|v_wire_count
operator|--
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_ACTIVE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|act_count
operator|<
name|ACT_MAX
condition|)
name|m
operator|->
name|act_count
operator|+=
literal|1
expr_stmt|;
name|cnt
operator|.
name|v_active_count
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_activate:  *  *	Put the specified page on the active list (if appropriate).  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_activate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_ACTIVE
condition|)
name|panic
argument_list|(
literal|"vm_page_activate: already active"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_CACHE
condition|)
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_ACTIVE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|act_count
operator|<
literal|5
condition|)
name|m
operator|->
name|act_count
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|act_count
operator|<
name|ACT_MAX
condition|)
name|m
operator|->
name|act_count
operator|+=
literal|1
expr_stmt|;
name|cnt
operator|.
name|v_active_count
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_deactivate:  *  *	Returns the given page to the inactive list,  *	indicating that no physical maps have access  *	to this page.  [Used by the physical mapping system.]  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_deactivate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
comment|/* 	 * Only move active pages -- ignore locked or already inactive ones. 	 * 	 * XXX: sometimes we get pages which aren't wired down or on any queue - 	 * we need to put them on the inactive queue also, otherwise we lose 	 * track of them. Paul Mackerras (paulus@cs.anu.edu.au) 9-Jan-93. 	 */
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_INACTIVE
condition|)
return|return;
name|spl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
operator|&&
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_CACHE
condition|)
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_INACTIVE
expr_stmt|;
name|cnt
operator|.
name|v_inactive_count
operator|++
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vm_page_cache  *  * Put the specified page onto the page cache queue (if appropriate).  */
end_comment

begin_function
name|void
name|vm_page_cache
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
name|m
operator|->
name|busy
operator|||
name|m
operator|->
name|wire_count
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_CACHE
condition|)
return|return;
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_cache
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_CACHE
expr_stmt|;
name|cnt
operator|.
name|v_cache_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|==
name|cnt
operator|.
name|v_free_min
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vm_pageout_pages_needed
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|vm_pageout_pages_needed
argument_list|)
expr_stmt|;
name|vm_pageout_pages_needed
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_zero_fill:  *  *	Zero-fill the specified page.  *	Written as a standard pagein routine, to  *	be used by the zero-fill object.  */
end_comment

begin_function
name|boolean_t
name|vm_page_zero_fill
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_copy:  *  *	Copy one page to another  */
end_comment

begin_function
name|void
name|vm_page_copy
parameter_list|(
name|src_m
parameter_list|,
name|dest_m
parameter_list|)
name|vm_page_t
name|src_m
decl_stmt|;
name|vm_page_t
name|dest_m
decl_stmt|;
block|{
name|pmap_copy_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src_m
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dest_m
argument_list|)
argument_list|)
expr_stmt|;
name|dest_m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mapping function for valid bits or for dirty bits in  * a page  */
end_comment

begin_function
specifier|inline
name|int
name|vm_page_bits
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|u_short
name|chunk
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|==
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>=
name|PAGE_SIZE
operator|)
condition|)
return|return
name|VM_PAGE_BITS_ALL
return|;
name|size
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|base
operator|=
operator|(
name|base
operator|%
name|PAGE_SIZE
operator|)
operator|/
name|DEV_BSIZE
expr_stmt|;
name|chunk
operator|=
name|vm_page_dev_bsize_chunks
index|[
name|size
operator|/
name|DEV_BSIZE
index|]
expr_stmt|;
return|return
operator|(
name|chunk
operator|<<
name|base
operator|)
operator|&
name|VM_PAGE_BITS_ALL
return|;
block|}
end_function

begin_comment
comment|/*  * set a page valid and clean  */
end_comment

begin_function
name|void
name|vm_page_set_validclean
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|pagebits
init|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|m
operator|->
name|valid
operator||=
name|pagebits
expr_stmt|;
name|m
operator|->
name|dirty
operator|&=
operator|~
name|pagebits
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
operator|&&
name|size
operator|==
name|PAGE_SIZE
condition|)
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set a page (partially) invalid  */
end_comment

begin_function
name|void
name|vm_page_set_invalid
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|bits
decl_stmt|;
name|m
operator|->
name|valid
operator|&=
operator|~
operator|(
name|bits
operator|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
literal|0
condition|)
name|m
operator|->
name|dirty
operator|&=
operator|~
name|bits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * is (partial) page valid?  */
end_comment

begin_function
name|int
name|vm_page_is_valid
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|bits
init|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|&&
operator|(
operator|(
name|m
operator|->
name|valid
operator|&
name|bits
operator|)
operator|==
name|bits
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|vm_page_test_dirty
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|dirty
operator|!=
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
name|pmap_is_modified
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
name|void
name|DDB_print_page_info
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"cnt.v_free_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_cache_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_inactive_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_inactive_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_active_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_active_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_wire_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_wire_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_free_reserved: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_reserved
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_free_min: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_free_target: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_cache_min: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cnt.v_inactive_target: %d\n"
argument_list|,
name|cnt
operator|.
name|v_inactive_target
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

