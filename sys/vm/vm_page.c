begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_page.c	7.4 (Berkeley) 5/7/91  *	$Id: vm_page.c,v 1.9 1994/01/17 09:33:52 davidg Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Resident memory management module.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"vm_map.h"
end_include

begin_include
include|#
directive|include
file|"vm_page.h"
end_include

begin_include
include|#
directive|include
file|"vm_pageout.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_comment
comment|/*  *	Associated with page of user-allocatable memory is a  *	page structure.  */
end_comment

begin_decl_stmt
name|queue_head_t
modifier|*
name|vm_page_buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of buckets */
end_comment

begin_decl_stmt
name|int
name|vm_page_bucket_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is array? */
end_comment

begin_decl_stmt
name|int
name|vm_page_hash_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask for hash function */
end_comment

begin_decl_stmt
name|simple_lock_data_t
name|bucket_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock for all buckets XXX */
end_comment

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|simple_lock_data_t
name|vm_page_queue_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|simple_lock_data_t
name|vm_page_queue_free_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_page_t
name|vm_page_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|first_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|last_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|first_phys_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|last_phys_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_active_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_inactive_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_wire_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_laundry_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vm_pageout_pages_needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_target
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_min
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_inactive_target
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_reserved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	vm_page_startup:  *  *	Initializes the resident memory module.  *  *	Allocates memory for the page cells, and  *	for the object/offset-to-page hash table headers.  *	Each page cell is initialized and placed on the free list.  */
end_comment

begin_function
name|vm_offset_t
name|vm_page_startup
parameter_list|(
name|starta
parameter_list|,
name|enda
parameter_list|,
name|vaddr
parameter_list|)
specifier|register
name|vm_offset_t
name|starta
decl_stmt|;
name|vm_offset_t
name|enda
decl_stmt|;
specifier|register
name|vm_offset_t
name|vaddr
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|mapped
decl_stmt|;
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|vm_size_t
name|npages
decl_stmt|,
name|page_range
decl_stmt|;
specifier|register
name|vm_offset_t
name|new_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|vm_offset_t
name|first_managed_page
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|extern
name|vm_offset_t
name|kentry_data
decl_stmt|;
specifier|extern
name|vm_size_t
name|kentry_data_size
decl_stmt|;
specifier|extern
name|vm_offset_t
name|phys_avail
index|[]
decl_stmt|;
comment|/* the biggest memory array is the second group of pages */
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|biggestone
decl_stmt|,
name|biggestsize
decl_stmt|;
name|vm_offset_t
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|biggestsize
operator|=
literal|0
expr_stmt|;
name|biggestone
operator|=
literal|0
expr_stmt|;
name|nblocks
operator|=
literal|0
expr_stmt|;
name|vaddr
operator|=
name|round_page
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|round_page
argument_list|(
name|phys_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|trunc_page
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|size
init|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|biggestsize
condition|)
block|{
name|biggestone
operator|=
name|i
expr_stmt|;
name|biggestsize
operator|=
name|size
expr_stmt|;
block|}
operator|++
name|nblocks
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|start
operator|=
name|phys_avail
index|[
name|biggestone
index|]
expr_stmt|;
comment|/* 	 *	Initialize the locks 	 */
name|simple_lock_init
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|vm_page_queue_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	Initialize the queue headers for the free queue, 	 *	the active queue and the inactive queue. 	 */
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
expr_stmt|;
comment|/* 	 *	Allocate (and initialize) the hash table buckets. 	 * 	 *	The number of buckets MUST BE a power of 2, and 	 *	the actual value is the next power of 2 greater 	 *	than the number of physical pages in the system. 	 * 	 *	Note: 	 *		This computation can be tweaked if desired. 	 */
name|vm_page_buckets
operator|=
operator|(
name|queue_t
operator|)
name|vaddr
expr_stmt|;
name|bucket
operator|=
name|vm_page_buckets
expr_stmt|;
if|if
condition|(
name|vm_page_bucket_count
operator|==
literal|0
condition|)
block|{
name|vm_page_bucket_count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|vm_page_bucket_count
operator|<
name|atop
argument_list|(
name|total
argument_list|)
condition|)
name|vm_page_bucket_count
operator|<<=
literal|1
expr_stmt|;
block|}
name|vm_page_hash_mask
operator|=
name|vm_page_bucket_count
operator|-
literal|1
expr_stmt|;
comment|/* 	 *	Validate these addresses. 	 */
name|new_start
operator|=
name|start
operator|+
name|vm_page_bucket_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|queue_entry
argument_list|)
expr_stmt|;
name|new_start
operator|=
name|round_page
argument_list|(
name|new_start
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
name|vaddr
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
name|vaddr
operator|-
name|mapped
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_bucket_count
condition|;
name|i
operator|++
control|)
block|{
name|queue_init
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
block|}
name|simple_lock_init
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	round (or truncate) the addresses to our page size. 	 */
comment|/* 	 *	Pre-allocate maps and map entries that cannot be dynamically 	 *	allocated via malloc().  The maps include the kernel_map and 	 *	kmem_map which must be initialized before malloc() will 	 *	work (obviously).  Also could include pager maps which would 	 *	be allocated before kmeminit. 	 * 	 *	Allow some kernel map entries... this should be plenty 	 *	since people shouldn't be cluttering up the kernel 	 *	map (they should use their own maps). 	 */
name|kentry_data_size
operator|=
name|MAX_KMAP
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
operator|+
name|MAX_KMAPENT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
expr_stmt|;
name|kentry_data_size
operator|=
name|round_page
argument_list|(
name|kentry_data_size
argument_list|)
expr_stmt|;
name|kentry_data
operator|=
operator|(
name|vm_offset_t
operator|)
name|vaddr
expr_stmt|;
name|vaddr
operator|+=
name|kentry_data_size
expr_stmt|;
comment|/* 	 *	Validate these zone addresses. 	 */
name|new_start
operator|=
name|start
operator|+
operator|(
name|vaddr
operator|-
name|mapped
operator|)
expr_stmt|;
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
operator|(
name|vaddr
operator|-
name|mapped
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|round_page
argument_list|(
name|new_start
argument_list|)
expr_stmt|;
comment|/*  	 *	Compute the number of pages of memory that will be 	 *	available for use (taking into account the overhead 	 *	of a page structure per page). 	 */
name|npages
operator|=
operator|(
name|total
operator|-
operator|(
name|start
operator|-
name|phys_avail
index|[
name|biggestone
index|]
operator|)
operator|)
operator|/
operator|(
name|PAGE_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|)
expr_stmt|;
name|first_page
operator|=
name|phys_avail
index|[
literal|0
index|]
operator|/
name|PAGE_SIZE
expr_stmt|;
name|page_range
operator|=
operator|(
name|phys_avail
index|[
operator|(
name|nblocks
operator|-
literal|1
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 *	Initialize the mem entry structures now, and 	 *	put them in the free queue. 	 */
name|vm_page_array
operator|=
operator|(
name|vm_page_t
operator|)
name|vaddr
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
comment|/* 	 *	Validate these addresses. 	 */
name|new_start
operator|=
name|round_page
argument_list|(
name|start
operator|+
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|first_managed_page
operator|=
name|start
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 *	Clear all of the page structures 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vm_page_array
argument_list|,
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_count
operator|=
literal|0
expr_stmt|;
name|vm_page_free_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|>
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|==
name|biggestone
condition|)
name|pa
operator|=
name|ptoa
argument_list|(
name|first_managed_page
argument_list|)
expr_stmt|;
else|else
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pa
operator|<
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|--
operator|>
literal|0
condition|)
block|{
operator|++
name|vm_page_count
expr_stmt|;
operator|++
name|vm_page_free_count
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|object
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
comment|/* 	 *	Initialize vm_pages_needed lock here - don't wait for pageout 	 *	daemon	XXX 	 */
name|simple_lock_init
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_hash:  *  *	Distributes the object/offset key pair among hash buckets.  *  *	NOTE:  This macro depends on vm_page_bucket_count being a power of 2.  */
end_comment

begin_function
specifier|inline
specifier|const
name|int
name|vm_page_hash
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|object
operator|+
name|offset
operator|/
name|NBPG
operator|)
operator|&
name|vm_page_hash_mask
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_insert:		[ internal use only ]  *  *	Inserts the given mem entry into the object/object-page  *	table and object list.  *  *	The object and page must be locked.  * interrupts must be disable in this routine!!!  */
end_comment

begin_function
name|void
name|vm_page_insert
parameter_list|(
name|mem
parameter_list|,
name|object
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_TABLED
condition|)
name|panic
argument_list|(
literal|"vm_page_insert: already inserted"
argument_list|)
expr_stmt|;
comment|/* 	 *	Record the object/offset pair in this page 	 */
name|mem
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|mem
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* 	 *	Insert it into the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
index|]
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
name|bucket
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	Now link into the object's list of backed pages. 	 */
name|queue_enter
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator||=
name|PG_TABLED
expr_stmt|;
comment|/* 	 *	And show that the object has one more resident 	 *	page. 	 */
name|object
operator|->
name|resident_page_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_remove:		[ internal use only ]  *  *	Removes the given mem entry from the object/offset-page  *	table and the object page list.  *  *	The object and page must be locked.  *  * interrupts must be disable in this routine!!!  */
end_comment

begin_function
name|void
name|vm_page_remove
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_TABLED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"page not tabled?????\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *	Remove from the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|mem
operator|->
name|object
argument_list|,
name|mem
operator|->
name|offset
argument_list|)
index|]
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
name|bucket
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	Now remove from the object's list of backed pages. 	 */
name|queue_remove
argument_list|(
operator|&
name|mem
operator|->
name|object
operator|->
name|memq
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 	 *	And show that the object has one fewer resident 	 *	page. 	 */
name|mem
operator|->
name|object
operator|->
name|resident_page_count
operator|--
expr_stmt|;
name|mem
operator|->
name|object
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_TABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_lookup:  *  *	Returns the page associated with the object/offset  *	pair specified; if none is found, NULL is returned.  *  *	The object must be locked.  No side effects.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_lookup
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
comment|/* 	 *	Search the hash table for this object/offset pair 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
index|]
expr_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
name|bucket
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|mem
argument_list|)
condition|)
block|{
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|->
name|object
operator|==
name|object
operator|)
operator|&&
operator|(
name|mem
operator|->
name|offset
operator|==
name|offset
operator|)
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
name|mem
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|mem
operator|->
name|hashq
argument_list|)
expr_stmt|;
block|}
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_rename:  *  *	Move the given memory entry from its  *	current object to the specified target object/offset.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_page_rename
parameter_list|(
name|mem
parameter_list|,
name|new_object
parameter_list|,
name|new_offset
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|vm_object_t
name|new_object
decl_stmt|;
name|vm_offset_t
name|new_offset
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
if|if
condition|(
name|mem
operator|->
name|object
operator|==
name|new_object
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* keep page from moving out from 				   under pageout daemon */
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
name|vm_page_remove
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|mem
argument_list|,
name|new_object
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_alloc:  *  *	Allocate and return a memory cell associated  *	with this VM object/offset pair.  *  *	Object must be locked.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_alloc
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|kernel_object
operator|&&
name|object
operator|!=
name|kmem_object
operator|&&
name|curproc
operator|!=
name|pageproc
operator|&&
name|curproc
operator|!=
operator|&
name|proc0
operator|&&
name|vm_page_free_count
operator|<
name|vm_page_free_reserved
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/* 		 * this wakeup seems unnecessary, but there is code that 		 * might just check to see if there are free pages, and 		 * punt if there aren't.  VM_WAIT does this too, but 		 * redundant wakeups aren't that bad... 		 */
if|if
condition|(
name|curproc
operator|!=
name|pageproc
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/* 		 * comment above re: wakeups applies here too... 		 */
if|if
condition|(
name|curproc
operator|!=
name|pageproc
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|queue_remove_first
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_free_count
operator|--
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|=
name|PG_BUSY
operator||
name|PG_CLEAN
operator||
name|PG_FAKE
expr_stmt|;
name|vm_page_insert
argument_list|(
name|mem
argument_list|,
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mem
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|deact
operator|=
literal|0
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/*  * don't wakeup too often, so we wakeup the pageout daemon when  * we would be nearly out of memory.  */
if|if
condition|(
name|curproc
operator|!=
name|pageproc
operator|&&
operator|(
name|vm_page_free_count
operator|<
name|vm_page_free_reserved
operator|)
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_free:  *  *	Returns the given page to the free list,  *	disassociating it with any VM object.  *  *	Object and page must be locked prior to entry.  */
end_comment

begin_function
name|void
name|vm_page_free
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
name|vm_page_remove
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|->
name|deact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_ACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_ACTIVE
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_INACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_INACTIVE
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mem
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
condition|)
block|{
name|vm_page_wire_count
operator|--
expr_stmt|;
name|mem
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
block|}
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_free_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/* 		 * if pageout daemon needs pages, then tell it that there 		 * are some free. 		 */
if|if
condition|(
name|vm_pageout_pages_needed
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_pageout_pages_needed
argument_list|)
expr_stmt|;
comment|/* 		 * wakeup processes that are waiting on memory if we 		 * hit a high water mark. 		 */
if|if
condition|(
name|vm_page_free_count
operator|==
name|vm_page_free_min
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vm_page_free_count
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * wakeup scheduler process if we have lots of memory. 		 * this process will swapin processes. 		 */
if|if
condition|(
name|vm_page_free_count
operator|==
name|vm_page_free_target
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_wire:  *  *	Mark this page as wired down by yet  *	another map, removing it from paging queues  *	as necessary.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_wire
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_ACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|flags
operator|&
name|PG_INACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
name|mem
operator|->
name|flags
operator|&=
operator|~
name|PG_INACTIVE
expr_stmt|;
block|}
name|vm_page_wire_count
operator|++
expr_stmt|;
block|}
name|mem
operator|->
name|wire_count
operator|++
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_unwire:  *  *	Release one wiring of this page, potentially  *	enabling it to be paged again.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_unwire
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
operator|!=
literal|0
condition|)
name|mem
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_active_count
operator|++
expr_stmt|;
name|mem
operator|->
name|flags
operator||=
name|PG_ACTIVE
expr_stmt|;
name|vm_page_wire_count
operator|--
expr_stmt|;
name|vm_pageout_deact_bump
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_deactivate:  *  *	Returns the given page to the inactive list,  *	indicating that no physical maps have access  *	to this page.  [Used by the physical mapping system.]  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_deactivate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 *	Only move active pages -- ignore locked or already 	 *	inactive ones. 	 * 	 *	XXX: sometimes we get pages which aren't wired down 	 *	or on any queue - we need to put them on the inactive 	 *	queue also, otherwise we lose track of them. 	 *	Paul Mackerras (paulus@cs.anu.edu.au) 9-Jan-93. 	 */
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
name|m
operator|->
name|deact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_INACTIVE
operator|)
operator|&&
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_ACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_ACTIVE
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
block|}
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_INACTIVE
expr_stmt|;
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|vm_page_inactive_count
operator|++
expr_stmt|;
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|flags
operator||=
name|PG_LAUNDRY
expr_stmt|;
block|}
else|else
block|{
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_makefault  *  *	Cause next access of this page to fault  */
end_comment

begin_function
name|void
name|vm_page_makefault
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|flags
operator||=
name|PG_LAUNDRY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_activate:  *  *	Put the specified page on the active list (if appropriate).  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_activate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_pageout_deact_bump
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|spl
operator|=
name|vm_disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_INACTIVE
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_INACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_ACTIVE
condition|)
name|panic
argument_list|(
literal|"vm_page_activate: already active"
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_ACTIVE
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
operator|&
name|m
operator|->
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|m
operator|->
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|vm_page_active_count
operator|++
expr_stmt|;
block|}
name|vm_set_intr
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_zero_fill:  *  *	Zero-fill the specified page.  *	Written as a standard pagein routine, to  *	be used by the zero-fill object.  */
end_comment

begin_function
name|boolean_t
name|vm_page_zero_fill
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_copy:  *  *	Copy one page to another  */
end_comment

begin_function
name|void
name|vm_page_copy
parameter_list|(
name|src_m
parameter_list|,
name|dest_m
parameter_list|)
name|vm_page_t
name|src_m
decl_stmt|;
name|vm_page_t
name|dest_m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|src_m
argument_list|)
expr_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|dest_m
argument_list|)
expr_stmt|;
name|pmap_copy_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src_m
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dest_m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

