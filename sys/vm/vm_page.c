begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)vm_page.c	7.4 (Berkeley) 5/7/91  *	$Id: vm_page.c,v 1.103 1998/07/11 07:46:14 bde Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Resident memory management module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|vm_page_queue_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|vm_page_select_free
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|,
name|vm_pindex_t
name|pindex
operator|,
name|int
name|prefqueue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_page_t
name|vm_page_select_cache
name|__P
argument_list|(
operator|(
name|vm_object_t
operator|,
name|vm_pindex_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Associated with page of user-allocatable memory is a  *	page structure.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pglist
modifier|*
name|vm_page_buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of buckets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vm_page_bucket_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is array? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vm_page_hash_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask for hash function */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|vm_page_bucket_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_free
index|[
name|PQ_L2_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_zero
index|[
name|PQ_L2_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_active
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_inactive
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pglist
name|vm_page_queue_cache
index|[
name|PQ_L2_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_queue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vpgqueues
name|vm_page_queues
index|[
name|PQ_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pqcnt
index|[
name|PQ_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vm_page_queue_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_queues
index|[
name|PQ_NONE
index|]
operator|.
name|pl
operator|=
name|NULL
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_NONE
index|]
operator|.
name|cnt
operator|=
operator|&
name|no_queue
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_queues
index|[
name|PQ_FREE
operator|+
name|i
index|]
operator|.
name|pl
operator|=
operator|&
name|vm_page_queue_free
index|[
name|i
index|]
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_FREE
operator|+
name|i
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_free_count
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_queues
index|[
name|PQ_ZERO
operator|+
name|i
index|]
operator|.
name|pl
operator|=
operator|&
name|vm_page_queue_zero
index|[
name|i
index|]
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_ZERO
operator|+
name|i
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_free_count
expr_stmt|;
block|}
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
operator|.
name|pl
operator|=
operator|&
name|vm_page_queue_inactive
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_inactive_count
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|pl
operator|=
operator|&
name|vm_page_queue_active
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_active_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_queues
index|[
name|PQ_CACHE
operator|+
name|i
index|]
operator|.
name|pl
operator|=
operator|&
name|vm_page_queue_cache
index|[
name|i
index|]
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_CACHE
operator|+
name|i
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_cache_count
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vm_page_queues
index|[
name|i
index|]
operator|.
name|pl
condition|)
block|{
name|TAILQ_INIT
argument_list|(
name|vm_page_queues
index|[
name|i
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vm_page_queue_init: queue %d is null"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|vm_page_queues
index|[
name|i
index|]
operator|.
name|lcnt
operator|=
operator|&
name|pqcnt
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|vm_page_t
name|vm_page_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vm_page_array_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|first_page
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|last_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_size_t
name|page_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|page_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_zero_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * map of contiguous valid DEV_BSIZE chunks in a page  * (this list is valid for page sizes upto 16*DEV_BSIZE)  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|vm_page_dev_bsize_chunks
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x1
block|,
literal|0x3
block|,
literal|0x7
block|,
literal|0xf
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0x1ff
block|,
literal|0x3ff
block|,
literal|0x7ff
block|,
literal|0xfff
block|,
literal|0x1fff
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|vm_page_hash
name|__P
argument_list|(
operator|(
name|vm_object_t
name|object
operator|,
name|vm_pindex_t
name|pindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vm_page_freechk_and_unqueue
name|__P
argument_list|(
operator|(
name|vm_page_t
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vm_page_free_wakeup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	vm_set_page_size:  *  *	Sets the page size, perhaps based upon the memory  *	size.  Must be called before any use of page-size  *	dependent functions.  *  *	Sets page_shift and page_mask from cnt.v_page_size.  */
end_comment

begin_function
name|void
name|vm_set_page_size
parameter_list|()
block|{
if|if
condition|(
name|cnt
operator|.
name|v_page_size
operator|==
literal|0
condition|)
name|cnt
operator|.
name|v_page_size
operator|=
name|DEFAULT_PAGE_SIZE
expr_stmt|;
name|page_mask
operator|=
name|cnt
operator|.
name|v_page_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|page_mask
operator|&
name|cnt
operator|.
name|v_page_size
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vm_set_page_size: page size not a power of two"
argument_list|)
expr_stmt|;
for|for
control|(
name|page_shift
operator|=
literal|0
init|;
condition|;
name|page_shift
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|page_shift
operator|)
operator|==
name|cnt
operator|.
name|v_page_size
condition|)
break|break;
block|}
end_function

begin_comment
comment|/*  *	vm_page_startup:  *  *	Initializes the resident memory module.  *  *	Allocates memory for the page cells, and  *	for the object/offset-to-page hash table headers.  *	Each page cell is initialized and placed on the free list.  */
end_comment

begin_function
name|vm_offset_t
name|vm_page_startup
parameter_list|(
name|starta
parameter_list|,
name|enda
parameter_list|,
name|vaddr
parameter_list|)
specifier|register
name|vm_offset_t
name|starta
decl_stmt|;
name|vm_offset_t
name|enda
decl_stmt|;
specifier|register
name|vm_offset_t
name|vaddr
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|mapped
decl_stmt|;
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
name|vm_size_t
name|npages
decl_stmt|,
name|page_range
decl_stmt|;
specifier|register
name|vm_offset_t
name|new_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|vm_offset_t
name|first_managed_page
decl_stmt|;
comment|/* the biggest memory array is the second group of pages */
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|biggestone
decl_stmt|,
name|biggestsize
decl_stmt|;
name|vm_offset_t
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|biggestsize
operator|=
literal|0
expr_stmt|;
name|biggestone
operator|=
literal|0
expr_stmt|;
name|nblocks
operator|=
literal|0
expr_stmt|;
name|vaddr
operator|=
name|round_page
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|round_page
argument_list|(
name|phys_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|trunc_page
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|size
init|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|biggestsize
condition|)
block|{
name|biggestone
operator|=
name|i
expr_stmt|;
name|biggestsize
operator|=
name|size
expr_stmt|;
block|}
operator|++
name|nblocks
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|start
operator|=
name|phys_avail
index|[
name|biggestone
index|]
expr_stmt|;
comment|/* 	 * Initialize the queue headers for the free queue, the active queue 	 * and the inactive queue. 	 */
name|vm_page_queue_init
argument_list|()
expr_stmt|;
comment|/* 	 * Allocate (and initialize) the hash table buckets. 	 * 	 * The number of buckets MUST BE a power of 2, and the actual value is 	 * the next power of 2 greater than the number of physical pages in 	 * the system. 	 * 	 * Note: This computation can be tweaked if desired. 	 */
name|vm_page_buckets
operator|=
operator|(
expr|struct
name|pglist
operator|*
operator|)
name|vaddr
expr_stmt|;
name|bucket
operator|=
name|vm_page_buckets
expr_stmt|;
if|if
condition|(
name|vm_page_bucket_count
operator|==
literal|0
condition|)
block|{
name|vm_page_bucket_count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|vm_page_bucket_count
operator|<
name|atop
argument_list|(
name|total
argument_list|)
condition|)
name|vm_page_bucket_count
operator|<<=
literal|1
expr_stmt|;
block|}
name|vm_page_hash_mask
operator|=
name|vm_page_bucket_count
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Validate these addresses. 	 */
name|new_start
operator|=
name|start
operator|+
name|vm_page_bucket_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pglist
argument_list|)
expr_stmt|;
name|new_start
operator|=
name|round_page
argument_list|(
name|new_start
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|round_page
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|vaddr
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|vaddr
operator|=
name|round_page
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
name|vaddr
operator|-
name|mapped
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_bucket_count
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compute the number of pages of memory that will be available for 	 * use (taking into account the overhead of a page structure per 	 * page). 	 */
name|first_page
operator|=
name|phys_avail
index|[
literal|0
index|]
operator|/
name|PAGE_SIZE
expr_stmt|;
name|last_page
operator|=
name|phys_avail
index|[
operator|(
name|nblocks
operator|-
literal|1
operator|)
operator|*
literal|2
operator|+
literal|1
index|]
operator|/
name|PAGE_SIZE
expr_stmt|;
name|page_range
operator|=
name|last_page
operator|-
operator|(
name|phys_avail
index|[
literal|0
index|]
operator|/
name|PAGE_SIZE
operator|)
expr_stmt|;
name|npages
operator|=
operator|(
name|total
operator|-
operator|(
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|)
operator|-
operator|(
name|start
operator|-
name|phys_avail
index|[
name|biggestone
index|]
operator|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Initialize the mem entry structures now, and put them in the free 	 * queue. 	 */
name|vm_page_array
operator|=
operator|(
name|vm_page_t
operator|)
name|vaddr
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
comment|/* 	 * Validate these addresses. 	 */
name|new_start
operator|=
name|round_page
argument_list|(
name|start
operator|+
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|first_managed_page
operator|=
name|start
operator|/
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Clear all of the page structures 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vm_page_array
argument_list|,
name|page_range
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_array_size
operator|=
name|page_range
expr_stmt|;
name|cnt
operator|.
name|v_page_count
operator|=
literal|0
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|>
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|==
name|biggestone
condition|)
name|pa
operator|=
name|ptoa
argument_list|(
name|first_managed_page
argument_list|)
expr_stmt|;
else|else
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pa
operator|<
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|npages
operator|--
operator|>
literal|0
condition|)
block|{
operator|++
name|cnt
operator|.
name|v_page_count
expr_stmt|;
operator|++
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|pc
operator|=
operator|(
name|pa
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
name|PQ_L2_MASK
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|m
operator|->
name|pc
operator|+
name|PQ_FREE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|*
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|lcnt
operator|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mapped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_hash:  *  *	Distributes the object/offset key pair among hash buckets.  *  *	NOTE:  This macro depends on vm_page_bucket_count being a power of 2.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|vm_page_hash
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|object
operator|)
operator|>>
literal|5
operator|)
operator|+
operator|(
name|pindex
operator|>>
literal|1
operator|)
operator|)
operator|&
name|vm_page_hash_mask
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_insert:		[ internal use only ]  *  *	Inserts the given mem entry into the object/object-page  *	table and object list.  *  *	The object and page must be locked, and must be splhigh.  */
end_comment

begin_function
name|void
name|vm_page_insert
parameter_list|(
name|m
parameter_list|,
name|object
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_TABLED
condition|)
name|panic
argument_list|(
literal|"vm_page_insert: already inserted"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Record the object/offset pair in this page 	 */
name|m
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|m
operator|->
name|pindex
operator|=
name|pindex
expr_stmt|;
comment|/* 	 * Insert it into the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bucket
argument_list|,
name|m
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|vm_page_bucket_generation
operator|++
expr_stmt|;
comment|/* 	 * Now link into the object's list of backed pages. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_TABLED
expr_stmt|;
name|m
operator|->
name|object
operator|->
name|page_hint
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|object
operator|->
name|generation
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
condition|)
name|object
operator|->
name|wire_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|object
operator|->
name|cache_count
operator|++
expr_stmt|;
comment|/* 	 * And show that the object has one more resident page. 	 */
name|object
operator|->
name|resident_page_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_remove:		[ internal use only ]  *				NOTE: used by device pager as well -wfj  *  *	Removes the given mem entry from the object/offset-page  *	table and the object page list.  *  *	The object and page must be locked, and at splhigh.  */
end_comment

begin_function
name|void
name|vm_page_remove
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_TABLED
operator|)
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vm_page_remove: page not busy"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|page_hint
operator|==
name|m
condition|)
name|object
operator|->
name|page_hint
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
condition|)
name|object
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|object
operator|->
name|cache_count
operator|--
expr_stmt|;
comment|/* 	 * Remove from the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|bucket
argument_list|,
name|m
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|vm_page_bucket_generation
operator|++
expr_stmt|;
comment|/* 	 * Now remove from the object's list of backed pages. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 	 * And show that the object has one fewer resident page. 	 */
name|object
operator|->
name|resident_page_count
operator|--
expr_stmt|;
name|object
operator|->
name|generation
operator|++
expr_stmt|;
name|m
operator|->
name|object
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_TABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_lookup:  *  *	Returns the page associated with the object/offset  *	pair specified; if none is found, NULL is returned.  *  *	The object must be locked.  No side effects.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_lookup
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|struct
name|pglist
modifier|*
name|bucket
decl_stmt|;
name|int
name|generation
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Search the hash table for this object/offset pair 	 */
if|if
condition|(
name|object
operator|->
name|page_hint
operator|&&
operator|(
name|object
operator|->
name|page_hint
operator|->
name|pindex
operator|==
name|pindex
operator|)
operator|&&
operator|(
name|object
operator|->
name|page_hint
operator|->
name|object
operator|==
name|object
operator|)
condition|)
return|return
name|object
operator|->
name|page_hint
return|;
name|retry
label|:
name|generation
operator|=
name|vm_page_bucket_generation
expr_stmt|;
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|bucket
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|hashq
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|object
operator|==
name|object
operator|)
operator|&&
operator|(
name|m
operator|->
name|pindex
operator|==
name|pindex
operator|)
condition|)
block|{
if|if
condition|(
name|vm_page_bucket_generation
operator|!=
name|generation
condition|)
goto|goto
name|retry
goto|;
name|m
operator|->
name|object
operator|->
name|page_hint
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vm_page_bucket_generation
operator|!=
name|generation
condition|)
goto|goto
name|retry
goto|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_rename:  *  *	Move the given memory entry from its  *	current object to the specified target object/offset.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_page_rename
parameter_list|(
name|m
parameter_list|,
name|new_object
parameter_list|,
name|new_pindex
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|vm_object_t
name|new_object
decl_stmt|;
name|vm_pindex_t
name|new_pindex
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|new_object
argument_list|,
name|new_pindex
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vm_page_unqueue without any wakeup  */
end_comment

begin_function
name|void
name|vm_page_unqueue_nowakeup
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|queue
init|=
name|m
operator|->
name|queue
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|lcnt
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|object
condition|)
name|m
operator|->
name|object
operator|->
name|cache_count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * vm_page_unqueue must be called at splhigh();  */
end_comment

begin_function
name|void
name|vm_page_unqueue
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|queue
init|=
name|m
operator|->
name|queue
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|lcnt
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_cache_count
operator|+
name|cnt
operator|.
name|v_free_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_reserved
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|object
condition|)
name|m
operator|->
name|object
operator|->
name|cache_count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find a page on the specified queue with color optimization.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_list_find
parameter_list|(
name|basequeue
parameter_list|,
name|index
parameter_list|)
name|int
name|basequeue
decl_stmt|,
name|index
decl_stmt|;
block|{
if|#
directive|if
name|PQ_L2_SIZE
operator|>
literal|1
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|hindex
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|basequeue
index|]
expr_stmt|;
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|index
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
return|return
name|m
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PQ_L1_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|int
name|ij
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|PQ_L2_SIZE
operator|/
literal|2
operator|)
operator|-
name|PQ_L1_SIZE
init|;
operator|(
name|ij
operator|=
name|i
operator|+
name|j
operator|)
operator|>
literal|0
condition|;
name|i
operator|-=
name|PQ_L1_SIZE
control|)
block|{
name|hindex
operator|=
name|index
operator|+
name|ij
expr_stmt|;
if|if
condition|(
name|hindex
operator|>=
name|PQ_L2_SIZE
condition|)
name|hindex
operator|-=
name|PQ_L2_SIZE
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
name|hindex
operator|=
name|index
operator|-
name|ij
expr_stmt|;
if|if
condition|(
name|hindex
operator|<
literal|0
condition|)
name|hindex
operator|+=
name|PQ_L2_SIZE
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
block|}
block|}
name|hindex
operator|=
name|index
operator|+
name|PQ_L2_SIZE
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|hindex
operator|>=
name|PQ_L2_SIZE
condition|)
name|hindex
operator|-=
name|PQ_L2_SIZE
expr_stmt|;
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
return|return
name|m
return|;
return|return
name|NULL
return|;
else|#
directive|else
return|return
name|TAILQ_FIRST
argument_list|(
name|vm_page_queues
index|[
name|basequeue
index|]
operator|.
name|pl
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Find a page on the specified queue with color optimization.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_select
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|basequeue
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|basequeue
decl_stmt|;
block|{
if|#
directive|if
name|PQ_L2_SIZE
operator|>
literal|1
name|int
name|index
decl_stmt|;
name|index
operator|=
operator|(
name|pindex
operator|+
name|object
operator|->
name|pg_color
operator|)
operator|&
name|PQ_L2_MASK
expr_stmt|;
return|return
name|vm_page_list_find
argument_list|(
name|basequeue
argument_list|,
name|index
argument_list|)
return|;
else|#
directive|else
return|return
name|TAILQ_FIRST
argument_list|(
name|vm_page_queues
index|[
name|basequeue
index|]
operator|.
name|pl
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Find a page on the cache queue with color optimization.  As pages  * might be found, but not applicable, they are deactivated.  This  * keeps us from using potentially busy cached pages.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_select_cache
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
block|{
name|vm_page_t
name|m
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|#
directive|if
name|PQ_L2_SIZE
operator|>
literal|1
name|int
name|index
decl_stmt|;
name|index
operator|=
operator|(
name|pindex
operator|+
name|object
operator|->
name|pg_color
operator|)
operator|&
name|PQ_L2_MASK
expr_stmt|;
name|m
operator|=
name|vm_page_list_find
argument_list|(
name|PQ_CACHE
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|vm_page_queues
index|[
name|PQ_CACHE
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
name|m
operator|->
name|busy
operator|||
name|m
operator|->
name|hold_count
operator|||
name|m
operator|->
name|wire_count
operator|)
condition|)
block|{
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
name|m
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find a free or zero page, with specified preference.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|vm_page_select_free
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|prefqueue
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|prefqueue
decl_stmt|;
block|{
if|#
directive|if
name|PQ_L2_SIZE
operator|>
literal|1
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|index
decl_stmt|,
name|hindex
decl_stmt|;
endif|#
directive|endif
name|vm_page_t
name|m
decl_stmt|,
name|mh
decl_stmt|;
name|int
name|oqueuediff
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|prefqueue
operator|==
name|PQ_ZERO
condition|)
name|oqueuediff
operator|=
name|PQ_FREE
operator|-
name|PQ_ZERO
expr_stmt|;
else|else
name|oqueuediff
operator|=
name|PQ_ZERO
operator|-
name|PQ_FREE
expr_stmt|;
if|if
condition|(
name|mh
operator|=
name|object
operator|->
name|page_hint
condition|)
block|{
if|if
condition|(
name|mh
operator|->
name|pindex
operator|==
operator|(
name|pindex
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mh
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mh
operator|<
operator|&
name|vm_page_array
index|[
name|cnt
operator|.
name|v_page_count
operator|-
literal|1
index|]
operator|)
operator|&&
operator|(
name|mh
operator|>=
operator|&
name|vm_page_array
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|int
name|queue
decl_stmt|;
name|m
operator|=
name|mh
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|==
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mh
argument_list|)
operator|+
name|PAGE_SIZE
operator|)
condition|)
block|{
name|queue
operator|=
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|PQ_FREE
operator|||
name|queue
operator|==
name|PQ_ZERO
condition|)
block|{
return|return
name|m
return|;
block|}
block|}
block|}
block|}
block|}
block|}
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|prefqueue
index|]
expr_stmt|;
if|#
directive|if
name|PQ_L2_SIZE
operator|>
literal|1
name|index
operator|=
operator|(
name|pindex
operator|+
name|object
operator|->
name|pg_color
operator|)
operator|&
name|PQ_L2_MASK
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|index
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|index
operator|+
name|oqueuediff
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PQ_L1_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|int
name|ij
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|PQ_L2_SIZE
operator|/
literal|2
operator|)
operator|-
name|PQ_L1_SIZE
init|;
operator|(
name|ij
operator|=
name|i
operator|+
name|j
operator|)
operator|>=
literal|0
condition|;
name|i
operator|-=
name|PQ_L1_SIZE
control|)
block|{
name|hindex
operator|=
name|index
operator|+
name|ij
expr_stmt|;
if|if
condition|(
name|hindex
operator|>=
name|PQ_L2_SIZE
condition|)
name|hindex
operator|-=
name|PQ_L2_SIZE
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
operator|+
name|oqueuediff
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
name|hindex
operator|=
name|index
operator|-
name|ij
expr_stmt|;
if|if
condition|(
name|hindex
operator|<
literal|0
condition|)
name|hindex
operator|+=
name|PQ_L2_SIZE
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
operator|+
name|oqueuediff
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
block|}
block|}
name|hindex
operator|=
name|index
operator|+
name|PQ_L2_SIZE
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|hindex
operator|>=
name|PQ_L2_SIZE
condition|)
name|hindex
operator|-=
name|PQ_L2_SIZE
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|hindex
operator|+
name|oqueuediff
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
else|#
directive|else
if|if
condition|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
literal|0
index|]
operator|.
name|pl
argument_list|)
condition|)
return|return
name|m
return|;
else|else
return|return
name|TAILQ_FIRST
argument_list|(
name|pq
index|[
name|oqueuediff
index|]
operator|.
name|pl
argument_list|)
return|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_alloc:  *  *	Allocate and return a memory cell associated  *	with this VM object/offset pair.  *  *	page_req classes:  *	VM_ALLOC_NORMAL		normal process request  *	VM_ALLOC_SYSTEM		system *really* needs a page  *	VM_ALLOC_INTERRUPT	interrupt time request  *	VM_ALLOC_ZERO		zero page  *  *	Object must be locked.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_alloc
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|page_req
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|page_req
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
name|vm_object_t
name|oldobject
decl_stmt|;
name|int
name|queue
decl_stmt|,
name|qtype
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc: page already allocated"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|curproc
operator|==
name|pageproc
operator|)
operator|&&
operator|(
name|page_req
operator|!=
name|VM_ALLOC_INTERRUPT
operator|)
condition|)
block|{
name|page_req
operator|=
name|VM_ALLOC_SYSTEM
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|page_req
condition|)
block|{
case|case
name|VM_ALLOC_NORMAL
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
name|m
operator|=
name|vm_page_select_free
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|PQ_FREE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc(NORMAL): missing page on free queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|m
operator|=
name|vm_page_select_cache
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|cnt
operator|.
name|v_cache_count
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"vm_page_alloc(NORMAL): missing pages on cache queue: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_pageout_deficit
operator|++
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_ZERO
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
condition|)
block|{
name|m
operator|=
name|vm_page_select_free
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|PQ_ZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc(ZERO): missing page on free queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|m
operator|=
name|vm_page_select_cache
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|cnt
operator|.
name|v_cache_count
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"vm_page_alloc(ZERO): missing pages on cache queue: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_pageout_deficit
operator|++
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_SYSTEM
case|:
if|if
condition|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_free_reserved
operator|)
operator|||
operator|(
operator|(
name|cnt
operator|.
name|v_cache_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|.
name|v_free_count
operator|>=
name|cnt
operator|.
name|v_interrupt_free_min
operator|)
operator|)
condition|)
block|{
name|m
operator|=
name|vm_page_select_free
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|PQ_FREE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc(SYSTEM): missing page on free queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|m
operator|=
name|vm_page_select_cache
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|cnt
operator|.
name|v_cache_count
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"vm_page_alloc(SYSTEM): missing pages on cache queue: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_pageout_deficit
operator|++
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|VM_ALLOC_INTERRUPT
case|:
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|vm_page_select_free
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|PQ_FREE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_page_alloc(INTERRUPT): missing page on free queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vm_pageout_deficit
operator|++
expr_stmt|;
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
default|default:
name|m
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|panic
argument_list|(
literal|"vm_page_alloc: invalid allocation class"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|queue
operator|=
name|m
operator|->
name|queue
expr_stmt|;
name|qtype
operator|=
name|queue
operator|-
name|m
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|PQ_ZERO
condition|)
name|vm_page_zero_count
operator|--
expr_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|lcnt
operator|)
operator|--
expr_stmt|;
name|oldobject
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|PQ_ZERO
condition|)
block|{
name|m
operator|->
name|flags
operator|=
name|PG_ZERO
operator||
name|PG_BUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|PQ_CACHE
condition|)
block|{
name|oldobject
operator|=
name|m
operator|->
name|object
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|=
name|PG_BUSY
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|flags
operator|=
name|PG_BUSY
expr_stmt|;
block|}
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|hold_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
comment|/* XXX before splx until vm_page_insert is safe */
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|object
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
comment|/* 	 * Don't wakeup too often - wakeup the pageout daemon when 	 * we would be nearly out of memory. 	 */
if|if
condition|(
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_reserved
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
operator|)
operator|||
operator|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_pageout_free_min
operator|)
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|qtype
operator|==
name|PQ_CACHE
operator|)
operator|&&
operator|(
operator|(
name|page_req
operator|==
name|VM_ALLOC_NORMAL
operator|)
operator|||
operator|(
name|page_req
operator|==
name|VM_ALLOC_ZERO
operator|)
operator|)
operator|&&
name|oldobject
operator|&&
operator|(
name|oldobject
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|)
operator|&&
operator|(
operator|(
name|oldobject
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|oldobject
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|vp
operator|&&
name|VSHOULDFREE
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
operator|(
name|VFREE
operator||
name|VTBFREE
operator||
name|VDOOMED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vnode_tobefree_list
argument_list|,
name|vp
argument_list|,
name|v_freelist
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VTBFREE
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vm_wait
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
block|{
name|vm_pageout_pages_needed
operator|=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|vm_pageout_pages_needed
argument_list|,
name|PSWP
argument_list|,
literal|"vmwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|vm_pages_needed
condition|)
block|{
name|vm_pages_needed
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
block|}
name|tsleep
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|,
name|PVM
argument_list|,
literal|"vmwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vm_page_sleep
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|busy
parameter_list|)
block|{
name|vm_object_t
name|object
init|=
name|m
operator|->
name|object
decl_stmt|;
name|int
name|slept
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|busy
operator|&&
operator|*
name|busy
operator|)
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|busy
operator|&&
operator|*
name|busy
operator|)
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slept
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|slept
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_activate:  *  *	Put the specified page on the active list (if appropriate).  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_activate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|vm_page_t
name|np
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|queue
operator|!=
name|PQ_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|queue
operator|=
name|PQ_ACTIVE
expr_stmt|;
operator|++
operator|(
operator|*
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|lcnt
operator|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|act_count
operator|<
name|ACT_INIT
condition|)
name|m
operator|->
name|act_count
operator|=
name|ACT_INIT
expr_stmt|;
name|cnt
operator|.
name|v_active_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|m
operator|->
name|act_count
operator|<
name|ACT_INIT
condition|)
name|m
operator|->
name|act_count
operator|=
name|ACT_INIT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * helper routine for vm_page_free and vm_page_free_zero  */
end_comment

begin_function
specifier|static
name|int
name|vm_page_freechk_and_unqueue
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|vm_object_t
name|oldobject
decl_stmt|;
name|oldobject
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|m
operator|->
name|busy
operator|||
operator|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_FREE
operator|)
operator|||
operator|(
name|m
operator|->
name|hold_count
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"vm_page_free: pindex(%lu), busy(%d), PG_BUSY(%d), hold(%d)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|m
operator|->
name|pindex
argument_list|,
name|m
operator|->
name|busy
argument_list|,
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|m
operator|->
name|hold_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_FREE
condition|)
name|panic
argument_list|(
literal|"vm_page_free: freeing free page"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"vm_page_free: freeing busy page"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vm_page_unqueue_nowakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|m
operator|->
name|wire_count
operator|>
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"vm_page_free: invalid wire count (%d), pindex: 0x%x"
argument_list|,
name|m
operator|->
name|wire_count
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|object
condition|)
name|m
operator|->
name|object
operator|->
name|wire_count
operator|--
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|oldobject
operator|&&
operator|(
name|oldobject
operator|->
name|type
operator|==
name|OBJT_VNODE
operator|)
operator|&&
operator|(
operator|(
name|oldobject
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|oldobject
operator|->
name|handle
expr_stmt|;
if|if
condition|(
name|vp
operator|&&
name|VSHOULDFREE
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
operator|(
name|VTBFREE
operator||
name|VDOOMED
operator||
name|VFREE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vnode_tobefree_list
argument_list|,
name|vp
argument_list|,
name|v_freelist
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VTBFREE
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * helper routine for vm_page_free and vm_page_free_zero  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|vm_page_free_wakeup
parameter_list|()
block|{
comment|/*  * if pageout daemon needs pages, then tell it that there are  * some free.  */
if|if
condition|(
name|vm_pageout_pages_needed
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|vm_pageout_pages_needed
argument_list|)
expr_stmt|;
name|vm_pageout_pages_needed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * wakeup processes that are waiting on memory if we hit a 	 * high water mark. And wakeup scheduler process if we have 	 * lots of memory. this process will swapin processes. 	 */
if|if
condition|(
name|vm_pages_needed
operator|&&
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|>=
name|cnt
operator|.
name|v_free_min
operator|)
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|vm_pages_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_free:  *  *	Returns the given page to the free list,  *	disassociating it with any VM object.  *  *	Object and page must be locked prior to entry.  */
end_comment

begin_function
name|void
name|vm_page_free
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_tfree
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_freechk_and_unqueue
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|queue
operator|=
name|PQ_FREE
operator|+
name|m
operator|->
name|pc
expr_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
expr_stmt|;
operator|++
operator|(
operator|*
name|pq
operator|->
name|lcnt
operator|)
expr_stmt|;
operator|++
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
expr_stmt|;
comment|/* 	 * If the pageout process is grabbing the page, it is likely 	 * that the page is NOT in the cache.  It is more likely that 	 * the page will be partially in the cache if it is being 	 * explicitly freed. 	 */
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
block|}
name|vm_page_free_wakeup
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_page_free_zero
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_tfree
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_freechk_and_unqueue
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|queue
operator|=
name|PQ_ZERO
operator|+
name|m
operator|->
name|pc
expr_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
expr_stmt|;
operator|++
operator|(
operator|*
name|pq
operator|->
name|lcnt
operator|)
expr_stmt|;
operator|++
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|++
name|vm_page_zero_count
expr_stmt|;
name|vm_page_free_wakeup
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_wire:  *  *	Mark this page as wired down by yet  *	another map, removing it from paging queues  *	as necessary.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_wire
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|object
condition|)
name|m
operator|->
name|object
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|vm_page_queues
index|[
name|PQ_NONE
index|]
operator|.
name|lcnt
operator|)
operator|++
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_unwire:  *  *	Release one wiring of this page, potentially  *	enabling it to be paged again.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_unwire
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|>
literal|0
condition|)
block|{
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|object
condition|)
name|m
operator|->
name|object
operator|->
name|wire_count
operator|--
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|--
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_ACTIVE
expr_stmt|;
operator|(
operator|*
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|lcnt
operator|)
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_active_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|panic
argument_list|(
literal|"vm_page_unwire: invalid wire count: %d\n"
argument_list|,
name|m
operator|->
name|wire_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_deactivate:  *  *	Returns the given page to the inactive list,  *	indicating that no physical maps have access  *	to this page.  [Used by the physical mapping system.]  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_deactivate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
comment|/* 	 * Only move active pages -- ignore locked or already inactive ones. 	 * 	 * XXX: sometimes we get pages which aren't wired down or on any queue - 	 * we need to put them on the inactive queue also, otherwise we lose 	 * track of them. Paul Mackerras (paulus@cs.anu.edu.au) 9-Jan-93. 	 */
if|if
condition|(
name|m
operator|->
name|queue
operator|==
name|PQ_INACTIVE
condition|)
return|return;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
name|vm_page_unqueue
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_INACTIVE
expr_stmt|;
operator|++
operator|(
operator|*
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
operator|.
name|lcnt
operator|)
expr_stmt|;
name|cnt
operator|.
name|v_inactive_count
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vm_page_cache  *  * Put the specified page onto the page cache queue (if appropriate).  */
end_comment

begin_function
name|void
name|vm_page_cache
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
name|m
operator|->
name|busy
operator|||
name|m
operator|->
name|wire_count
condition|)
block|{
name|printf
argument_list|(
literal|"vm_page_cache: attempting to cache busy page\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
condition|)
return|return;
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|m
operator|->
name|dirty
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"vm_page_cache: caching a dirty page, pindex: %d"
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|vm_page_unqueue_nowakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_CACHE
operator|+
name|m
operator|->
name|pc
expr_stmt|;
operator|(
operator|*
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|lcnt
operator|)
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_cache_count
operator|++
expr_stmt|;
name|m
operator|->
name|object
operator|->
name|cache_count
operator|++
expr_stmt|;
name|vm_page_free_wakeup
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab a page, waiting until we are waken up due to the page  * changing state.  We keep on waiting, if the page continues  * to be in the object.  If the page doesn't exist, allocate it.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_grab
parameter_list|(
name|object
parameter_list|,
name|pindex
parameter_list|,
name|allocflags
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|int
name|allocflags
decl_stmt|;
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|s
decl_stmt|,
name|generation
decl_stmt|;
name|retrylookup
label|:
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|busy
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
block|{
name|generation
operator|=
name|object
operator|->
name|generation
expr_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|object
operator|->
name|generation
operator|==
name|generation
operator|)
operator|&&
operator|(
name|m
operator|->
name|busy
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
operator||
name|PG_REFERENCED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"pgrbwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|allocflags
operator|&
name|VM_ALLOC_RETRY
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|retrylookup
goto|;
block|}
else|else
block|{
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
return|return
name|m
return|;
block|}
block|}
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|object
argument_list|,
name|pindex
argument_list|,
name|allocflags
operator|&
operator|~
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|VM_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|allocflags
operator|&
name|VM_ALLOC_RETRY
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
goto|goto
name|retrylookup
goto|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * mapping function for valid bits or for dirty bits in  * a page  */
end_comment

begin_function
name|__inline
name|int
name|vm_page_bits
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|u_short
name|chunk
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|==
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>=
name|PAGE_SIZE
operator|)
condition|)
return|return
name|VM_PAGE_BITS_ALL
return|;
name|size
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|base
operator|&=
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|PAGE_SIZE
operator|-
name|base
condition|)
block|{
name|size
operator|=
name|PAGE_SIZE
operator|-
name|base
expr_stmt|;
block|}
name|base
operator|=
name|base
operator|/
name|DEV_BSIZE
expr_stmt|;
name|chunk
operator|=
name|vm_page_dev_bsize_chunks
index|[
name|size
operator|/
name|DEV_BSIZE
index|]
expr_stmt|;
return|return
operator|(
name|chunk
operator|<<
name|base
operator|)
operator|&
name|VM_PAGE_BITS_ALL
return|;
block|}
end_function

begin_comment
comment|/*  * set a page valid and clean  */
end_comment

begin_function
name|void
name|vm_page_set_validclean
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|pagebits
init|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|m
operator|->
name|valid
operator||=
name|pagebits
expr_stmt|;
name|m
operator|->
name|dirty
operator|&=
operator|~
name|pagebits
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
operator|&&
name|size
operator|==
name|PAGE_SIZE
condition|)
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set a page (partially) invalid  */
end_comment

begin_function
name|void
name|vm_page_set_invalid
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|bits
decl_stmt|;
name|m
operator|->
name|valid
operator|&=
operator|~
operator|(
name|bits
operator|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
literal|0
condition|)
name|m
operator|->
name|dirty
operator|&=
operator|~
name|bits
expr_stmt|;
name|m
operator|->
name|object
operator|->
name|generation
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * is (partial) page valid?  */
end_comment

begin_function
name|int
name|vm_page_is_valid
parameter_list|(
name|m
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|bits
init|=
name|vm_page_bits
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|&&
operator|(
operator|(
name|m
operator|->
name|valid
operator|&
name|bits
operator|)
operator|==
name|bits
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|vm_page_test_dirty
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|dirty
operator|!=
name|VM_PAGE_BITS_ALL
operator|)
operator|&&
name|pmap_is_modified
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m
operator|->
name|dirty
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This interface is for merging with malloc() someday.  * Even if we never implement compaction so that contiguous allocation  * works after initialization time, malloc()'s data structures are good  * for statistics and for allocations of less than a page.  */
end_comment

begin_function
name|void
modifier|*
name|contigmalloc1
parameter_list|(
name|size
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|alignment
parameter_list|,
name|boundary
parameter_list|,
name|map
parameter_list|)
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* should be size_t here and for malloc() */
name|struct
name|malloc_type
modifier|*
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|long
name|low
decl_stmt|;
name|unsigned
name|long
name|high
decl_stmt|;
name|unsigned
name|long
name|alignment
decl_stmt|;
name|unsigned
name|long
name|boundary
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|start
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|,
name|phys
decl_stmt|,
name|tmp_addr
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|vm_page_t
name|pga
init|=
name|vm_page_array
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"contigmalloc1: size must not be 0"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alignment
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"contigmalloc1: alignment must be a power of 2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|boundary
operator|&
operator|(
name|boundary
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"contigmalloc1: boundary must be a power of 2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|1
condition|;
name|pass
operator|++
control|)
block|{
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
name|again
label|:
comment|/* 		 * Find first page in array that is free, within range, aligned, and 		 * such that the boundary won't be crossed. 		 */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|cnt
operator|.
name|v_page_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pqtype
decl_stmt|;
name|phys
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pqtype
operator|=
name|pga
index|[
name|i
index|]
operator|.
name|queue
operator|-
name|pga
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pqtype
operator|==
name|PQ_ZERO
operator|)
operator|||
operator|(
name|pqtype
operator|==
name|PQ_FREE
operator|)
operator|||
operator|(
name|pqtype
operator|==
name|PQ_CACHE
operator|)
operator|)
operator|&&
operator|(
name|phys
operator|>=
name|low
operator|)
operator|&&
operator|(
name|phys
operator|<
name|high
operator|)
operator|&&
operator|(
operator|(
name|phys
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|phys
operator|^
operator|(
name|phys
operator|+
name|size
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
comment|/* 		 * If the above failed or we will exceed the upper bound, fail. 		 */
if|if
condition|(
operator|(
name|i
operator|==
name|cnt
operator|.
name|v_page_count
operator|)
operator|||
operator|(
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
operator|+
name|size
operator|)
operator|>
name|high
operator|)
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|next
decl_stmt|;
name|again1
label|:
for|for
control|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|queue
operator|!=
name|PQ_INACTIVE
condition|)
block|{
break|break;
block|}
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_sleep
argument_list|(
name|m
argument_list|,
literal|"vpctw0"
argument_list|,
operator|&
name|m
operator|->
name|busy
argument_list|)
condition|)
goto|goto
name|again1
goto|;
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|vn_lock
argument_list|(
name|m
operator|->
name|object
operator|->
name|handle
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|m
operator|->
name|object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|m
operator|->
name|object
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
goto|goto
name|again1
goto|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|||
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
condition|)
block|{
name|vm_pageout_flush
argument_list|(
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again1
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|dirty
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|hold_count
operator|==
literal|0
operator|)
condition|)
name|vm_page_cache
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|queue
operator|!=
name|PQ_ACTIVE
condition|)
block|{
break|break;
block|}
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_sleep
argument_list|(
name|m
argument_list|,
literal|"vpctw1"
argument_list|,
operator|&
name|m
operator|->
name|busy
argument_list|)
condition|)
goto|goto
name|again1
goto|;
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|vn_lock
argument_list|(
name|m
operator|->
name|object
operator|->
name|handle
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|m
operator|->
name|object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|m
operator|->
name|object
operator|->
name|handle
argument_list|,
literal|0
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
goto|goto
name|again1
goto|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_SWAP
operator|||
name|m
operator|->
name|object
operator|->
name|type
operator|==
name|OBJT_DEFAULT
condition|)
block|{
name|vm_pageout_flush
argument_list|(
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again1
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|dirty
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|hold_count
operator|==
literal|0
operator|)
condition|)
name|vm_page_cache
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|start
operator|=
name|i
expr_stmt|;
comment|/* 		 * Check successive pages for contiguous and free. 		 */
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|/
name|PAGE_SIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pqtype
decl_stmt|;
name|pqtype
operator|=
name|pga
index|[
name|i
index|]
operator|.
name|queue
operator|-
name|pga
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
if|if
condition|(
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
index|]
argument_list|)
operator|!=
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pga
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|+
name|PAGE_SIZE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pqtype
operator|!=
name|PQ_ZERO
operator|)
operator|&&
operator|(
name|pqtype
operator|!=
name|PQ_FREE
operator|)
operator|&&
operator|(
name|pqtype
operator|!=
name|PQ_CACHE
operator|)
operator|)
condition|)
block|{
name|start
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|/
name|PAGE_SIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pqtype
decl_stmt|;
name|vm_page_t
name|m
init|=
operator|&
name|pga
index|[
name|i
index|]
decl_stmt|;
name|pqtype
operator|=
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|pqtype
operator|==
name|PQ_CACHE
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|lcnt
operator|)
operator|--
expr_stmt|;
name|cnt
operator|.
name|v_free_count
operator|--
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|m
operator|->
name|object
operator|=
name|NULL
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We've found a contiguous chunk that meets are requirements. 		 * Allocate kernel VM, unfree and assign the physical pages to it and 		 * return kernel VM pointer. 		 */
name|tmp_addr
operator|=
name|addr
operator|=
name|kmem_alloc_pageable
argument_list|(
name|map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX We almost never run out of kernel virtual 			 * space, so we don't make the allocated memory 			 * above available. 			 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|/
name|PAGE_SIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
operator|&
name|pga
index|[
name|i
index|]
decl_stmt|;
name|vm_page_insert
argument_list|(
name|m
argument_list|,
name|kernel_object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|tmp_addr
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|tmp_addr
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|contigmalloc
parameter_list|(
name|size
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|alignment
parameter_list|,
name|boundary
parameter_list|)
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* should be size_t here and for malloc() */
name|struct
name|malloc_type
modifier|*
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|long
name|low
decl_stmt|;
name|unsigned
name|long
name|high
decl_stmt|;
name|unsigned
name|long
name|alignment
decl_stmt|;
name|unsigned
name|long
name|boundary
decl_stmt|;
block|{
return|return
name|contigmalloc1
argument_list|(
name|size
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|alignment
argument_list|,
name|boundary
argument_list|,
name|kernel_map
argument_list|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|vm_page_alloc_contig
parameter_list|(
name|size
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|alignment
parameter_list|)
name|vm_offset_t
name|size
decl_stmt|;
name|vm_offset_t
name|low
decl_stmt|;
name|vm_offset_t
name|high
decl_stmt|;
name|vm_offset_t
name|alignment
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|contigmalloc1
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|alignment
argument_list|,
literal|0ul
argument_list|,
name|kernel_map
argument_list|)
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|page
argument_list|,
argument|vm_page_print_page_info
argument_list|)
end_macro

begin_block
block|{
name|db_printf
argument_list|(
literal|"cnt.v_free_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_cache_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_inactive_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_inactive_count
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_active_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_active_count
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_wire_count: %d\n"
argument_list|,
name|cnt
operator|.
name|v_wire_count
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_free_reserved: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_reserved
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_free_min: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_min
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_free_target: %d\n"
argument_list|,
name|cnt
operator|.
name|v_free_target
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_cache_min: %d\n"
argument_list|,
name|cnt
operator|.
name|v_cache_min
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cnt.v_inactive_target: %d\n"
argument_list|,
name|cnt
operator|.
name|v_inactive_target
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|pageq
argument_list|,
argument|vm_page_print_pageq_info
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|db_printf
argument_list|(
literal|"PQ_FREE:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|vm_page_queues
index|[
name|PQ_FREE
operator|+
name|i
index|]
operator|.
name|lcnt
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"PQ_CACHE:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|vm_page_queues
index|[
name|PQ_CACHE
operator|+
name|i
index|]
operator|.
name|lcnt
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"PQ_ZERO:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_L2_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|vm_page_queues
index|[
name|PQ_ZERO
operator|+
name|i
index|]
operator|.
name|lcnt
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"PQ_ACTIVE: %d, PQ_INACTIVE: %d\n"
argument_list|,
operator|*
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|lcnt
argument_list|,
operator|*
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
operator|.
name|lcnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

