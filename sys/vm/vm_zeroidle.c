begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 John Dyson  * Copyright (c) 2001 Matt Dillon  *  * All Rights Reserved.  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	from: @(#)vm_machdep.c	7.3 (Berkeley) 5/13/91  *	Utah $Hdr: vm_machdep.c 1.16.1.1 89/06/23$  * from: FreeBSD: .../i386/vm_machdep.c,v 1.165 2001/07/04 23:27:04 dillon  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<opt_sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|cnt_prezero
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_misc
argument_list|,
name|OID_AUTO
argument_list|,
name|cnt_prezero
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cnt_prezero
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|idlezero_enable_default
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vm.idlezero_enable"
argument_list|,
operator|&
name|idlezero_enable_default
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Defer setting the enable flag until the kthread is running. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idlezero_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|idlezero_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idlezero_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|idlezero_maxrun
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|idlezero_maxrun
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idlezero_maxrun
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vm.idlezero_maxrun"
argument_list|,
operator|&
name|idlezero_maxrun
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Implement the pre-zeroed page mechanism.  */
end_comment

begin_define
define|#
directive|define
name|ZIDLE_LO
parameter_list|(
name|v
parameter_list|)
value|((v) * 2 / 3)
end_define

begin_define
define|#
directive|define
name|ZIDLE_HI
parameter_list|(
name|v
parameter_list|)
value|((v) * 4 / 5)
end_define

begin_decl_stmt
specifier|static
name|boolean_t
name|wakeup_needed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zero_state
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vm_page_zero_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|idlezero_enable
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Attempt to maintain approximately 1/2 of our free pages in a 	 * PG_ZERO'd state.   Add some hysteresis to (attempt to) avoid 	 * generally zeroing a page when the system is near steady-state. 	 * Otherwise we might get 'flutter' during disk I/O / IPC or  	 * fast sleeps.  We also do not want to be continuously zeroing 	 * pages because doing so may flush our L1 and L2 caches too much. 	 */
if|if
condition|(
name|zero_state
operator|&&
name|vm_page_zero_count
operator|>=
name|ZIDLE_LO
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vm_page_zero_count
operator|>=
name|ZIDLE_HI
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_page_zero_idle
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|free_rover
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|zero_state
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|vm_pageq_find
argument_list|(
name|PQ_FREE
argument_list|,
name|free_rover
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_pageq_remove_nowakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|pmap_zero_page_idle
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_ZERO
expr_stmt|;
name|vm_pageq_enqueue
argument_list|(
name|PQ_FREE
operator|+
name|m
operator|->
name|pc
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|++
name|vm_page_zero_count
expr_stmt|;
operator|++
name|cnt_prezero
expr_stmt|;
if|if
condition|(
name|vm_page_zero_count
operator|>=
name|ZIDLE_HI
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
name|zero_state
operator|=
literal|1
expr_stmt|;
block|}
name|free_rover
operator|=
operator|(
name|free_rover
operator|+
name|PQ_PRIME2
operator|)
operator|&
name|PQ_COLORMASK
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by vm_page_free to hint that a new page is available. */
end_comment

begin_function
name|void
name|vm_page_zero_idle_wakeup
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_needed
operator|&&
name|vm_page_zero_check
argument_list|()
condition|)
block|{
name|wakeup_needed
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|zero_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vm_pagezero
parameter_list|(
name|void
name|__unused
modifier|*
name|arg
parameter_list|)
block|{
name|idlezero_enable
operator|=
name|idlezero_enable_default
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vm_page_zero_check
argument_list|()
condition|)
block|{
name|vm_page_zero_idle
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PREEMPTION
if|if
condition|(
name|sched_runnable
argument_list|()
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|wakeup_needed
operator|=
name|TRUE
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|zero_state
argument_list|,
operator|&
name|vm_page_queue_mtx
argument_list|,
name|PDROP
argument_list|,
literal|"pgzero"
argument_list|,
name|hz
operator|*
literal|300
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|pagezero_proc
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pagezero_start
parameter_list|(
name|void
name|__unused
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|vm_pagezero
argument_list|,
name|NULL
argument_list|,
operator|&
name|pagezero_proc
argument_list|,
name|RFSTOPPED
argument_list|,
literal|0
argument_list|,
literal|"pagezero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"pagezero_start: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * We're an idle task, don't count us in the load. 	 */
name|PROC_LOCK
argument_list|(
name|pagezero_proc
argument_list|)
expr_stmt|;
name|pagezero_proc
operator|->
name|p_flag
operator||=
name|P_NOLOAD
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pagezero_proc
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|pagezero_proc
argument_list|)
expr_stmt|;
name|sched_class
argument_list|(
name|td
argument_list|,
name|PRI_IDLE
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MAX_IDLE
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|pagezero
argument_list|,
argument|SI_SUB_KTHREAD_VM
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|pagezero_start
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

