begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 John Dyson  * Copyright (c) 2001 Matt Dillon  *  * All rights reserved.  Terms for use and redistribution  * are covered by the BSD Copyright as found in /usr/src/COPYRIGHT.  *  *	from: @(#)vm_machdep.c	7.3 (Berkeley) 5/13/91  *	Utah $Hdr: vm_machdep.c 1.16.1.1 89/06/23$  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vm_stats_misc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cnt_prezero
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_misc
argument_list|,
name|OID_AUTO
argument_list|,
name|cnt_prezero
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cnt_prezero
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|idlezero_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|idlezero_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idlezero_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vm.idlezero_enable"
argument_list|,
operator|&
name|idlezero_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|idlezero_maxrun
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|idlezero_maxrun
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|idlezero_maxrun
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vm.idlezero_maxrun"
argument_list|,
operator|&
name|idlezero_maxrun
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Implement the pre-zeroed page mechanism.  */
end_comment

begin_define
define|#
directive|define
name|ZIDLE_LO
parameter_list|(
name|v
parameter_list|)
value|((v) * 2 / 3)
end_define

begin_define
define|#
directive|define
name|ZIDLE_HI
parameter_list|(
name|v
parameter_list|)
value|((v) * 4 / 5)
end_define

begin_decl_stmt
specifier|static
name|int
name|zero_state
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vm_page_zero_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|idlezero_enable
condition|)
return|return
literal|0
return|;
comment|/* 	 * Attempt to maintain approximately 1/2 of our free pages in a 	 * PG_ZERO'd state.   Add some hysteresis to (attempt to) avoid 	 * generally zeroing a page when the system is near steady-state. 	 * Otherwise we might get 'flutter' during disk I/O / IPC or  	 * fast sleeps.  We also do not want to be continuously zeroing 	 * pages because doing so may flush our L1 and L2 caches too much. 	 */
if|if
condition|(
name|zero_state
operator|&&
name|vm_page_zero_count
operator|>=
name|ZIDLE_LO
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vm_page_zero_count
operator|>=
name|ZIDLE_HI
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vm_page_zero_idle
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|free_rover
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|zero_state
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|vm_pageq_find
argument_list|(
name|PQ_FREE
argument_list|,
name|free_rover
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|lcnt
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_NONE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pmap_zero_page_idle
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|m
operator|->
name|queue
operator|=
name|PQ_FREE
operator|+
name|m
operator|->
name|pc
expr_stmt|;
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|lcnt
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vm_page_queues
index|[
name|m
operator|->
name|queue
index|]
operator|.
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|++
name|vm_page_zero_count
expr_stmt|;
operator|++
name|cnt_prezero
expr_stmt|;
if|if
condition|(
name|vm_page_zero_count
operator|>=
name|ZIDLE_HI
argument_list|(
name|cnt
operator|.
name|v_free_count
argument_list|)
condition|)
name|zero_state
operator|=
literal|1
expr_stmt|;
block|}
name|free_rover
operator|=
operator|(
name|free_rover
operator|+
name|PQ_PRIME2
operator|)
operator|&
name|PQ_L2_MASK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called by vm_page_free to hint that a new page is available */
end_comment

begin_function
name|void
name|vm_page_zero_idle_wakeup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|idlezero_enable
operator|&&
name|vm_page_zero_check
argument_list|()
condition|)
name|wakeup
argument_list|(
operator|&
name|zero_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_pagezero
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|rtprio
name|rtp
decl_stmt|;
name|int
name|pages
init|=
literal|0
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|RTP_PRIO_MAX
expr_stmt|;
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_IDLE
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|rtp_to_pri
argument_list|(
operator|&
name|rtp
argument_list|,
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vm_page_zero_check
argument_list|()
condition|)
block|{
name|pages
operator|+=
name|vm_page_zero_idle
argument_list|()
expr_stmt|;
if|if
condition|(
name|pages
operator|>
name|idlezero_maxrun
operator|||
name|kserunnable
argument_list|()
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|pages
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|tsleep
argument_list|(
operator|&
name|zero_state
argument_list|,
name|pri
argument_list|,
literal|"pgzero"
argument_list|,
name|hz
operator|*
literal|300
argument_list|)
expr_stmt|;
name|pages
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|pagezero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|pagezero_kp
init|=
block|{
literal|"pagezero"
block|,
name|vm_pagezero
block|,
operator|&
name|pagezero
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|pagezero
argument_list|,
argument|SI_SUB_KTHREAD_VM
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|kproc_start
argument_list|,
argument|&pagezero_kp
argument_list|)
end_macro

end_unit

