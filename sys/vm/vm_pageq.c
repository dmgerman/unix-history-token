begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Matthew Dillon.  All Rights Reserved.  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_vmpage.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_function_decl
specifier|static
name|void
name|vm_coloring_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setPQL2
parameter_list|(
name|int
modifier|*
specifier|const
name|size
parameter_list|,
name|int
modifier|*
specifier|const
name|ways
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vpgqueues
name|vm_page_queues
index|[
name|PQ_MAXCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pq_coloring
name|page_queue_coloring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pq_cachesize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the cache in KB */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pq_cachenways
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* associativity of the cache */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vm_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pagequeue
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"VM meter stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_pagequeue
argument_list|,
name|OID_AUTO
argument_list|,
name|page_colors
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|PQ_NUMCOLORS
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Number of colors in the page queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_pagequeue
argument_list|,
name|OID_AUTO
argument_list|,
name|cachesize
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pq_cachesize
argument_list|,
literal|0
argument_list|,
literal|"Size of the processor cache in KB"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_pagequeue
argument_list|,
name|OID_AUTO
argument_list|,
name|cachenways
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pq_cachenways
argument_list|,
literal|0
argument_list|,
literal|"Associativity of the processor cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_pagequeue
argument_list|,
name|OID_AUTO
argument_list|,
name|prime1
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|PQ_PRIME1
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Cache tuning value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_stats_pagequeue
argument_list|,
name|OID_AUTO
argument_list|,
name|prime2
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|PQ_PRIME2
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Cache tuning value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vm_coloring_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PQ_NOOPT
name|PQ_NUMCOLORS
operator|=
name|PQ_PRIME1
operator|=
name|PQ_PRIME2
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|setPQL2
argument_list|(
operator|&
name|pq_cachesize
argument_list|,
operator|&
name|pq_cachenways
argument_list|)
expr_stmt|;
name|CTASSERT
argument_list|(
name|PAGE_SIZE
operator|/
literal|1024
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq_cachesize
operator|>
literal|0
operator|&&
name|pq_cachenways
operator|>
literal|0
condition|)
name|PQ_NUMCOLORS
operator|=
name|pq_cachesize
operator|/
operator|(
name|PAGE_SIZE
operator|/
literal|1024
operator|)
operator|/
expr|\
name|pq_cachenways
expr_stmt|;
else|else
name|PQ_NUMCOLORS
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|PQ_MAXCOLORS
operator|<
name|PQ_NUMCOLORS
condition|)
block|{
name|printf
argument_list|(
literal|"VM-PQ color limit (PQ_MAXCOLORS=%u) exceeded (%u), see vm_page.h"
argument_list|,
name|PQ_MAXCOLORS
argument_list|,
name|PQ_NUMCOLORS
argument_list|)
expr_stmt|;
name|PQ_NUMCOLORS
operator|=
name|PQ_MAXCOLORS
expr_stmt|;
block|}
if|if
condition|(
name|PQ_NUMCOLORS
operator|>=
literal|128
condition|)
block|{
name|PQ_PRIME1
operator|=
literal|31
expr_stmt|;
name|PQ_PRIME2
operator|=
literal|23
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PQ_NUMCOLORS
operator|>=
literal|64
condition|)
block|{
name|PQ_PRIME1
operator|=
literal|13
expr_stmt|;
name|PQ_PRIME2
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PQ_NUMCOLORS
operator|>=
literal|32
condition|)
block|{
name|PQ_PRIME1
operator|=
literal|9
expr_stmt|;
name|PQ_PRIME2
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PQ_NUMCOLORS
operator|>=
literal|16
condition|)
block|{
name|PQ_PRIME1
operator|=
literal|5
expr_stmt|;
name|PQ_PRIME2
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|PQ_NUMCOLORS
operator|=
name|PQ_PRIME1
operator|=
name|PQ_PRIME2
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * PQ_CACHE represents a 	 * PQ_NUMCOLORS consecutive queue. 	 */
name|PQ_COLORMASK
operator|=
name|PQ_NUMCOLORS
operator|-
literal|1
expr_stmt|;
name|PQ_INACTIVE
operator|=
literal|1
operator|+
name|PQ_NUMCOLORS
expr_stmt|;
name|PQ_ACTIVE
operator|=
literal|2
operator|+
name|PQ_NUMCOLORS
expr_stmt|;
name|PQ_CACHE
operator|=
literal|3
operator|+
name|PQ_NUMCOLORS
expr_stmt|;
name|PQ_HOLD
operator|=
literal|3
operator|+
literal|2
operator|*
name|PQ_NUMCOLORS
expr_stmt|;
name|PQ_COUNT
operator|=
literal|4
operator|+
literal|2
operator|*
name|PQ_NUMCOLORS
expr_stmt|;
name|PQ_MAXLENGTH
operator|=
name|PQ_NUMCOLORS
operator|/
literal|3
operator|+
name|PQ_PRIME1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: is it possible to allocate vm_page_queues[PQ_COUNT] here? */
error|#
directive|error
error|XXX: vm_page_queues = malloc(PQ_COUNT * sizeof(struct vpgqueues));
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
if|if
condition|(
name|PQ_NUMCOLORS
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"Using %d colors for the VM-PQ tuning (%d, %d)\n"
argument_list|,
name|PQ_NUMCOLORS
argument_list|,
name|pq_cachesize
argument_list|,
name|pq_cachenways
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_pageq_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_coloring_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_NUMCOLORS
condition|;
operator|++
name|i
control|)
block|{
name|vm_page_queues
index|[
name|PQ_FREE
operator|+
name|i
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_free_count
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_NUMCOLORS
condition|;
operator|++
name|i
control|)
block|{
name|vm_page_queues
index|[
name|PQ_CACHE
operator|+
name|i
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_cache_count
expr_stmt|;
block|}
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_inactive_count
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_active_count
expr_stmt|;
name|vm_page_queues
index|[
name|PQ_HOLD
index|]
operator|.
name|cnt
operator|=
operator|&
name|cnt
operator|.
name|v_active_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PQ_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|vm_page_queues
index|[
name|i
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vm_pageq_requeue
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|queue
init|=
name|VM_PAGE_GETQUEUE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|vpq
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vpq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vpq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_pageq_enqueue:  */
end_comment

begin_function
name|void
name|vm_pageq_enqueue
parameter_list|(
name|int
name|queue
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|vpgqueues
modifier|*
name|vpq
decl_stmt|;
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|VM_PAGE_SETQUEUE2
argument_list|(
name|m
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vpq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|++
operator|*
name|vpq
operator|->
name|cnt
expr_stmt|;
operator|++
name|vpq
operator|->
name|lcnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_add_new_page:  *  *	Add a new page to the freelist for use by the system.  */
end_comment

begin_function
name|void
name|vm_pageq_add_new_page
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|cnt
operator|.
name|v_page_count
operator|++
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|m
operator|->
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|pc
operator|=
operator|(
name|pa
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
name|PQ_COLORMASK
expr_stmt|;
name|pmap_page_init
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
name|vm_pageq_enqueue
argument_list|(
name|m
operator|->
name|pc
operator|+
name|PQ_FREE
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_page_queue_free_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vm_pageq_remove_nowakeup:  *  * 	vm_page_unqueue() without any wakeup  *  *	The queue containing the given page must be locked.  *	This routine may not block.  */
end_comment

begin_function
name|void
name|vm_pageq_remove_nowakeup
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|queue
init|=
name|VM_PAGE_GETQUEUE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|VM_PAGE_SETQUEUE2
argument_list|(
name|m
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
operator|--
expr_stmt|;
name|pq
operator|->
name|lcnt
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vm_pageq_remove:  *  *	Remove a page from its queue.  *  *	The queue containing the given page must be locked.  *	This routine may not block.  */
end_comment

begin_function
name|void
name|vm_pageq_remove
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|queue
init|=
name|VM_PAGE_GETQUEUE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
name|PQ_NONE
condition|)
block|{
name|VM_PAGE_SETQUEUE2
argument_list|(
name|m
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|queue
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pq
operator|->
name|pl
argument_list|,
name|m
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|->
name|cnt
operator|)
operator|--
expr_stmt|;
name|pq
operator|->
name|lcnt
operator|--
expr_stmt|;
if|if
condition|(
name|VM_PAGE_RESOLVEQUEUE
argument_list|(
name|m
argument_list|,
name|queue
argument_list|)
operator|==
name|PQ_CACHE
condition|)
block|{
if|if
condition|(
name|vm_paging_needed
argument_list|()
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PQ_NOOPT
end_ifndef

begin_comment
comment|/*  *	vm_pageq_find:  *  *	Find a page on the specified queue with color optimization.  *  *	The page coloring optimization attempts to locate a page  *	that does not overload other nearby pages in the object in  *	the cpu's L2 cache.  We need this optimization because cpu  *	caches tend to be physical caches, while object spaces tend   *	to be virtual.  *  *	The specified queue must be locked.  *	This routine may not block.  *  *	This routine may only be called from the vm_pageq_find()  *	function in this file.  */
end_comment

begin_function
specifier|static
specifier|inline
name|vm_page_t
name|_vm_pageq_find
parameter_list|(
name|int
name|basequeue
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|pq
decl_stmt|;
name|pq
operator|=
operator|&
name|vm_page_queues
index|[
name|basequeue
index|]
expr_stmt|;
comment|/* 	 * Note that for the first loop, index+i and index-i wind up at the 	 * same place.  Even though this is not totally optimal, we've already 	 * blown it by missing the cache case so we do not care. 	 */
for|for
control|(
name|i
operator|=
name|PQ_NUMCOLORS
operator|/
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pq
index|[
operator|(
name|index
operator|+
name|i
operator|)
operator|&
name|PQ_COLORMASK
index|]
operator|.
name|pl
argument_list|)
operator|)
expr|\
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pq
index|[
operator|(
name|index
operator|-
name|i
operator|)
operator|&
name|PQ_COLORMASK
index|]
operator|.
name|pl
argument_list|)
operator|)
expr|\
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PQ_NOOPT */
end_comment

begin_function
name|vm_page_t
name|vm_pageq_find
parameter_list|(
name|int
name|basequeue
parameter_list|,
name|int
name|index
parameter_list|,
name|boolean_t
name|prefer_zero
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
ifndef|#
directive|ifndef
name|PQ_NOOPT
if|if
condition|(
name|PQ_NUMCOLORS
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|prefer_zero
condition|)
block|{
name|m
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|vm_page_queues
index|[
name|basequeue
operator|+
name|index
index|]
operator|.
name|pl
argument_list|, \
name|pglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm_page_queues
index|[
name|basequeue
operator|+
name|index
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|_vm_pageq_find
argument_list|(
name|basequeue
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|prefer_zero
condition|)
block|{
name|m
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|vm_page_queues
index|[
name|basequeue
index|]
operator|.
name|pl
argument_list|,
name|pglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm_page_queues
index|[
name|basequeue
index|]
operator|.
name|pl
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PQ_NOOPT
block|}
endif|#
directive|endif
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

