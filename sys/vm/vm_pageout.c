begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)vm_pageout.c	8.7 (Berkeley) 6/19/95  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	The proverbial page-out daemon.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VM_PAGE_FREE_MIN
end_ifndef

begin_define
define|#
directive|define
name|VM_PAGE_FREE_MIN
value|(cnt.v_free_count / 20)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VM_PAGE_FREE_TARGET
end_ifndef

begin_define
define|#
directive|define
name|VM_PAGE_FREE_TARGET
value|((cnt.v_free_min * 4) / 3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|vm_page_free_min_min
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_min_max
init|=
literal|256
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_pages_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event on which pageout daemon sleeps */
end_comment

begin_decl_stmt
name|int
name|vm_page_max_wired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX max # of wired pages system-wide */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLUSTERED_PAGEOUT
end_ifdef

begin_define
define|#
directive|define
name|MAXPOCLUSTER
value|(MAXPHYS/NBPG)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|doclustered_pageout
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	vm_pageout_scan does the dirty work for the pageout daemon.  */
end_comment

begin_function
name|void
name|vm_pageout_scan
parameter_list|()
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|,
name|next
decl_stmt|;
specifier|register
name|int
name|page_shortage
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|pages_freed
decl_stmt|;
name|int
name|free
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
comment|/* 	 *	Only continue when we want more pages to be "free" 	 */
name|cnt
operator|.
name|v_rev
operator|++
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|<
name|cnt
operator|.
name|v_free_target
condition|)
block|{
name|swapout_threads
argument_list|()
expr_stmt|;
comment|/* 		 *	Be sure the pmap system is updated so 		 *	we can scan the inactive queue. 		 */
name|pmap_update
argument_list|()
expr_stmt|;
block|}
comment|/* 	 *	Acquire the resident page system lock, 	 *	as we may be changing what's resident quite a bit. 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* 	 *	Start scanning the inactive queue for pages we can free. 	 *	We keep scanning until we have enough free pages or 	 *	we have scanned through the entire queue.  If we 	 *	encounter dirty pages, we start cleaning them. 	 */
name|pages_freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|vm_page_queue_inactive
operator|.
name|tqh_first
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|next
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|>=
name|cnt
operator|.
name|v_free_target
condition|)
break|break;
name|cnt
operator|.
name|v_scan
operator|++
expr_stmt|;
name|next
operator|=
name|m
operator|->
name|pageq
operator|.
name|tqe_next
expr_stmt|;
comment|/* 		 * If the page has been referenced, move it back to the 		 * active queue. 		 */
if|if
condition|(
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the page is clean, free it up. 		 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_CLEAN
condition|)
block|{
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pages_freed
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * If the page is dirty but already being washed, skip it. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_LAUNDRY
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Otherwise the page is dirty and still in the laundry, 		 * so we start the cleaning operation and remove it from 		 * the laundry. 		 */
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
operator|!
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
continue|continue;
name|cnt
operator|.
name|v_pageouts
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CLUSTERED_PAGEOUT
if|if
condition|(
name|object
operator|->
name|pager
operator|&&
name|vm_pager_cancluster
argument_list|(
name|object
operator|->
name|pager
argument_list|,
name|PG_CLUSTERPUT
argument_list|)
condition|)
name|vm_pageout_cluster
argument_list|(
name|m
argument_list|,
name|object
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vm_pageout_page
argument_list|(
name|m
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|thread_wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 		 * Former next page may no longer even be on the inactive 		 * queue (due to potential blocking in the pager with the 		 * queues unlocked).  If it isn't, we just start over. 		 */
if|if
condition|(
name|next
operator|&&
operator|(
name|next
operator|->
name|flags
operator|&
name|PG_INACTIVE
operator|)
operator|==
literal|0
condition|)
name|next
operator|=
name|vm_page_queue_inactive
operator|.
name|tqh_first
expr_stmt|;
block|}
comment|/* 	 *	Compute the page shortage.  If we are still very low on memory 	 *	be sure that we will move a minimal amount of pages from active 	 *	to inactive. 	 */
name|page_shortage
operator|=
name|cnt
operator|.
name|v_inactive_target
operator|-
name|cnt
operator|.
name|v_inactive_count
expr_stmt|;
if|if
condition|(
name|page_shortage
operator|<=
literal|0
operator|&&
name|pages_freed
operator|==
literal|0
condition|)
name|page_shortage
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|page_shortage
operator|>
literal|0
condition|)
block|{
comment|/* 		 *	Move some more pages from active to inactive. 		 */
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_queue_active
operator|.
name|tqh_first
operator|)
operator|==
name|NULL
condition|)
break|break;
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|page_shortage
operator|--
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called with object and page queues locked.  * If reactivate is TRUE, a pager error causes the page to be  * put back on the active queue, ow it is left on the inactive queue.  */
end_comment

begin_function
name|void
name|vm_pageout_page
parameter_list|(
name|m
parameter_list|,
name|object
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
block|{
name|vm_pager_t
name|pager
decl_stmt|;
name|int
name|pageout_status
decl_stmt|;
comment|/* 	 * We set the busy bit to cause potential page faults on 	 * this page to block. 	 * 	 * We also set pageout-in-progress to keep the object from 	 * disappearing during pageout.  This guarantees that the 	 * page won't move from the inactive queue.  (However, any 	 * other page on the inactive queue may move!) 	 */
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
comment|/* 	 * Try to collapse the object before making a pager for it. 	 * We must unlock the page queues first. 	 */
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|pager
operator|==
name|NULL
condition|)
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * Do a wakeup here in case the following operations block. 	 */
name|thread_wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no pager for the page, use the default pager. 	 * If there is no place to put the page at the moment, 	 * leave it in the laundry and hope that there will be 	 * paging space later. 	 */
if|if
condition|(
operator|(
name|pager
operator|=
name|object
operator|->
name|pager
operator|)
operator|==
name|NULL
condition|)
block|{
name|pager
operator|=
name|vm_pager_allocate
argument_list|(
name|PG_DFLT
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|object
operator|->
name|size
argument_list|,
name|VM_PROT_ALL
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|NULL
condition|)
name|vm_object_setpager
argument_list|(
name|object
argument_list|,
name|pager
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|pageout_status
operator|=
name|pager
condition|?
name|vm_pager_put
argument_list|(
name|pager
argument_list|,
name|m
argument_list|,
name|FALSE
argument_list|)
else|:
name|VM_PAGER_FAIL
expr_stmt|;
name|vm_object_lock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pageout_status
condition|)
block|{
case|case
name|VM_PAGER_OK
case|:
case|case
name|VM_PAGER_PEND
case|:
name|cnt
operator|.
name|v_pgpgout
operator|++
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_LAUNDRY
expr_stmt|;
break|break;
case|case
name|VM_PAGER_BAD
case|:
comment|/* 		 * Page outside of range of object.  Right now we 		 * essentially lose the changes by pretending it 		 * worked. 		 * 		 * XXX dubious, what should we do? 		 */
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_LAUNDRY
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_PAGER_AGAIN
case|:
block|{
specifier|extern
name|int
name|lbolt
decl_stmt|;
comment|/* 		 * FAIL on a write is interpreted to mean a resource 		 * shortage, so we put pause for awhile and try again. 		 * XXX could get stuck here. 		 */
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"pageout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_object_lock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|VM_PAGER_FAIL
case|:
case|case
name|VM_PAGER_ERROR
case|:
comment|/* 		 * If page couldn't be paged out, then reactivate 		 * the page so it doesn't clog the inactive list. 		 * (We will try paging out it again later). 		 */
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
break|break;
block|}
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the operation is still going, leave the page busy 	 * to block all other accesses.  Also, leave the paging 	 * in progress indicator set so that we don't attempt an 	 * object collapse. 	 */
if|if
condition|(
name|pageout_status
operator|!=
name|VM_PAGER_PEND
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLUSTERED_PAGEOUT
end_ifdef

begin_define
define|#
directive|define
name|PAGEOUTABLE
parameter_list|(
name|p
parameter_list|)
define|\
value|((((p)->flags& (PG_INACTIVE|PG_CLEAN|PG_LAUNDRY)) == \ 	  (PG_INACTIVE|PG_LAUNDRY))&& !pmap_is_referenced(VM_PAGE_TO_PHYS(p)))
end_define

begin_comment
comment|/*  * Attempt to pageout as many contiguous (to ``m'') dirty pages as possible  * from ``object''.  Using information returned from the pager, we assemble  * a sorted list of contiguous dirty pages and feed them to the pager in one  * chunk.  Called with paging queues and object locked.  Also, object must  * already have a pager.  */
end_comment

begin_function
name|void
name|vm_pageout_cluster
parameter_list|(
name|m
parameter_list|,
name|object
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
block|{
name|vm_offset_t
name|offset
decl_stmt|,
name|loff
decl_stmt|,
name|hoff
decl_stmt|;
name|vm_page_t
name|plist
index|[
name|MAXPOCLUSTER
index|]
decl_stmt|,
modifier|*
name|plistp
decl_stmt|,
name|p
decl_stmt|;
name|int
name|postatus
decl_stmt|,
name|ix
decl_stmt|,
name|count
decl_stmt|;
comment|/* 	 * Determine the range of pages that can be part of a cluster 	 * for this object/offset.  If it is only our single page, just 	 * do it normally. 	 */
name|vm_pager_cluster
argument_list|(
name|object
operator|->
name|pager
argument_list|,
name|m
operator|->
name|offset
argument_list|,
operator|&
name|loff
argument_list|,
operator|&
name|hoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|hoff
operator|-
name|loff
operator|==
name|PAGE_SIZE
condition|)
block|{
name|vm_pageout_page
argument_list|(
name|m
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return;
block|}
name|plistp
operator|=
name|plist
expr_stmt|;
comment|/* 	 * Target page is always part of the cluster. 	 */
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|plistp
index|[
name|atop
argument_list|(
name|m
operator|->
name|offset
operator|-
name|loff
argument_list|)
index|]
operator|=
name|m
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Backup from the given page til we find one not fulfilling 	 * the pageout criteria or we hit the lower bound for the 	 * cluster.  For each page determined to be part of the 	 * cluster, unmap it and busy it out so it won't change. 	 */
name|ix
operator|=
name|atop
argument_list|(
name|m
operator|->
name|offset
operator|-
name|loff
argument_list|)
expr_stmt|;
name|offset
operator|=
name|m
operator|->
name|offset
expr_stmt|;
while|while
condition|(
name|offset
operator|>
name|loff
operator|&&
name|count
operator|<
name|MAXPOCLUSTER
operator|-
literal|1
condition|)
block|{
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|offset
operator|-
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|PAGEOUTABLE
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|plistp
index|[
operator|--
name|ix
index|]
operator|=
name|p
expr_stmt|;
name|offset
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|plistp
operator|+=
name|atop
argument_list|(
name|offset
operator|-
name|loff
argument_list|)
expr_stmt|;
name|loff
operator|=
name|offset
expr_stmt|;
comment|/* 	 * Now do the same moving forward from the target. 	 */
name|ix
operator|=
name|atop
argument_list|(
name|m
operator|->
name|offset
operator|-
name|loff
argument_list|)
operator|+
literal|1
expr_stmt|;
name|offset
operator|=
name|m
operator|->
name|offset
operator|+
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|hoff
operator|&&
name|count
operator|<
name|MAXPOCLUSTER
condition|)
block|{
name|p
operator|=
name|vm_page_lookup
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|PAGEOUTABLE
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|plistp
index|[
name|ix
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|offset
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|hoff
operator|=
name|offset
expr_stmt|;
comment|/* 	 * Pageout the page. 	 * Unlock everything and do a wakeup prior to the pager call 	 * in case it blocks. 	 */
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|again
label|:
name|thread_wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|postatus
operator|=
name|vm_pager_put_pages
argument_list|(
name|object
operator|->
name|pager
argument_list|,
name|plistp
argument_list|,
name|count
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * XXX rethink this 	 */
if|if
condition|(
name|postatus
operator|==
name|VM_PAGER_AGAIN
condition|)
block|{
specifier|extern
name|int
name|lbolt
decl_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"pageout"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|postatus
operator|==
name|VM_PAGER_BAD
condition|)
name|panic
argument_list|(
literal|"vm_pageout_cluster: VM_PAGER_BAD"
argument_list|)
expr_stmt|;
name|vm_object_lock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* 	 * Loop through the affected pages, reflecting the outcome of 	 * the operation. 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|count
condition|;
name|ix
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|plistp
operator|++
expr_stmt|;
switch|switch
condition|(
name|postatus
condition|)
block|{
case|case
name|VM_PAGER_OK
case|:
case|case
name|VM_PAGER_PEND
case|:
name|cnt
operator|.
name|v_pgpgout
operator|++
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|PG_LAUNDRY
expr_stmt|;
break|break;
case|case
name|VM_PAGER_FAIL
case|:
case|case
name|VM_PAGER_ERROR
case|:
comment|/* 			 * Pageout failed, reactivate the target page so it 			 * doesn't clog the inactive list.  Other pages are 			 * left as they are. 			 */
if|if
condition|(
name|p
operator|==
name|m
condition|)
block|{
name|vm_page_activate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the operation is still going, leave the page busy 		 * to block all other accesses. 		 */
if|if
condition|(
name|postatus
operator|!=
name|VM_PAGER_PEND
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the operation is still going, leave the paging in progress 	 * indicator set so that we don't attempt an object collapse. 	 */
if|if
condition|(
name|postatus
operator|!=
name|VM_PAGER_PEND
condition|)
name|object
operator|->
name|paging_in_progress
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	vm_pageout is the high level pageout daemon.  */
end_comment

begin_function
name|void
name|vm_pageout
parameter_list|()
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
comment|/* 	 *	Initialize some paging parameters. 	 */
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|==
literal|0
condition|)
block|{
name|cnt
operator|.
name|v_free_min
operator|=
name|VM_PAGE_FREE_MIN
expr_stmt|;
name|vm_page_free_min_min
operator|/=
name|cnt
operator|.
name|v_page_size
expr_stmt|;
name|vm_page_free_min_max
operator|/=
name|cnt
operator|.
name|v_page_size
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|<
name|vm_page_free_min_min
condition|)
name|cnt
operator|.
name|v_free_min
operator|=
name|vm_page_free_min_min
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|>
name|vm_page_free_min_max
condition|)
name|cnt
operator|.
name|v_free_min
operator|=
name|vm_page_free_min_max
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|.
name|v_free_target
operator|==
literal|0
condition|)
name|cnt
operator|.
name|v_free_target
operator|=
name|VM_PAGE_FREE_TARGET
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_target
operator|<=
name|cnt
operator|.
name|v_free_min
condition|)
name|cnt
operator|.
name|v_free_target
operator|=
name|cnt
operator|.
name|v_free_min
operator|+
literal|1
expr_stmt|;
comment|/* XXX does not really belong here */
if|if
condition|(
name|vm_page_max_wired
operator|==
literal|0
condition|)
name|vm_page_max_wired
operator|=
name|cnt
operator|.
name|v_free_count
operator|/
literal|3
expr_stmt|;
comment|/* 	 *	The pageout daemon is never done, so loop 	 *	forever. 	 */
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|thread_sleep
argument_list|(
operator|&
name|vm_pages_needed
argument_list|,
operator|&
name|vm_pages_needed_lock
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the inactive target for this scan. 		 * We need to keep a reasonable amount of memory in the 		 * inactive list to better simulate LRU behavior. 		 */
name|cnt
operator|.
name|v_inactive_target
operator|=
operator|(
name|cnt
operator|.
name|v_active_count
operator|+
name|cnt
operator|.
name|v_inactive_count
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_inactive_target
operator|<=
name|cnt
operator|.
name|v_free_target
condition|)
name|cnt
operator|.
name|v_inactive_target
operator|=
name|cnt
operator|.
name|v_free_target
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Only make a scan if we are likely to do something. 		 * Otherwise we might have been awakened by a pager 		 * to clean up async pageouts. 		 */
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_target
operator|||
name|cnt
operator|.
name|v_inactive_count
operator|<
name|cnt
operator|.
name|v_inactive_target
condition|)
name|vm_pageout_scan
argument_list|()
expr_stmt|;
name|vm_pager_sync
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

