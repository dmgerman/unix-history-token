begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * evtchn.c  *   * Communication via Xen event channels.  *   * Copyright (c) 2002-2005, K A Fraser  * Copyright (c) 2005-2006 Kip Macy  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/synch_bitops.h>
end_include

begin_include
include|#
directive|include
file|<xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* linux helper functions that got sucked in   * rename and move XXX  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|find_first_bit
parameter_list|(
specifier|const
name|unsigned
name|long
modifier|*
name|addr
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|int
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* This looks at memory. Mark it volatile to tell gcc not to move it around */
asm|__asm__
specifier|__volatile__
asm|( 		"xorl %%eax,%%eax\n\t" 		"repe; scasl\n\t" 		"jz 1f\n\t" 		"leal -4(%%edi),%%edi\n\t" 		"bsfl (%%edi),%%eax\n" 		"1:\tsubl %%ebx,%%edi\n\t" 		"shll $3,%%edi\n\t" 		"addl %%edi,%%eax" 		:"=a" (res), "=&c" (d0), "=&D" (d1) 		:"1" ((size + 31)>> 5), "2" (addr), "b" (addr) : "memory");
return|return
name|res
return|;
block|}
end_function

begin_define
define|#
directive|define
name|min_t
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|({ type __x = (x); type __y = (y); __x< __y ? __x: __y; })
end_define

begin_define
define|#
directive|define
name|first_cpu
parameter_list|(
name|src
parameter_list|)
value|__first_cpu(&(src), NR_CPUS)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|__first_cpu
parameter_list|(
specifier|const
name|xen_cpumask_t
modifier|*
name|srcp
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
return|return
name|min_t
argument_list|(
name|int
argument_list|,
name|nbits
argument_list|,
name|find_first_bit
argument_list|(
name|srcp
operator|->
name|bits
argument_list|,
name|nbits
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|__ffs
parameter_list|(
name|unsigned
name|long
name|word
parameter_list|)
block|{
asm|__asm__("bsfl %1,%0"                 :"=r" (word)                 :"rm" (word));
return|return
name|word
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|irq_mapping_update_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xenpic
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|xenpic_intsrc
block|{
name|struct
name|intsrc
name|xp_intsrc
decl_stmt|;
name|void
modifier|*
name|xp_cookie
decl_stmt|;
name|uint8_t
name|xp_vector
decl_stmt|;
name|boolean_t
name|xp_masked
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xenpic
block|{
name|struct
name|pic
modifier|*
name|xp_dynirq_pic
decl_stmt|;
name|struct
name|pic
modifier|*
name|xp_pirq_pic
decl_stmt|;
name|uint16_t
name|xp_numintr
decl_stmt|;
name|struct
name|xenpic_intsrc
name|xp_pins
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TODO
value|printf("%s: not implemented!\n", __func__)
end_define

begin_comment
comment|/* IRQ<-> event-channel mappings. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|evtchn_to_irq
index|[
name|NR_EVENT_CHANNELS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packed IRQ information: binding type, sub-type index, and event channel. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|irq_info
index|[
name|NR_IRQS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding types. */
end_comment

begin_enum
enum|enum
block|{
name|IRQT_UNBOUND
block|,
name|IRQT_PIRQ
block|,
name|IRQT_VIRQ
block|,
name|IRQT_IPI
block|,
name|IRQT_LOCAL_PORT
block|,
name|IRQT_CALLER_PORT
block|,
name|_IRQT_COUNT
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|_IRQT_BITS
value|4
end_define

begin_define
define|#
directive|define
name|_EVTCHN_BITS
value|12
end_define

begin_define
define|#
directive|define
name|_INDEX_BITS
value|(32 - _IRQT_BITS - _EVTCHN_BITS)
end_define

begin_comment
comment|/* Constructor for packed IRQ information. */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|mk_irq_info
parameter_list|(
name|uint32_t
name|type
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|evtchn
parameter_list|)
block|{
return|return
operator|(
operator|(
name|type
operator|<<
operator|(
literal|32
operator|-
name|_IRQT_BITS
operator|)
operator|)
operator||
operator|(
name|index
operator|<<
name|_EVTCHN_BITS
operator|)
operator||
name|evtchn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Constructor for packed IRQ information. */
end_comment

begin_comment
comment|/* Convenient shorthand for packed representation of an unbound IRQ. */
end_comment

begin_define
define|#
directive|define
name|IRQ_UNBOUND
value|mk_irq_info(IRQT_UNBOUND, 0, 0)
end_define

begin_comment
comment|/*  * Accessors for packed IRQ information.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|evtchn_from_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
return|return
name|irq_info
index|[
name|irq
index|]
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|_EVTCHN_BITS
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|index_from_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|irq_info
index|[
name|irq
index|]
operator|>>
name|_EVTCHN_BITS
operator|)
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|_INDEX_BITS
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|type_from_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
return|return
name|irq_info
index|[
name|irq
index|]
operator|>>
operator|(
literal|32
operator|-
name|_IRQT_BITS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* IRQ<-> VIRQ mapping. */
end_comment

begin_comment
comment|/* IRQ<-> IPI mapping. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NR_IPIS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_error
error|#
directive|error
literal|"NR_IPIS not defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NR_IPIS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bitmap indicating which PIRQs require Xen to be notified on unmask. */
end_comment

begin_expr_stmt
specifier|static
name|unsigned
name|long
name|pirq_needs_unmask_notify
index|[
name|NR_PIRQS
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Reference counts for bindings to IRQs. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|irq_bindcount
index|[
name|NR_IRQS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VALID_EVTCHN
parameter_list|(
name|_chn
parameter_list|)
value|((_chn) != 0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|uint8_t
name|cpu_evtchn
index|[
name|NR_EVENT_CHANNELS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cpu_evtchn_mask
index|[
name|NR_CPUS
index|]
index|[
name|NR_EVENT_CHANNELS
operator|/
name|BITS_PER_LONG
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|active_evtchns
parameter_list|(
name|cpu
parameter_list|,
name|sh
parameter_list|,
name|idx
parameter_list|)
define|\
value|((sh)->evtchn_pending[idx]&		\ 	 cpu_evtchn_mask[cpu][idx]&		\ 	 ~(sh)->evtchn_mask[idx])
end_define

begin_function
specifier|static
name|void
name|bind_evtchn_to_cpu
parameter_list|(
name|unsigned
name|int
name|chn
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
name|clear_bit
argument_list|(
name|chn
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cpu_evtchn_mask
index|[
name|cpu_evtchn
index|[
name|chn
index|]
index|]
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|chn
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cpu_evtchn_mask
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
name|cpu_evtchn
index|[
name|chn
index|]
operator|=
name|cpu
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_evtchn_cpu_bindings
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* By default all event channels notify CPU#0. */
name|memset
argument_list|(
name|cpu_evtchn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_evtchn
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cpu_evtchn_mask
index|[
literal|0
index|]
argument_list|,
operator|~
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_evtchn_mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|cpu_from_evtchn
parameter_list|(
name|evtchn
parameter_list|)
value|(cpu_evtchn[evtchn])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|active_evtchns
parameter_list|(
name|cpu
parameter_list|,
name|sh
parameter_list|,
name|idx
parameter_list|)
define|\
value|((sh)->evtchn_pending[idx]&		\ 	 ~(sh)->evtchn_mask[idx])
end_define

begin_define
define|#
directive|define
name|bind_evtchn_to_cpu
parameter_list|(
name|chn
parameter_list|,
name|cpu
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|init_evtchn_cpu_bindings
parameter_list|()
value|((void)0)
end_define

begin_define
define|#
directive|define
name|cpu_from_evtchn
parameter_list|(
name|evtchn
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Force a proper event-channel callback from Xen after clearing the  * callback mask. We do this in a very simple manner, by making a call  * down into Xen. The pending flag will be checked by Xen on return.  */
end_comment

begin_function
name|void
name|force_evtchn_callback
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|HYPERVISOR_xen_version
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evtchn_do_upcall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|unsigned
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|unsigned
name|int
name|l1i
decl_stmt|,
name|l2i
decl_stmt|,
name|port
decl_stmt|;
name|int
name|irq
decl_stmt|,
name|cpu
decl_stmt|;
name|shared_info_t
modifier|*
name|s
decl_stmt|;
name|vcpu_info_t
modifier|*
name|vcpu_info
decl_stmt|;
name|cpu
operator|=
name|smp_processor_id
argument_list|()
expr_stmt|;
name|s
operator|=
name|HYPERVISOR_shared_info
expr_stmt|;
name|vcpu_info
operator|=
operator|&
name|s
operator|->
name|vcpu_info
index|[
name|cpu
index|]
expr_stmt|;
name|vcpu_info
operator|->
name|evtchn_upcall_pending
operator|=
literal|0
expr_stmt|;
comment|/* NB. No need for a barrier here -- XCHG is a barrier on x86. */
name|l1
operator|=
name|xen_xchg
argument_list|(
operator|&
name|vcpu_info
operator|->
name|evtchn_pending_sel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|l1
operator|!=
literal|0
condition|)
block|{
name|l1i
operator|=
name|__ffs
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|l1
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|l1i
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|l2
operator|=
name|active_evtchns
argument_list|(
name|cpu
argument_list|,
name|s
argument_list|,
name|l1i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|l2i
operator|=
name|__ffs
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|port
operator|=
operator|(
name|l1i
operator|*
name|BITS_PER_LONG
operator|)
operator|+
name|l2i
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|evtchn_to_irq
index|[
name|port
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|intsrc
modifier|*
name|isrc
init|=
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
decl_stmt|;
comment|/*  				 * ack  				 */
name|mask_evtchn
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|clear_evtchn
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|intr_execute_handlers
argument_list|(
name|isrc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evtchn_device_upcall
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|ipi_pcpu
parameter_list|(
name|unsigned
name|int
name|cpu
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|irq
operator|=
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|vector
index|]
expr_stmt|;
name|notify_remote_via_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_unbound_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|dynirq
decl_stmt|,
name|irq
decl_stmt|;
for|for
control|(
name|dynirq
operator|=
literal|0
init|;
name|dynirq
operator|<
name|NR_IRQS
condition|;
name|dynirq
operator|++
control|)
block|{
name|irq
operator|=
name|dynirq_to_irq
argument_list|(
name|dynirq
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq_bindcount
index|[
name|irq
index|]
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|irq
operator|==
name|NR_IRQS
condition|)
name|panic
argument_list|(
literal|"No available IRQ to bind to: increase NR_IRQS!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_caller_port_to_irq
parameter_list|(
name|unsigned
name|int
name|caller_port
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|evtchn_to_irq
index|[
name|caller_port
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|irq
operator|=
name|find_unbound_irq
argument_list|()
operator|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|evtchn_to_irq
index|[
name|caller_port
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_CALLER_PORT
argument_list|,
literal|0
argument_list|,
name|caller_port
argument_list|)
expr_stmt|;
block|}
name|irq_bindcount
index|[
name|irq
index|]
operator|++
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|caller_port
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
return|return
name|irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_local_port_to_irq
parameter_list|(
name|unsigned
name|int
name|local_port
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|evtchn_to_irq
index|[
name|local_port
index|]
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|find_unbound_irq
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|struct
name|evtchn_close
name|close
init|=
block|{
operator|.
name|port
operator|=
name|local_port
block|}
decl_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_close
argument_list|,
operator|&
name|close
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|evtchn_to_irq
index|[
name|local_port
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_LOCAL_PORT
argument_list|,
literal|0
argument_list|,
name|local_port
argument_list|)
expr_stmt|;
name|irq_bindcount
index|[
name|irq
index|]
operator|++
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|local_port
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
return|return
name|irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_listening_port_to_irq
parameter_list|(
name|unsigned
name|int
name|remote_domain
parameter_list|)
block|{
name|struct
name|evtchn_alloc_unbound
name|alloc_unbound
decl_stmt|;
name|int
name|err
decl_stmt|;
name|alloc_unbound
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|alloc_unbound
operator|.
name|remote_dom
operator|=
name|remote_domain
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_alloc_unbound
argument_list|,
operator|&
name|alloc_unbound
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
else|:
name|bind_local_port_to_irq
argument_list|(
name|alloc_unbound
operator|.
name|port
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_interdomain_evtchn_to_irq
parameter_list|(
name|unsigned
name|int
name|remote_domain
parameter_list|,
name|unsigned
name|int
name|remote_port
parameter_list|)
block|{
name|struct
name|evtchn_bind_interdomain
name|bind_interdomain
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bind_interdomain
operator|.
name|remote_dom
operator|=
name|remote_domain
expr_stmt|;
name|bind_interdomain
operator|.
name|remote_port
operator|=
name|remote_port
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_interdomain
argument_list|,
operator|&
name|bind_interdomain
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
else|:
name|bind_local_port_to_irq
argument_list|(
name|bind_interdomain
operator|.
name|local_port
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_virq_to_irq
parameter_list|(
name|unsigned
name|int
name|virq
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|evtchn_bind_virq
name|bind_virq
decl_stmt|;
name|int
name|evtchn
init|=
literal|0
decl_stmt|,
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|virq
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|irq
operator|=
name|find_unbound_irq
argument_list|()
operator|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|bind_virq
operator|.
name|virq
operator|=
name|virq
expr_stmt|;
name|bind_virq
operator|.
name|vcpu
operator|=
name|cpu
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_virq
argument_list|,
operator|&
name|bind_virq
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|bind_virq
operator|.
name|port
expr_stmt|;
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_VIRQ
argument_list|,
name|virq
argument_list|,
name|evtchn
argument_list|)
expr_stmt|;
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|virq
index|]
operator|=
name|irq
expr_stmt|;
name|bind_evtchn_to_cpu
argument_list|(
name|evtchn
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
name|irq_bindcount
index|[
name|irq
index|]
operator|++
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
return|return
name|irq
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|bind_ipi_to_irq
parameter_list|(
name|unsigned
name|int
name|ipi
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|bind_ipi_to_irq
parameter_list|(
name|unsigned
name|int
name|ipi
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|evtchn_bind_ipi
name|bind_ipi
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|evtchn
init|=
literal|0
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|ipi
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|irq
operator|=
name|find_unbound_irq
argument_list|()
operator|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|bind_ipi
operator|.
name|vcpu
operator|=
name|cpu
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_ipi
argument_list|,
operator|&
name|bind_ipi
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|bind_ipi
operator|.
name|port
expr_stmt|;
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_IPI
argument_list|,
name|ipi
argument_list|,
name|evtchn
argument_list|)
expr_stmt|;
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|ipi
index|]
operator|=
name|irq
expr_stmt|;
name|bind_evtchn_to_cpu
argument_list|(
name|evtchn
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
name|irq_bindcount
index|[
name|irq
index|]
operator|++
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
return|return
name|irq
return|;
block|}
end_function

begin_function
name|void
name|unbind_from_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|evtchn_close
name|close
decl_stmt|;
name|int
name|evtchn
init|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|irq_bindcount
index|[
name|irq
index|]
operator|==
literal|0
operator|)
operator|&&
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
block|{
name|close
operator|.
name|port
operator|=
name|evtchn
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_close
argument_list|,
operator|&
name|close
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type_from_irq
argument_list|(
name|irq
argument_list|)
condition|)
block|{
case|case
name|IRQT_VIRQ
case|:
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
name|cpu_from_evtchn
argument_list|(
name|evtchn
argument_list|)
argument_list|)
index|[
name|index_from_irq
argument_list|(
name|irq
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|IRQT_IPI
case|:
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu_from_evtchn
argument_list|(
name|evtchn
argument_list|)
argument_list|)
index|[
name|index_from_irq
argument_list|(
name|irq
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Closed ports are implicitly re-bound to VCPU0. */
name|bind_evtchn_to_cpu
argument_list|(
name|evtchn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|IRQ_UNBOUND
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bind_caller_port_to_irqhandler
parameter_list|(
name|unsigned
name|int
name|caller_port
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|long
name|irqflags
parameter_list|,
name|unsigned
name|int
modifier|*
name|irqp
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|irq
operator|=
name|bind_caller_port_to_irq
argument_list|(
name|caller_port
argument_list|)
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_intsrc
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_add_handler
argument_list|(
name|devname
argument_list|,
name|irq
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|irqflags
argument_list|,
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|irqp
condition|)
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bind_listening_port_to_irqhandler
parameter_list|(
name|unsigned
name|int
name|remote_domain
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|long
name|irqflags
parameter_list|,
name|unsigned
name|int
modifier|*
name|irqp
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|irq
operator|=
name|bind_listening_port_to_irq
argument_list|(
name|remote_domain
argument_list|)
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_intsrc
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_add_handler
argument_list|(
name|devname
argument_list|,
name|irq
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|irqflags
argument_list|,
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|irqp
condition|)
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bind_interdomain_evtchn_to_irqhandler
parameter_list|(
name|unsigned
name|int
name|remote_domain
parameter_list|,
name|unsigned
name|int
name|remote_port
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|unsigned
name|long
name|irqflags
parameter_list|,
name|unsigned
name|int
modifier|*
name|irqp
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|irq
operator|=
name|bind_interdomain_evtchn_to_irq
argument_list|(
name|remote_domain
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_intsrc
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_add_handler
argument_list|(
name|devname
argument_list|,
name|irq
argument_list|,
name|filter
argument_list|,
name|handler
argument_list|,
name|NULL
argument_list|,
name|irqflags
argument_list|,
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|irqp
condition|)
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bind_virq_to_irqhandler
parameter_list|(
name|unsigned
name|int
name|virq
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|long
name|irqflags
parameter_list|,
name|unsigned
name|int
modifier|*
name|irqp
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|irq
operator|=
name|bind_virq_to_irq
argument_list|(
name|virq
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_intsrc
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_add_handler
argument_list|(
name|devname
argument_list|,
name|irq
argument_list|,
name|filter
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|irqflags
argument_list|,
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|irqp
condition|)
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bind_ipi_to_irqhandler
parameter_list|(
name|unsigned
name|int
name|ipi
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|unsigned
name|long
name|irqflags
parameter_list|,
name|unsigned
name|int
modifier|*
name|irqp
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|irq
operator|=
name|bind_ipi_to_irq
argument_list|(
name|ipi
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_intsrc
argument_list|)
expr_stmt|;
name|error
operator|=
name|intr_add_handler
argument_list|(
name|devname
argument_list|,
name|irq
argument_list|,
name|filter
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|irqflags
argument_list|,
operator|&
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|irqp
condition|)
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|unbind_from_irqhandler
parameter_list|(
name|unsigned
name|int
name|irq
parameter_list|)
block|{
name|intr_remove_handler
argument_list|(
name|xp
operator|->
name|xp_pins
index|[
name|irq
index|]
operator|.
name|xp_cookie
argument_list|)
expr_stmt|;
name|unbind_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Rebind an evtchn so that it gets delivered to a specific cpu */
end_comment

begin_comment
unit|static void rebind_irq_to_cpu(unsigned irq, unsigned tcpu) { 	evtchn_op_t op = { .cmd = EVTCHNOP_bind_vcpu }; 	int evtchn;  	mtx_lock_spin(&irq_mapping_update_lock);  	evtchn = evtchn_from_irq(irq); 	if (!VALID_EVTCHN(evtchn)) { 		mtx_unlock_spin(&irq_mapping_update_lock); 		return; 	}
comment|/* Send future instances of this interrupt to other vcpu. */
end_comment

begin_comment
unit|bind_vcpu.port = evtchn; 	bind_vcpu.vcpu = tcpu;
comment|/* 	 * If this fails, it usually just indicates that we're dealing with a  	 * virq or IPI channel, which don't actually need to be rebound. Ignore 	 * it, but don't do the xenlinux-level rebind in that case. 	 */
end_comment

begin_endif
unit|if (HYPERVISOR_event_channel_op(&op)>= 0) 		bind_evtchn_to_cpu(evtchn, tcpu);  	mtx_unlock_spin(&irq_mapping_update_lock);  }  static void set_affinity_irq(unsigned irq, xen_cpumask_t dest) { 	unsigned tcpu = first_cpu(dest); 	rebind_irq_to_cpu(irq, tcpu); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Interface to generic handling in intr_machdep.c  */
end_comment

begin_comment
comment|/*------------ interrupt handling --------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|TODO
value|printf("%s: not implemented!\n", __func__)
end_define

begin_function_decl
specifier|static
name|void
name|xenpic_dynirq_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_dynirq_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_dynirq_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_dynirq_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_dynirq_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_pirq_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_pirq_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_pirq_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_pirq_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_pirq_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xenpic_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xenpic_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_suspend
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xenpic_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pic
name|xenpic_dynirq_template
init|=
block|{
operator|.
name|pic_enable_source
operator|=
name|xenpic_dynirq_enable_source
block|,
operator|.
name|pic_disable_source
operator|=
name|xenpic_dynirq_disable_source
block|,
operator|.
name|pic_eoi_source
operator|=
name|xenpic_dynirq_eoi_source
block|,
operator|.
name|pic_enable_intr
operator|=
name|xenpic_dynirq_enable_intr
block|,
operator|.
name|pic_disable_intr
operator|=
name|xenpic_dynirq_disable_intr
block|,
operator|.
name|pic_vector
operator|=
name|xenpic_vector
block|,
operator|.
name|pic_source_pending
operator|=
name|xenpic_source_pending
block|,
operator|.
name|pic_suspend
operator|=
name|xenpic_suspend
block|,
operator|.
name|pic_resume
operator|=
name|xenpic_resume
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pic
name|xenpic_pirq_template
init|=
block|{
operator|.
name|pic_enable_source
operator|=
name|xenpic_pirq_enable_source
block|,
operator|.
name|pic_disable_source
operator|=
name|xenpic_pirq_disable_source
block|,
operator|.
name|pic_eoi_source
operator|=
name|xenpic_pirq_eoi_source
block|,
operator|.
name|pic_enable_intr
operator|=
name|xenpic_pirq_enable_intr
block|,
operator|.
name|pic_disable_intr
operator|=
name|xenpic_pirq_disable_intr
block|,
operator|.
name|pic_vector
operator|=
name|xenpic_vector
block|,
operator|.
name|pic_source_pending
operator|=
name|xenpic_source_pending
block|,
operator|.
name|pic_suspend
operator|=
name|xenpic_suspend
block|,
operator|.
name|pic_resume
operator|=
name|xenpic_resume
block|,
operator|.
name|pic_assign_cpu
operator|=
name|xenpic_assign_cpu
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xenpic_dynirq_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|xp_masked
condition|)
block|{
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_masked
operator|=
name|FALSE
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_dynirq_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|foo
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xp
operator|->
name|xp_masked
condition|)
block|{
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|mask_evtchn
argument_list|(
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_masked
operator|=
name|TRUE
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_dynirq_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_masked
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_dynirq_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_masked
operator|=
literal|1
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|mask_evtchn
argument_list|(
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_dynirq_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_masked
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|unmask_evtchn
argument_list|(
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenpic_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|xenpic_intsrc
modifier|*
name|pin
decl_stmt|;
name|pin
operator|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
expr_stmt|;
comment|//printf("xenpic_vector(): isrc=%p,vector=%u\n", pin, pin->xp_vector);
return|return
operator|(
name|pin
operator|->
name|xp_vector
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenpic_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|xenpic_intsrc
modifier|*
name|pin
init|=
operator|(
expr|struct
name|xenpic_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
comment|/* XXXEN: TODO */
name|printf
argument_list|(
literal|"xenpic_source_pending(): vector=%x,masked=%x\n"
argument_list|,
name|pin
operator|->
name|xp_vector
argument_list|,
name|pin
operator|->
name|xp_masked
argument_list|)
expr_stmt|;
comment|/*	notify_remote_via_evtchn(pin->xp_vector); // XXX RS: Is this correct? */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_suspend
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
block|{
name|TODO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
block|{
name|TODO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
block|{
name|TODO
expr_stmt|;
block|}
end_function

begin_function
name|void
name|notify_remote_via_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|evtchn
init|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
name|notify_remote_via_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"invalid evtchn"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* required for support of physical devices */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pirq_unmask_notify
parameter_list|(
name|int
name|pirq
parameter_list|)
block|{
name|struct
name|physdev_eoi
name|eoi
init|=
block|{
operator|.
name|irq
operator|=
name|pirq
block|}
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|test_bit
argument_list|(
name|pirq
argument_list|,
operator|&
name|pirq_needs_unmask_notify
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|HYPERVISOR_physdev_op
argument_list|(
name|PHYSDEVOP_eoi
argument_list|,
operator|&
name|eoi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pirq_query_unmask
parameter_list|(
name|int
name|pirq
parameter_list|)
block|{
name|struct
name|physdev_irq_status_query
name|irq_status_query
decl_stmt|;
name|irq_status_query
operator|.
name|irq
operator|=
name|pirq
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_physdev_op
argument_list|(
name|PHYSDEVOP_IRQ_STATUS_QUERY
argument_list|,
operator|&
name|irq_status_query
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|pirq
argument_list|,
operator|&
name|pirq_needs_unmask_notify
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq_status_query
operator|.
name|flags
operator|&
name|PHYSDEVOP_IRQ_NEEDS_UNMASK_NOTIFY
condition|)
name|set_bit
argument_list|(
name|pirq
argument_list|,
operator|&
name|pirq_needs_unmask_notify
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On startup, if there is no action associated with the IRQ then we are  * probing. In this case we should not share with others as it will confuse us.  */
end_comment

begin_define
define|#
directive|define
name|probing_irq
parameter_list|(
name|_irq
parameter_list|)
value|(intr_lookup_source(irq) == NULL)
end_define

begin_function
specifier|static
name|void
name|xenpic_pirq_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|evtchn_bind_pirq
name|bind_pirq
decl_stmt|;
name|int
name|evtchn
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|bind_pirq
operator|.
name|pirq
operator|=
name|irq
expr_stmt|;
comment|/* NB. We are happy to share unless we are probing. */
name|bind_pirq
operator|.
name|flags
operator|=
name|probing_irq
argument_list|(
name|irq
argument_list|)
condition|?
literal|0
else|:
name|BIND_PIRQ__WILL_SHARE
expr_stmt|;
if|if
condition|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_pirq
argument_list|,
operator|&
name|bind_pirq
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|XEN_PRIVILEGED_GUEST
name|panic
argument_list|(
literal|"unexpected pirq call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|probing_irq
argument_list|(
name|irq
argument_list|)
condition|)
comment|/* Some failures are expected when probing. */
name|printf
argument_list|(
literal|"Failed to obtain physical IRQ %d\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|evtchn
operator|=
name|bind_pirq
operator|.
name|port
expr_stmt|;
name|pirq_query_unmask
argument_list|(
name|irq_to_pirq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|bind_evtchn_to_cpu
argument_list|(
name|evtchn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_PIRQ
argument_list|,
name|irq
argument_list|,
name|evtchn
argument_list|)
expr_stmt|;
name|out
label|:
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|pirq_unmask_notify
argument_list|(
name|irq_to_pirq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_pirq_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|unsigned
name|int
name|irq
decl_stmt|;
name|int
name|evtchn
decl_stmt|;
name|struct
name|evtchn_close
name|close
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|mask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|close
operator|.
name|port
operator|=
name|evtchn
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_close
argument_list|,
operator|&
name|close
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bind_evtchn_to_cpu
argument_list|(
name|evtchn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|IRQ_UNBOUND
expr_stmt|;
name|done
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_pirq_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|int
name|evtchn
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|pirq_unmask_notify
argument_list|(
name|irq_to_pirq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_pirq_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
block|{
name|int
name|evtchn
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|mask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenpic_pirq_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|int
name|evtchn
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
name|irq
operator|=
name|xenpic_vector
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_EVTCHN
argument_list|(
name|evtchn
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
name|pirq_unmask_notify
argument_list|(
name|irq_to_pirq
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|irq_mapping_update_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|irq_to_evtchn_port
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
return|return
name|evtchn_from_irq
argument_list|(
name|irq
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mask_evtchn
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|shared_info_t
modifier|*
name|s
init|=
name|HYPERVISOR_shared_info
decl_stmt|;
name|synch_set_bit
argument_list|(
name|port
argument_list|,
operator|&
name|s
operator|->
name|evtchn_mask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unmask_evtchn
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|shared_info_t
modifier|*
name|s
init|=
name|HYPERVISOR_shared_info
decl_stmt|;
name|unsigned
name|int
name|cpu
init|=
name|smp_processor_id
argument_list|()
decl_stmt|;
name|vcpu_info_t
modifier|*
name|vcpu_info
init|=
operator|&
name|s
operator|->
name|vcpu_info
index|[
name|cpu
index|]
decl_stmt|;
comment|/* Slow path (hypercall) if this is a non-local port. */
if|if
condition|(
name|unlikely
argument_list|(
name|cpu
operator|!=
name|cpu_from_evtchn
argument_list|(
name|port
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|evtchn_unmask
name|unmask
init|=
block|{
operator|.
name|port
operator|=
name|port
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_unmask
argument_list|,
operator|&
name|unmask
argument_list|)
expr_stmt|;
return|return;
block|}
name|synch_clear_bit
argument_list|(
name|port
argument_list|,
operator|&
name|s
operator|->
name|evtchn_mask
argument_list|)
expr_stmt|;
comment|/* 	 * The following is basically the equivalent of 'hw_resend_irq'. Just 	 * like a real IO-APIC we 'lose the interrupt edge' if the channel is 	 * masked. 	 */
if|if
condition|(
name|synch_test_bit
argument_list|(
name|port
argument_list|,
operator|&
name|s
operator|->
name|evtchn_pending
argument_list|)
operator|&&
operator|!
name|synch_test_and_set_bit
argument_list|(
name|port
operator|/
name|BITS_PER_LONG
argument_list|,
operator|&
name|vcpu_info
operator|->
name|evtchn_pending_sel
argument_list|)
condition|)
block|{
name|vcpu_info
operator|->
name|evtchn_upcall_pending
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|vcpu_info
operator|->
name|evtchn_upcall_mask
condition|)
name|force_evtchn_callback
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|irq_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|evtchn_op_t
name|op
decl_stmt|;
name|int
name|cpu
decl_stmt|,
name|pirq
decl_stmt|,
name|virq
decl_stmt|,
name|ipi
decl_stmt|,
name|irq
decl_stmt|,
name|evtchn
decl_stmt|;
name|struct
name|evtchn_bind_virq
name|bind_virq
decl_stmt|;
name|struct
name|evtchn_bind_ipi
name|bind_ipi
decl_stmt|;
name|init_evtchn_cpu_bindings
argument_list|()
expr_stmt|;
comment|/* New event-channel space is not 'live' yet. */
for|for
control|(
name|evtchn
operator|=
literal|0
init|;
name|evtchn
operator|<
name|NR_EVENT_CHANNELS
condition|;
name|evtchn
operator|++
control|)
name|mask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
comment|/* Check that no PIRQs are still bound. */
for|for
control|(
name|pirq
operator|=
literal|0
init|;
name|pirq
operator|<
name|NR_PIRQS
condition|;
name|pirq
operator|++
control|)
name|PANIC_IF
argument_list|(
name|irq_info
index|[
name|pirq_to_irq
argument_list|(
name|pirq
argument_list|)
index|]
operator|!=
name|IRQ_UNBOUND
argument_list|)
expr_stmt|;
comment|/* Secondary CPUs must have no VIRQ or IPI bindings. */
for|for
control|(
name|cpu
operator|=
literal|1
init|;
name|cpu
operator|<
name|NR_CPUS
condition|;
name|cpu
operator|++
control|)
block|{
for|for
control|(
name|virq
operator|=
literal|0
init|;
name|virq
operator|<
name|NR_VIRQS
condition|;
name|virq
operator|++
control|)
name|PANIC_IF
argument_list|(
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|virq
index|]
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ipi
operator|=
literal|0
init|;
name|ipi
operator|<
name|NR_IPIS
condition|;
name|ipi
operator|++
control|)
name|PANIC_IF
argument_list|(
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|ipi
index|]
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* No IRQ<-> event-channel mappings. */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|NR_IRQS
condition|;
name|irq
operator|++
control|)
name|irq_info
index|[
name|irq
index|]
operator|&=
operator|~
literal|0xFFFF
expr_stmt|;
comment|/* zap event-channel binding */
for|for
control|(
name|evtchn
operator|=
literal|0
init|;
name|evtchn
operator|<
name|NR_EVENT_CHANNELS
condition|;
name|evtchn
operator|++
control|)
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Primary CPU: rebind VIRQs automatically. */
for|for
control|(
name|virq
operator|=
literal|0
init|;
name|virq
operator|<
name|NR_VIRQS
condition|;
name|virq
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|irq
operator|=
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
literal|0
argument_list|)
index|[
name|virq
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|PANIC_IF
argument_list|(
name|irq_info
index|[
name|irq
index|]
operator|!=
name|mk_irq_info
argument_list|(
name|IRQT_VIRQ
argument_list|,
name|virq
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get a new binding from Xen. */
name|bind_virq
operator|.
name|virq
operator|=
name|virq
expr_stmt|;
name|bind_virq
operator|.
name|vcpu
operator|=
literal|0
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_virq
argument_list|,
operator|&
name|bind_virq
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|bind_virq
operator|.
name|port
expr_stmt|;
comment|/* Record the new mapping. */
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_VIRQ
argument_list|,
name|virq
argument_list|,
name|evtchn
argument_list|)
expr_stmt|;
comment|/* Ready for use. */
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
block|}
comment|/* Primary CPU: rebind IPIs automatically. */
for|for
control|(
name|ipi
operator|=
literal|0
init|;
name|ipi
operator|<
name|NR_IPIS
condition|;
name|ipi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|irq
operator|=
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
literal|0
argument_list|)
index|[
name|ipi
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|PANIC_IF
argument_list|(
name|irq_info
index|[
name|irq
index|]
operator|!=
name|mk_irq_info
argument_list|(
name|IRQT_IPI
argument_list|,
name|ipi
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get a new binding from Xen. */
name|memset
argument_list|(
operator|&
name|op
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|bind_ipi
operator|.
name|vcpu
operator|=
literal|0
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_bind_ipi
argument_list|,
operator|&
name|bind_ipi
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|evtchn
operator|=
name|bind_ipi
operator|.
name|port
expr_stmt|;
comment|/* Record the new mapping. */
name|evtchn_to_irq
index|[
name|evtchn
index|]
operator|=
name|irq
expr_stmt|;
name|irq_info
index|[
name|irq
index|]
operator|=
name|mk_irq_info
argument_list|(
name|IRQT_IPI
argument_list|,
name|ipi
argument_list|,
name|evtchn
argument_list|)
expr_stmt|;
comment|/* Ready for use. */
name|unmask_evtchn
argument_list|(
name|evtchn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evtchn_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cpu
decl_stmt|;
name|struct
name|xenpic_intsrc
modifier|*
name|pin
decl_stmt|,
modifier|*
name|tpin
decl_stmt|;
name|init_evtchn_cpu_bindings
argument_list|()
expr_stmt|;
comment|/* No VIRQ or IPI bindings. */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_VIRQS
condition|;
name|i
operator|++
control|)
name|per_cpu
argument_list|(
name|virq_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_IPIS
condition|;
name|i
operator|++
control|)
name|per_cpu
argument_list|(
name|ipi_to_irq
argument_list|,
name|cpu
argument_list|)
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* No event-channel -> IRQ mappings. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_EVENT_CHANNELS
condition|;
name|i
operator|++
control|)
block|{
name|evtchn_to_irq
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|mask_evtchn
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* No event channels are 'live' right now. */
block|}
comment|/* No IRQ -> event-channel mappings. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_IRQS
condition|;
name|i
operator|++
control|)
name|irq_info
index|[
name|i
index|]
operator|=
name|IRQ_UNBOUND
expr_stmt|;
name|xp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xenpic
argument_list|)
operator|+
name|NR_IRQS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xenpic_intsrc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|xp
operator|->
name|xp_dynirq_pic
operator|=
operator|&
name|xenpic_dynirq_template
expr_stmt|;
name|xp
operator|->
name|xp_pirq_pic
operator|=
operator|&
name|xenpic_pirq_template
expr_stmt|;
name|xp
operator|->
name|xp_numintr
operator|=
name|NR_IRQS
expr_stmt|;
name|bzero
argument_list|(
name|xp
operator|->
name|xp_pins
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xenpic_intsrc
argument_list|)
operator|*
name|NR_IRQS
argument_list|)
expr_stmt|;
comment|/* We need to register our PIC's beforehand */
if|if
condition|(
name|intr_register_pic
argument_list|(
operator|&
name|xenpic_pirq_template
argument_list|)
condition|)
name|panic
argument_list|(
literal|"XEN: intr_register_pic() failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_register_pic
argument_list|(
operator|&
name|xenpic_dynirq_template
argument_list|)
condition|)
name|panic
argument_list|(
literal|"XEN: intr_register_pic() failure"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the dynamic IRQ's - we initialize the structures, but 	 * we do not bind them (bind_evtchn_to_irqhandle() does this) 	 */
name|pin
operator|=
name|xp
operator|->
name|xp_pins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_DYNIRQS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Dynamic IRQ space is currently unbound. Zero the refcnts. */
name|irq_bindcount
index|[
name|dynirq_to_irq
argument_list|(
name|i
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|tpin
operator|=
operator|&
name|pin
index|[
name|dynirq_to_irq
argument_list|(
name|i
argument_list|)
index|]
expr_stmt|;
name|tpin
operator|->
name|xp_intsrc
operator|.
name|is_pic
operator|=
name|xp
operator|->
name|xp_dynirq_pic
expr_stmt|;
name|tpin
operator|->
name|xp_vector
operator|=
name|dynirq_to_irq
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, we go ahead and claim every PIRQ there is. 	 */
name|pin
operator|=
name|xp
operator|->
name|xp_pins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_PIRQS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Dynamic IRQ space is currently unbound. Zero the refcnts. */
name|irq_bindcount
index|[
name|pirq_to_irq
argument_list|(
name|i
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RTC_IRQ
comment|/* If not domain 0, force our RTC driver to fail its probe. */
if|if
condition|(
operator|(
name|i
operator|==
name|RTC_IRQ
operator|)
operator|&&
operator|!
operator|(
name|xen_start_info
operator|->
name|flags
operator|&
name|SIF_INITDOMAIN
operator|)
condition|)
continue|continue;
endif|#
directive|endif
name|tpin
operator|=
operator|&
name|pin
index|[
name|pirq_to_irq
argument_list|(
name|i
argument_list|)
index|]
expr_stmt|;
name|tpin
operator|->
name|xp_intsrc
operator|.
name|is_pic
operator|=
name|xp
operator|->
name|xp_pirq_pic
expr_stmt|;
name|tpin
operator|->
name|xp_vector
operator|=
name|pirq_to_irq
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|evtchn_init
argument_list|,
name|SI_SUB_INTR
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|evtchn_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      * irq_mapping_update_lock: in order to allow an interrupt to occur in a critical      * 	        section, to set pcpu->ipending (etc...) properly, we      *	        must be able to get the icu lock, so it can't be      *	        under witness.      */
end_comment

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|irq_mapping_update_lock
argument_list|,
operator|&
name|irq_mapping_update_lock
argument_list|,
literal|"xp"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

