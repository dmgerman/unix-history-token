begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * Client-facing interface for the Xenbus driver.  In other words, the  * interface between the Xenbus and the device-specific code, be it the  * frontend or the backend of that driver.  *  * Copyright (C) 2005 XenSource Ltd  *   * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printk("xenbus_client (%s:%d) " fmt ".\n", __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_define
define|#
directive|define
name|EXPORT_SYMBOL
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|kmalloc
parameter_list|(
name|size
parameter_list|,
name|unused
parameter_list|)
value|malloc(size, M_DEVBUF, M_WAITOK)
end_define

begin_define
define|#
directive|define
name|kfree
parameter_list|(
name|ptr
parameter_list|)
value|free(ptr, M_DEVBUF)
end_define

begin_define
define|#
directive|define
name|BUG_ON
value|PANIC_IF
end_define

begin_function
specifier|const
name|char
modifier|*
name|xenbus_strstate
parameter_list|(
name|XenbusState
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name
index|[]
init|=
block|{
index|[
name|XenbusStateUnknown
index|]
operator|=
literal|"Unknown"
block|,
index|[
name|XenbusStateInitialising
index|]
operator|=
literal|"Initialising"
block|,
index|[
name|XenbusStateInitWait
index|]
operator|=
literal|"InitWait"
block|,
index|[
name|XenbusStateInitialised
index|]
operator|=
literal|"Initialised"
block|,
index|[
name|XenbusStateConnected
index|]
operator|=
literal|"Connected"
block|,
index|[
name|XenbusStateClosing
index|]
operator|=
literal|"Closing"
block|,
index|[
name|XenbusStateClosed
index|]
operator|=
literal|"Closed"
block|, 	}
decl_stmt|;
return|return
operator|(
name|state
operator|<
operator|(
name|XenbusStateClosed
operator|+
literal|1
operator|)
operator|)
condition|?
name|name
index|[
name|state
index|]
else|:
literal|"INVALID"
return|;
block|}
end_function

begin_function
name|int
name|xenbus_watch_path
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|watch
operator|->
name|node
operator|=
name|path
expr_stmt|;
name|watch
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|err
operator|=
name|register_xenbus_watch
argument_list|(
name|watch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|watch
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|watch
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"adding watch on %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_watch_path
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|xenbus_watch_path2
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|state
init|=
name|kmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|path2
argument_list|)
operator|+
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
operator|-
name|ENOMEM
argument_list|,
literal|"allocating path for watch"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|strcpy
argument_list|(
name|state
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|state
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|state
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|err
operator|=
name|xenbus_watch_path
argument_list|(
name|dev
argument_list|,
name|state
argument_list|,
name|watch
argument_list|,
name|callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kfree
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_watch_path2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|xenbus_switch_state
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|XenbusState
name|state
parameter_list|)
block|{
comment|/* We check whether the state is currently set to the given value, and 	   if not, then the state is set.  We don't want to unconditionally 	   write the given state, because we don't want to fire watches 	   unnecessarily.  Furthermore, if the node has gone, we don't write 	   to it, as the device will be tearing down, and we don't want to 	   resurrect that directory. 	*/
name|int
name|current_state
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|dev
operator|->
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|xenbus_scanf
argument_list|(
name|XBT_NIL
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"state"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|current_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|xenbus_printf
argument_list|(
name|XBT_NIL
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
literal|"state"
argument_list|,
literal|"%d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|XenbusStateClosing
condition|)
comment|/* Avoid looping */
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"writing new state"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|dev
operator|->
name|state
operator|=
name|state
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xenbus_frontend_closed
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|xenbus_switch_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|complete(&dev->down);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Return the path to the error node for the given device, or NULL on failure.  * If the value returned is non-NULL, then it is the caller's to kfree.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|error_path
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|path_buffer
init|=
name|kmalloc
argument_list|(
name|strlen
argument_list|(
literal|"error/"
argument_list|)
operator|+
name|strlen
argument_list|(
name|dev
operator|->
name|nodename
argument_list|)
operator|+
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|path_buffer
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|path_buffer
argument_list|,
literal|"error/"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path_buffer
operator|+
name|strlen
argument_list|(
literal|"error/"
argument_list|)
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
name|path_buffer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_dev_error
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|printf_buffer
init|=
name|NULL
decl_stmt|,
modifier|*
name|path_buffer
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|PRINTF_BUFFER_SIZE
value|4096
name|printf_buffer
operator|=
name|kmalloc
argument_list|(
name|PRINTF_BUFFER_SIZE
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|printf_buffer
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|len
operator|=
name|sprintf
argument_list|(
name|printf_buffer
argument_list|,
literal|"%i "
argument_list|,
operator|-
name|err
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsnprintf
argument_list|(
name|printf_buffer
operator|+
name|len
argument_list|,
name|PRINTF_BUFFER_SIZE
operator|-
name|len
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|len
operator|+
name|ret
operator|>
name|PRINTF_BUFFER_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|dev_err(&dev->dev, "%s\n", printf_buffer);
endif|#
directive|endif
name|path_buffer
operator|=
name|error_path
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_buffer
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"xenbus: failed to write error node for %s (%s)\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
name|printf_buffer
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|xenbus_write
argument_list|(
name|XBT_NIL
argument_list|,
name|path_buffer
argument_list|,
literal|"error"
argument_list|,
name|printf_buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"xenbus: failed to write error node for %s (%s)\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|,
name|printf_buffer
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|printf_buffer
condition|)
name|kfree
argument_list|(
name|printf_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_buffer
condition|)
name|kfree
argument_list|(
name|path_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xenbus_dev_error
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|_dev_error
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_dev_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|xenbus_dev_fatal
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|_dev_error
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|xenbus_switch_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosing
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_dev_fatal
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|xenbus_grant_ring
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|ring_mfn
parameter_list|)
block|{
name|int
name|err
init|=
name|gnttab_grant_foreign_access
argument_list|(
name|dev
operator|->
name|otherend_id
argument_list|,
name|ring_mfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"granting access to ring page"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_grant_ring
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|xenbus_alloc_evtchn
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|int
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|evtchn_alloc_unbound
name|alloc_unbound
decl_stmt|;
name|int
name|err
decl_stmt|;
name|alloc_unbound
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|alloc_unbound
operator|.
name|remote_dom
operator|=
name|dev
operator|->
name|otherend_id
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_alloc_unbound
argument_list|,
operator|&
name|alloc_unbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"allocating event channel"
argument_list|)
expr_stmt|;
else|else
operator|*
name|port
operator|=
name|alloc_unbound
operator|.
name|port
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_alloc_evtchn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|xenbus_free_evtchn
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|evtchn_close
name|close
decl_stmt|;
name|int
name|err
decl_stmt|;
name|close
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
name|EVTCHNOP_close
argument_list|,
operator|&
name|close
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|xenbus_dev_error
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"freeing event channel %d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_free_evtchn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|XenbusState
name|xenbus_read_driver_state
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|XenbusState
name|result
decl_stmt|;
name|int
name|err
init|=
name|xenbus_gather
argument_list|(
name|XBT_NIL
argument_list|,
name|path
argument_list|,
literal|"state"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|result
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
name|result
operator|=
name|XenbusStateClosed
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_read_driver_state
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Local variables:  *  c-file-style: "linux"  *  indent-tabs-mode: t  *  c-indent-level: 8  *  c-basic-offset: 8  *  tab-width: 8  * End:  */
end_comment

end_unit

