begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * Talks to Xen Store to figure out what devices we have.  *  * Copyright (C) 2009, 2010 Spectra Logic Corporation  * Copyright (C) 2008 Doug Rabson  * Copyright (C) 2005 Rusty Russell, IBM Corporation  * Copyright (C) 2005 Mike Wray, Hewlett-Packard  * Copyright (C) 2005 XenSource Ltd  *   * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_comment
comment|/**  * \file xenbusb_back.c  *  * XenBus management of the NewBus bus containing the backend instances of  * Xen split devices.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusb.h>
end_include

begin_comment
comment|/*------------------ Private Device Attachment Functions  --------------------*/
end_comment

begin_comment
comment|/**  * \brief Probe for the existance of the XenBus back bus.  *  * \param dev  NewBus device_t for this XenBus back bus instance.  *  * \return  Always returns 0 indicating success.  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_back_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Xen Backend Devices"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Attach the XenBus back bus.  *  * \param dev  NewBus device_t for this XenBus back bus instance.  *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_back_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbusb_attach
argument_list|(
name|dev
argument_list|,
literal|"backend"
argument_list|,
comment|/*id_components*/
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Backend devices operate to serve other domains, 	 * so there is no need to hold up boot processing 	 * while connections to foreign domains are made. 	 */
name|mtx_lock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xbs
operator|->
name|xbs_flags
operator|&
name|XBS_ATTACH_CH_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|xbs
operator|->
name|xbs_flags
operator|&=
operator|~
name|XBS_ATTACH_CH_ACTIVE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_attach_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Enumerate all devices of the given type on this bus.  *  * \param dev   NewBus device_t for this XenBus backend bus instance.  * \param type  String indicating the device sub-tree (e.g. "vfb", "vif")  *              to enumerate.   *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  *  * Devices that are found are entered into the NewBus hierarchy via  * xenbusb_add_device().  xenbusb_add_device() ignores duplicate detects  * and ignores duplicate devices, so it can be called unconditionally  * for any device found in the XenStore.  *  * The backend XenStore hierarchy has the following format:  *  *     backend/<device type>/<frontend vm id>/<device id>  *  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_back_enumerate_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|vms
decl_stmt|;
name|u_int
name|vm_idx
decl_stmt|;
name|u_int
name|vm_count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_directory
argument_list|(
name|XST_NIL
argument_list|,
name|xbs
operator|->
name|xbs_node
argument_list|,
name|type
argument_list|,
operator|&
name|vm_count
argument_list|,
operator|&
name|vms
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|vm_idx
operator|=
literal|0
init|;
name|vm_idx
operator|<
name|vm_count
condition|;
name|vm_idx
operator|++
control|)
block|{
name|struct
name|sbuf
modifier|*
name|vm_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|vm
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|devs
decl_stmt|;
name|u_int
name|dev_idx
decl_stmt|;
name|u_int
name|dev_count
decl_stmt|;
name|vm
operator|=
name|vms
index|[
name|vm_idx
index|]
expr_stmt|;
name|vm_path
operator|=
name|xs_join
argument_list|(
name|type
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|error
operator|=
name|xs_directory
argument_list|(
name|XST_NIL
argument_list|,
name|xbs
operator|->
name|xbs_node
argument_list|,
name|sbuf_data
argument_list|(
name|vm_path
argument_list|)
argument_list|,
operator|&
name|dev_count
argument_list|,
operator|&
name|devs
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|vm_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
for|for
control|(
name|dev_idx
operator|=
literal|0
init|;
name|dev_idx
operator|<
name|dev_count
condition|;
name|dev_idx
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|dev_num
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|id
decl_stmt|;
name|dev_num
operator|=
name|devs
index|[
name|dev_idx
index|]
expr_stmt|;
name|id
operator|=
name|xs_join
argument_list|(
name|vm
argument_list|,
name|dev_num
argument_list|)
expr_stmt|;
name|xenbusb_add_device
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|sbuf_data
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devs
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vms
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Determine and store the XenStore path for the other end of  *        a split device whose local end is represented by ivars.  *  * \param dev    NewBus device_t for this XenBus backend bus instance.  * \param ivars  Instance variables from the XenBus child device for  *               which to perform this function.  *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  *  * If successful, the xd_otherend_path field of the child's instance  * variables will be updated.  *  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_back_get_otherend_node
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
parameter_list|)
block|{
name|char
modifier|*
name|otherend_path
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_otherend_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_path
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|xs_gather
argument_list|(
name|XST_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"frontend-id"
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|ivars
operator|->
name|xd_otherend_id
argument_list|,
literal|"frontend"
argument_list|,
name|NULL
argument_list|,
operator|&
name|otherend_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ivars
operator|->
name|xd_otherend_path
operator|=
name|strdup
argument_list|(
name|otherend_path
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_path_len
operator|=
name|strlen
argument_list|(
name|otherend_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|otherend_path
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Backend XenBus method implementing responses to peer state changes.  *   * \param bus       The XenBus bus parent of child.  * \param child     The XenBus child whose peer stat has changed.  * \param state     The current state of the peer.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_back_otherend_changed
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|enum
name|xenbus_state
name|peer_state
parameter_list|)
block|{
comment|/* Perform default processing of state. */
name|xenbusb_otherend_changed
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|peer_state
argument_list|)
expr_stmt|;
comment|/* 	 * "Online" devices are never fully detached in the 	 * newbus sense.  Only the front<->back connection is 	 * torn down.  If the front returns to the initialising 	 * state after closing a previous connection, signal 	 * our willingness to reconnect and that all necessary 	 * XenStore data for feature negotiation is present. 	 */
if|if
condition|(
name|peer_state
operator|==
name|XenbusStateInitialising
operator|&&
name|xenbus_dev_is_online
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
operator|&&
name|xenbus_get_state
argument_list|(
name|child
argument_list|)
operator|==
name|XenbusStateClosed
condition|)
name|xenbus_set_state
argument_list|(
name|child
argument_list|,
name|XenbusStateInitWait
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Backend XenBus method implementing responses to local  *        XenStore changes.  *   * \param bus    The XenBus bus parent of child.  * \param child  The XenBus child whose peer stat has changed.  * \param_path   The tree relative sub-path to the modified node.  The empty  *               string indicates the root of the tree was destroyed.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_back_localend_changed
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|xenbusb_localend_changed
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
literal|"/state"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
literal|"/online"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|xenbus_get_state
argument_list|(
name|child
argument_list|)
operator|!=
name|XenbusStateClosed
operator|||
name|xenbus_dev_is_online
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Cleanup the hotplug entry in the XenStore if 	 * present.  The control domain expects any userland 	 * component associated with this device to destroy 	 * this node in order to signify it is safe to  	 * teardown the device.  However, not all backends 	 * rely on userland components, and those that 	 * do should either use a communication channel 	 * other than the XenStore, or ensure the hotplug 	 * data is already cleaned up. 	 * 	 * This removal ensures that no matter what path 	 * is taken to mark a back-end closed, the control 	 * domain will understand that it is closed. 	 */
name|xs_rm
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"hotplug-status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------- Private Device Attachment Data  -----------------------*/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|xenbusb_back_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|xenbusb_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xenbusb_back_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xenbusb_back_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|xenbusb_resume
argument_list|)
block|,
comment|/* Bus Interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|xenbusb_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|xenbusb_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|xenbusb_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|bus_generic_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
comment|/* XenBus Bus Interface */
name|DEVMETHOD
argument_list|(
name|xenbusb_enumerate_type
argument_list|,
name|xenbusb_back_enumerate_type
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|xenbusb_get_otherend_node
argument_list|,
name|xenbusb_back_get_otherend_node
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|xenbusb_otherend_changed
argument_list|,
name|xenbusb_back_otherend_changed
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|xenbusb_localend_changed
argument_list|,
name|xenbusb_back_localend_changed
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|xenbusb_back
argument_list|,
name|xenbusb_back_driver
argument_list|,
name|xenbusb_back_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xenbusb_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|devclass_t
name|xenbusb_back_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xenbusb_back
argument_list|,
name|xenstore
argument_list|,
name|xenbusb_back_driver
argument_list|,
name|xenbusb_back_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

