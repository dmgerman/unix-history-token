begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * Talks to Xen Store to figure out what devices we have.  *  * Copyright (C) 2005 Rusty Russell, IBM Corporation  * Copyright (C) 2005 Mike Wray, Hewlett-Packard  * Copyright (C) 2005 XenSource Ltd  *   * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("xenbus_probe (%s:%d) " fmt ".\n", __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbus_comms.h>
end_include

begin_decl_stmt
name|struct
name|xendev_list_head
name|xenbus_device_frontend_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xendev_list_head
name|xenbus_device_backend_list
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|xenbus_driver
argument_list|)
name|xendrv_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sx
name|xenwatch_mutex
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EVENTHANDLER_DECLARE
argument_list|(
name|xenstore_event
argument_list|,
name|xenstore_event_handler_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|eventhandler_list
modifier|*
name|xenstore_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|device_t
name|xenbus_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|device_t
name|xenbus_backend_dev
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_XENDEV
argument_list|,
literal|"xenintrdrv"
argument_list|,
literal|"xen system device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp((a), (b)) == 0)
end_define

begin_function_decl
specifier|static
name|int
name|watch_otherend
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If something in array of ids matches this device, return it. */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|match_device
parameter_list|(
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|arr
parameter_list|,
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
for|for
control|(
init|;
operator|!
name|streq
argument_list|(
name|arr
operator|->
name|devicetype
argument_list|,
literal|""
argument_list|)
condition|;
name|arr
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|arr
operator|->
name|devicetype
argument_list|,
name|dev
operator|->
name|devicetype
argument_list|)
condition|)
return|return
name|arr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int xenbus_match(device_t _dev) { 	struct xenbus_driver *drv;  	struct xenbus_device *dev;  	dev = device_get_softc(_dev); 	drv = dev->driver;  	if (!drv->ids) 		return 0;  	return match_device(drv->ids, to_xenbus_device(_dev)) != NULL; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* device/<type>/<id> =><type>-<id> */
end_comment

begin_function
specifier|static
name|int
name|frontend_bus_id
parameter_list|(
name|char
name|bus_id
index|[
name|BUS_ID_SIZE
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|)
block|{
name|nodename
operator|=
name|strchr
argument_list|(
name|nodename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodename
operator|||
name|strlen
argument_list|(
name|nodename
operator|+
literal|1
argument_list|)
operator|>=
name|BUS_ID_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENBUS: bad frontend %s\n"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|strlcpy
argument_list|(
name|bus_id
argument_list|,
name|nodename
operator|+
literal|1
argument_list|,
name|BUS_ID_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|bus_id
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENBUS: bus_id %s no slash\n"
argument_list|,
name|bus_id
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
operator|*
name|strchr
argument_list|(
name|bus_id
argument_list|,
literal|'/'
argument_list|)
operator|=
literal|'-'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_otherend_details
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|kfree
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|dev
operator|->
name|otherend
argument_list|)
expr_stmt|;
name|dev
operator|->
name|otherend
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_otherend_watch
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|otherend_watch
operator|.
name|node
condition|)
block|{
name|unregister_xenbus_watch
argument_list|(
operator|&
name|dev
operator|->
name|otherend_watch
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|otherend_watch
operator|.
name|node
argument_list|)
expr_stmt|;
name|dev
operator|->
name|otherend_watch
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|read_otherend_details
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xendev
parameter_list|,
name|char
modifier|*
name|id_node
parameter_list|,
name|char
modifier|*
name|path_node
parameter_list|)
block|{
name|int
name|err
init|=
name|xenbus_gather
argument_list|(
name|XBT_NIL
argument_list|,
name|xendev
operator|->
name|nodename
argument_list|,
name|id_node
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|xendev
operator|->
name|otherend_id
argument_list|,
name|path_node
argument_list|,
name|NULL
argument_list|,
operator|&
name|xendev
operator|->
name|otherend
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xendev
argument_list|,
name|err
argument_list|,
literal|"reading other end details from %s"
argument_list|,
name|xendev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|xendev
operator|->
name|otherend
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|xenbus_exists
argument_list|(
name|XBT_NIL
argument_list|,
name|xendev
operator|->
name|otherend
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xendev
argument_list|,
operator|-
name|ENOENT
argument_list|,
literal|"missing other end from %s"
argument_list|,
name|xendev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|xendev
operator|->
name|otherend
argument_list|)
expr_stmt|;
name|xendev
operator|->
name|otherend
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|ENOENT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_backend_details
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xendev
parameter_list|)
block|{
return|return
name|read_otherend_details
argument_list|(
name|xendev
argument_list|,
literal|"backend-id"
argument_list|,
literal|"backend"
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/* XXX - move to probe backend */
end_comment

begin_function
specifier|static
name|int
name|read_frontend_details
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xendev
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|xendev
operator|->
name|nodename
argument_list|,
literal|"backend"
argument_list|,
literal|7
argument_list|)
condition|)
return|return
operator|-
name|ENOENT
return|;
return|return
name|read_otherend_details
argument_list|(
name|xendev
argument_list|,
literal|"frontend-id"
argument_list|,
literal|"frontend"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bus type for frontend drivers. */
end_comment

begin_function_decl
specifier|static
name|int
name|xenbus_probe_frontend
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|xen_bus_type
name|xenbus_frontend
init|=
block|{
operator|.
name|root
operator|=
literal|"device"
block|,
operator|.
name|levels
operator|=
literal|2
block|,
comment|/* device/type/<id> */
operator|.
name|get_bus_id
operator|=
name|frontend_bus_id
block|,
operator|.
name|probe
operator|=
name|xenbus_probe_frontend
block|,
operator|.
name|bus
operator|=
operator|&
name|xenbus_device_frontend_list
block|,
if|#
directive|if
literal|0
comment|/* this initialization needs to happen dynamically */
block|.bus = { 		.name  = "xen", 		.match = xenbus_match, 	}, 	.dev = { 		.bus_id = "xen", 	},
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|static int xenbus_hotplug_backend(device_t dev, char **envp, 				  int num_envp, char *buffer, int buffer_size) { 	panic("implement me");
if|#
directive|if
literal|0
end_if

begin_comment
unit|struct xenbus_device *xdev; 	struct xenbus_driver *drv = NULL; 	int i = 0; 	int length = 0; 	char *basepath_end; 	char *frontend_id;  	DPRINTK("");  	if (dev == NULL) 		return -ENODEV;  	xdev = to_xenbus_device(dev); 	if (xdev == NULL) 		return -ENODEV;  	if (dev->driver) 		drv = to_xenbus_driver(dev->driver);
comment|/* stuff we want to pass to /sbin/hotplug */
end_comment

begin_comment
unit|add_hotplug_env_var(envp, num_envp,&i, 			    buffer, buffer_size,&length, 			    "XENBUS_TYPE=%s", xdev->devicetype);  	add_hotplug_env_var(envp, num_envp,&i, 			    buffer, buffer_size,&length, 			    "XENBUS_PATH=%s", xdev->nodename);  	add_hotplug_env_var(envp, num_envp,&i, 			    buffer, buffer_size,&length, 			    "XENBUS_BASE_PATH=%s", xdev->nodename);  	basepath_end = strrchr(envp[i - 1], '/'); 	length -= strlen(basepath_end); 	*basepath_end = '\0'; 	basepath_end = strrchr(envp[i - 1], '/'); 	length -= strlen(basepath_end); 	*basepath_end = '\0';  	basepath_end++; 	frontend_id = kmalloc(strlen(basepath_end) + 1, GFP_KERNEL); 	strcpy(frontend_id, basepath_end); 	add_hotplug_env_var(envp, num_envp,&i, 			    buffer, buffer_size,&length, 			    "XENBUS_FRONTEND_ID=%s", frontend_id); 	kfree(frontend_id);
comment|/* terminate, set to next free slot, shrink available space */
end_comment

begin_endif
unit|envp[i] = NULL; 	envp =&envp[i]; 	num_envp -= i; 	buffer =&buffer[length]; 	buffer_size -= length;  	if (drv&& drv->hotplug) 		return drv->hotplug(xdev, envp, num_envp, buffer, buffer_size);
endif|#
directive|endif
end_endif

begin_endif
unit|return 0; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int xenbus_probe_backend(const char *type, const char *domid, int unit); static struct xen_bus_type xenbus_backend = { 	.root = "backend", 	.levels = 3,
comment|/* backend/type/<frontend>/<id> */
end_comment

begin_comment
unit|.get_bus_id = backend_bus_id, 	.probe = xenbus_probe_backend,
comment|/* at init time */
end_comment

begin_if
unit|.bus =&xenbus_device_backend_list,
if|#
directive|if
literal|0
end_if

begin_endif
unit|.bus = { 		.name  = "xen-backend", 		.match = xenbus_match, 		.hotplug = xenbus_hotplug_backend, 	}, 	.dev = { 		.bus_id = "xen-backend", 	},
endif|#
directive|endif
end_endif

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|otherend_changed
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|xenbus_device
modifier|*
name|dev
init|=
operator|(
expr|struct
name|xenbus_device
operator|*
operator|)
name|watch
decl_stmt|;
name|struct
name|xenbus_driver
modifier|*
name|drv
init|=
name|dev
operator|->
name|driver
decl_stmt|;
name|XenbusState
name|state
decl_stmt|;
comment|/* Protect us against watches firing on old details when the otherend 	   details change, say immediately after a resume. */
if|if
condition|(
operator|!
name|dev
operator|->
name|otherend
operator|||
name|strncmp
argument_list|(
name|dev
operator|->
name|otherend
argument_list|,
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|,
name|strlen
argument_list|(
name|dev
operator|->
name|otherend
argument_list|)
argument_list|)
condition|)
block|{
name|DPRINTK
argument_list|(
literal|"Ignoring watch at %s"
argument_list|,
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|=
name|xenbus_read_driver_state
argument_list|(
name|dev
operator|->
name|otherend
argument_list|)
expr_stmt|;
name|DPRINTK
argument_list|(
literal|"state is %d, %s, %s"
argument_list|,
name|state
argument_list|,
name|dev
operator|->
name|otherend_watch
operator|.
name|node
argument_list|,
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore xenbus transitions during shutdown. This prevents us doing 	 * work that can fail e.g., when the rootfs is gone. 	 */
if|#
directive|if
literal|0
block|if (system_state> SYSTEM_RUNNING) { 		struct xen_bus_type *bus = bus; 		bus = container_of(dev->dev.bus, struct xen_bus_type, bus);
comment|/* If we're frontend, drive the state machine to Closed. */
comment|/* This should cause the backend to release our resources. */
block|if ((bus ==&xenbus_frontend)&& (state == XenbusStateClosing)) 			xenbus_frontend_closed(dev); 		return; 	}
endif|#
directive|endif
if|if
condition|(
name|drv
operator|->
name|otherend_changed
condition|)
name|drv
operator|->
name|otherend_changed
argument_list|(
name|dev
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|talk_to_otherend
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|xenbus_driver
modifier|*
name|drv
decl_stmt|;
name|drv
operator|=
name|dev
operator|->
name|driver
expr_stmt|;
name|free_otherend_watch
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free_otherend_details
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|drv
operator|->
name|read_otherend_details
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_otherend
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|xenbus_watch_path2
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|otherend
argument_list|,
literal|"state"
argument_list|,
operator|&
name|dev
operator|->
name|otherend_watch
argument_list|,
name|otherend_changed
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_dev_probe
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|xenbus_driver
modifier|*
name|drv
init|=
name|dev
operator|->
name|driver
decl_stmt|;
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|id
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drv
operator|->
name|probe
condition|)
block|{
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|id
operator|=
name|match_device
argument_list|(
name|drv
operator|->
name|ids
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
block|{
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|err
operator|=
name|talk_to_otherend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"xenbus_probe: talk_to_otherend on %s failed.\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|drv
operator|->
name|probe
argument_list|(
name|dev
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fail
goto|;
name|err
operator|=
name|watch_otherend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"xenbus_probe: watch_otherend on %s failed.\n"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
name|fail
label|:
name|xenbus_dev_error
argument_list|(
name|dev
argument_list|,
name|err
argument_list|,
literal|"xenbus_dev_probe on %s"
argument_list|,
name|dev
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|xenbus_switch_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_dev_free
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xendev
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|xendev
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|xendev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xenbus_remove_device
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|xenbus_driver
modifier|*
name|drv
init|=
name|dev
operator|->
name|driver
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free_otherend_watch
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free_otherend_details
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv
operator|->
name|remove
condition|)
name|drv
operator|->
name|remove
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xenbus_switch_state
argument_list|(
name|dev
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv
operator|->
name|cleanup_device
condition|)
return|return
name|drv
operator|->
name|cleanup_device
argument_list|(
name|dev
argument_list|)
return|;
name|xenbus_dev_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int  xenbus_dev_remove(device_t _dev) { 	return xenbus_remove_device(to_xenbus_device(_dev)); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|xenbus_register_driver_common
parameter_list|(
name|struct
name|xenbus_driver
modifier|*
name|drv
parameter_list|,
name|struct
name|xen_bus_type
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
if|#
directive|if
literal|0
block|int ret;
comment|/* this all happens in the driver itself  	 * doing this here simple serves to obfuscate 	 */
block|drv->driver.name = drv->name; 	drv->driver.bus =&bus->bus; 	drv->driver.owner = drv->owner; 	drv->driver.probe = xenbus_dev_probe; 	drv->driver.remove = xenbus_dev_remove;  	return ret;
endif|#
directive|endif
name|sx_xlock
argument_list|(
operator|&
name|xenwatch_mutex
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|xendrv_list
argument_list|,
name|drv
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|xenwatch_mutex
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|xdev
argument_list|,
argument|bus->bus
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|match_device
argument_list|(
name|drv
operator|->
name|ids
argument_list|,
name|xdev
argument_list|)
condition|)
block|{
name|xdev
operator|->
name|driver
operator|=
name|drv
expr_stmt|;
name|xenbus_dev_probe
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xenbus_register_frontend
parameter_list|(
name|struct
name|xenbus_driver
modifier|*
name|drv
parameter_list|)
block|{
name|drv
operator|->
name|read_otherend_details
operator|=
name|read_backend_details
expr_stmt|;
return|return
name|xenbus_register_driver_common
argument_list|(
name|drv
argument_list|,
operator|&
name|xenbus_frontend
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_register_frontend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|xenbus_unregister_driver
parameter_list|(
name|struct
name|xenbus_driver
modifier|*
name|drv
parameter_list|)
block|{
if|#
directive|if
literal|0
block|driver_unregister(&drv->driver);
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_unregister_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|xb_find_info
block|{
name|struct
name|xenbus_device
modifier|*
name|dev
decl_stmt|;
specifier|const
name|char
modifier|*
name|nodename
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|xenbus_device
modifier|*
name|xenbus_device_find
parameter_list|(
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
name|struct
name|xendev_list_head
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|xdev
argument_list|,
argument|bus
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|xdev
operator|->
name|nodename
argument_list|,
name|nodename
argument_list|)
condition|)
block|{
return|return
name|xdev
return|;
if|#
directive|if
literal|0
block|get_device(dev);
endif|#
directive|endif
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|static int cleanup_dev(device_t dev, void *data) { 	struct xenbus_device *xendev = device_get_softc(dev); 	struct xb_find_info *info = data; 	int len = strlen(info->nodename);  	DPRINTK("%s", info->nodename);  	if (!strncmp(xendev->nodename, info->nodename, len)) { 		info->dev = xendev;
if|#
directive|if
literal|0
end_if

begin_endif
unit|get_device(dev);
endif|#
directive|endif
end_endif

begin_endif
unit|return 1; 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|xenbus_cleanup_devices
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|xendev_list_head
modifier|*
name|bus
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct xb_find_info info = { .nodename = path };  	do { 		info.dev = NULL; 		bus_for_each_dev(bus, NULL,&info, cleanup_dev); 		if (info.dev) { 			device_unregister(&info.dev->dev); 			put_device(&info.dev->dev); 		} 	} while (info.dev);
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void xenbus_dev_release(device_t dev) {
comment|/*  	 * nothing to do softc gets freed with the device 	 */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* Simplified asprintf. */
end_comment

begin_function
name|char
modifier|*
name|kasprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* FIXME: vsnprintf has a bug, NULL should work */
name|len
operator|=
name|vsnprintf
argument_list|(
name|dummy
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p
operator|=
name|kmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static ssize_t xendev_show_nodename(struct device *dev, char *buf) { 	return sprintf(buf, "%s\n", to_xenbus_device(dev)->nodename); } DEVICE_ATTR(nodename, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_nodename, NULL);  static ssize_t xendev_show_devtype(struct device *dev, char *buf) { 	return sprintf(buf, "%s\n", to_xenbus_device(dev)->devicetype); } DEVICE_ATTR(devtype, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_devtype, NULL);
endif|#
directive|endif
end_endif

begin_function
name|int
name|xenbus_probe_node
parameter_list|(
name|struct
name|xen_bus_type
modifier|*
name|bus
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|)
block|{
define|#
directive|define
name|CHECK_FAIL
define|\
value|do {					\ 		if (err)			\ 			goto fail;		\ 	} while (0)				\    	int err;
name|struct
name|xenbus_device
modifier|*
name|xendev
decl_stmt|;
name|struct
name|xenbus_driver
modifier|*
name|xdrv
decl_stmt|;
name|size_t
name|stringlen
decl_stmt|;
name|char
modifier|*
name|tmpstring
decl_stmt|;
name|XenbusState
name|state
init|=
name|xenbus_read_driver_state
argument_list|(
name|nodename
argument_list|)
decl_stmt|;
if|if
condition|(
name|bus
operator|->
name|error
condition|)
return|return
operator|(
name|bus
operator|->
name|error
operator|)
return|;
if|if
condition|(
name|state
operator|!=
name|XenbusStateInitialising
condition|)
block|{
comment|/* Device is not new, so ignore it.  This can happen if a 		   device is going away after switching to Closed.  */
return|return
literal|0
return|;
block|}
name|stringlen
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xendev
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xendev
argument_list|)
operator|+
name|stringlen
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xendev
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|memset
argument_list|(
name|xendev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xendev
argument_list|)
argument_list|)
expr_stmt|;
name|xendev
operator|->
name|state
operator|=
name|XenbusStateInitialising
expr_stmt|;
comment|/* Copy the strings into the extra space. */
name|tmpstring
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xendev
operator|+
literal|1
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpstring
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
name|xendev
operator|->
name|nodename
operator|=
name|tmpstring
expr_stmt|;
name|tmpstring
operator|+=
name|strlen
argument_list|(
name|tmpstring
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|tmpstring
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|xendev
operator|->
name|devicetype
operator|=
name|tmpstring
expr_stmt|;
comment|/* 	 * equivalent to device registration  	 * events 	 */
name|LIST_INSERT_HEAD
argument_list|(
name|bus
operator|->
name|bus
argument_list|,
name|xendev
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|xdrv
argument_list|,
argument|&xendrv_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|match_device
argument_list|(
name|xdrv
operator|->
name|ids
argument_list|,
name|xendev
argument_list|)
condition|)
block|{
name|xendev
operator|->
name|driver
operator|=
name|xdrv
expr_stmt|;
if|if
condition|(
operator|!
name|xenbus_dev_probe
argument_list|(
name|xendev
argument_list|)
condition|)
break|break;
block|}
block|}
if|#
directive|if
literal|0
block|xendev->dev.parent =&bus->dev; 	xendev->dev.bus =&bus->bus; 	xendev->dev.release = xenbus_dev_release; 	 	err = bus->get_bus_id(xendev->dev.bus_id, xendev->nodename); 	CHECK_FAIL;
comment|/* Register with generic device framework. */
block|err = device_register(&xendev->dev); 	CHECK_FAIL; 	 	device_create_file(&xendev->dev,&dev_attr_nodename); 	device_create_file(&xendev->dev,&dev_attr_devtype);
endif|#
directive|endif
return|return
literal|0
return|;
undef|#
directive|undef
name|CHECK_FAIL
if|#
directive|if
literal|0
block|fail: 	xenbus_dev_free(xendev);
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* device/<typename>/<name> */
end_comment

begin_function
specifier|static
name|int
name|xenbus_probe_frontend
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|nodename
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nodename
operator|=
name|kasprintf
argument_list|(
literal|"%s/%s/%s"
argument_list|,
name|xenbus_frontend
operator|.
name|root
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodename
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|DPRINTK
argument_list|(
literal|"%s"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
name|err
operator|=
name|xenbus_probe_node
argument_list|(
operator|&
name|xenbus_frontend
argument_list|,
name|type
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_probe_device_type
parameter_list|(
name|struct
name|xen_bus_type
modifier|*
name|bus
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|dir
decl_stmt|;
name|unsigned
name|int
name|dir_n
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dir
operator|=
name|xenbus_directory
argument_list|(
name|XBT_NIL
argument_list|,
name|bus
operator|->
name|root
argument_list|,
name|type
argument_list|,
operator|&
name|dir_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|dir
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir_n
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus
operator|->
name|probe
argument_list|(
name|type
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|kfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|xenbus_probe_devices
parameter_list|(
name|struct
name|xen_bus_type
modifier|*
name|bus
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|dir
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|dir_n
decl_stmt|;
name|dir
operator|=
name|xenbus_directory
argument_list|(
name|XBT_NIL
argument_list|,
name|bus
operator|->
name|root
argument_list|,
literal|""
argument_list|,
operator|&
name|dir_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|dir
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir_n
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|xenbus_probe_device_type
argument_list|(
name|bus
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|kfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|char_count
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
name|c
condition|)
name|ret
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strsep_len
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
name|c
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|i
return|;
name|len
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|==
literal|0
operator|)
condition|?
name|i
else|:
operator|-
name|ERANGE
return|;
block|}
end_function

begin_function
name|void
name|dev_changed
parameter_list|(
specifier|const
name|char
modifier|*
name|node
parameter_list|,
name|struct
name|xen_bus_type
modifier|*
name|bus
parameter_list|)
block|{
name|int
name|exists
decl_stmt|,
name|rootlen
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|dev
decl_stmt|;
name|char
name|type
index|[
name|BUS_ID_SIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|root
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
argument_list|(
name|node
argument_list|,
literal|'/'
argument_list|)
operator|<
literal|2
condition|)
return|return;
name|exists
operator|=
name|xenbus_exists
argument_list|(
name|XBT_NIL
argument_list|,
name|node
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|xenbus_cleanup_devices
argument_list|(
name|node
argument_list|,
name|bus
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* backend/<type>/... or device/<type>/... */
name|p
operator|=
name|strchr
argument_list|(
name|node
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|type
argument_list|,
name|BUS_ID_SIZE
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|type
index|[
name|BUS_ID_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rootlen
operator|=
name|strsep_len
argument_list|(
name|node
argument_list|,
literal|'/'
argument_list|,
name|bus
operator|->
name|levels
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootlen
operator|<
literal|0
condition|)
return|return;
name|root
operator|=
name|kasprintf
argument_list|(
literal|"%.*s"
argument_list|,
name|rootlen
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return;
name|dev
operator|=
name|xenbus_device_find
argument_list|(
name|root
argument_list|,
name|bus
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
name|xenbus_probe_node
argument_list|(
name|bus
argument_list|,
name|type
argument_list|,
name|root
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else 		put_device(&dev->dev);
endif|#
directive|endif
name|kfree
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|frontend_changed
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dev_changed
argument_list|(
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|,
operator|&
name|xenbus_frontend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We watch for devices appearing and vanishing. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xenbus_watch
name|fe_watch
init|=
block|{
operator|.
name|node
operator|=
literal|"device"
block|,
operator|.
name|callback
operator|=
name|frontend_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|suspend_dev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|xenbus_driver
modifier|*
name|drv
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|xdev
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drv
operator|=
name|xdev
operator|->
name|driver
expr_stmt|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|drv
operator|->
name|suspend
condition|)
name|err
operator|=
name|drv
operator|->
name|suspend
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* bus_id ? */
block|if (err) 			log(LOG_WARNING, "xenbus: suspend %s failed: %i\n",  		       dev->bus_id, err);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_dev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|xenbus_driver
modifier|*
name|drv
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|xdev
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|drv
operator|=
name|xdev
operator|->
name|driver
expr_stmt|;
name|err
operator|=
name|talk_to_otherend
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (err) { 			log(LOG_WARNING, 			   "xenbus: resume (talk_to_otherend) %s failed: %i\n", 			   dev->bus_id, err); 		return err; 	}
endif|#
directive|endif
if|if
condition|(
name|drv
operator|->
name|resume
condition|)
name|err
operator|=
name|drv
operator|->
name|resume
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|watch_otherend
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* bus_id? */
block|if (err) 			log(LOG_WARNING, 			   "xenbus: resume %s failed: %i\n", dev->bus_id, err);
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|xenbus_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"implement me"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_for_each_dev(&xenbus_frontend.bus, NULL, NULL, suspend_dev); 	bus_for_each_dev(&xenbus_backend.bus, NULL, NULL, suspend_dev);
endif|#
directive|endif
name|xs_suspend
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_suspend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|xenbus_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|xb_init_comms
argument_list|()
expr_stmt|;
name|xs_resume
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"implement me"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_for_each_dev(&xenbus_frontend.bus, NULL, NULL, resume_dev); 	bus_for_each_dev(&xenbus_backend.bus, NULL, NULL, resume_dev);
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|xenbus_resume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static device_t  xenbus_add_child(device_t bus, int order, const char *name, int unit)  {  	device_t child;   	child = device_add_child_ordered(bus, order, name, unit);       	return(child);  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* A flag to determine if xenstored is 'ready' (i.e. has started) */
end_comment

begin_decl_stmt
name|int
name|xenstored_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|register_xenstore_notifier
parameter_list|(
name|xenstore_event_handler_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|xenstored_ready
operator|>
literal|0
condition|)
name|ret
operator|=
name|func
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|eventhandler_register
argument_list|(
name|xenstore_chain
argument_list|,
literal|"xenstore"
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|register_xenstore_notifier
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void unregister_xenstore_notifier(struct notifier_block *nb) { 	notifier_chain_unregister(&xenstore_chain, nb); } EXPORT_SYMBOL(unregister_xenstore_notifier);
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DOM0
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|proc_dir_entry
modifier|*
name|xsd_mfn_intf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc_dir_entry
modifier|*
name|xsd_port_intf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xsd_mfn_read
parameter_list|(
name|char
modifier|*
name|page
parameter_list|,
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|eof
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|page
argument_list|,
literal|"%ld"
argument_list|,
name|xen_start_info
operator|->
name|store_mfn
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xsd_port_read
parameter_list|(
name|char
modifier|*
name|page
parameter_list|,
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|eof
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|page
argument_list|,
literal|"%d"
argument_list|,
name|xen_start_info
operator|->
name|store_evtchn
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|xenbus_probe_sysinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|dom0
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|xenbus_device_frontend_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|xenbus_device_backend_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|xendrv_list
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (xen_init()< 0) { 		DPRINTK("failed"); 		return -ENODEV; 	}
comment|/* Register ourselves with the kernel bus& device subsystems */
block|bus_register(&xenbus_frontend.bus); 	bus_register(&xenbus_backend.bus); 	device_register(&xenbus_frontend.dev); 	device_register(&xenbus_backend.dev);
endif|#
directive|endif
comment|/* 	** Domain0 doesn't have a store_evtchn or store_mfn yet. 	*/
name|dom0
operator|=
operator|(
name|xen_start_info
operator|->
name|store_evtchn
operator|==
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOM0
if|if
condition|(
name|dom0
condition|)
block|{
name|unsigned
name|long
name|page
decl_stmt|;
name|evtchn_op_t
name|op
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Allocate page. */
name|page
operator|=
name|get_zeroed_page
argument_list|(
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* We don't refcnt properly, so set reserved on page. 		 * (this allocation is permanent) */
name|SetPageReserved
argument_list|(
name|virt_to_page
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
name|xen_start_info
operator|->
name|store_mfn
operator|=
name|pfn_to_mfn
argument_list|(
name|virt_to_phys
argument_list|(
operator|(
name|void
operator|*
operator|)
name|page
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
comment|/* Next allocate a local port which xenstored can bind to */
name|op
operator|.
name|cmd
operator|=
name|EVTCHNOP_alloc_unbound
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|alloc_unbound
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|alloc_unbound
operator|.
name|remote_dom
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
operator|&
name|op
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|xen_start_info
operator|->
name|store_evtchn
operator|=
name|op
operator|.
name|u
operator|.
name|alloc_unbound
operator|.
name|port
expr_stmt|;
comment|/* And finally publish the above info in /proc/xen */
if|if
condition|(
operator|(
name|xsd_mfn_intf
operator|=
name|create_xen_proc_entry
argument_list|(
literal|"xsd_mfn"
argument_list|,
literal|0400
argument_list|)
operator|)
condition|)
name|xsd_mfn_intf
operator|->
name|read_proc
operator|=
name|xsd_mfn_read
expr_stmt|;
if|if
condition|(
operator|(
name|xsd_port_intf
operator|=
name|create_xen_proc_entry
argument_list|(
literal|"xsd_port"
argument_list|,
literal|0400
argument_list|)
operator|)
condition|)
name|xsd_port_intf
operator|->
name|read_proc
operator|=
name|xsd_port_read
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the interface to xenstore. */
name|err
operator|=
name|xs_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENBUS: Error initializing xenstore comms: %i\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|!
name|dom0
condition|)
block|{
name|xenstored_ready
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|xenbus_dev = BUS_ADD_CHILD(parent, 0, "xenbus", 0); 		if (xenbus_dev == NULL) 			panic("xenbus: could not attach");  		xenbus_backend_dev = BUS_ADD_CHILD(parent, 0, "xb_be", 0); 		if (xenbus_backend_dev == NULL) 			panic("xenbus: could not attach");
endif|#
directive|endif
name|BUG_ON
argument_list|(
operator|(
name|xenstored_ready
operator|<=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Enumerate devices in xenstore. */
name|xenbus_probe_devices
argument_list|(
operator|&
name|xenbus_frontend
argument_list|)
expr_stmt|;
name|register_xenbus_watch
argument_list|(
operator|&
name|fe_watch
argument_list|)
expr_stmt|;
name|xenbus_backend_probe_and_watch
argument_list|()
expr_stmt|;
comment|/* Notify others that xenstore is up */
name|EVENTHANDLER_INVOKE
argument_list|(
name|xenstore_event
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|xenbus_probe_sysinit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|xenbus_probe_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static device_method_t xenbus_methods[] = {
comment|/* Device interface */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|DEVMETHOD(device_identify,      xenbus_identify),  	DEVMETHOD(device_probe,         xenbus_probe),  	DEVMETHOD(device_attach,        xenbus_attach),   	DEVMETHOD(device_detach,        bus_generic_detach),  	DEVMETHOD(device_shutdown,      bus_generic_shutdown),
endif|#
directive|endif
end_endif

begin_comment
unit|DEVMETHOD(device_suspend,       xenbus_suspend),  	DEVMETHOD(device_resume,        xenbus_resume),
comment|/* Bus interface */
end_comment

begin_if
unit|DEVMETHOD(bus_print_child,      bus_generic_print_child), 	DEVMETHOD(bus_add_child,        xenbus_add_child),  	DEVMETHOD(bus_read_ivar,        bus_generic_read_ivar),  	DEVMETHOD(bus_write_ivar,       bus_generic_write_ivar),
if|#
directive|if
literal|0
end_if

begin_endif
unit|DEVMETHOD(bus_set_resource,     bus_generic_set_resource),  	DEVMETHOD(bus_get_resource,     bus_generic_get_resource),
endif|#
directive|endif
end_endif

begin_if
unit|DEVMETHOD(bus_alloc_resource,   bus_generic_alloc_resource),  	DEVMETHOD(bus_release_resource, bus_generic_release_resource),
if|#
directive|if
literal|0
end_if

begin_endif
unit|DEVMETHOD(bus_delete_resource,  bus_generic_delete_resource),
endif|#
directive|endif
end_endif

begin_endif
unit|DEVMETHOD(bus_activate_resource, bus_generic_activate_resource),  	DEVMETHOD(bus_deactivate_resource, bus_generic_deactivate_resource),  	DEVMETHOD(bus_setup_intr,       bus_generic_setup_intr),  	DEVMETHOD(bus_teardown_intr,    bus_generic_teardown_intr),    	{ 0, 0 }  };   static char driver_name[] = "xenbus"; static driver_t xenbus_driver = {  	driver_name,  	xenbus_methods,  	sizeof(struct xenbus_device),                       };  devclass_t xenbus_devclass;    DRIVER_MODULE(xenbus, nexus, xenbus_driver, xenbus_devclass, 0, 0);
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local variables:  *  c-file-style: "bsd"  *  indent-tabs-mode: t  *  c-indent-level: 4  *  c-basic-offset: 8  *  tab-width: 4  * End:  */
end_comment

end_unit

