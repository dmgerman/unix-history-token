begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * Talks to Xen Store to figure out what devices we have.  *  * Copyright (C) 2008 Doug Rabson  * Copyright (C) 2005 Rusty Russell, IBM Corporation  * Copyright (C) 2005 Mike Wray, Hewlett-Packard  * Copyright (C) 2005 XenSource Ltd  *   * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("xenbus_probe (%s:%d) " fmt ".\n", __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTK
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbus_comms.h>
end_include

begin_struct
struct|struct
name|xenbus_softc
block|{
name|struct
name|xenbus_watch
name|xs_devicewatch
decl_stmt|;
name|struct
name|task
name|xs_probechildren
decl_stmt|;
name|struct
name|intr_config_hook
name|xs_attachcb
decl_stmt|;
name|device_t
name|xs_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xenbus_device_ivars
block|{
name|struct
name|xenbus_watch
name|xd_otherend_watch
decl_stmt|;
comment|/* must be first */
name|struct
name|sx
name|xd_lock
decl_stmt|;
name|device_t
name|xd_dev
decl_stmt|;
name|char
modifier|*
name|xd_node
decl_stmt|;
comment|/* node name in xenstore */
name|char
modifier|*
name|xd_type
decl_stmt|;
comment|/* xen device type */
name|enum
name|xenbus_state
name|xd_state
decl_stmt|;
name|int
name|xd_otherend_id
decl_stmt|;
name|char
modifier|*
name|xd_otherend_path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Simplified asprintf. */
end_comment

begin_function
name|char
modifier|*
name|kasprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* FIXME: vsnprintf has a bug, NULL should work */
name|len
operator|=
name|vsnprintf
argument_list|(
name|dummy
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"xenbus"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Initialize the interface to xenstore. */
name|err
operator|=
name|xs_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENBUS: Error initializing xenstore comms: %i\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|err
operator|=
name|gnttab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"XENBUS: Error initializing grant table: %i\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Xen Devices"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xenbus_state
name|xenbus_otherend_state
parameter_list|(
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
parameter_list|)
block|{
return|return
operator|(
name|xenbus_read_driver_state
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_backend_changed
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|enum
name|xenbus_state
name|newstate
decl_stmt|;
name|ivars
operator|=
operator|(
expr|struct
name|xenbus_device_ivars
operator|*
operator|)
name|watch
expr_stmt|;
name|dev
operator|=
name|ivars
operator|->
name|xd_dev
expr_stmt|;
if|if
condition|(
operator|!
name|ivars
operator|->
name|xd_otherend_path
operator|||
name|strncmp
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|,
name|strlen
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
argument_list|)
condition|)
return|return;
name|newstate
operator|=
name|xenbus_otherend_state
argument_list|(
name|ivars
argument_list|)
expr_stmt|;
name|XENBUS_BACKEND_CHANGED
argument_list|(
name|dev
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_device_exists
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|result
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_add_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|bus
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|enum
name|xenbus_state
name|state
decl_stmt|;
name|char
modifier|*
name|statepath
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ivars
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xenbus_device_ivars
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_node
operator|=
name|kasprintf
argument_list|(
literal|"%s/%s/%s"
argument_list|,
name|bus
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|xenbus_device_exists
argument_list|(
name|dev
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|)
condition|)
block|{
comment|/* 		 * We are already tracking this node 		 */
name|free
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivars
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|state
operator|=
name|xenbus_read_driver_state
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|XenbusStateInitialising
condition|)
block|{
comment|/* 		 * Device is not new, so ignore it. This can 		 * happen if a device is going away after 		 * switching to Closed. 		 */
name|free
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivars
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Find the backend details 	 */
name|error
operator|=
name|xenbus_gather
argument_list|(
name|XBT_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"backend-id"
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|ivars
operator|->
name|xd_otherend_id
argument_list|,
literal|"backend"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_init
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|,
literal|"xdlock"
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_type
operator|=
name|strdup
argument_list|(
name|type
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_state
operator|=
name|XenbusStateInitialising
expr_stmt|;
name|statepath
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"/state"
argument_list|)
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|statepath
argument_list|,
literal|"%s/state"
argument_list|,
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|=
name|statepath
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|callback
operator|=
name|xenbus_backend_changed
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_dev
operator|=
name|child
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ivars
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_enumerate_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|bus
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|dir
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xenbus_directory
argument_list|(
name|XBT_NIL
argument_list|,
name|bus
argument_list|,
name|type
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|xenbus_add_device
argument_list|(
name|dev
argument_list|,
name|bus
argument_list|,
name|type
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_enumerate_bus
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|bus
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|dir
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xenbus_directory
argument_list|(
name|XBT_NIL
argument_list|,
name|bus
argument_list|,
literal|""
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|xenbus_enumerate_type
argument_list|(
name|dev
argument_list|,
name|bus
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dir
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_probe_children
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* 	 * Probe any new devices and register watches for any that 	 * attach successfully. Since part of the protocol which 	 * establishes a connection with the other end is interrupt 	 * driven, we sleep until the device reaches a stable state 	 * (closed or connected). 	 */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device_get_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
continue|continue;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|register_xenbus_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ivars
operator|->
name|xd_state
operator|!=
name|XenbusStateClosed
operator|&&
name|ivars
operator|->
name|xd_state
operator|!=
name|XenbusStateConnected
condition|)
name|sx_sleep
argument_list|(
operator|&
name|ivars
operator|->
name|xd_state
argument_list|,
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|,
literal|0
argument_list|,
literal|"xdattach"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_probe_children_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|xenbus_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_devices_changed
parameter_list|(
name|struct
name|xenbus_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|xenbus_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|xenbus_softc
operator|*
operator|)
name|watch
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|xs_dev
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|bus
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|id
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|node
operator|=
name|strdup
argument_list|(
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|node
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|out
goto|;
name|bus
operator|=
name|node
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|type
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|out
goto|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|id
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|xenbus_add_device
argument_list|(
name|dev
argument_list|,
name|bus
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|xs_probechildren
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbus_attach_deferred
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|struct
name|xenbus_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xenbus_enumerate_bus
argument_list|(
name|dev
argument_list|,
literal|"device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|xenbus_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xs_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|xs_devicewatch
operator|.
name|node
operator|=
literal|"device"
expr_stmt|;
name|sc
operator|->
name|xs_devicewatch
operator|.
name|callback
operator|=
name|xenbus_devices_changed
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|xs_probechildren
argument_list|,
literal|0
argument_list|,
name|xenbus_probe_children_cb
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|register_xenbus_watch
argument_list|(
operator|&
name|sc
operator|->
name|xs_devicewatch
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|xs_attachcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xenbus_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|xs_attachcb
operator|.
name|ich_func
operator|=
name|xenbus_attach_deferred
expr_stmt|;
name|sc
operator|->
name|xs_attachcb
operator|.
name|ich_arg
operator|=
name|dev
expr_stmt|;
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|xs_attachcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DPRINTK
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xs_suspend
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|error
decl_stmt|;
name|char
modifier|*
name|statepath
decl_stmt|;
name|xb_init_comms
argument_list|()
expr_stmt|;
name|xs_resume
argument_list|()
expr_stmt|;
comment|/* 	 * We must re-examine each device and find the new path for 	 * its backend. 	 */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device_get_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
operator|==
name|DS_NOTPRESENT
condition|)
continue|continue;
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|unregister_xenbus_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_state
operator|=
name|XenbusStateInitialising
expr_stmt|;
comment|/* 			 * Find the new backend details and 			 * re-register our watch. 			 */
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|xenbus_gather
argument_list|(
name|XBT_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"backend-id"
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|ivars
operator|->
name|xd_otherend_id
argument_list|,
literal|"backend"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DEVICE_RESUME
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|statepath
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"/state"
argument_list|)
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|statepath
argument_list|,
literal|"%s/state"
argument_list|,
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|=
name|statepath
expr_stmt|;
name|register_xenbus_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * Can't do this yet since we are running in 			 * the xenwatch thread and if we sleep here, 			 * we will stop delivering watch notifications 			 * and the device will never come back online. 			 */
block|sx_xlock(&ivars->xd_lock); 			while (ivars->xd_state != XenbusStateClosed&& ivars->xd_state != XenbusStateConnected) 				sx_sleep(&ivars->xd_state,&ivars->xd_lock, 				    0, "xdresume", 0); 			sx_xunlock(&ivars->xd_lock);
endif|#
directive|endif
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|XENBUS_IVAR_NODE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_TYPE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_STATE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_state
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_OTHEREND_ID
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_otherend_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_OTHEREND_PATH
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_otherend_path
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xenbus_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|enum
name|xenbus_state
name|newstate
decl_stmt|;
name|int
name|currstate
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|XENBUS_IVAR_STATE
case|:
name|newstate
operator|=
operator|(
expr|enum
name|xenbus_state
operator|)
name|value
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_state
operator|==
name|newstate
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|xenbus_scanf
argument_list|(
name|XBT_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"state"
argument_list|,
name|NULL
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|currstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|xenbus_printf
argument_list|(
name|XBT_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"state"
argument_list|,
literal|"%d"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newstate
operator|!=
name|XenbusStateClosing
condition|)
comment|/* Avoid looping */
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"writing new state"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ivars
operator|->
name|xd_state
operator|=
name|newstate
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ivars
operator|->
name|xd_state
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_NODE
case|:
case|case
name|XENBUS_IVAR_TYPE
case|:
case|case
name|XENBUS_IVAR_OTHEREND_ID
case|:
case|case
name|XENBUS_IVAR_OTHEREND_PATH
case|:
comment|/* 		 * These variables are read-only. 		 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_dev
argument_list|,
name|OID_AUTO
argument_list|,
name|xen
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Xen"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_xen
argument_list|,
name|OID_AUTO
argument_list|,
name|xsd_port
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|xen_store_evtchn
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_dev_xen
argument_list|,
name|OID_AUTO
argument_list|,
name|xsd_kva
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|xen_store
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|xenbus_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|xenbus_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xenbus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xenbus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|xenbus_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|xenbus_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|xenbus_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|xenbus_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|xenbus_write_ivar
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|driver_name
index|[]
init|=
literal|"xenbus"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xenbus_driver
init|=
block|{
name|driver_name
block|,
name|xenbus_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|xenbus_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|xenbus_devclass
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XENHVM
end_ifdef

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xenbus
argument_list|,
name|xenpci
argument_list|,
name|xenbus_driver
argument_list|,
name|xenbus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|xenbus
argument_list|,
name|nexus
argument_list|,
name|xenbus_driver
argument_list|,
name|xenbus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

