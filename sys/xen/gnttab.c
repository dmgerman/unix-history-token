begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * gnttab.c  *   * Two sets of functionality:  * 1. Granting foreign access to our memory reservation.  * 2. Accessing others' memory reservations via grant references.  * (i.e., mechanisms for both sender and recipient of grant references)  *   * Copyright (c) 2005, Christopher Clark  * Copyright (c) 2004, K A Fraser  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_global.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/synch_bitops.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_define
define|#
directive|define
name|cmpxchg
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|atomic_cmpset_int((volatile u_int *)(a),(b),(c))
end_define

begin_comment
comment|/* External tools reserve first few grant table entries. */
end_comment

begin_define
define|#
directive|define
name|NR_RESERVED_ENTRIES
value|8
end_define

begin_define
define|#
directive|define
name|GNTTAB_LIST_END
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|GREFS_PER_GRANT_FRAME
value|(PAGE_SIZE / sizeof(grant_entry_t))
end_define

begin_decl_stmt
specifier|static
name|grant_ref_t
modifier|*
modifier|*
name|gnttab_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nr_grant_frames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|boot_max_nr_grant_frames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gnttab_free_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|grant_ref_t
name|gnttab_free_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|gnttab_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|grant_entry_t
modifier|*
name|shared
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gnttab_free_callback
modifier|*
name|gnttab_free_callback_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|gnttab_expand
parameter_list|(
name|unsigned
name|int
name|req_entries
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RPP
value|(PAGE_SIZE / sizeof(grant_ref_t))
end_define

begin_define
define|#
directive|define
name|gnttab_entry
parameter_list|(
name|entry
parameter_list|)
value|(gnttab_list[(entry) / RPP][(entry) % RPP])
end_define

begin_function
specifier|static
name|int
name|get_free_entries
parameter_list|(
name|int
name|count
parameter_list|,
name|int
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|ref
decl_stmt|,
name|error
decl_stmt|;
name|grant_ref_t
name|head
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gnttab_free_count
operator|<
name|count
operator|)
operator|&&
operator|(
operator|(
name|error
operator|=
name|gnttab_expand
argument_list|(
name|count
operator|-
name|gnttab_free_count
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ref
operator|=
name|head
operator|=
name|gnttab_free_head
expr_stmt|;
name|gnttab_free_count
operator|-=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|1
condition|)
name|head
operator|=
name|gnttab_entry
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|gnttab_free_head
operator|=
name|gnttab_entry
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|gnttab_entry
argument_list|(
name|head
argument_list|)
operator|=
name|GNTTAB_LIST_END
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
operator|*
name|entries
operator|=
name|ref
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gnttab_free_callback
modifier|*
name|callback
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|callback
operator|=
name|gnttab_free_callback_list
expr_stmt|;
name|gnttab_free_callback_list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|callback
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|callback
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gnttab_free_count
operator|>=
name|callback
operator|->
name|count
condition|)
block|{
name|callback
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|callback
operator|->
name|fn
argument_list|(
name|callback
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callback
operator|->
name|next
operator|=
name|gnttab_free_callback_list
expr_stmt|;
name|gnttab_free_callback_list
operator|=
name|callback
expr_stmt|;
block|}
name|callback
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|check_free_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|gnttab_free_callback_list
operator|!=
name|NULL
argument_list|)
condition|)
name|do_free_callbacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_free_entry
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
name|gnttab_entry
argument_list|(
name|ref
argument_list|)
operator|=
name|gnttab_free_head
expr_stmt|;
name|gnttab_free_head
operator|=
name|ref
expr_stmt|;
name|gnttab_free_count
operator|++
expr_stmt|;
name|check_free_callbacks
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public grant-issuing interface functions  */
end_comment

begin_function
name|int
name|gnttab_grant_foreign_access
parameter_list|(
name|domid_t
name|domid
parameter_list|,
name|unsigned
name|long
name|frame
parameter_list|,
name|int
name|readonly
parameter_list|,
name|grant_ref_t
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|;
name|error
operator|=
name|get_free_entries
argument_list|(
literal|1
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shared
index|[
name|ref
index|]
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|domid
operator|=
name|domid
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|flags
operator|=
name|GTF_permit_access
operator||
operator|(
name|readonly
condition|?
name|GTF_readonly
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|ref
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gnttab_grant_foreign_access_ref
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|,
name|domid_t
name|domid
parameter_list|,
name|unsigned
name|long
name|frame
parameter_list|,
name|int
name|readonly
parameter_list|)
block|{
name|shared
index|[
name|ref
index|]
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|domid
operator|=
name|domid
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|flags
operator|=
name|GTF_permit_access
operator||
operator|(
name|readonly
condition|?
name|GTF_readonly
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gnttab_query_foreign_access
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|uint16_t
name|nflags
decl_stmt|;
name|nflags
operator|=
name|shared
index|[
name|ref
index|]
operator|.
name|flags
expr_stmt|;
return|return
operator|(
name|nflags
operator|&
operator|(
name|GTF_reading
operator||
name|GTF_writing
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_end_foreign_access_ref
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|uint16_t
name|flags
decl_stmt|,
name|nflags
decl_stmt|;
name|nflags
operator|=
name|shared
index|[
name|ref
index|]
operator|.
name|flags
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|flags
operator|=
name|nflags
operator|)
operator|&
operator|(
name|GTF_reading
operator||
name|GTF_writing
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: g.e. still in use!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|nflags
operator|=
name|synch_cmpxchg
argument_list|(
operator|&
name|shared
index|[
name|ref
index|]
operator|.
name|flags
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|flags
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gnttab_end_foreign_access
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
block|{
if|if
condition|(
name|gnttab_end_foreign_access_ref
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|put_free_entry
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|page
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* XXX This needs to be fixed so that the ref and page are 		   placed on a list to be freed up later. */
name|printf
argument_list|(
literal|"WARNING: leaking g.e. and page still in use!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|gnttab_grant_foreign_transfer
parameter_list|(
name|domid_t
name|domid
parameter_list|,
name|unsigned
name|long
name|pfn
parameter_list|,
name|grant_ref_t
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|;
name|error
operator|=
name|get_free_entries
argument_list|(
literal|1
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gnttab_grant_foreign_transfer_ref
argument_list|(
name|ref
argument_list|,
name|domid
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|ref
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gnttab_grant_foreign_transfer_ref
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|,
name|domid_t
name|domid
parameter_list|,
name|unsigned
name|long
name|pfn
parameter_list|)
block|{
name|shared
index|[
name|ref
index|]
operator|.
name|frame
operator|=
name|pfn
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|domid
operator|=
name|domid
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|shared
index|[
name|ref
index|]
operator|.
name|flags
operator|=
name|GTF_accept_transfer
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|gnttab_end_foreign_transfer_ref
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|unsigned
name|long
name|frame
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
comment|/*          * If a transfer is not even yet started, try to reclaim the grant          * reference and return failure (== 0).          */
while|while
condition|(
operator|!
operator|(
operator|(
name|flags
operator|=
name|shared
index|[
name|ref
index|]
operator|.
name|flags
operator|)
operator|&
name|GTF_transfer_committed
operator|)
condition|)
block|{
if|if
condition|(
name|synch_cmpxchg
argument_list|(
operator|&
name|shared
index|[
name|ref
index|]
operator|.
name|flags
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
operator|==
name|flags
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cpu_relax
argument_list|()
expr_stmt|;
block|}
comment|/* If a transfer is in progress then wait until it is completed. */
while|while
condition|(
operator|!
operator|(
name|flags
operator|&
name|GTF_transfer_completed
operator|)
condition|)
block|{
name|flags
operator|=
name|shared
index|[
name|ref
index|]
operator|.
name|flags
expr_stmt|;
name|cpu_relax
argument_list|()
expr_stmt|;
block|}
comment|/* Read the frame number /after/ reading completion status. */
name|rmb
argument_list|()
expr_stmt|;
name|frame
operator|=
name|shared
index|[
name|ref
index|]
operator|.
name|frame
expr_stmt|;
name|KASSERT
argument_list|(
name|frame
operator|!=
literal|0
argument_list|,
operator|(
literal|"grant table inconsistent"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|gnttab_end_foreign_transfer
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|unsigned
name|long
name|frame
init|=
name|gnttab_end_foreign_transfer_ref
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|put_free_entry
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gnttab_free_grant_reference
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|)
block|{
name|put_free_entry
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gnttab_free_grant_references
parameter_list|(
name|grant_ref_t
name|head
parameter_list|)
block|{
name|grant_ref_t
name|ref
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|GNTTAB_LIST_END
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
name|ref
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|gnttab_entry
argument_list|(
name|ref
argument_list|)
operator|!=
name|GNTTAB_LIST_END
condition|)
block|{
name|ref
operator|=
name|gnttab_entry
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|gnttab_entry
argument_list|(
name|ref
argument_list|)
operator|=
name|gnttab_free_head
expr_stmt|;
name|gnttab_free_head
operator|=
name|head
expr_stmt|;
name|gnttab_free_count
operator|+=
name|count
expr_stmt|;
name|check_free_callbacks
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gnttab_alloc_grant_references
parameter_list|(
name|uint16_t
name|count
parameter_list|,
name|grant_ref_t
modifier|*
name|head
parameter_list|)
block|{
name|int
name|ref
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|get_free_entries
argument_list|(
name|count
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|head
operator|=
name|ref
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_empty_grant_references
parameter_list|(
specifier|const
name|grant_ref_t
modifier|*
name|private_head
parameter_list|)
block|{
return|return
operator|(
operator|*
name|private_head
operator|==
name|GNTTAB_LIST_END
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_claim_grant_reference
parameter_list|(
name|grant_ref_t
modifier|*
name|private_head
parameter_list|)
block|{
name|grant_ref_t
name|g
init|=
operator|*
name|private_head
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|g
operator|==
name|GNTTAB_LIST_END
argument_list|)
condition|)
return|return
operator|(
name|g
operator|)
return|;
operator|*
name|private_head
operator|=
name|gnttab_entry
argument_list|(
name|g
argument_list|)
expr_stmt|;
return|return
operator|(
name|g
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gnttab_release_grant_reference
parameter_list|(
name|grant_ref_t
modifier|*
name|private_head
parameter_list|,
name|grant_ref_t
name|release
parameter_list|)
block|{
name|gnttab_entry
argument_list|(
name|release
argument_list|)
operator|=
operator|*
name|private_head
expr_stmt|;
operator|*
name|private_head
operator|=
name|release
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gnttab_request_free_callback
parameter_list|(
name|struct
name|gnttab_free_callback
modifier|*
name|callback
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback
operator|->
name|next
condition|)
goto|goto
name|out
goto|;
name|callback
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|callback
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|callback
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|callback
operator|->
name|next
operator|=
name|gnttab_free_callback_list
expr_stmt|;
name|gnttab_free_callback_list
operator|=
name|callback
expr_stmt|;
name|check_free_callbacks
argument_list|()
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gnttab_cancel_free_callback
parameter_list|(
name|struct
name|gnttab_free_callback
modifier|*
name|callback
parameter_list|)
block|{
name|struct
name|gnttab_free_callback
modifier|*
modifier|*
name|pcb
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pcb
operator|=
operator|&
name|gnttab_free_callback_list
init|;
operator|*
name|pcb
condition|;
name|pcb
operator|=
operator|&
operator|(
operator|*
name|pcb
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|pcb
operator|==
name|callback
condition|)
block|{
operator|*
name|pcb
operator|=
name|callback
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|gnttab_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|grow_gnttab_list
parameter_list|(
name|unsigned
name|int
name|more_frames
parameter_list|)
block|{
name|unsigned
name|int
name|new_nr_grant_frames
decl_stmt|,
name|extra_entries
decl_stmt|,
name|i
decl_stmt|;
name|new_nr_grant_frames
operator|=
name|nr_grant_frames
operator|+
name|more_frames
expr_stmt|;
name|extra_entries
operator|=
name|more_frames
operator|*
name|GREFS_PER_GRANT_FRAME
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nr_grant_frames
init|;
name|i
operator|<
name|new_nr_grant_frames
condition|;
name|i
operator|++
control|)
block|{
name|gnttab_list
index|[
name|i
index|]
operator|=
operator|(
name|grant_ref_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gnttab_list
index|[
name|i
index|]
condition|)
goto|goto
name|grow_nomem
goto|;
block|}
for|for
control|(
name|i
operator|=
name|GREFS_PER_GRANT_FRAME
operator|*
name|nr_grant_frames
init|;
name|i
operator|<
name|GREFS_PER_GRANT_FRAME
operator|*
name|new_nr_grant_frames
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|gnttab_entry
argument_list|(
name|i
argument_list|)
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|gnttab_entry
argument_list|(
name|i
argument_list|)
operator|=
name|gnttab_free_head
expr_stmt|;
name|gnttab_free_head
operator|=
name|GREFS_PER_GRANT_FRAME
operator|*
name|nr_grant_frames
expr_stmt|;
name|gnttab_free_count
operator|+=
name|extra_entries
expr_stmt|;
name|nr_grant_frames
operator|=
name|new_nr_grant_frames
expr_stmt|;
name|check_free_callbacks
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|grow_nomem
label|:
for|for
control|(
init|;
name|i
operator|>=
name|nr_grant_frames
condition|;
name|i
operator|--
control|)
name|free
argument_list|(
name|gnttab_list
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|__max_nr_grant_frames
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gnttab_query_size
name|query
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|query
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|rc
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_query_size
argument_list|,
operator|&
name|query
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|<
literal|0
operator|)
operator|||
operator|(
name|query
operator|.
name|status
operator|!=
name|GNTST_okay
operator|)
condition|)
return|return
operator|(
literal|4
operator|)
return|;
comment|/* Legacy max supported number of frames */
return|return
operator|(
name|query
operator|.
name|max_nr_frames
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|max_nr_grant_frames
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|xen_max
init|=
name|__max_nr_grant_frames
argument_list|()
decl_stmt|;
if|if
condition|(
name|xen_max
operator|>
name|boot_max_nr_grant_frames
condition|)
return|return
operator|(
name|boot_max_nr_grant_frames
operator|)
return|;
return|return
operator|(
name|xen_max
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * XXX needed for backend support  *  */
end_comment

begin_function
specifier|static
name|int
name|map_pte_fn
parameter_list|(
name|pte_t
modifier|*
name|pte
parameter_list|,
name|struct
name|page
modifier|*
name|pmd_page
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
modifier|*
name|frames
init|=
operator|(
name|unsigned
name|long
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|set_pte_at
argument_list|(
operator|&
name|init_mm
argument_list|,
name|addr
argument_list|,
name|pte
argument_list|,
name|pfn_pte_ma
argument_list|(
operator|(
operator|*
name|frames
operator|)
index|[
literal|0
index|]
argument_list|,
name|PAGE_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|frames
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmap_pte_fn
parameter_list|(
name|pte_t
modifier|*
name|pte
parameter_list|,
name|struct
name|page
modifier|*
name|pmd_page
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|set_pte_at
argument_list|(
operator|&
name|init_mm
argument_list|,
name|addr
argument_list|,
name|pte
argument_list|,
name|__pte
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XENHVM
end_ifndef

begin_function
specifier|static
name|int
name|gnttab_map
parameter_list|(
name|unsigned
name|int
name|start_idx
parameter_list|,
name|unsigned
name|int
name|end_idx
parameter_list|)
block|{
name|struct
name|gnttab_setup_table
name|setup
decl_stmt|;
name|u_long
modifier|*
name|frames
decl_stmt|;
name|unsigned
name|int
name|nr_gframes
init|=
name|end_idx
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|frames
operator|=
name|malloc
argument_list|(
name|nr_gframes
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frames
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|setup
operator|.
name|dom
operator|=
name|DOMID_SELF
expr_stmt|;
name|setup
operator|.
name|nr_frames
operator|=
name|nr_gframes
expr_stmt|;
name|set_xen_guest_handle
argument_list|(
name|setup
operator|.
name|frame_list
argument_list|,
name|frames
argument_list|)
expr_stmt|;
name|rc
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_setup_table
argument_list|,
operator|&
name|setup
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
name|ENOSYS
condition|)
block|{
name|free
argument_list|(
name|frames
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|rc
operator|||
name|setup
operator|.
name|status
operator|)
argument_list|,
operator|(
literal|"unexpected result from grant_table_op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared
operator|==
name|NULL
condition|)
block|{
name|vm_offset_t
name|area
decl_stmt|;
name|area
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
operator|*
name|max_nr_grant_frames
argument_list|()
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|area
argument_list|,
operator|(
literal|"can't allocate VM space for grant table"
operator|)
argument_list|)
expr_stmt|;
name|shared
operator|=
operator|(
name|grant_entry_t
operator|*
operator|)
name|area
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_gframes
condition|;
name|i
operator|++
control|)
name|PT_SET_MA
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|shared
operator|)
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
operator|(
operator|(
name|vm_paddr_t
operator|)
name|frames
index|[
name|i
index|]
operator|)
operator|<<
name|PAGE_SHIFT
operator||
name|PG_RW
operator||
name|PG_V
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frames
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_resume
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|max_nr_grant_frames
argument_list|()
operator|<
name|nr_grant_frames
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
return|return
operator|(
name|gnttab_map
argument_list|(
literal|0
argument_list|,
name|nr_grant_frames
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_grant_frames
condition|;
name|i
operator|++
control|)
name|pmap_kremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|shared
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* XENHVM */
end_comment

begin_include
include|#
directive|include
file|<dev/xen/xenpci/xenpcivar.h>
end_include

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|resume_frames
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|gnttab_map
parameter_list|(
name|unsigned
name|int
name|start_idx
parameter_list|,
name|unsigned
name|int
name|end_idx
parameter_list|)
block|{
name|struct
name|xen_add_to_physmap
name|xatp
decl_stmt|;
name|unsigned
name|int
name|i
init|=
name|end_idx
decl_stmt|;
comment|/* 	 * Loop backwards, so that the first hypercall has the largest index, 	 * ensuring that the table will grow only once. 	 */
do|do
block|{
name|xatp
operator|.
name|domid
operator|=
name|DOMID_SELF
expr_stmt|;
name|xatp
operator|.
name|idx
operator|=
name|i
expr_stmt|;
name|xatp
operator|.
name|space
operator|=
name|XENMAPSPACE_grant_table
expr_stmt|;
name|xatp
operator|.
name|gpfn
operator|=
operator|(
name|resume_frames
operator|>>
name|PAGE_SHIFT
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_add_to_physmap
argument_list|,
operator|&
name|xatp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"HYPERVISOR_memory_op failed to map gnttab"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
operator|>
name|start_idx
condition|)
do|;
if|if
condition|(
name|shared
operator|==
name|NULL
condition|)
block|{
name|vm_offset_t
name|area
decl_stmt|;
name|area
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
operator|*
name|max_nr_grant_frames
argument_list|()
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|area
argument_list|,
operator|(
literal|"can't allocate VM space for grant table"
operator|)
argument_list|)
expr_stmt|;
name|shared
operator|=
operator|(
name|grant_entry_t
operator|*
operator|)
name|area
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<=
name|end_idx
condition|;
name|i
operator|++
control|)
block|{
name|pmap_kenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|shared
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
name|resume_frames
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|max_nr_gframes
decl_stmt|,
name|nr_gframes
decl_stmt|;
name|nr_gframes
operator|=
name|nr_grant_frames
expr_stmt|;
name|max_nr_gframes
operator|=
name|max_nr_grant_frames
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_nr_gframes
operator|<
name|nr_gframes
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
operator|!
name|resume_frames
condition|)
block|{
name|error
operator|=
name|xenpci_alloc_space
argument_list|(
name|PAGE_SIZE
operator|*
name|max_nr_gframes
argument_list|,
operator|&
name|resume_frames
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"error mapping gnttab share frames\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|gnttab_map
argument_list|(
literal|0
argument_list|,
name|nr_gframes
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|gnttab_expand
parameter_list|(
name|unsigned
name|int
name|req_entries
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|cur
decl_stmt|,
name|extra
decl_stmt|;
name|cur
operator|=
name|nr_grant_frames
expr_stmt|;
name|extra
operator|=
operator|(
operator|(
name|req_entries
operator|+
operator|(
name|GREFS_PER_GRANT_FRAME
operator|-
literal|1
operator|)
operator|)
operator|/
name|GREFS_PER_GRANT_FRAME
operator|)
expr_stmt|;
if|if
condition|(
name|cur
operator|+
name|extra
operator|>
name|max_nr_grant_frames
argument_list|()
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|error
operator|=
name|gnttab_map
argument_list|(
name|cur
argument_list|,
name|cur
operator|+
name|extra
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|grow_gnttab_list
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gnttab_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|max_nr_glist_frames
decl_stmt|;
name|unsigned
name|int
name|nr_init_grefs
decl_stmt|;
if|if
condition|(
operator|!
name|is_running_on_xen
argument_list|()
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|nr_grant_frames
operator|=
literal|1
expr_stmt|;
name|boot_max_nr_grant_frames
operator|=
name|__max_nr_grant_frames
argument_list|()
expr_stmt|;
comment|/* Determine the maximum number of frames required for the 	 * grant reference free list on the current hypervisor. 	 */
name|max_nr_glist_frames
operator|=
operator|(
name|boot_max_nr_grant_frames
operator|*
name|GREFS_PER_GRANT_FRAME
operator|/
operator|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|grant_ref_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|gnttab_list
operator|=
name|malloc
argument_list|(
name|max_nr_glist_frames
operator|*
sizeof|sizeof
argument_list|(
name|grant_ref_t
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnttab_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_grant_frames
condition|;
name|i
operator|++
control|)
block|{
name|gnttab_list
index|[
name|i
index|]
operator|=
operator|(
name|grant_ref_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnttab_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|ini_nomem
goto|;
block|}
if|if
condition|(
name|gnttab_resume
argument_list|()
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|nr_init_grefs
operator|=
name|nr_grant_frames
operator|*
name|GREFS_PER_GRANT_FRAME
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NR_RESERVED_ENTRIES
init|;
name|i
operator|<
name|nr_init_grefs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|gnttab_entry
argument_list|(
name|i
argument_list|)
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|gnttab_entry
argument_list|(
name|nr_init_grefs
operator|-
literal|1
argument_list|)
operator|=
name|GNTTAB_LIST_END
expr_stmt|;
name|gnttab_free_count
operator|=
name|nr_init_grefs
operator|-
name|NR_RESERVED_ENTRIES
expr_stmt|;
name|gnttab_free_head
operator|=
name|NR_RESERVED_ENTRIES
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Grant table initialized\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|ini_nomem
label|:
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|free
argument_list|(
name|gnttab_list
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gnttab_list
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|gnttab
argument_list|,
operator|&
name|gnttab_list_lock
argument_list|,
literal|"GNTTAB LOCK"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//SYSINIT(gnttab, SI_SUB_PSEUDO, SI_ORDER_FIRST, gnttab_init, NULL);
end_comment

end_unit

