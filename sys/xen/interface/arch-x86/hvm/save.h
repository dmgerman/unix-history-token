begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Structure definitions for HVM state that is held by Xen and must  * be saved along with the domain's memory and device-model state.  *   * Copyright (c) 2007 XenSource Ltd.  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to  * deal in the Software without restriction, including without limitation the  * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  * sell copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__XEN_PUBLIC_HVM_SAVE_X86_H__
end_ifndef

begin_define
define|#
directive|define
name|__XEN_PUBLIC_HVM_SAVE_X86_H__
end_define

begin_comment
comment|/*   * Save/restore header: general info about the save file.   */
end_comment

begin_define
define|#
directive|define
name|HVM_FILE_MAGIC
value|0x54381286
end_define

begin_define
define|#
directive|define
name|HVM_FILE_VERSION
value|0x00000001
end_define

begin_struct
struct|struct
name|hvm_save_header
block|{
name|uint32_t
name|magic
decl_stmt|;
comment|/* Must be HVM_FILE_MAGIC */
name|uint32_t
name|version
decl_stmt|;
comment|/* File format version */
name|uint64_t
name|changeset
decl_stmt|;
comment|/* Version of Xen that saved this file */
name|uint32_t
name|cpuid
decl_stmt|;
comment|/* CPUID[0x01][%eax] on the saving machine */
name|uint32_t
name|gtsc_khz
decl_stmt|;
comment|/* Guest's TSC frequency in kHz */
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|HEADER
argument_list|,
literal|1
argument_list|,
expr|struct
name|hvm_save_header
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Processor  *  * Compat: Pre-3.4 didn't have msr_tsc_aux  */
end_comment

begin_struct
struct|struct
name|hvm_hw_cpu
block|{
name|uint8_t
name|fpu_regs
index|[
literal|512
index|]
decl_stmt|;
name|uint64_t
name|rax
decl_stmt|;
name|uint64_t
name|rbx
decl_stmt|;
name|uint64_t
name|rcx
decl_stmt|;
name|uint64_t
name|rdx
decl_stmt|;
name|uint64_t
name|rbp
decl_stmt|;
name|uint64_t
name|rsi
decl_stmt|;
name|uint64_t
name|rdi
decl_stmt|;
name|uint64_t
name|rsp
decl_stmt|;
name|uint64_t
name|r8
decl_stmt|;
name|uint64_t
name|r9
decl_stmt|;
name|uint64_t
name|r10
decl_stmt|;
name|uint64_t
name|r11
decl_stmt|;
name|uint64_t
name|r12
decl_stmt|;
name|uint64_t
name|r13
decl_stmt|;
name|uint64_t
name|r14
decl_stmt|;
name|uint64_t
name|r15
decl_stmt|;
name|uint64_t
name|rip
decl_stmt|;
name|uint64_t
name|rflags
decl_stmt|;
name|uint64_t
name|cr0
decl_stmt|;
name|uint64_t
name|cr2
decl_stmt|;
name|uint64_t
name|cr3
decl_stmt|;
name|uint64_t
name|cr4
decl_stmt|;
name|uint64_t
name|dr0
decl_stmt|;
name|uint64_t
name|dr1
decl_stmt|;
name|uint64_t
name|dr2
decl_stmt|;
name|uint64_t
name|dr3
decl_stmt|;
name|uint64_t
name|dr6
decl_stmt|;
name|uint64_t
name|dr7
decl_stmt|;
name|uint32_t
name|cs_sel
decl_stmt|;
name|uint32_t
name|ds_sel
decl_stmt|;
name|uint32_t
name|es_sel
decl_stmt|;
name|uint32_t
name|fs_sel
decl_stmt|;
name|uint32_t
name|gs_sel
decl_stmt|;
name|uint32_t
name|ss_sel
decl_stmt|;
name|uint32_t
name|tr_sel
decl_stmt|;
name|uint32_t
name|ldtr_sel
decl_stmt|;
name|uint32_t
name|cs_limit
decl_stmt|;
name|uint32_t
name|ds_limit
decl_stmt|;
name|uint32_t
name|es_limit
decl_stmt|;
name|uint32_t
name|fs_limit
decl_stmt|;
name|uint32_t
name|gs_limit
decl_stmt|;
name|uint32_t
name|ss_limit
decl_stmt|;
name|uint32_t
name|tr_limit
decl_stmt|;
name|uint32_t
name|ldtr_limit
decl_stmt|;
name|uint32_t
name|idtr_limit
decl_stmt|;
name|uint32_t
name|gdtr_limit
decl_stmt|;
name|uint64_t
name|cs_base
decl_stmt|;
name|uint64_t
name|ds_base
decl_stmt|;
name|uint64_t
name|es_base
decl_stmt|;
name|uint64_t
name|fs_base
decl_stmt|;
name|uint64_t
name|gs_base
decl_stmt|;
name|uint64_t
name|ss_base
decl_stmt|;
name|uint64_t
name|tr_base
decl_stmt|;
name|uint64_t
name|ldtr_base
decl_stmt|;
name|uint64_t
name|idtr_base
decl_stmt|;
name|uint64_t
name|gdtr_base
decl_stmt|;
name|uint32_t
name|cs_arbytes
decl_stmt|;
name|uint32_t
name|ds_arbytes
decl_stmt|;
name|uint32_t
name|es_arbytes
decl_stmt|;
name|uint32_t
name|fs_arbytes
decl_stmt|;
name|uint32_t
name|gs_arbytes
decl_stmt|;
name|uint32_t
name|ss_arbytes
decl_stmt|;
name|uint32_t
name|tr_arbytes
decl_stmt|;
name|uint32_t
name|ldtr_arbytes
decl_stmt|;
name|uint64_t
name|sysenter_cs
decl_stmt|;
name|uint64_t
name|sysenter_esp
decl_stmt|;
name|uint64_t
name|sysenter_eip
decl_stmt|;
comment|/* msr for em64t */
name|uint64_t
name|shadow_gs
decl_stmt|;
comment|/* msr content saved/restored. */
name|uint64_t
name|msr_flags
decl_stmt|;
name|uint64_t
name|msr_lstar
decl_stmt|;
name|uint64_t
name|msr_star
decl_stmt|;
name|uint64_t
name|msr_cstar
decl_stmt|;
name|uint64_t
name|msr_syscall_mask
decl_stmt|;
name|uint64_t
name|msr_efer
decl_stmt|;
name|uint64_t
name|msr_tsc_aux
decl_stmt|;
comment|/* guest's idea of what rdtsc() would return */
name|uint64_t
name|tsc
decl_stmt|;
comment|/* pending event, if any */
union|union
block|{
name|uint32_t
name|pending_event
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|pending_vector
range|:
literal|8
decl_stmt|;
name|uint8_t
name|pending_type
range|:
literal|3
decl_stmt|;
name|uint8_t
name|pending_error_valid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pending_reserved
range|:
literal|19
decl_stmt|;
name|uint8_t
name|pending_valid
range|:
literal|1
decl_stmt|;
block|}
struct|;
block|}
union|;
comment|/* error code for pending event */
name|uint32_t
name|error_code
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hvm_hw_cpu_compat
block|{
name|uint8_t
name|fpu_regs
index|[
literal|512
index|]
decl_stmt|;
name|uint64_t
name|rax
decl_stmt|;
name|uint64_t
name|rbx
decl_stmt|;
name|uint64_t
name|rcx
decl_stmt|;
name|uint64_t
name|rdx
decl_stmt|;
name|uint64_t
name|rbp
decl_stmt|;
name|uint64_t
name|rsi
decl_stmt|;
name|uint64_t
name|rdi
decl_stmt|;
name|uint64_t
name|rsp
decl_stmt|;
name|uint64_t
name|r8
decl_stmt|;
name|uint64_t
name|r9
decl_stmt|;
name|uint64_t
name|r10
decl_stmt|;
name|uint64_t
name|r11
decl_stmt|;
name|uint64_t
name|r12
decl_stmt|;
name|uint64_t
name|r13
decl_stmt|;
name|uint64_t
name|r14
decl_stmt|;
name|uint64_t
name|r15
decl_stmt|;
name|uint64_t
name|rip
decl_stmt|;
name|uint64_t
name|rflags
decl_stmt|;
name|uint64_t
name|cr0
decl_stmt|;
name|uint64_t
name|cr2
decl_stmt|;
name|uint64_t
name|cr3
decl_stmt|;
name|uint64_t
name|cr4
decl_stmt|;
name|uint64_t
name|dr0
decl_stmt|;
name|uint64_t
name|dr1
decl_stmt|;
name|uint64_t
name|dr2
decl_stmt|;
name|uint64_t
name|dr3
decl_stmt|;
name|uint64_t
name|dr6
decl_stmt|;
name|uint64_t
name|dr7
decl_stmt|;
name|uint32_t
name|cs_sel
decl_stmt|;
name|uint32_t
name|ds_sel
decl_stmt|;
name|uint32_t
name|es_sel
decl_stmt|;
name|uint32_t
name|fs_sel
decl_stmt|;
name|uint32_t
name|gs_sel
decl_stmt|;
name|uint32_t
name|ss_sel
decl_stmt|;
name|uint32_t
name|tr_sel
decl_stmt|;
name|uint32_t
name|ldtr_sel
decl_stmt|;
name|uint32_t
name|cs_limit
decl_stmt|;
name|uint32_t
name|ds_limit
decl_stmt|;
name|uint32_t
name|es_limit
decl_stmt|;
name|uint32_t
name|fs_limit
decl_stmt|;
name|uint32_t
name|gs_limit
decl_stmt|;
name|uint32_t
name|ss_limit
decl_stmt|;
name|uint32_t
name|tr_limit
decl_stmt|;
name|uint32_t
name|ldtr_limit
decl_stmt|;
name|uint32_t
name|idtr_limit
decl_stmt|;
name|uint32_t
name|gdtr_limit
decl_stmt|;
name|uint64_t
name|cs_base
decl_stmt|;
name|uint64_t
name|ds_base
decl_stmt|;
name|uint64_t
name|es_base
decl_stmt|;
name|uint64_t
name|fs_base
decl_stmt|;
name|uint64_t
name|gs_base
decl_stmt|;
name|uint64_t
name|ss_base
decl_stmt|;
name|uint64_t
name|tr_base
decl_stmt|;
name|uint64_t
name|ldtr_base
decl_stmt|;
name|uint64_t
name|idtr_base
decl_stmt|;
name|uint64_t
name|gdtr_base
decl_stmt|;
name|uint32_t
name|cs_arbytes
decl_stmt|;
name|uint32_t
name|ds_arbytes
decl_stmt|;
name|uint32_t
name|es_arbytes
decl_stmt|;
name|uint32_t
name|fs_arbytes
decl_stmt|;
name|uint32_t
name|gs_arbytes
decl_stmt|;
name|uint32_t
name|ss_arbytes
decl_stmt|;
name|uint32_t
name|tr_arbytes
decl_stmt|;
name|uint32_t
name|ldtr_arbytes
decl_stmt|;
name|uint64_t
name|sysenter_cs
decl_stmt|;
name|uint64_t
name|sysenter_esp
decl_stmt|;
name|uint64_t
name|sysenter_eip
decl_stmt|;
comment|/* msr for em64t */
name|uint64_t
name|shadow_gs
decl_stmt|;
comment|/* msr content saved/restored. */
name|uint64_t
name|msr_flags
decl_stmt|;
name|uint64_t
name|msr_lstar
decl_stmt|;
name|uint64_t
name|msr_star
decl_stmt|;
name|uint64_t
name|msr_cstar
decl_stmt|;
name|uint64_t
name|msr_syscall_mask
decl_stmt|;
name|uint64_t
name|msr_efer
decl_stmt|;
comment|/*uint64_t msr_tsc_aux; COMPAT */
comment|/* guest's idea of what rdtsc() would return */
name|uint64_t
name|tsc
decl_stmt|;
comment|/* pending event, if any */
union|union
block|{
name|uint32_t
name|pending_event
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|pending_vector
range|:
literal|8
decl_stmt|;
name|uint8_t
name|pending_type
range|:
literal|3
decl_stmt|;
name|uint8_t
name|pending_error_valid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pending_reserved
range|:
literal|19
decl_stmt|;
name|uint8_t
name|pending_valid
range|:
literal|1
decl_stmt|;
block|}
struct|;
block|}
union|;
comment|/* error code for pending event */
name|uint32_t
name|error_code
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|_hvm_hw_fix_cpu
parameter_list|(
name|void
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|hvm_hw_cpu
modifier|*
name|new
init|=
name|h
decl_stmt|;
name|struct
name|hvm_hw_cpu_compat
modifier|*
name|old
init|=
name|h
decl_stmt|;
comment|/* If we copy from the end backwards, we should      * be able to do the modification in-place */
name|new
operator|->
name|error_code
operator|=
name|old
operator|->
name|error_code
expr_stmt|;
name|new
operator|->
name|pending_event
operator|=
name|old
operator|->
name|pending_event
expr_stmt|;
name|new
operator|->
name|tsc
operator|=
name|old
operator|->
name|tsc
expr_stmt|;
name|new
operator|->
name|msr_tsc_aux
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE_COMPAT
argument_list|(
name|CPU
argument_list|,
literal|2
argument_list|,
expr|struct
name|hvm_hw_cpu
argument_list|, \
expr|struct
name|hvm_hw_cpu_compat
argument_list|,
name|_hvm_hw_fix_cpu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PIC  */
end_comment

begin_struct
struct|struct
name|hvm_hw_vpic
block|{
comment|/* IR line bitmasks. */
name|uint8_t
name|irr
decl_stmt|;
name|uint8_t
name|imr
decl_stmt|;
name|uint8_t
name|isr
decl_stmt|;
comment|/* Line IRx maps to IRQ irq_base+x */
name|uint8_t
name|irq_base
decl_stmt|;
comment|/*      * Where are we in ICW2-4 initialisation (0 means no init in progress)?      * Bits 0-1 (=x): Next write at A=1 sets ICW(x+1).      * Bit 2: ICW1.IC4  (1 == ICW4 included in init sequence)      * Bit 3: ICW1.SNGL (0 == ICW3 included in init sequence)      */
name|uint8_t
name|init_state
range|:
literal|4
decl_stmt|;
comment|/* IR line with highest priority. */
name|uint8_t
name|priority_add
range|:
literal|4
decl_stmt|;
comment|/* Reads from A=0 obtain ISR or IRR? */
name|uint8_t
name|readsel_isr
range|:
literal|1
decl_stmt|;
comment|/* Reads perform a polling read? */
name|uint8_t
name|poll
range|:
literal|1
decl_stmt|;
comment|/* Automatically clear IRQs from the ISR during INTA? */
name|uint8_t
name|auto_eoi
range|:
literal|1
decl_stmt|;
comment|/* Automatically rotate IRQ priorities during AEOI? */
name|uint8_t
name|rotate_on_auto_eoi
range|:
literal|1
decl_stmt|;
comment|/* Exclude slave inputs when considering in-service IRQs? */
name|uint8_t
name|special_fully_nested_mode
range|:
literal|1
decl_stmt|;
comment|/* Special mask mode excludes masked IRs from AEOI and priority checks. */
name|uint8_t
name|special_mask_mode
range|:
literal|1
decl_stmt|;
comment|/* Is this a master PIC or slave PIC? (NB. This is not programmable.) */
name|uint8_t
name|is_master
range|:
literal|1
decl_stmt|;
comment|/* Edge/trigger selection. */
name|uint8_t
name|elcr
decl_stmt|;
comment|/* Virtual INT output. */
name|uint8_t
name|int_output
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|PIC
argument_list|,
literal|3
argument_list|,
expr|struct
name|hvm_hw_vpic
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IO-APIC  */
end_comment

begin_define
define|#
directive|define
name|VIOAPIC_NUM_PINS
value|48
end_define

begin_comment
comment|/* 16 ISA IRQs, 32 non-legacy PCI IRQS. */
end_comment

begin_struct
struct|struct
name|hvm_hw_vioapic
block|{
name|uint64_t
name|base_address
decl_stmt|;
name|uint32_t
name|ioregsel
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
union|union
name|vioapic_redir_entry
block|{
name|uint64_t
name|bits
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|vector
decl_stmt|;
name|uint8_t
name|delivery_mode
range|:
literal|3
decl_stmt|;
name|uint8_t
name|dest_mode
range|:
literal|1
decl_stmt|;
name|uint8_t
name|delivery_status
range|:
literal|1
decl_stmt|;
name|uint8_t
name|polarity
range|:
literal|1
decl_stmt|;
name|uint8_t
name|remote_irr
range|:
literal|1
decl_stmt|;
name|uint8_t
name|trig_mode
range|:
literal|1
decl_stmt|;
name|uint8_t
name|mask
range|:
literal|1
decl_stmt|;
name|uint8_t
name|reserve
range|:
literal|7
decl_stmt|;
name|uint8_t
name|reserved
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|dest_id
decl_stmt|;
block|}
name|fields
struct|;
block|}
name|redirtbl
index|[
name|VIOAPIC_NUM_PINS
index|]
union|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|IOAPIC
argument_list|,
literal|4
argument_list|,
expr|struct
name|hvm_hw_vioapic
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * LAPIC  */
end_comment

begin_struct
struct|struct
name|hvm_hw_lapic
block|{
name|uint64_t
name|apic_base_msr
decl_stmt|;
name|uint32_t
name|disabled
decl_stmt|;
comment|/* VLAPIC_xx_DISABLED */
name|uint32_t
name|timer_divisor
decl_stmt|;
name|uint64_t
name|tdt_msr
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|LAPIC
argument_list|,
literal|5
argument_list|,
expr|struct
name|hvm_hw_lapic
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hvm_hw_lapic_regs
block|{
name|uint8_t
name|data
index|[
literal|1024
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|LAPIC_REGS
argument_list|,
literal|6
argument_list|,
expr|struct
name|hvm_hw_lapic_regs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IRQs  */
end_comment

begin_struct
struct|struct
name|hvm_hw_pci_irqs
block|{
comment|/*      * Virtual interrupt wires for a single PCI bus.      * Indexed by: device*4 + INTx#.      */
union|union
block|{
name|unsigned
name|long
name|i
index|[
literal|16
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr|]
expr_stmt|;
comment|/* DECLARE_BITMAP(i, 32*4); */
name|uint64_t
name|pad
index|[
literal|2
index|]
decl_stmt|;
block|}
union|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|PCI_IRQ
argument_list|,
literal|7
argument_list|,
expr|struct
name|hvm_hw_pci_irqs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hvm_hw_isa_irqs
block|{
comment|/*      * Virtual interrupt wires for ISA devices.      * Indexed by ISA IRQ (assumes no ISA-device IRQ sharing).      */
union|union
block|{
name|unsigned
name|long
name|i
index|[
literal|1
index|]
decl_stmt|;
comment|/* DECLARE_BITMAP(i, 16); */
name|uint64_t
name|pad
index|[
literal|1
index|]
decl_stmt|;
block|}
union|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|ISA_IRQ
argument_list|,
literal|8
argument_list|,
expr|struct
name|hvm_hw_isa_irqs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hvm_hw_pci_link
block|{
comment|/*      * PCI-ISA interrupt router.      * Each PCI<device:INTx#> is 'wire-ORed' into one of four links using      * the traditional 'barber's pole' mapping ((device + INTx#)& 3).      * The router provides a programmable mapping from each link to a GSI.      */
name|uint8_t
name|route
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|pad0
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|PCI_LINK
argument_list|,
literal|9
argument_list|,
expr|struct
name|hvm_hw_pci_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   *  PIT  */
end_comment

begin_struct
struct|struct
name|hvm_hw_pit
block|{
struct|struct
name|hvm_hw_pit_channel
block|{
name|uint32_t
name|count
decl_stmt|;
comment|/* can be 65536 */
name|uint16_t
name|latched_count
decl_stmt|;
name|uint8_t
name|count_latched
decl_stmt|;
name|uint8_t
name|status_latched
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|uint8_t
name|read_state
decl_stmt|;
name|uint8_t
name|write_state
decl_stmt|;
name|uint8_t
name|write_latch
decl_stmt|;
name|uint8_t
name|rw_mode
decl_stmt|;
name|uint8_t
name|mode
decl_stmt|;
name|uint8_t
name|bcd
decl_stmt|;
comment|/* not supported */
name|uint8_t
name|gate
decl_stmt|;
comment|/* timer start */
block|}
name|channels
index|[
literal|3
index|]
struct|;
comment|/* 3 x 16 bytes */
name|uint32_t
name|speaker_data_on
decl_stmt|;
name|uint32_t
name|pad0
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|PIT
argument_list|,
literal|10
argument_list|,
expr|struct
name|hvm_hw_pit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * RTC  */
end_comment

begin_define
define|#
directive|define
name|RTC_CMOS_SIZE
value|14
end_define

begin_struct
struct|struct
name|hvm_hw_rtc
block|{
comment|/* CMOS bytes */
name|uint8_t
name|cmos_data
index|[
name|RTC_CMOS_SIZE
index|]
decl_stmt|;
comment|/* Index register for 2-part operations */
name|uint8_t
name|cmos_index
decl_stmt|;
name|uint8_t
name|pad0
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|RTC
argument_list|,
literal|11
argument_list|,
expr|struct
name|hvm_hw_rtc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * HPET  */
end_comment

begin_define
define|#
directive|define
name|HPET_TIMER_NUM
value|3
end_define

begin_comment
comment|/* 3 timers supported now */
end_comment

begin_struct
struct|struct
name|hvm_hw_hpet
block|{
comment|/* Memory-mapped, software visible registers */
name|uint64_t
name|capability
decl_stmt|;
comment|/* capabilities */
name|uint64_t
name|res0
decl_stmt|;
comment|/* reserved */
name|uint64_t
name|config
decl_stmt|;
comment|/* configuration */
name|uint64_t
name|res1
decl_stmt|;
comment|/* reserved */
name|uint64_t
name|isr
decl_stmt|;
comment|/* interrupt status reg */
name|uint64_t
name|res2
index|[
literal|25
index|]
decl_stmt|;
comment|/* reserved */
name|uint64_t
name|mc64
decl_stmt|;
comment|/* main counter */
name|uint64_t
name|res3
decl_stmt|;
comment|/* reserved */
struct|struct
block|{
comment|/* timers */
name|uint64_t
name|config
decl_stmt|;
comment|/* configuration/cap */
name|uint64_t
name|cmp
decl_stmt|;
comment|/* comparator */
name|uint64_t
name|fsb
decl_stmt|;
comment|/* FSB route, not supported now */
name|uint64_t
name|res4
decl_stmt|;
comment|/* reserved */
block|}
name|timers
index|[
name|HPET_TIMER_NUM
index|]
struct|;
name|uint64_t
name|res5
index|[
literal|4
operator|*
operator|(
literal|24
operator|-
name|HPET_TIMER_NUM
operator|)
index|]
decl_stmt|;
comment|/* reserved, up to 0x3ff */
comment|/* Hidden register state */
name|uint64_t
name|period
index|[
name|HPET_TIMER_NUM
index|]
decl_stmt|;
comment|/* Last value written to comparator */
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|HPET
argument_list|,
literal|12
argument_list|,
expr|struct
name|hvm_hw_hpet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PM timer  */
end_comment

begin_struct
struct|struct
name|hvm_hw_pmtimer
block|{
name|uint32_t
name|tmr_val
decl_stmt|;
comment|/* PM_TMR_BLK.TMR_VAL: 32bit free-running counter */
name|uint16_t
name|pm1a_sts
decl_stmt|;
comment|/* PM1a_EVT_BLK.PM1a_STS: status register */
name|uint16_t
name|pm1a_en
decl_stmt|;
comment|/* PM1a_EVT_BLK.PM1a_EN: enable register */
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|PMTIMER
argument_list|,
literal|13
argument_list|,
expr|struct
name|hvm_hw_pmtimer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MTRR MSRs  */
end_comment

begin_struct
struct|struct
name|hvm_hw_mtrr
block|{
define|#
directive|define
name|MTRR_VCNT
value|8
define|#
directive|define
name|NUM_FIXED_MSR
value|11
name|uint64_t
name|msr_pat_cr
decl_stmt|;
comment|/* mtrr physbase& physmask msr pair*/
name|uint64_t
name|msr_mtrr_var
index|[
name|MTRR_VCNT
operator|*
literal|2
index|]
decl_stmt|;
name|uint64_t
name|msr_mtrr_fixed
index|[
name|NUM_FIXED_MSR
index|]
decl_stmt|;
name|uint64_t
name|msr_mtrr_cap
decl_stmt|;
name|uint64_t
name|msr_mtrr_def_type
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|MTRR
argument_list|,
literal|14
argument_list|,
expr|struct
name|hvm_hw_mtrr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The save area of XSAVE/XRSTOR.  */
end_comment

begin_struct
struct|struct
name|hvm_hw_cpu_xsave
block|{
name|uint64_t
name|xfeature_mask
decl_stmt|;
name|uint64_t
name|xcr0
decl_stmt|;
comment|/* Updated by XSETBV */
name|uint64_t
name|xcr0_accum
decl_stmt|;
comment|/* Updated by XSETBV */
struct|struct
block|{
struct|struct
block|{
name|char
name|x
index|[
literal|512
index|]
decl_stmt|;
block|}
name|fpu_sse
struct|;
struct|struct
block|{
name|uint64_t
name|xstate_bv
decl_stmt|;
comment|/* Updated by XRSTOR */
name|uint64_t
name|reserved
index|[
literal|7
index|]
decl_stmt|;
block|}
name|xsave_hdr
struct|;
comment|/* The 64-byte header */
struct|struct
block|{
name|char
name|x
index|[
literal|0
index|]
decl_stmt|;
block|}
name|ymm
struct|;
comment|/* YMM */
block|}
name|save_area
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CPU_XSAVE_CODE
value|16
end_define

begin_comment
comment|/*  * Viridian hypervisor context.  */
end_comment

begin_struct
struct|struct
name|hvm_viridian_domain_context
block|{
name|uint64_t
name|hypercall_gpa
decl_stmt|;
name|uint64_t
name|guest_os_id
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|VIRIDIAN_DOMAIN
argument_list|,
literal|15
argument_list|,
expr|struct
name|hvm_viridian_domain_context
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hvm_viridian_vcpu_context
block|{
name|uint64_t
name|apic_assist
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|VIRIDIAN_VCPU
argument_list|,
literal|17
argument_list|,
expr|struct
name|hvm_viridian_vcpu_context
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hvm_vmce_vcpu
block|{
name|uint64_t
name|caps
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|DECLARE_HVM_SAVE_TYPE
argument_list|(
name|VMCE_VCPU
argument_list|,
literal|18
argument_list|,
expr|struct
name|hvm_vmce_vcpu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * Largest type-code in use  */
end_comment

begin_define
define|#
directive|define
name|HVM_SAVE_CODE_MAX
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __XEN_PUBLIC_HVM_SAVE_X86_H__ */
end_comment

end_unit

