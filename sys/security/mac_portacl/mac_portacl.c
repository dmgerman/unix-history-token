begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Network  * Associates Laboratories, the Security Research Division of Network  * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"),  * as part of the DARPA CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Developed by the TrustedBSD Project.  *  * Administratively limit access to local UDP/TCP ports for binding purposes.  * Intended to be combined with net.inet.ip.portrange.reservedhigh to allow  * specific uids and gids to bind specific ports for specific purposes,  * while not opening the door to any user replacing an "official" service  * while you're restarting it.  This only affects ports explicitly bound by  * the user process (either for listen/outgoing socket for TCP, or send/  * receive for UDP).  This module will not limit ports bound implicitly for  * out-going connections where the process hasn't explicitly selected a port:  * these are automatically selected by the IP stack.  *  * To use this module, security.mac.enforce_socket must be enabled, and  * you will probably want to twiddle the net.inet sysctl listed above.  * Then use sysctl(8) to modify the rules string:  *  * # sysctl security.mac.portacl.rules="uid:425:tcp:80,uid:425:tcp:79"  *  * This ruleset, for example, permits uid 425 to bind TCP ports 80 (http)  * and 79 (finger).  User names and group names can't be used directly  * because the kernel only knows about uids and gids.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac_policy.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_security_mac
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|portacl
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TrustedBSD mac_portacl policy controls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_portacl_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_mac_portacl
argument_list|,
name|OID_AUTO
argument_list|,
name|enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mac_portacl_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enforce portacl policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.mac.portacl.enabled"
argument_list|,
operator|&
name|mac_portacl_enabled
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_portacl_suser_exempt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_mac_portacl
argument_list|,
name|OID_AUTO
argument_list|,
name|suser_exempt
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mac_portacl_suser_exempt
argument_list|,
literal|0
argument_list|,
literal|"Privilege permits binding of any port"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.mac.portacl.suser_exempt"
argument_list|,
operator|&
name|mac_portacl_suser_exempt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_portacl_port_high
init|=
literal|1023
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_mac_portacl
argument_list|,
name|OID_AUTO
argument_list|,
name|port_high
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mac_portacl_port_high
argument_list|,
literal|0
argument_list|,
literal|"Highest port to enforce for"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.mac.portacl.port_high"
argument_list|,
operator|&
name|mac_portacl_port_high
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PORTACL
argument_list|,
literal|"portacl rule"
argument_list|,
literal|"Rules for mac_portacl"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MAC_RULE_STRING_LEN
value|1024
end_define

begin_define
define|#
directive|define
name|RULE_GID
value|1
end_define

begin_define
define|#
directive|define
name|RULE_UID
value|2
end_define

begin_define
define|#
directive|define
name|RULE_PROTO_TCP
value|1
end_define

begin_define
define|#
directive|define
name|RULE_PROTO_UDP
value|2
end_define

begin_struct
struct|struct
name|rule
block|{
name|id_t
name|r_id
decl_stmt|;
name|int
name|r_idtype
decl_stmt|;
name|u_int16_t
name|r_port
decl_stmt|;
name|int
name|r_protocol
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|rule
argument_list|)
name|r_entries
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|GID_STRING
value|"gid"
end_define

begin_define
define|#
directive|define
name|TCP_STRING
value|"tcp"
end_define

begin_define
define|#
directive|define
name|UID_STRING
value|"uid"
end_define

begin_define
define|#
directive|define
name|UDP_STRING
value|"udp"
end_define

begin_comment
comment|/*  * Text format for the rule string is that a rule consists of a  * comma-seperated list of elements.  Each element is in the form  * idtype:id:protocol:portnumber, and constitutes granting of permission  * for the specified binding.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|rule_sx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|rulehead
argument_list|,
argument|rule
argument_list|)
name|rule_head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|rule_string
index|[
name|MAC_RULE_STRING_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|toast_rules
parameter_list|(
name|struct
name|rulehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|rule
modifier|*
name|rule
decl_stmt|;
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|rule
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rule
argument_list|,
name|M_PORTACL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Note that there is an inherent race condition in the unload of modules  * and access via sysctl.  */
end_comment

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|sx_destroy
argument_list|(
operator|&
name|rule_sx
argument_list|)
expr_stmt|;
name|toast_rules
argument_list|(
operator|&
name|rule_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|sx_init
argument_list|(
operator|&
name|rule_sx
argument_list|,
literal|"rule_sx"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rule_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note: parsing routines are destructive on the passed string.  */
end_comment

begin_function
specifier|static
name|int
name|parse_rule_element
parameter_list|(
name|char
modifier|*
name|element
parameter_list|,
name|struct
name|rule
modifier|*
modifier|*
name|rule
parameter_list|)
block|{
name|char
modifier|*
name|idtype
decl_stmt|,
modifier|*
name|id
decl_stmt|,
modifier|*
name|protocol
decl_stmt|,
modifier|*
name|portnumber
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|rule
modifier|*
name|new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|,
name|M_PORTACL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|idtype
operator|=
name|strsep
argument_list|(
operator|&
name|element
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|idtype
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|id
operator|=
name|strsep
argument_list|(
operator|&
name|element
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|new
operator|->
name|r_id
operator|=
name|strtol
argument_list|(
name|id
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|idtype
argument_list|,
name|UID_STRING
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|r_idtype
operator|=
name|RULE_UID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|idtype
argument_list|,
name|GID_STRING
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|r_idtype
operator|=
name|RULE_GID
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|protocol
operator|=
name|strsep
argument_list|(
operator|&
name|element
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
name|TCP_STRING
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|r_protocol
operator|=
name|RULE_PROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
name|UDP_STRING
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|r_protocol
operator|=
name|RULE_PROTO_UDP
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|portnumber
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|portnumber
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|new
operator|->
name|r_port
operator|=
name|strtol
argument_list|(
name|portnumber
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|new
argument_list|,
name|M_PORTACL
argument_list|)
expr_stmt|;
operator|*
name|rule
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|rule
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_rules
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|rulehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|rule
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|element
operator|=
name|strsep
argument_list|(
operator|&
name|string
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|element
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|parse_rule_element
argument_list|(
name|element
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|new
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|toast_rules
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void rule_printf(struct sbuf *sb, struct rule *rule) { 	const char *idtype, *protocol;  	switch(rule->r_idtype) { 	case RULE_GID: 		idtype = GID_STRING; 		break; 	case RULE_UID: 		idtype = UID_STRING; 		break; 	default: 		panic("rule_printf: unknown idtype (%d)\n", rule->r_idtype); 	}  	switch (rule->r_protocol) { 	case RULE_PROTO_TCP: 		protocol = TCP_STRING; 		break; 	case RULE_PROTO_UDP: 		protocol = UDP_STRING; 		break; 	default: 		panic("rule_printf: unknown protocol (%d)\n", 		    rule->r_protocol); 	} 	sbuf_printf(sb, "%s:%jd:%s:%d", idtype, (intmax_t)rule->r_id, 	    protocol, rule->r_port); }  static char * rules_to_string(void) { 	struct rule *rule; 	struct sbuf *sb; 	int needcomma; 	char *temp;  	sb = sbuf_new(NULL, NULL, 0, SBUF_AUTOEXTEND); 	needcomma = 0; 	sx_slock(&rule_sx); 	for (rule = TAILQ_FIRST(&rule_head); rule != NULL; 	    rule = TAILQ_NEXT(rule, r_entries)) { 		if (!needcomma) 			needcomma = 1; 		else 			sbuf_printf(sb, ","); 		rule_printf(sb, rule); 	} 	sx_sunlock(&rule_sx); 	sbuf_finish(sb); 	temp = strdup(sbuf_data(sb), M_PORTACL); 	sbuf_delete(sb); 	return (temp); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Note: due to races, there is not a single serializable order  * between parallel calls to the sysctl.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_rules
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|copy_string
decl_stmt|,
modifier|*
name|new_string
decl_stmt|;
name|struct
name|rulehead
name|head
decl_stmt|,
name|save_head
decl_stmt|;
name|struct
name|rule
modifier|*
name|rule
decl_stmt|;
name|int
name|error
decl_stmt|;
name|new_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
block|{
name|new_string
operator|=
name|malloc
argument_list|(
name|MAC_RULE_STRING_LEN
argument_list|,
name|M_PORTACL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_string
argument_list|,
name|rule_string
argument_list|)
expr_stmt|;
name|string
operator|=
name|new_string
expr_stmt|;
block|}
else|else
name|string
operator|=
name|rule_string
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|string
argument_list|,
name|MAC_RULE_STRING_LEN
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|copy_string
operator|=
name|strdup
argument_list|(
name|string
argument_list|,
name|M_PORTACL
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
name|error
operator|=
name|parse_rules
argument_list|(
name|copy_string
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy_string
argument_list|,
name|M_PORTACL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|TAILQ_INIT
argument_list|(
operator|&
name|save_head
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rule_sx
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: Unfortunately, TAILQ doesn't yet have a supported 		 * assignment operator to copy one queue to another, due 	 	 * to a self-referential pointer in the tailq header. 		 * For now, do it the old-fashioned way. 		 */
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rule_head
argument_list|,
name|rule
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|save_head
argument_list|,
name|rule
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
argument_list|,
name|rule
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rule_head
argument_list|,
name|rule
argument_list|,
name|r_entries
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|rule_string
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rule_sx
argument_list|)
expr_stmt|;
name|toast_rules
argument_list|(
operator|&
name|save_head
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|new_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new_string
argument_list|,
name|M_PORTACL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_security_mac_portacl
argument_list|,
name|OID_AUTO
argument_list|,
name|rules
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_rules
argument_list|,
literal|"A"
argument_list|,
literal|"Rules"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|rules_check
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|family
parameter_list|,
name|int
name|type
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
block|{
name|struct
name|rule
modifier|*
name|rule
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
literal|0
block|printf("Check requested for euid %d, family %d, type %d, port %d\n", 	    cred->cr_uid, family, type, port);
endif|#
directive|endif
if|if
condition|(
name|port
operator|>
name|mac_portacl_port_high
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|EPERM
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|rule_sx
argument_list|)
expr_stmt|;
for|for
control|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule_head
argument_list|)
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|r_entries
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|==
name|SOCK_DGRAM
operator|&&
name|rule
operator|->
name|r_protocol
operator|!=
name|RULE_PROTO_UDP
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|SOCK_STREAM
operator|&&
name|rule
operator|->
name|r_protocol
operator|!=
name|RULE_PROTO_TCP
condition|)
continue|continue;
if|if
condition|(
name|port
operator|!=
name|rule
operator|->
name|r_port
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|r_idtype
operator|==
name|RULE_UID
condition|)
block|{
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
name|rule
operator|->
name|r_id
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|rule
operator|->
name|r_idtype
operator|==
name|RULE_GID
condition|)
block|{
if|if
condition|(
name|cred
operator|->
name|cr_gid
operator|==
name|rule
operator|->
name|r_id
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|groupmember
argument_list|(
name|rule
operator|->
name|r_id
argument_list|,
name|cred
argument_list|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|panic
argument_list|(
literal|"rules_check: unknown rule type %d"
argument_list|,
name|rule
operator|->
name|r_idtype
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|rule_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|mac_portacl_suser_exempt
operator|!=
literal|0
condition|)
name|error
operator|=
name|suser_cred
argument_list|(
name|cred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note, this only limits the ability to explicitly bind a port, it  * doesn't limit implicitly bound ports for outgoing connections where  * the source port is left up to the IP stack to determine automatically.  */
end_comment

begin_function
specifier|static
name|int
name|check_socket_bind
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|label
modifier|*
name|socketlabel
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sockaddr
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|family
decl_stmt|,
name|type
decl_stmt|;
name|u_int16_t
name|port
decl_stmt|;
comment|/* Only run if we are enabled. */
if|if
condition|(
name|mac_portacl_enabled
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only interested in IPv4 and IPv6 sockets. */
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|!=
name|PF_INET
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|!=
name|PF_INET6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Currently, we don't attempt to deal with SOCK_RAW, etc. */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_DGRAM
operator|&&
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reject addresses we don't understand; fail closed. */
if|if
condition|(
name|sockaddr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|&&
name|sockaddr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|family
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
expr_stmt|;
name|type
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sockaddr
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
return|return
operator|(
name|rules_check
argument_list|(
name|cred
argument_list|,
name|family
argument_list|,
name|type
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mac_policy_ops
name|mac_portacl_ops
init|=
block|{
operator|.
name|mpo_destroy
operator|=
name|destroy
block|,
operator|.
name|mpo_init
operator|=
name|init
block|,
operator|.
name|mpo_check_socket_bind
operator|=
name|check_socket_bind
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MAC_POLICY_SET
argument_list|(
operator|&
name|mac_portacl_ops
argument_list|,
name|trustedbsd_mac_portacl
argument_list|,
literal|"TrustedBSD MAC/portacl"
argument_list|,
name|MPC_LOADTIME_FLAG_UNLOADOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

