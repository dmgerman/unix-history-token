begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2002, 2006, 2009 Robert N. M. Watson  * Copyright (c) 2001 Ilmar S. Habibulin  * Copyright (c) 2001-2005 Networks Associates Technology, Inc.  * Copyright (c) 2005-2006 SPARTA, Inc.  * Copyright (c) 2008-2009 Apple Inc.  * All rights reserved.  *  * This software was developed by Robert Watson and Ilmar Habibulin for the  * TrustedBSD Project.  *  * This software was developed for the FreeBSD Project in part by Network  * Associates Laboratories, the Security Research Division of Network  * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"),  * as part of the DARPA CHATS research program.  *  * This software was enhanced by SPARTA ISSO under SPAWAR contract   * N66001-04-C-6019 ("SEFOS").  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Framework for extensible kernel access control.  This file contains core  * kernel infrastructure for the TrustedBSD MAC Framework, including policy  * registration, versioning, locking, error composition operator, and system  * calls.  *  * The MAC Framework implements three programming interfaces:  *  * - The kernel MAC interface, defined in mac_framework.h, and invoked  *   throughout the kernel to request security decisions, notify of security  *   related events, etc.  *  * - The MAC policy module interface, defined in mac_policy.h, which is  *   implemented by MAC policy modules and invoked by the MAC Framework to  *   forward kernel security requests and notifications to policy modules.  *  * - The user MAC API, defined in mac.h, which allows user programs to query  *   and set label state on objects.  *  * The majority of the MAC Framework implementation may be found in  * src/sys/security/mac.  Sample policy modules may be found in  * src/sys/security/mac_*.  */
end_comment

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_internal.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_policy.h>
end_include

begin_comment
comment|/*  * DTrace SDT provider for MAC.  */
end_comment

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|mac
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE2
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|modevent
argument_list|,
literal|"int"
argument_list|,
literal|"struct mac_policy_conf *mpc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
specifier|register
argument_list|,
literal|"struct mac_policy_conf *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|unregister
argument_list|,
literal|"struct mac_policy_conf *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Root sysctl node for all MAC and MAC policy controls.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_security
argument_list|,
name|OID_AUTO
argument_list|,
name|mac
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TrustedBSD MAC policy controls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Declare that the kernel provides MAC support, version 3 (FreeBSD 7.x).  * This permits modules to refuse to be loaded if the necessary support isn't  * present, even if it's pre-boot.  */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|kernel_mac_support
argument_list|,
name|MAC_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_version
init|=
name|MAC_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_version
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Labels consist of a indexed set of "slots", which are allocated policies  * as required.  The MAC Framework maintains a bitmask of slots allocated so  * far to prevent reuse.  Slots cannot be reused, as the MAC Framework  * guarantees that newly allocated slots in labels will be NULL unless  * otherwise initialized, and because we do not have a mechanism to garbage  * collect slots on policy unload.  As labeled policies tend to be statically  * loaded during boot, and not frequently unloaded and reloaded, this is not  * generally an issue.  */
end_comment

begin_if
if|#
directive|if
name|MAC_MAX_SLOTS
operator|>
literal|32
end_if

begin_error
error|#
directive|error
literal|"MAC_MAX_SLOTS too large"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_max_slots
init|=
name|MAC_MAX_SLOTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_slot_offsets_free
init|=
operator|(
literal|1
operator|<<
name|MAC_MAX_SLOTS
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|max_slots
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_max_slots
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Has the kernel started generating labeled objects yet?  All read/write  * access to this variable is serialized during the boot process.  Following  * the end of serialization, we don't update this flag; no locking.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mac_late
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each policy declares a mask of object types requiring labels to be  * allocated for them.  For convenience, we combine and cache the bitwise or  * of the per-policy object flags to track whether we will allocate a label  * for an object type at run-time.  */
end_comment

begin_decl_stmt
name|uint64_t
name|mac_labeled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|labeled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_labeled
argument_list|,
literal|0
argument_list|,
literal|"Mask of object types being labeled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MACTEMP
argument_list|,
literal|"mactemp"
argument_list|,
literal|"MAC temporary label storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * mac_static_policy_list holds a list of policy modules that are not loaded  * while the system is "live", and cannot be unloaded.  These policies can be  * invoked without holding the busy count.  *  * mac_policy_list stores the list of dynamic policies.  A busy count is  * maintained for the list, stored in mac_policy_busy.  The busy count is  * protected by mac_policy_mtx; the list may be modified only while the busy  * count is 0, requiring that the lock be held to prevent new references to  * the list from being acquired.  For almost all operations, incrementing the  * busy count is sufficient to guarantee consistency, as the list cannot be  * modified while the busy count is elevated.  For a few special operations  * involving a change to the list of active policies, the mtx itself must be  * held.  A condition variable, mac_policy_cv, is used to signal potential  * exclusive consumers that they should try to acquire the lock if a first  * attempt at exclusive access fails.  *  * This design intentionally avoids fairness, and may starve attempts to  * acquire an exclusive lock on a busy system.  This is required because we  * do not ever want acquiring a read reference to perform an unbounded length  * sleep.  Read references are acquired in ithreads, network isrs, etc, and  * any unbounded blocking could lead quickly to deadlock.  *  * Another reason for never blocking on read references is that the MAC  * Framework may recurse: if a policy calls a VOP, for example, this might  * lead to vnode life cycle operations (such as init/destroy).  *  * If the kernel option MAC_STATIC has been compiled in, all locking becomes  * a no-op, and the global list of policies is not allowed to change after  * early boot.  *  * XXXRW: Currently, we signal mac_policy_cv every time the framework becomes  * unbusy and there is a thread waiting to enter it exclusively.  Since it   * may take some time before the thread runs, we may issue a lot of signals.  * We should instead keep track of the fact that we've signalled, taking into   * account that the framework may be busy again by the time the thread runs,   * requiring us to re-signal.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC_STATIC
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mac_policy_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cv
name|mac_policy_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_policy_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_policy_wait
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|mac_policy_list_head
name|mac_policy_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mac_policy_list_head
name|mac_static_policy_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We manually invoke WITNESS_WARN() to allow Witness to generate warnings  * even if we don't end up ever triggering the wait at run-time.  The  * consumer of the exclusive interface must not hold any locks (other than  * potentially Giant) since we may sleep for long (potentially indefinite)  * periods of time waiting for the framework to become quiescent so that a  * policy list change may be made.  */
end_comment

begin_function
name|void
name|mac_policy_grab_exclusive
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"mac_policy_grab_exclusive() at %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|mac_policy_count
operator|!=
literal|0
condition|)
block|{
name|mac_policy_wait
operator|++
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|mac_policy_cv
argument_list|,
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
name|mac_policy_wait
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_assert_exclusive
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|mtx_assert
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mac_policy_count
operator|==
literal|0
argument_list|,
operator|(
literal|"mac_policy_assert_exclusive(): not exclusive"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_release_exclusive
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
name|int
name|dowakeup
decl_stmt|;
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|KASSERT
argument_list|(
name|mac_policy_count
operator|==
literal|0
argument_list|,
operator|(
literal|"mac_policy_release_exclusive(): not exclusive"
operator|)
argument_list|)
expr_stmt|;
name|dowakeup
operator|=
operator|(
name|mac_policy_wait
operator|!=
literal|0
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowakeup
condition|)
name|cv_signal
argument_list|(
operator|&
name|mac_policy_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_list_busy
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
name|mac_policy_count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|mac_policy_list_conditional_busy
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|mac_policy_list
argument_list|)
condition|)
block|{
name|mac_policy_count
operator|++
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_list_unbusy
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
name|int
name|dowakeup
decl_stmt|;
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
name|mac_policy_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|mac_policy_count
operator|>=
literal|0
argument_list|,
operator|(
literal|"MAC_POLICY_LIST_LOCK"
operator|)
argument_list|)
expr_stmt|;
name|dowakeup
operator|=
operator|(
name|mac_policy_count
operator|==
literal|0
operator|&&
name|mac_policy_wait
operator|!=
literal|0
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowakeup
condition|)
name|cv_signal
argument_list|(
operator|&
name|mac_policy_cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize the MAC subsystem, including appropriate SMP locks.  */
end_comment

begin_function
specifier|static
name|void
name|mac_init
parameter_list|(
name|void
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|mac_static_policy_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|mac_policy_list
argument_list|)
expr_stmt|;
name|mac_labelzone_init
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC_STATIC
name|mtx_init
argument_list|(
operator|&
name|mac_policy_mtx
argument_list|,
literal|"mac_policy_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|mac_policy_cv
argument_list|,
literal|"mac_policy_cv"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * For the purposes of modules that want to know if they were loaded "early",  * set the mac_late flag once we've processed modules either linked into the  * kernel, or loaded before the kernel startup.  */
end_comment

begin_function
specifier|static
name|void
name|mac_late_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mac_late
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a policy, derive from its set of non-NULL label init methods what  * object types the policy is interested in.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|mac_policy_getlabeled
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|uint64_t
name|labeled
decl_stmt|;
define|#
directive|define
name|MPC_FLAG
parameter_list|(
name|method
parameter_list|,
name|flag
parameter_list|)
define|\
value|if (mpc->mpc_ops->mpo_ ## method != NULL)			\ 		labeled |= (flag);					\  	labeled = 0;
name|MPC_FLAG
argument_list|(
name|cred_init_label
argument_list|,
name|MPC_OBJECT_CRED
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|proc_init_label
argument_list|,
name|MPC_OBJECT_PROC
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|vnode_init_label
argument_list|,
name|MPC_OBJECT_VNODE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|inpcb_init_label
argument_list|,
name|MPC_OBJECT_INPCB
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|socket_init_label
argument_list|,
name|MPC_OBJECT_SOCKET
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|devfs_init_label
argument_list|,
name|MPC_OBJECT_DEVFS
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|mbuf_init_label
argument_list|,
name|MPC_OBJECT_MBUF
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ipq_init_label
argument_list|,
name|MPC_OBJECT_IPQ
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ifnet_init_label
argument_list|,
name|MPC_OBJECT_IFNET
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|bpfdesc_init_label
argument_list|,
name|MPC_OBJECT_BPFDESC
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|pipe_init_label
argument_list|,
name|MPC_OBJECT_PIPE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|mount_init_label
argument_list|,
name|MPC_OBJECT_MOUNT
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|posixsem_init_label
argument_list|,
name|MPC_OBJECT_POSIXSEM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|posixshm_init_label
argument_list|,
name|MPC_OBJECT_POSIXSHM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvmsg_init_label
argument_list|,
name|MPC_OBJECT_SYSVMSG
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvmsq_init_label
argument_list|,
name|MPC_OBJECT_SYSVMSQ
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvsem_init_label
argument_list|,
name|MPC_OBJECT_SYSVSEM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvshm_init_label
argument_list|,
name|MPC_OBJECT_SYSVSHM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|syncache_init_label
argument_list|,
name|MPC_OBJECT_SYNCACHE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ip6q_init_label
argument_list|,
name|MPC_OBJECT_IP6Q
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MPC_FLAG
return|return
operator|(
name|labeled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When policies are loaded or unloaded, walk the list of registered policies  * and built mac_labeled, a bitmask representing the union of all objects  * requiring labels across all policies.  */
end_comment

begin_function
specifier|static
name|void
name|mac_policy_updateflags
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|mpc
decl_stmt|;
name|mac_policy_assert_exclusive
argument_list|()
expr_stmt|;
name|mac_labeled
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mpc
argument_list|,
argument|&mac_static_policy_list
argument_list|,
argument|mpc_list
argument_list|)
name|mac_labeled
operator||=
name|mac_policy_getlabeled
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mpc
argument_list|,
argument|&mac_policy_list
argument_list|,
argument|mpc_list
argument_list|)
name|mac_labeled
operator||=
name|mac_policy_getlabeled
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_policy_register
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|tmpc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|slot
decl_stmt|,
name|static_entry
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We don't technically need exclusive access while !mac_late, but 	 * hold it for assertion consistency. 	 */
name|mac_policy_grab_exclusive
argument_list|()
expr_stmt|;
comment|/* 	 * If the module can potentially be unloaded, or we're loading late, 	 * we have to stick it in the non-static list and pay an extra 	 * performance overhead.  Otherwise, we can pay a light locking cost 	 * and stick it in the static list. 	 */
name|static_entry
operator|=
operator|(
operator|!
name|mac_late
operator|&&
operator|!
operator|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_UNLOADOK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|static_entry
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|tmpc
argument_list|,
argument|&mac_static_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpc
operator|->
name|mpc_name
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|tmpc
argument_list|,
argument|&mac_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpc
operator|->
name|mpc_name
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|mpc
operator|->
name|mpc_field_off
operator|!=
name|NULL
condition|)
block|{
name|slot
operator|=
name|ffs
argument_list|(
name|mac_slot_offsets_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|slot
operator|--
expr_stmt|;
name|mac_slot_offsets_free
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|)
expr_stmt|;
operator|*
name|mpc
operator|->
name|mpc_field_off
operator|=
name|slot
expr_stmt|;
block|}
name|mpc
operator|->
name|mpc_runtime_flags
operator||=
name|MPC_RUNTIME_FLAG_REGISTERED
expr_stmt|;
comment|/* 	 * If we're loading a MAC module after the framework has initialized, 	 * it has to go into the dynamic list.  If we're loading it before 	 * we've finished initializing, it can go into the static list with 	 * weaker locker requirements. 	 */
if|if
condition|(
name|static_entry
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mac_static_policy_list
argument_list|,
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mac_policy_list
argument_list|,
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
comment|/* 	 * Per-policy initialization.  Currently, this takes place under the 	 * exclusive lock, so policies must not sleep in their init method. 	 * In the future, we may want to separate "init" from "start", with 	 * "init" occuring without the lock held.  Likewise, on tear-down, 	 * breaking out "stop" from "destroy". 	 */
if|if
condition|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_init
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_init
operator|)
operator|)
operator|(
name|mpc
operator|)
expr_stmt|;
name|mac_policy_updateflags
argument_list|()
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
specifier|register
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Security policy loaded: %s (%s)\n"
argument_list|,
name|mpc
operator|->
name|mpc_fullname
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
name|out
label|:
name|mac_policy_release_exclusive
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_policy_unregister
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
comment|/* 	 * If we fail the load, we may get a request to unload.  Check to see 	 * if we did the run-time registration, and if not, silently succeed. 	 */
name|mac_policy_grab_exclusive
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_runtime_flags
operator|&
name|MPC_RUNTIME_FLAG_REGISTERED
operator|)
operator|==
literal|0
condition|)
block|{
name|mac_policy_release_exclusive
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Don't allow unloading modules with private data. 	 */
block|if (mpc->mpc_field_off != NULL) { 		MAC_POLICY_LIST_UNLOCK(); 		return (EBUSY); 	}
endif|#
directive|endif
comment|/* 	 * Only allow the unload to proceed if the module is unloadable by 	 * its own definition. 	 */
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_UNLOADOK
operator|)
operator|==
literal|0
condition|)
block|{
name|mac_policy_release_exclusive
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_destroy
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_destroy
operator|)
operator|)
operator|(
name|mpc
operator|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
name|mpc
operator|->
name|mpc_runtime_flags
operator|&=
operator|~
name|MPC_RUNTIME_FLAG_REGISTERED
expr_stmt|;
name|mac_policy_updateflags
argument_list|()
expr_stmt|;
name|mac_policy_release_exclusive
argument_list|()
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|unregister
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Security policy unload: %s (%s)\n"
argument_list|,
name|mpc
operator|->
name|mpc_fullname
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow MAC policy modules to register during boot, etc.  */
end_comment

begin_function
name|int
name|mac_policy_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|mpc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mpc
operator|=
operator|(
expr|struct
name|mac_policy_conf
operator|*
operator|)
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC_STATIC
if|if
condition|(
name|mac_late
condition|)
block|{
name|printf
argument_list|(
literal|"mac_policy_modevent: MAC_STATIC and late\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
endif|#
directive|endif
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|modevent
argument_list|,
name|type
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_NOTLATE
operator|&&
name|mac_late
condition|)
block|{
name|printf
argument_list|(
literal|"mac_policy_modevent: can't load %s policy "
literal|"after booting\n"
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mac_policy_register
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Don't unregister the module if it was never registered. */
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_runtime_flags
operator|&
name|MPC_RUNTIME_FLAG_REGISTERED
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|mac_policy_unregister
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define an error value precedence, and given two arguments, selects the  * value with the higher precedence.  */
end_comment

begin_function
name|int
name|mac_error_select
parameter_list|(
name|int
name|error1
parameter_list|,
name|int
name|error2
parameter_list|)
block|{
comment|/* Certain decision-making errors take top priority. */
if|if
condition|(
name|error1
operator|==
name|EDEADLK
operator|||
name|error2
operator|==
name|EDEADLK
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
comment|/* Invalid arguments should be reported where possible. */
if|if
condition|(
name|error1
operator|==
name|EINVAL
operator|||
name|error2
operator|==
name|EINVAL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Precedence goes to "visibility", with both process and file. */
if|if
condition|(
name|error1
operator|==
name|ESRCH
operator|||
name|error2
operator|==
name|ESRCH
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|error1
operator|==
name|ENOENT
operator|||
name|error2
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Precedence goes to DAC/MAC protections. */
if|if
condition|(
name|error1
operator|==
name|EACCES
operator|||
name|error2
operator|==
name|EACCES
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* Precedence goes to privilege. */
if|if
condition|(
name|error1
operator|==
name|EPERM
operator|||
name|error2
operator|==
name|EPERM
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Precedence goes to error over success; otherwise, arbitrary. */
if|if
condition|(
name|error1
operator|!=
literal|0
condition|)
return|return
operator|(
name|error1
operator|)
return|;
return|return
operator|(
name|error2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mac_check_structmac_consistent
parameter_list|(
name|struct
name|mac
modifier|*
name|mac
parameter_list|)
block|{
if|if
condition|(
name|mac
operator|->
name|m_buflen
operator|<
literal|0
operator|||
name|mac
operator|->
name|m_buflen
operator|>
name|MAC_MAX_LABEL_BUF_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mac
argument_list|,
name|SI_SUB_MAC
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mac_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mac_late
argument_list|,
name|SI_SUB_MAC_LATE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mac_late_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

