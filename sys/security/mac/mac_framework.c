begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2002, 2006, 2009 Robert N. M. Watson  * Copyright (c) 2001 Ilmar S. Habibulin  * Copyright (c) 2001-2005 Networks Associates Technology, Inc.  * Copyright (c) 2005-2006 SPARTA, Inc.  * Copyright (c) 2008-2009 Apple Inc.  * All rights reserved.  *  * This software was developed by Robert Watson and Ilmar Habibulin for the  * TrustedBSD Project.  *  * This software was developed for the FreeBSD Project in part by Network  * Associates Laboratories, the Security Research Division of Network  * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"),  * as part of the DARPA CHATS research program.  *  * This software was enhanced by SPARTA ISSO under SPAWAR contract   * N66001-04-C-6019 ("SEFOS").  *  * This software was developed at the University of Cambridge Computer  * Laboratory with support from a grant from Google, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Framework for extensible kernel access control.  This file contains core  * kernel infrastructure for the TrustedBSD MAC Framework, including policy  * registration, versioning, locking, error composition operator, and system  * calls.  *  * The MAC Framework implements three programming interfaces:  *  * - The kernel MAC interface, defined in mac_framework.h, and invoked  *   throughout the kernel to request security decisions, notify of security  *   related events, etc.  *  * - The MAC policy module interface, defined in mac_policy.h, which is  *   implemented by MAC policy modules and invoked by the MAC Framework to  *   forward kernel security requests and notifications to policy modules.  *  * - The user MAC API, defined in mac.h, which allows user programs to query  *   and set label state on objects.  *  * The majority of the MAC Framework implementation may be found in  * src/sys/security/mac.  Sample policy modules may be found in  * src/sys/security/mac_*.  */
end_comment

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_internal.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_policy.h>
end_include

begin_comment
comment|/*  * DTrace SDT providers for MAC.  */
end_comment

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|mac
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|mac_framework
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE2
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|modevent
argument_list|,
literal|"int"
argument_list|,
literal|"struct mac_policy_conf *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
specifier|register
argument_list|,
literal|"struct mac_policy_conf *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|unregister
argument_list|,
literal|"struct mac_policy_conf *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Root sysctl node for all MAC and MAC policy controls.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_security
argument_list|,
name|OID_AUTO
argument_list|,
name|mac
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TrustedBSD MAC policy controls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Declare that the kernel provides MAC support, version 3 (FreeBSD 7.x).  * This permits modules to refuse to be loaded if the necessary support isn't  * present, even if it's pre-boot.  */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|kernel_mac_support
argument_list|,
name|MAC_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_version
init|=
name|MAC_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_version
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Labels consist of a indexed set of "slots", which are allocated policies  * as required.  The MAC Framework maintains a bitmask of slots allocated so  * far to prevent reuse.  Slots cannot be reused, as the MAC Framework  * guarantees that newly allocated slots in labels will be NULL unless  * otherwise initialized, and because we do not have a mechanism to garbage  * collect slots on policy unload.  As labeled policies tend to be statically  * loaded during boot, and not frequently unloaded and reloaded, this is not  * generally an issue.  */
end_comment

begin_if
if|#
directive|if
name|MAC_MAX_SLOTS
operator|>
literal|32
end_if

begin_error
error|#
directive|error
literal|"MAC_MAX_SLOTS too large"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_max_slots
init|=
name|MAC_MAX_SLOTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mac_slot_offsets_free
init|=
operator|(
literal|1
operator|<<
name|MAC_MAX_SLOTS
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|max_slots
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_max_slots
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Has the kernel started generating labeled objects yet?  All read/write  * access to this variable is serialized during the boot process.  Following  * the end of serialization, we don't update this flag; no locking.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mac_late
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each policy declares a mask of object types requiring labels to be  * allocated for them.  For convenience, we combine and cache the bitwise or  * of the per-policy object flags to track whether we will allocate a label  * for an object type at run-time.  */
end_comment

begin_decl_stmt
name|uint64_t
name|mac_labeled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_security_mac
argument_list|,
name|OID_AUTO
argument_list|,
name|labeled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mac_labeled
argument_list|,
literal|0
argument_list|,
literal|"Mask of object types being labeled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MACTEMP
argument_list|,
literal|"mactemp"
argument_list|,
literal|"MAC temporary label storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MAC policy modules are placed in one of two lists: mac_static_policy_list,  * for policies that are loaded early and cannot be unloaded, and  * mac_policy_list, which holds policies either loaded later in the boot  * cycle or that may be unloaded.  The static policy list does not require  * locks to iterate over, but the dynamic list requires synchronization.  * Support for dynamic policy loading can be compiled out using the  * MAC_STATIC kernel option.  *  * The dynamic policy list is protected by two locks: modifying the list  * requires both locks to be held exclusively.  One of the locks,  * mac_policy_rm, is acquired over policy entry points that will never sleep;  * the other, mac_policy_sx, is acquire over policy entry points that may  * sleep.  The former category will be used when kernel locks may be held  * over calls to the MAC Framework, during network processing in ithreads,  * etc.  The latter will tend to involve potentially blocking memory  * allocations, extended attribute I/O, etc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC_STATIC
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|mac_policy_rm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-sleeping entry points. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|mac_policy_sx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sleeping entry points. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|mac_policy_list_head
name|mac_policy_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mac_policy_list_head
name|mac_static_policy_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mac_policy_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Registered policy count. */
end_comment

begin_function_decl
specifier|static
name|void
name|mac_policy_xlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mac_policy_xlock_assert
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mac_policy_xunlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mac_policy_slock_nosleep
parameter_list|(
name|struct
name|rm_priotracker
modifier|*
name|tracker
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|rm_rlock
argument_list|(
operator|&
name|mac_policy_rm
argument_list|,
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_slock_sleep
parameter_list|(
name|void
parameter_list|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"mac_policy_slock_sleep"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|sx_slock
argument_list|(
operator|&
name|mac_policy_sx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_sunlock_nosleep
parameter_list|(
name|struct
name|rm_priotracker
modifier|*
name|tracker
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|rm_runlock
argument_list|(
operator|&
name|mac_policy_rm
argument_list|,
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mac_policy_sunlock_sleep
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|sx_sunlock
argument_list|(
operator|&
name|mac_policy_sx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mac_policy_xlock
parameter_list|(
name|void
parameter_list|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"mac_policy_xlock()"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|sx_xlock
argument_list|(
operator|&
name|mac_policy_sx
argument_list|)
expr_stmt|;
name|rm_wlock
argument_list|(
operator|&
name|mac_policy_rm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mac_policy_xunlock
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
name|rm_wunlock
argument_list|(
operator|&
name|mac_policy_rm
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mac_policy_sx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mac_policy_xlock_assert
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MAC_STATIC
if|if
condition|(
operator|!
name|mac_late
condition|)
return|return;
comment|/* XXXRW: rm_assert(&mac_policy_rm, RA_WLOCKED); */
name|sx_assert
argument_list|(
operator|&
name|mac_policy_sx
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize the MAC subsystem, including appropriate SMP locks.  */
end_comment

begin_function
specifier|static
name|void
name|mac_init
parameter_list|(
name|void
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|mac_static_policy_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|mac_policy_list
argument_list|)
expr_stmt|;
name|mac_labelzone_init
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC_STATIC
name|rm_init_flags
argument_list|(
operator|&
name|mac_policy_rm
argument_list|,
literal|"mac_policy_rm"
argument_list|,
name|RM_NOWITNESS
operator||
name|RM_RECURSE
argument_list|)
expr_stmt|;
name|sx_init_flags
argument_list|(
operator|&
name|mac_policy_sx
argument_list|,
literal|"mac_policy_sx"
argument_list|,
name|SX_NOWITNESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * For the purposes of modules that want to know if they were loaded "early",  * set the mac_late flag once we've processed modules either linked into the  * kernel, or loaded before the kernel startup.  */
end_comment

begin_function
specifier|static
name|void
name|mac_late_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mac_late
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a policy, derive from its set of non-NULL label init methods what  * object types the policy is interested in.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|mac_policy_getlabeled
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|uint64_t
name|labeled
decl_stmt|;
define|#
directive|define
name|MPC_FLAG
parameter_list|(
name|method
parameter_list|,
name|flag
parameter_list|)
define|\
value|if (mpc->mpc_ops->mpo_ ## method != NULL)			\ 		labeled |= (flag);					\  	labeled = 0;
name|MPC_FLAG
argument_list|(
name|cred_init_label
argument_list|,
name|MPC_OBJECT_CRED
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|proc_init_label
argument_list|,
name|MPC_OBJECT_PROC
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|vnode_init_label
argument_list|,
name|MPC_OBJECT_VNODE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|inpcb_init_label
argument_list|,
name|MPC_OBJECT_INPCB
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|socket_init_label
argument_list|,
name|MPC_OBJECT_SOCKET
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|devfs_init_label
argument_list|,
name|MPC_OBJECT_DEVFS
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|mbuf_init_label
argument_list|,
name|MPC_OBJECT_MBUF
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ipq_init_label
argument_list|,
name|MPC_OBJECT_IPQ
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ifnet_init_label
argument_list|,
name|MPC_OBJECT_IFNET
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|bpfdesc_init_label
argument_list|,
name|MPC_OBJECT_BPFDESC
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|pipe_init_label
argument_list|,
name|MPC_OBJECT_PIPE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|mount_init_label
argument_list|,
name|MPC_OBJECT_MOUNT
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|posixsem_init_label
argument_list|,
name|MPC_OBJECT_POSIXSEM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|posixshm_init_label
argument_list|,
name|MPC_OBJECT_POSIXSHM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvmsg_init_label
argument_list|,
name|MPC_OBJECT_SYSVMSG
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvmsq_init_label
argument_list|,
name|MPC_OBJECT_SYSVMSQ
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvsem_init_label
argument_list|,
name|MPC_OBJECT_SYSVSEM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|sysvshm_init_label
argument_list|,
name|MPC_OBJECT_SYSVSHM
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|syncache_init_label
argument_list|,
name|MPC_OBJECT_SYNCACHE
argument_list|)
expr_stmt|;
name|MPC_FLAG
argument_list|(
name|ip6q_init_label
argument_list|,
name|MPC_OBJECT_IP6Q
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MPC_FLAG
return|return
operator|(
name|labeled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When policies are loaded or unloaded, walk the list of registered policies  * and built mac_labeled, a bitmask representing the union of all objects  * requiring labels across all policies.  */
end_comment

begin_function
specifier|static
name|void
name|mac_policy_update
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|mpc
decl_stmt|;
name|mac_policy_xlock_assert
argument_list|()
expr_stmt|;
name|mac_labeled
operator|=
literal|0
expr_stmt|;
name|mac_policy_count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mpc
argument_list|,
argument|&mac_static_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
name|mac_labeled
operator||=
name|mac_policy_getlabeled
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
name|mac_policy_count
operator|++
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|mpc
argument_list|,
argument|&mac_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
name|mac_labeled
operator||=
name|mac_policy_getlabeled
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
name|mac_policy_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mac_policy_register
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|tmpc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|slot
decl_stmt|,
name|static_entry
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We don't technically need exclusive access while !mac_late, but 	 * hold it for assertion consistency. 	 */
name|mac_policy_xlock
argument_list|()
expr_stmt|;
comment|/* 	 * If the module can potentially be unloaded, or we're loading late, 	 * we have to stick it in the non-static list and pay an extra 	 * performance overhead.  Otherwise, we can pay a light locking cost 	 * and stick it in the static list. 	 */
name|static_entry
operator|=
operator|(
operator|!
name|mac_late
operator|&&
operator|!
operator|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_UNLOADOK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|static_entry
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|tmpc
argument_list|,
argument|&mac_static_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpc
operator|->
name|mpc_name
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|tmpc
argument_list|,
argument|&mac_policy_list
argument_list|,
argument|mpc_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpc
operator|->
name|mpc_name
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|mpc
operator|->
name|mpc_field_off
operator|!=
name|NULL
condition|)
block|{
name|slot
operator|=
name|ffs
argument_list|(
name|mac_slot_offsets_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|slot
operator|--
expr_stmt|;
name|mac_slot_offsets_free
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|)
expr_stmt|;
operator|*
name|mpc
operator|->
name|mpc_field_off
operator|=
name|slot
expr_stmt|;
block|}
name|mpc
operator|->
name|mpc_runtime_flags
operator||=
name|MPC_RUNTIME_FLAG_REGISTERED
expr_stmt|;
comment|/* 	 * If we're loading a MAC module after the framework has initialized, 	 * it has to go into the dynamic list.  If we're loading it before 	 * we've finished initializing, it can go into the static list with 	 * weaker locker requirements. 	 */
if|if
condition|(
name|static_entry
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mac_static_policy_list
argument_list|,
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mac_policy_list
argument_list|,
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
comment|/* 	 * Per-policy initialization.  Currently, this takes place under the 	 * exclusive lock, so policies must not sleep in their init method. 	 * In the future, we may want to separate "init" from "start", with 	 * "init" occuring without the lock held.  Likewise, on tear-down, 	 * breaking out "stop" from "destroy". 	 */
if|if
condition|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_init
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_init
operator|)
operator|)
operator|(
name|mpc
operator|)
expr_stmt|;
name|mac_policy_update
argument_list|()
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
specifier|register
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Security policy loaded: %s (%s)\n"
argument_list|,
name|mpc
operator|->
name|mpc_fullname
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
name|out
label|:
name|mac_policy_xunlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mac_policy_unregister
parameter_list|(
name|struct
name|mac_policy_conf
modifier|*
name|mpc
parameter_list|)
block|{
comment|/* 	 * If we fail the load, we may get a request to unload.  Check to see 	 * if we did the run-time registration, and if not, silently succeed. 	 */
name|mac_policy_xlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_runtime_flags
operator|&
name|MPC_RUNTIME_FLAG_REGISTERED
operator|)
operator|==
literal|0
condition|)
block|{
name|mac_policy_xunlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Don't allow unloading modules with private data. 	 */
block|if (mpc->mpc_field_off != NULL) { 		mac_policy_xunlock(); 		return (EBUSY); 	}
endif|#
directive|endif
comment|/* 	 * Only allow the unload to proceed if the module is unloadable by 	 * its own definition. 	 */
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_UNLOADOK
operator|)
operator|==
literal|0
condition|)
block|{
name|mac_policy_xunlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_destroy
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|mpc
operator|->
name|mpc_ops
operator|->
name|mpo_destroy
operator|)
operator|)
operator|(
name|mpc
operator|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mpc
argument_list|,
name|mpc_list
argument_list|)
expr_stmt|;
name|mpc
operator|->
name|mpc_runtime_flags
operator|&=
operator|~
name|MPC_RUNTIME_FLAG_REGISTERED
expr_stmt|;
name|mac_policy_update
argument_list|()
expr_stmt|;
name|mac_policy_xunlock
argument_list|()
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|unregister
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Security policy unload: %s (%s)\n"
argument_list|,
name|mpc
operator|->
name|mpc_fullname
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow MAC policy modules to register during boot, etc.  */
end_comment

begin_function
name|int
name|mac_policy_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mac_policy_conf
modifier|*
name|mpc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mpc
operator|=
operator|(
expr|struct
name|mac_policy_conf
operator|*
operator|)
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC_STATIC
if|if
condition|(
name|mac_late
condition|)
block|{
name|printf
argument_list|(
literal|"mac_policy_modevent: MAC_STATIC and late\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
endif|#
directive|endif
name|SDT_PROBE
argument_list|(
name|mac
argument_list|,
name|kernel
argument_list|,
name|policy
argument_list|,
name|modevent
argument_list|,
name|type
argument_list|,
name|mpc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|mpc
operator|->
name|mpc_loadtime_flags
operator|&
name|MPC_LOADTIME_FLAG_NOTLATE
operator|&&
name|mac_late
condition|)
block|{
name|printf
argument_list|(
literal|"mac_policy_modevent: can't load %s policy "
literal|"after booting\n"
argument_list|,
name|mpc
operator|->
name|mpc_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mac_policy_register
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Don't unregister the module if it was never registered. */
if|if
condition|(
operator|(
name|mpc
operator|->
name|mpc_runtime_flags
operator|&
name|MPC_RUNTIME_FLAG_REGISTERED
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|mac_policy_unregister
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define an error value precedence, and given two arguments, selects the  * value with the higher precedence.  */
end_comment

begin_function
name|int
name|mac_error_select
parameter_list|(
name|int
name|error1
parameter_list|,
name|int
name|error2
parameter_list|)
block|{
comment|/* Certain decision-making errors take top priority. */
if|if
condition|(
name|error1
operator|==
name|EDEADLK
operator|||
name|error2
operator|==
name|EDEADLK
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
comment|/* Invalid arguments should be reported where possible. */
if|if
condition|(
name|error1
operator|==
name|EINVAL
operator|||
name|error2
operator|==
name|EINVAL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Precedence goes to "visibility", with both process and file. */
if|if
condition|(
name|error1
operator|==
name|ESRCH
operator|||
name|error2
operator|==
name|ESRCH
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|error1
operator|==
name|ENOENT
operator|||
name|error2
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Precedence goes to DAC/MAC protections. */
if|if
condition|(
name|error1
operator|==
name|EACCES
operator|||
name|error2
operator|==
name|EACCES
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* Precedence goes to privilege. */
if|if
condition|(
name|error1
operator|==
name|EPERM
operator|||
name|error2
operator|==
name|EPERM
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* Precedence goes to error over success; otherwise, arbitrary. */
if|if
condition|(
name|error1
operator|!=
literal|0
condition|)
return|return
operator|(
name|error1
operator|)
return|;
return|return
operator|(
name|error2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mac_check_structmac_consistent
parameter_list|(
name|struct
name|mac
modifier|*
name|mac
parameter_list|)
block|{
if|if
condition|(
name|mac
operator|->
name|m_buflen
operator|>
name|MAC_MAX_LABEL_BUF_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mac
argument_list|,
name|SI_SUB_MAC
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mac_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mac_late
argument_list|,
name|SI_SUB_MAC_LATE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|mac_late_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

