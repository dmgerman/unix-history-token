begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by NAI Labs, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/pipe.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|"kernel_interface.h"
end_include

begin_include
include|#
directive|include
file|"lomacfs.h"
end_include

begin_include
include|#
directive|include
file|"kernel_log.h"
end_include

begin_comment
comment|/*  * Reuse the eflags field of proc.p_vmspace->vm_map.header (since it is  * currently not used for anything but a placeholder, and won't change  * generally...) as storage for our process-based information.  *  * This is the only really effective way to make thread-based MAC  * easy.  */
end_comment

begin_define
define|#
directive|define
name|p_eflags
value|p_vmspace->vm_map.header.eflags
end_define

begin_define
define|#
directive|define
name|EF_HIGHEST_LEVEL
value|0x00010000
end_define

begin_define
define|#
directive|define
name|EF_LOWEST_LEVEL
value|0x00020000
end_define

begin_define
define|#
directive|define
name|EF_LEVEL_MASK
value|0x00030000
end_define

begin_define
define|#
directive|define
name|EF_ATTR_NONETDEMOTE
value|0x00040000
end_define

begin_define
define|#
directive|define
name|EF_ATTR_NODEMOTE
value|0x00080000
end_define

begin_define
define|#
directive|define
name|EF_ATTR_MASK
value|0x000c0000
end_define

begin_function
specifier|static
name|u_int
name|level2subjectbits
parameter_list|(
name|level_t
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|LOMAC_HIGHEST_LEVEL
case|:
return|return
operator|(
name|EF_HIGHEST_LEVEL
operator|)
return|;
case|case
name|LOMAC_LOWEST_LEVEL
case|:
return|return
operator|(
name|EF_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"level2subjectbits: invalid level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|level_t
name|subjectbits2level
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_LEVEL_MASK
condition|)
block|{
case|case
name|EF_HIGHEST_LEVEL
case|:
comment|/* 	 * During an execve(), the kernel's original execve() creates a 	 * new vmspace and puts it into use before it has been initialized 	 * by us to contain a subject level.  Since this is the only case 	 * when a subject may have a level not set, pretend that it 	 * is just a high-level file, and allow the lomacfs_open() to then 	 * succeed. 	 */
case|case
literal|0
case|:
return|return
operator|(
name|LOMAC_HIGHEST_LEVEL
operator|)
return|;
case|case
name|EF_LOWEST_LEVEL
case|:
return|return
operator|(
name|LOMAC_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"subjectbits2level: invalid flags %#x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|attr2subjectbits
parameter_list|(
name|u_int
name|attr
parameter_list|)
block|{
name|u_int
name|bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NONETDEMOTE
condition|)
name|bits
operator||=
name|EF_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NODEMOTE
condition|)
name|bits
operator||=
name|EF_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|subjectbits2attr
parameter_list|(
name|u_int
name|bits
parameter_list|)
block|{
name|u_int
name|attr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bits
operator|&
name|EF_ATTR_NONETDEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|EF_ATTR_NODEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|attr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|subject_lock
parameter_list|(
name|lomac_subject_t
modifier|*
name|p
parameter_list|,
name|int
name|read
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USES_LOCKMGR
name|int
name|hadlock
decl_stmt|;
name|hadlock
operator|=
name|PROC_LOCKED
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hadlock
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read
condition|)
name|vm_map_lock_read
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
else|else
name|vm_map_lock
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USES_LOCKMGR
return|return
operator|(
name|hadlock
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|subject_unlock
parameter_list|(
name|lomac_subject_t
modifier|*
name|p
parameter_list|,
name|int
name|read
parameter_list|,
name|int
name|hadlock
parameter_list|)
block|{
if|if
condition|(
name|read
condition|)
name|vm_map_unlock_read
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
else|else
name|vm_map_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USES_LOCKMGR
if|if
condition|(
name|hadlock
condition|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_subject_lattr
parameter_list|(
name|lomac_subject_t
modifier|*
name|p
parameter_list|,
name|lattr_t
modifier|*
name|lattr
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|subject_lock
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_eflags
operator|=
name|level2subjectbits
argument_list|(
name|lattr
operator|->
name|level
argument_list|)
operator||
name|attr2subjectbits
argument_list|(
name|lattr
operator|->
name|flags
argument_list|)
expr_stmt|;
name|subject_unlock
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/get the subject level on a process.  The process must not be able  * to change, so either the process must be locked on entry or it must  * be held in exclusivity otherwise (executing on behalf of via a syscall,  * including as EITHER child or parent in a fork).  */
end_comment

begin_function
name|void
name|set_subject_lattr
parameter_list|(
name|lomac_subject_t
modifier|*
name|p
parameter_list|,
name|lattr_t
name|lattr
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
do|do
block|{
name|lattr_t
name|oslattr
decl_stmt|;
name|get_subject_lattr
argument_list|(
name|p
argument_list|,
operator|&
name|oslattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lomac_must_demote
argument_list|(
operator|&
name|lattr
argument_list|,
operator|&
name|oslattr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"raising subject level"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* !INVARIANTS */
name|s
operator|=
name|subject_lock
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_eflags
operator|=
operator|(
name|p
operator|->
name|p_eflags
operator|&
operator|~
operator|(
name|EF_LEVEL_MASK
operator||
name|EF_ATTR_MASK
operator|)
operator|)
operator||
name|level2subjectbits
argument_list|(
name|lattr
operator|.
name|level
argument_list|)
operator||
name|attr2subjectbits
argument_list|(
name|lattr
operator|.
name|flags
argument_list|)
expr_stmt|;
name|subject_unlock
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|kernel_vm_drop_perms
argument_list|(
name|curthread
argument_list|,
operator|&
name|lattr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_subject_lattr
parameter_list|(
name|lomac_subject_t
modifier|*
name|p
parameter_list|,
name|lattr_t
modifier|*
name|lattr
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|subject_lock
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
name|subjectbits2level
argument_list|(
name|p
operator|->
name|p_eflags
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
name|subjectbits2attr
argument_list|(
name|p
operator|->
name|p_eflags
argument_list|)
expr_stmt|;
name|subject_unlock
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|level2lvnodebits
parameter_list|(
name|level_t
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|LOMAC_HIGHEST_LEVEL
case|:
return|return
operator|(
name|LN_HIGHEST_LEVEL
operator|)
return|;
case|case
name|LOMAC_LOWEST_LEVEL
case|:
return|return
operator|(
name|LN_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"level2lvnodebits: invalid level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|level_t
name|lvnodebits2level
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|LN_LEVEL_MASK
condition|)
block|{
case|case
name|LN_HIGHEST_LEVEL
case|:
return|return
operator|(
name|LOMAC_HIGHEST_LEVEL
operator|)
return|;
case|case
name|LN_LOWEST_LEVEL
case|:
return|return
operator|(
name|LOMAC_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"lvnodebits2level: invalid flags %#x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|attr2lvnodebits
parameter_list|(
name|unsigned
name|int
name|attr
parameter_list|)
block|{
name|unsigned
name|int
name|bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_LOWWRITE
condition|)
name|bits
operator||=
name|LN_ATTR_LOWWRITE
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_LOWNOOPEN
condition|)
name|bits
operator||=
name|LN_ATTR_LOWNOOPEN
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NONETDEMOTE
condition|)
name|bits
operator||=
name|LN_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NODEMOTE
condition|)
name|bits
operator||=
name|LN_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|lvnodebits2attr
parameter_list|(
name|unsigned
name|int
name|bits
parameter_list|)
block|{
name|unsigned
name|int
name|attr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bits
operator|&
name|LN_ATTR_LOWWRITE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_LOWWRITE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|LN_ATTR_LOWNOOPEN
condition|)
name|attr
operator||=
name|LOMAC_ATTR_LOWNOOPEN
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|LN_ATTR_NONETDEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|LN_ATTR_NODEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|attr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These flags correspond to the same ones set in lomac_node{}s.  */
end_comment

begin_define
define|#
directive|define
name|UV_LEVEL_MASK
value|0x08000000
end_define

begin_define
define|#
directive|define
name|UV_LOWEST_LEVEL
value|0x00000000
end_define

begin_define
define|#
directive|define
name|UV_HIGHEST_LEVEL
value|0x08000000
end_define

begin_define
define|#
directive|define
name|UV_ATTR_LOWWRITE
value|0x10000000
end_define

begin_define
define|#
directive|define
name|UV_ATTR_LOWNOOPEN
value|0x20000000
end_define

begin_define
define|#
directive|define
name|UV_ATTR_NONETDEMOTE
value|0x40000000
end_define

begin_define
define|#
directive|define
name|UV_ATTR_NODEMOTE
value|0x80000000
end_define

begin_define
define|#
directive|define
name|UV_ATTR_MASK
value|0xf0000000
end_define

begin_function
specifier|static
name|__inline
name|u_int
name|level2uvnodebits
parameter_list|(
name|level_t
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|LOMAC_HIGHEST_LEVEL
case|:
return|return
operator|(
name|UV_HIGHEST_LEVEL
operator|)
return|;
case|case
name|LOMAC_LOWEST_LEVEL
case|:
return|return
operator|(
name|UV_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"level2uvnodebits: invalid level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|level_t
name|uvnodebits2level
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|UV_LEVEL_MASK
condition|)
block|{
case|case
name|UV_HIGHEST_LEVEL
case|:
return|return
operator|(
name|LOMAC_HIGHEST_LEVEL
operator|)
return|;
case|case
name|UV_LOWEST_LEVEL
case|:
return|return
operator|(
name|LOMAC_LOWEST_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"uvnodebits2level: invalid flags %#x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|attr2uvnodebits
parameter_list|(
name|u_int
name|attr
parameter_list|)
block|{
name|unsigned
name|int
name|bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_LOWWRITE
condition|)
name|bits
operator||=
name|UV_ATTR_LOWWRITE
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_LOWNOOPEN
condition|)
name|bits
operator||=
name|UV_ATTR_LOWNOOPEN
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NONETDEMOTE
condition|)
name|bits
operator||=
name|UV_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|LOMAC_ATTR_NODEMOTE
condition|)
name|bits
operator||=
name|UV_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|uvnodebits2attr
parameter_list|(
name|u_int
name|bits
parameter_list|)
block|{
name|unsigned
name|int
name|attr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bits
operator|&
name|UV_ATTR_LOWWRITE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_LOWWRITE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|UV_ATTR_LOWNOOPEN
condition|)
name|attr
operator||=
name|LOMAC_ATTR_LOWNOOPEN
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|UV_ATTR_NONETDEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NONETDEMOTE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|UV_ATTR_NODEMOTE
condition|)
name|attr
operator||=
name|LOMAC_ATTR_NODEMOTE
expr_stmt|;
return|return
operator|(
name|attr
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OBJ_LOWEST_LEVEL
value|0x8000
end_define

begin_comment
comment|/* the highest level is implicit */
end_comment

begin_comment
comment|/*  * This code marks pipes with levels.  We use a previously unnused bit  * in the pipe_state field of struct pipe to store the level  * information.  Bit clear means LOMAC_HIGHEST_LEVEL, bit set means  * LOMAC_LOWEST_LEVEL.  Since new pipes have clear bits by default,  * using clear bit as highest causes new pipes to start at the highest  * level automatically.  */
end_comment

begin_define
define|#
directive|define
name|PIPE_LEVEL_LOWEST
value|0x10000000
end_define

begin_comment
comment|/* This code marks sockets created by socketpair() with levels.  It  * uses a previouslt unused bit in the so_state field of struct socket  * to store the level information.  Bit clear means  * LOMAC_HIGHEST_LEVEL, bit set means LOMAC_LOWEST_LEVEL.  Since new  * sockets have clear bits by default, using clear bit as highest  * causes new sockets to start at the highest level automatically.  */
end_comment

begin_define
define|#
directive|define
name|SOCKET_LEVEL_LOWEST
value|0x4000
end_define

begin_function
name|void
name|set_object_lattr
parameter_list|(
name|lomac_object_t
modifier|*
name|obj
parameter_list|,
name|lattr_t
name|lattr
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|lomac_node
modifier|*
name|ln
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|struct
name|pipe
modifier|*
name|pipe
decl_stmt|;
name|struct
name|socket
modifier|*
name|socket
decl_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|lo_type
condition|)
block|{
case|case
name|LO_TYPE_LVNODE
case|:
name|KASSERT
argument_list|(
name|VISLOMAC
argument_list|(
name|obj
operator|->
name|lo_object
operator|.
name|vnode
argument_list|)
argument_list|,
operator|(
literal|"not a LOMACFS vnode"
operator|)
argument_list|)
expr_stmt|;
name|ln
operator|=
name|VTOLOMAC
argument_list|(
name|obj
operator|->
name|lo_object
operator|.
name|vnode
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_flags
operator|=
operator|(
name|ln
operator|->
name|ln_flags
operator|&
operator|~
operator|(
name|LN_LEVEL_MASK
operator||
name|LN_ATTR_MASK
operator|)
operator|)
operator||
name|level2lvnodebits
argument_list|(
name|lattr
operator|.
name|level
argument_list|)
operator||
name|attr2lvnodebits
argument_list|(
name|lattr
operator|.
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_UVNODE
case|:
name|vp
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|vnode
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|VISLOMAC
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
literal|"is a LOMACFS vnode"
operator|)
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_iflag
operator|=
operator|(
name|vp
operator|->
name|v_iflag
operator|&
operator|~
operator|(
name|UV_LEVEL_MASK
operator||
name|UV_ATTR_MASK
operator|)
operator|)
operator||
name|level2uvnodebits
argument_list|(
name|lattr
operator|.
name|level
argument_list|)
operator||
name|attr2uvnodebits
argument_list|(
name|lattr
operator|.
name|flags
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_VM_OBJECT
case|:
name|object
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|vm_object
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
argument_list|,
operator|(
literal|"object has a vnode"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|backing_object
operator|==
name|NULL
argument_list|,
operator|(
literal|"is a backing object"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lattr
operator|.
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|vm_object_clear_flag
argument_list|(
name|object
argument_list|,
name|OBJ_LOWEST_LEVEL
argument_list|)
expr_stmt|;
else|else
name|vm_object_set_flag
argument_list|(
name|object
argument_list|,
name|OBJ_LOWEST_LEVEL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lattr
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"cannot set attr on a vm_object"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_PIPE
case|:
name|pipe
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|pipe
expr_stmt|;
name|KASSERT
argument_list|(
name|pipe
operator|->
name|pipe_peer
operator|==
name|NULL
operator|||
operator|(
name|pipe
operator|->
name|pipe_state
operator|&
name|PIPE_LEVEL_LOWEST
operator|)
operator|==
operator|(
name|pipe
operator|->
name|pipe_peer
operator|->
name|pipe_state
operator|&
name|PIPE_LEVEL_LOWEST
operator|)
argument_list|,
operator|(
literal|"pipe attrs unsynchronized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lattr
operator|.
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|pipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LEVEL_LOWEST
expr_stmt|;
else|else
name|pipe
operator|->
name|pipe_state
operator||=
name|PIPE_LEVEL_LOWEST
expr_stmt|;
name|pipe
operator|=
name|pipe
operator|->
name|pipe_peer
expr_stmt|;
if|if
condition|(
name|pipe
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lattr
operator|.
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|pipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LEVEL_LOWEST
expr_stmt|;
else|else
name|pipe
operator|->
name|pipe_state
operator||=
name|PIPE_LEVEL_LOWEST
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|lattr
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"cannot set attr on a pipe"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_SOCKETPAIR
case|:
name|socket
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|socket
expr_stmt|;
comment|/* KASSERT that socket peer levels are synchronized */
if|if
condition|(
name|lattr
operator|.
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|socket
operator|->
name|so_state
operator|&=
operator|~
name|SOCKET_LEVEL_LOWEST
expr_stmt|;
else|else
name|socket
operator|->
name|so_state
operator||=
name|SOCKET_LEVEL_LOWEST
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_YET
name|pipe
operator|=
name|pipe
operator|->
name|pipe_peer
expr_stmt|;
if|if
condition|(
name|pipe
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lattr
operator|.
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|pipe
operator|->
name|pipe_state
operator|&=
operator|~
name|PIPE_LEVEL_LOWEST
expr_stmt|;
else|else
name|pipe
operator|->
name|pipe_state
operator||=
name|PIPE_LEVEL_LOWEST
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|lattr
operator|.
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"cannot set attr on a pipe"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|panic
argument_list|(
literal|"set_object_lattr: invalid lo_type %d"
argument_list|,
name|obj
operator|->
name|lo_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_object_lattr
parameter_list|(
specifier|const
name|lomac_object_t
modifier|*
name|obj
parameter_list|,
name|lattr_t
modifier|*
name|lattr
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|lomac_node
modifier|*
name|ln
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|struct
name|pipe
modifier|*
name|pipe
decl_stmt|;
name|struct
name|socket
modifier|*
name|socket
decl_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|lo_type
condition|)
block|{
case|case
name|LO_TYPE_LVNODE
case|:
name|KASSERT
argument_list|(
name|VISLOMAC
argument_list|(
name|obj
operator|->
name|lo_object
operator|.
name|vnode
argument_list|)
argument_list|,
operator|(
literal|"not a LOMACFS vnode"
operator|)
argument_list|)
expr_stmt|;
name|ln
operator|=
name|VTOLOMAC
argument_list|(
name|obj
operator|->
name|lo_object
operator|.
name|vnode
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
name|lvnodebits2level
argument_list|(
name|ln
operator|->
name|ln_flags
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
name|lvnodebits2attr
argument_list|(
name|ln
operator|->
name|ln_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_UVNODE
case|:
name|vp
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|vnode
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|VISLOMAC
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
literal|"is a LOMACFS vnode"
operator|)
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
name|uvnodebits2level
argument_list|(
name|vp
operator|->
name|v_iflag
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
name|uvnodebits2attr
argument_list|(
name|vp
operator|->
name|v_iflag
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_TYPE_VM_OBJECT
case|:
name|object
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|vm_object
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
argument_list|,
operator|(
literal|"object has a vnode"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|backing_object
operator|==
name|NULL
argument_list|,
operator|(
literal|"is a backing object"
operator|)
argument_list|)
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_LOWEST_LEVEL
operator|)
condition|?
name|LOMAC_LOWEST_LEVEL
else|:
name|LOMAC_HIGHEST_LEVEL
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LO_TYPE_PIPE
case|:
name|pipe
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|pipe
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
operator|(
name|pipe
operator|->
name|pipe_state
operator|&
name|PIPE_LEVEL_LOWEST
operator|)
condition|?
name|LOMAC_LOWEST_LEVEL
else|:
name|LOMAC_HIGHEST_LEVEL
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LO_TYPE_SOCKETPAIR
case|:
name|socket
operator|=
name|obj
operator|->
name|lo_object
operator|.
name|socket
expr_stmt|;
name|lattr
operator|->
name|level
operator|=
operator|(
name|socket
operator|->
name|so_state
operator|&
name|SOCKET_LEVEL_LOWEST
operator|)
condition|?
name|LOMAC_LOWEST_LEVEL
else|:
name|LOMAC_HIGHEST_LEVEL
expr_stmt|;
name|lattr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"get_object_level: invalid lo_type %d"
argument_list|,
name|obj
operator|->
name|lo_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flag certain procs, like init(8) and kthreads, as "invincible".  */
end_comment

begin_function
name|int
name|subject_do_not_demote
parameter_list|(
name|lomac_subject_t
modifier|*
name|subj
parameter_list|)
block|{
name|int
name|inv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|subj
operator|->
name|p_pid
operator|==
literal|1
condition|)
block|{
name|inv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|had_lock
init|=
name|PROC_LOCKED
argument_list|(
name|subj
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|had_lock
condition|)
name|PROC_LOCK
argument_list|(
name|subj
argument_list|)
expr_stmt|;
if|if
condition|(
name|subj
operator|->
name|p_flag
operator|&
name|P_SYSTEM
condition|)
name|inv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|had_lock
condition|)
name|PROC_UNLOCK
argument_list|(
name|subj
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|inv
operator|)
return|;
block|}
end_function

end_unit

