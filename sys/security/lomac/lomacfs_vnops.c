begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by NAI Labs, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|"lomacfs.h"
end_include

begin_include
include|#
directive|include
file|"kernel_mediate.h"
end_include

begin_include
include|#
directive|include
file|"kernel_monitor.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LOOKUPSTATS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lomacfs_successful_lookups
decl_stmt|,
name|lomacfs_failed_lookups
decl_stmt|,
name|lomacfs_successful_cachedlookups
decl_stmt|,
name|lomacfs_failed_cachedlookups
decl_stmt|,
name|lomacfs_node_alloc_clashes
decl_stmt|,
name|lomacfs_node_alloc_failures
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|lomacfs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"LOMACFS filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_lomacfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"debug stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|successful_lookups
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_successful_lookups
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|failed_lookups
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_failed_lookups
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|successful_cachedlookups
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_successful_cachedlookups
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|failed_cachedlookups
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_failed_cachedlookups
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|node_alloc_clashes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_node_alloc_clashes
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_lomacfs_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|node_alloc_failures
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lomacfs_node_alloc_failures
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|lomacfs_defaultop
parameter_list|(
name|struct
name|vop_generic_args
comment|/* { 		struct vnodeop_desc *a_desc; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|printf
argument_list|(
literal|"lomacfs: %s unsupported\n"
argument_list|,
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|KASSERT
argument_list|(
name|lvp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"inactive with NULL lowervp"
operator|)
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Temporarily drop our reference to the lower vnode, while keeping 	 * it held, to possibly call VOP_INACTIVE() on the lower layer. 	 */
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_INACTIVE
argument_list|)
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_INCNAME
argument_list|)
specifier|const
name|char
modifier|*
name|name
init|=
name|VTOLOMAC
argument_list|(
name|vp
argument_list|)
operator|->
name|ln_name
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|name
init|=
literal|"[unknown]"
decl_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"lomacfs: inactive(%p \"%s\"), lvp usecount down to %u\n"
argument_list|,
name|vp
argument_list|,
name|name
argument_list|,
name|vrefcnt
argument_list|(
name|lvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* 	 * Since the lower fs may actually remove the vnode on last 	 * release, destroy ourselves mostly here if that occurs. 	 * 	 * Additionally, devices should be totally freed 	 * on last close, not lazily. 	 */
if|if
condition|(
name|vrefcnt
argument_list|(
name|lvp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|lvp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|lvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|)
condition|)
block|{
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|VTOLVP
argument_list|(
name|vp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
name|vref
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|lomac_node
modifier|*
name|ln
init|=
name|VTOLOMAC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_RECLAIM
argument_list|)
if|if
condition|(
name|lvp
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_INCNAME
argument_list|)
specifier|const
name|char
modifier|*
name|name
init|=
name|ln
operator|->
name|ln_name
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|name
init|=
literal|"[unknown]"
decl_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"lomacfs: reclaim(%p \"%s\"), lvp usecount down to %u\n"
argument_list|,
name|vp
argument_list|,
name|name
argument_list|,
name|vrefcnt
argument_list|(
name|lvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lvp
operator|!=
name|NULL
condition|)
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_rdev
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ln
argument_list|,
name|M_LOMACFS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_print
parameter_list|(
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag %s, vp=%p, lowervp=%p\n"
argument_list|,
name|vp
operator|->
name|v_tag
argument_list|,
name|vp
argument_list|,
name|VTOLVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_lock
parameter_list|(
name|struct
name|vop_lock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|int
name|lflags
init|=
name|flags
operator|&
operator|~
operator|(
name|LK_INTERLOCK
operator||
name|LK_THISLAYER
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * To prevent race conditions involving doing a lookup 	 * on "..", we have to lock the lower node, then lock our 	 * node. Most of the time it won't matter that we lock our 	 * node (as any locking would need the lower one locked 	 * first). But we can LK_DRAIN the upper lock as a step 	 * towards decomissioning it. 	 */
name|lvp
operator|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|==
name|NULL
operator|||
name|flags
operator|&
name|LK_THISLAYER
condition|)
return|return
operator|(
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|flags
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|LK_INTERLOCK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_DRAIN
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|lvp
argument_list|,
operator|(
name|lflags
operator|&
operator|~
name|LK_TYPE_MASK
operator|)
operator||
name|LK_EXCLUSIVE
operator||
name|LK_CANRECURSE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|vn_lock
argument_list|(
name|lvp
argument_list|,
name|lflags
operator||
name|LK_CANRECURSE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|flags
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to process our own vnode unlock and then clear the  * interlock flag as it applies only to our vnode, not the  * vnodes below us on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|lomacfs_unlock
parameter_list|(
name|struct
name|vop_unlock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|int
name|lflags
init|=
operator|(
name|ap
operator|->
name|a_flags
operator||
name|LK_RELEASE
operator|)
operator|&
operator|~
operator|(
name|LK_THISLAYER
operator||
name|LK_INTERLOCK
operator|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|flags
operator||
name|LK_RELEASE
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|==
name|NULL
operator|||
name|flags
operator|&
name|LK_THISLAYER
operator|||
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Hmm... in a vput(), this means we'll grab the lomacfs interlock, 	 * then the lower interlock.  I don't think this matters, though, 	 * since both won't be held at the same time. 	 */
if|if
condition|(
name|lvp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|lflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_islocked
parameter_list|(
name|struct
name|vop_islocked_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
return|return
operator|(
name|lockstatus
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_lookup
parameter_list|(
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vfs_cache_lookup
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LOOKUPSTATS
argument_list|)
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|lomacfs_successful_lookups
operator|++
expr_stmt|;
else|else
name|lomacfs_failed_lookups
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LOOKUP
argument_list|)
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|)
operator|->
name|v_mount
operator|==
name|dvp
operator|->
name|v_mount
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
operator|*
name|ap
operator|->
name|a_vpp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_INCNAME
argument_list|)
specifier|const
name|char
modifier|*
name|name
init|=
name|VTOLOMAC
argument_list|(
name|vp
argument_list|)
operator|->
name|ln_name
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|name
init|=
literal|"[unknown]"
decl_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"lomacfs: lookup(%p \"%s\"), lvp usecount up to %u\n"
argument_list|,
name|vp
argument_list|,
name|name
argument_list|,
name|vrefcnt
argument_list|(
name|VTOLVP
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_cachedlookup
parameter_list|(
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ldvp
init|=
name|VTOLVP
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|int
name|makeentry
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|&&
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|CREATE
condition|)
block|{
name|lomac_object_t
name|lobj
init|=
block|{
name|LO_TYPE_LVNODE
block|,
block|{
name|dvp
block|}
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
condition|)
name|op
operator|=
literal|"delete"
expr_stmt|;
else|else
name|op
operator|=
literal|"rename"
expr_stmt|;
if|if
condition|(
operator|!
name|mediate_subject_object
argument_list|(
name|op
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|makeentry
operator|=
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|makeentry
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ldvp
argument_list|,
operator|&
name|lvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|makeentry
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EJUSTRETURN
operator|)
operator|&&
name|cnp
operator|->
name|cn_flags
operator|!=
operator|(
name|cnp
operator|->
name|cn_flags
operator||
name|LOCKPARENT
operator||
name|ISLASTCN
operator|)
condition|)
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
name|LK_THISLAYER
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|lvp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
comment|/* 		 * Check to see if the vnode has been mounted on; 		 * if so find the root of the mounted filesystem. 		 */
if|if
condition|(
name|lvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|mp
operator|=
name|lvp
operator|->
name|v_mountedhere
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|NOCROSSMOUNT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|vnode
modifier|*
name|tdp
decl_stmt|;
if|if
condition|(
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
condition|)
goto|goto
name|forget_it
goto|;
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_ROOT
argument_list|(
name|mp
argument_list|,
operator|&
name|tdp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|tdp
expr_stmt|;
block|}
name|forget_it
label|:
comment|/* 		 * For a create or for devices (dynamic things, aren't they), 		 * don't enter the vnode into the cache. 		 */
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|lvp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|makeentry
expr_stmt|;
comment|/* 		 * The top half of dvp is locked, but ldvp is unlocked. 		 * Additionally, lvp is locked already, and 		 * lomacfs_node_alloc() always returns it locked. 		 */
name|error
operator|=
name|lomacfs_node_alloc
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|cnp
argument_list|,
name|dvp
argument_list|,
name|lvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|makeentry
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LOOKUPSTATS
argument_list|)
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
block|{
name|lomacfs_node_alloc_failures
operator|++
expr_stmt|;
block|}
else|else
block|{
name|lomacfs_node_alloc_clashes
operator|++
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * For sockets, just return the "real" thing 		 * after entering it into the cache. 		 */
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|lvp
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|CREATE
operator|&&
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|lvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LOOKUPSTATS
argument_list|)
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|lomacfs_successful_cachedlookups
operator|++
expr_stmt|;
else|else
name|lomacfs_failed_cachedlookups
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	*/
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|VTOLVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vap
operator|->
name|va_fsid
operator|==
name|VNOVAL
condition|)
name|vap
operator|->
name|va_fsid
operator|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_setattr
parameter_list|(
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	*/
modifier|*
name|ap
parameter_list|)
block|{
name|lomac_object_t
name|lobj
init|=
block|{
name|LO_TYPE_LVNODE
block|,
block|{
name|ap
operator|->
name|a_vp
block|}
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mediate_subject_object
argument_list|(
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_name
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_READDIR
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_open
parameter_list|(
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|lomac_object_t
name|lobj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_LVNODE
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
operator|!
name|mediate_subject_object_open
argument_list|(
name|ap
operator|->
name|a_td
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_close
parameter_list|(
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX 	 * Try to cope with the horrible semantics introduced here... 	 */
name|vref
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CLOSE
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_access
parameter_list|(
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_ACCESS
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|lvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|VOP_READLINK
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_lease
parameter_list|(
name|struct
name|vop_lease_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 		struct ucred *a_cred; 		int a_flag; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
return|return
operator|(
name|VOP_LEASE
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_read
parameter_list|(
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|lomac_object_t
name|lobj
init|=
block|{
name|LO_TYPE_LVNODE
block|,
block|{
name|ap
operator|->
name|a_vp
block|}
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|monitor_read_object
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_READ
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_write
parameter_list|(
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|lomac_object_t
name|lobj
init|=
block|{
name|LO_TYPE_LVNODE
block|,
block|{
name|ap
operator|->
name|a_vp
block|}
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mediate_subject_object
argument_list|(
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_name
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
return|return
operator|(
name|VOP_IOCTL
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_muxcreate
parameter_list|(
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ldvp
init|=
name|VTOLVP
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|makeentry
init|=
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
decl_stmt|;
name|lomac_object_t
name|lobj
init|=
block|{
name|LO_TYPE_LVNODE
block|,
block|{
name|dvp
block|}
block|}
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|mediate_subject_object
argument_list|(
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_name
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
operator|||
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VCHR
operator|&&
operator|!
name|mediate_subject_at_level
argument_list|(
literal|"mknod"
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
name|LOMAC_HIGHEST_LEVEL
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|ap
operator|->
name|a_dvp
operator|=
name|ldvp
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|makeentry
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|ldvp
argument_list|,
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|issock
decl_stmt|;
name|issock
operator|=
name|vap
operator|->
name|va_type
operator|==
name|VSOCK
expr_stmt|;
name|vp
operator|=
operator|*
name|ap
operator|->
name|a_vpp
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|issock
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|makeentry
expr_stmt|;
name|error
operator|=
name|lomacfs_node_alloc
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|cnp
argument_list|,
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|issock
condition|)
block|{
comment|/* 			 * I should really find a nicer way to do this. 			 */
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|vp
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_LOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_muxremove
parameter_list|(
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ap
operator|->
name|a_dvp
operator|=
name|VTOLVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VISLOMAC
argument_list|(
name|vp
argument_list|)
condition|)
name|ap
operator|->
name|a_vp
operator|=
name|VTOLVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_desc
operator|->
name|vdesc_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int a_waitfor; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_FSYNC
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t a_id; 		int a_op; 		struct flock *a_fl; 		int a_flags; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_ADVLOCK
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_whiteout
parameter_list|(
name|struct
name|vop_whiteout_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 		int a_flags; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_WHITEOUT
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_poll
parameter_list|(
name|struct
name|vop_poll_args
comment|/* { 		struct vnode *a_vp; 		int a_events; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_POLL
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_events
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_revoke
parameter_list|(
name|struct
name|vop_revoke_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_REVOKE
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_link
parameter_list|(
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VISLOMAC
argument_list|(
name|vp
argument_list|)
condition|?
name|VTOLVP
argument_list|(
name|vp
argument_list|)
else|:
name|vp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_LINK
argument_list|(
name|VTOLVP
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|lvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
block|{
name|cache_enter
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOMAC_DEBUG_LINK
argument_list|)
do|do
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|int
name|nerror
decl_stmt|;
name|nerror
operator|=
name|cache_lookup
argument_list|(
name|tdvp
argument_list|,
operator|&
name|nvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lomacfs: link(%p), cache_lookup() = %d (%p)\n"
argument_list|,
name|vp
argument_list|,
name|nerror
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_rename
parameter_list|(
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|int
name|fvp_is_lomac
init|=
name|VISLOMAC
argument_list|(
name|fvp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vref
argument_list|(
name|VTOLVP
argument_list|(
name|fdvp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Handle the case when LOMAC returns a real vnode for 	 * VSOCK, rather than the LOMAC covering vnode. 	 */
if|if
condition|(
name|fvp_is_lomac
condition|)
name|vref
argument_list|(
name|VTOLVP
argument_list|(
name|fvp
argument_list|)
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|VTOLVP
argument_list|(
name|tdvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|vref
argument_list|(
name|VTOLVP
argument_list|(
name|tvp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|VTOLVP
argument_list|(
name|fdvp
argument_list|)
argument_list|,
name|fvp_is_lomac
condition|?
name|VTOLVP
argument_list|(
name|fvp
argument_list|)
else|:
name|fvp
argument_list|,
name|fcnp
argument_list|,
name|VTOLVP
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|tvp
operator|!=
name|NULL
condition|?
name|VTOLVP
argument_list|(
name|tvp
argument_list|)
else|:
name|NULL
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|cache_purge
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|cache_purge
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
name|LK_THISLAYER
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp_is_lomac
condition|)
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|,
name|LK_THISLAYER
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
comment|/* NOCACHE unsets MAKEENTRY */
operator|&&
name|fvp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
name|cache_enter
argument_list|(
name|tdvp
argument_list|,
name|fvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_STRATEGY
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Let an underlying filesystem do the work of creating the "actual"  * vm_object_t, and we will reference it.  */
end_comment

begin_function
specifier|static
name|int
name|lomacfs_createvobject
parameter_list|(
name|struct
name|vop_createvobject_args
comment|/* { 		struct vnode *vp; 		struct ucred *cred; 		struct proc *p; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
init|=
name|VTOLOMAC
argument_list|(
name|vp
argument_list|)
operator|!=
name|NULL
condition|?
name|VTOLVP
argument_list|(
name|vp
argument_list|)
else|:
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VNON
operator|||
name|lowervp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|VOP_CREATEVOBJECT
argument_list|(
name|lowervp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|->
name|v_vflag
operator||=
name|VV_OBJBUF
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to destroy the lower vnode object only if we created it.  * XXX - I am very unsure about all of this.  */
end_comment

begin_function
specifier|static
name|int
name|lomacfs_destroyvobject
parameter_list|(
name|struct
name|vop_destroyvobject_args
comment|/* { 		struct vnode *vp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|vp
operator|->
name|v_vflag
operator|&=
operator|~
name|VV_OBJBUF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_bmap
parameter_list|(
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_BMAP
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|,
name|ap
operator|->
name|a_runb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_getpages
parameter_list|(
name|struct
name|vop_getpages_args
comment|/* { 		struct vnode *a_vp; 		vm_page_t *a_m; 		int a_count; 		int a_reqpage; 		vm_ooffset_t a_offset; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_GETPAGES
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_reqpage
argument_list|,
name|ap
operator|->
name|a_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_putpages
parameter_list|(
name|struct
name|vop_putpages_args
comment|/* { 		struct vnode *a_vp; 		vm_page_t *a_m; 		int a_count; 		int a_sync; 		int *a_rtvals; 		vm_ooffset_t a_offset; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_PUTPAGES
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_sync
argument_list|,
name|ap
operator|->
name|a_rtvals
argument_list|,
name|ap
operator|->
name|a_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_getvobject
parameter_list|(
name|struct
name|vop_getvobject_args
comment|/* { 		struct vnode *a_vp; 		struct vm_object **a_objpp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
init|=
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|lvp
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
return|return
operator|(
name|VOP_GETVOBJECT
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_objpp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_kqfilter
parameter_list|(
name|struct
name|vop_kqfilter_args
comment|/* { 		struct vnode *a_vp; 		struct knote *a_kn; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_KQFILTER
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_kn
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_PATHCONF
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_reallocblks
parameter_list|(
name|struct
name|vop_reallocblks_args
comment|/* { 		struct vnode *a_vp; 		struct cluster_save *a_buflist; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_REALLOCBLKS
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_buflist
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_freeblks
parameter_list|(
name|struct
name|vop_freeblks_args
comment|/* { 		struct vnode *a_vp; 		daddr_t a_addr; 		daddr_t a_length; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_FREEBLKS
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_addr
argument_list|,
name|ap
operator|->
name|a_length
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_getacl
parameter_list|(
name|struct
name|vop_getacl_args
comment|/* { 		struct vnode *a_vp; 		acl_type_t a_type; 		struct acl *a_aclp; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_GETACL
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_setacl
parameter_list|(
name|struct
name|vop_setacl_args
comment|/* { 		struct vnode *a_vp; 		acl_type_t a_type; 		struct acl *a_aclp; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|lomac_object_t
name|lobj
decl_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_LVNODE
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
operator|!
name|mediate_subject_object
argument_list|(
literal|"setacl"
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
else|else
return|return
operator|(
name|VOP_SETACL
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_aclcheck
parameter_list|(
name|struct
name|vop_aclcheck_args
comment|/* { 		struct vnode *a_vp; 		acl_type_t a_type; 		struct acl *a_aclp; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|VOP_ACLCHECK
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
comment|/* { 		struct vnode *a_vp; 		int a_attrnamespace; 		const char *a_name; 		struct uio *a_uio; 		size_t *a_size; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|lomac_object_t
name|lobj
decl_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_LVNODE
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
name|monitor_read_object
argument_list|(
name|ap
operator|->
name|a_td
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
else|else
return|return
operator|(
name|VOP_GETEXTATTR
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_size
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lomacfs_setextattr
parameter_list|(
name|struct
name|vop_setextattr_args
comment|/* { 		struct vnode *a_vp; 		int a_attrnamespace; 		const char *a_name; 		struct uio *a_uio; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|lomac_object_t
name|lobj
decl_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_LVNODE
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
operator|!
name|mediate_subject_object
argument_list|(
literal|"setextattr"
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_proc
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
else|else
return|return
operator|(
name|VOP_SETEXTATTR
argument_list|(
name|VTOLVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|lomacfs_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|lomacfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_defaultop
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_inactive
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_print
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_lock
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_unlock
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_islocked
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_lookup
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_setattr
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_getattr
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_readdir
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_open
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_close
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_access
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_readlink
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_lease
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_read
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_write
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_ioctl
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxcreate
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxcreate
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxcreate
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxcreate
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxremove
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_muxremove
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_fsync
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_advlock
block|}
block|,
block|{
operator|&
name|vop_whiteout_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_whiteout
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_poll
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_link
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_revoke
block|}
block|,
block|{
operator|&
name|vop_cachedlookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_cachedlookup
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_lookup
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_bmap
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_getpages
block|}
block|,
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_putpages
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_strategy
block|}
block|,
block|{
operator|&
name|vop_createvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_createvobject
block|}
block|,
block|{
operator|&
name|vop_destroyvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_destroyvobject
block|}
block|,
block|{
operator|&
name|vop_getvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_getvobject
block|}
block|,
block|{
operator|&
name|vop_getwritemount_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdgetwritemount
block|}
block|,
block|{
operator|&
name|vop_kqfilter_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_kqfilter
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_pathconf
block|}
block|,
block|{
operator|&
name|vop_reallocblks_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_reallocblks
block|}
block|,
block|{
operator|&
name|vop_freeblks_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_freeblks
block|}
block|,
block|{
operator|&
name|vop_getacl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_getacl
block|}
block|,
block|{
operator|&
name|vop_setacl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_setacl
block|}
block|,
block|{
operator|&
name|vop_aclcheck_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_aclcheck
block|}
block|,
block|{
operator|&
name|vop_getextattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_getextattr
block|}
block|,
block|{
operator|&
name|vop_setextattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|lomacfs_setextattr
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|lomacfs_vnodeopv_opv_desc
init|=
block|{
operator|&
name|lomacfs_vnodeop_p
block|,
name|lomacfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|lomacfs_vnodeopv_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

