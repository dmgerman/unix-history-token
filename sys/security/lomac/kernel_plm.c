begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by NAI Labs, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|"kernel_interface.h"
end_include

begin_include
include|#
directive|include
file|"kernel_plm.h"
end_include

begin_include
include|#
directive|include
file|"lomacfs.h"
end_include

begin_include
include|#
directive|include
file|"policy_plm.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_LOMACPLM
argument_list|,
literal|"LOMAC_PLM"
argument_list|,
literal|"LOMAC PLM nodes and strings"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|char
modifier|*
name|strsep
parameter_list|(
specifier|register
name|char
modifier|*
modifier|*
name|stringp
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|delim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get next token from string *stringp, where tokens are possibly-empty  * strings separated by characters from delim.  *  * Writes NULs into the string at *stringp to end tokens.  * delim need not remain constant from call to call.  * On return, *stringp points past the last NUL written (if there might  * be further tokens), or is NULL (if there are definitely no more tokens).  *  * If *stringp is NULL, strsep returns NULL.  */
end_comment

begin_function
name|char
modifier|*
name|strsep
parameter_list|(
name|stringp
parameter_list|,
name|delim
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|stringp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|spanp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|sc
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|*
name|stringp
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|tok
operator|=
name|s
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|spanp
operator|=
name|delim
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|sc
operator|=
operator|*
name|spanp
operator|++
operator|)
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|s
operator|=
name|NULL
expr_stmt|;
else|else
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|stringp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|tok
operator|)
return|;
block|}
block|}
do|while
condition|(
name|sc
operator|!=
literal|0
condition|)
do|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_decl_stmt
name|struct
name|lomac_node_entry
name|lomac_node_entry_root
init|=
block|{
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|lomac_node_entry
argument_list|)
block|,
block|{
name|NULL
block|}
block|,
name|LN_HIGHEST_LEVEL
operator||
name|LN_INHERIT_HIGH
block|,
literal|"/"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|lomac_node_entry
modifier|*
name|lomac_plm_subtree_find_cnp
parameter_list|(
name|struct
name|lomac_node_entry
modifier|*
name|root
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|)
block|{
name|char
modifier|*
name|nameptr
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|struct
name|lomac_node_entry
modifier|*
name|lne
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lne
argument_list|,
argument|&root->ln_children
argument_list|,
argument|ln_chain
argument_list|)
if|if
condition|(
name|strlen
argument_list|(
name|lne
operator|->
name|ln_name
argument_list|)
operator|==
name|len
operator|&&
name|bcmp
argument_list|(
name|lne
operator|->
name|ln_name
argument_list|,
name|nameptr
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|lne
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|lomac_node_entry
modifier|*
name|lomac_plm_subtree_find
parameter_list|(
name|struct
name|lomac_node_entry
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|lomac_node_entry
modifier|*
name|lne
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lne
argument_list|,
argument|&root->ln_children
argument_list|,
argument|ln_chain
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|lne
operator|->
name|ln_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|lne
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called from inside getnewvnode() before the vnode is in use.  */
end_comment

begin_function
name|void
name|lomac_plm_init_lomacfs_vnode
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|lattr_t
modifier|*
name|subjlattr
parameter_list|)
block|{
name|struct
name|lomac_node
modifier|*
name|ln
init|=
name|VTOLOMAC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|lomac_node_entry
modifier|*
name|mlne
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Only "/" has no parent, so inherit directly from our PLM root. 	 */
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
block|{
name|ln
operator|->
name|ln_flags
operator|=
name|lomac_node_entry_root
operator|.
name|ln_flags
expr_stmt|;
name|ln
operator|->
name|ln_entry
operator|=
name|ln
operator|->
name|ln_underpolicy
operator|=
operator|&
name|lomac_node_entry_root
expr_stmt|;
block|}
else|else
block|{
name|struct
name|lomac_node
modifier|*
name|dln
init|=
name|VTOLOMAC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|lomac_node_entry
modifier|*
name|dlne
init|=
name|dln
operator|->
name|ln_entry
decl_stmt|;
name|int
name|fixup_inherit
init|=
literal|0
decl_stmt|;
comment|/* 		 * If we have no directory-specific entry, we inherit 		 * directly from the lomac_node's previously-inherited 		 * flags implicitly, otherwise we inherit explicitly 		 * from the corresponding lomac_node_entry. 		 */
if|if
condition|(
name|dlne
operator|==
name|NULL
condition|)
block|{
name|ln
operator|->
name|ln_flags
operator|=
name|dln
operator|->
name|ln_flags
operator|&
name|LN_INHERIT_MASK
expr_stmt|;
name|fixup_inherit
operator|=
literal|1
expr_stmt|;
name|ln
operator|->
name|ln_underpolicy
operator|=
name|dln
operator|->
name|ln_underpolicy
expr_stmt|;
name|ln
operator|->
name|ln_entry
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mlne
operator|=
name|lomac_plm_subtree_find_cnp
argument_list|(
name|dlne
argument_list|,
name|cnp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ln
operator|->
name|ln_flags
operator|=
name|dlne
operator|->
name|ln_flags
operator|&
name|LN_INHERIT_MASK
expr_stmt|;
name|fixup_inherit
operator|=
literal|2
expr_stmt|;
name|ln
operator|->
name|ln_underpolicy
operator|=
name|dlne
expr_stmt|;
name|ln
operator|->
name|ln_entry
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|->
name|ln_entry
operator|=
name|ln
operator|->
name|ln_underpolicy
operator|=
name|mlne
expr_stmt|;
block|}
if|if
condition|(
name|fixup_inherit
condition|)
block|{
switch|switch
condition|(
name|ln
operator|->
name|ln_flags
condition|)
block|{
case|case
name|LN_INHERIT_LOW
case|:
name|ln
operator|->
name|ln_flags
operator||=
name|LN_LOWEST_LEVEL
expr_stmt|;
break|break;
case|case
name|LN_INHERIT_SUBJ
case|:
if|if
condition|(
name|subjlattr
operator|->
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|ln
operator|->
name|ln_flags
operator||=
name|LN_HIGHEST_LEVEL
expr_stmt|;
else|else
block|{
name|ln
operator|->
name|ln_flags
operator|&=
operator|~
name|LN_INHERIT_MASK
expr_stmt|;
name|ln
operator|->
name|ln_flags
operator||=
name|LN_INHERIT_LOW
operator||
name|LN_LOWEST_LEVEL
expr_stmt|;
block|}
break|break;
case|case
name|LN_INHERIT_HIGH
case|:
name|ln
operator|->
name|ln_flags
operator||=
name|LN_HIGHEST_LEVEL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixup_inherit
operator|==
literal|2
condition|)
name|ln
operator|->
name|ln_flags
operator||=
operator|(
name|dlne
operator|->
name|ln_flags
operator|&
name|LN_CHILD_ATTR_MASK
operator|)
operator|>>
name|LN_CHILD_ATTR_SHIFT
expr_stmt|;
block|}
else|else
block|{
comment|/* this is the only case where mlne != NULL */
name|ln
operator|->
name|ln_flags
operator|&=
operator|~
operator|(
name|LN_INHERIT_MASK
operator||
name|LN_ATTR_MASK
operator|)
expr_stmt|;
name|ln
operator|->
name|ln_flags
operator||=
name|mlne
operator|->
name|ln_flags
operator|&
operator|(
name|LN_INHERIT_MASK
operator||
name|LN_ATTR_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mlne
operator|->
name|ln_flags
operator|&
name|LN_LEVEL_MASK
operator|)
operator|==
name|LN_SUBJ_LEVEL
condition|)
block|{
if|if
condition|(
name|subjlattr
operator|->
name|level
operator|==
name|LOMAC_HIGHEST_LEVEL
condition|)
name|ln
operator|->
name|ln_flags
operator||=
name|LN_HIGHEST_LEVEL
expr_stmt|;
else|else
name|ln
operator|->
name|ln_flags
operator||=
name|LN_LOWEST_LEVEL
expr_stmt|;
block|}
else|else
name|ln
operator|->
name|ln_flags
operator||=
name|mlne
operator|->
name|ln_flags
operator|&
name|LN_LEVEL_MASK
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|ln
operator|->
name|ln_flags
operator|&
name|LN_LEVEL_MASK
argument_list|,
operator|(
literal|"lomac_node has no level"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ln
operator|->
name|ln_flags
operator|&
name|LN_INHERIT_MASK
argument_list|,
operator|(
literal|"lomac_node has no inherit"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|mlne
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|mlne
operator|->
name|ln_flags
operator|&
name|LN_LEVEL_MASK
argument_list|,
operator|(
literal|"lomac_node_entry has no level"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mlne
operator|->
name|ln_flags
operator|&
name|LN_INHERIT_MASK
argument_list|,
operator|(
literal|"lomac_node_entry has no inherit"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INVARIANTS */
block|}
end_function

begin_function
specifier|static
name|struct
name|lomac_node_entry
modifier|*
name|lomac_plm_subtree_new
parameter_list|(
name|struct
name|lomac_node_entry
modifier|*
name|plne
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|lomac_node_entry
modifier|*
name|lne
decl_stmt|;
specifier|static
name|struct
name|lomac_node_entry_head
name|head_init
init|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|lomac_node_entry
argument_list|)
decl_stmt|;
name|lne
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lne
argument_list|)
argument_list|,
name|M_LOMACPLM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|head_init
argument_list|,
operator|&
name|lne
operator|->
name|ln_children
argument_list|,
sizeof|sizeof
argument_list|(
name|head_init
argument_list|)
argument_list|)
expr_stmt|;
name|lne
operator|->
name|ln_name
operator|=
name|name
expr_stmt|;
name|lne
operator|->
name|ln_flags
operator|=
name|plne
operator|->
name|ln_flags
operator|&
name|LN_INHERIT_MASK
expr_stmt|;
switch|switch
condition|(
name|lne
operator|->
name|ln_flags
condition|)
block|{
case|case
name|LN_INHERIT_LOW
case|:
name|lne
operator|->
name|ln_flags
operator||=
name|LN_LOWEST_LEVEL
expr_stmt|;
break|break;
case|case
name|LN_INHERIT_HIGH
case|:
name|lne
operator|->
name|ln_flags
operator||=
name|LN_HIGHEST_LEVEL
expr_stmt|;
break|break;
case|case
name|LN_INHERIT_SUBJ
case|:
name|lne
operator|->
name|ln_flags
operator||=
name|LN_SUBJ_LEVEL
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|plne
operator|->
name|ln_children
argument_list|,
name|lne
argument_list|,
name|ln_chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|lne
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lomac_plm_subtree_free
parameter_list|(
name|struct
name|lomac_node_entry
modifier|*
name|lneself
parameter_list|)
block|{
name|struct
name|lomac_node_entry_head
modifier|*
name|head
init|=
operator|&
name|lneself
operator|->
name|ln_children
decl_stmt|;
name|struct
name|lomac_node_entry
modifier|*
name|lne
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|lne
operator|=
name|SLIST_FIRST
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|head
argument_list|,
name|ln_chain
argument_list|)
expr_stmt|;
name|lomac_plm_subtree_free
argument_list|(
name|lne
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lneself
argument_list|,
name|M_LOMACPLM
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|string_list
block|{
name|SLIST_ENTRY
argument_list|(
argument|string_list
argument_list|)
name|entries
expr_stmt|;
name|char
name|string
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|string_list
argument_list|)
name|string_list_head
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|string_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|string_list_new
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|sl
decl_stmt|;
name|sl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sl
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|M_LOMACPLM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sl
operator|->
name|string
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|string_list_head
argument_list|,
name|sl
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|sl
operator|->
name|string
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lomac_plm_uninitialize
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lomac_node_entry_head
modifier|*
name|head
init|=
operator|&
name|lomac_node_entry_root
operator|.
name|ln_children
decl_stmt|;
name|struct
name|lomac_node_entry
modifier|*
name|lne
decl_stmt|;
name|struct
name|string_list
modifier|*
name|sl
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|lne
operator|=
name|SLIST_FIRST
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|head
argument_list|,
name|ln_chain
argument_list|)
expr_stmt|;
name|lomac_plm_subtree_free
argument_list|(
name|lne
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|string_list_head
argument_list|)
condition|)
block|{
name|sl
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|string_list_head
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|string_list_head
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sl
argument_list|,
name|M_LOMACPLM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lomac_plm_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lomac_node_entry
modifier|*
name|plne
decl_stmt|,
modifier|*
name|lne
decl_stmt|;
name|plm_rule_t
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|plm
init|;
name|pr
operator|->
name|path
operator|!=
name|NULL
condition|;
name|pr
operator|++
control|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|comp
decl_stmt|;
name|int
name|depth
decl_stmt|;
if|if
condition|(
operator|*
name|pr
operator|->
name|path
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"lomac_plm: invalid path \"%s\"\n"
argument_list|,
name|pr
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|path
operator|=
name|string_list_new
argument_list|(
name|pr
operator|->
name|path
argument_list|)
expr_stmt|;
name|lne
operator|=
operator|&
name|lomac_node_entry_root
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|depth
operator|++
control|)
block|{
name|plne
operator|=
name|lne
expr_stmt|;
name|comp
operator|=
name|strsep
argument_list|(
operator|&
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
comment|/* special case: beginning / */
if|if
condition|(
operator|*
name|comp
operator|==
literal|'\0'
condition|)
continue|continue;
else|else
block|{
name|printf
argument_list|(
literal|"lomac_plm: not absolute path "
literal|"\"%s\"\n"
argument_list|,
name|pr
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* special case: "/" */
if|if
condition|(
operator|*
name|comp
operator|==
literal|'\0'
operator|&&
name|strsep
argument_list|(
operator|&
name|path
argument_list|,
literal|"/"
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|comp
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|comp
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|comp
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"lomac_plm: empty path component in "
literal|"\"%s\"\n"
argument_list|,
name|pr
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lne
operator|=
name|lomac_plm_subtree_find
argument_list|(
name|plne
argument_list|,
name|comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lne
operator|==
name|NULL
condition|)
block|{
name|lne
operator|=
name|lomac_plm_subtree_new
argument_list|(
name|plne
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|lne
operator|->
name|ln_path
operator|=
name|plne
operator|->
name|ln_path
expr_stmt|;
block|}
block|}
name|lne
operator|->
name|ln_path
operator|=
name|pr
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|flags
operator|==
name|PLM_NOFLAGS
condition|)
name|lne
operator|->
name|ln_flags
operator|&=
operator|~
name|LN_LEVEL_MASK
expr_stmt|;
else|else
name|lne
operator|->
name|ln_flags
operator|&=
operator|~
name|LN_INHERIT_MASK
expr_stmt|;
name|lne
operator|->
name|ln_flags
operator||=
name|plm_levelflags_to_node_flags
index|[
name|pr
operator|->
name|level
index|]
index|[
name|pr
operator|->
name|flags
index|]
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|flags
operator|==
name|PLM_NOFLAGS
condition|)
name|lne
operator|->
name|ln_flags
operator||=
name|pr
operator|->
name|attr
expr_stmt|;
else|else
name|lne
operator|->
name|ln_flags
operator||=
operator|(
name|pr
operator|->
name|attr
operator|&
name|LN_ATTR_MASK
operator|)
operator|<<
name|LN_CHILD_ATTR_SHIFT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|lomac_plm_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|lomac_plm_modevent
parameter_list|(
name|module_t
name|module
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|modeventtype
operator|)
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|lomac_plm_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|lomac_plm_initialized
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|lomac_plm_uninitialize
argument_list|()
expr_stmt|;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|lomac_plm_moduledata
init|=
block|{
literal|"lomac_plm"
block|,
operator|&
name|lomac_plm_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|lomac_plm
argument_list|,
name|lomac_plm_moduledata
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|lomac_plm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

