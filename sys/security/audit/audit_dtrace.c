begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by BAE Systems, the University of Cambridge  * Computer Laboratory, and Memorial University under DARPA/AFRL contract  * FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent Computing  * (TC) research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_internal.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_kevents.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_comment
comment|/*-  * Audit DTrace provider: allow DTrace to request that audit records be  * generated for various audit events, and then expose those records (in  * various forms) to probes.  The model is that each event type has two  * probes, which use the event's name to create the probe:  *  * - "commit" passes the kernel-internal (unserialised) kaudit_record  *   synchronously (from the originating thread) of the record as we prepare  *   to "commit" the record to the audit queue.  *  * - "bsm" also passes generated BSM, and executes asynchronously in the audit  *   worker thread, once it has been extracted from the audit queue.  This is  *   the point at which an audit record would be enqueued to the trail on  *   disk, or to pipes.  *  * These probes support very different goals.  The former executes in the  * thread originating the record, making it easier to correlate other DTrace  * probe activity with the event described in the record.  The latter gives  * access to BSM-formatted events (at a cost) allowing DTrace to extract BSM  * directly an alternative mechanism to the formal audit trail and audit  * pipes.  *  * To generate names for numeric event IDs, userspace will push the contents  * of /etc/security/audit_event into the kernel during audit setup, much as it  * does /etc/security/audit_class.  We then create the probes for each of  * those mappings.  If one (or both) of the probes are enabled, then we cause  * a record to be generated (as both normal audit preselection and audit pipes  * do), and catch it on the way out during commit.  There are suitable hook  * functions in the audit code that this provider can register to catch  * various events in the audit-record life cycle.  *  * Further ponderings:  *  * - How do we want to handle events for which there are not names -- perhaps  *   a catch-all probe for those events without mappings?  *  * - Should the evname code really be present even if DTrace isn't loaded...?  *   Right now, we arrange that it is so that userspace can usefully maintain  *   the list in case DTrace is later loaded (and to prevent userspace  *   confusion).  *  * - Should we add an additional set of audit:class::commit probes that use  *   event class names to match broader categories of events as specified in  *   /etc/security/event_class?  *  * - If we pursue that last point, we will want to pass the name of the event  *   into the probe explicitly (e.g., as arg0), since it would no longer be  *   available as the probe function name.  */
end_comment

begin_function_decl
specifier|static
name|int
name|dtaudit_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_getargdesc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|dtrace_argdesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_provide
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_probedesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_destroy
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_enable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_disable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtaudit_load
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|dtaudit_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Strings for the "module" and "name" portions of the probe.  The name of the  * audit event will be the "function" portion of the probe.  All dtaudit  * probes therefore take the form audit:event:<event name>:commit.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dtaudit_module_str
init|=
literal|"event"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dtaudit_name_commit_str
init|=
literal|"commit"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dtaudit_name_bsm_str
init|=
literal|"bsm"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|dtaudit_pops
init|=
block|{
operator|.
name|dtps_provide
operator|=
name|dtaudit_provide
block|,
operator|.
name|dtps_provide_module
operator|=
name|NULL
block|,
operator|.
name|dtps_enable
operator|=
name|dtaudit_enable
block|,
operator|.
name|dtps_disable
operator|=
name|dtaudit_disable
block|,
operator|.
name|dtps_suspend
operator|=
name|NULL
block|,
operator|.
name|dtps_resume
operator|=
name|NULL
block|,
operator|.
name|dtps_getargdesc
operator|=
name|dtaudit_getargdesc
block|,
operator|.
name|dtps_getargval
operator|=
name|NULL
block|,
operator|.
name|dtps_usermode
operator|=
name|NULL
block|,
operator|.
name|dtps_destroy
operator|=
name|dtaudit_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_provider_id_t
name|dtaudit_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Because looking up entries in the event-to-name mapping is quite expensive,  * maintain a global flag tracking whether any dtaudit probes are enabled.  If  * not, don't bother doing all that work whenever potential queries about  * events turn up during preselection or commit.  */
end_comment

begin_decl_stmt
specifier|static
name|uint_t
name|dtaudit_probes_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check dtaudit policy for the event to see whether this is an event we would  * like to preselect (i.e., cause an audit record to be generated for).  To  * minimise probe effect when not used at all, we not only check for the probe  * on the individual event, but also a global flag indicating that at least  * one probe is enabled, before acquiring locks, searching lists, etc.  *  * If the event is selected, return an evname_elem reference to be stored in  * the audit record, which we can use later to avoid further lookups.  The  * contents of the evname_elem must be sufficiently stable so as to not risk  * race conditions here.  *  * Currently, we take an interest only in the 'event' argument, but in the  * future might want to support other types of record selection tied to  * additional probe types (e.g., event clases).  *  * XXXRW: Should we have a catch-all probe here for events without registered  * names?  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dtaudit_preselect
parameter_list|(
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|)
block|{
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|int
name|probe_enabled
decl_stmt|;
comment|/* 	 * NB: Lockless reads here may return a slightly stale value; this is 	 * considered better than acquiring a lock, however. 	 */
if|if
condition|(
operator|!
name|dtaudit_probes_enabled
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ene
operator|=
name|au_evnamemap_lookup
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ene
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * See if either of the two probes for the audit event are enabled. 	 * 	 * NB: Lock also not acquired here -- but perhaps it wouldn't matter 	 * given that we've already used the list lock above? 	 * 	 * XXXRW: Alternatively, au_evnamemap_lookup() could return these 	 * values while holding the list lock...? 	 */
name|probe_enabled
operator|=
name|ene
operator|->
name|ene_commit_probe_enabled
operator|||
name|ene
operator|->
name|ene_bsm_probe_enabled
expr_stmt|;
if|if
condition|(
operator|!
name|probe_enabled
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|ene
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Commit probe pre-BSM.  Fires the probe but also checks to see if we should  * ask the audit framework to call us again with BSM arguments in the audit  * worker thread.  *  * XXXRW: Should we have a catch-all probe here for events without registered  * names?  */
end_comment

begin_function
specifier|static
name|int
name|dtaudit_commit
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|kar
parameter_list|,
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|,
name|int
name|sorf
parameter_list|)
block|{
name|char
name|ene_name_lower
index|[
name|EVNAMEMAP_NAME_SIZE
index|]
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ene
operator|=
operator|(
expr|struct
name|evname_elem
operator|*
operator|)
name|kar
operator|->
name|k_dtaudit_state
expr_stmt|;
if|if
condition|(
name|ene
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Process a possibly registered commit probe. 	 */
if|if
condition|(
name|ene
operator|->
name|ene_commit_probe_enabled
condition|)
block|{
comment|/* 		 * XXXRW: Lock ene to provide stability to the name string.  A 		 * bit undesirable!  We may want another locking strategy 		 * here.  At least we don't run the DTrace probe under the 		 * lock. 		 * 		 * XXXRW: We provide the struct audit_record pointer -- but 		 * perhaps should provide the kaudit_record pointer? 		 */
name|EVNAME_LOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ene_name_lower
argument_list|)
condition|;
name|i
operator|++
control|)
name|ene_name_lower
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|ene
operator|->
name|ene_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|EVNAME_UNLOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|ene
operator|->
name|ene_commit_probe_id
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ene_name_lower
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|kar
operator|->
name|k_ar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the state of the BSM probe to the caller. 	 */
return|return
operator|(
name|ene
operator|->
name|ene_bsm_probe_enabled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Commit probe post-BSM.  *  * XXXRW: Should we have a catch-all probe here for events without registered  * names?  */
end_comment

begin_function
specifier|static
name|void
name|dtaudit_bsm
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|kar
parameter_list|,
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|,
name|int
name|sorf
parameter_list|,
name|void
modifier|*
name|bsm_data
parameter_list|,
name|size_t
name|bsm_len
parameter_list|)
block|{
name|char
name|ene_name_lower
index|[
name|EVNAMEMAP_NAME_SIZE
index|]
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ene
operator|=
operator|(
expr|struct
name|evname_elem
operator|*
operator|)
name|kar
operator|->
name|k_dtaudit_state
expr_stmt|;
if|if
condition|(
name|ene
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|ene
operator|->
name|ene_bsm_probe_enabled
operator|)
condition|)
return|return;
comment|/* 	 * XXXRW: Lock ene to provide stability to the name string.  A bit 	 * undesirable!  We may want another locking strategy here.  At least 	 * we don't run the DTrace probe under the lock. 	 * 	 * XXXRW: We provide the struct audit_record pointer -- but perhaps 	 * should provide the kaudit_record pointer? 	 */
name|EVNAME_LOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ene_name_lower
argument_list|)
condition|;
name|i
operator|++
control|)
name|ene_name_lower
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|ene
operator|->
name|ene_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|EVNAME_UNLOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|ene
operator|->
name|ene_bsm_probe_id
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ene_name_lower
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|kar
operator|->
name|k_ar
argument_list|,
operator|(
name|uintptr_t
operator|)
name|bsm_data
argument_list|,
operator|(
name|uintptr_t
operator|)
name|bsm_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A very simple provider: argument types are identical across all probes: the  * kaudit_record, plus a BSM pointer and length.  */
end_comment

begin_function
specifier|static
name|void
name|dtaudit_getargdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_argdesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ene
operator|=
operator|(
expr|struct
name|evname_elem
operator|*
operator|)
name|parg
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|dtargd_ndx
condition|)
block|{
case|case
literal|0
case|:
comment|/* Audit event name. */
name|p
operator|=
literal|"char *"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* In-kernel audit record. */
name|p
operator|=
literal|"struct audit_record *"
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* BSM data, if present. */
if|if
condition|(
name|id
operator|==
name|ene
operator|->
name|ene_bsm_probe_id
condition|)
name|p
operator|=
literal|"const void *"
expr_stmt|;
else|else
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* BSM length, if present. */
if|if
condition|(
name|id
operator|==
name|ene
operator|->
name|ene_bsm_probe_id
condition|)
name|p
operator|=
literal|"size_t"
expr_stmt|;
else|else
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
break|break;
default|default:
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the event-to-name mapping code when performing  * evname_foreach().  Note that we may update the entry, so the foreach code  * must have a write lock.  However, as the synchronisation model is private  * to the evname code, we cannot easily assert it here.  *  * XXXRW: How do we want to handle event rename / collision issues here --  * e.g., if userspace was using a name to point to one event number, and then  * changes it so that the name points at another?  For now, paper over this by  * skipping event numbers that are already registered, and likewise skipping  * names that are already registered.  However, this could lead to confusing  * behaviour so possibly needs to be resolved in the longer term.  */
end_comment

begin_function
specifier|static
name|void
name|dtaudit_au_evnamemap_callback
parameter_list|(
name|struct
name|evname_elem
modifier|*
name|ene
parameter_list|)
block|{
name|char
name|ene_name_lower
index|[
name|EVNAMEMAP_NAME_SIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * DTrace, by convention, has lower-case probe names.  However, the 	 * in-kernel event-to-name mapping table must maintain event-name case 	 * as submitted by userspace.  Create a temporary lower-case version 	 * here, away from the fast path, to use when exposing the event name 	 * to DTrace as part of the name of a probe. 	 * 	 * NB: Convert the entire array, including the terminating nul, 	 * because these strings are short and it's more work not to.  If they 	 * become long, we might feel more guilty about this sloppiness! 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ene_name_lower
argument_list|)
condition|;
name|i
operator|++
control|)
name|ene_name_lower
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|ene
operator|->
name|ene_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Don't register a new probe if this event number already has an 	 * associated commit probe -- or if another event has already 	 * registered this name. 	 * 	 * XXXRW: There is an argument that if multiple numeric events match 	 * a single name, they should all be exposed to the same named probe. 	 * In particular, we should perhaps use a probe ID returned by this 	 * lookup and just stick that in the saved probe ID? 	 */
if|if
condition|(
operator|(
name|ene
operator|->
name|ene_commit_probe_id
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dtrace_probe_lookup
argument_list|(
name|dtaudit_id
argument_list|,
name|dtaudit_module_str
argument_list|,
name|ene_name_lower
argument_list|,
name|dtaudit_name_commit_str
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Create the commit probe. 		 * 		 * NB: We don't declare any extra stack frames because stack() 		 * will just return the path to the audit commit code, which 		 * is not really interesting anyway. 		 * 		 * We pass in the pointer to the evnam_elem entry so that we 		 * can easily change its enabled flag in the probe 		 * enable/disable interface. 		 */
name|ene
operator|->
name|ene_commit_probe_id
operator|=
name|dtrace_probe_create
argument_list|(
name|dtaudit_id
argument_list|,
name|dtaudit_module_str
argument_list|,
name|ene_name_lower
argument_list|,
name|dtaudit_name_commit_str
argument_list|,
literal|0
argument_list|,
name|ene
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Don't register a new probe if this event number already has an 	 * associated bsm probe -- or if another event has already 	 * registered this name. 	 * 	 * XXXRW: There is an argument that if multiple numeric events match 	 * a single name, they should all be exposed to the same named probe. 	 * In particular, we should perhaps use a probe ID returned by this 	 * lookup and just stick that in the saved probe ID? 	 */
if|if
condition|(
operator|(
name|ene
operator|->
name|ene_bsm_probe_id
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dtrace_probe_lookup
argument_list|(
name|dtaudit_id
argument_list|,
name|dtaudit_module_str
argument_list|,
name|ene_name_lower
argument_list|,
name|dtaudit_name_bsm_str
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Create the bsm probe. 		 * 		 * NB: We don't declare any extra stack frames because stack() 		 * will just return the path to the audit commit code, which 		 * is not really interesting anyway. 		 * 		 * We pass in the pointer to the evnam_elem entry so that we 		 * can easily change its enabled flag in the probe 		 * enable/disable interface. 		 */
name|ene
operator|->
name|ene_bsm_probe_id
operator|=
name|dtrace_probe_create
argument_list|(
name|dtaudit_id
argument_list|,
name|dtaudit_module_str
argument_list|,
name|ene_name_lower
argument_list|,
name|dtaudit_name_bsm_str
argument_list|,
literal|0
argument_list|,
name|ene
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dtaudit_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
comment|/* 	 * Walk all registered number-to-name mapping entries, and ensure each 	 * is properly registered. 	 */
name|au_evnamemap_foreach
argument_list|(
name|dtaudit_au_evnamemap_callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtaudit_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|dtaudit_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|ene
operator|=
name|parg
expr_stmt|;
name|KASSERT
argument_list|(
name|ene
operator|->
name|ene_commit_probe_id
operator|==
name|id
operator|||
name|ene
operator|->
name|ene_bsm_probe_id
operator|==
name|id
argument_list|,
operator|(
literal|"%s: probe ID mismatch (%u, %u != %u)"
operator|,
name|__func__
operator|,
name|ene
operator|->
name|ene_commit_probe_id
operator|,
name|ene
operator|->
name|ene_bsm_probe_id
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ene
operator|->
name|ene_commit_probe_id
condition|)
name|ene
operator|->
name|ene_commit_probe_enabled
operator|=
literal|1
expr_stmt|;
else|else
name|ene
operator|->
name|ene_bsm_probe_enabled
operator|=
literal|1
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|dtaudit_probes_enabled
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtaudit_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|ene
operator|=
name|parg
expr_stmt|;
name|KASSERT
argument_list|(
name|ene
operator|->
name|ene_commit_probe_id
operator|==
name|id
operator|||
name|ene
operator|->
name|ene_bsm_probe_id
operator|==
name|id
argument_list|,
operator|(
literal|"%s: probe ID mismatch (%u, %u != %u)"
operator|,
name|__func__
operator|,
name|ene
operator|->
name|ene_commit_probe_id
operator|,
name|ene
operator|->
name|ene_bsm_probe_id
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ene
operator|->
name|ene_commit_probe_id
condition|)
name|ene
operator|->
name|ene_commit_probe_enabled
operator|=
literal|0
expr_stmt|;
else|else
name|ene
operator|->
name|ene_bsm_probe_enabled
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_release
argument_list|(
operator|&
name|dtaudit_probes_enabled
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtaudit_load
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|dtrace_register
argument_list|(
literal|"audit"
argument_list|,
operator|&
name|dtaudit_attr
argument_list|,
name|DTRACE_PRIV_USER
argument_list|,
name|NULL
argument_list|,
operator|&
name|dtaudit_pops
argument_list|,
name|NULL
argument_list|,
operator|&
name|dtaudit_id
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|dtaudit_hook_preselect
operator|=
name|dtaudit_preselect
expr_stmt|;
name|dtaudit_hook_commit
operator|=
name|dtaudit_commit
expr_stmt|;
name|dtaudit_hook_bsm
operator|=
name|dtaudit_bsm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtaudit_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dtaudit_hook_preselect
operator|=
name|NULL
expr_stmt|;
name|dtaudit_hook_commit
operator|=
name|NULL
expr_stmt|;
name|dtaudit_hook_bsm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dtrace_unregister
argument_list|(
name|dtaudit_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtaudit_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dtaudit_load
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|dtaudit_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dtaudit_unload
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|dtaudit_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|dtaudit
argument_list|,
name|dtaudit_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|dtaudit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dtaudit
argument_list|,
name|dtrace
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dtaudit
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

