begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2009 Apple Inc.  * Copyright (c) 2005, 2016-2017 Robert N. M. Watson  * All rights reserved.  *  * Portions of this software were developed by BAE Systems, the University of  * Cambridge Computer Laboratory, and Memorial University under DARPA/AFRL  * contract FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent  * Computing (TC) research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_kevents.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_comment
comment|/*  * Hash table functions for the audit event number to event class mask  * mapping.  */
end_comment

begin_define
define|#
directive|define
name|EVCLASSMAP_HASH_TABLE_SIZE
value|251
end_define

begin_struct
struct|struct
name|evclass_elem
block|{
name|au_event_t
name|event
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|evclass_elem
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|evclass_list
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|evclass_elem
argument_list|)
name|head
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITEVCLASS
argument_list|,
literal|"audit_evclass"
argument_list|,
literal|"Audit event class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|evclass_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|evclass_list
name|evclass_hash
index|[
name|EVCLASSMAP_HASH_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EVCLASS_LOCK_INIT
parameter_list|()
value|rw_init(&evclass_lock, "evclass_lock")
end_define

begin_define
define|#
directive|define
name|EVCLASS_RLOCK
parameter_list|()
value|rw_rlock(&evclass_lock)
end_define

begin_define
define|#
directive|define
name|EVCLASS_RUNLOCK
parameter_list|()
value|rw_runlock(&evclass_lock)
end_define

begin_define
define|#
directive|define
name|EVCLASS_WLOCK
parameter_list|()
value|rw_wlock(&evclass_lock)
end_define

begin_define
define|#
directive|define
name|EVCLASS_WUNLOCK
parameter_list|()
value|rw_wunlock(&evclass_lock)
end_define

begin_comment
comment|/*  * Hash table maintaining a mapping from audit event numbers to audit event  * names.  For now, used only by DTrace, but present always so that userspace  * tools can register and inspect fields consistently even if DTrace is not  * present.  *  * struct evname_elem is defined in audit_private.h so that audit_dtrace.c can  * use the definition.  */
end_comment

begin_define
define|#
directive|define
name|EVNAMEMAP_HASH_TABLE_SIZE
value|251
end_define

begin_struct
struct|struct
name|evname_list
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|evname_elem
argument_list|)
name|enl_head
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITEVNAME
argument_list|,
literal|"audit_evname"
argument_list|,
literal|"Audit event name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|evnamemap_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|evname_list
name|evnamemap_hash
index|[
name|EVNAMEMAP_HASH_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EVNAMEMAP_LOCK_INIT
parameter_list|()
value|sx_init(&evnamemap_lock, "evnamemap_lock");
end_define

begin_define
define|#
directive|define
name|EVNAMEMAP_RLOCK
parameter_list|()
value|sx_slock(&evnamemap_lock)
end_define

begin_define
define|#
directive|define
name|EVNAMEMAP_RUNLOCK
parameter_list|()
value|sx_sunlock(&evnamemap_lock)
end_define

begin_define
define|#
directive|define
name|EVNAMEMAP_WLOCK
parameter_list|()
value|sx_xlock(&evnamemap_lock)
end_define

begin_define
define|#
directive|define
name|EVNAMEMAP_WUNLOCK
parameter_list|()
value|sx_xunlock(&evnamemap_lock)
end_define

begin_comment
comment|/*  * Look up the class for an audit event in the class mapping table.  */
end_comment

begin_function
name|au_class_t
name|au_event_class
parameter_list|(
name|au_event_t
name|event
parameter_list|)
block|{
name|struct
name|evclass_list
modifier|*
name|evcl
decl_stmt|;
name|struct
name|evclass_elem
modifier|*
name|evc
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|EVCLASS_RLOCK
argument_list|()
expr_stmt|;
name|evcl
operator|=
operator|&
name|evclass_hash
index|[
name|event
operator|%
name|EVCLASSMAP_HASH_TABLE_SIZE
index|]
expr_stmt|;
name|class
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|evc
argument_list|,
argument|&evcl->head
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|evc
operator|->
name|event
operator|==
name|event
condition|)
block|{
name|class
operator|=
name|evc
operator|->
name|class
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|EVCLASS_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a event to class mapping. If the event already exists in the  * mapping, then replace the mapping with the new one.  *  * XXX There is currently no constraints placed on the number of mappings.  * May want to either limit to a number, or in terms of memory usage.  */
end_comment

begin_function
name|void
name|au_evclassmap_insert
parameter_list|(
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|)
block|{
name|struct
name|evclass_list
modifier|*
name|evcl
decl_stmt|;
name|struct
name|evclass_elem
modifier|*
name|evc
decl_stmt|,
modifier|*
name|evc_new
decl_stmt|;
comment|/* 	 * Pessimistically, always allocate storage before acquiring mutex. 	 * Free if there is already a mapping for this event. 	 */
name|evc_new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|evc
argument_list|)
argument_list|,
name|M_AUDITEVCLASS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|EVCLASS_WLOCK
argument_list|()
expr_stmt|;
name|evcl
operator|=
operator|&
name|evclass_hash
index|[
name|event
operator|%
name|EVCLASSMAP_HASH_TABLE_SIZE
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|evc
argument_list|,
argument|&evcl->head
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|evc
operator|->
name|event
operator|==
name|event
condition|)
block|{
name|evc
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|EVCLASS_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|evc_new
argument_list|,
name|M_AUDITEVCLASS
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|evc
operator|=
name|evc_new
expr_stmt|;
name|evc
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|evc
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|evcl
operator|->
name|head
argument_list|,
name|evc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|EVCLASS_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|au_evclassmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EVCLASS_LOCK_INIT
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EVCLASSMAP_HASH_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|evclass_hash
index|[
name|i
index|]
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the initial event to class mapping for system calls. 	 * 	 * XXXRW: Really, this should walk all possible audit events, not all 	 * native ABI system calls, as there may be audit events reachable 	 * only through non-native system calls.  It also seems a shame to 	 * frob the mutex this early. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYS_MAXSYSCALL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sysent
index|[
name|i
index|]
operator|.
name|sy_auevent
operator|!=
name|AUE_NULL
condition|)
name|au_evclassmap_insert
argument_list|(
name|sysent
index|[
name|i
index|]
operator|.
name|sy_auevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up the name for an audit event in the event-to-name mapping table.  */
end_comment

begin_function
name|int
name|au_event_name
parameter_list|(
name|au_event_t
name|event
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|evname_list
modifier|*
name|enl
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
name|EVNAMEMAP_RLOCK
argument_list|()
expr_stmt|;
name|enl
operator|=
operator|&
name|evnamemap_hash
index|[
name|event
operator|%
name|EVNAMEMAP_HASH_TABLE_SIZE
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ene
argument_list|,
argument|&enl->enl_head
argument_list|,
argument|ene_entry
argument_list|)
block|{
if|if
condition|(
name|ene
operator|->
name|ene_event
operator|==
name|event
condition|)
block|{
name|strlcpy
argument_list|(
name|name
argument_list|,
name|ene
operator|->
name|ene_name
argument_list|,
name|EVNAMEMAP_NAME_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|EVNAMEMAP_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a event-to-name mapping.  If the event already exists in the  * mapping, then replace the mapping with the new one.  *  * XXX There is currently no constraints placed on the number of mappings.  * May want to either limit to a number, or in terms of memory usage.  *  * XXXRW: Accepts truncated name -- but perhaps should return failure instead?  *  * XXXRW: It could be we need a way to remove existing names...?  *  * XXXRW: We handle collisions between numbers, but I wonder if we also need a  * way to handle name collisions, for DTrace, where probe names must be  * unique?  */
end_comment

begin_function
name|void
name|au_evnamemap_insert
parameter_list|(
name|au_event_t
name|event
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|evname_list
modifier|*
name|enl
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|,
modifier|*
name|ene_new
decl_stmt|;
comment|/* 	 * Pessimistically, always allocate storage before acquiring lock. 	 * Free if there is already a mapping for this event. 	 */
name|ene_new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ene_new
argument_list|)
argument_list|,
name|M_AUDITEVNAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|EVNAMEMAP_WLOCK
argument_list|()
expr_stmt|;
name|enl
operator|=
operator|&
name|evnamemap_hash
index|[
name|event
operator|%
name|EVNAMEMAP_HASH_TABLE_SIZE
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ene
argument_list|,
argument|&enl->enl_head
argument_list|,
argument|ene_entry
argument_list|)
block|{
if|if
condition|(
name|ene
operator|->
name|ene_event
operator|==
name|event
condition|)
block|{
name|EVNAME_LOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ene
operator|->
name|ene_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ene
operator|->
name|ene_name
argument_list|)
argument_list|)
expr_stmt|;
name|EVNAME_UNLOCK
argument_list|(
name|ene
argument_list|)
expr_stmt|;
name|EVNAMEMAP_WUNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ene_new
argument_list|,
name|M_AUDITEVNAME
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ene
operator|=
name|ene_new
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ene
operator|->
name|ene_lock
argument_list|,
literal|"au_evnamemap"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ene
operator|->
name|ene_event
operator|=
name|event
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ene
operator|->
name|ene_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ene
operator|->
name|ene_name
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|enl
operator|->
name|enl_head
argument_list|,
name|ene
argument_list|,
name|ene_entry
argument_list|)
expr_stmt|;
name|EVNAMEMAP_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|au_evnamemap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EVNAMEMAP_LOCK_INIT
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EVNAMEMAP_HASH_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|evnamemap_hash
index|[
name|i
index|]
operator|.
name|enl_head
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Unlike the event-to-class mapping, we don't attempt to 	 * pre-populate the list.  Perhaps we should...?  But not sure we 	 * really want to duplicate /etc/security/audit_event in the kernel 	 * -- and we'd need a way to remove names? 	 */
block|}
end_function

begin_comment
comment|/*  * The DTrace audit provider occasionally needs to walk the entries in the  * event-to-name mapping table, and uses this public interface to do so.  A  * write lock is acquired so that the provider can safely update its fields in  * table entries.  */
end_comment

begin_function
name|void
name|au_evnamemap_foreach
parameter_list|(
name|au_evnamemap_callback_t
name|callback
parameter_list|)
block|{
name|struct
name|evname_list
modifier|*
name|enl
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EVNAMEMAP_WLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EVNAMEMAP_HASH_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|enl
operator|=
operator|&
name|evnamemap_hash
index|[
name|i
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ene
argument_list|,
argument|&enl->enl_head
argument_list|,
argument|ene_entry
argument_list|)
name|callback
argument_list|(
name|ene
argument_list|)
expr_stmt|;
block|}
name|EVNAMEMAP_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_comment
comment|/*  * Look up an event-to-name mapping table entry by event number.  As evname  * elements are stable in memory, we can return the pointer without the table  * lock held -- but the caller will need to lock the element mutex before  * accessing element fields.  *  * NB: the event identifier in elements is stable and can be read without  * holding the evname_elem lock.  */
end_comment

begin_function
name|struct
name|evname_elem
modifier|*
name|au_evnamemap_lookup
parameter_list|(
name|au_event_t
name|event
parameter_list|)
block|{
name|struct
name|evname_list
modifier|*
name|enl
decl_stmt|;
name|struct
name|evname_elem
modifier|*
name|ene
decl_stmt|;
name|EVNAMEMAP_RLOCK
argument_list|()
expr_stmt|;
name|enl
operator|=
operator|&
name|evnamemap_hash
index|[
name|event
operator|%
name|EVNAMEMAP_HASH_TABLE_SIZE
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ene
argument_list|,
argument|&enl->enl_head
argument_list|,
argument|ene_entry
argument_list|)
block|{
if|if
condition|(
name|ene
operator|->
name|ene_event
operator|==
name|event
condition|)
goto|goto
name|out
goto|;
block|}
name|ene
operator|=
name|NULL
expr_stmt|;
name|out
label|:
name|EVNAMEMAP_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ene
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !KDTRACE_HOOKS */
end_comment

end_unit

