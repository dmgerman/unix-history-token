begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 1999-2008 Apple Inc.  * Copyright (c) 2006-2008, 2016 Robert N. M. Watson  * All rights reserved.  *  * Portions of this software were developed by BAE Systems, the University of  * Cambridge Computer Laboratory, and Memorial University under DARPA/AFRL  * contract FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent  * Computing (TC) research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_internal.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_kevents.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/*  * Worker thread that will schedule disk I/O, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|audit_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * audit_cred and audit_vp are the stored credential and vnode to use for  * active audit trail.  They are protected by the audit worker lock, which  * will be held across all I/O and all rotation to prevent them from being  * replaced (rotated) while in use.  The audit_file_rotate_wait flag is set  * when the kernel has delivered a trigger to auditd to rotate the trail, and  * is cleared when the next rotation takes place.  It is also protected by  * the audit worker lock.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audit_file_rotate_wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucred
modifier|*
name|audit_cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|audit_vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|audit_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|audit_worker_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AUDIT_WORKER_LOCK_INIT
parameter_list|()
value|sx_init(&audit_worker_lock, \ 					    "audit_worker_lock");
end_define

begin_define
define|#
directive|define
name|AUDIT_WORKER_LOCK_ASSERT
parameter_list|()
value|sx_assert(&audit_worker_lock, \ 					    SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|AUDIT_WORKER_LOCK
parameter_list|()
value|sx_xlock(&audit_worker_lock)
end_define

begin_define
define|#
directive|define
name|AUDIT_WORKER_UNLOCK
parameter_list|()
value|sx_xunlock(&audit_worker_lock)
end_define

begin_function
specifier|static
name|void
name|audit_worker_sync_vp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp1
argument_list|)
expr_stmt|;
block|}
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an audit record to a file, performed as the last stage after both  * preselection and BSM conversion.  Both space management and write failures  * are handled in this function.  *  * No attempt is made to deal with possible failure to deliver a trigger to  * the audit daemon, since the message is asynchronous anyway.  */
end_comment

begin_function
specifier|static
name|void
name|audit_record_write
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|last_lowspace_trigger
decl_stmt|;
specifier|static
name|struct
name|timeval
name|last_fail
decl_stmt|;
specifier|static
name|int
name|cur_lowspace_trigger
decl_stmt|;
name|struct
name|statfs
modifier|*
name|mnt_stat
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|static
name|int
name|cur_fail
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|AUDIT_WORKER_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mnt_stat
operator|=
operator|&
name|mp
operator|->
name|mnt_stat
expr_stmt|;
comment|/* 	 * First, gather statistics on the audit log file and file system so 	 * that we know how we're doing on space.  Consider failure of these 	 * operations to indicate a future inability to write to the file. 	 */
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|mp
argument_list|,
name|mnt_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * We handle four different space-related limits: 	 * 	 * - A fixed (hard) limit on the minimum free blocks we require on 	 *   the file system, and results in record loss, a trigger, and 	 *   possible fail stop due to violating invariants. 	 * 	 * - An administrative (soft) limit, which when fallen below, results 	 *   in the kernel notifying the audit daemon of low space. 	 * 	 * - An audit trail size limit, which when gone above, results in the 	 *   kernel notifying the audit daemon that rotation is desired. 	 * 	 * - The total depth of the kernel audit record exceeding free space, 	 *   which can lead to possible fail stop (with drain), in order to 	 *   prevent violating invariants.  Failure here doesn't halt 	 *   immediately, but prevents new records from being generated. 	 * 	 * Possibly, the last of these should be handled differently, always 	 * allowing a full queue to be lost, rather than trying to prevent 	 * loss. 	 * 	 * First, handle the hard limit, which generates a trigger and may 	 * fail stop.  This is handled in the same manner as ENOSPC from 	 * VOP_WRITE, and results in record loss. 	 */
if|if
condition|(
name|mnt_stat
operator|->
name|f_bfree
operator|<
name|AUDIT_HARD_LIMIT_FREE_BLOCKS
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail_enospc
goto|;
block|}
comment|/* 	 * Second, handle falling below the soft limit, if defined; we send 	 * the daemon a trigger and continue processing the record.  Triggers 	 * are limited to 1/sec. 	 */
if|if
condition|(
name|audit_qctrl
operator|.
name|aq_minfree
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|mnt_stat
operator|->
name|f_blocks
operator|/
operator|(
literal|100
operator|/
name|audit_qctrl
operator|.
name|aq_minfree
operator|)
expr_stmt|;
if|if
condition|(
name|mnt_stat
operator|->
name|f_bfree
operator|<
name|temp
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|last_lowspace_trigger
argument_list|,
operator|&
name|cur_lowspace_trigger
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|audit_send_trigger
argument_list|(
name|AUDIT_TRIGGER_LOW_SPACE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: disk space low (< %d%% free) "
literal|"on audit log file-system\n"
argument_list|,
name|audit_qctrl
operator|.
name|aq_minfree
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If the current file is getting full, generate a rotation trigger 	 * to the daemon.  This is only approximate, which is fine as more 	 * records may be generated before the daemon rotates the file. 	 */
if|if
condition|(
name|audit_fstat
operator|.
name|af_filesz
operator|!=
literal|0
operator|&&
name|audit_size
operator|>=
name|audit_fstat
operator|.
name|af_filesz
operator|*
operator|(
name|audit_file_rotate_wait
operator|+
literal|1
operator|)
condition|)
block|{
name|AUDIT_WORKER_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|audit_file_rotate_wait
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|audit_send_trigger
argument_list|(
name|AUDIT_TRIGGER_ROTATE_KERNEL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the estimated amount of audit data in the audit event queue 	 * (plus records allocated but not yet queued) has reached the amount 	 * of free space on the disk, then we need to go into an audit fail 	 * stop state, in which we do not permit the allocation/committing of 	 * any new audit records.  We continue to process records but don't 	 * allow any activities that might generate new records.  In the 	 * future, we might want to detect when space is available again and 	 * allow operation to continue, but this behavior is sufficient to 	 * meet fail stop requirements in CAPP. 	 */
if|if
condition|(
name|audit_fail_stop
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|audit_q_len
operator|+
name|audit_pre_q_len
operator|+
literal|1
operator|)
operator|*
name|MAX_AUDIT_RECORD_SIZE
argument_list|)
operator|/
name|mnt_stat
operator|->
name|f_bsize
operator|>=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|mnt_stat
operator|->
name|f_bfree
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|last_fail
argument_list|,
operator|&
name|cur_fail
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"audit_record_write: free space "
literal|"below size of audit queue, failing "
literal|"stop\n"
argument_list|)
expr_stmt|;
name|audit_in_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|audit_in_failure
condition|)
block|{
comment|/* 			 * Note: if we want to handle recovery, this is the 			 * spot to do it: unset audit_in_failure, and issue a 			 * wakeup on the cv. 			 */
block|}
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
goto|goto
name|fail_enospc
goto|;
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|AUDIT_WORKER_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|audit_size
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Catch completion of a queue drain here; if we're draining and the 	 * queue is now empty, fail stop.  That audit_fail_stop is implicitly 	 * true, since audit_in_failure can only be set of audit_fail_stop is 	 * set. 	 * 	 * Note: if we handle recovery from audit_in_failure, then we need to 	 * make panic here conditional. 	 */
if|if
condition|(
name|audit_in_failure
condition|)
block|{
if|if
condition|(
name|audit_q_len
operator|==
literal|0
operator|&&
name|audit_pre_q_len
operator|==
literal|0
condition|)
block|{
name|audit_worker_sync_vp
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|,
literal|"Audit store overflow; record queue drained."
argument_list|)
expr_stmt|;
block|}
block|}
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
name|fail_enospc
label|:
comment|/* 	 * ENOSPC is considered a special case with respect to failures, as 	 * this can reflect either our preemptive detection of insufficient 	 * space, or ENOSPC returned by the vnode write call. 	 */
if|if
condition|(
name|audit_fail_stop
condition|)
block|{
name|audit_worker_sync_vp
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|,
literal|"Audit log space exhausted and fail-stop set."
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|audit_send_trigger
argument_list|(
name|AUDIT_TRIGGER_NO_SPACE
argument_list|)
expr_stmt|;
name|audit_suspended
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
name|fail
label|:
comment|/* 	 * We have failed to write to the file, so the current record is 	 * lost, which may require an immediate system halt. 	 */
if|if
condition|(
name|audit_panic_on_write_fail
condition|)
block|{
name|audit_worker_sync_vp
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|,
literal|"audit_worker: write error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|last_fail
argument_list|,
operator|&
name|cur_fail
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"audit_worker: write error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a kernel audit record, process as required.  Kernel audit records  * are converted to one, or possibly two, BSM records, depending on whether  * there is a user audit record present also.  Kernel records need be  * converted to BSM before they can be written out.  Both types will be  * written to disk, and audit pipes.  */
end_comment

begin_function
specifier|static
name|void
name|audit_worker_process_record
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|ar
parameter_list|)
block|{
name|struct
name|au_record
modifier|*
name|bsm
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|au_event_t
name|event
decl_stmt|;
name|au_id_t
name|auid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sorf
decl_stmt|;
name|int
name|locked
decl_stmt|;
comment|/* 	 * We hold the audit worker lock over both writes, if there are two, 	 * so that the two records won't be split across a rotation and end 	 * up in two different trail files. 	 */
if|if
condition|(
operator|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_USER
operator|)
operator|&&
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_USER_TRAIL
operator|)
operator|)
operator|||
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_TRAIL
operator|)
condition|)
block|{
name|AUDIT_WORKER_LOCK
argument_list|()
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First, handle the user record, if any: commit to the system trail 	 * and audit pipes as selected. 	 */
if|if
condition|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_USER
operator|)
operator|&&
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_USER_TRAIL
operator|)
condition|)
block|{
name|AUDIT_WORKER_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|audit_record_write
argument_list|(
name|audit_vp
argument_list|,
name|audit_cred
argument_list|,
name|ar
operator|->
name|k_udata
argument_list|,
name|ar
operator|->
name|k_ulen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_USER
operator|)
operator|&&
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_USER_PIPE
operator|)
condition|)
name|audit_pipe_submit_user
argument_list|(
name|ar
operator|->
name|k_udata
argument_list|,
name|ar
operator|->
name|k_ulen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_KERNEL
operator|)
operator|||
operator|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_PIPE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_TRAIL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_DTRACE
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
name|auid
operator|=
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
expr_stmt|;
name|event
operator|=
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
expr_stmt|;
name|class
operator|=
name|au_event_class
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_errno
operator|==
literal|0
condition|)
name|sorf
operator|=
name|AU_PRS_SUCCESS
expr_stmt|;
else|else
name|sorf
operator|=
name|AU_PRS_FAILURE
expr_stmt|;
name|error
operator|=
name|kaudit_to_bsm
argument_list|(
name|ar
argument_list|,
operator|&
name|bsm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|BSM_NOAUDIT
case|:
goto|goto
name|out
goto|;
case|case
name|BSM_FAILURE
case|:
name|printf
argument_list|(
literal|"audit_worker_process_record: BSM_FAILURE\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|BSM_SUCCESS
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"kaudit_to_bsm returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_TRAIL
condition|)
block|{
name|AUDIT_WORKER_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|audit_record_write
argument_list|(
name|audit_vp
argument_list|,
name|audit_cred
argument_list|,
name|bsm
operator|->
name|data
argument_list|,
name|bsm
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_PIPE
condition|)
name|audit_pipe_submit
argument_list|(
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_TRAIL
argument_list|,
name|bsm
operator|->
name|data
argument_list|,
name|bsm
operator|->
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
comment|/* 	 * Version of the dtaudit commit hook that accepts BSM. 	 */
if|if
condition|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_DTRACE
condition|)
block|{
if|if
condition|(
name|dtaudit_hook_bsm
operator|!=
name|NULL
condition|)
name|dtaudit_hook_bsm
argument_list|(
name|ar
argument_list|,
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
name|bsm
operator|->
name|data
argument_list|,
name|bsm
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|kau_free
argument_list|(
name|bsm
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|locked
condition|)
name|AUDIT_WORKER_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The audit_worker thread is responsible for watching the event queue,  * dequeueing records, converting them to BSM format, and committing them to  * disk.  In order to minimize lock thrashing, records are dequeued in sets  * to a thread-local work queue.  *  * Note: this means that the effect bound on the size of the pending record  * queue is 2x the length of the global queue.  */
end_comment

begin_function
specifier|static
name|void
name|audit_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|kaudit_queue
name|ar_worklist
decl_stmt|;
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|int
name|lowater_signal
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ar_worklist
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|audit_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for a record. 		 */
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|audit_q
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|audit_worker_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * If there are records in the global audit record queue, 		 * transfer them to a thread-local queue and process them 		 * one by one.  If we cross the low watermark threshold, 		 * signal any waiting processes that they may wake up and 		 * continue generating records. 		 */
name|lowater_signal
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ar
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_q
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|audit_q
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|--
expr_stmt|;
if|if
condition|(
name|audit_q_len
operator|==
name|audit_qctrl
operator|.
name|aq_lowater
condition|)
name|lowater_signal
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ar_worklist
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lowater_signal
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|audit_watermark_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ar
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ar_worklist
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ar_worklist
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|audit_worker_process_record
argument_list|(
name|ar
argument_list|)
expr_stmt|;
name|audit_free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * audit_rotate_vnode() is called by a user or kernel thread to configure or  * de-configure auditing on a vnode.  The arguments are the replacement  * credential (referenced) and vnode (referenced and opened) to substitute  * for the current credential and vnode, if any.  If either is set to NULL,  * both should be NULL, and this is used to indicate that audit is being  * disabled.  Any previous cred/vnode will be closed and freed.  We re-enable  * generating rotation requests to auditd.  */
end_comment

begin_function
name|void
name|audit_rotate_vnode
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|old_audit_cred
decl_stmt|;
name|struct
name|vnode
modifier|*
name|old_audit_vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cred
operator|!=
name|NULL
operator|&&
name|vp
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|cred
operator|==
name|NULL
operator|&&
name|vp
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"audit_rotate_vnode: cred %p vp %p"
operator|,
name|cred
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cred
argument_list|)
operator|!=
literal|0
condition|)
name|vattr
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vattr
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Rotate the vnode/cred, and clear the rotate flag so that we will 	 * send a rotate trigger if the new file fills. 	 */
name|AUDIT_WORKER_LOCK
argument_list|()
expr_stmt|;
name|old_audit_cred
operator|=
name|audit_cred
expr_stmt|;
name|old_audit_vp
operator|=
name|audit_vp
expr_stmt|;
name|audit_cred
operator|=
name|cred
expr_stmt|;
name|audit_vp
operator|=
name|vp
expr_stmt|;
name|audit_size
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
name|audit_file_rotate_wait
operator|=
literal|0
expr_stmt|;
name|audit_enabled
operator|=
operator|(
name|audit_vp
operator|!=
name|NULL
operator|)
expr_stmt|;
name|AUDIT_WORKER_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * If there was an old vnode/credential, close and free. 	 */
if|if
condition|(
name|old_audit_vp
operator|!=
name|NULL
condition|)
block|{
name|vn_close
argument_list|(
name|old_audit_vp
argument_list|,
name|AUDIT_CLOSE_FLAGS
argument_list|,
name|old_audit_cred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|old_audit_cred
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|audit_worker_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|AUDIT_WORKER_LOCK_INIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|audit_worker
argument_list|,
name|NULL
argument_list|,
operator|&
name|audit_thread
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"audit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"audit_worker_init: kproc_create returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

