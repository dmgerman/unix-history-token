begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_comment
comment|/*  * Implementation of a clonable special device providing a live stream of BSM  * audit data.  This is a "tee" of the data going to the file.  It provides  * unreliable but timely access to audit events.  Consumers of this interface  * should be very careful to avoid introducing event cycles.  */
end_comment

begin_comment
comment|/*  * Memory types.  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDIT_PIPE
argument_list|,
literal|"audit_pipe"
argument_list|,
literal|"Audit pipes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDIT_PIPE_ENTRY
argument_list|,
literal|"audit_pipeent"
argument_list|,
literal|"Audit pipe entries and buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Audit pipe buffer parameters.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_DEFAULT
value|(128)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_MIN
value|(0)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_MAX
value|(1024)
end_define

begin_comment
comment|/*  * Description of an entry in an audit_pipe.  */
end_comment

begin_struct
struct|struct
name|audit_pipe_entry
block|{
name|void
modifier|*
name|ape_record
decl_stmt|;
name|u_int
name|ape_record_len
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|audit_pipe_entry
argument_list|)
name|ape_queue
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Description of an individual audit_pipe.  Consists largely of a bounded  * length queue.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_ASYNC
value|0x00000001
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_NBIO
value|0x00000002
end_define

begin_struct
struct|struct
name|audit_pipe
block|{
name|int
name|ap_open
decl_stmt|;
comment|/* Device open? */
name|u_int
name|ap_flags
decl_stmt|;
name|struct
name|selinfo
name|ap_selinfo
decl_stmt|;
name|struct
name|sigio
modifier|*
name|ap_sigio
decl_stmt|;
name|u_int
name|ap_qlen
decl_stmt|;
name|u_int
name|ap_qlimit
decl_stmt|;
name|u_int64_t
name|ap_inserts
decl_stmt|;
comment|/* Records added. */
name|u_int64_t
name|ap_reads
decl_stmt|;
comment|/* Records read. */
name|u_int64_t
name|ap_drops
decl_stmt|;
comment|/* Records dropped. */
name|u_int64_t
name|ap_truncates
decl_stmt|;
comment|/* Records too long. */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|audit_pipe_entry
argument_list|)
name|ap_queue
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|audit_pipe
argument_list|)
name|ap_list
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Global list of audit pipes, mutex to protect it and the pipes.  Finder  * grained locking may be desirable at some point.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|audit_pipe
argument_list|)
name|audit_pipe_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|audit_pipe_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This CV is used to wakeup on an audit record write.  Eventually, it should  * probably be per-pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_pipe_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Cloning related variables and constants.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_NAME
value|"auditpipe"
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|audit_pipe_eh_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clonedevs
modifier|*
name|audit_pipe_clones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special device methods and definition.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|audit_pipe_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|audit_pipe_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|audit_pipe_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|audit_pipe_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|audit_pipe_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|audit_pipe_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_PSEUDO
block|,
operator|.
name|d_open
operator|=
name|audit_pipe_open
block|,
operator|.
name|d_close
operator|=
name|audit_pipe_close
block|,
operator|.
name|d_read
operator|=
name|audit_pipe_read
block|,
operator|.
name|d_ioctl
operator|=
name|audit_pipe_ioctl
block|,
operator|.
name|d_poll
operator|=
name|audit_pipe_poll
block|,
operator|.
name|d_name
operator|=
name|AUDIT_PIPE_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some global statistics on audit pipes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audit_pipe_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of pipes. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_ever
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pipes ever allocated. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_records
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records seen. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_drops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global record drop count. */
end_comment

begin_comment
comment|/*  * Free an audit pipe entry.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_entry_free
parameter_list|(
name|struct
name|audit_pipe_entry
modifier|*
name|ape
parameter_list|)
block|{
name|free
argument_list|(
name|ape
operator|->
name|ape_record
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ape
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Apparent individual record to a queue -- allocate queue-local buffer, and  * add to the queue.  We try to drop from the head of the queue so that more  * recent events take precedence over older ones, but if allocation fails we  * do drop the new event.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_append
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|void
modifier|*
name|record
parameter_list|,
name|u_int
name|record_len
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|,
modifier|*
name|ape_remove
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ape
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ape
argument_list|)
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|==
name|NULL
condition|)
block|{
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
return|return;
block|}
name|ape
operator|->
name|ape_record
operator|=
name|malloc
argument_list|(
name|record_len
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|->
name|ape_record
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ape
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|record
argument_list|,
name|ape
operator|->
name|ape_record
argument_list|,
name|record_len
argument_list|)
expr_stmt|;
name|ape
operator|->
name|ape_record_len
operator|=
name|record_len
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_qlen
operator|>=
name|ap
operator|->
name|ap_qlimit
condition|)
block|{
name|ape_remove
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape_remove
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|audit_pipe_entry_free
argument_list|(
name|ape_remove
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|--
expr_stmt|;
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_inserts
operator|++
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|++
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_flags
operator|&
name|AUDIT_PIPE_ASYNC
condition|)
name|pgsigio
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_pipe_submit(): audit_worker submits audit records via this  * interface, which arranges for them to be delivered to pipe queues.  */
end_comment

begin_function
name|void
name|audit_pipe_submit
parameter_list|(
name|void
modifier|*
name|record
parameter_list|,
name|u_int
name|record_len
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
comment|/* 	 * Lockless read to avoid mutex overhead if pipes are not in use. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_pipe_list
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ap
argument_list|,
argument|&audit_pipe_list
argument_list|,
argument|ap_list
argument_list|)
name|audit_pipe_append
argument_list|(
name|ap
argument_list|,
name|record
argument_list|,
name|record_len
argument_list|)
expr_stmt|;
name|audit_pipe_records
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|audit_pipe_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next record off of an audit pipe.  */
end_comment

begin_function
specifier|static
name|struct
name|audit_pipe_entry
modifier|*
name|audit_pipe_pop
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ape
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ape
operator|==
name|NULL
operator|&&
name|ap
operator|->
name|ap_qlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|ape
operator|!=
name|NULL
operator|&&
name|ap
operator|->
name|ap_qlen
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"audit_pipe_pop: qlen"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|--
expr_stmt|;
return|return
operator|(
name|ape
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new audit pipe.  Connects the pipe, on success, to the global  * list and updates statistics.  */
end_comment

begin_function
specifier|static
name|struct
name|audit_pipe
modifier|*
name|audit_pipe_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|,
name|M_AUDIT_PIPE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ap
operator|->
name|ap_qlimit
operator|=
name|AUDIT_PIPE_QLIMIT_DEFAULT
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|audit_pipe_list
argument_list|,
name|ap
argument_list|,
name|ap_list
argument_list|)
expr_stmt|;
name|audit_pipe_count
operator|++
expr_stmt|;
name|audit_pipe_ever
operator|++
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an audit pipe.  Assumes mutex is held, audit_pipe is still on the  * global list.  Frees any audit pipe entries in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_free
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|audit_pipe_list
argument_list|,
name|ap
argument_list|,
name|ap_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ape
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|audit_pipe_entry_free
argument_list|(
name|ape
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_qlen
operator|==
literal|0
argument_list|,
operator|(
literal|"audit_pipe_free: ap_qlen"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|,
name|M_AUDIT_PIPE
argument_list|)
expr_stmt|;
name|audit_pipe_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe clone routine -- provide specific requested audit pipe, or a  * fresh one if a specific one is not requested.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|)
operator|==
literal|0
condition|)
name|u
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|,
operator|&
name|u
argument_list|)
operator|!=
literal|1
condition|)
return|return;
name|i
operator|=
name|clone_create
argument_list|(
operator|&
name|audit_pipe_clones
argument_list|,
operator|&
name|audit_pipe_cdevsw
argument_list|,
operator|&
name|u
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|audit_pipe_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|u
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
block|{
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|si_flags
operator||=
name|SI_CHEAPCLONE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Audit pipe open method.  Explicit suser check isn't used as this allows  * file permissions on the special device to be used to grant audit review  * access.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
name|ap
operator|=
name|audit_pipe_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dev
operator|->
name|si_drv1
operator|=
name|ap
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_open
argument_list|,
operator|(
literal|"audit_pipe_open: ap&& !ap_open"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ap
operator|->
name|ap_open
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|fsetown
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close audit pipe, tear down all records, etc.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_close: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_open
argument_list|,
operator|(
literal|"audit_pipe_close: !ap_open"
operator|)
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_open
operator|=
literal|0
expr_stmt|;
name|audit_pipe_free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe ioctl() routine.  Handle file descriptor and audit pipe layer  * commands.  *  * Would be desirable to support filtering, although perhaps something simple  * like an event mask, as opposed to something complicated like BPF.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_ioctl: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|ap
operator|->
name|ap_flags
operator||=
name|AUDIT_PIPE_NBIO
expr_stmt|;
else|else
name|ap
operator|->
name|ap_flags
operator|&=
operator|~
name|AUDIT_PIPE_NBIO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIONREAD
case|:
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|->
name|ape_record_len
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|ap
operator|->
name|ap_flags
operator||=
name|AUDIT_PIPE_ASYNC
expr_stmt|;
else|else
name|ap
operator|->
name|ap_flags
operator|&=
operator|~
name|AUDIT_PIPE_ASYNC
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_qlen
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_qlimit
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_QLIMIT
case|:
comment|/* Lockless integer write. */
if|if
condition|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|>=
name|AUDIT_PIPE_QLIMIT_MIN
operator|||
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|<=
name|AUDIT_PIPE_QLIMIT_MAX
condition|)
block|{
name|ap
operator|->
name|ap_qlimit
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT_MIN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|AUDIT_PIPE_QLIMIT_MIN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT_MAX
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|AUDIT_PIPE_QLIMIT_MAX
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_INSERTS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_inserts
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_READS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_reads
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_DROPS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_drops
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_TRUNCATES
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_truncates
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe read.  Pull one record off the queue and copy to user space.  * On error, the record is dropped.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_read: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		 * Wait for a record that fits into the read buffer, dropping 		 * records that would be truncated if actually passed to the 		 * process.  This helps maintain the discreet record read 		 * interface. 		 */
while|while
condition|(
operator|(
name|ape
operator|=
name|audit_pipe_pop
argument_list|(
name|ap
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|ap_flags
operator|&
name|AUDIT_PIPE_NBIO
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|audit_pipe_cv
argument_list|,
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ape
operator|->
name|ape_record_len
operator|<=
name|uio
operator|->
name|uio_resid
condition|)
break|break;
name|audit_pipe_entry_free
argument_list|(
name|ape
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_truncates
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Now read record to user space memory.  Even if the read is short, 	 * we abandon the remainder of the record, supporting only discreet 	 * record reads. 	 */
name|error
operator|=
name|uiomove
argument_list|(
name|ape
operator|->
name|ape_record
argument_list|,
name|ape
operator|->
name|ape_record_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|audit_pipe_entry_free
argument_list|(
name|ape
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe poll.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_poll: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|!=
name|NULL
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|ap
operator|->
name|ap_selinfo
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the audit pipe system.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|audit_pipe_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|audit_pipe_mtx
argument_list|,
literal|"audit_pipe_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_pipe_cv
argument_list|,
literal|"audit_pipe_cv"
argument_list|)
expr_stmt|;
name|clone_setup
argument_list|(
operator|&
name|audit_pipe_clones
argument_list|)
expr_stmt|;
name|audit_pipe_eh_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|audit_pipe_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_pipe_eh_tag
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"audit_pipe_init: EVENTHANDLER_REGISTER"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|audit_pipe_init
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|audit_pipe_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

