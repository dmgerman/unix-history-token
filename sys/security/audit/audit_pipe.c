begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Robert N. M. Watson  * Copyright (c) 2008 Apple, Inc.  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_comment
comment|/*  * Implementation of a clonable special device providing a live stream of BSM  * audit data.  This is a "tee" of the data going to the file.  It provides  * unreliable but timely access to audit events.  Consumers of this interface  * should be very careful to avoid introducing event cycles.  Consumers may  * express interest via a set of preselection ioctls.  */
end_comment

begin_comment
comment|/*  * Memory types.  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDIT_PIPE
argument_list|,
literal|"audit_pipe"
argument_list|,
literal|"Audit pipes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDIT_PIPE_ENTRY
argument_list|,
literal|"audit_pipeent"
argument_list|,
literal|"Audit pipe entries and buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDIT_PIPE_PRESELECT
argument_list|,
literal|"audit_pipe_presel"
argument_list|,
literal|"Audit pipe preselection structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Audit pipe buffer parameters.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_DEFAULT
value|(128)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_MIN
value|(0)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_QLIMIT_MAX
value|(1024)
end_define

begin_comment
comment|/*  * Description of an entry in an audit_pipe.  */
end_comment

begin_struct
struct|struct
name|audit_pipe_entry
block|{
name|void
modifier|*
name|ape_record
decl_stmt|;
name|u_int
name|ape_record_len
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|audit_pipe_entry
argument_list|)
name|ape_queue
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Audit pipes allow processes to express "interest" in the set of records  * that are delivered via the pipe.  They do this in a similar manner to the  * mechanism for audit trail configuration, by expressing two global masks,  * and optionally expressing per-auid masks.  The following data structure is  * the per-auid mask description.  The global state is stored in the audit  * pipe data structure.  *  * We may want to consider a more space/time-efficient data structure once  * usage patterns for per-auid specifications are clear.  */
end_comment

begin_struct
struct|struct
name|audit_pipe_preselect
block|{
name|au_id_t
name|app_auid
decl_stmt|;
name|au_mask_t
name|app_mask
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|audit_pipe_preselect
argument_list|)
name|app_list
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Description of an individual audit_pipe.  Consists largely of a bounded  * length queue.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_ASYNC
value|0x00000001
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_NBIO
value|0x00000002
end_define

begin_struct
struct|struct
name|audit_pipe
block|{
name|int
name|ap_open
decl_stmt|;
comment|/* Device open? */
name|u_int
name|ap_flags
decl_stmt|;
name|struct
name|selinfo
name|ap_selinfo
decl_stmt|;
name|struct
name|sigio
modifier|*
name|ap_sigio
decl_stmt|;
comment|/* 	 * Per-pipe mutex protecting most fields in this data structure. 	 */
name|struct
name|mtx
name|ap_mtx
decl_stmt|;
comment|/* 	 * Per-pipe sleep lock serializing user-generated reads and flushes. 	 * uiomove() is called to copy out the current head record's data 	 * while the record remains in the queue, so we prevent other threads 	 * from removing it using this lock. 	 */
name|struct
name|sx
name|ap_sx
decl_stmt|;
comment|/* 	 * Condition variable to signal when data has been delivered to a 	 * pipe. 	 */
name|struct
name|cv
name|ap_cv
decl_stmt|;
comment|/* 	 * Various queue-reated variables: qlen and qlimit are a count of 	 * records in the queue; qbyteslen is the number of bytes of data 	 * across all records, and qoffset is the amount read so far of the 	 * first record in the queue.  The number of bytes available for 	 * reading in the queue is qbyteslen - qoffset. 	 */
name|u_int
name|ap_qlen
decl_stmt|;
name|u_int
name|ap_qlimit
decl_stmt|;
name|u_int
name|ap_qbyteslen
decl_stmt|;
name|u_int
name|ap_qoffset
decl_stmt|;
comment|/* 	 * Per-pipe operation statistics. 	 */
name|u_int64_t
name|ap_inserts
decl_stmt|;
comment|/* Records added. */
name|u_int64_t
name|ap_reads
decl_stmt|;
comment|/* Records read. */
name|u_int64_t
name|ap_drops
decl_stmt|;
comment|/* Records dropped. */
comment|/* 	 * Fields relating to pipe interest: global masks for unmatched 	 * processes (attributable, non-attributable), and a list of specific 	 * interest specifications by auid. 	 */
name|int
name|ap_preselect_mode
decl_stmt|;
name|au_mask_t
name|ap_preselect_flags
decl_stmt|;
name|au_mask_t
name|ap_preselect_naflags
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|audit_pipe_preselect
argument_list|)
name|ap_preselect_list
expr_stmt|;
comment|/* 	 * Current pending record list.  Protected by a combination of ap_mtx 	 * and ap_sx.  Note particularly that *both* locks are required to 	 * remove a record from the head of the queue, as an in-progress read		 * may sleep while copying and therefore cannot hold ap_mtx. 	 */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|audit_pipe_entry
argument_list|)
name|ap_queue
expr_stmt|;
comment|/* 	 * Global pipe list. 	 */
name|TAILQ_ENTRY
argument_list|(
argument|audit_pipe
argument_list|)
name|ap_list
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AUDIT_PIPE_LOCK
parameter_list|(
name|ap
parameter_list|)
value|mtx_lock(&(ap)->ap_mtx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LOCK_ASSERT
parameter_list|(
name|ap
parameter_list|)
value|mtx_assert(&(ap)->ap_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LOCK_DESTROY
parameter_list|(
name|ap
parameter_list|)
value|mtx_destroy(&(ap)->ap_mtx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LOCK_INIT
parameter_list|(
name|ap
parameter_list|)
value|mtx_init(&(ap)->ap_mtx, \ 					    "audit_pipe_mtx", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_UNLOCK
parameter_list|(
name|ap
parameter_list|)
value|mtx_unlock(&(ap)->ap_mtx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_MTX
parameter_list|(
name|ap
parameter_list|)
value|(&(ap)->ap_mtx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_SX_LOCK_DESTROY
parameter_list|(
name|ap
parameter_list|)
value|sx_destroy(&(ap)->ap_sx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_SX_LOCK_INIT
parameter_list|(
name|ap
parameter_list|)
value|sx_init(&(ap)->ap_sx, "audit_pipe_sx")
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_SX_XLOCK_ASSERT
parameter_list|(
name|ap
parameter_list|)
value|sx_assert(&(ap)->ap_sx, SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_SX_XLOCK_SIG
parameter_list|(
name|ap
parameter_list|)
value|sx_xlock_sig(&(ap)->ap_sx)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_SX_XUNLOCK
parameter_list|(
name|ap
parameter_list|)
value|sx_xunlock(&(ap)->ap_sx)
end_define

begin_comment
comment|/*  * Global list of audit pipes, rwlock to protect it.  Individual record  * queues on pipes are protected by per-pipe locks; these locks synchronize  * between threads walking the list to deliver to individual pipes and add/  * remove of pipes, and are mostly acquired for read.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|audit_pipe
argument_list|)
name|audit_pipe_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|audit_pipe_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_LOCK_INIT
parameter_list|()
value|rw_init(&audit_pipe_lock, \ 					    "audit_pipe_list_lock")
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_RLOCK
parameter_list|()
value|rw_rlock(&audit_pipe_lock)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_RUNLOCK
parameter_list|()
value|rw_runlock(&audit_pipe_lock)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_WLOCK
parameter_list|()
value|rw_wlock(&audit_pipe_lock)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_WLOCK_ASSERT
parameter_list|()
value|rw_assert(&audit_pipe_lock, \ 					    RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|AUDIT_PIPE_LIST_WUNLOCK
parameter_list|()
value|rw_wunlock(&audit_pipe_lock)
end_define

begin_comment
comment|/*  * Cloning related variables and constants.  */
end_comment

begin_define
define|#
directive|define
name|AUDIT_PIPE_NAME
value|"auditpipe"
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|audit_pipe_eh_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clonedevs
modifier|*
name|audit_pipe_clones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special device methods and definition.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|audit_pipe_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|audit_pipe_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|audit_pipe_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|audit_pipe_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|audit_pipe_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|audit_pipe_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|audit_pipe_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_PSEUDO
operator||
name|D_NEEDGIANT
operator||
name|D_NEEDMINOR
block|,
operator|.
name|d_open
operator|=
name|audit_pipe_open
block|,
operator|.
name|d_close
operator|=
name|audit_pipe_close
block|,
operator|.
name|d_read
operator|=
name|audit_pipe_read
block|,
operator|.
name|d_ioctl
operator|=
name|audit_pipe_ioctl
block|,
operator|.
name|d_poll
operator|=
name|audit_pipe_poll
block|,
operator|.
name|d_kqfilter
operator|=
name|audit_pipe_kqfilter
block|,
operator|.
name|d_name
operator|=
name|AUDIT_PIPE_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|audit_pipe_kqread
parameter_list|(
name|struct
name|knote
modifier|*
name|note
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|audit_pipe_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|audit_pipe_read_filterops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_attach
operator|=
name|NULL
block|,
operator|.
name|f_detach
operator|=
name|audit_pipe_kqdetach
block|,
operator|.
name|f_event
operator|=
name|audit_pipe_kqread
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some global statistics on audit pipes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audit_pipe_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of pipes. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_ever
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pipes ever allocated. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_records
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records seen. */
end_comment

begin_decl_stmt
specifier|static
name|u_int64_t
name|audit_pipe_drops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global record drop count. */
end_comment

begin_comment
comment|/*  * Free an audit pipe entry.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_entry_free
parameter_list|(
name|struct
name|audit_pipe_entry
modifier|*
name|ape
parameter_list|)
block|{
name|free
argument_list|(
name|ape
operator|->
name|ape_record
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ape
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an audit pipe preselection specification for an auid, if any.  */
end_comment

begin_function
specifier|static
name|struct
name|audit_pipe_preselect
modifier|*
name|audit_pipe_preselect_find
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|au_id_t
name|auid
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|app
argument_list|,
argument|&ap->ap_preselect_list
argument_list|,
argument|app_list
argument_list|)
block|{
if|if
condition|(
name|app
operator|->
name|app_auid
operator|==
name|auid
condition|)
return|return
operator|(
name|app
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the per-pipe mask for a specific auid.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_preselect_get
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|au_id_t
name|auid
parameter_list|,
name|au_mask_t
modifier|*
name|maskp
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|;
name|int
name|error
decl_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|app
operator|=
name|audit_pipe_preselect_find
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|!=
name|NULL
condition|)
block|{
operator|*
name|maskp
operator|=
name|app
operator|->
name|app_mask
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the per-pipe mask for a specific auid.  Add a new entry if needed;  * otherwise, update the current entry.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_preselect_set
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|au_id_t
name|auid
parameter_list|,
name|au_mask_t
name|mask
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|,
modifier|*
name|app_new
decl_stmt|;
comment|/* 	 * Pessimistically assume that the auid doesn't already have a mask 	 * set, and allocate.  We will free it if it is unneeded. 	 */
name|app_new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|app_new
argument_list|)
argument_list|,
name|M_AUDIT_PIPE_PRESELECT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|app
operator|=
name|audit_pipe_preselect_find
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|==
name|NULL
condition|)
block|{
name|app
operator|=
name|app_new
expr_stmt|;
name|app_new
operator|=
name|NULL
expr_stmt|;
name|app
operator|->
name|app_auid
operator|=
name|auid
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_list
argument_list|,
name|app
argument_list|,
name|app_list
argument_list|)
expr_stmt|;
block|}
name|app
operator|->
name|app_mask
operator|=
name|mask
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|app_new
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|app_new
argument_list|,
name|M_AUDIT_PIPE_PRESELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a per-auid mask on an audit pipe.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_preselect_delete
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|au_id_t
name|auid
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|;
name|int
name|error
decl_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|app
operator|=
name|audit_pipe_preselect_find
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_list
argument_list|,
name|app
argument_list|,
name|app_list
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|app
argument_list|,
name|M_AUDIT_PIPE_PRESELECT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all per-auid masks on an audit pipe.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_preselect_flush_locked
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|app
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_list
argument_list|,
name|app
argument_list|,
name|app_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|app
argument_list|,
name|M_AUDIT_PIPE_PRESELECT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|audit_pipe_preselect_flush
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|audit_pipe_preselect_flush_locked
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Determine whether a specific audit pipe matches a record with these  * properties.  Algorithm is as follows:  *  * - If the pipe is configured to track the default trail configuration, then  *   use the results of global preselection matching.  * - If not, search for a specifically configured auid entry matching the  *   event.  If an entry is found, use that.  * - Otherwise, use the default flags or naflags configured for the pipe.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_preselect_check
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|,
name|int
name|sorf
parameter_list|,
name|int
name|trail_preselect
parameter_list|)
block|{
name|struct
name|audit_pipe_preselect
modifier|*
name|app
decl_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|ap_preselect_mode
condition|)
block|{
case|case
name|AUDITPIPE_PRESELECT_MODE_TRAIL
case|:
return|return
operator|(
name|trail_preselect
operator|)
return|;
case|case
name|AUDITPIPE_PRESELECT_MODE_LOCAL
case|:
name|app
operator|=
name|audit_pipe_preselect_find
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|auid
operator|==
name|AU_DEFAUDITID
condition|)
return|return
operator|(
name|au_preselect
argument_list|(
name|event
argument_list|,
name|class
argument_list|,
operator|&
name|ap
operator|->
name|ap_preselect_naflags
argument_list|,
name|sorf
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|au_preselect
argument_list|(
name|event
argument_list|,
name|class
argument_list|,
operator|&
name|ap
operator|->
name|ap_preselect_flags
argument_list|,
name|sorf
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|au_preselect
argument_list|(
name|event
argument_list|,
name|class
argument_list|,
operator|&
name|app
operator|->
name|app_mask
argument_list|,
name|sorf
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"audit_pipe_preselect_check: mode %d"
argument_list|,
name|ap
operator|->
name|ap_preselect_mode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether there exists a pipe interested in a record with specific  * properties.  */
end_comment

begin_function
name|int
name|audit_pipe_preselect
parameter_list|(
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|,
name|int
name|sorf
parameter_list|,
name|int
name|trail_preselect
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|AUDIT_PIPE_LIST_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ap
argument_list|,
argument|&audit_pipe_list
argument_list|,
argument|ap_list
argument_list|)
block|{
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_pipe_preselect_check
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
name|trail_preselect
argument_list|)
condition|)
block|{
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LIST_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|AUDIT_PIPE_LIST_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append individual record to a queue -- allocate queue-local buffer, and  * add to the queue.  If the queue is full or we can't allocate memory, drop  * the newest record.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_append
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|,
name|void
modifier|*
name|record
parameter_list|,
name|u_int
name|record_len
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_qlen
operator|>=
name|ap
operator|->
name|ap_qlimit
condition|)
block|{
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
return|return;
block|}
name|ape
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ape
argument_list|)
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|==
name|NULL
condition|)
block|{
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
return|return;
block|}
name|ape
operator|->
name|ape_record
operator|=
name|malloc
argument_list|(
name|record_len
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|->
name|ape_record
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ape
argument_list|,
name|M_AUDIT_PIPE_ENTRY
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_drops
operator|++
expr_stmt|;
name|audit_pipe_drops
operator|++
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|record
argument_list|,
name|ape
operator|->
name|ape_record
argument_list|,
name|record_len
argument_list|)
expr_stmt|;
name|ape
operator|->
name|ape_record_len
operator|=
name|record_len
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_inserts
operator|++
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|++
expr_stmt|;
name|ap
operator|->
name|ap_qbyteslen
operator|+=
name|ape
operator|->
name|ape_record_len
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_flags
operator|&
name|AUDIT_PIPE_ASYNC
condition|)
name|pgsigio
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ap
operator|->
name|ap_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_pipe_submit(): audit_worker submits audit records via this  * interface, which arranges for them to be delivered to pipe queues.  */
end_comment

begin_function
name|void
name|audit_pipe_submit
parameter_list|(
name|au_id_t
name|auid
parameter_list|,
name|au_event_t
name|event
parameter_list|,
name|au_class_t
name|class
parameter_list|,
name|int
name|sorf
parameter_list|,
name|int
name|trail_select
parameter_list|,
name|void
modifier|*
name|record
parameter_list|,
name|u_int
name|record_len
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
comment|/* 	 * Lockless read to avoid lock overhead if pipes are not in use. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_pipe_list
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|AUDIT_PIPE_LIST_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ap
argument_list|,
argument|&audit_pipe_list
argument_list|,
argument|ap_list
argument_list|)
block|{
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_pipe_preselect_check
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
name|trail_select
argument_list|)
condition|)
name|audit_pipe_append
argument_list|(
name|ap
argument_list|,
name|record
argument_list|,
name|record_len
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|AUDIT_PIPE_LIST_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* Unlocked increment. */
name|audit_pipe_records
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_pipe_submit_user(): the same as audit_pipe_submit(), except that  * since we don't currently have selection information available, it is  * delivered to the pipe unconditionally.  *  * XXXRW: This is a bug.  The BSM check routine for submitting a user record  * should parse that information and return it.  */
end_comment

begin_function
name|void
name|audit_pipe_submit_user
parameter_list|(
name|void
modifier|*
name|record
parameter_list|,
name|u_int
name|record_len
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
comment|/* 	 * Lockless read to avoid lock overhead if pipes are not in use. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_pipe_list
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|AUDIT_PIPE_LIST_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ap
argument_list|,
argument|&audit_pipe_list
argument_list|,
argument|ap_list
argument_list|)
block|{
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|audit_pipe_append
argument_list|(
name|ap
argument_list|,
name|record
argument_list|,
name|record_len
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|AUDIT_PIPE_LIST_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* Unlocked increment. */
name|audit_pipe_records
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new audit pipe.  Connects the pipe, on success, to the global  * list and updates statistics.  */
end_comment

begin_function
specifier|static
name|struct
name|audit_pipe
modifier|*
name|audit_pipe_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|AUDIT_PIPE_LIST_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|ap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|,
name|M_AUDIT_PIPE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ap
operator|->
name|ap_qlimit
operator|=
name|AUDIT_PIPE_QLIMIT_DEFAULT
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
operator|.
name|si_note
argument_list|,
name|AUDIT_PIPE_MTX
argument_list|(
name|ap
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LOCK_INIT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_LOCK_INIT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|ap
operator|->
name|ap_cv
argument_list|,
literal|"audit_pipe"
argument_list|)
expr_stmt|;
comment|/* 	 * Default flags, naflags, and auid-specific preselection settings to 	 * 0.  Initialize the mode to the global trail so that if praudit(1) 	 * is run on /dev/auditpipe, it sees events associated with the 	 * default trail.  Pipe-aware application can clear the flag, set 	 * custom masks, and flush the pipe as needed. 	 */
name|bzero
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|ap_preselect_flags
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_naflags
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|ap_preselect_naflags
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ap
operator|->
name|ap_preselect_list
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_preselect_mode
operator|=
name|AUDITPIPE_PRESELECT_MODE_TRAIL
expr_stmt|;
comment|/* 	 * Add to global list and update global statistics. 	 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|audit_pipe_list
argument_list|,
name|ap
argument_list|,
name|ap_list
argument_list|)
expr_stmt|;
name|audit_pipe_count
operator|++
expr_stmt|;
name|audit_pipe_ever
operator|++
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all records currently present in an audit pipe; assume mutex is held.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_flush
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ape
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qbyteslen
operator|-=
name|ape
operator|->
name|ape_record_len
expr_stmt|;
name|audit_pipe_entry_free
argument_list|(
name|ape
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|--
expr_stmt|;
block|}
name|ap
operator|->
name|ap_qoffset
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_qlen
operator|==
literal|0
argument_list|,
operator|(
literal|"audit_pipe_free: ap_qbyteslen"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_qbyteslen
operator|==
literal|0
argument_list|,
operator|(
literal|"audit_pipe_flush: ap_qbyteslen"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an audit pipe; this means freeing all preselection state and all  * records in the pipe.  Assumes global write lock and pipe mutex are held to  * prevent any new records from being inserted during the free, and that the  * audit pipe is still on the global list.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_free
parameter_list|(
name|struct
name|audit_pipe
modifier|*
name|ap
parameter_list|)
block|{
name|AUDIT_PIPE_LIST_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|audit_pipe_preselect_flush_locked
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|audit_pipe_flush
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ap
operator|->
name|ap_cv
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_LOCK_DESTROY
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LOCK_DESTROY
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|audit_pipe_list
argument_list|,
name|ap
argument_list|,
name|ap_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|,
name|M_AUDIT_PIPE
argument_list|)
expr_stmt|;
name|audit_pipe_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe clone routine -- provide specific requested audit pipe, or a  * fresh one if a specific one is not requested.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|)
operator|==
literal|0
condition|)
name|u
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|,
operator|&
name|u
argument_list|)
operator|!=
literal|1
condition|)
return|return;
name|i
operator|=
name|clone_create
argument_list|(
operator|&
name|audit_pipe_clones
argument_list|,
operator|&
name|audit_pipe_cdevsw
argument_list|,
operator|&
name|u
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|audit_pipe_cdevsw
argument_list|,
name|u
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s%d"
argument_list|,
name|AUDIT_PIPE_NAME
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
block|{
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|si_flags
operator||=
name|SI_CHEAPCLONE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Audit pipe open method.  Explicit privilege check isn't used as this  * allows file permissions on the special device to be used to grant audit  * review access.  Those file permissions should be managed carefully.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|AUDIT_PIPE_LIST_WLOCK
argument_list|()
expr_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
name|ap
operator|=
name|audit_pipe_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
name|AUDIT_PIPE_LIST_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dev
operator|->
name|si_drv1
operator|=
name|ap
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_open
argument_list|,
operator|(
literal|"audit_pipe_open: ap&& !ap_open"
operator|)
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LIST_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ap
operator|->
name|ap_open
operator|=
literal|1
expr_stmt|;
comment|/* No lock required yet. */
name|AUDIT_PIPE_LIST_WUNLOCK
argument_list|()
expr_stmt|;
name|fsetown
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close audit pipe, tear down all records, etc.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_close: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|ap_open
argument_list|,
operator|(
literal|"audit_pipe_close: !ap_open"
operator|)
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LIST_WLOCK
argument_list|()
expr_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_open
operator|=
literal|0
expr_stmt|;
name|audit_pipe_free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|AUDIT_PIPE_LIST_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe ioctl() routine.  Handle file descriptor and audit pipe layer  * commands.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|auditpipe_ioctl_preselect
modifier|*
name|aip
decl_stmt|;
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|au_mask_t
modifier|*
name|maskp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mode
decl_stmt|;
name|au_id_t
name|auid
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_ioctl: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Audit pipe ioctls: first come standard device node ioctls, then 	 * manipulation of pipe settings, and finally, statistics query 	 * ioctls. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|ap
operator|->
name|ap_flags
operator||=
name|AUDIT_PIPE_NBIO
expr_stmt|;
else|else
name|ap
operator|->
name|ap_flags
operator|&=
operator|~
name|AUDIT_PIPE_NBIO
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIONREAD
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_qbyteslen
operator|-
name|ap
operator|->
name|ap_qoffset
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|ap
operator|->
name|ap_flags
operator||=
name|AUDIT_PIPE_ASYNC
expr_stmt|;
else|else
name|ap
operator|->
name|ap_flags
operator|&=
operator|~
name|AUDIT_PIPE_ASYNC
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|ap
operator|->
name|ap_sigio
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_qlen
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_qlimit
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_QLIMIT
case|:
comment|/* Lockless integer write. */
if|if
condition|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|>=
name|AUDIT_PIPE_QLIMIT_MIN
operator|||
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|<=
name|AUDIT_PIPE_QLIMIT_MAX
condition|)
block|{
name|ap
operator|->
name|ap_qlimit
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT_MIN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|AUDIT_PIPE_QLIMIT_MIN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_QLIMIT_MAX
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|AUDIT_PIPE_QLIMIT_MAX
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_PRESELECT_FLAGS
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|maskp
operator|=
operator|(
name|au_mask_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|maskp
operator|=
name|ap
operator|->
name|ap_preselect_flags
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_PRESELECT_FLAGS
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|maskp
operator|=
operator|(
name|au_mask_t
operator|*
operator|)
name|data
expr_stmt|;
name|ap
operator|->
name|ap_preselect_flags
operator|=
operator|*
name|maskp
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_PRESELECT_NAFLAGS
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|maskp
operator|=
operator|(
name|au_mask_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|maskp
operator|=
name|ap
operator|->
name|ap_preselect_naflags
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_PRESELECT_NAFLAGS
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|maskp
operator|=
operator|(
name|au_mask_t
operator|*
operator|)
name|data
expr_stmt|;
name|ap
operator|->
name|ap_preselect_naflags
operator|=
operator|*
name|maskp
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_PRESELECT_AUID
case|:
name|aip
operator|=
operator|(
expr|struct
name|auditpipe_ioctl_preselect
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|audit_pipe_preselect_get
argument_list|(
name|ap
argument_list|,
name|aip
operator|->
name|aip_auid
argument_list|,
operator|&
name|aip
operator|->
name|aip_mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_PRESELECT_AUID
case|:
name|aip
operator|=
operator|(
expr|struct
name|auditpipe_ioctl_preselect
operator|*
operator|)
name|data
expr_stmt|;
name|audit_pipe_preselect_set
argument_list|(
name|ap
argument_list|,
name|aip
operator|->
name|aip_auid
argument_list|,
name|aip
operator|->
name|aip_mask
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_DELETE_PRESELECT_AUID
case|:
name|auid
operator|=
operator|*
operator|(
name|au_id_t
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|audit_pipe_preselect_delete
argument_list|(
name|ap
argument_list|,
name|auid
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_FLUSH_PRESELECT_AUID
case|:
name|audit_pipe_preselect_flush
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_PRESELECT_MODE
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_preselect_mode
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_SET_PRESELECT_MODE
case|:
name|mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|AUDITPIPE_PRESELECT_MODE_TRAIL
case|:
case|case
name|AUDITPIPE_PRESELECT_MODE_LOCAL
case|:
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_preselect_mode
operator|=
name|mode
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|AUDITPIPE_FLUSH
case|:
if|if
condition|(
name|AUDIT_PIPE_SX_XLOCK_SIG
argument_list|(
name|ap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|audit_pipe_flush
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_XUNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_MAXAUDITDATA
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|MAXAUDITDATA
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_INSERTS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_inserts
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_READS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_reads
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_DROPS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|ap
operator|->
name|ap_drops
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AUDITPIPE_GET_TRUNCATES
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe read.  Read one or more partial or complete records to user  * memory.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|u_int
name|toread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_read: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We hold an sx(9) lock over read and flush because we rely on the 	 * stability of a record in the queue during uiomove(9). 	 */
if|if
condition|(
name|AUDIT_PIPE_SX_XLOCK_SIG
argument_list|(
name|ap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|ap_flags
operator|&
name|AUDIT_PIPE_NBIO
condition|)
block|{
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_XUNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|ap
operator|->
name|ap_cv
argument_list|,
name|AUDIT_PIPE_MTX
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_XUNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Copy as many remaining bytes from the current record to userspace 	 * as we can.  Keep processing records until we run out of records in 	 * the queue, or until the user buffer runs out of space. 	 * 	 * Note: we rely on the SX lock to maintain ape's stability here. 	 */
name|ap
operator|->
name|ap_reads
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|ape
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ape
operator|->
name|ape_record_len
operator|>
name|ap
operator|->
name|ap_qoffset
argument_list|,
operator|(
literal|"audit_pipe_read: record_len> qoffset (1)"
operator|)
argument_list|)
expr_stmt|;
name|toread
operator|=
name|MIN
argument_list|(
name|ape
operator|->
name|ape_record_len
operator|-
name|ap
operator|->
name|ap_qoffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ape
operator|->
name|ape_record
operator|+
name|ap
operator|->
name|ap_qoffset
argument_list|,
name|toread
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|AUDIT_PIPE_SX_XUNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * If the copy succeeded, update book-keeping, and if no 		 * bytes remain in the current record, free it. 		 */
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|==
name|ape
argument_list|,
operator|(
literal|"audit_pipe_read: queue out of sync after uiomove"
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qoffset
operator|+=
name|toread
expr_stmt|;
name|KASSERT
argument_list|(
name|ape
operator|->
name|ape_record_len
operator|>=
name|ap
operator|->
name|ap_qoffset
argument_list|,
operator|(
literal|"audit_pipe_read: record_len>= qoffset (2)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_qoffset
operator|==
name|ape
operator|->
name|ape_record_len
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|,
name|ape
argument_list|,
name|ape_queue
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qbyteslen
operator|-=
name|ape
operator|->
name|ape_record_len
expr_stmt|;
name|audit_pipe_entry_free
argument_list|(
name|ape
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_qlen
operator|--
expr_stmt|;
name|ap
operator|->
name|ap_qoffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_SX_XUNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe poll.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_poll: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
operator|!=
name|NULL
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|ap
operator|->
name|ap_selinfo
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Audit pipe kqfilter.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_kqfilter: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|!=
name|EVFILT_READ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|audit_pipe_read_filterops
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|ap
expr_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if there are records available for reading on the pipe.  */
end_comment

begin_function
specifier|static
name|int
name|audit_pipe_kqread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|audit_pipe_entry
modifier|*
name|ape
decl_stmt|;
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|audit_pipe
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_kqread: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LOCK_ASSERT
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_qlen
operator|!=
literal|0
condition|)
block|{
name|ape
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ap
operator|->
name|ap_queue
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ape
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_kqread: ape == NULL"
operator|)
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|ap
operator|->
name|ap_qbyteslen
operator|-
name|ap
operator|->
name|ap_qoffset
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Detach kqueue state from audit pipe.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|audit_pipe
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|audit_pipe
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_pipe_kqdetach: ap == NULL"
operator|)
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|ap
operator|->
name|ap_selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_UNLOCK
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the audit pipe system.  */
end_comment

begin_function
specifier|static
name|void
name|audit_pipe_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|audit_pipe_list
argument_list|)
expr_stmt|;
name|AUDIT_PIPE_LIST_LOCK_INIT
argument_list|()
expr_stmt|;
name|clone_setup
argument_list|(
operator|&
name|audit_pipe_clones
argument_list|)
expr_stmt|;
name|audit_pipe_eh_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|audit_pipe_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_pipe_eh_tag
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"audit_pipe_init: EVENTHANDLER_REGISTER"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|audit_pipe_init
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|audit_pipe_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

