begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2005 Apple Inc.  * Copyright (c) 2006-2007 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_internal.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_kevents.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|static
name|uma_zone_t
name|audit_record_zone
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITCRED
argument_list|,
literal|"audit_cred"
argument_list|,
literal|"Audit cred storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITDATA
argument_list|,
literal|"audit_data"
argument_list|,
literal|"Audit data storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITPATH
argument_list|,
literal|"audit_path"
argument_list|,
literal|"Audit path storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITTEXT
argument_list|,
literal|"audit_text"
argument_list|,
literal|"Audit text storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_security
argument_list|,
name|OID_AUTO
argument_list|,
name|audit
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TrustedBSD audit controls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Audit control settings that are set/read by system calls and are hence  * non-static.  *  * Define the audit control flags.  */
end_comment

begin_decl_stmt
name|int
name|audit_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_suspended
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags controlling behavior in low storage situations.  Should we panic if  * a write fails?  Should we fail stop if we're out of disk space?  */
end_comment

begin_decl_stmt
name|int
name|audit_panic_on_write_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_fail_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_arge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Are we currently "failing stop" due to out of disk space?  */
end_comment

begin_decl_stmt
name|int
name|audit_in_failure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global audit statistics.  */
end_comment

begin_decl_stmt
name|struct
name|audit_fstat
name|audit_fstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Preselection mask for non-attributable events.  */
end_comment

begin_decl_stmt
name|struct
name|au_mask
name|audit_nae_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mutex to protect global variables shared between various threads and  * processes.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|audit_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Queue of audit records ready for delivery to disk.  We insert new records  * at the tail, and remove records from the head.  Also, a count of the  * number of records used for checking queue depth.  In addition, a counter  * of records that we have allocated but are not yet in the queue, which is  * needed to estimate the total size of the combined set of records  * outstanding in the system.  */
end_comment

begin_decl_stmt
name|struct
name|kaudit_queue
name|audit_q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|audit_q_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|audit_pre_q_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Audit queue control settings (minimum free, low/high water marks, etc.)  */
end_comment

begin_decl_stmt
name|struct
name|au_qctrl
name|audit_qctrl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Condition variable to signal to the worker that it has work to do: either  * new records are in the queue, or a log replacement is taking place.  */
end_comment

begin_decl_stmt
name|struct
name|cv
name|audit_worker_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Condition variable to flag when crossing the low watermark, meaning that  * threads blocked due to hitting the high watermark can wake up and continue  * to commit records.  */
end_comment

begin_decl_stmt
name|struct
name|cv
name|audit_watermark_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Condition variable for  auditing threads wait on when in fail-stop mode.  * Threads wait on this CV forever (and ever), never seeing the light of day  * again.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_fail_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel audit information.  This will store the current audit address  * or host information that the kernel will use when it's generating  * audit records.  This data is modified by the A_GET{SET}KAUDIT auditon(2)  * command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|auditinfo_addr
name|audit_kinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|audit_kinfo_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KINFO_LOCK_INIT
parameter_list|()
value|rw_init(&audit_kinfo_lock, \ 				    "audit_kinfo_lock")
end_define

begin_define
define|#
directive|define
name|KINFO_RLOCK
parameter_list|()
value|rw_rlock(&audit_kinfo_lock)
end_define

begin_define
define|#
directive|define
name|KINFO_WLOCK
parameter_list|()
value|rw_wlock(&audit_kinfo_lock)
end_define

begin_define
define|#
directive|define
name|KINFO_RUNLOCK
parameter_list|()
value|rw_runlock(&audit_kinfo_lock)
end_define

begin_define
define|#
directive|define
name|KINFO_WUNLOCK
parameter_list|()
value|rw_wunlock(&audit_kinfo_lock)
end_define

begin_function
name|void
name|audit_set_kinfo
parameter_list|(
name|struct
name|auditinfo_addr
modifier|*
name|ak
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ak
operator|->
name|ai_termid
operator|.
name|at_type
operator|==
name|AU_IPv4
operator|||
name|ak
operator|->
name|ai_termid
operator|.
name|at_type
operator|==
name|AU_IPv6
argument_list|,
operator|(
literal|"audit_set_kinfo: invalid address type"
operator|)
argument_list|)
expr_stmt|;
name|KINFO_WLOCK
argument_list|()
expr_stmt|;
name|audit_kinfo
operator|=
operator|*
name|ak
expr_stmt|;
name|KINFO_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_get_kinfo
parameter_list|(
name|struct
name|auditinfo_addr
modifier|*
name|ak
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|audit_kinfo
operator|.
name|ai_termid
operator|.
name|at_type
operator|==
name|AU_IPv4
operator|||
name|audit_kinfo
operator|.
name|ai_termid
operator|.
name|at_type
operator|==
name|AU_IPv6
argument_list|,
operator|(
literal|"audit_set_kinfo: invalid address type"
operator|)
argument_list|)
expr_stmt|;
name|KINFO_RLOCK
argument_list|()
expr_stmt|;
operator|*
name|ak
operator|=
name|audit_kinfo
expr_stmt|;
name|KINFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an audit record for the passed thread.  */
end_comment

begin_function
specifier|static
name|int
name|audit_record_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
operator|==
name|size
argument_list|,
operator|(
literal|"audit_record_ctor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|arg
expr_stmt|;
name|ar
operator|=
name|mem
expr_stmt|;
name|bzero
argument_list|(
name|ar
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_magic
operator|=
name|AUDIT_RECORD_MAGIC
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_starttime
argument_list|)
expr_stmt|;
comment|/* 	 * Export the subject credential. 	 */
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|cru2x
argument_list|(
name|cred
argument_list|,
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_cred
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_ruid
operator|=
name|cred
operator|->
name|cr_ruid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_rgid
operator|=
name|cred
operator|->
name|cr_rgid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_egid
operator|=
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
operator|=
name|cred
operator|->
name|cr_audit
operator|.
name|ai_auid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_asid
operator|=
name|cred
operator|->
name|cr_audit
operator|.
name|ai_asid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_amask
operator|=
name|cred
operator|->
name|cr_audit
operator|.
name|ai_mask
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_term_addr
operator|=
name|cred
operator|->
name|cr_audit
operator|.
name|ai_termid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|audit_record_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
operator|==
name|size
argument_list|,
operator|(
literal|"audit_record_dtor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|ar
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath1
argument_list|,
name|M_AUDITPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath2
argument_list|,
name|M_AUDITPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_text
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_text
argument_list|,
name|M_AUDITTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_udata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_udata
argument_list|,
name|M_AUDITDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_argv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_argv
argument_list|,
name|M_AUDITTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_envv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_envv
argument_list|,
name|M_AUDITTEXT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the Audit subsystem: configuration state, work queue,  * synchronization primitives, worker thread, and trigger device node.  Also  * call into the BSM assembly code to initialize it.  */
end_comment

begin_function
specifier|static
name|void
name|audit_init
parameter_list|(
name|void
parameter_list|)
block|{
name|audit_enabled
operator|=
literal|0
expr_stmt|;
name|audit_suspended
operator|=
literal|0
expr_stmt|;
name|audit_panic_on_write_fail
operator|=
literal|0
expr_stmt|;
name|audit_fail_stop
operator|=
literal|0
expr_stmt|;
name|audit_in_failure
operator|=
literal|0
expr_stmt|;
name|audit_argv
operator|=
literal|0
expr_stmt|;
name|audit_arge
operator|=
literal|0
expr_stmt|;
name|audit_fstat
operator|.
name|af_filesz
operator|=
literal|0
expr_stmt|;
comment|/* '0' means unset, unbounded. */
name|audit_fstat
operator|.
name|af_currsz
operator|=
literal|0
expr_stmt|;
name|audit_nae_mask
operator|.
name|am_success
operator|=
literal|0
expr_stmt|;
name|audit_nae_mask
operator|.
name|am_failure
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|audit_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|=
literal|0
expr_stmt|;
name|audit_pre_q_len
operator|=
literal|0
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_hiwater
operator|=
name|AQ_HIWATER
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_lowater
operator|=
name|AQ_LOWATER
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_bufsz
operator|=
name|AQ_BUFSZ
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_minfree
operator|=
name|AU_FS_MINFREE
expr_stmt|;
name|audit_kinfo
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
name|audit_kinfo
operator|.
name|ai_termid
operator|.
name|at_addr
index|[
literal|0
index|]
operator|=
name|INADDR_ANY
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|audit_mtx
argument_list|,
literal|"audit_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|KINFO_LOCK_INIT
argument_list|()
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_worker_cv
argument_list|,
literal|"audit_worker_cv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_watermark_cv
argument_list|,
literal|"audit_watermark_cv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_fail_cv
argument_list|,
literal|"audit_fail_cv"
argument_list|)
expr_stmt|;
name|audit_record_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"audit_record"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kaudit_record
argument_list|)
argument_list|,
name|audit_record_ctor
argument_list|,
name|audit_record_dtor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the BSM audit subsystem. */
name|kau_init
argument_list|()
expr_stmt|;
name|audit_trigger_init
argument_list|()
expr_stmt|;
comment|/* Register shutdown handler. */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|audit_shutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* Start audit worker thread. */
name|audit_worker_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|audit_init
argument_list|,
name|SI_SUB_AUDIT
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|audit_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Drain the audit queue and close the log at shutdown.  Note that this can  * be called both from the system shutdown path and also from audit  * configuration syscalls, so 'arg' and 'howto' are ignored.  *  * XXXRW: In FreeBSD 7.x and 8.x, this fails to wait for the record queue to  * drain before returning, which could lead to lost records on shutdown.  */
end_comment

begin_function
name|void
name|audit_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|audit_rotate_vnode
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current thread's audit record, if any.  */
end_comment

begin_function
name|struct
name|kaudit_record
modifier|*
name|currecord
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|curthread
operator|->
name|td_ar
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXAUDIT: There are a number of races present in the code below due to  * release and re-grab of the mutex.  The code should be revised to become  * slightly less racy.  *  * XXXAUDIT: Shouldn't there be logic here to sleep waiting on available  * pre_q space, suspending the system call until there is room?  */
end_comment

begin_function
name|struct
name|kaudit_record
modifier|*
name|audit_new
parameter_list|(
name|int
name|event
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|int
name|no_record
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|no_record
operator|=
operator|(
name|audit_suspended
operator|||
operator|!
name|audit_enabled
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_record
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Note: the number of outstanding uncommitted audit records is 	 * limited to the number of concurrent threads servicing system calls 	 * in the kernel. 	 */
name|ar
operator|=
name|uma_zalloc_arg
argument_list|(
name|audit_record_zone
argument_list|,
name|td
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|event
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_pre_q_len
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ar
operator|)
return|;
block|}
end_function

begin_function
name|void
name|audit_free
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|ar
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|audit_record_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_commit
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|ar
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|retval
parameter_list|)
block|{
name|au_event_t
name|event
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|au_id_t
name|auid
decl_stmt|;
name|int
name|sorf
decl_stmt|;
name|struct
name|au_mask
modifier|*
name|aumask
decl_stmt|;
if|if
condition|(
name|ar
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Decide whether to commit the audit record by checking the error 	 * value from the system call and using the appropriate audit mask. 	 */
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
operator|==
name|AU_DEFAUDITID
condition|)
name|aumask
operator|=
operator|&
name|audit_nae_mask
expr_stmt|;
else|else
name|aumask
operator|=
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_amask
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|sorf
operator|=
name|AU_PRS_FAILURE
expr_stmt|;
else|else
name|sorf
operator|=
name|AU_PRS_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
condition|)
block|{
case|case
name|AUE_OPEN_RWTC
case|:
comment|/* 		 * The open syscall always writes a AUE_OPEN_RWTC event; 		 * change it to the proper type of event based on the flags 		 * and the error value. 		 */
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|audit_flags_and_error_to_openevent
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_fflags
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUE_SYSCTL
case|:
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|audit_ctlname_to_sysctlevent
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_ctlname
argument_list|,
name|ar
operator|->
name|k_ar
operator|.
name|ar_valid_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUE_AUDITON
case|:
comment|/* Convert the auditon() command to an event. */
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|auditon_command_event
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|auid
operator|=
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
expr_stmt|;
name|event
operator|=
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
expr_stmt|;
name|class
operator|=
name|au_event_class
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar_commit
operator||=
name|AR_COMMIT_KERNEL
expr_stmt|;
if|if
condition|(
name|au_preselect
argument_list|(
name|event
argument_list|,
name|class
argument_list|,
name|aumask
argument_list|,
name|sorf
argument_list|)
operator|!=
literal|0
condition|)
name|ar
operator|->
name|k_ar_commit
operator||=
name|AR_PRESELECT_TRAIL
expr_stmt|;
if|if
condition|(
name|audit_pipe_preselect
argument_list|(
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_PRESELECT_TRAIL
argument_list|)
operator|!=
literal|0
condition|)
name|ar
operator|->
name|k_ar_commit
operator||=
name|AR_PRESELECT_PIPE
expr_stmt|;
if|if
condition|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
operator|(
name|AR_PRESELECT_TRAIL
operator||
name|AR_PRESELECT_PIPE
operator||
name|AR_PRESELECT_USER_TRAIL
operator||
name|AR_PRESELECT_USER_PIPE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_pre_q_len
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return;
block|}
name|ar
operator|->
name|k_ar
operator|.
name|ar_errno
operator|=
name|error
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_retval
operator|=
name|retval
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_endtime
argument_list|)
expr_stmt|;
comment|/* 	 * Note: it could be that some records initiated while audit was 	 * enabled should still be committed? 	 */
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_suspended
operator|||
operator|!
name|audit_enabled
condition|)
block|{
name|audit_pre_q_len
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Constrain the number of committed audit records based on the 	 * configurable parameter. 	 */
while|while
condition|(
name|audit_q_len
operator|>=
name|audit_qctrl
operator|.
name|aq_hiwater
condition|)
name|cv_wait
argument_list|(
operator|&
name|audit_watermark_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|audit_q
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|++
expr_stmt|;
name|audit_pre_q_len
operator|--
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|audit_worker_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_syscall_enter() is called on entry to each system call.  It is  * responsible for deciding whether or not to audit the call (preselection),  * and if so, allocating a per-thread audit record.  audit_new() will fill in  * basic thread/credential properties.  */
end_comment

begin_function
name|void
name|audit_syscall_enter
parameter_list|(
name|unsigned
name|short
name|code
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|au_mask
modifier|*
name|aumask
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|au_event_t
name|event
decl_stmt|;
name|au_id_t
name|auid
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_ar
operator|==
name|NULL
argument_list|,
operator|(
literal|"audit_syscall_enter: td->td_ar != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_AUDITREC
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"audit_syscall_enter: TDP_AUDITREC set"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * In FreeBSD, each ABI has its own system call table, and hence 	 * mapping of system call codes to audit events.  Convert the code to 	 * an audit event identifier using the process system call table 	 * reference.  In Darwin, there's only one, so we use the global 	 * symbol for the system call table.  No audit record is generated 	 * for bad system calls, as no operation has been performed. 	 */
if|if
condition|(
name|code
operator|>=
name|td
operator|->
name|td_proc
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
return|return;
name|event
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
operator|.
name|sy_auevent
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|AUE_NULL
condition|)
return|return;
comment|/* 	 * Check which audit mask to use; either the kernel non-attributable 	 * event mask or the process audit mask. 	 */
name|auid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_audit
operator|.
name|ai_auid
expr_stmt|;
if|if
condition|(
name|auid
operator|==
name|AU_DEFAUDITID
condition|)
name|aumask
operator|=
operator|&
name|audit_nae_mask
expr_stmt|;
else|else
name|aumask
operator|=
operator|&
name|td
operator|->
name|td_ucred
operator|->
name|cr_audit
operator|.
name|ai_mask
expr_stmt|;
comment|/* 	 * Allocate an audit record, if preselection allows it, and store in 	 * the thread for later use. 	 */
name|class
operator|=
name|au_event_class
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_preselect
argument_list|(
name|event
argument_list|,
name|class
argument_list|,
name|aumask
argument_list|,
name|AU_PRS_BOTH
argument_list|)
condition|)
block|{
comment|/* 		 * If we're out of space and need to suspend unprivileged 		 * processes, do that here rather than trying to allocate 		 * another audit record. 		 * 		 * Note: we might wish to be able to continue here in the 		 * future, if the system recovers.  That should be possible 		 * by means of checking the condition in a loop around 		 * cv_wait().  It might be desirable to reevaluate whether an 		 * audit record is still required for this event by 		 * re-calling au_preselect(). 		 */
if|if
condition|(
name|audit_in_failure
operator|&&
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_AUDIT_FAILSTOP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|audit_fail_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"audit_failing_stop: thread continued"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_ar
operator|=
name|audit_new
argument_list|(
name|event
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ar
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_pflags
operator||=
name|TDP_AUDITREC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|audit_pipe_preselect
argument_list|(
name|auid
argument_list|,
name|event
argument_list|,
name|class
argument_list|,
name|AU_PRS_BOTH
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_ar
operator|=
name|audit_new
argument_list|(
name|event
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ar
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_pflags
operator||=
name|TDP_AUDITREC
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_syscall_exit() is called from the return of every system call, or in  * the event of exit1(), during the execution of exit1().  It is responsible  * for committing the audit record, if any, along with return condition.  */
end_comment

begin_function
name|void
name|audit_syscall_exit
parameter_list|(
name|int
name|error
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* 	 * Commit the audit record as desired; once we pass the record into 	 * audit_commit(), the memory is owned by the audit subsystem.  The 	 * return value from the system call is stored on the user thread. 	 * If there was an error, the return value is set to -1, imitating 	 * the behavior of the cerror routine. 	 */
if|if
condition|(
name|error
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|audit_commit
argument_list|(
name|td
operator|->
name|td_ar
argument_list|,
name|error
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_AUDITREC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_cred_copy
parameter_list|(
name|struct
name|ucred
modifier|*
name|src
parameter_list|,
name|struct
name|ucred
modifier|*
name|dest
parameter_list|)
block|{
name|bcopy
argument_list|(
operator|&
name|src
operator|->
name|cr_audit
argument_list|,
operator|&
name|dest
operator|->
name|cr_audit
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
operator|->
name|cr_audit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_cred_destroy
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{  }
end_function

begin_function
name|void
name|audit_cred_init
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|cred
operator|->
name|cr_audit
argument_list|,
sizeof|sizeof
argument_list|(
name|cred
operator|->
name|cr_audit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize audit information for the first kernel process (proc 0) and for  * the first user process (init).  */
end_comment

begin_function
name|void
name|audit_cred_kproc0
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|cred
operator|->
name|cr_audit
operator|.
name|ai_auid
operator|=
name|AU_DEFAUDITID
expr_stmt|;
name|cred
operator|->
name|cr_audit
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_cred_proc1
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|cred
operator|->
name|cr_audit
operator|.
name|ai_auid
operator|=
name|AU_DEFAUDITID
expr_stmt|;
name|cred
operator|->
name|cr_audit
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_thread_alloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_thread_free
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|td
operator|->
name|td_ar
operator|==
name|NULL
argument_list|,
operator|(
literal|"audit_thread_free: td_ar != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_AUDITREC
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"audit_thread_free: TDP_AUDITREC set"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_proc_coredump
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|errcode
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|struct
name|au_mask
modifier|*
name|aumask
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|au_class_t
name|class
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sorf
decl_stmt|;
name|char
modifier|*
modifier|*
name|pathp
decl_stmt|;
name|au_id_t
name|auid
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure we are using the correct preselection mask. 	 */
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|auid
operator|=
name|cred
operator|->
name|cr_audit
operator|.
name|ai_auid
expr_stmt|;
if|if
condition|(
name|auid
operator|==
name|AU_DEFAUDITID
condition|)
name|aumask
operator|=
operator|&
name|audit_nae_mask
expr_stmt|;
else|else
name|aumask
operator|=
operator|&
name|cred
operator|->
name|cr_audit
operator|.
name|ai_mask
expr_stmt|;
comment|/* 	 * It's possible for coredump(9) generation to fail.  Make sure that 	 * we handle this case correctly for preselection. 	 */
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|sorf
operator|=
name|AU_PRS_FAILURE
expr_stmt|;
else|else
name|sorf
operator|=
name|AU_PRS_SUCCESS
expr_stmt|;
name|class
operator|=
name|au_event_class
argument_list|(
name|AUE_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_preselect
argument_list|(
name|AUE_CORE
argument_list|,
name|class
argument_list|,
name|aumask
argument_list|,
name|sorf
argument_list|)
operator|==
literal|0
operator|&&
name|audit_pipe_preselect
argument_list|(
name|auid
argument_list|,
name|AUE_CORE
argument_list|,
name|class
argument_list|,
name|sorf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If we are interested in seeing this audit record, allocate it. 	 * Where possible coredump records should contain a pathname and arg32 	 * (signal) tokens. 	 */
name|ar
operator|=
name|audit_new
argument_list|(
name|AUE_CORE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|pathp
operator|=
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath1
expr_stmt|;
operator|*
name|pathp
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|M_AUDITPATH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|audit_canon_path
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
operator|*
name|pathp
argument_list|)
expr_stmt|;
name|ARG_SET_VALID
argument_list|(
name|ar
argument_list|,
name|ARG_UPATH1
argument_list|)
expr_stmt|;
block|}
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_signum
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sig
expr_stmt|;
name|ARG_SET_VALID
argument_list|(
name|ar
argument_list|,
name|ARG_SIGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|audit_commit
argument_list|(
name|ar
argument_list|,
name|errcode
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

