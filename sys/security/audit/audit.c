begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2005 Apple Computer, Inc.  * Copyright (c) 2006 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_internal.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_kevents.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit_private.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * The AUDIT_EXCESSIVELY_VERBOSE define enables a number of  * gratuitously noisy printf's to the console.  Due to the  * volume, it should be left off unless you want your system  * to churn a lot whenever the audit record flow gets high.  */
end_comment

begin_comment
comment|//#define	AUDIT_EXCESSIVELY_VERBOSE
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIT_EXCESSIVELY_VERBOSE
end_ifdef

begin_define
define|#
directive|define
name|AUDIT_PRINTF
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AUDIT_PRINTF
parameter_list|(
name|X
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uma_zone_t
name|audit_record_zone
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITPROC
argument_list|,
literal|"audit_proc"
argument_list|,
literal|"Audit process storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITDATA
argument_list|,
literal|"audit_data"
argument_list|,
literal|"Audit data storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITPATH
argument_list|,
literal|"audit_path"
argument_list|,
literal|"Audit path storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUDITTEXT
argument_list|,
literal|"audit_text"
argument_list|,
literal|"Audit text storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Audit control settings that are set/read by system calls and are   * hence non-static.  */
end_comment

begin_comment
comment|/*   * Define the audit control flags.  */
end_comment

begin_decl_stmt
name|int
name|audit_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_suspended
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags controlling behavior in low storage situations.  * Should we panic if a write fails?  Should we fail stop  * if we're out of disk space?  */
end_comment

begin_decl_stmt
name|int
name|audit_panic_on_write_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|audit_fail_stop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Are we currently "failing stop" due to out of disk space?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audit_in_failure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global audit statistiscs.   */
end_comment

begin_decl_stmt
name|struct
name|audit_fstat
name|audit_fstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Preselection mask for non-attributable events.  */
end_comment

begin_decl_stmt
name|struct
name|au_mask
name|audit_nae_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mutex to protect global variables shared between various threads and  * processes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|audit_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Queue of audit records ready for delivery to disk.  We insert new  * records at the tail, and remove records from the head.  Also,  * a count of the number of records used for checking queue depth.  * In addition, a counter of records that we have allocated but are  * not yet in the queue, which is needed to estimate the total  * size of the combined set of records outstanding in the system.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaudit_record
argument_list|)
name|audit_q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|audit_q_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audit_pre_q_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Audit queue control settings (minimum free, low/high water marks, etc.)  */
end_comment

begin_decl_stmt
name|struct
name|au_qctrl
name|audit_qctrl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Condition variable to signal to the worker that it has work to do:  * either new records are in the queue, or a log replacement is taking  * place.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Worker thread that will schedule disk I/O, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|audit_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When an audit log is rotated, the actual rotation must be performed  * by the audit worker thread, as it may have outstanding writes on the  * current audit log.  audit_replacement_vp holds the vnode replacing  * the current vnode.  We can't let more than one replacement occur  * at a time, so if more than one thread requests a replacement, only  * one can have the replacement "in progress" at any given moment.  If  * a thread tries to replace the audit vnode and discovers a replacement  * is already in progress (i.e., audit_replacement_flag != 0), then it  * will sleep on audit_replacement_cv waiting its turn to perform a  * replacement.  When a replacement is completed, this cv is signalled  * by the worker thread so a waiting thread can start another replacement.  * We also store a credential to perform audit log write operations with.  *  * The current credential and vnode are thread-local to audit_worker.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_replacement_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|audit_replacement_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnode
modifier|*
name|audit_replacement_vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ucred
modifier|*
name|audit_replacement_cred
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Condition variable to signal to the worker that it has work to do:  * either new records are in the queue, or a log replacement is taking  * place.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_commit_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Condition variable for  auditing threads wait on when in fail-stop mode.   * Threads wait on this CV forever (and ever), never seeing the light of   * day again.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cv
name|audit_fail_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags related to Kernel->user-space communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audit_file_rotate_wait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Construct an audit record for the passed thread.  */
end_comment

begin_function
specifier|static
name|int
name|audit_record_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
operator|==
name|size
argument_list|,
operator|(
literal|"audit_record_ctor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|arg
expr_stmt|;
name|ar
operator|=
name|mem
expr_stmt|;
name|bzero
argument_list|(
name|ar
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_magic
operator|=
name|AUDIT_RECORD_MAGIC
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_starttime
argument_list|)
expr_stmt|;
comment|/* 	 * Export the subject credential. 	 * 	 * XXXAUDIT: td_ucred access is OK without proc lock, but some other 	 * fields here may require the proc lock. 	 */
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_cred
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_ruid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_rgid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_egid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_auid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_asid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_asid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_amask
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_mask
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_term
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_termid
expr_stmt|;
name|bcopy
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_comm
argument_list|,
name|MAXCOMLEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|audit_record_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
operator|==
name|size
argument_list|,
operator|(
literal|"audit_record_dtor: wrong size"
operator|)
argument_list|)
expr_stmt|;
name|ar
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath1
argument_list|,
name|M_AUDITPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_upath2
argument_list|,
name|M_AUDITPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_text
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_text
argument_list|,
name|M_AUDITTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|k_udata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|k_udata
argument_list|,
name|M_AUDITDATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXXAUDIT: Should adjust comments below to make it clear that we get to  * this point only if we believe we have storage, so not having space here  * is a violation of invariants derived from administrative procedures.  * I.e., someone else has written to the audit partition, leaving less space  * than we accounted for.  */
end_comment

begin_function
specifier|static
name|int
name|audit_record_write
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|kaudit_record
modifier|*
name|ar
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|struct
name|au_record
modifier|*
name|bsm
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|statfs
modifier|*
name|mnt_stat
init|=
operator|&
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
comment|/* 	 * First, gather statistics on the audit log file and file system 	 * so that we know how we're doing on space.  In both cases, 	 * if we're unable to perform the operation, we drop the record 	 * and return.  However, this is arguably an assertion failure. 	 * XXX Need a FreeBSD equivalent. 	 */
name|ret
operator|=
name|VFS_STATFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|mnt_stat
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
comment|/* update the global stats struct */
name|audit_fstat
operator|.
name|af_currsz
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
comment|/* 	 * XXX Need to decide what to do if the trigger to the audit daemon 	 * fails. 	 */
comment|/*  	 * If we fall below minimum free blocks (hard limit), tell the audit 	 * daemon to force a rotation off of the file system. We also stop 	 * writing, which means this audit record is probably lost. 	 * If we fall below the minimum percent free blocks (soft limit),  	 * then kindly suggest to the audit daemon to do something. 	 */
if|if
condition|(
name|mnt_stat
operator|->
name|f_bfree
operator|<
name|AUDIT_HARD_LIMIT_FREE_BLOCKS
condition|)
block|{
name|send_trigger
argument_list|(
name|AUDIT_TRIGGER_NO_SPACE
argument_list|)
expr_stmt|;
comment|/* Hopefully userspace did something about all the previous 		 * triggers that were sent prior to this critical condition. 		 * If fail-stop is set, then we're done; goodnight Gracie. 		 */
if|if
condition|(
name|audit_fail_stop
condition|)
name|panic
argument_list|(
literal|"Audit log space exhausted and fail-stop set."
argument_list|)
expr_stmt|;
else|else
block|{
name|audit_suspended
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
comment|/*  		 * Send a message to the audit daemon that disk space  		 * is getting low. 		 * 		 * XXXAUDIT: Check math and block size calculation here. 		 */
if|if
condition|(
name|audit_qctrl
operator|.
name|aq_minfree
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|mnt_stat
operator|->
name|f_blocks
operator|/
operator|(
literal|100
operator|/
name|audit_qctrl
operator|.
name|aq_minfree
operator|)
expr_stmt|;
if|if
condition|(
name|mnt_stat
operator|->
name|f_bfree
operator|<
name|temp
condition|)
name|send_trigger
argument_list|(
name|AUDIT_TRIGGER_LOW_SPACE
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the current log file is full; if so, call for 	 * a log rotate. This is not an exact comparison; we may 	 * write some records over the limit. If that's not 	 * acceptable, then add a fudge factor here. 	 */
if|if
condition|(
operator|(
name|audit_fstat
operator|.
name|af_filesz
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|audit_file_rotate_wait
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vattr
operator|.
name|va_size
operator|>=
name|audit_fstat
operator|.
name|af_filesz
operator|)
condition|)
block|{
name|audit_file_rotate_wait
operator|=
literal|1
expr_stmt|;
name|send_trigger
argument_list|(
name|AUDIT_TRIGGER_OPEN_NEW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the estimated amount of audit data in the audit event queue 	 * (plus records allocated but not yet queued) has reached the 	 * amount of free space on the disk, then we need to go into an 	 * audit fail stop state, in which we do not permit the 	 * allocation/committing of any new audit records.  We continue to 	 * process packets but don't allow any activities that might 	 * generate new records.  In the future, we might want to detect 	 * when space is available again and allow operation to continue, 	 * but this behavior is sufficient to meet fail stop requirements 	 * in CAPP. 	 */
if|if
condition|(
name|audit_fail_stop
operator|&&
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|audit_q_len
operator|+
name|audit_pre_q_len
operator|+
literal|1
operator|)
operator|*
name|MAX_AUDIT_RECORD_SIZE
argument_list|)
operator|/
name|mnt_stat
operator|->
name|f_bsize
operator|>=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|mnt_stat
operator|->
name|f_bfree
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audit_worker: free space below size of audit queue, failing stop\n"
argument_list|)
expr_stmt|;
name|audit_in_failure
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  	 * If there is a user audit record attached to the kernel record, 	 * then write the user record. 	 */
comment|/* XXX Need to decide a few things here: IF the user audit  	 * record is written, but the write of the kernel record fails, 	 * what to do? Should the kernel record come before or after the 	 * user record? For now, we write the user record first, and 	 * we ignore errors. 	 */
if|if
condition|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_USER
condition|)
block|{
comment|/* 		 * Try submitting the record to any active audit pipes. 		 */
name|audit_pipe_submit
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar
operator|->
name|k_udata
argument_list|,
name|ar
operator|->
name|k_ulen
argument_list|)
expr_stmt|;
comment|/* 		 * And to disk. 		 */
name|ret
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ar
operator|->
name|k_udata
argument_list|,
name|ar
operator|->
name|k_ulen
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
comment|/*  	 * Convert the internal kernel record to BSM format and write it 	 * out if everything's OK. 	 */
if|if
condition|(
operator|!
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
name|AR_COMMIT_KERNEL
operator|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * XXXAUDIT: Should we actually allow this conversion to fail?  With 	 * sleeping memory allocation and invariants checks, perhaps not. 	 */
name|ret
operator|=
name|kaudit_to_bsm
argument_list|(
name|ar
argument_list|,
operator|&
name|bsm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|BSM_NOAUDIT
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * XXX: We drop the record on BSM conversion failure, but really 	 * this is an assertion failure. 	 */
if|if
condition|(
name|ret
operator|==
name|BSM_FAILURE
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"BSM conversion failure\n"
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Try submitting the record to any active audit pipes. 	 */
name|audit_pipe_submit
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bsm
operator|->
name|data
argument_list|,
name|bsm
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * We should break the write functionality away from the BSM record 	 * generation and have the BSM generation done before this function 	 * is called. This function will then take the BSM record as a 	 * parameter. 	 */
name|ret
operator|=
operator|(
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bsm
operator|->
name|data
argument_list|,
name|bsm
operator|->
name|len
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_APPEND
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
operator|)
expr_stmt|;
name|kau_free
argument_list|(
name|bsm
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * When we're done processing the current record, we have to 	 * check to see if we're in a failure mode, and if so, whether 	 * this was the last record left to be drained.  If we're done 	 * draining, then we fsync the vnode and panic. 	 */
if|if
condition|(
name|audit_in_failure
operator|&&
name|audit_q_len
operator|==
literal|0
operator|&&
name|audit_pre_q_len
operator|==
literal|0
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|vp
argument_list|,
name|LK_DRAIN
operator||
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Audit store overflow; record queue drained."
argument_list|)
expr_stmt|;
block|}
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The audit_worker thread is responsible for watching the event queue,  * dequeueing records, converting them to BSM format, and committing them to  * disk.  In order to minimize lock thrashing, records are dequeued in sets  * to a thread-local work queue.  In addition, the audit_work performs the  * actual exchange of audit log vnode pointer, as audit_vp is a thread-local  * variable.  */
end_comment

begin_function
specifier|static
name|void
name|audit_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|do_replacement_signal
decl_stmt|,
name|error
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kaudit_record
argument_list|)
name|ar_worklist
expr_stmt|;
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|struct
name|vnode
modifier|*
name|audit_vp
decl_stmt|,
modifier|*
name|old_vp
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|struct
name|ucred
modifier|*
name|audit_cred
decl_stmt|,
modifier|*
name|old_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|audit_td
decl_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_worker starting\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * These are thread-local variables requiring no synchronization. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|ar_worklist
argument_list|)
expr_stmt|;
name|audit_cred
operator|=
name|NULL
expr_stmt|;
name|audit_td
operator|=
name|curthread
expr_stmt|;
name|audit_vp
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * First priority: replace the audit log target if requested. 		 * Accessing the vnode here requires dropping the audit_mtx; 		 * in case another replacement was scheduled while the mutex 		 * was released, we loop. 		 * 		 * XXX It could well be we should drain existing records 		 * first to ensure that the timestamps and ordering 		 * are right. 		 */
name|do_replacement_signal
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|audit_replacement_flag
operator|!=
literal|0
condition|)
block|{
name|old_cred
operator|=
name|audit_cred
expr_stmt|;
name|old_vp
operator|=
name|audit_vp
expr_stmt|;
name|audit_cred
operator|=
name|audit_replacement_cred
expr_stmt|;
name|audit_vp
operator|=
name|audit_replacement_vp
expr_stmt|;
name|audit_replacement_cred
operator|=
name|NULL
expr_stmt|;
name|audit_replacement_vp
operator|=
name|NULL
expr_stmt|;
name|audit_replacement_flag
operator|=
literal|0
expr_stmt|;
name|audit_enabled
operator|=
operator|(
name|audit_vp
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* 			 * XXX: What to do about write failures here? 			 */
if|if
condition|(
name|old_vp
operator|!=
name|NULL
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"Closing old audit file\n"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|old_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|old_vp
argument_list|,
name|AUDIT_CLOSE_FLAGS
argument_list|,
name|old_cred
argument_list|,
name|audit_td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|old_cred
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|old_cred
operator|=
name|NULL
expr_stmt|;
name|old_vp
operator|=
name|NULL
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"Audit file closed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|audit_vp
operator|!=
name|NULL
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"Opening new audit file\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|do_replacement_signal
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Signal that replacement have occurred to wake up and 		 * start any other replacements started in parallel.  We can 		 * continue about our business in the mean time.  We 		 * broadcast so that both new replacements can be inserted, 		 * but also so that the source(s) of replacement can return 		 * successfully. 		 */
if|if
condition|(
name|do_replacement_signal
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|audit_replacement_cv
argument_list|)
expr_stmt|;
comment|/* 		 * Next, check to see if we have any records to drain into 		 * the vnode.  If not, go back to waiting for an event. 		 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|audit_q
argument_list|)
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_worker waiting\n"
operator|)
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|audit_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_worker woken up\n"
operator|)
argument_list|)
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_worker: new vp = %p; value of flag %d\n"
operator|,
name|audit_replacement_vp
operator|,
name|audit_replacement_flag
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we have records, but there's no active vnode to write 		 * to, drain the record queue.  Generally, we prevent the 		 * unnecessary allocation of records elsewhere, but we need 		 * to allow for races between conditional allocation and 		 * queueing.  Go back to waiting when we're done. 		 */
if|if
condition|(
name|audit_vp
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ar
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_q
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|audit_q
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|audit_record_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|audit_q_len
operator|--
expr_stmt|;
comment|/* 				 * XXXRW: Why broadcast if we hold the 				 * mutex and know that audit_vp is NULL? 				 */
if|if
condition|(
name|audit_q_len
operator|<=
name|audit_qctrl
operator|.
name|aq_lowater
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|audit_commit_cv
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * We have both records to write and an active vnode to write 		 * to.  Dequeue a record, and start the write.  Eventually, 		 * it might make sense to dequeue several records and perform 		 * our own clustering, if the lower layers aren't doing it 		 * automatically enough. 		 */
while|while
condition|(
operator|(
name|ar
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|audit_q
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|audit_q
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|--
expr_stmt|;
if|if
condition|(
name|audit_q_len
operator|<=
name|audit_qctrl
operator|.
name|aq_lowater
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|audit_commit_cv
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ar_worklist
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ar
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ar_worklist
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ar_worklist
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|audit_vp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|audit_record_write
argument_list|(
name|audit_vp
argument_list|,
name|ar
argument_list|,
name|audit_cred
argument_list|,
name|audit_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|audit_panic_on_write_fail
condition|)
name|panic
argument_list|(
literal|"audit_worker: write error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"audit_worker: write error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|uma_zfree
argument_list|(
name|audit_record_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the Audit subsystem: configuration state, work queue,  * synchronization primitives, worker thread, and trigger device node.  Also  * call into the BSM assembly code to initialize it.  */
end_comment

begin_function
specifier|static
name|void
name|audit_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|printf
argument_list|(
literal|"Security auditing service present\n"
argument_list|)
expr_stmt|;
name|audit_enabled
operator|=
literal|0
expr_stmt|;
name|audit_suspended
operator|=
literal|0
expr_stmt|;
name|audit_panic_on_write_fail
operator|=
literal|0
expr_stmt|;
name|audit_fail_stop
operator|=
literal|0
expr_stmt|;
name|audit_in_failure
operator|=
literal|0
expr_stmt|;
name|audit_replacement_vp
operator|=
name|NULL
expr_stmt|;
name|audit_replacement_cred
operator|=
name|NULL
expr_stmt|;
name|audit_replacement_flag
operator|=
literal|0
expr_stmt|;
name|audit_fstat
operator|.
name|af_filesz
operator|=
literal|0
expr_stmt|;
comment|/* '0' means unset, unbounded */
name|audit_fstat
operator|.
name|af_currsz
operator|=
literal|0
expr_stmt|;
name|audit_nae_mask
operator|.
name|am_success
operator|=
name|AU_NULL
expr_stmt|;
name|audit_nae_mask
operator|.
name|am_failure
operator|=
name|AU_NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|audit_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|=
literal|0
expr_stmt|;
name|audit_pre_q_len
operator|=
literal|0
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_hiwater
operator|=
name|AQ_HIWATER
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_lowater
operator|=
name|AQ_LOWATER
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_bufsz
operator|=
name|AQ_BUFSZ
expr_stmt|;
name|audit_qctrl
operator|.
name|aq_minfree
operator|=
name|AU_FS_MINFREE
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|audit_mtx
argument_list|,
literal|"audit_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_cv
argument_list|,
literal|"audit_cv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_replacement_cv
argument_list|,
literal|"audit_replacement_cv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_commit_cv
argument_list|,
literal|"audit_commit_cv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|audit_fail_cv
argument_list|,
literal|"audit_fail_cv"
argument_list|)
expr_stmt|;
name|audit_record_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"audit_record_zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kaudit_record
argument_list|)
argument_list|,
name|audit_record_ctor
argument_list|,
name|audit_record_dtor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the BSM audit subsystem. */
name|kau_init
argument_list|()
expr_stmt|;
name|audit_file_rotate_wait
operator|=
literal|0
expr_stmt|;
name|audit_trigger_init
argument_list|()
expr_stmt|;
comment|/* Register shutdown handler. */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|audit_shutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|audit_worker
argument_list|,
name|NULL
argument_list|,
operator|&
name|audit_thread
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"audit_worker"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"audit_init: kthread_create returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|audit_init
argument_list|,
argument|SI_SUB_AUDIT
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|audit_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * audit_rotate_vnode() is called by a user or kernel thread to configure or  * de-configure auditing on a vnode.  The arguments are the replacement  * credential and vnode to substitute for the current credential and vnode,  * if any.  If either is set to NULL, both should be NULL, and this is used  * to indicate that audit is being disabled.  The real work is done in the  * audit_worker thread, but audit_rotate_vnode() waits synchronously for that  * to complete.  *  * The vnode should be referenced and opened by the caller.  The credential  * should be referenced.  audit_rotate_vnode() will own both references as of  * this call, so the caller should not release either.  *  * XXXAUDIT: Review synchronize communication logic.  Really, this is a  * message queue of depth 1.  *  * XXXAUDIT: Enhance the comments below to indicate that we are basically  * acquiring ownership of the communications queue, inserting our message,  * and waiting for an acknowledgement.  */
end_comment

begin_function
name|void
name|audit_rotate_vnode
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
comment|/* 	 * If other parallel log replacements have been requested, we wait 	 * until they've finished before continuing. 	 */
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|audit_replacement_flag
operator|!=
literal|0
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_rotate_vnode: sleeping to wait for "
literal|"flag\n"
operator|)
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|audit_replacement_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_rotate_vnode: woken up (flag %d)\n"
operator|,
name|audit_replacement_flag
operator|)
argument_list|)
expr_stmt|;
block|}
name|audit_replacement_cred
operator|=
name|cred
expr_stmt|;
name|audit_replacement_flag
operator|=
literal|1
expr_stmt|;
name|audit_replacement_vp
operator|=
name|vp
expr_stmt|;
comment|/* 	 * Wake up the audit worker to perform the exchange once we 	 * release the mutex. 	 */
name|cv_signal
argument_list|(
operator|&
name|audit_cv
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the audit_worker to broadcast that a replacement has 	 * taken place; we know that once this has happened, our vnode 	 * has been replaced in, so we can return successfully. 	 */
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_rotate_vnode: waiting for news of "
literal|"replacement\n"
operator|)
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|audit_replacement_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_rotate_vnode: change acknowledged by "
literal|"audit_worker (flag "
literal|"now %d)\n"
operator|,
name|audit_replacement_flag
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_file_rotate_wait
operator|=
literal|0
expr_stmt|;
comment|/* We can now request another rotation */
block|}
end_function

begin_comment
comment|/*  * Drain the audit queue and close the log at shutdown.  Note that this can  * be called both from the system shutdown path and also from audit  * configuration syscalls, so 'arg' and 'howto' are ignored.  */
end_comment

begin_function
name|void
name|audit_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|audit_rotate_vnode
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current thread's audit record, if any.  */
end_comment

begin_function
name|__inline__
name|struct
name|kaudit_record
modifier|*
name|currecord
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|curthread
operator|->
name|td_ar
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  *  * XXXAUDIT: There are a number of races present in the code below due to  * release and re-grab of the mutex.  The code should be revised to become  * slightly less racy.  *  * XXXAUDIT: Shouldn't there be logic here to sleep waiting on available  * pre_q space, suspending the system call until there is room?  */
end_comment

begin_function
name|struct
name|kaudit_record
modifier|*
name|audit_new
parameter_list|(
name|int
name|event
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kaudit_record
modifier|*
name|ar
decl_stmt|;
name|int
name|no_record
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|no_record
operator|=
operator|(
name|audit_suspended
operator|||
operator|!
name|audit_enabled
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_record
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * XXX: The number of outstanding uncommitted audit records is 	 * limited to the number of concurrent threads servicing system 	 * calls in the kernel. 	 */
name|ar
operator|=
name|uma_zalloc_arg
argument_list|(
name|audit_record_zone
argument_list|,
name|td
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|event
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_pre_q_len
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ar
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|void
name|audit_commit
parameter_list|(
name|struct
name|kaudit_record
modifier|*
name|ar
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|retval
parameter_list|)
block|{
name|int
name|sorf
decl_stmt|;
name|struct
name|au_mask
modifier|*
name|aumask
decl_stmt|;
if|if
condition|(
name|ar
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Decide whether to commit the audit record by checking the 	 * error value from the system call and using the appropriate 	 * audit mask. 	 * 	 * XXXAUDIT: Synchronize access to audit_nae_mask? 	 */
if|if
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_auid
operator|==
name|AU_DEFAUDITID
condition|)
name|aumask
operator|=
operator|&
name|audit_nae_mask
expr_stmt|;
else|else
name|aumask
operator|=
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_subj_amask
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|sorf
operator|=
name|AU_PRS_FAILURE
expr_stmt|;
else|else
name|sorf
operator|=
name|AU_PRS_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
condition|)
block|{
case|case
name|AUE_OPEN_RWTC
case|:
comment|/* The open syscall always writes a AUE_OPEN_RWTC event; change 		 * it to the proper type of event based on the flags and the  		 * error value. 		 */
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|flags_and_error_to_openevent
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_fflags
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUE_SYSCTL
case|:
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|ctlname_to_sysctlevent
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_ctlname
argument_list|,
name|ar
operator|->
name|k_ar
operator|.
name|ar_valid_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUE_AUDITON
case|:
comment|/* Convert the auditon() command to an event */
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
operator|=
name|auditon_command_event
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_arg_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|au_preselect
argument_list|(
name|ar
operator|->
name|k_ar
operator|.
name|ar_event
argument_list|,
name|aumask
argument_list|,
name|sorf
argument_list|)
operator|!=
literal|0
condition|)
name|ar
operator|->
name|k_ar_commit
operator||=
name|AR_COMMIT_KERNEL
expr_stmt|;
comment|/* 	 * XXXRW: Why is this necessary?  Should we ever accept a record that 	 * we're not willing to commit? 	 */
if|if
condition|(
operator|(
name|ar
operator|->
name|k_ar_commit
operator|&
operator|(
name|AR_COMMIT_USER
operator||
name|AR_COMMIT_KERNEL
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|audit_pre_q_len
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|audit_record_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
return|return;
block|}
name|ar
operator|->
name|k_ar
operator|.
name|ar_errno
operator|=
name|error
expr_stmt|;
name|ar
operator|->
name|k_ar
operator|.
name|ar_retval
operator|=
name|retval
expr_stmt|;
comment|/* 	 * We might want to do some system-wide post-filtering 	 * here at some point. 	 */
comment|/* 	 * Timestamp system call end. 	 */
name|nanotime
argument_list|(
operator|&
name|ar
operator|->
name|k_ar
operator|.
name|ar_endtime
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Note: it could be that some records initiated while audit was 	 * enabled should still be committed? 	 */
if|if
condition|(
name|audit_suspended
operator|||
operator|!
name|audit_enabled
condition|)
block|{
name|audit_pre_q_len
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|audit_record_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Constrain the number of committed audit records based on 	 * the configurable parameter. 	 */
while|while
condition|(
name|audit_q_len
operator|>=
name|audit_qctrl
operator|.
name|aq_hiwater
condition|)
block|{
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_commit: sleeping to wait for "
literal|"audit queue to drain below high water mark\n"
operator|)
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|audit_commit_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit_commit: woke up waiting for "
literal|"audit queue draining\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|audit_q
argument_list|,
name|ar
argument_list|,
name|k_q
argument_list|)
expr_stmt|;
name|audit_q_len
operator|++
expr_stmt|;
name|audit_pre_q_len
operator|--
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|audit_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_syscall_enter() is called on entry to each system call.  It is  * responsible for deciding whether or not to audit the call (preselection),  * and if so, allocating a per-thread audit record.  audit_new() will fill in  * basic thread/credential properties.  */
end_comment

begin_function
name|void
name|audit_syscall_enter
parameter_list|(
name|unsigned
name|short
name|code
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|audit_event
decl_stmt|;
name|struct
name|au_mask
modifier|*
name|aumask
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_ar
operator|==
name|NULL
argument_list|,
operator|(
literal|"audit_syscall_enter: td->td_ar != NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * In FreeBSD, each ABI has its own system call table, and hence 	 * mapping of system call codes to audit events.  Convert the code to 	 * an audit event identifier using the process system call table 	 * reference.  In Darwin, there's only one, so we use the global 	 * symbol for the system call table. 	 * 	 * XXXAUDIT: Should we audit that a bad system call was made, and if 	 * so, how? 	 */
if|if
condition|(
name|code
operator|>=
name|td
operator|->
name|td_proc
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
return|return;
name|audit_event
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
operator|.
name|sy_auevent
expr_stmt|;
if|if
condition|(
name|audit_event
operator|==
name|AUE_NULL
condition|)
return|return;
comment|/* 	 * Check which audit mask to use; either the kernel non-attributable 	 * event mask or the process audit mask. 	 */
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_auid
operator|==
name|AU_DEFAUDITID
condition|)
name|aumask
operator|=
operator|&
name|audit_nae_mask
expr_stmt|;
else|else
name|aumask
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_au
operator|->
name|ai_mask
expr_stmt|;
comment|/* 	 * Allocate an audit record, if preselection allows it, and store  	 * in the thread for later use. 	 */
if|if
condition|(
name|au_preselect
argument_list|(
name|audit_event
argument_list|,
name|aumask
argument_list|,
name|AU_PRS_FAILURE
operator||
name|AU_PRS_SUCCESS
argument_list|)
condition|)
block|{
comment|/* 		 * If we're out of space and need to suspend unprivileged 		 * processes, do that here rather than trying to allocate 		 * another audit record. 		 * 		 * XXXRW: We might wish to be able to continue here in the 		 * future, if the system recovers.  That should be possible 		 * by means of checking the condition in a loop around 		 * cv_wait().  It might be desirable to reevaluate whether an 		 * audit record is still required for this event by 		 * re-calling au_preselect(). 		 */
if|if
condition|(
name|audit_in_failure
operator|&&
name|suser
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|audit_fail_cv
argument_list|,
operator|&
name|audit_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"audit_failing_stop: thread continued"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_ar
operator|=
name|audit_new
argument_list|(
name|audit_event
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * audit_syscall_exit() is called from the return of every system call, or in  * the event of exit1(), during the execution of exit1().  It is responsible  * for committing the audit record, if any, along with return condition.  */
end_comment

begin_function
name|void
name|audit_syscall_exit
parameter_list|(
name|int
name|error
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* 	 * Commit the audit record as desired; once we pass the record 	 * into audit_commit(), the memory is owned by the audit 	 * subsystem. 	 * The return value from the system call is stored on the user 	 * thread. If there was an error, the return value is set to -1, 	 * imitating the behavior of the cerror routine. 	 */
if|if
condition|(
name|error
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|audit_commit
argument_list|(
name|td
operator|->
name|td_ar
argument_list|,
name|error
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ar
operator|!=
name|NULL
condition|)
name|AUDIT_PRINTF
argument_list|(
operator|(
literal|"audit record committed by pid %d\n"
operator|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate storage for a new process (init, or otherwise).  */
end_comment

begin_function
name|void
name|audit_proc_alloc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_au
operator|==
name|NULL
argument_list|,
operator|(
literal|"audit_proc_alloc: p->p_au != NULL (%d)"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_au
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p
operator|->
name|p_au
operator|)
argument_list|)
argument_list|,
name|M_AUDITPROC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* XXXAUDIT: Zero?  Slab allocate? */
comment|//printf("audit_proc_alloc: pid %d p_au %p\n", p->p_pid, p->p_au);
block|}
end_function

begin_comment
comment|/*  * Allocate storage for a new thread.  */
end_comment

begin_function
name|void
name|audit_thread_alloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|td_ar
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Thread destruction.  */
end_comment

begin_function
name|void
name|audit_thread_free
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|td
operator|->
name|td_ar
operator|==
name|NULL
argument_list|,
operator|(
literal|"audit_thread_free: td_ar != NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Initialize the audit information for the a process, presumably the first   * process in the system.  * XXX It is not clear what the initial values should be for audit ID,   * session ID, etc.   */
end_comment

begin_function
name|void
name|audit_proc_kproc0
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_au
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_proc_kproc0: p->p_au == NULL (%d)"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
comment|//printf("audit_proc_kproc0: pid %d p_au %p\n", p->p_pid, p->p_au);
name|bzero
argument_list|(
name|p
operator|->
name|p_au
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p
operator|)
operator|->
name|p_au
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_proc_init
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_au
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_proc_init: p->p_au == NULL (%d)"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
comment|//printf("audit_proc_init: pid %d p_au %p\n", p->p_pid, p->p_au);
name|bzero
argument_list|(
name|p
operator|->
name|p_au
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p
operator|)
operator|->
name|p_au
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_au
operator|->
name|ai_auid
operator|=
name|AU_DEFAUDITID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Copy the audit info from the parent process to the child process when  * a fork takes place.  */
end_comment

begin_function
name|void
name|audit_proc_fork
parameter_list|(
name|struct
name|proc
modifier|*
name|parent
parameter_list|,
name|struct
name|proc
modifier|*
name|child
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|parent
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|child
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parent
operator|->
name|p_au
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_proc_fork: parent->p_au == NULL (%d)"
operator|,
name|parent
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|child
operator|->
name|p_au
operator|!=
name|NULL
argument_list|,
operator|(
literal|"audit_proc_fork: child->p_au == NULL (%d)"
operator|,
name|child
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
comment|//printf("audit_proc_fork: parent pid %d p_au %p\n", parent->p_pid,
comment|//    parent->p_au);
comment|//printf("audit_proc_fork: child pid %d p_au %p\n", child->p_pid,
comment|//    child->p_au);
name|bcopy
argument_list|(
name|parent
operator|->
name|p_au
argument_list|,
name|child
operator|->
name|p_au
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child
operator|->
name|p_au
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXXAUDIT: Zero pointers to external memory, or assert they are 	 * zero? 	 */
block|}
end_function

begin_comment
comment|/*  * Free the auditing structure for the process.   */
end_comment

begin_function
name|void
name|audit_proc_free
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_au
operator|!=
name|NULL
argument_list|,
operator|(
literal|"p->p_au == NULL (%d)"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
comment|//printf("audit_proc_free: pid %d p_au %p\n", p->p_pid, p->p_au);
comment|/* 	 * XXXAUDIT: Assert that external memory pointers are NULL? 	 */
name|free
argument_list|(
name|p
operator|->
name|p_au
argument_list|,
name|M_AUDITPROC
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_au
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

