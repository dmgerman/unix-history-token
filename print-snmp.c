begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997  *     John Robert LoVerso. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * This implementation has been influenced by the CMU SNMP release,  * by Steve Waldbusser.  However, this shares no code with that system.  * Additional ASN.1 insight gained from Marshall T. Rose's _The_Open_Book_.  * Earlier forms of this implementation were derived and/or inspired by an  * awk script originally written by C. Philip Wood of LANL (but later  * heavily modified by John Robert LoVerso).  The copyright notice for  * that work is preserved below, even though it may not rightly apply  * to this file.  *  * Support for SNMPv2c/SNMPv3 and the ability to link the module against  * the libsmi was added by J. Schoenwaelder, Copyright (c) 1999.  *  * This started out as a very simple program, but the incremental decoding  * (into the BE structure) complicated things.  *  #			Los Alamos National Laboratory  #  #	Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997  #	This software was produced under a U.S. Government contract  #	(W-7405-ENG-36) by Los Alamos National Laboratory, which is  #	operated by the	University of California for the U.S. Department  #	of Energy.  The U.S. Government is licensed to use, reproduce,  #	and distribute this software.  Permission is granted to the  #	public to copy and use this software without charge, provided  #	that this Notice and any statement of authorship are reproduced  #	on all copies.  Neither the Government nor the University makes  #	any warranty, express or implied, or assumes any liability or  #	responsibility for the use of this software.  #	@(#)snmp.awk.x	1.1 (LANL) 1/15/90  */
end_comment

begin_define
define|#
directive|define
name|NETDISSECT_REWORKED
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBSMI
end_ifdef

begin_include
include|#
directive|include
file|<smi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_undef
undef|#
directive|undef
name|OPAQUE
end_undef

begin_comment
comment|/* defined in<wingdi.h> */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tstr
index|[]
init|=
literal|"[|snmp]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Universal ASN.1 types  * (we only care about the tag values for those allowed in the Internet SMI)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Universal
index|[]
init|=
block|{
literal|"U-0"
block|,
literal|"Boolean"
block|,
literal|"Integer"
block|,
define|#
directive|define
name|INTEGER
value|2
literal|"Bitstring"
block|,
literal|"String"
block|,
define|#
directive|define
name|STRING
value|4
literal|"Null"
block|,
define|#
directive|define
name|ASN_NULL
value|5
literal|"ObjID"
block|,
define|#
directive|define
name|OBJECTID
value|6
literal|"ObjectDes"
block|,
literal|"U-8"
block|,
literal|"U-9"
block|,
literal|"U-10"
block|,
literal|"U-11"
block|,
comment|/* 8-11 */
literal|"U-12"
block|,
literal|"U-13"
block|,
literal|"U-14"
block|,
literal|"U-15"
block|,
comment|/* 12-15 */
literal|"Sequence"
block|,
define|#
directive|define
name|SEQUENCE
value|16
literal|"Set"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Application-wide ASN.1 types from the Internet SMI and their tags  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Application
index|[]
init|=
block|{
literal|"IpAddress"
block|,
define|#
directive|define
name|IPADDR
value|0
literal|"Counter"
block|,
define|#
directive|define
name|COUNTER
value|1
literal|"Gauge"
block|,
define|#
directive|define
name|GAUGE
value|2
literal|"TimeTicks"
block|,
define|#
directive|define
name|TIMETICKS
value|3
literal|"Opaque"
block|,
define|#
directive|define
name|OPAQUE
value|4
literal|"C-5"
block|,
literal|"Counter64"
define|#
directive|define
name|COUNTER64
value|6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Context-specific ASN.1 types for the SNMP PDUs and their tags  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Context
index|[]
init|=
block|{
literal|"GetRequest"
block|,
define|#
directive|define
name|GETREQ
value|0
literal|"GetNextRequest"
block|,
define|#
directive|define
name|GETNEXTREQ
value|1
literal|"GetResponse"
block|,
define|#
directive|define
name|GETRESP
value|2
literal|"SetRequest"
block|,
define|#
directive|define
name|SETREQ
value|3
literal|"Trap"
block|,
define|#
directive|define
name|TRAP
value|4
literal|"GetBulk"
block|,
define|#
directive|define
name|GETBULKREQ
value|5
literal|"Inform"
block|,
define|#
directive|define
name|INFORMREQ
value|6
literal|"V2Trap"
block|,
define|#
directive|define
name|V2TRAP
value|7
literal|"Report"
define|#
directive|define
name|REPORT
value|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOTIFY_CLASS
parameter_list|(
name|x
parameter_list|)
value|(x == TRAP || x == V2TRAP || x == INFORMREQ)
end_define

begin_define
define|#
directive|define
name|READ_CLASS
parameter_list|(
name|x
parameter_list|)
value|(x == GETREQ || x == GETNEXTREQ || x == GETBULKREQ)
end_define

begin_define
define|#
directive|define
name|WRITE_CLASS
parameter_list|(
name|x
parameter_list|)
value|(x == SETREQ)
end_define

begin_define
define|#
directive|define
name|RESPONSE_CLASS
parameter_list|(
name|x
parameter_list|)
value|(x == GETRESP)
end_define

begin_define
define|#
directive|define
name|INTERNAL_CLASS
parameter_list|(
name|x
parameter_list|)
value|(x == REPORT)
end_define

begin_comment
comment|/*  * Context-specific ASN.1 types for the SNMP Exceptions and their tags  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Exceptions
index|[]
init|=
block|{
literal|"noSuchObject"
block|,
define|#
directive|define
name|NOSUCHOBJECT
value|0
literal|"noSuchInstance"
block|,
define|#
directive|define
name|NOSUCHINSTANCE
value|1
literal|"endOfMibView"
block|,
define|#
directive|define
name|ENDOFMIBVIEW
value|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private ASN.1 types  * The Internet SMI does not specify any  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Private
index|[]
init|=
block|{
literal|"P-0"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * error-status values for any SNMP PDU  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ErrorStatus
index|[]
init|=
block|{
literal|"noError"
block|,
literal|"tooBig"
block|,
literal|"noSuchName"
block|,
literal|"badValue"
block|,
literal|"readOnly"
block|,
literal|"genErr"
block|,
literal|"noAccess"
block|,
literal|"wrongType"
block|,
literal|"wrongLength"
block|,
literal|"wrongEncoding"
block|,
literal|"wrongValue"
block|,
literal|"noCreation"
block|,
literal|"inconsistentValue"
block|,
literal|"resourceUnavailable"
block|,
literal|"commitFailed"
block|,
literal|"undoFailed"
block|,
literal|"authorizationError"
block|,
literal|"notWritable"
block|,
literal|"inconsistentName"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DECODE_ErrorStatus
parameter_list|(
name|e
parameter_list|)
define|\
value|( e>= 0&& (size_t)e< sizeof(ErrorStatus)/sizeof(ErrorStatus[0]) \ 		? ErrorStatus[e] \ 		: (snprintf(errbuf, sizeof(errbuf), "err=%u", e), errbuf))
end_define

begin_comment
comment|/*  * generic-trap values in the SNMP Trap-PDU  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|GenericTrap
index|[]
init|=
block|{
literal|"coldStart"
block|,
literal|"warmStart"
block|,
literal|"linkDown"
block|,
literal|"linkUp"
block|,
literal|"authenticationFailure"
block|,
literal|"egpNeighborLoss"
block|,
literal|"enterpriseSpecific"
define|#
directive|define
name|GT_ENTERPRISE
value|6
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DECODE_GenericTrap
parameter_list|(
name|t
parameter_list|)
define|\
value|( t>= 0&& (size_t)t< sizeof(GenericTrap)/sizeof(GenericTrap[0]) \ 		? GenericTrap[t] \ 		: (snprintf(buf, sizeof(buf), "gt=%d", t), buf))
end_define

begin_comment
comment|/*  * ASN.1 type class table  * Ties together the preceding Universal, Application, Context, and Private  * type definitions.  */
end_comment

begin_define
define|#
directive|define
name|defineCLASS
parameter_list|(
name|x
parameter_list|)
value|{ "x", x, sizeof(x)/sizeof(x[0]) }
end_define

begin_comment
comment|/* not ANSI-C */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|Id
decl_stmt|;
name|int
name|numIDs
decl_stmt|;
block|}
name|Class
index|[]
init|=
block|{
name|defineCLASS
argument_list|(
name|Universal
argument_list|)
block|,
define|#
directive|define
name|UNIVERSAL
value|0
name|defineCLASS
argument_list|(
name|Application
argument_list|)
block|,
define|#
directive|define
name|APPLICATION
value|1
name|defineCLASS
argument_list|(
name|Context
argument_list|)
block|,
define|#
directive|define
name|CONTEXT
value|2
name|defineCLASS
argument_list|(
name|Private
argument_list|)
block|,
define|#
directive|define
name|PRIVATE
value|3
name|defineCLASS
argument_list|(
name|Exceptions
argument_list|)
block|,
define|#
directive|define
name|EXCEPTIONS
value|4
block|}
struct|;
end_struct

begin_comment
comment|/*  * defined forms for ASN.1 types  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Form
index|[]
init|=
block|{
literal|"Primitive"
block|,
define|#
directive|define
name|PRIMITIVE
value|0
literal|"Constructed"
block|,
define|#
directive|define
name|CONSTRUCTED
value|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A structure for the OID tree for the compiled-in MIB.  * This is stored as a general-order tree.  */
end_comment

begin_struct
struct|struct
name|obj
block|{
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* name of object */
name|u_char
name|oid
decl_stmt|;
comment|/* sub-id following parent */
name|u_char
name|type
decl_stmt|;
comment|/* object type (unused) */
name|struct
name|obj
modifier|*
name|child
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* child and next sibling pointers */
block|}
modifier|*
name|objp
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/*  * Include the compiled in SNMP MIB.  "mib.h" is produced by feeding  * RFC-1156 format files into "makemib".  "mib.h" MUST define at least  * a value for `mibroot'.  *  * In particular, this is gross, as this is including initialized structures,  * and by right shouldn't be an "include" file.  */
end_comment

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_comment
comment|/*  * This defines a list of OIDs which will be abbreviated on output.  * Currently, this includes the prefixes for the Internet MIB, the  * private enterprises tree, and the experimental tree.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|obj_abrev
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* prefix for this abrev */
name|struct
name|obj
modifier|*
name|node
decl_stmt|;
comment|/* pointer into object table */
specifier|const
name|char
modifier|*
name|oid
decl_stmt|;
comment|/* ASN.1 encoded OID */
block|}
name|obj_abrev_list
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NO_ABREV_MIB
comment|/* .iso.org.dod.internet.mgmt.mib */
block|{
literal|""
block|,
operator|&
name|_mib_obj
block|,
literal|"\53\6\1\2\1"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABREV_ENTER
comment|/* .iso.org.dod.internet.private.enterprises */
block|{
literal|"E:"
block|,
operator|&
name|_enterprises_obj
block|,
literal|"\53\6\1\4\1"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABREV_EXPERI
comment|/* .iso.org.dod.internet.experimental */
block|{
literal|"X:"
block|,
operator|&
name|_experimental_obj
block|,
literal|"\53\6\1\3"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABBREV_SNMPMODS
comment|/* .iso.org.dod.internet.snmpV2.snmpModules */
block|{
literal|"S:"
block|,
operator|&
name|_snmpModules_obj
block|,
literal|"\53\6\1\6\3"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is used in the OID print routine to walk down the object tree  * rooted at `mibroot'.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_PRINT
parameter_list|(
name|o
parameter_list|,
name|suppressdot
parameter_list|)
define|\
value|{ \ 	if (objp) { \ 		do { \ 			if ((o) == objp->oid) \ 				break; \ 		} while ((objp = objp->next) != NULL); \ 	} \ 	if (objp) { \ 		ND_PRINT((ndo, suppressdot?"%s":".%s", objp->desc)); \ 		objp = objp->child; \ 	} else \ 		ND_PRINT((ndo, suppressdot?"%u":".%u", (o))); \ }
end_define

begin_comment
comment|/*  * This is the definition for the Any-Data-Type storage used purely for  * temporary internal representation while decoding an ASN.1 data stream.  */
end_comment

begin_struct
struct|struct
name|be
block|{
name|uint32_t
name|asnlen
decl_stmt|;
union|union
block|{
name|caddr_t
name|raw
decl_stmt|;
name|int32_t
name|integer
decl_stmt|;
name|uint32_t
name|uns
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|str
decl_stmt|;
struct|struct
block|{
name|uint32_t
name|high
decl_stmt|;
name|uint32_t
name|low
decl_stmt|;
block|}
name|uns64
struct|;
block|}
name|data
union|;
name|u_short
name|id
decl_stmt|;
name|u_char
name|form
decl_stmt|,
name|class
decl_stmt|;
comment|/* tag info */
name|u_char
name|type
decl_stmt|;
define|#
directive|define
name|BE_ANY
value|255
define|#
directive|define
name|BE_NONE
value|0
define|#
directive|define
name|BE_NULL
value|1
define|#
directive|define
name|BE_OCTET
value|2
define|#
directive|define
name|BE_OID
value|3
define|#
directive|define
name|BE_INT
value|4
define|#
directive|define
name|BE_UNS
value|5
define|#
directive|define
name|BE_STR
value|6
define|#
directive|define
name|BE_SEQ
value|7
define|#
directive|define
name|BE_INETADDR
value|8
define|#
directive|define
name|BE_PDU
value|9
define|#
directive|define
name|BE_UNS64
value|10
define|#
directive|define
name|BE_NOSUCHOBJECT
value|128
define|#
directive|define
name|BE_NOSUCHINST
value|129
define|#
directive|define
name|BE_ENDOFMIBVIEW
value|130
block|}
struct|;
end_struct

begin_comment
comment|/*  * SNMP versions recognized by this module  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|SnmpVersion
index|[]
init|=
block|{
literal|"SNMPv1"
block|,
define|#
directive|define
name|SNMP_VERSION_1
value|0
literal|"SNMPv2c"
block|,
define|#
directive|define
name|SNMP_VERSION_2
value|1
literal|"SNMPv2u"
block|,
define|#
directive|define
name|SNMP_VERSION_2U
value|2
literal|"SNMPv3"
define|#
directive|define
name|SNMP_VERSION_3
value|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defaults for SNMP PDU components  */
end_comment

begin_define
define|#
directive|define
name|DEF_COMMUNITY
value|"public"
end_define

begin_comment
comment|/*  * constants for ASN.1 decoding  */
end_comment

begin_define
define|#
directive|define
name|OIDMUX
value|40
end_define

begin_define
define|#
directive|define
name|ASNLEN_INETADDR
value|4
end_define

begin_define
define|#
directive|define
name|ASN_SHIFT7
value|7
end_define

begin_define
define|#
directive|define
name|ASN_SHIFT8
value|8
end_define

begin_define
define|#
directive|define
name|ASN_BIT8
value|0x80
end_define

begin_define
define|#
directive|define
name|ASN_LONGLEN
value|0x80
end_define

begin_define
define|#
directive|define
name|ASN_ID_BITS
value|0x1f
end_define

begin_define
define|#
directive|define
name|ASN_FORM_BITS
value|0x20
end_define

begin_define
define|#
directive|define
name|ASN_FORM_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|ASN_CLASS_BITS
value|0xc0
end_define

begin_define
define|#
directive|define
name|ASN_CLASS_SHIFT
value|6
end_define

begin_define
define|#
directive|define
name|ASN_ID_EXT
value|0x1f
end_define

begin_comment
comment|/* extension ID in tag field */
end_comment

begin_comment
comment|/*  * This decodes the next ASN.1 object in the stream pointed to by "p"  * (and of real-length "len") and stores the intermediate data in the  * provided BE object.  *  * This returns -l if it fails (i.e., the ASN.1 stream is not valid).  * O/w, this returns the number of bytes parsed from "p".  */
end_comment

begin_function
specifier|static
name|int
name|asn1_parse
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|u_char
name|form
decl_stmt|,
name|class
decl_stmt|,
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hdr
decl_stmt|;
name|elem
operator|->
name|asnlen
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_ANY
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[nothing to parse]"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * it would be nice to use a bit field, but you can't depend on them. 	 *  +---+---+---+---+---+---+---+---+ 	 *  + class |frm|        id         | 	 *  +---+---+---+---+---+---+---+---+ 	 *    7   6   5   4   3   2   1   0 	 */
name|id
operator|=
operator|*
name|p
operator|&
name|ASN_ID_BITS
expr_stmt|;
comment|/* lower 5 bits, range 00-1f */
ifdef|#
directive|ifdef
name|notdef
name|form
operator|=
operator|(
operator|*
name|p
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
expr_stmt|;
comment|/* move upper 3 bits to lower 3 */
name|class
operator|=
name|form
operator|>>
literal|1
expr_stmt|;
comment|/* bits 7&6 -> bits 1&0, range 0-3 */
name|form
operator|&=
literal|0x1
expr_stmt|;
comment|/* bit 5 -> bit 0, range 0-1 */
else|#
directive|else
name|form
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|p
operator|&
name|ASN_FORM_BITS
argument_list|)
operator|>>
name|ASN_FORM_SHIFT
expr_stmt|;
name|class
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|p
operator|&
name|ASN_CLASS_BITS
argument_list|)
operator|>>
name|ASN_CLASS_SHIFT
expr_stmt|;
endif|#
directive|endif
name|elem
operator|->
name|form
operator|=
name|form
expr_stmt|;
name|elem
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|elem
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|hdr
operator|=
literal|1
expr_stmt|;
comment|/* extended tag field */
if|if
condition|(
name|id
operator|==
name|ASN_ID_EXT
condition|)
block|{
comment|/* 		 * The ID follows, as a sequence of octets with the 		 * 8th bit set and the remaining 7 bits being 		 * the next 7 bits of the value, terminated with 		 * an octet with the 8th bit not set. 		 * 		 * First, assemble all the octets with the 8th 		 * bit set.  XXX - this doesn't handle a value 		 * that won't fit in 32 bits. 		 */
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|*
name|p
operator|&
name|ASN_BIT8
condition|;
name|len
operator|--
operator|,
name|hdr
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[Xtagfield?]"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
name|p
operator|&
operator|~
name|ASN_BIT8
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[Xtagfield?]"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|elem
operator|->
name|id
operator|=
name|id
operator|=
operator|(
name|id
operator|<<
literal|7
operator|)
operator||
operator|*
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
operator|++
name|hdr
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[no asnlen]"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|elem
operator|->
name|asnlen
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|hdr
operator|++
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|asnlen
operator|&
name|ASN_BIT8
condition|)
block|{
name|uint32_t
name|noct
init|=
name|elem
operator|->
name|asnlen
operator|%
name|ASN_BIT8
decl_stmt|;
name|elem
operator|->
name|asnlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|noct
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[asnlen? %d<%d]"
operator|,
name|len
operator|,
name|noct
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|noct
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|noct
operator|--
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|hdr
operator|++
control|)
name|elem
operator|->
name|asnlen
operator|=
operator|(
name|elem
operator|->
name|asnlen
operator|<<
name|ASN_SHIFT8
operator|)
operator||
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
name|elem
operator|->
name|asnlen
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[len%d<asnlen%u]"
operator|,
name|len
operator|,
name|elem
operator|->
name|asnlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|form
operator|>=
sizeof|sizeof
argument_list|(
name|Form
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Form
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[form?%d]"
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|class
operator|>=
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Class
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[class?%c/%d]"
operator|,
operator|*
name|Form
index|[
name|form
index|]
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|id
operator|>=
name|Class
index|[
name|class
index|]
operator|.
name|numIDs
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[id?%c/%s/%d]"
operator|,
operator|*
name|Form
index|[
name|form
index|]
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|name
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|PRIMITIVE
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|UNIVERSAL
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|STRING
case|:
name|elem
operator|->
name|type
operator|=
name|BE_STR
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|str
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|INTEGER
case|:
block|{
specifier|register
name|int32_t
name|data
decl_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_INT
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
name|ASN_BIT8
condition|)
comment|/* negative */
name|data
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|elem
operator|->
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
name|ASN_SHIFT8
operator|)
operator||
operator|*
name|p
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|integer
operator|=
name|data
expr_stmt|;
break|break;
block|}
case|case
name|OBJECTID
case|:
name|elem
operator|->
name|type
operator|=
name|BE_OID
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
case|case
name|ASN_NULL
case|:
name|elem
operator|->
name|type
operator|=
name|BE_NULL
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[P/U/%s]"
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|APPLICATION
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|IPADDR
case|:
name|elem
operator|->
name|type
operator|=
name|BE_INETADDR
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
case|case
name|COUNTER
case|:
case|case
name|GAUGE
case|:
case|case
name|TIMETICKS
case|:
block|{
specifier|register
name|uint32_t
name|data
decl_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_UNS
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|elem
operator|->
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator|+
operator|*
name|p
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|uns
operator|=
name|data
expr_stmt|;
break|break;
block|}
case|case
name|COUNTER64
case|:
block|{
specifier|register
name|uint32_t
name|high
decl_stmt|,
name|low
decl_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_UNS64
expr_stmt|;
name|high
operator|=
literal|0
operator|,
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|elem
operator|->
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|high
operator|=
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|low
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|24
operator|)
expr_stmt|;
name|low
operator|=
operator|(
name|low
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|high
operator|=
name|high
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|low
operator|=
name|low
expr_stmt|;
break|break;
block|}
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[P/A/%s]"
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONTEXT
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|NOSUCHOBJECT
case|:
name|elem
operator|->
name|type
operator|=
name|BE_NOSUCHOBJECT
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NOSUCHINSTANCE
case|:
name|elem
operator|->
name|type
operator|=
name|BE_NOSUCHINST
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|ENDOFMIBVIEW
case|:
name|elem
operator|->
name|type
operator|=
name|BE_ENDOFMIBVIEW
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[P/%s/%s]"
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|name
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONSTRUCTED
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|UNIVERSAL
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SEQUENCE
case|:
name|elem
operator|->
name|type
operator|=
name|BE_SEQ
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"C/U/%s"
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONTEXT
case|:
name|elem
operator|->
name|type
operator|=
name|BE_PDU
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"C/%s/%s"
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|name
operator|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|p
operator|+=
name|elem
operator|->
name|asnlen
expr_stmt|;
name|len
operator|-=
name|elem
operator|->
name|asnlen
expr_stmt|;
return|return
name|elem
operator|->
name|asnlen
operator|+
name|hdr
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Display the ASN.1 object represented by the BE object.  * This used to be an integral part of asn1_parse() before the intermediate  * BE form was added.  */
end_comment

begin_function
specifier|static
name|int
name|asn1_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|->
name|data
operator|.
name|raw
decl_stmt|;
name|uint32_t
name|asnlen
init|=
name|elem
operator|->
name|asnlen
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
switch|switch
condition|(
name|elem
operator|->
name|type
condition|)
block|{
case|case
name|BE_OCTET
case|:
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|asnlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"_%.2x"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_NULL
case|:
break|break;
case|case
name|BE_OID
case|:
block|{
name|int
name|o
init|=
literal|0
decl_stmt|,
name|first
init|=
operator|-
literal|1
decl_stmt|,
name|i
init|=
name|asnlen
decl_stmt|;
if|if
condition|(
operator|!
name|ndo
operator|->
name|ndo_sflag
operator|&&
operator|!
name|ndo
operator|->
name|ndo_nflag
operator|&&
name|asnlen
operator|>
literal|2
condition|)
block|{
specifier|const
name|struct
name|obj_abrev
modifier|*
name|a
init|=
operator|&
name|obj_abrev_list
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|a_len
init|=
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|a
operator|->
name|node
condition|;
name|a
operator|++
control|)
block|{
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|a_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|a
operator|->
name|oid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|a_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objp
operator|=
name|a
operator|->
name|node
operator|->
name|child
expr_stmt|;
name|i
operator|-=
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|a
operator|->
name|prefix
operator|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
operator|!
name|ndo
operator|->
name|ndo_sflag
operator|&&
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|o
operator|=
operator|(
name|o
operator|<<
name|ASN_SHIFT7
operator|)
operator|+
operator|(
operator|*
name|p
operator|&
operator|~
name|ASN_BIT8
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
name|ASN_LONGLEN
condition|)
continue|continue;
comment|/* 			 * first subitem encodes two items with 1st*OIDMUX+2nd 			 * (see X.690:1997 clause 8.19 for the details) 			 */
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|ndo
operator|->
name|ndo_nflag
condition|)
name|objp
operator|=
name|mibroot
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|o
operator|/
name|OIDMUX
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|2
condition|)
name|s
operator|=
literal|2
expr_stmt|;
name|OBJ_PRINT
argument_list|(
name|s
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|o
operator|-=
name|s
operator|*
name|OIDMUX
expr_stmt|;
block|}
name|OBJ_PRINT
argument_list|(
name|o
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|first
operator|<
literal|0
condition|)
name|first
operator|=
literal|0
expr_stmt|;
name|o
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BE_INT
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%d"
operator|,
name|elem
operator|->
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_UNS
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%u"
operator|,
name|elem
operator|->
name|data
operator|.
name|uns
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_UNS64
case|:
block|{
comment|/* idea borrowed from by Marshall Rose */
name|double
name|d
decl_stmt|;
name|int
name|j
decl_stmt|,
name|carry
decl_stmt|;
name|char
modifier|*
name|cpf
decl_stmt|,
modifier|*
name|cpl
decl_stmt|,
name|last
index|[
literal|6
index|]
decl_stmt|,
name|first
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|high
operator|==
literal|0
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%u"
operator|,
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|low
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|=
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|high
operator|*
literal|4294967296.0
expr_stmt|;
comment|/* 2^32 */
if|if
condition|(
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|high
operator|<=
literal|0x1fffff
condition|)
block|{
name|d
operator|+=
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|low
expr_stmt|;
if|#
directive|if
literal|0
comment|/*is looks illegal, but what is the intention?*/
block|ND_PRINT((ndo, "%.f", d));
else|#
directive|else
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%f"
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|d
operator|+=
operator|(
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|low
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*is looks illegal, but what is the intention?*/
block|snprintf(first, sizeof(first), "%.f", d);
else|#
directive|else
name|snprintf
argument_list|(
name|first
argument_list|,
sizeof|sizeof
argument_list|(
name|first
argument_list|)
argument_list|,
literal|"%f"
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|,
literal|"%5.5d"
argument_list|,
name|elem
operator|->
name|data
operator|.
name|uns64
operator|.
name|low
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
for|for
control|(
name|carry
operator|=
literal|0
operator|,
name|cpf
operator|=
name|first
operator|+
name|strlen
argument_list|(
name|first
argument_list|)
operator|-
literal|1
operator|,
name|cpl
operator|=
name|last
operator|+
literal|4
init|;
name|cpl
operator|>=
name|last
condition|;
name|cpf
operator|--
operator|,
name|cpl
operator|--
control|)
block|{
name|j
operator|=
name|carry
operator|+
operator|(
operator|*
name|cpf
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|cpl
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|9
condition|)
block|{
name|j
operator|-=
literal|10
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|carry
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|cpf
operator|=
name|j
operator|+
literal|'0'
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|first
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BE_STR
case|:
block|{
specifier|register
name|int
name|printable
init|=
literal|1
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
init|=
name|elem
operator|->
name|data
operator|.
name|str
decl_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|asnlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|printable
operator|&&
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|printable
operator|=
name|ND_ISPRINT
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|elem
operator|->
name|data
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|printable
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_printn
argument_list|(
name|ndo
argument_list|,
name|p
argument_list|,
name|asnlen
argument_list|,
name|ndo
operator|->
name|ndo_snapend
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\""
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|trunc
goto|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\""
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
name|first
condition|?
literal|"%.2x"
else|:
literal|"_%.2x"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BE_SEQ
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Seq(%u)"
operator|,
name|elem
operator|->
name|asnlen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_INETADDR
case|:
if|if
condition|(
name|asnlen
operator|!=
name|ASNLEN_INETADDR
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[inetaddr len!=%d]"
operator|,
name|ASNLEN_INETADDR
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|asnlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
operator|(
name|i
operator|==
name|asnlen
operator|-
literal|1
operator|)
condition|?
literal|"%u"
else|:
literal|".%u"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BE_NOSUCHOBJECT
case|:
case|case
name|BE_NOSUCHINST
case|:
case|case
name|BE_ENDOFMIBVIEW
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%s]"
operator|,
name|Class
index|[
name|EXCEPTIONS
index|]
operator|.
name|Id
index|[
name|elem
operator|->
name|id
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_PDU
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s(%u)"
operator|,
name|Class
index|[
name|CONTEXT
index|]
operator|.
name|Id
index|[
name|elem
operator|->
name|id
index|]
operator|,
name|elem
operator|->
name|asnlen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_ANY
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[BE_ANY!?]"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[be!?]"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * This is a brute force ASN.1 printer: recurses to dump an entire structure.  * This will work for any ASN.1 stream, not just an SNMP PDU.  *  * By adding newlines and spaces at the correct places, this would print in  * Rose-Normal-Form.  *  * This is not currently used.  */
end_comment

begin_function
specifier|static
name|void
name|asn1_decode
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|p
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|==
name|BE_SEQ
operator|||
name|elem
operator|.
name|type
operator|==
name|BE_PDU
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" {"
operator|)
argument_list|)
expr_stmt|;
name|asn1_decode
argument_list|(
name|elem
operator|.
name|data
operator|.
name|raw
argument_list|,
name|elem
operator|.
name|asnlen
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" }"
operator|)
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|i
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBSMI
end_ifdef

begin_struct
struct|struct
name|smi2be
block|{
name|SmiBasetype
name|basetype
decl_stmt|;
name|int
name|be
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|smi2be
name|smi2betab
index|[]
init|=
block|{
block|{
name|SMI_BASETYPE_INTEGER32
block|,
name|BE_INT
block|}
block|,
block|{
name|SMI_BASETYPE_OCTETSTRING
block|,
name|BE_STR
block|}
block|,
block|{
name|SMI_BASETYPE_OCTETSTRING
block|,
name|BE_INETADDR
block|}
block|,
block|{
name|SMI_BASETYPE_OBJECTIDENTIFIER
block|,
name|BE_OID
block|}
block|,
block|{
name|SMI_BASETYPE_UNSIGNED32
block|,
name|BE_UNS
block|}
block|,
block|{
name|SMI_BASETYPE_INTEGER64
block|,
name|BE_NONE
block|}
block|,
block|{
name|SMI_BASETYPE_UNSIGNED64
block|,
name|BE_UNS64
block|}
block|,
block|{
name|SMI_BASETYPE_FLOAT32
block|,
name|BE_NONE
block|}
block|,
block|{
name|SMI_BASETYPE_FLOAT64
block|,
name|BE_NONE
block|}
block|,
block|{
name|SMI_BASETYPE_FLOAT128
block|,
name|BE_NONE
block|}
block|,
block|{
name|SMI_BASETYPE_ENUM
block|,
name|BE_INT
block|}
block|,
block|{
name|SMI_BASETYPE_BITS
block|,
name|BE_STR
block|}
block|,
block|{
name|SMI_BASETYPE_UNKNOWN
block|,
name|BE_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|smi_decode_oid
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|,
name|unsigned
name|int
modifier|*
name|oid
parameter_list|,
name|unsigned
name|int
name|oidsize
parameter_list|,
name|unsigned
name|int
modifier|*
name|oidlen
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|->
name|data
operator|.
name|raw
decl_stmt|;
name|uint32_t
name|asnlen
init|=
name|elem
operator|->
name|asnlen
decl_stmt|;
name|int
name|o
init|=
literal|0
decl_stmt|,
name|first
init|=
operator|-
literal|1
decl_stmt|,
name|i
init|=
name|asnlen
decl_stmt|;
name|unsigned
name|int
name|firstval
decl_stmt|;
for|for
control|(
operator|*
name|oidlen
operator|=
literal|0
init|;
name|ndo
operator|->
name|ndo_sflag
operator|&&
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|o
operator|=
operator|(
name|o
operator|<<
name|ASN_SHIFT7
operator|)
operator|+
operator|(
operator|*
name|p
operator|&
operator|~
name|ASN_BIT8
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
name|ASN_LONGLEN
condition|)
continue|continue;
comment|/* 		 * first subitem encodes two items with 1st*OIDMUX+2nd 		 * (see X.690:1997 clause 8.19 for the details) 		 */
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|firstval
operator|=
name|o
operator|/
name|OIDMUX
expr_stmt|;
if|if
condition|(
name|firstval
operator|>
literal|2
condition|)
name|firstval
operator|=
literal|2
expr_stmt|;
name|o
operator|-=
name|firstval
operator|*
name|OIDMUX
expr_stmt|;
if|if
condition|(
operator|*
name|oidlen
operator|<
name|oidsize
condition|)
block|{
name|oid
index|[
operator|(
operator|*
name|oidlen
operator|)
operator|++
index|]
operator|=
name|firstval
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|oidlen
operator|<
name|oidsize
condition|)
block|{
name|oid
index|[
operator|(
operator|*
name|oidlen
operator|)
operator|++
index|]
operator|=
name|o
expr_stmt|;
block|}
name|o
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smi_check_type
parameter_list|(
name|SmiBasetype
name|basetype
parameter_list|,
name|int
name|be
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|smi2betab
index|[
name|i
index|]
operator|.
name|basetype
operator|!=
name|SMI_BASETYPE_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smi2betab
index|[
name|i
index|]
operator|.
name|basetype
operator|==
name|basetype
operator|&&
name|smi2betab
index|[
name|i
index|]
operator|.
name|be
operator|==
name|be
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smi_check_a_range
parameter_list|(
name|SmiType
modifier|*
name|smiType
parameter_list|,
name|SmiRange
modifier|*
name|smiRange
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|smiType
operator|->
name|basetype
condition|)
block|{
case|case
name|SMI_BASETYPE_OBJECTIDENTIFIER
case|:
case|case
name|SMI_BASETYPE_OCTETSTRING
case|:
if|if
condition|(
name|smiRange
operator|->
name|minValue
operator|.
name|value
operator|.
name|unsigned32
operator|==
name|smiRange
operator|->
name|maxValue
operator|.
name|value
operator|.
name|unsigned32
condition|)
block|{
name|ok
operator|=
operator|(
name|elem
operator|->
name|asnlen
operator|==
name|smiRange
operator|->
name|minValue
operator|.
name|value
operator|.
name|unsigned32
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
operator|(
name|elem
operator|->
name|asnlen
operator|>=
name|smiRange
operator|->
name|minValue
operator|.
name|value
operator|.
name|unsigned32
operator|&&
name|elem
operator|->
name|asnlen
operator|<=
name|smiRange
operator|->
name|maxValue
operator|.
name|value
operator|.
name|unsigned32
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SMI_BASETYPE_INTEGER32
case|:
name|ok
operator|=
operator|(
name|elem
operator|->
name|data
operator|.
name|integer
operator|>=
name|smiRange
operator|->
name|minValue
operator|.
name|value
operator|.
name|integer32
operator|&&
name|elem
operator|->
name|data
operator|.
name|integer
operator|<=
name|smiRange
operator|->
name|maxValue
operator|.
name|value
operator|.
name|integer32
operator|)
expr_stmt|;
break|break;
case|case
name|SMI_BASETYPE_UNSIGNED32
case|:
name|ok
operator|=
operator|(
name|elem
operator|->
name|data
operator|.
name|uns
operator|>=
name|smiRange
operator|->
name|minValue
operator|.
name|value
operator|.
name|unsigned32
operator|&&
name|elem
operator|->
name|data
operator|.
name|uns
operator|<=
name|smiRange
operator|->
name|maxValue
operator|.
name|value
operator|.
name|unsigned32
operator|)
expr_stmt|;
break|break;
case|case
name|SMI_BASETYPE_UNSIGNED64
case|:
comment|/* XXX */
break|break;
comment|/* case SMI_BASETYPE_INTEGER64: SMIng */
comment|/* case SMI_BASETYPE_FLOAT32: SMIng */
comment|/* case SMI_BASETYPE_FLOAT64: SMIng */
comment|/* case SMI_BASETYPE_FLOAT128: SMIng */
case|case
name|SMI_BASETYPE_ENUM
case|:
case|case
name|SMI_BASETYPE_BITS
case|:
case|case
name|SMI_BASETYPE_UNKNOWN
case|:
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smi_check_range
parameter_list|(
name|SmiType
modifier|*
name|smiType
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|SmiRange
modifier|*
name|smiRange
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
for|for
control|(
name|smiRange
operator|=
name|smiGetFirstRange
argument_list|(
name|smiType
argument_list|)
init|;
name|smiRange
condition|;
name|smiRange
operator|=
name|smiGetNextRange
argument_list|(
name|smiRange
argument_list|)
control|)
block|{
name|ok
operator|=
name|smi_check_a_range
argument_list|(
name|smiType
argument_list|,
name|smiRange
argument_list|,
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|SmiType
modifier|*
name|parentType
decl_stmt|;
name|parentType
operator|=
name|smiGetParentType
argument_list|(
name|smiType
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentType
condition|)
block|{
name|ok
operator|=
name|smi_check_range
argument_list|(
name|parentType
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|SmiNode
modifier|*
name|smi_print_variable
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|unsigned
name|int
name|oid
index|[
literal|128
index|]
decl_stmt|,
name|oidlen
decl_stmt|;
name|SmiNode
modifier|*
name|smiNode
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
operator|*
name|status
operator|=
name|smi_decode_oid
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|,
name|oid
argument_list|,
sizeof|sizeof
argument_list|(
name|oid
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|,
operator|&
name|oidlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|status
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|smiNode
operator|=
name|smiGetNodeByOID
argument_list|(
name|oidlen
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smiNode
condition|)
block|{
operator|*
name|status
operator|=
name|asn1_print
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s::"
operator|,
name|smiGetNodeModule
argument_list|(
name|smiNode
argument_list|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|smiNode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smiNode
operator|->
name|oidlen
operator|<
name|oidlen
condition|)
block|{
for|for
control|(
name|i
operator|=
name|smiNode
operator|->
name|oidlen
init|;
name|i
operator|<
name|oidlen
condition|;
name|i
operator|++
control|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|".%u"
operator|,
name|oid
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
name|smiNode
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smi_print_value
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|SmiNode
modifier|*
name|smiNode
parameter_list|,
name|u_char
name|pduid
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|oid
index|[
literal|128
index|]
decl_stmt|,
name|oidlen
decl_stmt|;
name|SmiType
modifier|*
name|smiType
decl_stmt|;
name|SmiNamedNumber
modifier|*
name|nn
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|smiNode
operator|||
operator|!
operator|(
name|smiNode
operator|->
name|nodekind
operator|&
operator|(
name|SMI_NODEKIND_SCALAR
operator||
name|SMI_NODEKIND_COLUMN
operator|)
operator|)
condition|)
block|{
return|return
name|asn1_print
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|)
return|;
block|}
if|if
condition|(
name|elem
operator|->
name|type
operator|==
name|BE_NOSUCHOBJECT
operator|||
name|elem
operator|->
name|type
operator|==
name|BE_NOSUCHINST
operator|||
name|elem
operator|->
name|type
operator|==
name|BE_ENDOFMIBVIEW
condition|)
block|{
return|return
name|asn1_print
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|)
return|;
block|}
if|if
condition|(
name|NOTIFY_CLASS
argument_list|(
name|pduid
argument_list|)
operator|&&
name|smiNode
operator|->
name|access
operator|<
name|SMI_ACCESS_NOTIFY
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[notNotifyable]"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|READ_CLASS
argument_list|(
name|pduid
argument_list|)
operator|&&
name|smiNode
operator|->
name|access
operator|<
name|SMI_ACCESS_READ_ONLY
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[notReadable]"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WRITE_CLASS
argument_list|(
name|pduid
argument_list|)
operator|&&
name|smiNode
operator|->
name|access
operator|<
name|SMI_ACCESS_READ_WRITE
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[notWritable]"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RESPONSE_CLASS
argument_list|(
name|pduid
argument_list|)
operator|&&
name|smiNode
operator|->
name|access
operator|==
name|SMI_ACCESS_NOT_ACCESSIBLE
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[noAccess]"
operator|)
argument_list|)
expr_stmt|;
block|}
name|smiType
operator|=
name|smiGetNodeType
argument_list|(
name|smiNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smiType
condition|)
block|{
return|return
name|asn1_print
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|smi_check_type
argument_list|(
name|smiType
operator|->
name|basetype
argument_list|,
name|elem
operator|->
name|type
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[wrongType]"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|smi_check_range
argument_list|(
name|smiType
argument_list|,
name|elem
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[outOfRange]"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* resolve bits to named bits */
comment|/* check whether instance identifier is valid */
comment|/* apply display hints (integer, octetstring) */
comment|/* convert instance identifier to index type values */
switch|switch
condition|(
name|elem
operator|->
name|type
condition|)
block|{
case|case
name|BE_OID
case|:
if|if
condition|(
name|smiType
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_BITS
condition|)
block|{
comment|/* print bit labels */
block|}
else|else
block|{
name|smi_decode_oid
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|,
name|oid
argument_list|,
sizeof|sizeof
argument_list|(
name|oid
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|,
operator|&
name|oidlen
argument_list|)
expr_stmt|;
name|smiNode
operator|=
name|smiGetNodeByOID
argument_list|(
name|oidlen
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|smiNode
condition|)
block|{
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s::"
operator|,
name|smiGetNodeModule
argument_list|(
name|smiNode
argument_list|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|smiNode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|smiNode
operator|->
name|oidlen
operator|<
name|oidlen
condition|)
block|{
for|for
control|(
name|i
operator|=
name|smiNode
operator|->
name|oidlen
init|;
name|i
operator|<
name|oidlen
condition|;
name|i
operator|++
control|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|".%u"
operator|,
name|oid
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BE_INT
case|:
if|if
condition|(
name|smiType
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_ENUM
condition|)
block|{
for|for
control|(
name|nn
operator|=
name|smiGetFirstNamedNumber
argument_list|(
name|smiType
argument_list|)
init|;
name|nn
condition|;
name|nn
operator|=
name|smiGetNextNamedNumber
argument_list|(
name|nn
argument_list|)
control|)
block|{
if|if
condition|(
name|nn
operator|->
name|value
operator|.
name|value
operator|.
name|integer32
operator|==
name|elem
operator|->
name|data
operator|.
name|integer
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|nn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(%d)"
operator|,
name|elem
operator|->
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
return|return
name|asn1_print
argument_list|(
name|ndo
argument_list|,
name|elem
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General SNMP header  *	SEQUENCE {  *		version INTEGER {version-1(0)},  *		community OCTET STRING,  *		data ANY	-- PDUs  *	}  * PDUs for all but Trap: (see rfc1157 from page 15 on)  *	SEQUENCE {  *		request-id INTEGER,  *		error-status INTEGER,  *		error-index INTEGER,  *		varbindlist SEQUENCE OF  *			SEQUENCE {  *				name ObjectName,  *				value ObjectValue  *			}  *	}  * PDU for Trap:  *	SEQUENCE {  *		enterprise OBJECT IDENTIFIER,  *		agent-addr NetworkAddress,  *		generic-trap INTEGER,  *		specific-trap INTEGER,  *		time-stamp TimeTicks,  *		varbindlist SEQUENCE OF  *			SEQUENCE {  *				name ObjectName,  *				value ObjectValue  *			}  *	}  */
end_comment

begin_comment
comment|/*  * Decode SNMP varBind  */
end_comment

begin_function
specifier|static
name|void
name|varbind_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|u_char
name|pduid
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|ind
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBSMI
name|SmiNode
modifier|*
name|smiNode
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|int
name|status
decl_stmt|;
comment|/* Sequence of varBind */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!SEQ of varbind]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|u_int
operator|)
name|count
operator|<
name|length
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%d extra after SEQ of varbind]"
operator|,
name|length
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
for|for
control|(
name|ind
operator|=
literal|1
init|;
name|length
operator|>
literal|0
condition|;
name|ind
operator|++
control|)
block|{
specifier|const
name|u_char
modifier|*
name|vbend
decl_stmt|;
name|u_int
name|vblength
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!varbind]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|vbend
operator|=
name|np
operator|+
name|count
expr_stmt|;
name|vblength
operator|=
name|length
operator|-
name|count
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* objName (OID) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_OID
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[objName!=OID]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|USE_LIBSMI
name|smiNode
operator|=
name|smi_print_variable
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|pduid
operator|!=
name|GETREQ
operator|&&
name|pduid
operator|!=
name|GETNEXTREQ
operator|&&
name|pduid
operator|!=
name|GETBULKREQ
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"="
operator|)
argument_list|)
expr_stmt|;
comment|/* objVal (ANY) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
operator|||
name|pduid
operator|==
name|GETBULKREQ
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_NULL
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[objVal!=NULL]"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LIBSMI
name|status
operator|=
name|smi_print_value
argument_list|(
name|ndo
argument_list|,
name|smiNode
argument_list|,
name|pduid
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return;
block|}
name|length
operator|=
name|vblength
expr_stmt|;
name|np
operator|=
name|vbend
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode SNMP PDUs: GetRequest, GetNextRequest, GetResponse, SetRequest,  * GetBulk, Inform, V2Trap, and Report  */
end_comment

begin_function
specifier|static
name|void
name|snmppdu_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|u_short
name|pduid
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
comment|/* reqId (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[reqId!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"R=%d "
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* errorStatus (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorStatus!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
operator|||
name|pduid
operator|==
name|SETREQ
operator|||
name|pduid
operator|==
name|INFORMREQ
operator|||
name|pduid
operator|==
name|V2TRAP
operator|||
name|pduid
operator|==
name|REPORT
operator|)
operator|&&
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|20
index|]
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorStatus(%s)!=0]"
operator|,
name|DECODE_ErrorStatus
argument_list|(
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pduid
operator|==
name|GETBULKREQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" N=%d"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|20
index|]
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %s"
operator|,
name|DECODE_ErrorStatus
argument_list|(
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* errorIndex (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorIndex!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
operator|||
name|pduid
operator|==
name|SETREQ
operator|||
name|pduid
operator|==
name|INFORMREQ
operator|||
name|pduid
operator|==
name|V2TRAP
operator|||
name|pduid
operator|==
name|REPORT
operator|)
operator|&&
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorIndex(%d)!=0]"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pduid
operator|==
name|GETBULKREQ
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" M=%d"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorIndex(%d) w/o errorStatus]"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"@%d"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[errorIndex==0]"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|varbind_print
argument_list|(
name|ndo
argument_list|,
name|pduid
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode SNMP Trap PDU  */
end_comment

begin_function
specifier|static
name|void
name|trappdu_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|generic
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* enterprise (oid) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_OID
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[enterprise!=OID]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* agent-addr (inetaddr) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INETADDR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[agent-addr!=INETADDR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* generic-trap (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[generic-trap!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|generic
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %s"
operator|,
name|DECODE_GenericTrap
argument_list|(
name|generic
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* specific-trap (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[specific-trap!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|generic
operator|!=
name|GT_ENTERPRISE
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[specific-trap(%d)!=0]"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" s=%d"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* time-stamp (TimeTicks) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_UNS
condition|)
block|{
comment|/* XXX */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[time-stamp!=TIMETICKS]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|varbind_print
argument_list|(
name|ndo
argument_list|,
name|TRAP
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode arbitrary SNMP PDUs.  */
end_comment

begin_function
specifier|static
name|void
name|pdu_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|be
name|pdu
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* PDU (Context) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|pdu
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|pdu
operator|.
name|type
operator|!=
name|BE_PDU
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[no PDU]"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|u_int
operator|)
name|count
operator|<
name|length
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%d extra after PDU]"
operator|,
name|length
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"{ "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|pdu
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* descend into PDU */
name|length
operator|=
name|pdu
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pdu
operator|.
name|data
operator|.
name|raw
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|SNMP_VERSION_1
operator|&&
operator|(
name|pdu
operator|.
name|id
operator|==
name|GETBULKREQ
operator|||
name|pdu
operator|.
name|id
operator|==
name|INFORMREQ
operator|||
name|pdu
operator|.
name|id
operator|==
name|V2TRAP
operator|||
name|pdu
operator|.
name|id
operator|==
name|REPORT
operator|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[v2 PDU in v1 message]"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|version
operator|==
name|SNMP_VERSION_2
operator|&&
name|pdu
operator|.
name|id
operator|==
name|TRAP
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[v1 PDU in v2 message]"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pdu
operator|.
name|id
condition|)
block|{
case|case
name|TRAP
case|:
name|trappdu_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETREQ
case|:
case|case
name|GETNEXTREQ
case|:
case|case
name|GETRESP
case|:
case|case
name|SETREQ
case|:
case|case
name|GETBULKREQ
case|:
case|case
name|INFORMREQ
case|:
case|case
name|V2TRAP
case|:
case|case
name|REPORT
case|:
name|snmppdu_print
argument_list|(
name|ndo
argument_list|,
name|pdu
operator|.
name|id
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" } "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode a scoped SNMP PDU.  */
end_comment

begin_function
specifier|static
name|void
name|scopedpdu_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
comment|/* Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!scoped PDU]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* contextEngineID (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[contextEngineID!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"E= "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|elem
operator|.
name|asnlen
condition|;
name|i
operator|++
control|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"0x%02X"
operator|,
name|elem
operator|.
name|data
operator|.
name|str
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* contextName (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[contextName!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"C=%.*s "
operator|,
operator|(
name|int
operator|)
name|elem
operator|.
name|asnlen
operator|,
name|elem
operator|.
name|data
operator|.
name|str
operator|)
argument_list|)
expr_stmt|;
name|pdu_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode SNMP Community Header (SNMPv1 and SNMPv2c)  */
end_comment

begin_function
specifier|static
name|void
name|community_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Community (String) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[comm!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* default community */
if|if
condition|(
operator|!
operator|(
name|elem
operator|.
name|asnlen
operator|==
sizeof|sizeof
argument_list|(
name|DEF_COMMUNITY
argument_list|)
operator|-
literal|1
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|str
argument_list|,
name|DEF_COMMUNITY
argument_list|,
sizeof|sizeof
argument_list|(
name|DEF_COMMUNITY
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* ! "public" */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"C=%.*s "
operator|,
operator|(
name|int
operator|)
name|elem
operator|.
name|asnlen
operator|,
name|elem
operator|.
name|data
operator|.
name|str
operator|)
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|pdu_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode SNMPv3 User-based Security Message Header (SNMPv3)  */
end_comment

begin_function
specifier|static
name|void
name|usm_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!usm]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* msgAuthoritativeEngineID (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgAuthoritativeEngineID!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgAuthoritativeEngineBoots (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgAuthoritativeEngineBoots!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"B=%d "
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgAuthoritativeEngineTime (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgAuthoritativeEngineTime!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"T=%d "
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgUserName (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgUserName!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"U=%.*s "
operator|,
operator|(
name|int
operator|)
name|elem
operator|.
name|asnlen
operator|,
name|elem
operator|.
name|data
operator|.
name|str
operator|)
argument_list|)
expr_stmt|;
comment|/* msgAuthenticationParameters (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgAuthenticationParameters!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgPrivacyParameters (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgPrivacyParameters!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|count
operator|<
name|length
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%d extra after usm SEQ]"
operator|,
name|length
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode SNMPv3 Message Header (SNMPv3)  */
end_comment

begin_function
specifier|static
name|void
name|v3msg_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|int
name|model
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|xnp
init|=
name|np
decl_stmt|;
name|int
name|xlength
init|=
name|length
decl_stmt|;
comment|/* Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!message]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"{ "
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* msgID (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgID!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgMaxSize (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgMaxSize!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* msgFlags (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgFlags!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|elem
operator|.
name|asnlen
operator|!=
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgFlags size %d]"
operator|,
name|elem
operator|.
name|asnlen
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|elem
operator|.
name|data
operator|.
name|str
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0x00
operator|&&
name|flags
operator|!=
literal|0x01
operator|&&
name|flags
operator|!=
literal|0x03
operator|&&
name|flags
operator|!=
literal|0x04
operator|&&
name|flags
operator|!=
literal|0x05
operator|&&
name|flags
operator|!=
literal|0x07
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgFlags=0x%02X]"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"F=%s%s%s "
operator|,
name|flags
operator|&
literal|0x01
condition|?
literal|"a"
else|:
literal|""
operator|,
name|flags
operator|&
literal|0x02
condition|?
literal|"p"
else|:
literal|""
operator|,
name|flags
operator|&
literal|0x04
condition|?
literal|"r"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
comment|/* msgSecurityModel (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgSecurityModel!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|model
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|count
operator|<
name|length
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%d extra after message SEQ]"
operator|,
name|length
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"} "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|model
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"{ USM "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[security model %d]"
operator|,
name|model
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|np
operator|=
name|xnp
operator|+
operator|(
name|np
operator|-
name|xnp
operator|)
expr_stmt|;
name|length
operator|=
name|xlength
operator|-
operator|(
name|np
operator|-
name|xnp
operator|)
expr_stmt|;
comment|/* msgSecurityParameters (OCTET STRING) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[msgSecurityParameters!=STR]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|model
operator|==
literal|3
condition|)
block|{
name|usm_print
argument_list|(
name|ndo
argument_list|,
name|elem
operator|.
name|data
operator|.
name|str
argument_list|,
name|elem
operator|.
name|asnlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"} "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"{ ScopedPDU "
operator|)
argument_list|)
expr_stmt|;
block|}
name|scopedpdu_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"} "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode SNMP header and pass on to PDU printing routines  */
end_comment

begin_function
name|void
name|snmp_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|version
init|=
literal|0
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
comment|/* initial Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[!init SEQ]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|u_int
operator|)
name|count
operator|<
name|length
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%d extra after iSEQ]"
operator|,
name|length
operator|-
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* Version (INTEGER) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[version!=INT]"
operator|)
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
condition|)
block|{
case|case
name|SNMP_VERSION_1
case|:
case|case
name|SNMP_VERSION_2
case|:
case|case
name|SNMP_VERSION_3
case|:
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"{ %s "
operator|,
name|SnmpVersion
index|[
name|elem
operator|.
name|data
operator|.
name|integer
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[version = %d]"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|version
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
switch|switch
condition|(
name|version
condition|)
block|{
case|case
name|SNMP_VERSION_1
case|:
case|case
name|SNMP_VERSION_2
case|:
name|community_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_VERSION_3
case|:
name|v3msg_print
argument_list|(
name|ndo
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[version = %d]"
operator|,
name|elem
operator|.
name|data
operator|.
name|integer
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"} "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

