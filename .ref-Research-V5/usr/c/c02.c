begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/* C compiler  Copyright 1972 Bell Telephone Laboratories, Inc.   */
end_comment

begin_include
include|#
directive|include
file|"c0h.c"
end_include

begin_macro
name|extdef
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|o
operator|,
name|width
expr_stmt|;
name|int
name|type
decl_stmt|,
name|elsize
decl_stmt|,
name|nel
decl_stmt|;
name|char
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|EOF
operator|)
operator|||
name|o
operator|==
name|SEMI
condition|)
return|return;
name|type
operator|=
literal|0
expr_stmt|;
name|xdflg
operator|=
name|FNDEL
expr_stmt|;
name|xxx
label|:
if|if
condition|(
name|o
operator|==
name|KEYW
condition|)
block|{
if|if
condition|(
name|cval
operator|==
name|EXTERN
condition|)
block|{
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
goto|goto
name|xxx
goto|;
block|}
if|if
condition|(
operator|(
name|type
operator|=
name|cval
operator|)
operator|>
name|STRUCT
condition|)
goto|goto
name|syntax
goto|;
comment|/* not type */
name|elsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|STRUCT
condition|)
block|{
name|elsize
operator|=
name|strdec
argument_list|(
operator|&
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|KEYW
condition|)
name|blkhed
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|o
operator|!=
name|NAME
condition|)
goto|goto
name|syntax
goto|;
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
do|do
block|{
name|defsym
operator|=
literal|0
expr_stmt|;
name|strflg
operator|=
literal|1
expr_stmt|;
name|decl1
argument_list|(
name|EXTERN
argument_list|,
name|type
operator|&
literal|07
argument_list|,
literal|0
argument_list|,
name|elsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|defsym
operator|)
operator|==
literal|0
condition|)
return|return;
name|cs
operator|=
name|ds
operator|->
name|name
expr_stmt|;
name|funcsym
operator|=
name|ds
expr_stmt|;
name|ds
operator|->
name|hflag
operator|=
name|FNDEL
expr_stmt|;
name|printf
argument_list|(
literal|".globl	_%.8s\n"
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|xdflg
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|ds
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
literal|030
operator|)
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|LBRACE
operator|||
name|peeksym
operator|==
name|KEYW
condition|)
name|cfunc
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
name|nel
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ds
operator|->
name|type
operator|&
literal|030
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|nel
operator|=
name|dimtab
index|[
name|ds
operator|->
name|ssp
operator|&
literal|0377
index|]
expr_stmt|;
name|ds
operator|->
name|type
operator|=
name|decref
argument_list|(
name|ds
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|width
operator|=
name|length
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|type
operator|==
name|STRUCT
condition|)
block|{
name|nel
operator|=
operator|*
name|width
operator|/
literal|2
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
block|}
name|ds
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cinit
argument_list|(
name|cs
argument_list|,
name|type
argument_list|,
name|nel
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|o
operator|==
name|SEMI
condition|)
return|return;
name|syntax
label|:
name|error
argument_list|(
literal|"External definition syntax"
argument_list|)
expr_stmt|;
name|errflush
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cfunc
argument_list|(
argument|cs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|savdimp
expr_stmt|;
name|strflg
operator|=
literal|0
expr_stmt|;
name|savdimp
operator|=
name|dimp
expr_stmt|;
name|printf
argument_list|(
literal|".text\n_%.8s:\n"
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|declist
argument_list|(
name|ARG
argument_list|)
expr_stmt|;
name|regvar
operator|=
literal|5
expr_stmt|;
name|retlab
operator|=
name|isn
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|LBRACE
condition|)
name|error
argument_list|(
literal|"Compound statement required"
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:jmp	rretrn\n"
argument_list|,
name|retlab
argument_list|)
expr_stmt|;
name|dimp
operator|=
name|savdimp
expr_stmt|;
block|}
end_block

begin_macro
name|cinit
argument_list|(
argument|cs
argument_list|,
argument|type
argument_list|,
argument|nel
argument_list|,
argument|awidth
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|o
operator|,
name|ninit
operator|,
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|=
name|awidth
operator|)
operator|==
literal|0
condition|)
name|width
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COMMA
operator|||
name|peeksym
operator|==
name|SEMI
condition|)
block|{
name|printf
argument_list|(
literal|".comm	_%.8s,%o\n"
argument_list|,
name|cs
argument_list|,
operator|(
name|nel
operator|*
name|width
operator|+
literal|1
operator|)
operator|&
operator|~
literal|01
argument_list|)
expr_stmt|;
return|return;
block|}
name|ninit
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".data\n_%.8s=.\n"
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|LBRACE
condition|)
block|{
do|do
name|ninit
operator|=
name|cinit1
argument_list|(
name|cs
argument_list|,
name|type
argument_list|,
name|awidth
argument_list|,
name|ninit
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|o
operator|!=
name|RBRACE
condition|)
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|peeksym
operator|=
name|o
expr_stmt|;
name|ninit
operator|=
name|cinit1
argument_list|(
name|cs
argument_list|,
name|type
argument_list|,
name|awidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ninit
operator|<
name|nel
condition|)
name|printf
argument_list|(
literal|".=.+%o\n"
argument_list|,
operator|(
name|nel
operator|-
name|ninit
operator|)
operator|*
name|width
argument_list|)
expr_stmt|;
else|else
name|nel
operator|=
name|ninit
expr_stmt|;
if|if
condition|(
name|nel
operator|>
literal|1
operator|&&
operator|(
name|type
operator|&
literal|030
operator|)
operator|!=
name|ARRAY
operator|&&
operator|(
name|type
operator|&
literal|07
operator|)
operator|!=
name|STRUCT
condition|)
name|error
argument_list|(
literal|"Too many initializers"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nel
operator|&
name|width
operator|)
operator|&
literal|01
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|".even\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cinit1
argument_list|(
argument|cs
argument_list|,
argument|type
argument_list|,
argument|awidth
argument_list|,
argument|ninit
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|sf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|s
decl_stmt|;
specifier|register
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|STRING
operator|&&
name|type
operator|==
name|ARRAY
operator|+
name|CHAR
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ninit
condition|)
name|bxdec
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|".text\n_%.8s=L%d\n"
argument_list|,
name|cs
argument_list|,
name|cval
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|nchstr
operator|+
literal|1
operator|)
operator|&
operator|~
literal|01
operator|)
return|;
block|}
if|if
condition|(
name|peeksym
operator|==
name|RBRACE
condition|)
return|return
operator|(
name|ninit
operator|)
return|;
name|initflg
operator|++
expr_stmt|;
name|s
operator|=
name|tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|=
name|awidth
operator|)
operator|==
literal|0
condition|)
name|width
operator|=
name|length
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|initflg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|".byte "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|op
operator|!=
name|CON
condition|)
name|bxdec
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
if|if
condition|(
name|s
operator|->
name|op
operator|==
name|CON
condition|)
block|{
name|printf
argument_list|(
literal|"%o\n"
argument_list|,
name|s
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|INIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sf
operator|=
name|fcval
expr_stmt|;
name|printf
argument_list|(
literal|"%o;%o\n"
argument_list|,
name|sf
argument_list|)
expr_stmt|;
goto|goto
name|flt
goto|;
case|case
literal|8
case|:
name|printf
argument_list|(
literal|"%o;%o;%o;%o\n"
argument_list|,
name|fcval
argument_list|)
expr_stmt|;
if|if
condition|(
name|awidth
operator|==
literal|0
condition|)
name|ninit
operator|=
operator|+
literal|3
expr_stmt|;
name|flt
label|:
if|if
condition|(
name|s
operator|->
name|op
operator|==
name|FCON
operator|||
name|s
operator|->
name|op
operator|==
name|SFCON
condition|)
break|break;
default|default:
name|bxdec
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|++
name|ninit
operator|)
return|;
block|}
end_block

begin_macro
name|bxdec
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Inconsistent external initialization"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|statement
argument_list|(
argument|d
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|o
operator|,
name|o1
operator|,
name|o2
expr_stmt|;
name|int
name|o3
decl_stmt|,
name|o4
decl_stmt|;
name|struct
name|tnode
modifier|*
name|np
decl_stmt|;
name|stmt
label|:
switch|switch
condition|(
name|o
operator|=
name|symbol
argument_list|()
condition|)
block|{
case|case
name|EOF
case|:
name|error
argument_list|(
literal|"Unexpected EOF"
argument_list|)
expr_stmt|;
case|case
name|SEMI
case|:
case|case
name|RBRACE
case|:
return|return;
case|case
name|LBRACE
case|:
if|if
condition|(
name|d
condition|)
block|{
name|o2
operator|=
name|blkhed
argument_list|()
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|proflg
condition|)
name|o
operator|=
literal|"jsr\tr5,mrsave;0f;%o\n.bss\n0:.=.+2\n.text\n"
expr_stmt|;
else|else
name|o
operator|=
literal|"jsr	r5,rsave; %o\n"
expr_stmt|;
name|printf
argument_list|(
name|o
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|eof
condition|)
block|{
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|RBRACE
condition|)
return|return;
name|peeksym
operator|=
name|o
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Missing '}'"
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEYW
case|:
switch|switch
condition|(
name|cval
condition|)
block|{
case|case
name|GOTO
case|:
if|if
condition|(
name|o1
operator|=
name|simplegoto
argument_list|()
condition|)
name|branch
argument_list|(
name|o1
argument_list|)
expr_stmt|;
else|else
name|dogoto
argument_list|()
expr_stmt|;
goto|goto
name|semi
goto|;
case|case
name|RETURN
case|:
name|doret
argument_list|()
expr_stmt|;
goto|goto
name|semi
goto|;
case|case
name|IF
case|:
name|np
operator|=
name|pexpr
argument_list|()
expr_stmt|;
name|o2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|o1
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
condition|)
switch|switch
condition|(
name|cval
condition|)
block|{
case|case
name|GOTO
case|:
if|if
condition|(
name|o2
operator|=
name|simplegoto
argument_list|()
condition|)
goto|goto
name|simpif
goto|;
name|cbranch
argument_list|(
name|np
argument_list|,
name|o2
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dogoto
argument_list|()
expr_stmt|;
name|label
argument_list|(
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|hardif
goto|;
case|case
name|RETURN
case|:
if|if
condition|(
name|nextchar
argument_list|()
operator|==
literal|';'
condition|)
block|{
name|o2
operator|=
name|retlab
expr_stmt|;
goto|goto
name|simpif
goto|;
block|}
name|cbranch
argument_list|(
name|np
argument_list|,
name|o1
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|doret
argument_list|()
expr_stmt|;
name|label
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|o2
operator|++
expr_stmt|;
goto|goto
name|hardif
goto|;
case|case
name|BREAK
case|:
name|o2
operator|=
name|brklab
expr_stmt|;
goto|goto
name|simpif
goto|;
case|case
name|CONTIN
case|:
name|o2
operator|=
name|contlab
expr_stmt|;
name|simpif
label|:
name|chconbrk
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|np
argument_list|,
name|o2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hardif
label|:
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|SEMI
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
operator|(
name|o1
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
operator|&&
name|cval
operator|==
name|ELSE
condition|)
goto|goto
name|stmt
goto|;
name|peeksym
operator|=
name|o1
expr_stmt|;
return|return;
block|}
name|peeksym
operator|=
name|o1
expr_stmt|;
name|cbranch
argument_list|(
name|np
argument_list|,
name|o1
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
operator|&&
name|cval
operator|==
name|ELSE
condition|)
block|{
name|o2
operator|=
name|isn
operator|++
expr_stmt|;
name|branch
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|o2
argument_list|)
expr_stmt|;
return|return;
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
name|label
argument_list|(
name|o1
argument_list|)
expr_stmt|;
return|return;
case|case
name|WHILE
case|:
name|o1
operator|=
name|contlab
expr_stmt|;
name|o2
operator|=
name|brklab
expr_stmt|;
name|label
argument_list|(
name|contlab
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|pexpr
argument_list|()
argument_list|,
name|brklab
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|contlab
operator|=
name|o1
expr_stmt|;
name|brklab
operator|=
name|o2
expr_stmt|;
return|return;
case|case
name|BREAK
case|:
name|chconbrk
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
goto|goto
name|semi
goto|;
case|case
name|CONTIN
case|:
name|chconbrk
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
goto|goto
name|semi
goto|;
case|case
name|DO
case|:
name|o1
operator|=
name|contlab
expr_stmt|;
name|o2
operator|=
name|brklab
expr_stmt|;
name|contlab
operator|=
name|isn
operator|++
expr_stmt|;
name|brklab
operator|=
name|isn
operator|++
expr_stmt|;
name|label
argument_list|(
name|o3
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|contlab
operator|=
name|o1
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
operator|&&
name|cval
operator|==
name|WHILE
condition|)
block|{
name|cbranch
argument_list|(
name|tree
argument_list|()
argument_list|,
name|o3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|brklab
operator|=
name|o2
expr_stmt|;
goto|goto
name|semi
goto|;
block|}
goto|goto
name|syntax
goto|;
case|case
name|CASE
case|:
name|o1
operator|=
name|conexp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|COLON
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
name|swp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Case not in switch"
argument_list|)
expr_stmt|;
goto|goto
name|stmt
goto|;
block|}
if|if
condition|(
name|swp
operator|>=
name|swtab
operator|+
name|swsiz
condition|)
block|{
name|error
argument_list|(
literal|"Switch table overflow"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swp
operator|->
name|swlab
operator|=
name|isn
expr_stmt|;
operator|(
name|swp
operator|++
operator|)
operator|->
name|swval
operator|=
name|o1
expr_stmt|;
name|label
argument_list|(
name|isn
operator|++
argument_list|)
expr_stmt|;
block|}
goto|goto
name|stmt
goto|;
case|case
name|SWITCH
case|:
name|o1
operator|=
name|brklab
expr_stmt|;
name|brklab
operator|=
name|isn
operator|++
expr_stmt|;
name|np
operator|=
name|pexpr
argument_list|()
expr_stmt|;
name|chkw
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|RFORCE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|np
argument_list|)
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
name|pswitch
argument_list|()
expr_stmt|;
name|brklab
operator|=
name|o1
expr_stmt|;
return|return;
case|case
name|DEFAULT
case|:
if|if
condition|(
name|swp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Default not in switch"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|COLON
condition|)
goto|goto
name|syntax
goto|;
name|label
argument_list|(
name|deflab
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
goto|goto
name|stmt
goto|;
case|case
name|FOR
case|:
name|o1
operator|=
name|contlab
expr_stmt|;
name|o2
operator|=
name|brklab
expr_stmt|;
name|contlab
operator|=
name|isn
operator|++
expr_stmt|;
name|brklab
operator|=
name|isn
operator|++
expr_stmt|;
if|if
condition|(
name|o
operator|=
name|forstmt
argument_list|()
condition|)
goto|goto
name|syntax
goto|;
name|label
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|contlab
operator|=
name|o1
expr_stmt|;
name|brklab
operator|=
name|o2
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"Unknown keyword"
argument_list|)
expr_stmt|;
goto|goto
name|syntax
goto|;
case|case
name|NAME
case|:
if|if
condition|(
name|nextchar
argument_list|()
operator|==
literal|':'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|o1
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|o1
operator|->
name|hclass
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Redefinition"
argument_list|)
expr_stmt|;
goto|goto
name|stmt
goto|;
block|}
name|o1
operator|->
name|hclass
operator|=
name|STATIC
expr_stmt|;
name|o1
operator|->
name|htype
operator|=
name|ARRAY
expr_stmt|;
if|if
condition|(
name|o1
operator|->
name|hoffset
operator|==
literal|0
condition|)
name|o1
operator|->
name|hoffset
operator|=
name|isn
operator|++
expr_stmt|;
name|label
argument_list|(
name|o1
operator|->
name|hoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|RBRACE
condition|)
return|return;
goto|goto
name|stmt
goto|;
block|}
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|()
argument_list|,
name|efftab
argument_list|)
expr_stmt|;
name|semi
label|:
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|SEMI
condition|)
return|return;
name|syntax
label|:
name|error
argument_list|(
literal|"Statement syntax"
argument_list|)
expr_stmt|;
name|errflush
argument_list|(
name|o
argument_list|)
expr_stmt|;
goto|goto
name|stmt
goto|;
block|}
end_block

begin_define
define|#
directive|define
name|forsps
value|150
end_define

begin_macro
name|forstmt
argument_list|()
end_macro

begin_block
block|{
name|int
name|l
decl_stmt|,
name|savxpr
index|[
name|forsps
index|]
decl_stmt|;
name|int
modifier|*
name|st
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|,
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|LPARN
condition|)
return|return
operator|(
name|o
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|SEMI
condition|)
block|{
comment|/* init part */
name|peeksym
operator|=
name|o
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|()
argument_list|,
name|efftab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|SEMI
condition|)
return|return
operator|(
name|o
operator|)
return|;
block|}
name|label
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|SEMI
condition|)
block|{
comment|/* test part */
name|peeksym
operator|=
name|o
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|CBRANCH
argument_list|,
name|tree
argument_list|()
argument_list|,
name|brklab
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cctab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|SEMI
condition|)
return|return
operator|(
name|o
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|RPARN
condition|)
block|{
comment|/* incr part */
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|l
operator|=
name|contlab
expr_stmt|;
name|contlab
operator|=
name|isn
operator|++
expr_stmt|;
name|st
operator|=
name|tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
return|return
operator|(
name|o
operator|)
return|;
name|ss
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|space
operator|-
name|treebase
operator|>
name|forsps
condition|)
block|{
name|error
argument_list|(
literal|"Expression too large"
argument_list|)
expr_stmt|;
name|space
operator|=
operator|&
name|treebase
index|[
name|forsps
index|]
expr_stmt|;
block|}
name|sp2
operator|=
name|savxpr
expr_stmt|;
for|for
control|(
name|sp1
operator|=
name|treebase
init|;
name|sp1
operator|<
name|space
condition|;
control|)
operator|*
name|sp2
operator|++
operator|=
operator|*
name|sp1
operator|++
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|space
operator|=
name|ss
expr_stmt|;
name|sp2
operator|=
name|savxpr
expr_stmt|;
for|for
control|(
name|sp1
operator|=
name|treebase
init|;
name|sp1
operator|<
name|space
condition|;
control|)
operator|*
name|sp1
operator|++
operator|=
operator|*
name|sp2
operator|++
expr_stmt|;
name|label
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
name|st
argument_list|,
name|efftab
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pexpr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|o
operator|,
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|LPARN
condition|)
goto|goto
name|syntax
goto|;
name|t
operator|=
name|tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
goto|goto
name|syntax
goto|;
return|return
operator|(
name|t
operator|)
return|;
name|syntax
label|:
name|error
argument_list|(
literal|"Statement syntax"
argument_list|)
expr_stmt|;
name|errflush
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pswitch
argument_list|()
end_macro

begin_block
block|{
name|int
modifier|*
name|sswp
decl_stmt|,
name|swlab
decl_stmt|;
specifier|register
name|int
modifier|*
name|swb
decl_stmt|,
modifier|*
name|wswp
decl_stmt|,
name|dl
decl_stmt|;
name|swb
operator|=
name|sswp
operator|=
name|swp
expr_stmt|;
if|if
condition|(
name|swp
operator|==
literal|0
condition|)
name|swb
operator|=
name|swp
operator|=
name|swtab
expr_stmt|;
name|branch
argument_list|(
name|swlab
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
name|dl
operator|=
name|deflab
expr_stmt|;
name|deflab
operator|=
literal|0
expr_stmt|;
name|statement
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|swlab
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
comment|/* switch is pseudo-expression */
name|label
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deflab
condition|)
block|{
name|deflab
operator|=
name|isn
operator|++
expr_stmt|;
name|label
argument_list|(
name|deflab
argument_list|)
expr_stmt|;
block|}
name|wswp
operator|=
name|swp
expr_stmt|;
name|putw
argument_list|(
name|wswp
operator|-
name|swb
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|putw
argument_list|(
name|deflab
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|putw
argument_list|(
literal|4
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
comment|/* table 4 is switch */
name|putw
argument_list|(
name|line
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|swb
operator|<
name|wswp
condition|)
name|putw
argument_list|(
operator|*
name|swb
operator|++
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|deflab
operator|=
name|dl
expr_stmt|;
name|swp
operator|=
name|sswp
expr_stmt|;
block|}
end_block

begin_macro
name|blkhed
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|pl
expr_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|cs
decl_stmt|;
name|autolen
operator|=
literal|6
expr_stmt|;
name|declist
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pl
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|paraml
condition|)
block|{
name|parame
operator|->
name|hoffset
operator|=
literal|0
expr_stmt|;
name|cs
operator|=
name|paraml
expr_stmt|;
name|paraml
operator|=
name|paraml
operator|->
name|hoffset
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|htype
operator|==
name|FLOAT
condition|)
name|cs
operator|->
name|htype
operator|=
name|DOUBLE
expr_stmt|;
name|cs
operator|->
name|hoffset
operator|=
name|pl
expr_stmt|;
name|cs
operator|->
name|hclass
operator|=
name|AUTO
expr_stmt|;
if|if
condition|(
operator|(
name|cs
operator|->
name|htype
operator|&
literal|030
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|cs
operator|->
name|htype
operator|=
operator|-
literal|020
expr_stmt|;
comment|/* set ptr */
name|cs
operator|->
name|ssp
operator|++
expr_stmt|;
comment|/* pop dims */
block|}
name|pl
operator|=
operator|+
name|rlength
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cs
operator|=
name|hshtab
init|;
name|cs
operator|<
name|hshtab
operator|+
name|hshsiz
condition|;
name|cs
operator|++
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* check tagged structure */
if|if
condition|(
name|cs
operator|->
name|hclass
operator|>
name|KEYWC
operator|&&
operator|(
name|cs
operator|->
name|htype
operator|&
literal|07
operator|)
operator|==
name|RSTRUCT
condition|)
block|{
name|cs
operator|->
name|lenp
operator|=
name|dimtab
index|[
name|cs
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|->
name|lenp
expr_stmt|;
name|cs
operator|->
name|htype
operator|=
name|cs
operator|->
name|htype
operator|&
operator|~
literal|07
operator||
name|STRUCT
expr_stmt|;
block|}
if|if
condition|(
name|cs
operator|->
name|hclass
operator|==
name|STRTAG
operator|&&
name|dimtab
index|[
name|cs
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Undefined structure: %.8s"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|hclass
operator|==
name|ARG
condition|)
name|error
argument_list|(
literal|"Not an argument: %.8s"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|osleft
operator|=
name|ossiz
expr_stmt|;
name|space
operator|=
name|treebase
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|SETREG
argument_list|,
name|regvar
argument_list|)
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|autolen
operator|)
return|;
block|}
end_block

begin_macro
name|blkend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hshtab
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|cs
operator|=
name|hshtab
init|;
name|cs
operator|<
name|hshtab
operator|+
name|hshsiz
condition|;
name|cs
operator|++
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|hclass
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%.8s undefined"
argument_list|,
name|cs
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cs
operator|->
name|hflag
operator|&
name|FNDEL
operator|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hshused
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|errflush
argument_list|(
argument|ao
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|o
expr_stmt|;
name|o
operator|=
name|ao
expr_stmt|;
while|while
condition|(
name|o
operator|>
name|RBRACE
condition|)
comment|/* ; { } */
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
end_block

begin_macro
name|declist
argument_list|(
argument|skwd
argument_list|)
end_macro

begin_block
block|{
name|int
name|o
decl_stmt|,
name|elsize
decl_stmt|,
name|ndec
decl_stmt|;
specifier|register
name|offset
operator|,
name|tkw
operator|,
name|skw
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|ndec
operator|=
literal|0
expr_stmt|;
name|tkw
operator|=
operator|-
literal|1
expr_stmt|;
name|skw
operator|=
name|skwd
expr_stmt|;
name|elsize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
condition|)
switch|switch
condition|(
name|cval
condition|)
block|{
case|case
name|AUTO
case|:
case|case
name|STATIC
case|:
case|case
name|EXTERN
case|:
case|case
name|REG
case|:
if|if
condition|(
name|skw
condition|)
name|error
argument_list|(
literal|"Conflict in storage class"
argument_list|)
expr_stmt|;
name|skw
operator|=
name|cval
expr_stmt|;
name|ndec
operator|++
expr_stmt|;
if|if
condition|(
name|tkw
operator|<
literal|0
condition|)
continue|continue;
goto|goto
name|list
goto|;
case|case
name|STRUCT
case|:
name|o
operator|=
name|cval
expr_stmt|;
name|elsize
operator|=
name|strdec
argument_list|(
operator|&
name|o
argument_list|,
name|skw
operator|==
name|MOS
argument_list|)
expr_stmt|;
name|cval
operator|=
name|o
expr_stmt|;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
name|ndec
operator|++
expr_stmt|;
if|if
condition|(
name|tkw
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Type clash"
argument_list|)
expr_stmt|;
name|tkw
operator|=
name|cval
expr_stmt|;
if|if
condition|(
name|skw
operator|==
literal|0
condition|)
continue|continue;
goto|goto
name|list
goto|;
default|default:
goto|goto
name|brk1
goto|;
block|}
name|brk1
label|:
name|peeksym
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|ndec
operator|==
literal|0
condition|)
return|return
operator|(
name|offset
operator|)
return|;
name|list
label|:
if|if
condition|(
name|tkw
operator|<
literal|0
condition|)
name|tkw
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|skw
operator|==
literal|0
condition|)
name|skw
operator|=
name|AUTO
expr_stmt|;
name|offset
operator|=
name|declare
argument_list|(
name|skw
argument_list|,
name|tkw
argument_list|,
name|offset
argument_list|,
name|elsize
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_macro
name|strdec
argument_list|(
argument|tkwp
argument_list|,
argument|mosf
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|tkwp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|elsize
operator|,
name|o
expr_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ssym
decl_stmt|;
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
name|mosflg
operator|=
literal|1
expr_stmt|;
name|ssym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
condition|)
block|{
name|ssym
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|==
literal|0
condition|)
block|{
name|ssym
operator|->
name|hclass
operator|=
name|STRTAG
expr_stmt|;
name|ssym
operator|->
name|lenp
operator|=
name|dimp
expr_stmt|;
name|chkdim
argument_list|()
expr_stmt|;
name|dimtab
index|[
name|dimp
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|STRTAG
condition|)
name|redec
argument_list|()
expr_stmt|;
name|mosflg
operator|=
name|mosf
expr_stmt|;
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
block|}
name|mosflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|LBRACE
condition|)
block|{
if|if
condition|(
name|ssym
operator|==
literal|0
condition|)
block|{
name|syntax
label|:
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|STRTAG
condition|)
name|error
argument_list|(
literal|"Bad structure name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elsize
operator|=
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|tkwp
operator|=
name|RSTRUCT
expr_stmt|;
name|elsize
operator|=
name|ssym
expr_stmt|;
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|defsym
expr_stmt|;
name|mosflg
operator|=
literal|0
expr_stmt|;
name|elsize
operator|=
name|declist
argument_list|(
name|MOS
argument_list|)
expr_stmt|;
if|if
condition|(
name|elsize
operator|&
literal|01
condition|)
name|elsize
operator|++
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACE
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
name|ssym
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
condition|)
name|error
argument_list|(
literal|"%.8s redeclared"
argument_list|,
name|ssym
operator|->
name|name
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|=
name|elsize
expr_stmt|;
block|}
block|}
return|return
operator|(
name|elsize
operator|)
return|;
block|}
end_block

begin_macro
name|chkdim
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dimp
operator|>=
name|dimsiz
condition|)
block|{
name|error
argument_list|(
literal|"Dimension/struct table overflow"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

