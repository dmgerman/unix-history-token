begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/* C compiler  Copyright 1972 Bell Telephone Laboratories, Inc.   */
end_comment

begin_include
include|#
directive|include
file|"c0h.c"
end_include

begin_macro
name|decref
argument_list|(
argument|at
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|t
expr_stmt|;
name|t
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|&
operator|~
literal|07
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Illegal indirection"
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|t
operator|>>
literal|2
operator|)
operator|&
operator|~
literal|07
operator||
name|t
operator|&
literal|07
operator|)
return|;
block|}
end_block

begin_macro
name|incref
argument_list|(
argument|t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|t
operator|<<
literal|2
operator|)
operator|&
operator|~
literal|034
operator||
operator|(
name|t
operator|&
literal|07
operator|)
operator||
name|PTR
operator|)
return|;
block|}
end_block

begin_macro
name|cbranch
argument_list|(
argument|tree
argument_list|,
argument|lbl
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|CBRANCH
argument_list|,
name|tree
argument_list|,
name|lbl
argument_list|,
name|cond
argument_list|)
argument_list|,
name|cctab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rcexpr
argument_list|(
argument|tree
argument_list|,
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|int
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
operator|,
operator|*
name|sp
expr_stmt|;
if|if
condition|(
name|tree
operator|==
literal|0
condition|)
return|return;
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|c
operator|=
name|space
operator|-
name|treebase
expr_stmt|;
name|sp
operator|=
name|treebase
expr_stmt|;
name|putw
argument_list|(
name|c
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|putw
argument_list|(
name|tree
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|putw
argument_list|(
name|table
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
name|putw
argument_list|(
name|line
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
name|putw
argument_list|(
operator|*
name|sp
operator|++
argument_list|,
name|binbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|branch
argument_list|(
argument|lab
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"jbr\tL%d\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|label
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|plength
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tname
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|l
expr_stmt|;
specifier|register
name|struct
name|tname
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|t
operator|=
name|p
operator|->
name|type
operator|)
operator|&
operator|~
literal|07
operator|)
operator|==
literal|0
condition|)
comment|/* not a reference */
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|type
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|l
operator|=
name|length
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

begin_macro
name|length
argument_list|(
argument|acs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|acs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|n
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|acs
expr_stmt|;
name|t
operator|=
name|cs
operator|->
name|type
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|&
literal|030
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|t
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|=
name|dimtab
index|[
name|cs
operator|->
name|ssp
operator|&
literal|0377
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|&
operator|~
literal|07
operator|)
operator|==
name|FUNC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|>=
name|PTR
condition|)
return|return
operator|(
literal|2
operator|*
name|n
operator|)
return|;
switch|switch
condition|(
name|t
operator|&
literal|07
condition|)
block|{
case|case
name|INT
case|:
return|return
operator|(
literal|2
operator|*
name|n
operator|)
return|;
case|case
name|CHAR
case|:
return|return
operator|(
name|n
operator|)
return|;
case|case
name|FLOAT
case|:
return|return
operator|(
literal|4
operator|*
name|n
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|*
name|n
operator|)
return|;
case|case
name|STRUCT
case|:
return|return
operator|(
name|n
operator|*
name|dimtab
index|[
name|cs
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|)
return|;
case|case
name|RSTRUCT
case|:
name|error
argument_list|(
literal|"Bad structure"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
argument_list|(
literal|"Compiler error (length)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rlength
argument_list|(
argument|cs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|l
operator|=
name|length
argument_list|(
name|cs
argument_list|)
operator|)
operator|&
literal|01
operator|)
operator|!=
literal|0
condition|)
name|l
operator|++
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

begin_macro
name|simplegoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hshtab
modifier|*
name|csp
decl_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
operator|&&
name|nextchar
argument_list|()
operator|==
literal|';'
condition|)
block|{
name|csp
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|&&
name|csp
operator|->
name|htype
operator|==
literal|0
condition|)
block|{
name|csp
operator|->
name|htype
operator|=
name|ARRAY
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hoffset
operator|==
literal|0
condition|)
name|csp
operator|->
name|hoffset
operator|=
name|isn
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|||
name|csp
operator|->
name|hclass
operator|==
name|STATIC
operator|)
operator|&&
name|csp
operator|->
name|htype
operator|==
name|ARRAY
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|csp
operator|->
name|hoffset
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nextchar
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|ctab
index|[
name|peekc
index|]
operator|==
name|SPACE
condition|)
name|peekc
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|peekc
operator|)
return|;
block|}
end_block

begin_macro
name|chconbrk
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Break/continue error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dogoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|np
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tree
argument_list|()
expr_stmt|;
name|build
argument_list|(
name|STAR
argument_list|)
expr_stmt|;
name|chkw
argument_list|(
name|np
operator|=
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|JUMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|np
argument_list|)
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doret
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nextchar
argument_list|()
operator|!=
literal|';'
condition|)
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|RFORCE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tree
argument_list|()
argument_list|)
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

