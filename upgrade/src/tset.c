begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* **  TSET -- set terminal modes ** **	This program does sophisticated terminal initialization. **	I recommend that you include it in your .start_up or .login **	file to initialize whatever terminal you are on. ** **	There are several features: ** **	A special file or sequence (as controlled by the ttycap file) **	is sent to the terminal. ** **	Mode bits are set on a per-terminal_type basis (much better **	than UNIX itself).  This allows special delays, automatic **	tabs, etc. ** **	Erase and Kill characters can be set to whatever you want. **	Default is to change erase to control-H on a terminal which **	can overstrike, and leave it alone on anything else.  Kill **	is always left alone unless specifically requested. ** **	Terminals which are dialups or plugboard types can be aliased **	to whatever type you may have in your home or office.  Thus, **	if you know that when you dial up you will always be on a **	TI 733, you can specify that fact to tset. ** **	The htmp file, used by ex, etc., can be updated. ** **	The current terminal type can be queried. ** **	Usage: **		tset [-] [-r] [-EC] [-eC] [-d type] [-p type] **			[-b type] [-h] [-u] [type] ** **		In systems with environments, use: **			setenv TERM `tset - ...` ** **	Positional Parameters: **		type -- the terminal type to force.  If this is **			specified, initialization is for this **			terminal type. ** **	Flags: **		- -- report terminal type.  Whatever type is **			decided on is reported. **		-r -- report to user, on diagnostic output instead **			of standard output. **		-EC -- set the erase character to C on all terminals **			except those which cannot backspace (e.g., **			a TTY 33).  C defaults to control-H. **		-eC -- set the erase character to C on all terminals. **			C defaults to control-H.  If neither -E or -e **			are specified, the erase character is set to **			control-H if the terminal can both backspace **			and not overstrike (e.g., a CRT).  If the erase **			character is NULL (zero byte), it will be reset **			to '#' if nothing else is specified. **		-kC -- set the kill character to C on all terminals. **			Default for C is control-X.  If not specified, **			the kill character is untouched; however, if **			not specified and the kill character is NULL **			(zero byte), the kill character is set to '@'. **		-d type -- set the dialup type to be type.  If the **			terminal type seems to be dialup, make it **			'type' instead.  There need not be a space **			between 'd' and 'type'. **		-p type -- ditto for a plugboard. **		-b type -- ditto for a bussiplexer. **		-h -- don't read htmp file.  Normally the terminal type **			is determined by reading the htmp file (unless **			-d or -p are specified).  This forces a read **			of the ttytype file -- useful when htmp is **			somehow wrong.  On a version seven system, this **			flag means don't look at the TERM entry in **			the environment. **		-u -- don't update htmp.  It seemed like this should **			be put in.  Note that htmp is never actually **			written if there are no changes, so don't bother **			bother using this for efficiency reasons alone. **			On version seven systems this flag is ignored. ** **	Files: **		/etc/ttytype **			contains a terminal id -> terminal type **			mapping; used when -h, -d, or -p is used. **		/etc/termcap **			a terminal_type -> terminal_capabilities **			mapping. ** **	Return Codes: **		-1 -- couldn't open ttycap. **		1 -- bad terminal type, or standard output not tty. **		0 -- ok. ** **	Defined Constants: **		DIALUP -- the type code for a dialup port **		PLUGBOARD -- the code for a plugboard port. **		BUSSIPLEXER -- the code for a bussiplexer port. **		BACKSPACE -- control-H, the default for -e. **		CONTROLX -- control-X, the default for -k. **		OLDERASE -- the system default erase character. **		OLDKILL -- the system default kill character. **		FILEDES -- the file descriptor to do the operation **			on, nominally 1 or 2. **		STDOUT -- the standard output file descriptor. **		UIDMASK -- the bit pattern to mask with the getuid() **			call to get just the user id. ** **	Requires: **		Routines to handle htmp, ttytype, and ttycap. ** **	Compilation Flags: **		PLUGBOARD -- if defined, accept the -p flag. **		BUSSIPLEXER -- if defined, accept the -b flag. **		FULLLOGIN -- if defined, login sets the ttytype from **			/etc/ttytype file. **		VERSION7 -- if set, use environments, not htmp. **			Also, use 'ioctl' not 'stty' -- to get type- **			ahead. **		GTTYN -- if set, uses generalized tty names. ** **	Compilation Instructions: **		cc -n -O tset.c -lX **		mv a.out tset **		chown bin tset **		chmod 4755 tset ** **		where 'bin' should be whoever owns the 'htmp' file. **		If 'htmp' is 666, then tset need not be setuid. ** **	Author: **		Eric Allman **		Electronics Research Labs **		U.C. Berkeley ** **	History: **		3/79 -- Use ioctl in version7. **		12/78 -- modified for eventual migration to VAX/UNIX, **			so the '-' option is changed to output only **			the terminal type to STDOUT instead of **			FILEDES.  FULLLOGIN flag added.  BUSSIPLEXER **			and -r added. **		9/78 -- '-' and '-p' options added (now fully **			compatible with ttytype!), and spaces are **			permitted between the -d and the type. **		8/78 -- The sense of -h and -u were reversed, and the **			-f flag is dropped -- same effect is available **			by just stating the terminal type. **		10/77 -- This version, in much it's previous state, **			written by Eric Allman. */
end_comment

begin_define
define|#
directive|define
name|BACKSPACE
value|('H'& 037)
end_define

begin_define
define|#
directive|define
name|CONTROLX
value|('X'& 037)
end_define

begin_define
define|#
directive|define
name|OLDERASE
value|'#'
end_define

begin_define
define|#
directive|define
name|OLDKILL
value|'@'
end_define

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_define
define|#
directive|define
name|DIALUP
value|"du"
end_define

begin_define
define|#
directive|define
name|PLUGBOARD
value|"pb"
end_define

begin_define
define|#
directive|define
name|BUSSIPLEXER
value|"bx"
end_define

begin_comment
comment|/* # define	FULLLOGIN	FULLLOGIN	login does everything */
end_comment

begin_comment
comment|/* # define	VERSION7	VERSION7	   version seven flag */
end_comment

begin_comment
comment|/* # define	GTTYN		GTTYN		   general tty names */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VERSION7
end_ifdef

begin_define
define|#
directive|define
name|UIDMASK
value|0177777
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UIDMASK
value|0377
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_typedef
typedef|typedef
name|char
modifier|*
name|ttyid_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
name|ttyid_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_decl_stmt
name|char
name|Erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new erase character */
end_comment

begin_decl_stmt
name|char
name|Kill_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new kill character */
end_comment

begin_decl_stmt
name|char
name|Specialerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set => Erase_char only on terminals with backspace */
end_comment

begin_decl_stmt
name|ttyid_t
name|Ttyid
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal identifier */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Ttytype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Dialtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if dialup terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Plugtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if plugboard port */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Bxtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if bussiplexer port */
end_comment

begin_decl_stmt
name|int
name|Dash_u
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't-update-htmp flag */
end_comment

begin_decl_stmt
name|int
name|Dash_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't-read-htmp flag */
end_comment

begin_decl_stmt
name|int
name|Report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report current type */
end_comment

begin_decl_stmt
name|int
name|Ureport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report to user */
end_comment

begin_decl_stmt
name|char
name|Usage
index|[]
init|=
literal|"usage: tset [-] [-r] [-eC] [-kC] [-d T] [-p T] [-b T] [-h] [-u] [type]\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Capbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line from /etc/ttycap for this Ttytype */
end_comment

begin_struct
struct|struct
name|delay
block|{
name|int
name|d_delay
decl_stmt|;
name|int
name|d_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"tset.del.h"
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|sgttyb
name|mode
decl_stmt|;
name|struct
name|sgttyb
name|oldmode
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|auto
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|int
name|mdvect
index|[
literal|2
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|VERSION7
specifier|extern
name|char
modifier|*
name|hsgettype
parameter_list|()
function_decl|;
else|#
directive|else
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GTTYN
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* scan argument list and collect flags */
name|error
operator|=
literal|0
expr_stmt|;
name|command
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* report current terminal type */
name|Report
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* report to user */
name|Ureport
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* special erase: operate on all but TTY33 */
name|Specialerase
operator|++
expr_stmt|;
comment|/* exlicit fall-through to -e case */
case|case
literal|'e'
case|:
comment|/* erase character */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|Erase_char
operator|=
name|BACKSPACE
expr_stmt|;
else|else
name|Erase_char
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
case|case
literal|'k'
case|:
comment|/* kill character */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|Kill_char
operator|=
name|CONTROLX
expr_stmt|;
else|else
name|Kill_char
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
comment|/* dialup type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|Dialtype
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|Dialtype
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|PLUGBOARD
case|case
literal|'p'
case|:
comment|/* plugboard type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|Plugtype
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|Plugtype
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUSSIPLEXER
case|case
literal|'b'
case|:
comment|/* bussiplexer type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|Bxtype
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|Bxtype
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
endif|#
directive|endif
case|case
literal|'h'
case|:
comment|/* don't get type from htmp */
name|Dash_h
operator|++
expr_stmt|;
continue|continue;
ifndef|#
directive|ifndef
name|VERSION7
case|case
literal|'u'
case|:
comment|/* don't update htmp */
name|Dash_u
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
name|prs
argument_list|(
literal|"Bad flag "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* terminal type */
name|Ttytype
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|prs
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FULLLOGIN
comment|/* if dialup is specified, check ttytype not htmp */
if|if
condition|(
name|Dialtype
operator|!=
literal|0
operator|||
name|Plugtype
operator|!=
literal|0
operator|||
name|Bxtype
operator|!=
literal|0
condition|)
name|Dash_h
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* determine terminal id if needed */
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|Ttytype
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|||
operator|!
name|Dash_u
operator|)
condition|)
ifndef|#
directive|ifndef
name|VERSION7
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
else|#
directive|else
name|Ttyid
operator|=
name|ttyname
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VERSION7
comment|/* get htmp if ever used */
if|if
condition|(
operator|!
name|Dash_u
operator|||
operator|(
name|Ttytype
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
operator|)
condition|)
block|{
comment|/* get htmp entry */
name|hget
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
comment|/* if not for this user, look at ttytype file */
if|if
condition|(
name|hgettype
argument_list|()
operator|==
literal|0
operator|||
name|hgetuid
argument_list|()
operator|!=
operator|(
name|getuid
argument_list|()
operator|&
name|UIDMASK
operator|)
condition|)
name|Dash_h
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* find terminal type (if not already known) */
if|if
condition|(
name|Ttytype
operator|==
literal|0
condition|)
block|{
comment|/* get type from /etc/ttytype or /etc/htmp */
if|if
condition|(
operator|!
name|Dash_h
condition|)
block|{
ifndef|#
directive|ifndef
name|VERSION7
name|Ttytype
operator|=
name|hsgettype
argument_list|()
expr_stmt|;
else|#
directive|else
name|Ttytype
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|Ttytype
operator|==
literal|0
condition|)
block|{
name|Ttytype
operator|=
name|stypeof
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
comment|/* check for dialup or plugboard override */
if|if
condition|(
name|Dialtype
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|Ttytype
argument_list|,
name|DIALUP
argument_list|,
literal|2
argument_list|)
condition|)
name|Ttytype
operator|=
name|Dialtype
expr_stmt|;
ifdef|#
directive|ifdef
name|PLUGBOARD
elseif|else
if|if
condition|(
name|Plugtype
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|Ttytype
argument_list|,
name|PLUGBOARD
argument_list|,
literal|2
argument_list|)
condition|)
name|Ttytype
operator|=
name|Plugtype
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUSSIPLEXER
elseif|else
if|if
condition|(
name|Bxtype
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|Ttytype
argument_list|,
name|BUSSIPLEXER
argument_list|,
literal|2
argument_list|)
condition|)
name|Ttytype
operator|=
name|Bxtype
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Ttytype now contains a pointer to the type of the terminal */
if|if
condition|(
name|gtty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Not a terminal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bmove
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
comment|/* get terminal capabilities */
switch|switch
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|Ttytype
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|prs
argument_list|(
literal|"Cannot open ttycap file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|prs
argument_list|(
literal|"Type "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|Ttytype
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" unknown\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* report type if appropriate */
if|if
condition|(
name|Report
operator|||
name|Ureport
condition|)
block|{
comment|/* find first alias (if any) */
for|for
control|(
name|p
operator|=
name|Capbuf
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|=
name|Capbuf
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|bufp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|Report
condition|)
block|{
operator|*
name|p
operator|=
literal|'\n'
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|bufp
argument_list|,
name|p
operator|+
literal|1
operator|-
name|bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ureport
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|prs
argument_list|(
literal|"Terminal type is "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|i
expr_stmt|;
block|}
comment|/* determine erase and kill characters */
if|if
condition|(
name|Specialerase
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Erase_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|.
name|sg_erase
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|OLDERASE
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|BACKSPACE
expr_stmt|;
block|}
else|else
name|mode
operator|.
name|sg_erase
operator|=
name|Erase_char
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_kill
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|OLDKILL
expr_stmt|;
if|if
condition|(
name|Kill_char
operator|!=
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|Kill_char
expr_stmt|;
comment|/* set modes */
name|setdelay
argument_list|(
literal|"dC"
argument_list|,
name|CRdelay
argument_list|,
name|CRbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dN"
argument_list|,
name|NLdelay
argument_list|,
name|NLbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dB"
argument_list|,
name|BSdelay
argument_list|,
name|BSbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dF"
argument_list|,
name|FFdelay
argument_list|,
name|FFbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dT"
argument_list|,
name|TBdelay
argument_list|,
name|TBbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
name|command
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|LCASE
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|LCASE
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|EVENP
operator||
name|ODDP
operator||
name|RAW
operator|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|ODDP
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|.
name|sg_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
operator||
name|ODDP
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
comment|/* new line, not line feed */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CRMOD
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* half duplex */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* print tabs */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
ifdef|#
directive|ifdef
name|VERSION7
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
name|stty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* output startup string */
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"is"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|prs
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"if"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* tell about changing erase and kill characters */
name|reportek
argument_list|(
literal|"Erase"
argument_list|,
name|mode
operator|.
name|sg_erase
argument_list|,
name|oldmode
operator|.
name|sg_erase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
name|reportek
argument_list|(
literal|"Kill"
argument_list|,
name|mode
operator|.
name|sg_kill
argument_list|,
name|oldmode
operator|.
name|sg_kill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VERSION7
comment|/* update htmp */
if|if
condition|(
operator|!
name|Dash_u
condition|)
block|{
if|if
condition|(
name|Ttyid
operator|==
literal|0
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ttyid
operator|==
literal|'x'
condition|)
name|prs
argument_list|(
literal|"Cannot update htmp\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* update htmp file only if changed */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Capbuf
argument_list|,
name|hsgettype
argument_list|()
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|hsettype
argument_list|(
name|Capbuf
index|[
literal|0
index|]
operator||
operator|(
name|Capbuf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hput
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|reportek
argument_list|(
argument|name
argument_list|,
argument|new
argument_list|,
argument|old
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|o
decl_stmt|;
specifier|register
name|char
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|o
operator|=
name|old
expr_stmt|;
name|n
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
operator|&&
name|n
operator|==
name|def
condition|)
return|return;
name|prs
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
condition|)
name|prs
argument_list|(
literal|" is "
argument_list|)
expr_stmt|;
else|else
name|prs
argument_list|(
literal|" set to "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|040
condition|)
block|{
name|prs
argument_list|(
literal|"control-"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
literal|037
operator|)
operator||
literal|0100
expr_stmt|;
block|}
name|p
operator|=
literal|"x\n"
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setdelay
argument_list|(
argument|cap
argument_list|,
argument|dtab
argument_list|,
argument|bits
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delay
name|dtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|delay
modifier|*
name|p
decl_stmt|;
comment|/* see if this capability exists at all */
name|i
operator|=
name|tgetnum
argument_list|(
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* clear out the bits, replace with new ones */
operator|*
name|flags
operator|&=
operator|~
name|bits
expr_stmt|;
comment|/* scan dtab for first entry with adequate delay */
for|for
control|(
name|p
operator|=
name|dtab
init|;
name|p
operator|->
name|d_delay
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|d_delay
operator|>=
name|i
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* use last entry if none will do */
operator|*
name|flags
operator||=
operator|(
operator|--
name|p
operator|)
operator|->
name|d_bits
expr_stmt|;
block|}
end_block

begin_macro
name|prs
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|=
name|q
operator|=
name|s
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot open "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bmove
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|length
expr_stmt|;
name|p
operator|=
name|from
expr_stmt|;
name|q
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

