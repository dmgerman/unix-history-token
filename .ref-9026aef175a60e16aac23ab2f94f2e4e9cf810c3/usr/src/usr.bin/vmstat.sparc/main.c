begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1986, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1986, 1991, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"getdev.h"
end_include

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_alldevs"
block|}
block|,
define|#
directive|define
name|X_ALLDEVS
value|0
block|{
literal|"_boottime"
block|}
block|,
define|#
directive|define
name|X_BOOTTIME
value|1
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dkinfo
modifier|*
name|dkinfo
decl_stmt|,
modifier|*
modifier|*
name|nextdk
init|=
operator|&
name|dkinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndrives
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dkadd
name|__P
argument_list|(
operator|(
name|u_long
operator|,
expr|struct
name|device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|dkselect
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|getdisks
name|__P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isdk
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INTRSTAT
value|0x01
end_define

begin_define
define|#
directive|define
name|MEMSTAT
value|0x02
end_define

begin_define
define|#
directive|define
name|SUMSTAT
value|0x04
end_define

begin_define
define|#
directive|define
name|VMSTAT
value|0x08
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|todo
decl_stmt|;
name|u_int
name|interval
decl_stmt|;
name|int
name|reps
decl_stmt|;
name|char
modifier|*
name|memf
decl_stmt|,
modifier|*
name|nlistf
decl_stmt|;
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|memf
operator|=
name|nlistf
operator|=
name|NULL
expr_stmt|;
name|interval
operator|=
name|reps
operator|=
name|todo
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:iM:mN:sw:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|reps
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|todo
operator||=
name|INTRSTAT
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|memf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|todo
operator||=
name|MEMSTAT
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|nlistf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|todo
operator||=
name|SUMSTAT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|interval
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|errexit
argument_list|(
literal|"usage: vmstat [-ims] [-c count] [-M core] \ [-N system] [-w wait] [disks]\n"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|todo
operator|==
literal|0
condition|)
name|todo
operator|=
name|VMSTAT
expr_stmt|;
comment|/* 	 * Discard setgid privileges if not the running kernel so that bad 	 * guys can't print interesting stuff from kernel memory. 	 */
if|if
condition|(
name|nlistf
operator|!=
name|NULL
operator|||
name|memf
operator|!=
name|NULL
condition|)
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|kd
operator|=
name|kvm_openfiles
argument_list|(
name|nlistf
argument_list|,
name|memf
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: kvm_openfiles: %s\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|kvm_nlist
argument_list|(
name|kd
argument_list|,
name|nl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: undefined symbols: "
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
sizeof|sizeof
argument_list|(
name|nl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|nl
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|nl
index|[
name|c
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|nl
index|[
name|c
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: kvm_nlist: %s\n"
argument_list|,
name|kvm_geterr
argument_list|(
name|kd
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|todo
operator|&
name|VMSTAT
condition|)
block|{
name|getdev
argument_list|(
name|nl
index|[
name|X_ALLDEVS
index|]
operator|.
name|n_value
argument_list|,
name|isdk
argument_list|,
name|dkadd
argument_list|)
expr_stmt|;
name|argv
operator|=
name|dkselect
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|BACKWARD_COMPATIBILITY
ifdef|#
directive|ifdef
name|BACKWARD_COMPATIBILITY
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|interval
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argv
condition|)
name|reps
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|interval
condition|)
block|{
if|if
condition|(
operator|!
name|reps
condition|)
name|reps
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reps
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|MEMSTAT
condition|)
name|domem
argument_list|()
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|SUMSTAT
condition|)
name|dosum
argument_list|()
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|INTRSTAT
condition|)
name|dointr
argument_list|()
expr_stmt|;
if|if
condition|(
name|todo
operator|&
name|VMSTAT
condition|)
name|dovmstat
argument_list|(
name|interval
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isdk
parameter_list|(
name|dv
parameter_list|)
name|struct
name|device
modifier|*
name|dv
decl_stmt|;
block|{
return|return
operator|(
name|dv
operator|->
name|dv_class
operator|==
name|DV_DISK
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dkadd
parameter_list|(
name|addr
parameter_list|,
name|dv
parameter_list|)
name|u_long
name|addr
decl_stmt|;
name|struct
name|device
modifier|*
name|dv
decl_stmt|;
block|{
specifier|register
name|struct
name|dkinfo
modifier|*
name|dk
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|dv
operator|->
name|dv_xname
expr_stmt|;
name|dk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|==
name|NULL
operator|||
operator|(
name|dk
operator|->
name|dk_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|"dkadd(%s): malloc: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nextdk
operator|=
name|dk
expr_stmt|;
name|nextdk
operator|=
operator|&
name|dk
operator|->
name|dk_next
expr_stmt|;
name|dk
operator|->
name|dk_next
operator|=
name|NULL
expr_stmt|;
name|dk
operator|->
name|dk_sel
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|dk_addr
operator|=
name|addr
expr_stmt|;
name|dk
operator|->
name|dk_2c
index|[
literal|0
index|]
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
name|dk
operator|->
name|dk_2c
index|[
literal|1
index|]
operator|=
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|dk
operator|->
name|dk_2c
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * Fill in dk_oxfer so that we can compute deltas next time. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s xfer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|kread
argument_list|(
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dkdevice
argument_list|,
name|dk_xfer
argument_list|)
argument_list|,
operator|&
name|dk
operator|->
name|dk_oxfer
argument_list|,
sizeof|sizeof
name|dk
operator|->
name|dk_oxfer
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Choose drives to be displayed.  Priority goes to (in order) drives  * supplied as arguments, default drives.  If everything isn't filled  * in and there are drives not taken care of, display the first few  * that fit.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|dkselect
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|struct
name|dkinfo
modifier|*
name|dk
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|defdrives
index|[]
decl_stmt|;
define|#
directive|define
name|BACKWARD_COMPATIBILITY
for|for
control|(
init|;
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|argv
control|)
block|{
ifdef|#
directive|ifdef
name|BACKWARD_COMPATIBILITY
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
endif|#
directive|endif
for|for
control|(
name|dk
operator|=
name|dkinfo
init|;
name|dk
operator|!=
name|NULL
condition|;
name|dk
operator|=
name|dk
operator|->
name|dk_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dk
operator|->
name|dk_name
argument_list|,
name|cp
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dk
operator|->
name|dk_sel
condition|)
block|{
name|dk
operator|->
name|dk_sel
operator|=
literal|1
expr_stmt|;
operator|++
name|ndrives
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|dk
operator|=
name|dkinfo
init|;
name|dk
operator|!=
name|NULL
operator|&&
name|ndrives
operator|<
literal|4
condition|;
name|dk
operator|=
name|dk
operator|->
name|dk_next
control|)
block|{
if|if
condition|(
name|dk
operator|->
name|dk_sel
condition|)
continue|continue;
for|for
control|(
name|cpp
operator|=
name|defdrives
init|;
operator|(
name|cp
operator|=
operator|*
name|cpp
operator|)
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|dk
operator|->
name|dk_name
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dk
operator|->
name|dk_sel
operator|=
literal|1
expr_stmt|;
operator|++
name|ndrives
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|dk
operator|=
name|dkinfo
init|;
name|dk
operator|!=
name|NULL
operator|&&
name|ndrives
operator|<
literal|4
condition|;
name|dk
operator|=
name|dk
operator|->
name|dk_next
control|)
block|{
if|if
condition|(
name|dk
operator|->
name|dk_sel
condition|)
continue|continue;
name|dk
operator|->
name|dk_sel
operator|=
literal|1
expr_stmt|;
operator|++
name|ndrives
expr_stmt|;
block|}
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

begin_function
name|long
name|getuptime
parameter_list|()
block|{
specifier|static
name|time_t
name|boottime
decl_stmt|;
name|time_t
name|now
decl_stmt|,
name|uptime
decl_stmt|;
if|if
condition|(
name|boottime
operator|==
literal|0
condition|)
name|kread
argument_list|(
name|nl
index|[
name|X_BOOTTIME
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|boottime
argument_list|,
sizeof|sizeof
name|boottime
argument_list|,
literal|"boottime"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|uptime
operator|=
name|now
operator|-
name|boottime
expr_stmt|;
if|if
condition|(
name|uptime
operator|<=
literal|0
operator|||
name|uptime
operator|>
literal|60
operator|*
literal|60
operator|*
literal|24
operator|*
literal|365
operator|*
literal|10
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: time makes no sense; namelist must be wrong.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|uptime
operator|)
return|;
block|}
end_function

end_unit

