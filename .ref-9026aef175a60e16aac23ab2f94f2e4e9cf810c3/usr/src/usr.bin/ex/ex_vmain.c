begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_vmain.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * This is the main routine for visual.  * We here decode the count and possible named buffer specification  * preceding a command and interpret a few of the commands.  * Commands which involve a target (i.e. an operator) are decoded  * in the routine operate in ex_voperate.c.  */
end_comment

begin_define
define|#
directive|define
name|forbid
parameter_list|(
name|a
parameter_list|)
value|{ if (a) goto fonfon; }
end_define

begin_macro
name|vmain
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|char
name|esave
index|[
name|TUBECOLS
index|]
decl_stmt|;
name|char
modifier|*
name|oglobp
decl_stmt|;
name|short
name|d
decl_stmt|;
name|line
modifier|*
name|addr
decl_stmt|;
name|int
name|ind
decl_stmt|,
name|nlput
decl_stmt|;
name|int
name|shouldpo
init|=
literal|0
decl_stmt|;
name|int
name|onumber
decl_stmt|,
name|olist
decl_stmt|,
argument_list|(
operator|*
name|OPline
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|OPutchar
argument_list|)
argument_list|()
decl_stmt|;
name|vch_mac
operator|=
name|VC_NOTINMAC
expr_stmt|;
comment|/* 	 * If we started as a vi command (on the command line) 	 * then go process initial commands (recover, next or tag). 	 */
if|if
condition|(
name|initev
condition|)
block|{
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
name|initev
expr_stmt|;
name|hadcnt
operator|=
name|cnt
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|tchng
expr_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
goto|goto
name|doinit
goto|;
block|}
comment|/* 	 * NB: 	 * 	 * The current line is always in the line buffer linebuf, 	 * and the cursor at the position cursor.  You should do 	 * a vsave() before moving off the line to make sure the disk 	 * copy is updated if it has changed, and a getDOT() to get 	 * the line back if you mung linebuf.  The motion 	 * routines in ex_vwind.c handle most of this. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Decode a visual command. 		 * First sync the temp file if there has been a reasonable 		 * amount of change.  Clear state for decoding of next 		 * command. 		 */
name|TSYNC
argument_list|()
expr_stmt|;
name|vglobp
operator|=
literal|0
expr_stmt|;
name|vreg
operator|=
literal|0
expr_stmt|;
name|hold
operator|=
literal|0
expr_stmt|;
name|seenprompt
operator|=
literal|1
expr_stmt|;
name|wcursor
operator|=
literal|0
expr_stmt|;
name|Xhadcnt
operator|=
name|hadcnt
operator|=
literal|0
expr_stmt|;
name|Xcnt
operator|=
name|cnt
operator|=
literal|1
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|holdupd
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|ignore
argument_list|(
name|peekkey
argument_list|()
argument_list|)
expr_stmt|;
name|holdupd
operator|=
literal|0
expr_stmt|;
comment|/* 			if (LINE(0)< ex_ZERO) { 				vclear(); 				vcnt = 0; 				i = 3; 			} */
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
name|vcnt
operator|=
literal|0
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|vredraw
argument_list|(
name|WTOP
argument_list|)
expr_stmt|;
else|else
name|vsync
argument_list|(
name|WTOP
argument_list|)
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Gobble up counts and named buffer specifications. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|looptop
label|:
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"pc=%c"
argument_list|,
name|peekkey
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isdigit
argument_list|(
name|peekkey
argument_list|()
argument_list|)
operator|&&
name|peekkey
argument_list|()
operator|!=
literal|'0'
condition|)
block|{
name|hadcnt
operator|=
literal|1
expr_stmt|;
name|cnt
operator|=
name|vgetcnt
argument_list|()
expr_stmt|;
name|forbid
argument_list|(
name|cnt
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peekkey
argument_list|()
operator|!=
literal|'"'
condition|)
break|break;
name|ignore
argument_list|(
name|getkey
argument_list|()
argument_list|)
operator|,
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
comment|/* 			 * Buffer names be letters or digits. 			 * But not '0' as that is the source of 			 * an 'empty' named buffer spec in the routine 			 * kshift (see ex_temp.c). 			 */
name|forbid
argument_list|(
name|c
operator|==
literal|'0'
operator|||
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|vreg
operator|=
name|c
expr_stmt|;
block|}
name|reread
label|:
comment|/* 		 * Come to reread from below after some macro expansions. 		 * The call to map allows use of function key pads 		 * by performing a terminal dependent mapping of inputs. 		 */
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"pcb=%c,"
argument_list|,
name|peekkey
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|getkey
argument_list|()
expr_stmt|;
name|maphopcnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 			 * Keep mapping the char as long as it changes. 			 * This allows for double mappings, e.g., q to #, 			 * #1 to something else. 			 */
name|c
operator|=
name|op
expr_stmt|;
name|op
operator|=
name|map
argument_list|(
name|c
argument_list|,
name|arrows
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"pca=%c,"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Maybe the mapped to char is a count. If so, we have 			 * to go back to the "for" to interpret it. Likewise 			 * for a buffer name. 			 */
if|if
condition|(
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'0'
operator|)
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|looptop
goto|;
block|}
if|if
condition|(
operator|!
name|value
argument_list|(
name|REMAP
argument_list|)
condition|)
block|{
name|c
operator|=
name|op
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|maphopcnt
operator|>
literal|256
condition|)
name|error
argument_list|(
literal|"Infinite macro loop"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|op
condition|)
do|;
comment|/* 		 * Begin to build an image of this command for possible 		 * later repeat in the buffer workcmd.  It will be copied 		 * to lastcmd by the routine setLAST 		 * if/when completely specified. 		 */
name|lastcp
operator|=
name|workcmd
expr_stmt|;
if|if
condition|(
operator|!
name|vglobp
condition|)
operator|*
name|lastcp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* 		 * First level command decode. 		 */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 		 * ^L		Clear screen e.g. after transmission error. 		 */
comment|/* 		 * ^R		Retype screen, getting rid of @ lines. 		 *		If in open, equivalent to ^L. 		 *		On terminals where the right arrow key sends 		 *		^L we make ^R act like ^L, since there is no 		 *		way to get ^L.  These terminals (adm31, tvi) 		 *		are intelligent so ^R is useless.  Soroc 		 *		will probably foul this up, but nobody has 		 *		one of them. 		 */
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'r'
argument_list|)
case|:
if|if
condition|(
name|c
operator|==
name|CTRL
argument_list|(
literal|'l'
argument_list|)
operator|||
operator|(
name|KR
operator|&&
operator|*
name|KR
operator|==
name|CTRL
argument_list|(
literal|'l'
argument_list|)
operator|)
condition|)
block|{
name|vclear
argument_list|()
expr_stmt|;
name|vdirty
argument_list|(
literal|0
argument_list|,
name|vcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
comment|/* 				 * Get a clean line, throw away the 				 * memory of what is displayed now, 				 * and move back onto the current line. 				 */
name|vclean
argument_list|()
expr_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
name|vmoveto
argument_list|(
name|dot
argument_list|,
name|cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vredraw
argument_list|(
name|WTOP
argument_list|)
expr_stmt|;
comment|/* 			 * Weird glitch -- when we enter visual 			 * in a very small window we may end up with 			 * no lines on the screen because the line 			 * at the top is too long.  This forces the screen 			 * to be expanded to make room for it (after 			 * we have printed @'s ick showing we goofed). 			 */
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
continue|continue;
comment|/* 		 * $		Escape just cancels the current command 		 *		with a little feedback. 		 */
case|case
name|ESCAPE
case|:
name|beep
argument_list|()
expr_stmt|;
continue|continue;
comment|/* 		 * @   		Macros. Bring in the macro and put it 		 *		in vmacbuf, point vglobp there and punt. 		 */
case|case
literal|'@'
case|:
name|c
operator|=
name|getesc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
name|c
operator|=
name|lastmac
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|forbid
argument_list|(
operator|!
name|islower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|lastmac
operator|=
name|c
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|CATCH
name|char
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|regbuf
argument_list|(
name|c
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmacbuf
argument_list|)
argument_list|)
expr_stmt|;
name|macpush
argument_list|(
name|tmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ONERR
name|lastmac
init|=
literal|0
decl_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
continue|continue;
name|ENDCATCH
name|vmacp
init|=
name|vmacbuf
decl_stmt|;
goto|goto
name|reread
goto|;
comment|/* 		 * .		Repeat the last (modifying) open/visual command. 		 */
case|case
literal|'.'
case|:
comment|/* 			 * Check that there was a last command, and 			 * take its count and named buffer unless they 			 * were given anew.  Special case if last command 			 * referenced a numeric named buffer -- increment 			 * the number and go to a named buffer again. 			 * This allows a sequence like "1pu.u.u... 			 * to successively look for stuff in the kill chain 			 * much as one does in EMACS with C-Y and M-Y. 			 */
name|forbid
argument_list|(
name|lastcmd
index|[
literal|0
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hadcnt
condition|)
name|lastcnt
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|vreg
condition|)
name|lastreg
operator|=
name|vreg
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|lastreg
argument_list|)
operator|&&
name|lastreg
operator|<
literal|'9'
condition|)
name|lastreg
operator|++
expr_stmt|;
name|vreg
operator|=
name|lastreg
expr_stmt|;
name|cnt
operator|=
name|lastcnt
expr_stmt|;
name|hadcnt
operator|=
name|lasthad
expr_stmt|;
name|vglobp
operator|=
name|lastcmd
expr_stmt|;
goto|goto
name|reread
goto|;
comment|/* 		 * ^U		Scroll up.  A count sticks around for 		 *		future scrolls as the scroll amount. 		 *		Attempt to hold the indentation from the 		 *		top of the screen (in logical lines). 		 * 		 * BUG:		A ^U near the bottom of the screen 		 *		on a dumb terminal (which can't roll back) 		 *		causes the screen to be cleared and then 		 *		redrawn almost as it was.  In this case 		 *		one should simply move the cursor. 		 */
case|case
name|CTRL
argument_list|(
literal|'u'
argument_list|)
case|:
if|if
condition|(
name|hadcnt
condition|)
name|ex_vSCROLL
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|=
name|ex_vSCROLL
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|ind
operator|=
name|vcline
operator|,
name|cnt
operator|+=
name|ind
expr_stmt|;
else|else
name|ind
operator|=
literal|0
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|vup
argument_list|(
name|cnt
argument_list|,
name|ind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * ^D		Scroll down.  Like scroll up. 		 */
case|case
name|CTRL
argument_list|(
literal|'d'
argument_list|)
case|:
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"before vdown in ^D, dot=%d, wdot=%d, dol=%d\n"
argument_list|,
name|lineno
argument_list|(
name|dot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|wdot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dol
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hadcnt
condition|)
name|ex_vSCROLL
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|=
name|ex_vSCROLL
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|ind
operator|=
name|vcnt
operator|-
name|vcline
operator|-
literal|1
operator|,
name|cnt
operator|+=
name|ind
expr_stmt|;
else|else
name|ind
operator|=
literal|0
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|vdown
argument_list|(
name|cnt
argument_list|,
name|ind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"before vnline in ^D, dot=%d, wdot=%d, dol=%d\n"
argument_list|,
name|lineno
argument_list|(
name|dot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|wdot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dol
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vnline
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"after vnline in ^D, dot=%d, wdot=%d, dol=%d\n"
argument_list|,
name|lineno
argument_list|(
name|dot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|wdot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dol
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
comment|/* 		 * ^E		Glitch the screen down (one) line. 		 *		Cursor left on same line in file. 		 */
case|case
name|CTRL
argument_list|(
literal|'e'
argument_list|)
case|:
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hadcnt
condition|)
name|cnt
operator|=
literal|1
expr_stmt|;
comment|/* Bottom line of file already on screen */
name|forbid
argument_list|(
name|lineDOL
argument_list|()
operator|-
name|lineDOT
argument_list|()
operator|<=
name|vcnt
operator|-
literal|1
operator|-
name|vcline
argument_list|)
expr_stmt|;
name|ind
operator|=
name|vcnt
operator|-
name|vcline
operator|-
literal|1
operator|+
name|cnt
expr_stmt|;
name|vdown
argument_list|(
name|ind
argument_list|,
name|ind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * ^Y		Like ^E but up 		 */
case|case
name|CTRL
argument_list|(
literal|'y'
argument_list|)
case|:
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hadcnt
condition|)
name|cnt
operator|=
literal|1
expr_stmt|;
name|forbid
argument_list|(
name|lineDOT
argument_list|()
operator|-
literal|1
operator|<=
name|vcline
argument_list|)
expr_stmt|;
comment|/* line 1 already there */
name|ind
operator|=
name|vcline
operator|+
name|cnt
expr_stmt|;
name|vup
argument_list|(
name|ind
argument_list|,
name|ind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * m		Mark position in mark register given 		 *		by following letter.  Return is 		 *		accomplished via ' or `; former 		 *		to beginning of line where mark 		 *		was set, latter to column where marked. 		 */
case|case
literal|'m'
case|:
comment|/* 			 * Getesc is generally used when a character 			 * is read as a latter part of a command 			 * to allow one to hit rubout/escape to cancel 			 * what you have typed so far.  These characters 			 * are mapped to 0 by the subroutine. 			 */
name|c
operator|=
name|getesc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Markreg checks that argument is a letter 			 * and also maps ' and ` to the end of the range 			 * to allow '' or `` to reference the previous 			 * context mark. 			 */
name|c
operator|=
name|markreg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|forbid
argument_list|(
name|c
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
operator|(
operator|*
name|dot
operator|&
operator|~
literal|01
operator|)
expr_stmt|;
name|ncols
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
name|cursor
expr_stmt|;
name|anymarks
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * ^F		Window forwards, with 2 lines of continuity. 		 *		Count repeats. 		 */
case|case
name|CTRL
argument_list|(
literal|'f'
argument_list|)
case|:
name|vsave
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcnt
operator|>
literal|2
condition|)
block|{
name|addr
operator|=
name|dot
operator|+
operator|(
name|vcnt
operator|-
name|vcline
operator|)
operator|-
literal|2
operator|+
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|*
name|basWLINES
expr_stmt|;
name|forbid
argument_list|(
name|addr
operator|>
name|dol
argument_list|)
expr_stmt|;
name|dot
operator|=
name|addr
expr_stmt|;
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
block|}
name|vzop
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * ^B		Window backwards, with 2 lines of continuity. 		 *		Inverse of ^F. 		 */
case|case
name|CTRL
argument_list|(
literal|'b'
argument_list|)
case|:
name|vsave
argument_list|()
expr_stmt|;
if|if
condition|(
name|one
operator|+
name|vcline
operator|!=
name|dot
operator|&&
name|vcnt
operator|>
literal|2
condition|)
block|{
name|addr
operator|=
name|dot
operator|-
name|vcline
operator|+
literal|2
operator|-
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|*
name|basWLINES
expr_stmt|;
name|forbid
argument_list|(
name|addr
operator|<=
name|zero
argument_list|)
expr_stmt|;
name|dot
operator|=
name|addr
expr_stmt|;
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
block|}
name|vzop
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * z		Screen adjustment, taking a following character: 		 *			z<CR>		current line to top 		 *			z<NL>		like z<CR> 		 *			z-		current line to bottom 		 *		also z+, z^ like ^F and ^B. 		 *		A preceding count is line to use rather 		 *		than current line.  A count between z and 		 *		specifier character changes the screen size 		 *		for the redraw. 		 * 		 */
case|case
literal|'z'
case|:
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
block|{
name|i
operator|=
name|vgetcnt
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|vsetsiz
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|c
operator|=
name|getesc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
block|}
name|vsave
argument_list|()
expr_stmt|;
name|vzop
argument_list|(
name|hadcnt
argument_list|,
name|cnt
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * Y		Yank lines, abbreviation for y_ or yy. 		 *		Yanked lines can be put later if no 		 *		changes intervene, or can be put in named 		 *		buffers and put anytime in this session. 		 */
case|case
literal|'Y'
case|:
name|ungetkey
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'y'
expr_stmt|;
break|break;
comment|/* 		 * J		Join lines, 2 by default.  Count is number 		 *		of lines to join (no join operator sorry.) 		 */
case|case
literal|'J'
case|:
name|forbid
argument_list|(
name|dot
operator|==
name|dol
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
name|cnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
operator|(
name|i
operator|=
name|dol
operator|-
name|dot
operator|+
literal|1
operator|)
condition|)
name|cnt
operator|=
name|i
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|vmacchng
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
name|cursor
operator|=
name|strend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|vremote
argument_list|(
name|cnt
argument_list|,
name|join
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|notenam
operator|=
literal|"join"
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|killU
argument_list|()
expr_stmt|;
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cursor
operator|&&
name|cursor
operator|>
name|linebuf
condition|)
name|cursor
operator|--
expr_stmt|;
if|if
condition|(
name|notecnt
operator|==
literal|2
condition|)
name|notecnt
operator|=
literal|0
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * S		Substitute text for whole lines, abbrev for c_. 		 *		Count is number of lines to change. 		 */
case|case
literal|'S'
case|:
name|ungetkey
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'c'
expr_stmt|;
break|break;
comment|/* 		 * O		Create a new line above current and accept new 		 *		input text, to an escape, there. 		 *		A count specifies, for dumb terminals when 		 *		slowopen is not set, the number of physical 		 *		line space to open on the screen. 		 * 		 * o		Like O, but opens lines below. 		 */
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
name|vmacchng
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|voOpen
argument_list|(
name|c
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * C		Change text to end of line, short for c$. 		 */
case|case
literal|'C'
case|:
if|if
condition|(
operator|*
name|cursor
condition|)
block|{
name|ungetkey
argument_list|(
literal|'$'
argument_list|)
operator|,
name|c
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
goto|goto
name|appnd
goto|;
comment|/* 		 * ~	Switch case of letter under cursor 		 */
case|case
literal|'~'
case|:
block|{
name|char
name|mbuf
index|[
literal|4
index|]
decl_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'r'
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cursor
expr_stmt|;
name|mbuf
index|[
literal|2
index|]
operator|=
name|cursor
index|[
literal|1
index|]
operator|==
literal|0
condition|?
literal|0
else|:
literal|'l'
expr_stmt|;
name|mbuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|mbuf
index|[
literal|1
index|]
argument_list|)
condition|)
name|mbuf
index|[
literal|1
index|]
operator|^=
literal|' '
expr_stmt|;
comment|/* toggle the case */
name|macpush
argument_list|(
name|mbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* 		 * A		Append at end of line, short for $a. 		 */
case|case
literal|'A'
case|:
name|operate
argument_list|(
literal|'$'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|appnd
label|:
name|c
operator|=
literal|'a'
expr_stmt|;
comment|/* fall into ... */
comment|/* 		 * a		Appends text after cursor.  Text can continue 		 *		through arbitrary number of lines. 		 */
case|case
literal|'a'
case|:
if|if
condition|(
operator|*
name|cursor
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|ex_putchar
argument_list|(
operator|*
name|cursor
argument_list|)
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
goto|goto
name|insrt
goto|;
comment|/* 		 * I		Insert at beginning of whitespace of line, 		 *		short for ^i. 		 */
case|case
literal|'I'
case|:
name|operate
argument_list|(
literal|'^'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'i'
expr_stmt|;
comment|/* fall into ... */
comment|/* 		 * R		Replace characters, one for one, by input 		 *		(logically), like repeated r commands. 		 * 		 * BUG:		This is like the typeover mode of many other 		 *		editors, and is only rarely useful.  Its 		 *		implementation is a hack in a low level 		 *		routine and it doesn't work very well, e.g. 		 *		you can't move around within a R, etc. 		 */
case|case
literal|'R'
case|:
comment|/* fall into... */
comment|/* 		 * i		Insert text to an escape in the buffer. 		 *		Text is arbitrary.  This command reminds of 		 *		the i command in bare teco. 		 */
case|case
literal|'i'
case|:
name|insrt
label|:
comment|/* 			 * Common code for all the insertion commands. 			 * Save for redo, position cursor, prepare for append 			 * at command and in visual undo.  Note that nothing 			 * is doomed, unless R when all is, and save the 			 * current line in a the undo temporary buffer. 			 */
name|vmacchng
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
name|vcursat
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|prepapp
argument_list|()
expr_stmt|;
name|vnoapp
argument_list|()
expr_stmt|;
name|doomed
operator|=
name|c
operator|==
literal|'R'
condition|?
literal|10000
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VCHNG
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|CP
argument_list|(
name|vutmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* 			 * If this is a repeated command, then suppress 			 * fake insert mode on dumb terminals which looks 			 * ridiculous and wastes lots of time even at 9600B. 			 */
if|if
condition|(
name|vglobp
condition|)
name|hold
operator|=
name|HOLDQIK
expr_stmt|;
name|vappend
argument_list|(
name|c
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * ^?		An attention, normally a ^?, just beeps. 		 *		If you are a vi command within ex, then 		 *		two ATTN's will drop you back to command mode. 		 */
case|case
name|ATTN
case|:
name|beep
argument_list|()
expr_stmt|;
if|if
condition|(
name|initev
operator|||
name|peekkey
argument_list|()
operator|!=
name|ATTN
condition|)
continue|continue;
comment|/* fall into... */
comment|/* 		 * ^\		A quit always gets command mode. 		 */
case|case
name|QUIT
case|:
comment|/* 			 * Have to be careful if we were called 			 *	g/xxx/vi 			 * since a return will just start up again. 			 * So we simulate an interrupt. 			 */
if|if
condition|(
name|inglobal
condition|)
name|onintr
argument_list|()
expr_stmt|;
comment|/* fall into... */
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * q		Quit back to command mode, unless called as 		 *		vi on command line in which case dont do it 		 */
case|case
literal|'q'
case|:
comment|/* quit */
if|if
condition|(
name|initev
condition|)
block|{
name|vsave
argument_list|()
expr_stmt|;
name|CATCH
name|error
argument_list|(
literal|"Q gets ex command mode, :q leaves vi"
argument_list|)
decl_stmt|;
name|ENDCATCH
name|splitw
init|=
literal|0
decl_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* fall into... */
comment|/* 		 * Q		Is like q, but always gets to command mode 		 *		even if command line invocation was as vi. 		 */
case|case
literal|'Q'
case|:
name|vsave
argument_list|()
expr_stmt|;
comment|/* 			 * If we are in the middle of a macro, throw away 			 * the rest and fix up undo. 			 * This code copied from getbr(). 			 */
if|if
condition|(
name|vmacp
condition|)
block|{
name|vmacp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inopen
operator|==
operator|-
literal|1
condition|)
comment|/* don't screw up undo for esc esc */
name|vundkind
operator|=
name|VMANY
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
comment|/* restore old setting now that macro done */
block|}
return|return;
comment|/* 		 * ZZ		Like :x 		 */
case|case
literal|'Z'
case|:
name|forbid
argument_list|(
name|getkey
argument_list|()
operator|!=
literal|'Z'
argument_list|)
expr_stmt|;
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|"x"
expr_stmt|;
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|gogo
goto|;
comment|/* 		 * P		Put back text before cursor or before current 		 *		line.  If text was whole lines goes back 		 *		as whole lines.  If part of a single line 		 *		or parts of whole lines splits up current 		 *		line to form many new lines. 		 *		May specify a named buffer, or the delete 		 *		saving buffers 1-9. 		 * 		 * p		Like P but after rather than before. 		 */
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|vmoving
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|forbid
argument_list|(
operator|!
name|vreg
operator|&&
name|value
argument_list|(
name|UNDOMACRO
argument_list|)
operator|&&
name|inopen
operator|<
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * If previous delete was partial line, use an 			 * append or insert to put it back so as to 			 * use insert mode on intelligent terminals. 			 */
if|if
condition|(
operator|!
name|vreg
operator|&&
name|DEL
index|[
literal|0
index|]
condition|)
block|{
name|forbid
argument_list|(
operator|(
name|DEL
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
argument_list|)
expr_stmt|;
name|vglobp
operator|=
name|DEL
expr_stmt|;
name|ungetkey
argument_list|(
name|c
operator|==
literal|'p'
condition|?
literal|'a'
else|:
literal|'i'
argument_list|)
expr_stmt|;
goto|goto
name|reread
goto|;
block|}
comment|/* 			 * If a register wasn't specified, then make 			 * sure there is something to put back. 			 */
name|forbid
argument_list|(
operator|!
name|vreg
operator|&&
name|unddol
operator|==
name|dol
argument_list|)
expr_stmt|;
comment|/* 			 * If we just did a macro the whole buffer is in 			 * the undo save area.  We don't want to put THAT. 			 */
name|forbid
argument_list|(
name|vundkind
operator|==
name|VMANY
operator|&&
name|undkind
operator|==
name|UNDALL
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|vmacchng
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setLAST
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vreg
operator|&&
name|partreg
argument_list|(
name|vreg
argument_list|)
operator|||
operator|!
name|vreg
operator|&&
name|pkill
index|[
literal|0
index|]
condition|)
block|{
comment|/* 				 * Restoring multiple lines which were partial 				 * lines; will leave cursor in middle 				 * of line after shoving restored text in to 				 * split the current line. 				 */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
operator|*
name|cursor
condition|)
name|cursor
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * In whole line case, have to back up dot 				 * for P; also want to clear cursor so 				 * cursor will eventually be positioned 				 * at the beginning of the first put line. 				 */
name|cursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'P'
condition|)
block|{
name|dot
operator|--
operator|,
name|vcline
operator|--
expr_stmt|;
name|c
operator|=
literal|'p'
expr_stmt|;
block|}
block|}
name|killU
argument_list|()
expr_stmt|;
comment|/* 			 * The call to putreg can potentially 			 * bomb since there may be nothing in a named buffer. 			 * We thus put a catch in here.  If we didn't and 			 * there was an error we would end up in command mode. 			 */
name|addr
operator|=
name|dol
expr_stmt|;
comment|/* old dol */
name|CATCH
name|vremote
argument_list|(
literal|1
argument_list|,
name|vreg
condition|?
name|putreg
else|:
name|put
argument_list|,
name|vreg
argument_list|)
decl_stmt|;
name|ONERR
if|if
condition|(
name|vreg
operator|==
operator|-
literal|1
condition|)
block|{
name|splitw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'P'
condition|)
name|dot
operator|++
operator|,
name|vcline
operator|++
expr_stmt|;
goto|goto
name|pfixup
goto|;
block|}
name|ENDCATCH
name|splitw
init|=
literal|0
decl_stmt|;
name|nlput
operator|=
name|dol
operator|-
name|addr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 				 * Increment undap1, undap2 to make up 				 * for their incorrect initialization in the 				 * routine vremote before calling put/putreg. 				 */
if|if
condition|(
name|FIXUNDO
condition|)
name|undap1
operator|++
operator|,
name|undap2
operator|++
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
name|nlput
operator|--
expr_stmt|;
comment|/* 				 * After a put want current line first line, 				 * and dot was made the last line put in code 				 * run so far.  This is why we increment vcline 				 * above and decrease dot here. 				 */
name|dot
operator|-=
name|nlput
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vreplace(%d, %d, %d), undap1=%d, undap2=%d, dot=%d\n"
argument_list|,
name|vcline
argument_list|,
name|i
argument_list|,
name|nlput
argument_list|,
name|lineno
argument_list|(
name|undap1
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|undap2
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dot
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vreplace
argument_list|(
name|vcline
argument_list|,
name|i
argument_list|,
name|nlput
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
comment|/* 				 * Special case in open mode. 				 * Force action on the screen when a single 				 * line is put even if it is identical to 				 * the current line, e.g. on YP; otherwise 				 * you can't tell anything happened. 				 */
name|vjumpto
argument_list|(
name|dot
argument_list|,
name|cursor
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pfixup
label|:
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|vfixcurs
argument_list|()
expr_stmt|;
continue|continue;
comment|/* 		 * ^^		Return to previous file. 		 *		Like a :e #, and thus can be used after a 		 *		"No Write" diagnostic. 		 */
case|case
name|CTRL
argument_list|(
literal|'^'
argument_list|)
case|:
name|forbid
argument_list|(
name|hadcnt
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|ckaw
argument_list|()
expr_stmt|;
name|oglobp
operator|=
name|globp
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|AUTOWRITE
argument_list|)
condition|)
name|globp
operator|=
literal|"e! #"
expr_stmt|;
else|else
name|globp
operator|=
literal|"e #"
expr_stmt|;
goto|goto
name|gogo
goto|;
comment|/* 		 * ^]		Takes word after cursor as tag, and then does 		 *		tag command.  Read ``go right to''. 		 */
case|case
name|CTRL
argument_list|(
literal|']'
argument_list|)
case|:
name|grabtag
argument_list|()
expr_stmt|;
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|"tag"
expr_stmt|;
goto|goto
name|gogo
goto|;
comment|/* 		 *&		Like :& 		 */
case|case
literal|'&'
case|:
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|"&"
expr_stmt|;
goto|goto
name|gogo
goto|;
comment|/* 		 * ^G		Bring up a status line at the bottom of 		 *		the screen, like a :file command. 		 * 		 * BUG:		Was ^S but doesn't work in cbreak mode 		 */
case|case
name|CTRL
argument_list|(
literal|'g'
argument_list|)
case|:
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|"file"
expr_stmt|;
name|gogo
label|:
name|addr
operator|=
name|dot
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
goto|goto
name|doinit
goto|;
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* 		 * ^Z:	suspend editor session and temporarily return 		 * 	to shell.  Only works with Berkeley/IIASA process 		 *	control in kernel. 		 */
case|case
name|CTRL
argument_list|(
literal|'z'
argument_list|)
case|:
name|forbid
argument_list|(
name|dosusp
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|"stop"
expr_stmt|;
goto|goto
name|gogo
goto|;
endif|#
directive|endif
comment|/* 		 * :		Read a command from the echo area and 		 *		execute it in command mode. 		 */
case|case
literal|':'
case|:
name|forbid
argument_list|(
name|hadcnt
argument_list|)
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|i
operator|=
name|tchng
expr_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|readecho
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|esave
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|fixup
goto|;
block|}
name|getDOT
argument_list|()
expr_stmt|;
comment|/* 			 * Use the visual undo buffer to store the global 			 * string for command mode, since it is idle right now. 			 */
name|oglobp
operator|=
name|globp
expr_stmt|;
name|strcpy
argument_list|(
name|vutmp
argument_list|,
name|genbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|globp
operator|=
name|vutmp
expr_stmt|;
name|doinit
label|:
name|esave
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fixech
argument_list|()
expr_stmt|;
comment|/* 			 * Have to finagle around not to lose last 			 * character after this command (when run from ex 			 * command mode).  This is clumsy. 			 */
name|d
operator|=
name|peekc
expr_stmt|;
name|ungetchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldpo
condition|)
block|{
comment|/* 				 * So after a "Hit return..." ":", we do 				 * another "Hit return..." the next time 				 */
name|pofix
argument_list|()
expr_stmt|;
name|shouldpo
operator|=
literal|0
expr_stmt|;
block|}
name|CATCH
comment|/* 				 * Save old values of options so we can 				 * notice when they change; switch into 				 * cooked mode so we are interruptible. 				 */
name|onumber
init|=
name|value
argument_list|(
name|NUMBER
argument_list|)
decl_stmt|;
name|olist
operator|=
name|value
argument_list|(
name|LIST
argument_list|)
expr_stmt|;
name|OPline
operator|=
name|Pline
expr_stmt|;
name|OPutchar
operator|=
name|Put_char
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
name|vcook
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|zero
operator|&&
name|dol
operator|>
name|zero
condition|)
name|dot
operator|=
name|one
expr_stmt|;
ifndef|#
directive|ifndef
name|CBREAK
name|vraw
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ONERR
ifndef|#
directive|ifndef
name|CBREAK
name|vraw
parameter_list|()
function_decl|;
endif|#
directive|endif
name|copy
argument_list|(
name|esave
argument_list|,
name|vtube
index|[
name|WECHO
index|]
argument_list|,
name|TUBECOLS
argument_list|)
expr_stmt|;
name|ENDCATCH
name|fixol
parameter_list|()
function_decl|;
name|Pline
operator|=
name|OPline
expr_stmt|;
name|Put_char
operator|=
name|OPutchar
expr_stmt|;
name|ungetchar
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|globp
operator|=
name|oglobp
expr_stmt|;
comment|/* 			 * If we ended up with no lines in the buffer, make 			 * a line, and don't consider the buffer changed. 			 */
if|if
condition|(
name|dot
operator|==
name|zero
condition|)
block|{
name|fixzero
argument_list|()
expr_stmt|;
name|ex_sync
argument_list|()
expr_stmt|;
block|}
name|splitw
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Special case: did list/number options change? 			 */
if|if
condition|(
name|onumber
operator|!=
name|value
argument_list|(
name|NUMBER
argument_list|)
condition|)
name|ignorf
argument_list|(
name|setnumb
argument_list|(
name|value
argument_list|(
name|NUMBER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olist
operator|!=
name|value
argument_list|(
name|LIST
argument_list|)
condition|)
name|ignorf
argument_list|(
name|setlist
argument_list|(
name|value
argument_list|(
name|LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fixup
label|:
comment|/* 			 * If a change occurred, other than 			 * a write which clears changes, then 			 * we should allow an undo even if . 			 * didn't move. 			 * 			 * BUG: You can make this wrong by 			 * tricking around with multiple commands 			 * on one line of : escape, and including 			 * a write command there, but its not 			 * worth worrying about. 			 */
if|if
condition|(
name|FIXUNDO
operator|&&
name|tchng
operator|&&
name|tchng
operator|!=
name|i
condition|)
name|vundkind
operator|=
name|VMANY
operator|,
name|cursor
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If we are about to do another :, hold off 			 * updating of screen. 			 */
if|if
condition|(
name|vcnt
operator|<
literal|0
operator|&&
name|Peek_key
operator|==
literal|':'
condition|)
block|{
name|getDOT
argument_list|()
expr_stmt|;
name|shouldpo
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|shouldpo
operator|=
literal|0
expr_stmt|;
comment|/* 			 * In the case where the file being edited is 			 * new; e.g. if the initial state hasn't been 			 * saved yet, then do so now. 			 */
if|if
condition|(
name|unddol
operator|==
name|truedol
condition|)
block|{
name|vundkind
operator|=
name|VNONE
expr_stmt|;
name|Vlines
operator|=
name|lineDOL
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inglobal
condition|)
name|savevis
argument_list|()
expr_stmt|;
name|addr
operator|=
name|zero
expr_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|esave
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|copy
argument_list|(
name|esave
argument_list|,
name|vtube
index|[
name|WECHO
index|]
argument_list|,
name|TUBECOLS
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the current line moved reset the cursor position. 			 */
if|if
condition|(
name|dot
operator|!=
name|addr
condition|)
block|{
name|vmoving
operator|=
literal|0
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * If current line is not on screen or if we are 			 * in open mode and . moved, then redraw. 			 */
name|i
operator|=
name|vcline
operator|+
operator|(
name|dot
operator|-
name|addr
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|vcnt
operator|&&
name|i
operator|>=
operator|-
name|vcnt
operator|||
name|state
operator|!=
name|VISUAL
operator|&&
name|dot
operator|!=
name|addr
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcnt
operator|>
literal|0
condition|)
name|vcnt
operator|=
literal|0
expr_stmt|;
name|vjumpto
argument_list|(
name|dot
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Current line IS on screen. 				 * If we did a [Hit return...] then 				 * restore vcnt and clear screen if in visual 				 */
name|vcline
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vcnt
operator|<
literal|0
condition|)
block|{
name|vcnt
operator|=
operator|-
name|vcnt
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|vclear
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
block|{
name|vcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 				 * Limit max value of vcnt based on $ 				 */
name|i
operator|=
name|vcline
operator|+
name|lineDOL
argument_list|()
operator|-
name|lineDOT
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|vcnt
condition|)
name|vcnt
operator|=
name|i
expr_stmt|;
comment|/* 				 * Dirty and repaint. 				 */
name|vdirty
argument_list|(
literal|0
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
name|vrepaint
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If in visual, put back the echo area 			 * if it was clobberred. 			 */
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
block|{
name|int
name|sdc
init|=
name|destcol
decl_stmt|,
name|sdl
init|=
name|destline
decl_stmt|;
name|splitw
operator|++
expr_stmt|;
name|vigoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TUBECOLS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|esave
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|vputchar
argument_list|(
name|esave
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|splitw
operator|=
literal|0
expr_stmt|;
name|vgoto
argument_list|(
name|sdl
argument_list|,
name|sdc
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* 		 * u		undo the last changing command. 		 */
case|case
literal|'u'
case|:
name|vundo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * U		restore current line to initial state. 		 */
case|case
literal|'U'
case|:
name|ex_vUndo
argument_list|()
expr_stmt|;
continue|continue;
name|fonfon
label|:
name|beep
argument_list|()
expr_stmt|;
name|vmacp
operator|=
literal|0
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
comment|/* might have been -1 */
continue|continue;
block|}
comment|/* 		 * Rest of commands are decoded by the operate 		 * routine. 		 */
name|operate
argument_list|(
name|c
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Grab the word after the cursor so we can look for it as a tag.  */
end_comment

begin_macro
name|grabtag
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|vpastwh
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|dp
operator|=
name|lasttag
expr_stmt|;
do|do
block|{
if|if
condition|(
name|dp
operator|<
operator|&
name|lasttag
index|[
sizeof|sizeof
name|lasttag
operator|-
literal|2
index|]
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'_'
ifdef|#
directive|ifdef
name|LISPCODE
operator|||
operator|(
name|value
argument_list|(
name|LISP
argument_list|)
operator|&&
operator|*
name|cp
operator|==
literal|'-'
operator|)
endif|#
directive|endif
endif|LISPCODE
condition|)
do|;
operator|*
name|dp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Before appending lines, set up addr1 and  * the command mode undo information.  */
end_comment

begin_macro
name|prepapp
argument_list|()
end_macro

begin_block
block|{
name|addr1
operator|=
name|dot
expr_stmt|;
name|deletenone
argument_list|()
expr_stmt|;
name|addr1
operator|++
expr_stmt|;
name|appendnone
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Execute function f with the address bounds addr1  * and addr2 surrounding cnt lines starting at dot.  */
end_comment

begin_macro
name|vremote
argument_list|(
argument|cnt
argument_list|,
argument|f
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|,
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|oing
init|=
name|inglobal
decl_stmt|;
name|addr1
operator|=
name|dot
expr_stmt|;
name|addr2
operator|=
name|dot
operator|+
name|cnt
operator|-
literal|1
expr_stmt|;
name|inglobal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|undap1
operator|=
name|undap2
operator|=
name|dot
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|inglobal
operator|=
name|oing
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VMANY
expr_stmt|;
name|vmcurs
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Save the current contents of linebuf, if it has changed.  */
end_comment

begin_macro
name|vsave
argument_list|()
end_macro

begin_block
block|{
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
name|CP
argument_list|(
name|temp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|FIXUNDO
operator|&&
name|vundkind
operator|==
name|VCHNG
operator|||
name|vundkind
operator|==
name|VCAPU
condition|)
block|{
comment|/* 		 * If the undo state is saved in the temporary buffer 		 * vutmp, then we sync this into the temp file so that 		 * we will be able to undo even after we have moved off 		 * the line.  It would be possible to associate a line 		 * with vutmp but we assume that vutmp is only associated 		 * with line dot (e.g. in case ':') above, so beware. 		 */
name|prepapp
argument_list|()
expr_stmt|;
name|strcLIN
argument_list|(
name|vutmp
argument_list|)
expr_stmt|;
name|putmark
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|vremote
argument_list|(
literal|1
argument_list|,
name|yank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vundkind
operator|=
name|VMCHNG
expr_stmt|;
name|notecnt
operator|=
literal|0
expr_stmt|;
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
block|}
comment|/* 	 * Get the line out of the temp file and do nothing if it hasn't 	 * changed.  This may seem like a loss, but the line will 	 * almost always be in a read buffer so this may well avoid disk i/o. 	 */
name|getDOT
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|putmark
argument_list|(
name|dot
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|forbid
end_undef

begin_define
define|#
directive|define
name|forbid
parameter_list|(
name|a
parameter_list|)
value|if (a) { beep(); return; }
end_define

begin_comment
comment|/*  * Do a z operation.  * Code here is rather long, and very uninteresting.  */
end_comment

begin_macro
name|vzop
argument_list|(
argument|hadcnt
argument_list|,
argument|cnt
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|hadcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
comment|/* 		 * Z from open; always like a z=. 		 * This code is a mess and should be cleaned up. 		 */
name|vmoveitup
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|outline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ostop
argument_list|(
name|normf
argument_list|)
expr_stmt|;
name|setoutt
argument_list|()
expr_stmt|;
name|addr2
operator|=
name|dot
expr_stmt|;
name|vclear
argument_list|()
expr_stmt|;
name|destline
operator|=
name|WECHO
expr_stmt|;
name|zop2
argument_list|(
name|Xhadcnt
condition|?
name|Xcnt
else|:
name|value
argument_list|(
name|WINDOW
argument_list|)
operator|-
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CRTOPEN
condition|)
name|putnl
argument_list|()
expr_stmt|;
name|putNFL
argument_list|()
expr_stmt|;
name|termreset
argument_list|()
expr_stmt|;
name|Outchar
operator|=
name|vputchar
expr_stmt|;
name|ignore
argument_list|(
name|ostart
argument_list|()
argument_list|)
expr_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
name|outline
operator|=
name|destline
operator|=
literal|0
expr_stmt|;
name|vjumpto
argument_list|(
name|dot
argument_list|,
name|cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hadcnt
condition|)
block|{
name|addr
operator|=
name|zero
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|one
condition|)
name|addr
operator|=
name|one
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|dol
condition|)
name|addr
operator|=
name|dol
expr_stmt|;
name|markit
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|addr
operator|=
name|dot
operator|+
name|vcnt
operator|-
name|vcline
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|addr
operator|=
name|dot
operator|-
name|vcline
operator|-
literal|1
expr_stmt|;
name|forbid
argument_list|(
name|addr
operator|<
name|one
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'-'
expr_stmt|;
break|break;
default|default:
name|addr
operator|=
name|dot
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
case|case
literal|'-'
case|:
break|break;
case|case
literal|'^'
case|:
name|forbid
argument_list|(
name|addr
operator|<=
name|one
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|forbid
argument_list|(
name|addr
operator|>=
name|dol
argument_list|)
expr_stmt|;
comment|/* fall into ... */
case|case
name|CR
case|:
case|case
name|NL
case|:
name|c
operator|=
name|CR
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|vmoving
operator|=
literal|0
expr_stmt|;
name|vjumpto
argument_list|(
name|addr
argument_list|,
name|NOSTR
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

