begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Edward Wang at The University of California, Berkeley.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)xxflush.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ww.h"
end_include

begin_include
include|#
directive|include
file|"xx.h"
end_include

begin_include
include|#
directive|include
file|"tt.h"
end_include

begin_expr_stmt
name|xxflush
argument_list|(
name|intr
argument_list|)
specifier|register
name|intr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|xx
modifier|*
name|xp
decl_stmt|,
modifier|*
name|xq
decl_stmt|;
for|for
control|(
name|xp
operator|=
name|xx_head
init|;
name|xp
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|intr
operator|&&
name|wwinterrupt
argument_list|()
operator|)
condition|;
name|xp
operator|=
name|xq
control|)
block|{
switch|switch
condition|(
name|xp
operator|->
name|cmd
condition|)
block|{
case|case
name|xc_move
case|:
if|if
condition|(
name|xp
operator|->
name|link
operator|==
literal|0
condition|)
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|xc_scroll
case|:
name|xxflush_scroll
argument_list|(
name|xp
argument_list|)
expr_stmt|;
break|break;
case|case
name|xc_inschar
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|tt
operator|.
name|tt_nmodes
operator|=
name|xp
operator|->
name|arg3
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_inschar
call|)
argument_list|(
name|xp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|xc_insspace
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_insspace
call|)
argument_list|(
name|xp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|xc_delchar
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_delchar
call|)
argument_list|(
name|xp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|xc_clear
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_clear
call|)
argument_list|()
expr_stmt|;
break|break;
case|case
name|xc_clreos
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_clreos
call|)
argument_list|()
expr_stmt|;
break|break;
case|case
name|xc_clreol
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_clreol
call|)
argument_list|()
expr_stmt|;
break|break;
case|case
name|xc_write
case|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|,
name|xp
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|tt
operator|.
name|tt_nmodes
operator|=
name|xp
operator|->
name|arg3
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_write
call|)
argument_list|(
name|xp
operator|->
name|buf
argument_list|,
name|xp
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
block|}
name|xq
operator|=
name|xp
operator|->
name|link
expr_stmt|;
name|xxfree
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xx_head
operator|=
name|xp
operator|)
operator|==
literal|0
condition|)
block|{
name|xx_tail
operator|=
literal|0
expr_stmt|;
name|xxbufp
operator|=
name|xxbuf
expr_stmt|;
block|}
name|ttflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|xxflush_scroll
argument_list|(
name|xp
argument_list|)
specifier|register
expr|struct
name|xx
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|xx
modifier|*
name|xq
decl_stmt|;
name|top
label|:
if|if
condition|(
name|xp
operator|->
name|arg0
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * We handle retain (da and db) by putting the burden on scrolling up, 	 * which is the less common operation.  It must ensure that 	 * text is not pushed below the screen, so scrolling down doesn't 	 * have to worry about it. 	 * 	 * Try scrolling region (or scrolling the whole screen) first. 	 * Can we assume "sr" doesn't push text below the screen 	 * so we don't have to worry about retain below? 	 * What about scrolling down with a newline?  It probably does 	 * push text above (with da).  Scrolling up would then have 	 * to take care of that. 	 * It's easy to be fool proof, but that slows things down. 	 * The current solution is to disallow tt_scroll_up if da or db is true 	 * but cs (scrolling region) is not.  Again, we sacrifice scrolling 	 * up in favor of scrolling down.  The idea is having scrolling regions 	 * probably means we can scroll (even the whole screen) with impunity. 	 * This lets us work efficiently on simple terminals (use newline 	 * on the bottom to scroll), on any terminal without retain, and 	 * on vt100 style scrolling regions (I think). 	 */
if|if
condition|(
name|xp
operator|->
name|arg0
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|xq
operator|=
name|xp
operator|->
name|link
operator|)
operator|!=
literal|0
operator|&&
name|xq
operator|->
name|cmd
operator|==
name|xc_scroll
operator|&&
name|xp
operator|->
name|arg2
operator|==
name|xq
operator|->
name|arg2
operator|&&
name|xq
operator|->
name|arg0
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|xp
operator|->
name|arg1
operator|<
name|xq
operator|->
name|arg1
condition|)
block|{
if|if
condition|(
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg0
operator|<=
name|xq
operator|->
name|arg1
condition|)
block|{
name|xq
operator|->
name|arg0
operator|=
name|xp
operator|->
name|arg0
expr_stmt|;
name|xq
operator|->
name|arg1
operator|=
name|xp
operator|->
name|arg1
expr_stmt|;
name|xq
operator|->
name|arg2
operator|=
name|xp
operator|->
name|arg2
expr_stmt|;
return|return;
block|}
name|xp
operator|->
name|arg2
operator|=
name|xq
operator|->
name|arg1
operator|+
name|xp
operator|->
name|arg0
expr_stmt|;
name|xq
operator|->
name|arg0
operator|+=
name|xp
operator|->
name|arg0
expr_stmt|;
name|xq
operator|->
name|arg1
operator|=
name|xp
operator|->
name|arg2
expr_stmt|;
if|if
condition|(
name|xq
operator|->
name|arg0
operator|>
literal|0
condition|)
name|xq
operator|->
name|arg1
operator|-=
name|xq
operator|->
name|arg0
expr_stmt|;
goto|goto
name|top
goto|;
block|}
else|else
block|{
if|if
condition|(
name|xp
operator|->
name|arg1
operator|-
name|xq
operator|->
name|arg0
operator|>=
name|xp
operator|->
name|arg2
condition|)
return|return;
name|xq
operator|->
name|arg2
operator|=
name|xp
operator|->
name|arg1
operator|-
name|xq
operator|->
name|arg0
expr_stmt|;
name|xp
operator|->
name|arg0
operator|+=
name|xq
operator|->
name|arg0
expr_stmt|;
name|xp
operator|->
name|arg1
operator|=
name|xq
operator|->
name|arg2
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|arg0
operator|<
literal|0
condition|)
name|xp
operator|->
name|arg1
operator|+=
name|xp
operator|->
name|arg0
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
if|if
condition|(
name|xp
operator|->
name|arg0
operator|>
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg1
condition|)
name|xp
operator|->
name|arg0
operator|=
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg1
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_scroll_down
condition|)
block|{
if|if
condition|(
name|tt
operator|.
name|tt_scroll_top
operator|!=
name|xp
operator|->
name|arg1
operator|||
name|tt
operator|.
name|tt_scroll_bot
operator|!=
name|xp
operator|->
name|arg2
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tt
operator|.
name|tt_setscroll
operator|==
literal|0
condition|)
goto|goto
name|down
goto|;
call|(
modifier|*
name|tt
operator|.
name|tt_setscroll
call|)
argument_list|(
name|xp
operator|->
name|arg1
argument_list|,
name|xp
operator|->
name|arg2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tt
operator|.
name|tt_scroll_down
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|down
label|:
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_delline
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|arg2
operator|<
name|tt
operator|.
name|tt_nrow
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_insline
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xp
operator|->
name|arg0
operator|=
operator|-
name|xp
operator|->
name|arg0
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|arg0
operator|>
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg1
condition|)
name|xp
operator|->
name|arg0
operator|=
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg1
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_scroll_up
condition|)
block|{
if|if
condition|(
name|tt
operator|.
name|tt_scroll_top
operator|!=
name|xp
operator|->
name|arg1
operator|||
name|tt
operator|.
name|tt_scroll_bot
operator|!=
name|xp
operator|->
name|arg2
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tt
operator|.
name|tt_setscroll
operator|==
literal|0
condition|)
goto|goto
name|up
goto|;
call|(
modifier|*
name|tt
operator|.
name|tt_setscroll
call|)
argument_list|(
name|xp
operator|->
name|arg1
argument_list|,
name|xp
operator|->
name|arg2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tt
operator|.
name|tt_scroll_up
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
label|:
if|if
condition|(
name|tt
operator|.
name|tt_retain
operator|||
name|xp
operator|->
name|arg2
operator|!=
name|tt
operator|.
name|tt_nrow
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg2
operator|-
name|xp
operator|->
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_delline
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|tt
operator|.
name|tt_move
call|)
argument_list|(
name|xp
operator|->
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_insline
call|)
argument_list|(
name|xp
operator|->
name|arg0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

