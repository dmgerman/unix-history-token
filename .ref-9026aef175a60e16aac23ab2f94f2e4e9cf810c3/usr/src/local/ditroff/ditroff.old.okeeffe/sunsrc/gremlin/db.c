begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)db.c	1.2	%G%  *  * This file contains routines for database manipulation for the  * SUN Gremlin picture editor.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from undodb */
end_comment

begin_extern
extern|extern UNRembAdd(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern UNRembDelete(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern UNRembMod(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from point.c */
end_comment

begin_extern
extern|extern PTModifyTextPoints(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from text.c  */
end_comment

begin_extern
extern|extern TxPutMsg(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern TxMsgOK(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from main */
end_comment

begin_extern
extern|extern SEARCH;
end_extern

begin_comment
comment|/* Search the path for filename */
end_comment

begin_extern
extern|extern TOOLINSTALLED;
end_extern

begin_comment
comment|/* cset is a pointer to the current set available to the outside world. */
end_comment

begin_decl_stmt
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine creates a new element with the specified attributes and  * links it into database db.  */
end_comment

begin_decl_stmt
name|ELT
modifier|*
name|DBCreateElt
argument_list|(
name|type
argument_list|,
name|pointlist
argument_list|,
name|brush
argument_list|,
name|size
argument_list|,
name|text
argument_list|,
name|db
argument_list|)
name|int
name|type
decl_stmt|,
name|brush
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POINT
modifier|*
name|pointlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ELT
argument_list|*
operator|(
operator|*
name|db
operator|)
argument_list|;
block|{
specifier|register
name|ELT
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|ELT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ELT
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|nextelt
operator|=
operator|*
name|db
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|ptlist
operator|=
name|pointlist
expr_stmt|;
name|temp
operator|->
name|brushf
operator|=
name|brush
expr_stmt|;
name|temp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|temp
operator|->
name|textpt
operator|=
name|text
expr_stmt|;
operator|*
name|db
operator|=
name|temp
expr_stmt|;
name|UNRembAdd
argument_list|(
name|temp
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* end DBCreateElt */
end_comment

begin_comment
comment|/*  * This routine deletes the specified element by searching the database  * for its predecessor and deleting the pointer to the element.  * Flag indicates whether or not the element was in the current set  * and is passed along for use by the undo routines.  */
end_comment

begin_expr_stmt
name|DBDelete
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
operator|,
operator|*
operator|(
operator|*
name|db
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ELT
operator|*
operator|(
operator|*
name|temp
operator|)
expr_stmt|;
name|temp
operator|=
name|db
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|!=
name|elt
condition|)
block|{
if|if
condition|(
name|DBNullelt
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no such element"
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp
operator|=
operator|&
operator|(
name|DBNextElt
argument_list|(
operator|(
operator|*
name|temp
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|UNRembDelete
argument_list|(
operator|*
name|temp
argument_list|,
name|db
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|=
name|DBNextElt
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBDelete */
end_comment

begin_define
define|#
directive|define
name|highval
value|100000
end_define

begin_comment
comment|/* arbitrary value greater than any  					 * expected distance */
end_comment

begin_comment
comment|/*  * This routine searches the database for the point closest to  * (Euclidean distance) point1.  This point is returned as point2  * and the element which contained the point is also returned.  * The point must be closer than some predefined maximum distance  * in order to be gravitated.  * If setonly == TRUE the element's "setnext" pointer is used to  * find the elements in the list, otherwise "nextelt" is used.  */
end_comment

begin_macro
name|DBGravitate
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|point
argument_list|,
argument|elt
argument_list|,
argument|db
argument_list|,
argument|setonly
argument_list|)
end_macro

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
modifier|*
name|x2
decl_stmt|,
modifier|*
name|y2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|POINT
argument_list|*
operator|(
operator|*
name|point
operator|)
argument_list|;
name|ELT
operator|*
operator|(
operator|*
name|elt
operator|)
argument_list|,
operator|*
name|db
argument_list|;
name|int
name|setonly
argument_list|;
block|{
specifier|register
name|POINT
modifier|*
name|holdpt
decl_stmt|;
specifier|register
name|ELT
modifier|*
name|temp
decl_stmt|;
specifier|register
name|t
operator|,
name|t1
operator|,
name|t2
expr_stmt|;
specifier|register
name|distance
operator|=
name|highval
expr_stmt|;
name|temp
operator|=
name|db
expr_stmt|;
operator|*
name|elt
operator|=
name|DBInit
argument_list|()
expr_stmt|;
operator|*
name|x2
operator|=
name|x1
expr_stmt|;
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|holdpt
operator|=
name|temp
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|holdpt
argument_list|)
condition|)
block|{
comment|/* Calculate the distance between the point in the data 	       base and the specified point.  Use Euclidean distance 	       except that, since we only need relative distance and 	       not an absolute number, it is not necessary to take the 	       square root.  The equation for the distance was broken up 	       as below in order to allow integer arithmetic wherever 	       possible to increase efficiency when it was discovered 	       that this routine was too slow. */
name|t1
operator|=
name|holdpt
operator|->
name|x
operator|-
name|x1
expr_stmt|;
name|t1
operator|*=
name|t1
expr_stmt|;
name|t2
operator|=
name|holdpt
operator|->
name|y
operator|-
name|y1
expr_stmt|;
name|t2
operator|*=
name|t2
expr_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|<
name|distance
operator|)
operator|&&
operator|(
name|t
operator|<
name|MAXGDIST
operator|)
condition|)
block|{
name|distance
operator|=
name|t
expr_stmt|;
operator|*
name|x2
operator|=
name|holdpt
operator|->
name|x
expr_stmt|;
operator|*
name|y2
operator|=
name|holdpt
operator|->
name|y
expr_stmt|;
operator|*
name|point
operator|=
name|holdpt
expr_stmt|;
operator|*
name|elt
operator|=
name|temp
expr_stmt|;
block|}
name|holdpt
operator|=
name|holdpt
operator|->
name|nextpt
expr_stmt|;
block|}
name|temp
operator|=
name|setonly
condition|?
name|DBNextofSet
argument_list|(
name|temp
argument_list|)
else|:
name|DBNextElt
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_expr_stmt

begin_comment
comment|/* end DBGravitate */
end_comment

begin_comment
comment|/*  * This routine returns all storage associated with the element to  * free storage.  */
end_comment

begin_expr_stmt
name|DBClearElt
argument_list|(
name|elt
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pt2
decl_stmt|;
name|pt
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|pt
argument_list|)
condition|)
block|{
name|pt2
operator|=
name|PTNextPoint
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt2
expr_stmt|;
block|}
name|free
argument_list|(
name|elt
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBClearElt */
end_comment

begin_comment
comment|/*  * This routine reads the specified file into a database and   * returns a pointer to that database.  Orient and pos are also set  * from the file.  *  * The format of a file written by gremlin is:  * the string: "gremlinfile" followed by a carriage return.  * the orientation (integer) and the x and y coordinates of a positioning  * point (float) followed by another carriage return.  * The output of 0 or more elements (see below).  * a -1 (integer) indicating end of data.  *  * The format of each element is:  * The element type (integer) followed by a carriage return.  * a list of 0 or more pairs of point coordinates (float) each on separate  * lines and terminated by the coordinates -1.0 -1.0.  * the brush (font) and size (integer) the element was defined with then<cr>  * the length (integer) of the string followed by the string terminated with  * a carriage return.  *  * All numbers are printed using standard C output conversion (ascii).  *  * +++ NEW FORMAT FOR SUN +++  *  * "sungremlinfile" is keyword in place of "gremlinfile"  *  * Point lists are terminated by a line containing a single asterik ('*')  * to allow the legal point (-1.00 -1.00) in the point list.  All negative  * coordinates are now legal.  Element types are indicated by ascii text,  * eg, POLYGON, VECTOR, ARC, BOTLEFT, TOPCENT, etc.  */
end_comment

begin_function
name|ELT
modifier|*
name|DBRead
parameter_list|(
name|filename
parameter_list|,
name|orient
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
modifier|*
name|orient
decl_stmt|;
name|POINT
modifier|*
name|pos
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|POpen
argument_list|()
decl_stmt|;
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
name|elist
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
name|string
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|txt
decl_stmt|,
modifier|*
name|prealname
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|i
decl_stmt|,
name|brush
decl_stmt|,
name|size
decl_stmt|,
name|done
decl_stmt|,
name|lastpoint
decl_stmt|,
name|sunfile
decl_stmt|;
name|sunfile
operator|=
name|FALSE
expr_stmt|;
name|elist
operator|=
name|DBInit
argument_list|()
expr_stmt|;
name|fp
operator|=
name|POpen
argument_list|(
name|filename
argument_list|,
operator|&
name|prealname
argument_list|,
name|SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"can't open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
if|if
condition|(
name|TOOLINSTALLED
condition|)
comment|/* no message if reading startup edit file */
name|TxPutMsg
argument_list|(
literal|"reading file..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"gremlinfile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"sungremlinfile"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"not gremlin file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
name|sunfile
operator|=
name|TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d%f%f\n"
argument_list|,
name|orient
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|pos
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|string
argument_list|)
operator|==
name|EOF
condition|)
block|{
comment|/* element type */
name|error
argument_list|(
literal|"error in file format"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|=
name|DBGetType
argument_list|(
name|string
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* no more data */
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%f%f\n"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* read first point */
comment|/* Files created on the SUN have point lists terminated 	     * by a line containing only an asterik ('*').  Files 	     * created on the AED have point lists terminated by the 	     * coordinate pair (-1.00 -1.00). 	     */
name|lastpoint
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|string
argument_list|,
literal|127
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* SUN gremlin file */
name|lastpoint
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%f%f"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
operator|-
literal|1.00
operator|&&
name|y
operator|==
operator|-
literal|1.00
operator|)
operator|&&
operator|(
operator|!
name|sunfile
operator|)
condition|)
name|lastpoint
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|lastpoint
condition|)
do|;
ifdef|#
directive|ifdef
name|oldway
while|while
condition|(
operator|(
name|x
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|y
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* plist terminated by -1, -1 */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%f%f\n"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d%d\n"
argument_list|,
operator|&
name|brush
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* eat blank */
name|txt
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|txt
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|txt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|elt
operator|=
name|DBCreateElt
argument_list|(
name|type
argument_list|,
name|plist
argument_list|,
name|brush
argument_list|,
name|size
argument_list|,
name|txt
argument_list|,
operator|&
name|elist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
condition|)
comment|/* recompute text reference points */
name|PTModifyTextPoints
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
name|TxMsgOK
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end DBRead */
end_comment

begin_comment
comment|/*  * Interpret element type in string s.  * Old file format consisted of integer element types.  * New file format has literal names for element types.  */
end_comment

begin_expr_stmt
name|DBGetType
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|||
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
comment|/* old element format or EOF */
return|return
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'P'
case|:
return|return
operator|(
name|POLYGON
operator|)
return|;
case|case
literal|'V'
case|:
return|return
operator|(
name|VECTOR
operator|)
return|;
case|case
literal|'A'
case|:
return|return
operator|(
name|ARC
operator|)
return|;
case|case
literal|'C'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'U'
condition|)
return|return
operator|(
name|CURVE
operator|)
return|;
switch|switch
condition|(
name|s
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|'L'
case|:
return|return
operator|(
name|CENTLEFT
operator|)
return|;
case|case
literal|'C'
case|:
return|return
operator|(
name|CENTCENT
operator|)
return|;
case|case
literal|'R'
case|:
return|return
operator|(
name|CENTRIGHT
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"unknown element type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
case|case
literal|'B'
case|:
switch|switch
condition|(
name|s
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'L'
case|:
return|return
operator|(
name|BOTLEFT
operator|)
return|;
case|case
literal|'C'
case|:
return|return
operator|(
name|BOTCENT
operator|)
return|;
case|case
literal|'R'
case|:
return|return
operator|(
name|BOTRIGHT
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"unknown element type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
case|case
literal|'T'
case|:
switch|switch
condition|(
name|s
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'L'
case|:
return|return
operator|(
name|TOPLEFT
operator|)
return|;
case|case
literal|'C'
case|:
return|return
operator|(
name|TOPCENT
operator|)
return|;
case|case
literal|'R'
case|:
return|return
operator|(
name|TOPRIGHT
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"unknown element type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
default|default:
name|error
argument_list|(
literal|"unknown element type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* end DBGetType */
end_comment

begin_comment
comment|/*  * This routine returns true if all points in elt are bounded by  * the rectangle who diagonal is formed by (x1, y1) and (x2, y2).  */
end_comment

begin_expr_stmt
name|DBBounded
argument_list|(
name|elt
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|;
specifier|register
name|float
name|lox
decl_stmt|,
name|loy
decl_stmt|,
name|hix
decl_stmt|,
name|hiy
decl_stmt|;
comment|/* OK to compare register floats */
name|lox
operator|=
operator|(
name|x1
operator|<
name|x2
operator|)
condition|?
name|x1
else|:
name|x2
expr_stmt|;
name|loy
operator|=
operator|(
name|y1
operator|<
name|y2
operator|)
condition|?
name|y1
else|:
name|y2
expr_stmt|;
name|hix
operator|=
operator|(
name|x1
operator|>
name|x2
operator|)
condition|?
name|x1
else|:
name|x2
expr_stmt|;
name|hiy
operator|=
operator|(
name|y1
operator|>
name|y2
operator|)
condition|?
name|y1
else|:
name|y2
expr_stmt|;
name|p1
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p1
operator|->
name|x
operator|<
name|lox
operator|)
operator|||
operator|(
name|p1
operator|->
name|x
operator|>
name|hix
operator|)
operator|||
operator|(
name|p1
operator|->
name|y
operator|<
name|loy
operator|)
operator|||
operator|(
name|p1
operator|->
name|y
operator|>
name|hiy
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end DBBounded */
end_comment

begin_comment
comment|/*  * This routine creates a copy of the the element transformed by  * the transformation matrix and adds the new copy to the database.  */
end_comment

begin_decl_stmt
name|ELT
modifier|*
name|DBCopy
argument_list|(
name|elt
argument_list|,
name|transform
argument_list|,
name|db
argument_list|)
decl|register
name|ELT
modifier|*
name|elt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ELT
argument_list|*
operator|(
operator|*
name|db
operator|)
argument_list|;
name|float
name|transform
index|[
literal|3
index|]
index|[
literal|2
index|]
argument_list|;
block|{
specifier|register
name|POINT
modifier|*
name|pt
decl_stmt|;
name|POINT
modifier|*
name|newlist
decl_stmt|;
name|char
modifier|*
name|newtext
decl_stmt|;
name|newlist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|pt
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|pt
argument_list|)
condition|)
block|{
comment|/* matrix multiply */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|(
operator|(
operator|(
name|pt
operator|->
name|x
operator|)
operator|*
name|transform
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|+
operator|(
operator|(
name|pt
operator|->
name|y
operator|)
operator|*
name|transform
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
operator|+
name|transform
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|pt
operator|->
name|x
operator|)
operator|*
name|transform
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|+
operator|(
operator|(
name|pt
operator|->
name|y
operator|)
operator|*
name|transform
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|+
name|transform
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|)
argument_list|,
operator|&
name|newlist
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextpt
expr_stmt|;
block|}
name|newtext
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|elt
operator|->
name|textpt
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newtext
argument_list|,
name|elt
operator|->
name|textpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|DBCreateElt
argument_list|(
name|elt
operator|->
name|type
argument_list|,
name|newlist
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|newtext
argument_list|,
name|db
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* end DBCopy */
end_comment

begin_comment
comment|/*  * This routine transforms the element by multiplying the  * coordinates of each of the points in the element by the   * transformation matrix.  */
end_comment

begin_expr_stmt
name|DBXform
argument_list|(
name|elt
argument_list|,
name|transform
argument_list|,
name|db
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|float
name|transform
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ELT
argument_list|*
operator|(
operator|*
name|db
operator|)
argument_list|;
block|{
specifier|register
name|POINT
modifier|*
name|pt
decl_stmt|;
name|float
name|px
decl_stmt|,
name|py
decl_stmt|;
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|pt
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|pt
argument_list|)
condition|)
block|{
name|px
operator|=
operator|(
operator|(
name|pt
operator|->
name|x
operator|)
operator|*
name|transform
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|+
operator|(
operator|(
name|pt
operator|->
name|y
operator|)
operator|*
name|transform
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|)
operator|+
name|transform
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|py
operator|=
operator|(
operator|(
name|pt
operator|->
name|x
operator|)
operator|*
name|transform
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|+
operator|(
operator|(
name|pt
operator|->
name|y
operator|)
operator|*
name|transform
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|+
name|transform
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
name|pt
operator|->
name|x
operator|=
name|px
expr_stmt|;
name|pt
operator|->
name|y
operator|=
name|py
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextpt
expr_stmt|;
block|}
block|}
end_expr_stmt

begin_comment
comment|/* end DBXform */
end_comment

begin_comment
comment|/*  * This routine changes the brush attribute of the element.  */
end_comment

begin_macro
name|DBChangeBrush
argument_list|(
argument|elt
argument_list|,
argument|brush
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brush
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|brushf
operator|=
name|brush
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeBrush */
end_comment

begin_comment
comment|/*  * This routine changes the justify attribute of the element.  */
end_comment

begin_macro
name|DBChangeJustify
argument_list|(
argument|elt
argument_list|,
argument|justmode
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|justmode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|length
expr_stmt|;
specifier|register
name|POINT
modifier|*
name|pos
decl_stmt|,
modifier|*
name|point
decl_stmt|;
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|type
operator|=
name|justmode
expr_stmt|;
name|PTModifyTextPoints
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeJustify */
end_comment

begin_comment
comment|/*  * This routine changes the font attribute of the given element.  */
end_comment

begin_macro
name|DBChangeFont
argument_list|(
argument|elt
argument_list|,
argument|font
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|brushf
operator|=
name|font
expr_stmt|;
name|PTModifyTextPoints
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeFont */
end_comment

begin_comment
comment|/*  * This routine changes the size attribute of the given element.  */
end_comment

begin_macro
name|DBChangeSize
argument_list|(
argument|elt
argument_list|,
argument|size
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|PTModifyTextPoints
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeSize */
end_comment

begin_comment
comment|/*  * This routine changes the stipple attribute of the given element.  */
end_comment

begin_macro
name|DBChangeStipple
argument_list|(
argument|elt
argument_list|,
argument|stipple
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stipple
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|size
operator|=
name|stipple
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeStipple */
end_comment

begin_comment
comment|/*  * This routine changes the text attribute of the given element.  */
end_comment

begin_macro
name|DBChangeText
argument_list|(
argument|elt
argument_list|,
argument|text
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elt
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|elt
operator|->
name|textpt
operator|=
name|new
expr_stmt|;
name|PTModifyTextPoints
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeText */
end_comment

begin_comment
comment|/*  * This routine changes the type attribute of the given element.  */
end_comment

begin_macro
name|DBChangeType
argument_list|(
argument|elt
argument_list|,
argument|newtype
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newtype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeType */
end_comment

begin_comment
comment|/*  * This routine changes the type and stipple attributes of the given element.  */
end_comment

begin_macro
name|DBChangeTypeStipple
argument_list|(
argument|elt
argument_list|,
argument|newtype
argument_list|,
argument|newstipple
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newtype
decl_stmt|,
name|newstipple
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
name|elt
operator|->
name|size
operator|=
name|newstipple
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeType */
end_comment

begin_comment
comment|/*  * This routine changes the type, brush and stipple attributes  * of the given element.  */
end_comment

begin_macro
name|DBChangeTypeBrushStipple
argument_list|(
argument|elt
argument_list|,
argument|newtype
argument_list|,
argument|newbrush
argument_list|,
argument|newstipple
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newtype
decl_stmt|,
name|newbrush
decl_stmt|,
name|newstipple
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNRembMod
argument_list|(
name|elt
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|elt
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
name|elt
operator|->
name|brushf
operator|=
name|newbrush
expr_stmt|;
name|elt
operator|->
name|size
operator|=
name|newstipple
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBChangeType */
end_comment

begin_comment
comment|/*  * This routine adds the element to the current set database.  */
end_comment

begin_expr_stmt
name|DBAddSet
argument_list|(
name|elt
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elist
decl_stmt|;
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
comment|/* makes sure element not already in list */
if|if
condition|(
name|elist
operator|==
name|elt
condition|)
return|return;
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
name|elt
operator|->
name|setnext
operator|=
name|cset
expr_stmt|;
name|cset
operator|=
name|elt
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBAddSet */
end_comment

begin_comment
comment|/*  *  Return TRUE if element in current set, else FALSE.  */
end_comment

begin_expr_stmt
name|DBInCset
argument_list|(
name|elt
argument_list|)
specifier|register
name|ELT
operator|*
name|elt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elist
decl_stmt|;
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
comment|/* makes sure element not already in list */
if|if
condition|(
name|elist
operator|==
name|elt
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end DBInCset */
end_comment

begin_comment
comment|/*  * This routine clears the current set by setting the pointer  * to a null element.  */
end_comment

begin_macro
name|DBClearSet
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
name|cset
operator|=
name|DBNextofSet
argument_list|(
name|cset
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBClearSet */
end_comment

end_unit

