begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)graphics2.c	1.2	%G%  *  * Line drawing and polygon fill routines for the SUN Gremlin  * picture editor.  Line drawing courtesy of dsun.c and polygon  * fill courtesy of dvar.c.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|<suntool/tool_hs.h>
end_include

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_define
define|#
directive|define
name|point
parameter_list|(
name|sun_x
parameter_list|,
name|sun_y
parameter_list|)
value|pr_put(scratch_pr, (sun_x), (sun_y), 1)
end_define

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pixrect
modifier|*
name|scratch_pr
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern linestyle;
end_extern

begin_comment
comment|/* type of line (1 - 6) */
end_comment

begin_extern
extern|extern linemod;
end_extern

begin_comment
comment|/* line drawing mask (SOLID, DOTTED, ...) */
end_comment

begin_extern
extern|extern linethickness;
end_extern

begin_comment
comment|/* 1, 2, 3 */
end_comment

begin_extern
extern|extern SymbolicLines;
end_extern

begin_comment
comment|/* TRUE if OK to use pr_vector for all lines */
end_comment

begin_extern
extern|extern SUN_XORIGIN;
end_extern

begin_comment
comment|/* database x-coord of upper left screen */
end_comment

begin_extern
extern|extern SUN_YORIGIN;
end_extern

begin_comment
comment|/* database y-coord of upper left screen */
end_comment

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern minsunx
operator|,
extern|maxsunx
operator|,
extern|minsuny
operator|,
extern|maxsuny;
end_extern

begin_comment
comment|/* imports from menu.c */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|_menu
name|menu
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|HiStipple
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from graphics.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|stipple_patterns
index|[
name|NSTIPPLES
index|]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern rasterlength;
end_extern

begin_extern
extern|extern bytesperline;
end_extern

begin_extern
extern|extern nlines;
end_extern

begin_comment
comment|/* scratch_pr->pr_size.x */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fill
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero origin in filling buffer */
end_comment

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* locals */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stipplebits
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|poly
block|{
name|struct
name|poly
modifier|*
name|next
decl_stmt|;
comment|/* doubly-linked lists of vectors */
name|struct
name|poly
modifier|*
name|prev
decl_stmt|;
name|int
name|param
decl_stmt|;
comment|/* bressenham line algorithm parameter */
name|short
name|dy
decl_stmt|;
comment|/* delta-y for calculating line */
name|short
name|dx
decl_stmt|;
comment|/* delta-x for calculating line */
name|short
name|curry
decl_stmt|;
comment|/* current y in this vector */
name|short
name|endx
decl_stmt|;
comment|/* where vector ends */
block|}
name|polyvector
typedef|;
end_typedef

begin_comment
comment|/*  * Vector from (x1, y1) to (x2, y2) using global linemod and linethickness.  * Parameters in database coordinates system.  * Always write to scratch_pr.  * Borrowed from dsun.  */
end_comment

begin_macro
name|GRVector
argument_list|(
argument|dbx1
argument_list|,
argument|dby1
argument_list|,
argument|dbx2
argument_list|,
argument|dby2
argument_list|)
end_macro

begin_decl_stmt
name|float
name|dbx1
decl_stmt|,
name|dby1
decl_stmt|,
name|dbx2
decl_stmt|,
name|dby2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|x0
expr_stmt|;
comment|/* starting point and line-walking registers */
specifier|register
name|y0
expr_stmt|;
specifier|register
name|res
expr_stmt|;
specifier|register
name|i
expr_stmt|;
comment|/* line-bleeding carrier */
name|int
name|dx
decl_stmt|;
comment|/* parameters in the line calculations */
name|int
name|dy
decl_stmt|;
name|int
name|xinc
decl_stmt|;
name|int
name|yinc
decl_stmt|;
name|int
name|x1
decl_stmt|;
comment|/* end-point of the line */
name|int
name|y1
decl_stmt|;
name|int
name|radius
decl_stmt|;
name|int
name|top
decl_stmt|;
comment|/* how much to bleed line in "up" (left) direction */
name|int
name|bottom
decl_stmt|;
comment|/* how much to bleed line in "down" (right) direction */
name|int
name|stop1
decl_stmt|;
comment|/* place to stop making circles at start of line */
name|int
name|stop2
decl_stmt|;
comment|/* place to start making circles at end of line */
name|int
name|halfstop
decl_stmt|;
comment|/* distance tween stop1 and stop3 */
name|int
name|stop3
decl_stmt|;
comment|/* midpoint `tween making circles and lines */
name|x0
operator|=
name|dbx_to_win
argument_list|(
name|dbx1
argument_list|)
expr_stmt|;
comment|/* convert endpoints to SUN coordinates */
name|y0
operator|=
name|dby_to_win
argument_list|(
name|dby1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|dbx_to_win
argument_list|(
name|dbx2
argument_list|)
expr_stmt|;
name|y1
operator|=
name|dby_to_win
argument_list|(
name|dby2
argument_list|)
expr_stmt|;
name|MINMAX
argument_list|(
name|minsunx
argument_list|,
name|maxsunx
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|MINMAX
argument_list|(
name|minsuny
argument_list|,
name|maxsuny
argument_list|,
name|y0
argument_list|)
expr_stmt|;
name|MINMAX
argument_list|(
name|minsunx
argument_list|,
name|maxsunx
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|MINMAX
argument_list|(
name|minsuny
argument_list|,
name|maxsuny
argument_list|,
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SymbolicLines
operator|)
operator|||
operator|(
name|linestyle
operator|==
literal|5
comment|/* NARROW */
operator|)
condition|)
block|{
name|pr_vector
argument_list|(
name|scratch_pr
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|PIX_SRC
operator||
name|PIX_DST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|xinc
operator|=
literal|1
expr_stmt|;
name|yinc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dx
operator|=
name|x1
operator|-
name|x0
operator|)
operator|<
literal|0
condition|)
block|{
name|xinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dy
operator|=
name|y1
operator|-
name|y0
operator|)
operator|<
literal|0
condition|)
block|{
name|yinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|radius
operator|=
operator|(
name|linethickness
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add ends of line */
name|RoundEnd
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|radius
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* (nice and curvy) */
name|top
operator|=
name|linethickness
expr_stmt|;
comment|/* increase line thickness if at an angle */
name|stop1
operator|=
name|halfstop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
argument_list|)
operator|+
literal|0.01
argument_list|)
operator|)
operator|<
literal|2
condition|)
return|return;
comment|/* small lines are done with endpoints */
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
block|{
name|top
operator|=
operator|(
name|linethickness
operator|*
name|i
operator|)
operator|/
name|dx
expr_stmt|;
name|stop1
operator|=
operator|(
name|linethickness
operator|*
name|dy
operator|)
operator|/
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|halfstop
operator|=
operator|(
name|radius
operator|*
name|dy
operator|)
operator|/
name|i
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
operator|(
name|linethickness
operator|*
name|i
operator|)
operator|/
name|dy
expr_stmt|;
name|stop1
operator|=
operator|(
name|linethickness
operator|*
name|dx
operator|)
operator|/
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|halfstop
operator|=
operator|(
name|radius
operator|*
name|dx
operator|)
operator|/
name|i
expr_stmt|;
block|}
name|bottom
operator|=
operator|(
name|top
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|top
operator|=
name|top
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
block|{
name|res
operator|=
operator|(
name|dy
operator|>>
literal|1
operator|)
operator|-
operator|(
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|linethickness
operator|>=
name|i
condition|)
block|{
name|stop1
operator|=
name|stop2
operator|=
name|x0
expr_stmt|;
name|halfstop
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xinc
operator|==
literal|1
condition|)
block|{
name|stop2
operator|=
name|x1
operator|-
name|stop1
expr_stmt|;
name|stop1
operator|=
name|x0
operator|+
name|stop1
expr_stmt|;
name|stop3
operator|=
name|x0
operator|+
name|halfstop
expr_stmt|;
block|}
else|else
block|{
name|stop2
operator|=
name|x1
operator|+
name|stop1
expr_stmt|;
name|stop1
operator|=
name|x0
operator|-
name|stop1
expr_stmt|;
name|stop3
operator|=
name|x0
operator|-
name|halfstop
expr_stmt|;
block|}
while|while
condition|(
name|x0
operator|!=
name|stop1
condition|)
block|{
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x0
operator|&
name|linemod
operator|)
operator|&&
operator|(
name|xinc
operator|==
literal|1
condition|?
name|x0
operator|>
name|stop3
else|:
name|x0
operator|<
name|stop3
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|y0
operator|-
name|top
init|;
name|i
operator|<=
name|y0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|x0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
while|while
condition|(
name|x0
operator|!=
name|stop2
condition|)
block|{
if|if
condition|(
name|x0
operator|&
name|linemod
condition|)
block|{
for|for
control|(
name|i
operator|=
name|y0
operator|-
name|top
init|;
name|i
operator|<=
name|y0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|x0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|stop3
operator|=
name|x1
operator|+
operator|(
name|xinc
operator|==
literal|1
condition|?
operator|-
name|halfstop
else|:
name|halfstop
operator|)
expr_stmt|;
while|while
condition|(
name|x0
operator|!=
name|x1
condition|)
block|{
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x0
operator|&
name|linemod
operator|)
operator|&&
operator|(
name|xinc
operator|==
literal|1
condition|?
name|x0
operator|<
name|stop3
else|:
name|x0
operator|>
name|stop3
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|y0
operator|-
name|top
init|;
name|i
operator|<=
name|y0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|x0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
block|}
else|else
block|{
name|res
operator|=
operator|(
name|dx
operator|>>
literal|1
operator|)
operator|-
operator|(
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|linethickness
operator|>=
name|i
condition|)
block|{
name|stop1
operator|=
name|stop2
operator|=
name|y0
expr_stmt|;
name|halfstop
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yinc
operator|==
literal|1
condition|)
block|{
name|stop2
operator|=
name|y1
operator|-
name|stop1
expr_stmt|;
name|stop1
operator|=
name|y0
operator|+
name|stop1
expr_stmt|;
name|stop3
operator|=
name|y0
operator|+
name|halfstop
expr_stmt|;
block|}
else|else
block|{
name|stop2
operator|=
name|y1
operator|+
name|stop1
expr_stmt|;
name|stop1
operator|=
name|y0
operator|-
name|stop1
expr_stmt|;
name|stop3
operator|=
name|y0
operator|-
name|halfstop
expr_stmt|;
block|}
while|while
condition|(
name|y0
operator|!=
name|stop1
condition|)
block|{
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y0
operator|&
name|linemod
operator|)
operator|&&
operator|(
name|yinc
operator|==
literal|1
condition|?
name|y0
operator|>
name|stop3
else|:
name|y0
operator|<
name|stop3
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|x0
operator|-
name|top
init|;
name|i
operator|<=
name|x0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|i
argument_list|,
name|y0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
while|while
condition|(
name|y0
operator|!=
name|stop2
condition|)
block|{
if|if
condition|(
name|y0
operator|&
name|linemod
condition|)
block|{
for|for
control|(
name|i
operator|=
name|x0
operator|-
name|top
init|;
name|i
operator|<=
name|x0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|i
argument_list|,
name|y0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|stop3
operator|=
name|y1
operator|+
operator|(
name|yinc
operator|==
literal|1
condition|?
operator|-
name|halfstop
else|:
name|halfstop
operator|)
expr_stmt|;
while|while
condition|(
name|y0
operator|!=
name|y1
condition|)
block|{
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y0
operator|&
name|linemod
operator|)
operator|&&
operator|(
name|yinc
operator|==
literal|1
condition|?
name|y0
operator|<
name|stop3
else|:
name|y0
operator|>
name|stop3
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|x0
operator|-
name|top
init|;
name|i
operator|<=
name|x0
operator|+
name|bottom
condition|;
name|i
operator|++
control|)
name|point
argument_list|(
name|i
argument_list|,
name|y0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|res
operator|-=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Plots a filled (if requested) circle of the specified radius  * centered about (x, y).  * Coordinates are window relative.  * Modified from dsun source.  */
end_comment

begin_expr_stmt
name|RoundEnd
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|radius
argument_list|,
name|filled
argument_list|)
specifier|register
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|y
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|radius
decl_stmt|,
name|filled
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|epsilon
decl_stmt|;
specifier|register
name|j
operator|,
name|k
expr_stmt|;
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|radius
argument_list|)
expr_stmt|;
comment|/* do the starting point of the circle */
if|if
condition|(
name|radius
operator|<
literal|1
condition|)
comment|/* if circle is tiny, quit now */
return|return;
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|-
name|radius
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|-
name|radius
operator|<
name|minsuny
condition|)
name|minsuny
operator|=
name|y
operator|-
name|radius
expr_stmt|;
comment|/* Calculate trajectory of the circle for 1/4 the circumference         (while ys is positive) and mirror to get the other three quadrants. */
name|xs
operator|=
literal|0.0
expr_stmt|;
name|ys
operator|=
operator|(
name|float
operator|)
name|radius
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|ys
expr_stmt|;
while|while
condition|(
name|ys
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|k
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|filled
condition|)
block|{
comment|/* fill from center */
do|do
block|{
name|point
argument_list|(
name|j
operator|+
name|x
argument_list|,
name|k
operator|+
name|y
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|j
operator|+
name|x
argument_list|,
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|x
operator|-
name|j
argument_list|,
name|k
operator|+
name|y
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|x
operator|-
name|j
argument_list|,
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* do the perimeter only */
name|point
argument_list|(
name|j
operator|+
name|x
argument_list|,
name|k
operator|+
name|y
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|j
operator|+
name|x
argument_list|,
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|x
operator|-
name|j
argument_list|,
name|k
operator|+
name|y
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|x
operator|-
name|j
argument_list|,
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
comment|/* generate circumference */
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end RoundEnd */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Set drawing parameters for filling polygons.  * Must be called before GRStippleFill().  */
end_comment

begin_macro
name|GRSetStippleStyle
argument_list|(
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|style
operator|<=
literal|0
operator|)
operator|||
operator|(
name|style
operator|>
name|NSTIPPLES
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GRSetStippleStyle: bad stipple #%d\n"
argument_list|,
name|style
argument_list|)
expr_stmt|;
return|return;
block|}
name|stipplebits
operator|=
name|stipple_patterns
index|[
name|style
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*>>> stipple fonts must be 32 x 32 bits<<< */
end_comment

begin_define
define|#
directive|define
name|MASK
value|31
end_define

begin_comment
comment|/* mask to pick off pixel index into stipple */
end_comment

begin_define
define|#
directive|define
name|BYTEWIDTH
value|4
end_define

begin_comment
comment|/* glyph width in bytes */
end_comment

begin_define
define|#
directive|define
name|BYTEMASK
value|3
end_define

begin_comment
comment|/* mask to pick off byte index into stipple */
end_comment

begin_comment
comment|/*  * Fill polygon defined by points in plist using parameters set by  * previous call to GRSetStippleStyle().  *  * This routine was modified from source for the varian driver.  * Because the varian rotates everything 90 degrees before printing,  * the x and y coordinates from the window are reversed before  * computing the region.  This is just a kludge to get the code  * to work as soon as possible.  Better to change this at some point,  * but I don't have time now.  *  * The scan-line algorithm implemented scans from left to right   * (low x to high x).  It also scans, within a line, from bottom to top   * (high y to low y).  Stipple patterns MUST be a power of two bytes wide  * and square (in fact, they must be 32 x 32 bits).  */
end_comment

begin_macro
name|GRStippleFill
argument_list|(
argument|plist
argument_list|)
end_macro

begin_decl_stmt
name|POINT
modifier|*
name|plist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nextx
decl_stmt|;
comment|/* x value where next vector starts */
name|int
name|maxx
decl_stmt|,
name|minx
decl_stmt|,
name|maxy
decl_stmt|,
name|miny
decl_stmt|;
comment|/* finds bounds of polygon */
name|polyvector
modifier|*
name|activehead
decl_stmt|;
comment|/* doing fill, is active edge list */
name|polyvector
modifier|*
name|waitinghead
decl_stmt|;
comment|/* edges waiting to be active */
specifier|register
name|polyvector
modifier|*
name|vectptr
decl_stmt|;
comment|/* random vector */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* random register */
name|char
modifier|*
name|topstipple
decl_stmt|;
comment|/* beginning of stipple glyph */
name|char
modifier|*
name|leftstipple
decl_stmt|;
comment|/* beginning of line of stipple */
name|char
modifier|*
name|bottompage
decl_stmt|;
comment|/* the edge of a raster line */
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
comment|/* algorithm requires this form */
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|npts
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|p1
operator|=
name|plist
expr_stmt|;
name|npts
operator|=
literal|0
expr_stmt|;
comment|/*      * convert coordinates to arrays of integers exchanging x and y,      * and making origin upper right.      */
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|npts
operator|++
expr_stmt|;
name|x
index|[
name|npts
index|]
operator|=
name|dby_to_win
argument_list|(
name|p1
operator|->
name|y
argument_list|)
operator|-
literal|1
expr_stmt|;
name|y
index|[
name|npts
index|]
operator|=
name|rasterlength
operator|-
literal|1
operator|-
name|dbx_to_win
argument_list|(
name|p1
operator|->
name|x
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|topstipple
operator|=
name|stipplebits
expr_stmt|;
comment|/* start of stipple pattern */
comment|/* allocate space for raster-fill algorithm */
if|if
condition|(
operator|(
name|vectptr
operator|=
operator|(
name|polyvector
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|polyvector
argument_list|)
argument_list|,
name|npts
operator|+
literal|6
argument_list|)
operator|)
operator|==
operator|(
name|polyvector
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to allocate space for polygon"
argument_list|)
expr_stmt|;
return|return;
block|}
name|waitinghead
operator|=
name|vectptr
expr_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|prev
operator|=
operator|(
name|polyvector
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* put dummy entry at start */
name|waitinghead
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|waitinghead
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* starting point of coords */
if|if
condition|(
name|y
index|[
literal|1
index|]
operator|!=
name|y
index|[
name|npts
index|]
operator|||
name|x
index|[
literal|1
index|]
operator|!=
name|x
index|[
name|npts
index|]
condition|)
block|{
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|npts
index|]
expr_stmt|;
comment|/* close polygon if it's not */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|npts
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|npts
condition|)
block|{
comment|/* set up the vectors */
specifier|register
name|int
name|j
decl_stmt|;
comment|/* indexes to work off of */
specifier|register
name|int
name|k
decl_stmt|;
comment|/* remember limits */
name|MINMAX
argument_list|(
name|miny
argument_list|,
name|maxy
argument_list|,
name|y
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|MINMAX
argument_list|(
name|minx
argument_list|,
name|maxx
argument_list|,
name|x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
comment|/* j points to the higher (lesser) point */
name|k
operator|=
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|k
index|]
condition|)
comment|/* ignore vertical lines */
continue|continue;
if|if
condition|(
name|x
index|[
name|j
index|]
operator|>
name|x
index|[
name|k
index|]
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|k
operator|--
expr_stmt|;
block|}
name|vectptr
operator|->
name|next
operator|=
name|vectptr
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
comment|/* starting point of vector */
name|vectptr
operator|->
name|dy
operator|=
name|y
index|[
name|k
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
comment|/* line-calculating parameters */
name|vectptr
operator|->
name|dx
operator|=
name|x
index|[
name|k
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
name|vectptr
operator|->
name|curry
operator|=
name|y
index|[
name|j
index|]
expr_stmt|;
comment|/* starting point */
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|endx
operator|=
name|x
index|[
name|k
index|]
expr_stmt|;
comment|/* ending point */
name|vectptr
operator|->
name|prev
operator|=
name|vectptr
operator|-
literal|1
expr_stmt|;
block|}
comment|/*      * keep polygon within bounds of scratch pixrect       * width is checked when actual drawing is done      */
if|if
condition|(
name|maxx
operator|>=
name|scratch_pr
operator|->
name|pr_size
operator|.
name|y
condition|)
name|maxx
operator|=
name|scratch_pr
operator|->
name|pr_size
operator|.
name|y
operator|-
literal|1
expr_stmt|;
comment|/* set now because we didn't know minx before */
name|leftstipple
operator|=
name|topstipple
operator|+
operator|(
name|minx
operator|&
name|MASK
operator|)
operator|*
name|BYTEWIDTH
expr_stmt|;
name|bottompage
operator|=
name|fill
operator|+
name|minx
operator|*
name|bytesperline
expr_stmt|;
name|waitinghead
operator|->
name|param
operator|=
name|minx
operator|-
literal|1
expr_stmt|;
comment|/* if no useable vectors, quit */
if|if
condition|(
name|vectptr
operator|==
name|waitinghead
operator|+
literal|1
condition|)
block|{
name|free
argument_list|(
name|waitinghead
argument_list|)
expr_stmt|;
return|return;
block|}
name|vectptr
operator|->
name|param
operator|=
name|maxx
operator|+
literal|1
expr_stmt|;
comment|/* dummy entry at end, too */
name|vectptr
operator|->
name|next
operator|=
operator|(
name|polyvector
operator|*
operator|)
name|NULL
expr_stmt|;
name|activehead
operator|=
operator|++
name|vectptr
expr_stmt|;
comment|/* two dummy entries for active list */
name|vectptr
operator|->
name|curry
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
comment|/* head */
name|vectptr
operator|->
name|endx
operator|=
name|maxx
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|activehead
operator|->
name|next
operator|=
operator|++
name|vectptr
expr_stmt|;
name|activehead
operator|->
name|prev
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|activehead
expr_stmt|;
comment|/* tail */
name|vectptr
operator|->
name|next
operator|=
name|activehead
expr_stmt|;
name|vectptr
operator|->
name|curry
operator|=
name|miny
operator|-
literal|1
expr_stmt|;
name|vectptr
operator|->
name|endx
operator|=
name|maxx
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
comment|/*       * main loop -- gets vectors off the waiting list, then displays spans       * while updating the vectors in the active list       */
while|while
condition|(
name|minx
operator|<=
name|maxx
condition|)
block|{
name|i
operator|=
name|maxx
operator|+
literal|1
expr_stmt|;
comment|/* this is the NEXT time to get a new vector */
for|for
control|(
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|vectptr
operator|!=
operator|(
name|polyvector
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|minx
operator|==
name|vectptr
operator|->
name|param
condition|)
block|{
comment|/*  		 * The entry in waiting list (vectptr) is ready to go into  		 * active list.  Need to convert some vector stuff and  		 * sort the entry into the list.  		 */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* random vector pointers */
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* convert this entry to active */
if|if
condition|(
name|vectptr
operator|->
name|dy
operator|<
literal|0
condition|)
name|vectptr
operator|->
name|param
operator|=
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
operator|-
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
expr_stmt|;
else|else
name|vectptr
operator|->
name|param
operator|=
operator|-
operator|(
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
operator|+
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|vectptr
expr_stmt|;
comment|/* remove from the */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* waiting list */
name|vectptr
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
comment|/*  		 * find where it goes in the active list  		 * (sorted greatest first)  		 */
for|for
control|(
name|v
operator|=
name|activehead
operator|->
name|next
init|;
name|v
operator|->
name|curry
operator|>
name|p
operator|->
name|curry
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
comment|/* insert into active list */
name|p
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
comment|/* before the one it stopped on */
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
name|vectptr
operator|->
name|param
condition|)
block|{
name|i
operator|=
name|vectptr
operator|->
name|param
expr_stmt|;
block|}
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
name|nextx
operator|=
name|i
expr_stmt|;
comment|/* print the polygon while there are no more vectors to add */
while|while
condition|(
name|minx
operator|<
name|nextx
condition|)
block|{
comment|/* remove any finished vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|endx
operator|<=
name|minx
condition|)
block|{
name|vectptr
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
name|vectptr
operator|->
name|next
operator|->
name|prev
operator|=
name|vectptr
operator|->
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|vectptr
operator|=
name|vectptr
operator|->
name|next
operator|)
operator|!=
name|activehead
condition|)
do|;
comment|/* draw the span */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|minx
operator|)
operator|<
name|nlines
condition|)
block|{
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|vectptr
operator|->
name|next
operator|!=
name|activehead
condition|)
block|{
specifier|register
name|int
name|start
decl_stmt|;
comment|/* get the beginning */
specifier|register
name|int
name|length
decl_stmt|;
comment|/* and the end of span */
specifier|register
name|char
modifier|*
name|glyph
decl_stmt|;
specifier|register
name|char
modifier|*
name|raster
decl_stmt|;
name|start
operator|=
operator|(
name|rasterlength
operator|-
literal|1
operator|)
operator|-
name|vectptr
operator|->
name|curry
expr_stmt|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
name|length
operator|=
name|rasterlength
operator|-
name|vectptr
operator|->
name|curry
expr_stmt|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* bound the polygon to the page */
if|if
condition|(
name|start
operator|>=
name|rasterlength
condition|)
break|break;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|rasterlength
condition|)
name|length
operator|=
name|rasterlength
expr_stmt|;
name|length
operator|-=
name|start
expr_stmt|;
comment|/* length is in pixels */
name|i
operator|=
name|start
operator|&
literal|7
expr_stmt|;
name|start
operator|=
name|start
operator|>>
literal|3
expr_stmt|;
comment|/* start is in bytes */
name|raster
operator|=
name|bottompage
operator|+
name|start
expr_stmt|;
name|glyph
operator|=
name|leftstipple
operator|+
operator|(
name|start
operator|&
name|BYTEMASK
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* do any piece of byte */
specifier|register
name|char
name|data
decl_stmt|;
comment|/* that hangs on the front */
name|data
operator|=
operator|(
operator|*
operator|(
name|glyph
operator|++
operator|)
operator|)
operator|&
operator|(
literal|0x7f
operator|>>
operator|--
name|i
operator|)
expr_stmt|;
name|length
operator|-=
literal|7
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
comment|/* less than one byte wide? */
name|data
operator|&=
literal|0xff
operator|<<
operator|-
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/* force clean stoppage */
block|}
operator|*
operator|(
name|raster
operator|++
operator|)
operator||=
name|data
expr_stmt|;
comment|/* update glyph ptr after first byte */
if|if
condition|(
operator|!
operator|(
operator|++
name|start
operator|&
name|BYTEMASK
operator|)
condition|)
name|glyph
operator|=
name|leftstipple
expr_stmt|;
block|}
comment|/* fill the line of raster */
while|while
condition|(
operator|(
name|length
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
operator|(
name|raster
operator|++
operator|)
operator||=
operator|*
operator|(
name|glyph
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|++
name|start
operator|&
name|BYTEMASK
operator|)
condition|)
name|glyph
operator|=
name|leftstipple
expr_stmt|;
block|}
comment|/* add any part hanging off the end */
if|if
condition|(
name|length
operator|&
literal|7
condition|)
block|{
operator|*
name|raster
operator||=
operator|(
operator|*
name|glyph
operator|)
operator|&
operator|(
literal|0xff
operator|<<
operator|-
name|length
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update the vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|dy
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dx
expr_stmt|;
name|vectptr
operator|->
name|curry
operator|++
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|+=
name|vectptr
operator|->
name|dy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vectptr
operator|->
name|dy
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dx
expr_stmt|;
name|vectptr
operator|->
name|curry
operator|--
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dy
expr_stmt|;
block|}
comment|/*  		 * must sort the vectors if updates caused them to cross  		 * also move to next vector here  		 */
if|if
condition|(
name|vectptr
operator|->
name|curry
operator|>
name|vectptr
operator|->
name|prev
operator|->
name|curry
condition|)
block|{
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* vector to move */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* vector to put it after */
name|v
operator|=
name|vectptr
expr_stmt|;
name|p
operator|=
name|v
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|curry
operator|>
name|p
operator|->
name|curry
condition|)
comment|/* find the */
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
comment|/* right vector */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* remove from spot */
name|vectptr
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
name|v
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
comment|/* put in new spot */
name|v
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|next
operator|->
name|prev
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|vectptr
operator|!=
name|activehead
condition|)
do|;
if|if
condition|(
operator|++
name|minx
operator|&
name|MASK
condition|)
block|{
name|leftstipple
operator|+=
name|BYTEWIDTH
expr_stmt|;
block|}
else|else
block|{
name|leftstipple
operator|=
name|topstipple
expr_stmt|;
block|}
name|bottompage
operator|+=
name|bytesperline
expr_stmt|;
block|}
comment|/* while (minx< nextx) */
block|}
comment|/* while (minx<= maxx) */
name|free
argument_list|(
name|waitinghead
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end GRStippleFill */
end_comment

end_unit

