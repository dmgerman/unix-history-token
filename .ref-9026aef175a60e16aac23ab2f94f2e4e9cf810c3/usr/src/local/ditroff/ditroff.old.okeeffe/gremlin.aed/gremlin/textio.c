begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)textio.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  * This file contains functions that manipulate the text interface  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* Library routines: */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tgetstr
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|,
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following definitions are used by the termlib routines  */
end_comment

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|,
modifier|*
name|cm
decl_stmt|,
modifier|*
name|ce
decl_stmt|,
modifier|*
name|vs
decl_stmt|,
modifier|*
name|cl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ospeed
decl_stmt|,
name|lastline
init|=
literal|23
decl_stmt|,
name|msgline
init|=
literal|23
decl_stmt|,
specifier|inline
namespace|=22;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bp
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the termcap entry for the tty */
end_comment

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds selected strings from bp */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|sttybuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds stty information for resetting tty */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sttyflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag word from sttybuf */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|tchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds tchars information for resetting */
end_comment

begin_decl_stmt
specifier|static
name|char
name|brkc
decl_stmt|,
name|eofc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fields from tchars, saved for resetting */
end_comment

begin_decl_stmt
specifier|static
name|int
name|c100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE means text display is c100 */
end_comment

begin_expr_stmt
specifier|static
name|putmsg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TRUE means TxPutMsg has been called 				 * since last character input. 				 */
end_comment

begin_comment
comment|/* The following structures define the various fields that are available  * on the terminal screen.  */
end_comment

begin_decl_stmt
name|TXFIELD
name|TAlign
init|=
block|{
literal|56
block|,
literal|1
block|,
literal|3
block|}
decl_stmt|,
name|TAdjust
init|=
block|{
literal|63
block|,
literal|1
block|,
literal|13
block|}
decl_stmt|,
name|TBrush
init|=
block|{
literal|30
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|,
name|TEdit
init|=
block|{
literal|10
block|,
literal|2
block|,
literal|32
block|}
decl_stmt|,
name|TJustmode
init|=
block|{
literal|76
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|,
name|TFont
init|=
block|{
literal|10
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|,
name|TGravity
init|=
block|{
literal|43
block|,
literal|1
block|,
literal|4
block|}
decl_stmt|,
name|TCSize
init|=
block|{
literal|19
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|OutChar
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character to be output */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------------  *	OutChar merely outputs a character on the file being used for  *	text I/O.  This routine is passed as a parameter to the tputs  *	pad-generating routine.  *  *	Results:	None.  *	Side Effects:	The character is output.  *	Errors:		None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|putc
argument_list|(
name|val
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|TxInit
argument_list|(
argument|ttytype
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ttytype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the terminal type, as returned 				 * by getenv("TERM") */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------------  *	TxInit initializes the text terminal and saves state information  *	so that we can restore its characteristics later.  *  *	Results:	None.  *	Side Effects:	Terminal characteristics are saved.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|pcap
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Turn off buffering.  This is necessary to avoid mess-ups during      * the constant mode changes.      */
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the termcap entry, and set up the strings and constants      * required by the termlib routines.      */
if|if
condition|(
name|tgetent
argument_list|(
name|bp
argument_list|,
name|ttytype
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot find terminal characteristics"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|sttybuf
operator|.
name|sg_ospeed
expr_stmt|;
name|pcap
operator|=
name|buf
expr_stmt|;
name|p1
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|PC
operator|=
literal|0
expr_stmt|;
else|else
name|PC
operator|=
operator|*
name|p1
expr_stmt|;
name|pcap
operator|=
name|buf
expr_stmt|;
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
name|UP
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
name|cm
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
name|ce
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
name|vs
operator|=
name|tgetstr
argument_list|(
literal|"vs"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
name|cl
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|pcap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
name|sttyflags
operator|=
name|sttybuf
operator|.
name|sg_flags
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tchars
argument_list|)
expr_stmt|;
name|eofc
operator|=
name|tchars
operator|.
name|t_eofc
expr_stmt|;
name|brkc
operator|=
name|tchars
operator|.
name|t_brkc
expr_stmt|;
name|p1
operator|=
literal|"c100"
expr_stmt|;
name|p2
operator|=
name|ttytype
expr_stmt|;
name|c100
operator|=
name|FALSE
expr_stmt|;
name|putmsg
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|-
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
break|break;
if|if
condition|(
name|i
operator|=
literal|1
condition|)
name|c100
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|TxRedisplay
argument_list|()
end_macro

begin_comment
comment|/*-----------------------------------------------------------------------------  *	This routine merely redisplays the command menu on the text screen,  *	and modifies text display parameters for menu processing.  *  *	Results:	None.  *  *	Side Effects:  *	The text display is cleared, menu information is reprinted, and  *	terminal characteristics are set for menu processing.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
specifier|static
name|char
name|initstring1
index|[]
init|=
literal|"\n\      font 1   size 1    brush 6    gravi\ ty OFF    align   4    NO ADJUSTMENT \n\ Editing:                                \                      Justification: BL \n\ ----------------------------------------\ ---------------------------------------\n\     Long Commands:          |\          Short Commands:\n\                             |\n\    Align          MSize     |\    a - draw arc         ! - shell escape\n\    BRush          MText     |\    b - draw curve       . - repeat last command\n\    BUffer         Orient    |\    c - copy set        ^L - redraw picture\n\    Clearpoints    PAth      |\    d - define set       l - redisplay text screen\n\ "
decl_stmt|;
specifier|static
name|char
name|initstring2
index|[]
init|=
literal|"\    Deletepoint    POint     |\    e - erase      1,2,3,4 - store set buffer\n\    Edit<!>        Quit<!>   |\    f - define area \n\    Font           Read      |\    g - gravity\n\    Gripe          SAveset<!>|\    q - grid\n\    Hadjust        SHowpoints|\    r - rotate set\n\    Includeset     SIze      |\    s - scale set\n\    Justify        Text      |\    t - translate set\n\    Littlepoint    Undo      |\    v - draw vectors\n\    MBrush         Vadjust   |\    w - draw arrow \n\    MFont          Write<!>  |\    x - draw box\n\    MIrror                   |\    z - manhattan adjust\n\    MPoint                   |\    \n\ "
decl_stmt|;
comment|/* Clear the terminal screen and output the gremlin menu.  The      * TxClose call is necessary to put the terminal back into its standard      * operating mode;  otherwise this stuff will appear as garbage!      * However, turn off echoing to keep type-ahead from appearing      * in the middle of the screen.      */
name|TxClose
argument_list|()
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|vs
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|cl
argument_list|,
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
argument_list|,
name|OutChar
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|initstring1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|initstring2
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* If the terminal is a Concept 100, then output special characters      * for the border lines between the three screen areas.      */
if|if
condition|(
name|c100
condition|)
block|{
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\33U\33r\1p"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|28
argument_list|,
literal|4
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\33R"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'2'
argument_list|)
expr_stmt|;
block|}
comment|/* Place the cursor in the lower-left corner, save terminal      * characteristics so we can restore them later, then make ^M      * into a break character, put the terminal into CBREAK mode,      * and turn off echoing.      */
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
name|lastline
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
name|tchars
operator|.
name|t_eofc
operator|=
operator|-
literal|1
expr_stmt|;
name|tchars
operator|.
name|t_brkc
operator|=
literal|'\r'
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tchars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putmsg
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|TxClose
argument_list|()
end_macro

begin_comment
comment|/*-----------------------------------------------------------------------------  *	TxClose resets the terminal to the way we found it.  *  *	Results:	None.  *	Side Effects:	None.  *	Errors:		None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
modifier|*
name|dummy
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator|=
name|sttyflags
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
name|tchars
operator|.
name|t_eofc
operator|=
name|eofc
expr_stmt|;
name|tchars
operator|.
name|t_brkc
operator|=
name|brkc
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tchars
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|buf
expr_stmt|;
name|fputs
argument_list|(
name|tgetstr
argument_list|(
literal|"ve"
argument_list|,
operator|&
name|dummy
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|TxPutString
argument_list|(
argument|field
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|TXFIELD
modifier|*
name|field
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The screen field to be overwritten */
end_comment

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character string to be written */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------------  *	TxPutString displays a string in a given field of the text display.  *  *	Results:	None.  *  *	Side Effects:  *	The given text screen field is overwritten with the given text  *	string, blank filled and left justified.  *  *	Errors:		None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
name|format
index|[
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"%%s%%-%d.%ds"
argument_list|,
name|field
operator|->
name|tx_size
argument_list|,
name|field
operator|->
name|tx_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|format
argument_list|,
name|tgoto
argument_list|(
name|cm
argument_list|,
name|field
operator|->
name|tx_x
argument_list|,
name|field
operator|->
name|tx_y
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
name|TxGetChar
parameter_list|()
comment|/*-----------------------------------------------------------------------------  *	TxGetChar gets the next character from the text keyboard.  *  *	Results:	The next character.  *	Side Effects:	None.  *-----------------------------------------------------------------------------  */
block|{
name|putmsg
operator|=
name|FALSE
expr_stmt|;
return|return
name|getchar
argument_list|()
return|;
block|}
end_function

begin_macro
name|TxMsgOK
argument_list|()
end_macro

begin_comment
comment|/*-----------------------------------------------------------------------------  *	This routine marks it OK to output messages again, just as if text  *	had been input.  *  *	Results:	None.  *	Side Effects:	As above.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
if|if
condition|(
name|putmsg
condition|)
comment|/* message on the screen to be blanked */
block|{
name|TxLine
argument_list|(
name|msgline
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                                                                            "
argument_list|)
expr_stmt|;
name|TxLine
argument_list|(
name|msgline
argument_list|)
expr_stmt|;
block|}
name|putmsg
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|TxGetLine
argument_list|(
argument|prompt
argument_list|,
argument|ptr
argument_list|,
argument|maxsize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prompt to be output at beginning of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place to store the input line */
end_comment

begin_decl_stmt
name|int
name|maxsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of characters to be read */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------------  *	TxGetLine reads a line of text from the terminal.  It does so  *	by positioning the cursor at the bottom of the screen and enabling  *	echoes again.  When the line has been read, echoes etc. are turned  *	off once more.  *  *	Results:	None.  *	Side Effects:	The last line of the text screen is destroyed.  *	Errors:		None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|putmsg
operator|=
name|FALSE
expr_stmt|;
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
specifier|inline
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|,
name|OutChar
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
comment|/* Input characters until a carriage return is found.  Then      * erase the control character from the screen.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxsize
condition|;
name|i
operator|++
control|)
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
break|break;
block|}
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|maxsize
condition|;
name|j
operator|++
control|)
name|ptr
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
literal|"\b\b  \b\b"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Reset the terminal into no-echo mode */
name|sttybuf
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|sttybuf
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sttybuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|TxPutMsg
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A message (not containing \r or \n) to 				 * be output on the text screen.  It must 				 * fit on a single line.  /*  /*-----------------------------------------------------------------------------  *	TPutMsg outputs a one-line message onto the text screen.  *  *	Results:	None.  *  *	Side Effects:  *	The string in msg is output on the last line of the text display.  *	If TxPutMsg is called twice between calls to TxGetLine or TxGetChar  *	then we output the message "More" at the end of the line and  *	wait for a space to be typed.  This is to protect against  *	multiple error messages overwriting each other.  *  *	Errors:		None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
if|if
condition|(
name|putmsg
condition|)
block|{
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|50
argument_list|,
name|msgline
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|0
index|]
operator|==
literal|'\7'
condition|)
block|{
name|putchar
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
name|msg
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"--More--"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|' '
condition|)
empty_stmt|;
block|}
name|putmsg
operator|=
name|TRUE
expr_stmt|;
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
name|msgline
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|,
name|OutChar
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|TxLine
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|short
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-----------------------------------------------------------------------------  *	TxLastLine moves the cursor to the first character of the specified  *	line of the text display.  *  *	Results:	None.  *	Side Effects:	None.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|fputs
argument_list|(
name|tgoto
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
name|line
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

