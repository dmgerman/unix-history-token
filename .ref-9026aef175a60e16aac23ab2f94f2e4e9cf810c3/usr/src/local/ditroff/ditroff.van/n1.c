begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_comment
comment|/* static char sccsid[] = "@(#)n1.c	2.2 (CWI) 88/03/31"; */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)n1.c	2.3 (Berkeley) 11/3/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * n1.c  *  *	consume options, initialization, main loop,  *	input routines, escape function calling  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* See cvtime() (jaap) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NROFF
end_ifdef

begin_include
include|#
directive|include
file|"tw.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|filep
name|ipl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ioff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ttyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cfname
index|[
name|NSO
index|]
index|[
name|NS
index|]
init|=
block|{
literal|"<standard input>"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*file name stack*/
end_comment

begin_decl_stmt
name|int
name|cfline
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*input line count stack*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name (troff) */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|j
expr_stmt|;
specifier|register
name|tchar
name|i
decl_stmt|;
specifier|extern
name|void
name|catch
argument_list|()
decl_stmt|,
name|kcatch
argument_list|()
decl_stmt|;
name|char
modifier|*
modifier|*
name|oargv
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|catch
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|kcatch
argument_list|)
expr_stmt|;
name|oargv
operator|=
name|argv
expr_stmt|;
name|mrehash
argument_list|()
expr_stmt|;
name|nrehash
argument_list|()
expr_stmt|;
name|init0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"TYPESETTER"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|devname
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
operator|++
name|argv
operator|)
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'F'
case|:
comment|/* switch font tables from default */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|termtab
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fontfile
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|strcpy
argument_list|(
name|termtab
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fontfile
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|0
case|:
goto|goto
name|start
goto|;
case|case
literal|'i'
case|:
name|stdi
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttys
argument_list|)
operator|>=
literal|0
condition|)
name|ttysave
operator|=
name|ttys
operator|.
name|sg_flags
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|npn
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* set emboldening amount */
name|bdtab
index|[
literal|3
index|]
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdtab
index|[
literal|3
index|]
operator|<
literal|0
operator|||
name|bdtab
index|[
literal|3
index|]
operator|>
literal|50
condition|)
name|bdtab
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
operator|(
name|stop
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|stop
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|eibuf
operator|=
name|ibuf
operator|+
name|strlen
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|eibuf
argument_list|,
literal|".nr %c %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
case|case
literal|'m'
case|:
name|strcat
argument_list|(
name|nextf
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|nextf
argument_list|,
literal|4
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|local
index|[
name|NS
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|local
argument_list|,
name|_PATH_LOCAL_TMAC
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|local
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|nextf
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
name|mflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
name|getpn
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
name|strcpy
argument_list|(
name|devname
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dotT
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
comment|/* select DUTCH as hyphenation style (jaap) */
name|hyalg1
operator|=
name|hyalg
operator|=
name|DUTCH
expr_stmt|;
name|thresh
operator|=
name|DUTCH_THRESH
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|NROFF
case|case
literal|'h'
case|:
name|hflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|eqflg
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NROFF
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
case|case
literal|'a'
case|:
name|ascii
operator|=
literal|1
expr_stmt|;
name|nofeed
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|nofeed
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
comment|/* for backward compatability */
continue|continue;
endif|#
directive|endif
default|default:
name|errprint
argument_list|(
literal|"unknown option %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|start
label|:
name|init1
argument_list|(
name|oargv
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argp
operator|=
name|argv
expr_stmt|;
name|rargc
operator|=
name|argc
expr_stmt|;
name|init2
argument_list|()
expr_stmt|;
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
name|loop
label|:
name|copyf
operator|=
name|lgf
operator|=
name|nb
operator|=
name|nflush
operator|=
name|nlflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|&&
name|rbf0
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|&&
name|ejf
operator|&&
name|frame
operator|->
name|pframe
operator|<=
name|ejl
condition|)
block|{
name|nflush
operator|++
expr_stmt|;
name|trap
operator|=
literal|0
expr_stmt|;
name|eject
argument_list|(
operator|(
expr|struct
name|s
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendt
condition|)
goto|goto
name|Lt
goto|;
if|if
condition|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|XPAR
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|tflg
operator|++
expr_stmt|;
while|while
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pchar
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|j
operator|==
name|cc
operator|||
name|j
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|j
operator|==
name|c2
condition|)
name|nb
operator|++
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|j
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|control
argument_list|(
name|getrq
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|Lt
label|:
name|ch
operator|=
name|i
expr_stmt|;
name|text
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlflg
condition|)
name|numtab
index|[
name|HP
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_function
name|void
name|catch
parameter_list|()
block|{
name|done3
argument_list|(
literal|01
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kcatch
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|done3
argument_list|(
literal|01
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|init0
argument_list|()
end_macro

begin_block
block|{
name|eibuf
operator|=
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|ibuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|numtab
index|[
name|NL
index|]
operator|.
name|val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|init1
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTRTAB
init|;
operator|--
name|i
condition|;
control|)
name|trtab
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|trtab
index|[
name|UNPAD
index|]
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_macro
name|init2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|char
modifier|*
name|cp
decl_stmt|;
name|ttyod
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
else|else
name|ttyp
operator|=
literal|"notty"
expr_stmt|;
name|iflg
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|ascii
condition|)
name|mesg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptinit
argument_list|()
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
name|cvtime
argument_list|()
expr_stmt|;
name|numtab
index|[
name|PID
index|]
operator|.
name|val
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|olinep
operator|=
name|oline
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
name|numtab
index|[
name|HP
index|]
operator|.
name|val
operator|=
name|init
operator|=
literal|0
expr_stmt|;
name|numtab
index|[
name|NL
index|]
operator|.
name|val
operator|=
operator|-
literal|1
expr_stmt|;
name|nfo
operator|=
literal|0
expr_stmt|;
name|ifile
operator|=
literal|0
expr_stmt|;
name|copyf
operator|=
name|raw
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|ibuf
operator|+
name|strlen
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|".ds .T %s\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|eibuf
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* compensation */
name|cpushback
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|nx
operator|=
name|mflg
expr_stmt|;
name|frame
operator|=
name|stk
operator|=
operator|(
expr|struct
name|s
operator|*
operator|)
name|malloc
argument_list|(
name|DELTA
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|&
name|d
index|[
literal|0
index|]
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NEV
condition|;
operator|++
name|i
control|)
name|env_array
index|[
name|i
index|]
operator|=
operator|*
name|env
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * (jaap)  * This replaces the old cvtime, so on well maintained systems, you don't  * need to change the (quite unknown) ZONE constant in tdef.h  */
end_comment

begin_macro
name|cvtime
argument_list|()
end_macro

begin_block
block|{
name|long
name|tt
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tym
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|time
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|tym
operator|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|numtab
index|[
name|DY
index|]
operator|.
name|val
operator|=
name|tym
operator|->
name|tm_mday
expr_stmt|;
comment|/* Current day of the month */
name|numtab
index|[
name|DW
index|]
operator|.
name|val
operator|=
name|tym
operator|->
name|tm_wday
operator|+
literal|1
expr_stmt|;
comment|/* Current day of the week */
name|numtab
index|[
name|YR
index|]
operator|.
name|val
operator|=
name|tym
operator|->
name|tm_year
expr_stmt|;
comment|/* Current year */
name|numtab
index|[
name|MO
index|]
operator|.
name|val
operator|=
name|tym
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
comment|/* Current month of year */
block|}
end_block

begin_expr_stmt
name|ctoi
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_macro
name|mesg
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|mode
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|stat
argument_list|(
name|ttyp
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|mode
operator|=
name|stbuf
operator|.
name|st_mode
expr_stmt|;
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
operator|&
operator|~
literal|0122
argument_list|)
expr_stmt|;
comment|/* turn off writing for others */
block|}
else|else
block|{
if|if
condition|(
name|ttyp
operator|&&
operator|*
name|ttyp
operator|&&
name|mode
condition|)
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|errprint
argument_list|(
argument|s
argument_list|,
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|,
argument|s5
argument_list|)
end_macro

begin_comment
comment|/* error message printer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|,
modifier|*
name|s4
decl_stmt|,
modifier|*
name|s5
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fdprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|,
name|s5
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|>
literal|0
condition|)
name|fdprintf
argument_list|(
name|stderr
argument_list|,
literal|"; line %d, file %s"
argument_list|,
name|numtab
index|[
name|CD
index|]
operator|.
name|val
argument_list|,
name|cfname
index|[
name|ifi
index|]
argument_list|)
expr_stmt|;
name|fdprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|stackdump
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|control
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
operator|(
name|j
operator|=
name|findmn
argument_list|(
name|a
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|contab
index|[
name|j
index|]
operator|.
name|f
operator|==
literal|0
condition|)
block|{
name|nxf
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|collect
argument_list|()
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
return|return
name|pushi
argument_list|(
operator|(
name|filep
operator|)
name|contab
index|[
name|j
index|]
operator|.
name|mx
argument_list|,
name|a
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|b
condition|)
return|return
operator|(
operator|(
operator|*
name|contab
index|[
name|j
index|]
operator|.
name|f
operator|)
operator|(
literal|0
operator|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getrq
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|j
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|rtn
goto|;
name|i
operator|=
name|PAIR
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rtn
label|:
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * table encodes some special characters, to speed up tests  * in getchar, viz FLSS, RPT, f, \b, \n, fc, tabch, ldrch  */
end_comment

begin_decl_stmt
name|char
name|gchtab
index|[]
init|=
block|{
literal|000
block|,
literal|004
block|,
literal|000
block|,
literal|000
block|,
literal|010
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
comment|/* fc, ldr */
literal|001
block|,
literal|002
block|,
literal|001
block|,
literal|000
block|,
literal|001
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
comment|/* \b, tab, nl, RPT */
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|001
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
comment|/* FLSS */
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|001
block|,
literal|000
block|,
comment|/* f */
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|,
literal|000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|tchar
name|getch
parameter_list|()
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|tchar
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tchar
name|setht
argument_list|()
decl_stmt|,
name|setslant
argument_list|()
decl_stmt|;
name|g0
label|:
if|if
condition|(
name|i
operator|=
name|ch
condition|)
block|{
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
name|nlflg
operator|++
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|nlflg
condition|)
return|return
operator|(
literal|'\n'
operator|)
return|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|k
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|ESC
condition|)
block|{
if|if
condition|(
name|gchtab
index|[
name|k
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
name|k
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|nlflg
operator|++
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|++
expr_stmt|;
comment|/* line number */
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
if|if
condition|(
name|k
operator|==
name|FLSS
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fi
condition|)
name|flss
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
name|k
operator|==
name|RPT
condition|)
block|{
name|setrpt
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
operator|!
name|copyf
condition|)
block|{
if|if
condition|(
name|k
operator|==
literal|'f'
operator|&&
name|lg
operator|&&
operator|!
name|lgf
condition|)
block|{
name|i
operator|=
name|getlg
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|k
operator|==
name|fc
operator|||
name|k
operator|==
name|tabch
operator|||
name|k
operator|==
name|ldrch
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|setfield
argument_list|(
name|k
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
else|else
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|k
operator|==
literal|'\b'
condition|)
block|{
name|i
operator|=
name|makem
argument_list|(
operator|-
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
name|k
operator|=
name|cbits
argument_list|(
name|j
operator|=
name|getch0
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|j
argument_list|)
condition|)
return|return
operator|(
name|j
operator|)
return|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* concealed newline */
goto|goto
name|g0
goto|;
case|case
literal|'n'
case|:
comment|/* number register */
name|setn
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'*'
case|:
comment|/* string indicator */
name|setstr
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'$'
case|:
comment|/* argument indicator */
name|seta
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'{'
case|:
comment|/* LEFT */
name|i
operator|=
name|LEFT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'}'
case|:
comment|/* RIGHT */
name|i
operator|=
name|RIGHT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'"'
case|:
comment|/* comment */
while|while
condition|(
name|cbits
argument_list|(
name|i
operator|=
name|getch0
argument_list|()
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|nlflg
operator|++
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
case|case
name|ESC
case|:
comment|/* double backslash */
name|i
operator|=
name|eschar
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'e'
case|:
comment|/* printable version of current eschar */
name|i
operator|=
name|PRESC
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|' '
case|:
comment|/* unpaddable space */
name|i
operator|=
name|UNPAD
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'\''
case|:
comment|/* \(aa */
name|i
operator|=
name|ACUTE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'`'
case|:
comment|/* \(ga */
name|i
operator|=
name|GRAVE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'_'
case|:
comment|/* \(ul */
name|i
operator|=
name|UNDERLINE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'-'
case|:
comment|/* current font minus */
name|i
operator|=
name|MINUS
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'&'
case|:
comment|/* filler */
name|i
operator|=
name|FILLER
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'c'
case|:
comment|/* to be continued */
name|i
operator|=
name|CONT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'!'
case|:
comment|/* transparent indicator */
name|i
operator|=
name|XPAR
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'t'
case|:
comment|/* tab */
name|i
operator|=
literal|'\t'
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
case|case
literal|'a'
case|:
comment|/* leader (SOH) */
name|i
operator|=
name|LEADER
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
case|case
literal|'%'
case|:
comment|/* ohc */
name|i
operator|=
name|OHC
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
case|case
literal|'g'
case|:
comment|/* return format of a number register */
name|setaf
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'N'
case|:
comment|/* absolute character number */
name|i
operator|=
name|setabs
argument_list|()
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'.'
case|:
comment|/* . */
name|i
operator|=
literal|'.'
expr_stmt|;
name|gx
label|:
name|setsfbits
argument_list|(
name|i
argument_list|,
name|sfbits
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|copyf
condition|)
block|{
operator|*
name|pbp
operator|++
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|eschar
operator|)
return|;
block|}
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'X'
case|:
comment|/* \X'...' for copy through */
name|setxon
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'p'
case|:
comment|/* spread */
name|spread
operator|++
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'('
case|:
comment|/* special char name */
if|if
condition|(
operator|(
name|i
operator|=
name|setch
argument_list|()
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
return|return
operator|(
name|i
operator|)
return|;
case|case
literal|'s'
case|:
comment|/* size indicator */
name|setps
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'H'
case|:
comment|/* character height */
return|return
operator|(
name|setht
argument_list|()
operator|)
return|;
case|case
literal|'S'
case|:
comment|/* slant */
return|return
operator|(
name|setslant
argument_list|()
operator|)
return|;
case|case
literal|'f'
case|:
comment|/* font indicator */
name|setfont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'w'
case|:
comment|/* width function */
name|setwd
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'v'
case|:
comment|/* vert mot */
if|if
condition|(
name|i
operator|=
name|vmot
argument_list|()
condition|)
return|return
operator|(
name|i
operator|)
return|;
goto|goto
name|g0
goto|;
case|case
literal|'h'
case|:
comment|/* horiz mot */
if|if
condition|(
name|i
operator|=
name|hmot
argument_list|()
condition|)
return|return
operator|(
name|i
operator|)
return|;
goto|goto
name|g0
goto|;
case|case
literal|'z'
case|:
comment|/* zero with char */
return|return
operator|(
name|setz
argument_list|()
operator|)
return|;
case|case
literal|'l'
case|:
comment|/* hor line */
name|setline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'L'
case|:
comment|/* vert line */
name|setvline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'D'
case|:
comment|/* drawing function */
name|setdraw
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'b'
case|:
comment|/* bracket */
name|setbra
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'o'
case|:
comment|/* overstrike */
name|setov
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'k'
case|:
comment|/* mark hor place */
if|if
condition|(
operator|(
name|k
operator|=
name|findr
argument_list|(
name|getsn
argument_list|()
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|numtab
index|[
name|k
index|]
operator|.
name|val
operator|=
name|numtab
index|[
name|HP
index|]
operator|.
name|val
expr_stmt|;
block|}
goto|goto
name|g0
goto|;
case|case
literal|'0'
case|:
comment|/* number space */
return|return
operator|(
name|makem
argument_list|(
name|width
argument_list|(
literal|'0'
operator||
name|chbits
argument_list|)
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|NROFF
case|case
literal|'|'
case|:
case|case
literal|'^'
case|:
goto|goto
name|g0
goto|;
else|#
directive|else
case|case
literal|'|'
case|:
comment|/* narrow space */
return|return
operator|(
name|makem
argument_list|(
call|(
name|int
call|)
argument_list|(
name|EM
argument_list|)
operator|/
literal|6
argument_list|)
operator|)
return|;
case|case
literal|'^'
case|:
comment|/* half narrow space */
return|return
operator|(
name|makem
argument_list|(
call|(
name|int
call|)
argument_list|(
name|EM
argument_list|)
operator|/
literal|12
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
literal|'x'
case|:
comment|/* extra line space */
if|if
condition|(
name|i
operator|=
name|xlss
argument_list|()
condition|)
return|return
operator|(
name|i
operator|)
return|;
goto|goto
name|g0
goto|;
case|case
literal|'u'
case|:
comment|/* half em up */
case|case
literal|'r'
case|:
comment|/* full em up */
case|case
literal|'d'
case|:
comment|/* half em down */
return|return
operator|(
name|sethl
argument_list|(
name|k
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|j
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|setxon
argument_list|()
end_macro

begin_comment
comment|/* \X'...' for copy through */
end_comment

begin_block
block|{
name|tchar
name|xbuf
index|[
name|NC
index|]
decl_stmt|;
specifier|register
name|tchar
modifier|*
name|i
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|int
name|delim
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|c
operator|=
name|getch
argument_list|()
argument_list|)
condition|)
return|return;
name|delim
operator|=
name|cbits
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|i
operator|=
name|xbuf
expr_stmt|;
operator|*
name|i
operator|++
operator|=
name|XON
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|cbits
argument_list|(
name|c
operator|=
name|getch
argument_list|()
argument_list|)
operator|)
operator|!=
name|delim
operator|&&
name|k
operator|!=
literal|'\n'
operator|&&
name|i
operator|<
name|xbuf
operator|+
name|NC
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|k
operator|==
literal|' '
condition|)
name|setcbits
argument_list|(
name|c
argument_list|,
name|UNPAD
argument_list|)
expr_stmt|;
operator|*
name|i
operator|++
operator|=
name|c
operator||
name|ZBIT
expr_stmt|;
block|}
operator|*
name|i
operator|++
operator|=
name|XOFF
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
name|pushback
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
name|char
name|ifilt
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|001
block|,
literal|002
block|,
literal|003
block|,
literal|0
block|,
literal|005
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|011
block|,
literal|012
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|tchar
name|getch0
parameter_list|()
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|tchar
name|i
decl_stmt|;
name|again
label|:
if|if
condition|(
name|pbp
operator|>
name|lastpbp
condition|)
name|i
operator|=
operator|*
operator|--
name|pbp
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
condition|)
block|{
ifdef|#
directive|ifdef
name|INCORE
specifier|extern
name|tchar
name|corebuf
index|[]
decl_stmt|;
name|i
operator|=
name|corebuf
index|[
name|ip
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|rbf
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
operator|++
name|ip
operator|&
operator|(
name|BLK
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|--
name|ip
expr_stmt|;
operator|(
name|void
operator|)
name|rbf
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
name|i
operator|=
name|rbf
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|donef
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|||
name|ibufp
operator|>=
name|eibuf
condition|)
block|{
if|if
condition|(
name|nfo
operator|==
literal|0
condition|)
block|{
name|g0
label|:
if|if
condition|(
name|nextfile
argument_list|()
condition|)
block|{
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|ibufp
operator|<
name|eibuf
condition|)
goto|goto
name|g2
goto|;
block|}
block|}
name|nx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|g0
goto|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|eibuf
operator|=
name|ibuf
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
block|}
name|g2
label|:
name|i
operator|=
operator|*
name|ibufp
operator|++
operator|&
literal|0177
expr_stmt|;
name|ioff
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|040
operator|&&
name|i
operator|<
literal|0177
condition|)
goto|goto
name|g4
goto|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|i
operator|!=
literal|0177
condition|)
name|i
operator|=
name|ifilt
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
name|IMP
operator|&&
operator|!
name|raw
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
literal|0177
operator|)
operator|&&
operator|!
name|init
operator|&&
operator|!
name|raw
condition|)
block|{
goto|goto
name|again
goto|;
block|}
name|g4
label|:
if|if
condition|(
name|copyf
operator|==
literal|0
operator|&&
operator|(
name|i
operator|&
operator|~
name|BYTEMASK
operator|)
operator|==
literal|0
condition|)
name|i
operator||=
name|chbits
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
name|eschar
operator|&&
operator|!
name|raw
condition|)
name|setcbits
argument_list|(
name|i
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|pushback
argument_list|(
name|b
argument_list|)
specifier|register
name|tchar
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|tchar
modifier|*
name|ob
init|=
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|b
operator|++
condition|)
empty_stmt|;
name|b
operator|--
expr_stmt|;
while|while
condition|(
name|b
operator|>
name|ob
operator|&&
name|pbp
operator|<
operator|&
name|pbbuf
index|[
name|NC
operator|-
literal|3
index|]
condition|)
operator|*
name|pbp
operator|++
operator|=
operator|*
operator|--
name|b
expr_stmt|;
if|if
condition|(
name|pbp
operator|>=
operator|&
name|pbbuf
index|[
name|NC
operator|-
literal|3
index|]
condition|)
block|{
name|errprint
argument_list|(
literal|"pushback overflow"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|cpushback
argument_list|(
name|b
argument_list|)
specifier|register
name|char
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ob
init|=
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|b
operator|++
condition|)
empty_stmt|;
name|b
operator|--
expr_stmt|;
while|while
condition|(
name|b
operator|>
name|ob
operator|&&
name|pbp
operator|<
operator|&
name|pbbuf
index|[
name|NC
operator|-
literal|3
index|]
condition|)
operator|*
name|pbp
operator|++
operator|=
operator|*
operator|--
name|b
expr_stmt|;
if|if
condition|(
name|pbp
operator|>=
operator|&
name|pbbuf
index|[
name|NC
operator|-
literal|3
index|]
condition|)
block|{
name|errprint
argument_list|(
literal|"cpushback overflow"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|n0
label|:
if|if
condition|(
name|ifile
condition|)
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
condition|)
block|{
name|p
operator|=
name|nextf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|n1
goto|;
block|}
if|if
condition|(
name|ifi
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|popf
argument_list|()
condition|)
goto|goto
name|n0
goto|;
comment|/* popf error */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* popf ok */
block|}
if|if
condition|(
name|rargc
operator|--
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nfo
operator|-=
name|mflg
operator|)
operator|&&
operator|!
name|stdi
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nfo
operator|++
expr_stmt|;
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
name|ifile
operator|=
name|stdi
operator|=
name|mflg
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|cfname
index|[
name|ifi
index|]
argument_list|,
literal|"<standard input>"
argument_list|)
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|argp
operator|++
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|n1
label|:
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|ifile
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|cfname
index|[
name|ifi
index|]
argument_list|,
literal|"<standard input>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errprint
argument_list|(
literal|"cannot open file %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfo
operator|-=
name|mflg
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|cfname
index|[
name|ifi
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfo
operator|++
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|popf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|ioff
operator|=
name|offl
index|[
operator|--
name|ifi
index|]
expr_stmt|;
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
name|cfline
index|[
name|ifi
index|]
expr_stmt|;
comment|/*restore line counter*/
name|ip
operator|=
name|ipl
index|[
name|ifi
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifile
operator|=
name|ifl
index|[
name|ifi
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|xbuf
expr_stmt|;
name|q
operator|=
name|ibuf
expr_stmt|;
name|ibufp
operator|=
name|xbufp
expr_stmt|;
name|eibuf
operator|=
name|xeibuf
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|ifile
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ioff
operator|&
operator|~
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|long
operator|)
operator|-
literal|1
operator|||
operator|(
name|i
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|eibuf
operator|=
name|ibuf
operator|+
name|i
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
if|if
condition|(
name|ttyname
argument_list|(
name|ifile
argument_list|)
operator|==
literal|0
condition|)
comment|/* was>= ... */
if|if
condition|(
operator|(
name|ibufp
operator|=
name|ibuf
operator|+
call|(
name|int
call|)
argument_list|(
name|ioff
operator|&
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|>
name|eibuf
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|flushi
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nflush
condition|)
return|return;
name|ch
operator|=
literal|0
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|nlflg
condition|)
block|{
if|if
condition|(
name|donef
operator|&&
operator|(
name|frame
operator|==
name|stk
operator|)
condition|)
break|break;
name|getch
argument_list|()
expr_stmt|;
block|}
name|copyf
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|getach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|tchar
name|i
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|lgf
operator|++
expr_stmt|;
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|i
argument_list|)
operator|||
name|j
operator|==
literal|' '
operator|||
name|j
operator|==
literal|'\n'
operator|||
name|j
operator|&
literal|0200
condition|)
block|{
name|ch
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|j
operator|&
literal|0177
operator|)
return|;
block|}
end_block

begin_macro
name|casenx
argument_list|()
end_macro

begin_block
block|{
name|lgf
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|getname
argument_list|()
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nextfile
argument_list|()
expr_stmt|;
name|nlflg
operator|++
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|pendt
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|stk
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|getname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|tchar
name|i
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|NS
operator|-
literal|1
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|)
operator|<=
literal|' '
operator|)
operator|||
operator|(
name|j
operator|>
literal|0176
operator|)
condition|)
break|break;
name|nextf
index|[
name|k
index|]
operator|=
name|j
expr_stmt|;
block|}
name|nextf
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|nextf
index|[
literal|0
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|caseso
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ifi
operator|>=
name|NSO
operator|)
condition|)
block|{
name|errprint
argument_list|(
literal|"can't open file %s"
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cfname
index|[
name|ifi
operator|+
literal|1
index|]
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
name|cfline
index|[
name|ifi
index|]
operator|=
name|numtab
index|[
name|CD
index|]
operator|.
name|val
expr_stmt|;
comment|/*hold line counter*/
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
name|ifl
index|[
name|ifi
index|]
operator|=
name|ifile
expr_stmt|;
name|ifile
operator|=
name|i
expr_stmt|;
name|offl
index|[
name|ifi
index|]
operator|=
name|ioff
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
name|ipl
index|[
name|ifi
index|]
operator|=
name|ip
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nflush
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ifl
index|[
name|ifi
operator|++
index|]
condition|)
block|{
name|p
operator|=
name|ibuf
expr_stmt|;
name|q
operator|=
name|xbuf
expr_stmt|;
name|xbufp
operator|=
name|ibufp
expr_stmt|;
name|xeibuf
operator|=
name|eibuf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|caself
argument_list|()
end_macro

begin_comment
comment|/* set line number and file */
end_comment

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
return|return;
name|n
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
expr_stmt|;
name|cfline
index|[
name|ifi
index|]
operator|=
name|numtab
index|[
name|CD
index|]
operator|.
name|val
operator|=
name|n
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
return|return;
if|if
condition|(
name|getname
argument_list|()
condition|)
name|strcpy
argument_list|(
name|cfname
index|[
name|ifi
index|]
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|casecf
argument_list|()
end_macro

begin_block
block|{
comment|/* copy file without change */
ifndef|#
directive|ifndef
name|NROFF
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
specifier|extern
name|int
name|hpos
decl_stmt|,
name|esc
decl_stmt|,
name|po
decl_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errprint
argument_list|(
literal|"can't open file %s"
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|tbreak
argument_list|()
expr_stmt|;
comment|/* make it into a clean state, be sure that everything is out */
name|hpos
operator|=
name|po
expr_stmt|;
name|esc
operator|=
name|un
expr_stmt|;
name|ptesc
argument_list|()
expr_stmt|;
name|ptlead
argument_list|()
expr_stmt|;
name|ptps
argument_list|()
expr_stmt|;
name|ptfont
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|casesy
argument_list|()
end_macro

begin_comment
comment|/* call system */
end_comment

begin_block
block|{
name|char
name|sybuf
index|[
name|NTM
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTM
operator|-
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sybuf
index|[
name|i
index|]
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
break|break;
name|sybuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|system
argument_list|(
name|sybuf
argument_list|)
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|lgf
operator|--
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getpn
argument_list|(
name|a
argument_list|)
specifier|register
name|char
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|neg
decl_stmt|;
if|if
condition|(
operator|*
name|a
operator|==
literal|0
condition|)
return|return;
name|neg
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|a
condition|;
name|a
operator|++
control|)
switch|switch
condition|(
operator|*
name|a
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|','
case|:
continue|continue;
case|case
literal|'-'
case|:
name|neg
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
do|do
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|a
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
do|;
name|a
operator|--
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|9999
expr_stmt|;
operator|*
name|pnp
operator|++
operator|=
name|neg
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnp
operator|>=
operator|&
name|pnlist
index|[
name|NPN
operator|-
literal|2
index|]
condition|)
block|{
name|errprint
argument_list|(
literal|"too many page numbers"
argument_list|)
expr_stmt|;
name|done3
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|neg
condition|)
operator|*
name|pnp
operator|++
operator|=
operator|-
literal|9999
expr_stmt|;
operator|*
name|pnp
operator|=
operator|-
literal|32767
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
name|pnp
operator|=
name|pnlist
expr_stmt|;
if|if
condition|(
operator|*
name|pnp
operator|!=
operator|-
literal|32767
condition|)
name|chkpn
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setrpt
argument_list|()
end_macro

begin_block
block|{
name|tchar
name|i
decl_stmt|,
name|j
decl_stmt|;
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|cbits
argument_list|(
name|j
operator|=
name|getch0
argument_list|()
argument_list|)
operator|==
name|RPT
condition|)
return|return;
name|i
operator|&=
name|BYTEMASK
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|pbp
operator|<
operator|&
name|pbbuf
index|[
name|NC
operator|-
literal|3
index|]
condition|)
block|{
name|i
operator|--
expr_stmt|;
operator|*
name|pbp
operator|++
operator|=
name|j
expr_stmt|;
block|}
block|}
end_block

end_unit

