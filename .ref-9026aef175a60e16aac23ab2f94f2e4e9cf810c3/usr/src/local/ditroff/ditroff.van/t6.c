begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)t6.c	2.2 (CWI) 87/07/10"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * t6.c  *   * width functions, sizes and fonts  */
end_comment

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_comment
comment|/* fitab[f][c] is 0 if c is not on font f 	/* if it's non-zero, c is in fontab[f] at position 	/* fitab[f][c]. 	*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|Font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fontlab
index|[
name|MAXFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cstab
index|[
name|MAXFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ccstab
index|[
name|MAXFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bdtab
index|[
name|MAXFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sbold
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|width
argument_list|(
name|j
argument_list|)
specifier|register
name|tchar
name|j
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|&
operator|(
name|ZBIT
operator||
name|MOT
operator|)
condition|)
block|{
if|if
condition|(
name|iszbit
argument_list|(
name|j
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isvmot
argument_list|(
name|j
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|k
operator|=
name|absmot
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnmot
argument_list|(
name|j
argument_list|)
condition|)
name|k
operator|=
operator|-
name|k
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
name|i
operator|=
name|cbits
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|' '
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'\b'
condition|)
return|return
operator|(
operator|-
name|widthp
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|PRESC
condition|)
name|i
operator|=
name|eschar
expr_stmt|;
elseif|else
if|if
condition|(
name|iscontrol
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
name|ohc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|trtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|32
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sfbits
argument_list|(
name|j
argument_list|)
operator|==
name|oldbits
condition|)
block|{
name|xfont
operator|=
name|pfont
expr_stmt|;
name|xpts
operator|=
name|ppts
expr_stmt|;
block|}
else|else
name|xbits
argument_list|(
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|widcache
index|[
name|i
operator|-
literal|32
index|]
operator|.
name|fontpts
operator|==
operator|(
name|xfont
operator|<<
literal|8
operator|)
operator|+
name|xpts
operator|&&
operator|!
name|setwdf
condition|)
name|k
operator|=
name|widcache
index|[
name|i
operator|-
literal|32
index|]
operator|.
name|width
expr_stmt|;
else|else
block|{
name|k
operator|=
name|getcw
argument_list|(
name|i
operator|-
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
condition|)
name|k
operator|+=
operator|(
name|bd
operator|-
literal|1
operator|)
operator|*
name|HOR
expr_stmt|;
if|if
condition|(
name|cs
condition|)
name|k
operator|=
name|cs
expr_stmt|;
block|}
name|widthp
operator|=
name|k
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * clear width cache-- s means just space  */
end_comment

begin_macro
name|zapwcache
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|widcache
index|[
literal|0
index|]
operator|.
name|fontpts
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NWIDCACHE
condition|;
name|i
operator|++
control|)
name|widcache
index|[
name|i
index|]
operator|.
name|fontpts
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getcw
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nocache
init|=
literal|0
decl_stmt|;
name|int
name|savxfont
init|=
literal|0
decl_stmt|,
name|savsbold
init|=
literal|0
decl_stmt|,
name|savulfont
init|=
literal|0
decl_stmt|;
comment|/* 	 * Here comes first part of bug fix 	 */
if|if
condition|(
name|xfont
operator|>
name|nfonts
condition|)
block|{
comment|/* font is not mounted */
name|savxfont
operator|=
name|xfont
expr_stmt|;
if|if
condition|(
name|xfont
operator|==
name|sbold
condition|)
block|{
name|savsbold
operator|=
name|sbold
expr_stmt|;
name|sbold
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xfont
operator|==
name|ulfont
condition|)
block|{
name|savulfont
operator|=
name|ulfont
expr_stmt|;
name|ulfont
operator|=
literal|0
expr_stmt|;
block|}
name|xfont
operator|=
literal|0
expr_stmt|;
name|setfp
argument_list|(
literal|0
argument_list|,
name|fontlab
index|[
name|savxfont
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bdtab
index|[
literal|0
index|]
operator|=
name|bdtab
index|[
name|savxfont
index|]
expr_stmt|;
comment|/* Save */
name|cstab
index|[
literal|0
index|]
operator|=
name|cstab
index|[
name|savxfont
index|]
expr_stmt|;
comment|/*  as  */
name|ccstab
index|[
literal|0
index|]
operator|=
name|ccstab
index|[
name|savxfont
index|]
expr_stmt|;
comment|/* well */
block|}
comment|/* End */
name|bd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|)
block|{
name|j
operator|=
name|abscw
argument_list|(
name|i
operator|+
literal|32
operator|-
operator|(
name|nchtab
operator|+
literal|128
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* a blank */
name|k
operator|=
operator|(
name|fontab
index|[
name|xfont
index|]
index|[
literal|0
index|]
operator|*
name|spacesz
operator|+
literal|6
operator|)
operator|/
literal|12
expr_stmt|;
comment|/* this nonsense because .ss cmd uses 1/36 em as its units */
comment|/* and default is 12 */
goto|goto
name|g1
goto|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|fitab
index|[
name|xfont
index|]
index|[
name|i
index|]
operator|&
name|BYTEMASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* it's not on current font */
comment|/* search through search list of xfont 		/* to see what font it ought to be on. 		/* searches S, then remaining fonts in wraparound order. 		*/
name|nocache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|smnt
condition|)
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
for|for
control|(
name|ii
operator|=
name|smnt
operator|,
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nfonts
condition|;
name|jj
operator|++
operator|,
name|ii
operator|=
name|ii
operator|%
name|nfonts
operator|+
literal|1
control|)
block|{
name|j
operator|=
name|fitab
index|[
name|ii
index|]
index|[
name|i
index|]
operator|&
name|BYTEMASK
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|fontab
index|[
name|ii
index|]
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|p
operator|+
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|xfont
operator|==
name|sbold
condition|)
name|bd
operator|=
name|bdtab
index|[
name|ii
index|]
expr_stmt|;
if|if
condition|(
name|setwdf
condition|)
name|numtab
index|[
name|CT
index|]
operator|.
name|val
operator||=
name|kerntab
index|[
name|ii
index|]
index|[
name|j
index|]
expr_stmt|;
goto|goto
name|g1
goto|;
block|}
block|}
block|}
name|k
operator|=
name|fontab
index|[
name|xfont
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* leave a space-size space */
goto|goto
name|g1
goto|;
block|}
name|g0
label|:
name|p
operator|=
name|fontab
index|[
name|xfont
index|]
expr_stmt|;
if|if
condition|(
name|setwdf
condition|)
name|numtab
index|[
name|CT
index|]
operator|.
name|val
operator||=
name|kerntab
index|[
name|xfont
index|]
index|[
name|j
index|]
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|p
operator|+
name|j
operator|)
expr_stmt|;
name|g1
label|:
if|if
condition|(
operator|!
name|bd
condition|)
name|bd
operator|=
name|bdtab
index|[
name|xfont
index|]
expr_stmt|;
if|if
condition|(
name|cs
operator|=
name|cstab
index|[
name|xfont
index|]
condition|)
block|{
name|nocache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ccs
operator|=
name|ccstab
index|[
name|xfont
index|]
condition|)
name|x
operator|=
name|ccs
expr_stmt|;
else|else
name|x
operator|=
name|xpts
expr_stmt|;
name|cs
operator|=
operator|(
name|cs
operator|*
name|EMPTS
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|36
expr_stmt|;
block|}
name|k
operator|=
operator|(
operator|(
name|k
operator|&
name|BYTEMASK
operator|)
operator|*
name|xpts
operator|+
operator|(
name|Unitwidth
operator|/
literal|2
operator|)
operator|)
operator|/
name|Unitwidth
expr_stmt|;
comment|/* 	 * undo the fontswap 	 */
if|if
condition|(
name|savxfont
condition|)
block|{
name|xfont
operator|=
name|savxfont
expr_stmt|;
if|if
condition|(
name|savsbold
condition|)
name|sbold
operator|=
name|savsbold
expr_stmt|;
if|if
condition|(
name|savulfont
condition|)
name|ulfont
operator|=
name|savulfont
expr_stmt|;
comment|/* 		 * H'm, I guess we should not put 		 * this width in the cache 		 */
name|nocache
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nocache
operator||
name|bd
condition|)
name|widcache
index|[
name|i
index|]
operator|.
name|fontpts
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|widcache
index|[
name|i
index|]
operator|.
name|fontpts
operator|=
operator|(
name|xfont
operator|<<
literal|8
operator|)
operator|+
name|xpts
expr_stmt|;
name|widcache
index|[
name|i
index|]
operator|.
name|width
operator|=
name|k
expr_stmt|;
block|}
return|return
operator|(
name|k
operator|)
return|;
comment|/* Unitwidth is Units/Point, where 	/* Units is the fundamental digitization 	/* of the character set widths, and 	/* Point is the number of goobies in a point 	/* e.g., for cat, Units=36, Point=6, so Unitwidth=36/6=6 	/* In effect, it's the size at which the widths 	/* translate directly into units. 	*/
block|}
end_block

begin_macro
name|abscw
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* return index of abs char n in fontab[], etc. */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ncf
decl_stmt|;
name|ncf
operator|=
name|fontbase
index|[
name|xfont
index|]
operator|->
name|nwfont
operator|&
name|BYTEMASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncf
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|codetab
index|[
name|xfont
index|]
index|[
name|i
index|]
operator|==
name|n
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
name|xbits
argument_list|(
name|i
argument_list|,
name|bitf
argument_list|)
specifier|register
name|tchar
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
name|xfont
operator|=
name|fbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
name|sbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|xpts
operator|=
name|pstab
index|[
operator|--
name|k
index|]
expr_stmt|;
name|oldbits
operator|=
name|sfbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pfont
operator|=
name|xfont
expr_stmt|;
name|ppts
operator|=
name|xpts
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|bitf
condition|)
block|{
case|case
literal|0
case|:
name|xfont
operator|=
name|font
expr_stmt|;
name|xpts
operator|=
name|pts
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|xfont
operator|=
name|pfont
expr_stmt|;
name|xpts
operator|=
name|ppts
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|xfont
operator|=
name|mfont
expr_stmt|;
name|xpts
operator|=
name|mpts
expr_stmt|;
block|}
block|}
end_block

begin_function
name|tchar
name|setch
parameter_list|()
block|{
specifier|register
name|j
expr_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|extern
name|char
modifier|*
name|chname
decl_stmt|;
specifier|extern
name|short
modifier|*
name|chtab
decl_stmt|;
specifier|extern
name|int
name|nchtab
decl_stmt|;
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|||
operator|(
operator|*
name|s
operator|++
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchtab
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|j
index|]
index|]
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|+
literal|128
operator||
name|chbits
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|setabs
parameter_list|()
comment|/* set absolute char from \C'...' */
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nf
decl_stmt|;
specifier|extern
name|int
name|nchtab
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|inumb
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
return|return
literal|0
return|;
return|return
name|n
operator|+
name|nchtab
operator|+
literal|128
return|;
block|}
end_function

begin_comment
comment|/*  * I (jaap) expand fontlab to the maximum of fonts troff can  * handle. The maximum number i, due to the two chars  * fontname limit, is 99.  * If we don't use the (named) font in one of the  * standard position, we install the name in the next  * free slot. Whenever we need info about the font, we  * read in the data at position zero, and secretly use  * the data (actually only necessary for the width  * and ligature info). The ptfont() (t10.c) routine will tell  * the device filter to put the font always at position  * zero if xfont> physfonts, so no need to change these filters.  * Yes, this is a bit kludgy.  *  * This gives the new specs of findft:  *  * find the font name i, where i also can be a number.  *  * Installs the font(name) i when not present  *  * returns -1 on error  */
end_comment

begin_expr_stmt
name|findft
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|unpair
parameter_list|()
function_decl|;
name|p
operator|=
name|unpair
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* first look for numbers */
if|if
condition|(
name|isdigit
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|k
operator|=
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|k
operator|=
literal|10
operator|*
name|k
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* 		fprintf(ptid, "x xxx it's a number: %d\n", k); 		*/
if|if
condition|(
name|k
operator|>
literal|0
operator|&&
name|k
operator|<=
name|nfonts
operator|&&
name|fontbase
index|[
name|k
index|]
operator|->
name|specfont
operator|==
literal|0
condition|)
block|{
comment|/* 			fprintf(ptid, "x xxx it's a mounted font\n"); 			*/
return|return
operator|(
name|k
operator|)
return|;
comment|/* mounted font */
block|}
if|if
condition|(
name|fontlab
index|[
name|k
index|]
operator|&&
name|k
operator|<=
name|MAXFONTS
condition|)
block|{
comment|/* translate */
comment|/* 			fprintf(ptid, "x xxx font exists\n"); 			*/
return|return
operator|(
name|k
operator|)
return|;
comment|/*number to a name */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: no font at position %d\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* wild number */
block|}
block|}
comment|/* 	 * Now we look for font names 	 */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|fontlab
index|[
name|k
index|]
operator|!=
name|i
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|>
name|MAXFONTS
operator|+
literal|1
condition|)
comment|/* the +1 is for the ``font cache'' */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* running out of fontlab space */
if|if
condition|(
operator|!
name|fontlab
index|[
name|k
index|]
condition|)
block|{
comment|/* passed all existing names */
if|if
condition|(
name|k
operator|<=
name|NFONT
condition|)
block|{
if|if
condition|(
name|setfp
argument_list|(
name|k
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nfonts
operator|=
name|k
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setfp
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			fprintf(ptid, "x xxx installed %s on %d\n", name ,k); 			*/
comment|/* now install the name */
name|fontlab
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
comment|/* 				 * and remember accociated with 				 * this font, ligature info etc. 				*/
return|return
operator|(
name|k
operator|)
return|;
block|}
block|}
return|return
operator|(
name|k
operator|)
return|;
comment|/* was one of the existing names */
block|}
end_block

begin_macro
name|caseps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
name|i
operator|=
name|apts1
expr_stmt|;
else|else
block|{
name|noscale
operator|++
expr_stmt|;
name|i
operator|=
name|inumb
argument_list|(
operator|&
name|apts
argument_list|)
expr_stmt|;
comment|/* this is a disaster for fractional point sizes */
name|noscale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
return|return;
block|}
name|casps1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|casps1
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*  * in olden times, it used to ignore changes to 0 or negative.  * this is meant to allow the requested size to be anything,  * in particular so eqn can generate lots of \s-3's and still  * get back by matching \s+3's.  	if (i<= 0) 		return; */
name|apts1
operator|=
name|apts
expr_stmt|;
name|apts
operator|=
name|i
expr_stmt|;
name|pts1
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|findps
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|findps
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|j
operator|,
name|k
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
operator|=
literal|0
init|;
name|pstab
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|abs
argument_list|(
name|pstab
index|[
name|j
index|]
operator|-
name|i
argument_list|)
operator|<
name|abs
argument_list|(
name|pstab
index|[
name|k
index|]
operator|-
name|i
argument_list|)
condition|)
name|k
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|pstab
index|[
name|k
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|mchbits
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|i
operator|=
name|pts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|>
operator|(
name|k
operator|=
name|pstab
index|[
name|j
index|]
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|k
condition|)
block|{
name|k
operator|=
name|pstab
index|[
operator|--
name|j
index|]
expr_stmt|;
break|break;
block|}
name|chbits
operator|=
literal|0
expr_stmt|;
name|setsbits
argument_list|(
name|chbits
argument_list|,
operator|++
name|j
argument_list|)
expr_stmt|;
name|setfbits
argument_list|(
name|chbits
argument_list|,
name|font
argument_list|)
expr_stmt|;
name|sps
operator|=
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
expr_stmt|;
name|zapwcache
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* \sd or \sdd */
name|i
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* \s0 */
name|j
operator|=
name|apts1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|3
operator|&&
name|isdigit
argument_list|(
name|j
operator|=
name|cbits
argument_list|(
name|ch
operator|=
name|getch
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|/* \sdd */
name|j
operator|=
literal|10
operator|*
name|i
operator|+
name|j
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* \sd */
name|j
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'('
condition|)
block|{
comment|/* \s(dd */
name|j
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|j
operator|=
literal|10
operator|*
name|j
operator|+
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
comment|/* \s(00 */
name|j
operator|=
name|apts1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'+'
operator|||
name|i
operator|==
literal|'-'
condition|)
block|{
comment|/* \s+, \s- */
name|j
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|j
argument_list|)
condition|)
block|{
comment|/* \s+d, \s-d */
name|j
operator|-=
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|'('
condition|)
block|{
comment|/* \s+(dd, \s-(dd */
name|j
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|j
operator|=
literal|10
operator|*
name|j
operator|+
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|'-'
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
name|j
operator|+=
name|apts
expr_stmt|;
block|}
name|casps1
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|setht
parameter_list|()
comment|/* set character height from \H'...' */
block|{
name|int
name|n
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|n
operator|=
name|inumb
argument_list|(
operator|&
name|apts
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|nonumb
condition|)
name|n
operator|=
name|apts
expr_stmt|;
comment|/* does this work? */
name|c
operator|=
name|CHARHT
expr_stmt|;
name|c
operator||=
name|ZBIT
expr_stmt|;
name|setsbits
argument_list|(
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|setslant
parameter_list|()
comment|/* set slant from \S'...' */
block|{
name|int
name|n
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|inumb
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|SLANT
expr_stmt|;
name|c
operator||=
name|ZBIT
expr_stmt|;
name|setsfbits
argument_list|(
name|c
argument_list|,
name|n
operator|+
literal|180
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_macro
name|caseft
argument_list|()
end_macro

begin_block
block|{
name|skip
argument_list|()
expr_stmt|;
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|i
operator|=
name|getrq
argument_list|()
expr_stmt|;
else|else
name|i
operator|=
name|getsn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|||
name|i
operator|==
literal|'P'
condition|)
block|{
name|j
operator|=
name|font1
expr_stmt|;
goto|goto
name|s0
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|'S'
operator|||
name|i
operator|==
literal|'0'
condition|)
return|return;
if|if
condition|(
operator|(
name|j
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
ifdef|#
directive|ifdef
name|notdef
comment|/* findft does the setfp if possible */
if|if
condition|(
operator|(
name|j
operator|=
name|setfp
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* try to put it in position 0 */
endif|#
directive|endif
return|return;
name|s0
label|:
name|font1
operator|=
name|font
expr_stmt|;
name|font
operator|=
name|j
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setwd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|base
operator|,
name|wid
expr_stmt|;
specifier|register
name|tchar
name|i
decl_stmt|;
name|int
name|delim
decl_stmt|,
name|emsz
decl_stmt|,
name|k
decl_stmt|;
name|int
name|savhp
decl_stmt|,
name|savapts
decl_stmt|,
name|savapts1
decl_stmt|,
name|savfont
decl_stmt|,
name|savfont1
decl_stmt|,
name|savpts
decl_stmt|,
name|savpts1
decl_stmt|;
name|base
operator|=
name|numtab
index|[
name|ST
index|]
operator|.
name|val
operator|=
name|numtab
index|[
name|ST
index|]
operator|.
name|val
operator|=
name|wid
operator|=
name|numtab
index|[
name|CT
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
condition|)
return|return;
name|delim
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|savhp
operator|=
name|numtab
index|[
name|HP
index|]
operator|.
name|val
expr_stmt|;
name|numtab
index|[
name|HP
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|savapts
operator|=
name|apts
expr_stmt|;
name|savapts1
operator|=
name|apts1
expr_stmt|;
name|savfont
operator|=
name|font
expr_stmt|;
name|savfont1
operator|=
name|font1
expr_stmt|;
name|savpts
operator|=
name|pts
expr_stmt|;
name|savpts1
operator|=
name|pts1
expr_stmt|;
name|setwdf
operator|++
expr_stmt|;
while|while
condition|(
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|!=
name|delim
operator|&&
operator|!
name|nlflg
condition|)
block|{
name|k
operator|=
name|width
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|wid
operator|+=
name|k
expr_stmt|;
name|numtab
index|[
name|HP
index|]
operator|.
name|val
operator|+=
name|k
expr_stmt|;
if|if
condition|(
operator|!
name|ismot
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|emsz
operator|=
name|POINT
operator|*
name|xpts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isvmot
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|k
operator|=
name|absmot
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnmot
argument_list|(
name|i
argument_list|)
condition|)
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|base
operator|-=
name|k
expr_stmt|;
name|emsz
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|base
operator|<
name|numtab
index|[
name|SB
index|]
operator|.
name|val
condition|)
name|numtab
index|[
name|SB
index|]
operator|.
name|val
operator|=
name|base
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|base
operator|+
name|emsz
operator|)
operator|>
name|numtab
index|[
name|ST
index|]
operator|.
name|val
condition|)
name|numtab
index|[
name|ST
index|]
operator|.
name|val
operator|=
name|k
expr_stmt|;
block|}
name|setn1
argument_list|(
name|wid
argument_list|,
literal|0
argument_list|,
operator|(
name|tchar
operator|)
literal|0
argument_list|)
expr_stmt|;
name|numtab
index|[
name|HP
index|]
operator|.
name|val
operator|=
name|savhp
expr_stmt|;
name|apts
operator|=
name|savapts
expr_stmt|;
name|apts1
operator|=
name|savapts1
expr_stmt|;
name|font
operator|=
name|savfont
expr_stmt|;
name|font1
operator|=
name|savfont1
expr_stmt|;
name|pts
operator|=
name|savpts
expr_stmt|;
name|pts1
operator|=
name|savpts1
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
name|setwdf
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|vmot
parameter_list|()
block|{
name|dfact
operator|=
name|lss
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
return|return
operator|(
name|mot
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|hmot
parameter_list|()
block|{
name|dfact
operator|=
name|EM
expr_stmt|;
return|return
operator|(
name|mot
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|mot
parameter_list|()
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|tchar
name|i
decl_stmt|;
name|j
operator|=
name|HOR
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
comment|/*eat delim*/
if|if
condition|(
name|n
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
condition|)
block|{
if|if
condition|(
name|vflag
condition|)
name|j
operator|=
name|VERT
expr_stmt|;
name|i
operator|=
name|makem
argument_list|(
name|quant
argument_list|(
name|n
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
name|dfact
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|sethl
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
block|{
specifier|register
name|j
expr_stmt|;
name|tchar
name|i
decl_stmt|;
name|j
operator|=
name|EM
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|'u'
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
literal|'r'
condition|)
name|j
operator|=
operator|-
literal|2
operator|*
name|j
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
name|i
operator|=
name|makem
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|makem
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|tchar
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|i
operator|)
operator|<
literal|0
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
name|j
operator||=
name|MOT
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|j
operator||=
name|NMOT
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|j
operator||=
name|VMOT
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|getlg
parameter_list|(
name|i
parameter_list|)
name|tchar
name|i
decl_stmt|;
block|{
name|tchar
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
name|lf
decl_stmt|;
comment|/* remember to map the font */
if|if
condition|(
operator|(
name|lf
operator|=
name|fontbase
index|[
name|fbits
argument_list|(
name|i
argument_list|)
operator|>
name|nfonts
condition|?
literal|0
else|:
name|fbits
argument_list|(
name|i
argument_list|)
index|]
operator|->
name|ligfont
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* font lacks ligatures */
return|return
operator|(
name|i
operator|)
return|;
block|}
name|j
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|lf
operator|&
name|LFI
operator|)
condition|)
name|j
operator|=
name|LIG_FI
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'l'
operator|&&
operator|(
name|lf
operator|&
name|LFL
operator|)
condition|)
name|j
operator|=
name|LIG_FL
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'f'
operator|&&
operator|(
name|lf
operator|&
name|LFF
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lf
operator|&
operator|(
name|LFFI
operator||
name|LFFL
operator|)
operator|)
operator|&&
name|lg
operator|!=
literal|2
condition|)
block|{
name|k
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|k
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|lf
operator|&
name|LFFI
operator|)
condition|)
name|j
operator|=
name|LIG_FFI
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|k
argument_list|)
operator|==
literal|'l'
operator|&&
operator|(
name|lf
operator|&
name|LFFL
operator|)
condition|)
name|j
operator|=
name|LIG_FFL
expr_stmt|;
else|else
block|{
operator|*
name|pbp
operator|++
operator|=
name|k
expr_stmt|;
name|j
operator|=
name|LIG_FF
expr_stmt|;
block|}
block|}
else|else
name|j
operator|=
name|LIG_FF
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pbp
operator|++
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|&
name|SFMASK
operator||
name|j
operator|)
return|;
block|}
end_function

begin_macro
name|caselg
argument_list|()
end_macro

begin_block
block|{
name|lg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
return|return;
name|lg
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|casefp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|skip
argument_list|()
expr_stmt|;
comment|/* allow .fp for fonts>nfonts,<NFONTS? */
if|if
condition|(
operator|(
name|i
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nfonts
condition|)
name|errprint
argument_list|(
literal|"fp: bad font position %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
operator|(
name|j
operator|=
name|getrq
argument_list|()
operator|)
condition|)
name|errprint
argument_list|(
literal|"fp: no font name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
condition|)
name|setfp
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* 3rd argument = filename */
name|setfp
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|setfp
argument_list|(
name|pos
argument_list|,
name|f
argument_list|,
name|truename
argument_list|)
comment|/* mount font f at position pos[0...NFONTS] */
specifier|register
name|pos
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|truename
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
specifier|register
name|struct
name|Font
modifier|*
name|ft
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|longname
index|[
name|NS
index|]
decl_stmt|,
name|shortname
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
name|int
name|nchtab
decl_stmt|;
specifier|extern
name|struct
name|dev
name|dev
decl_stmt|;
if|if
condition|(
name|fontlab
index|[
name|pos
index|]
operator|==
name|f
condition|)
comment|/* if f already mounted at pos, */
return|return
operator|(
name|pos
operator|)
return|;
comment|/* don't remount it */
name|zapwcache
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|truename
condition|)
name|strcpy
argument_list|(
name|shortname
argument_list|,
name|truename
argument_list|)
expr_stmt|;
else|else
block|{
name|shortname
index|[
literal|0
index|]
operator|=
name|f
operator|&
name|BYTEMASK
expr_stmt|;
name|shortname
index|[
literal|1
index|]
operator|=
name|f
operator|>>
name|BYTE
expr_stmt|;
name|shortname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|longname
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|fontfile
argument_list|,
name|devname
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|open
argument_list|(
name|longname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errprint
argument_list|(
literal|"Can't open %s"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ft
operator|=
name|fontbase
index|[
name|pos
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|ft
operator|=
name|fontbase
index|[
name|pos
index|]
operator|=
operator|(
expr|struct
name|Font
operator|*
operator|)
name|malloc
argument_list|(
name|EXTRAFONT
argument_list|)
expr_stmt|;
name|ft
operator|->
name|nwfont
operator|=
name|MAXCHARS
expr_stmt|;
name|fontab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ft
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|n
operator|=
name|ft
operator|->
name|nwfont
expr_stmt|;
name|read
argument_list|(
name|k
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ft
argument_list|,
literal|3
operator|*
name|n
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|k
operator|=
name|ft
operator|->
name|nwfont
expr_stmt|;
name|kerntab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontab
index|[
name|pos
index|]
operator|+
name|k
expr_stmt|;
name|codetab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontab
index|[
name|pos
index|]
operator|+
literal|2
operator|*
name|k
expr_stmt|;
comment|/* have to reset the fitab pointer because the width may be different */
name|fitab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontab
index|[
name|pos
index|]
operator|+
literal|3
operator|*
name|k
expr_stmt|;
name|ft
operator|->
name|nwfont
operator|=
name|n
expr_stmt|;
comment|/* so can load a larger one again later */
if|if
condition|(
name|k
operator|>
name|n
condition|)
block|{
name|errprint
argument_list|(
literal|"Font %s too big for position %d"
argument_list|,
name|shortname
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pos
operator|==
name|smnt
condition|)
block|{
name|smnt
operator|=
literal|0
expr_stmt|;
name|sbold
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fontlab
index|[
name|pos
index|]
operator|=
name|f
operator|)
operator|==
literal|'S'
condition|)
name|smnt
operator|=
name|pos
expr_stmt|;
name|bdtab
index|[
name|pos
index|]
operator|=
name|cstab
index|[
name|pos
index|]
operator|=
name|ccstab
index|[
name|pos
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if there is a directory, no place to store its name. */
comment|/* if position isn't zero, no place to store its value. */
comment|/* only time a FONTPOS is pushed back is if it's a */
comment|/* standard font on position 0 (i.e., mounted implicitly. */
comment|/* there's a bug here:  if there are several input lines */
comment|/* that look like .ft XX in short successtion, the output */
comment|/* will all be in the last one because the "x font ..." */
comment|/* comes out too soon.  pushing back FONTPOS doesn't work */
comment|/* with .ft commands because input is flushed after .xx cmds */
comment|/* 		 * Trying to fix this FONTPOS problem: See findft() 		 */
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|physfonts
condition|)
name|ptfpcmd
argument_list|(
name|pos
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_block

begin_macro
name|casecs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|getrq
argument_list|()
operator|)
operator|||
operator|(
name|i
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|rtn
goto|;
name|skip
argument_list|()
expr_stmt|;
name|cstab
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|j
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|ccstab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|ccstab
index|[
name|i
index|]
operator|=
name|findps
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|rtn
label|:
name|zapwcache
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|casebd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|zapwcache
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|bd0
label|:
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
operator|(
name|i
operator|=
name|getrq
argument_list|()
operator|)
operator|||
operator|(
name|j
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|k
condition|)
goto|goto
name|bd1
goto|;
else|else
return|return;
block|}
if|if
condition|(
name|j
operator|==
name|smnt
condition|)
block|{
name|k
operator|=
name|smnt
expr_stmt|;
goto|goto
name|bd0
goto|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|sbold
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|bd1
label|:
name|skip
argument_list|()
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|bdtab
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
expr_stmt|;
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|casevs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
name|dfact
operator|=
name|INCH
expr_stmt|;
comment|/* default scaling is points! */
name|dfactd
operator|=
literal|72
expr_stmt|;
name|res
operator|=
name|VERT
expr_stmt|;
name|i
operator|=
name|inumb
argument_list|(
operator|&
name|lss
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|i
operator|=
name|lss1
expr_stmt|;
comment|/*	if(i< VERT)i = VERT; */
if|if
condition|(
name|i
operator|<
name|VERT
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|lss1
operator|=
name|lss
expr_stmt|;
name|lss
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_macro
name|casess
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|=
operator|(
name|int
operator|)
name|atoi0
argument_list|()
condition|)
block|{
name|spacesz
operator|=
name|i
operator|&
literal|0177
expr_stmt|;
name|zapwcache
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sps
operator|=
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
expr_stmt|;
block|}
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|xlss
parameter_list|()
block|{
comment|/* stores \x'...' into 	/* two successive tchars. 	/* the first contains HX, the second the value, 	/* encoded as a vertical motion. 	/* decoding is done in n2.c by pchar(). 	*/
name|int
name|i
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|dfact
operator|=
name|lss
expr_stmt|;
name|i
operator|=
name|quant
argument_list|(
operator|(
name|int
operator|)
name|atoi0
argument_list|()
argument_list|,
name|VERT
argument_list|)
expr_stmt|;
name|dfact
operator|=
literal|1
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
operator|*
name|pbp
operator|++
operator|=
name|MOT
operator||
name|VMOT
operator||
name|i
expr_stmt|;
else|else
operator|*
name|pbp
operator|++
operator|=
name|MOT
operator||
name|VMOT
operator||
name|NMOT
operator||
operator|-
name|i
expr_stmt|;
return|return
operator|(
name|HX
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unpair
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|static
name|char
name|name
index|[
literal|3
index|]
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|i
operator|&
name|BYTEMASK
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|i
operator|>>
name|BYTE
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

end_unit

