begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"../hdr/had.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)prt.c	4.3	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Program to print parts or all of an SCCS file. 	Arguments to the program may appear in any order 	and consist of keyletters, which begin with '-', 	and named files.  	If a direcory is given as an argument, each 	SCCS file within the directory is processed as if 	it had been specifically named. If a name of '-' 	is given, the standard input is read for a list 	of names of SCCS files to be processed. 	Non-SCCS files are ignored. */
end_comment

begin_define
define|#
directive|define
name|NOEOF
value|0
end_define

begin_define
define|#
directive|define
name|BLANK
parameter_list|(
name|p
parameter_list|)
value|while (!(*p == ' ' || *p == '\t')) p++;
end_define

begin_decl_stmt
name|char
name|had
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|iptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|statistics
index|[
literal|25
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|delent
block|{
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|osid
decl_stmt|;
name|char
modifier|*
name|datetime
decl_stmt|;
name|char
modifier|*
name|pgmr
decl_stmt|;
name|char
modifier|*
name|serial
decl_stmt|;
name|char
modifier|*
name|pred
decl_stmt|;
block|}
name|del
struct|;
end_struct

begin_decl_stmt
name|int
name|num_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cutoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|revcut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ysid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flagdesc
index|[
literal|26
index|]
init|=
block|{
literal|""
block|,
literal|"branch"
block|,
literal|"ceiling"
block|,
literal|"default SID"
block|,
literal|""
block|,
literal|"floor"
block|,
literal|""
block|,
literal|""
block|,
literal|"id keywd err/warn"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"module"
block|,
literal|"null delta"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"type"
block|,
literal|""
block|,
literal|"validate MRs"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|testklt
decl_stmt|;
extern|extern prt(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Set flags for 'fatal' to issue message, call clean-up 	routine, and terminate processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|testklt
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	The following loop processes keyletters and arguments. 	Note that these are processed only once for each 	invocation of 'main'. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|p
operator|=
operator|&
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'e'
case|:
comment|/* print everything but body */
case|case
literal|'s'
case|:
comment|/* print only delta desc. and stats */
case|case
literal|'d'
case|:
comment|/* print whole delta table */
case|case
literal|'a'
case|:
comment|/* print all deltas */
case|case
literal|'i'
case|:
comment|/* print inc, exc, and ignore info */
case|case
literal|'u'
case|:
comment|/* print users allowed to do deltas */
case|case
literal|'f'
case|:
comment|/* print flags */
case|case
literal|'t'
case|:
comment|/* print descriptive user-text */
case|case
literal|'b'
case|:
comment|/* print body */
break|break;
case|case
literal|'y'
case|:
comment|/* delta cutoff */
name|ysid
operator|=
name|p
expr_stmt|;
name|prefix
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* time cutoff */
if|if
condition|(
operator|*
name|p
operator|&&
name|date_ab
argument_list|(
name|p
argument_list|,
operator|&
name|cutoff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad date/time (cm5)"
argument_list|)
expr_stmt|;
name|prefix
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* reverse time cutoff */
if|if
condition|(
operator|*
name|p
operator|&&
name|date_ab
argument_list|(
name|p
argument_list|,
operator|&
name|revcut
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad date/time (cm5)"
argument_list|)
expr_stmt|;
name|prefix
operator|++
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown key letter (cm1)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had
index|[
name|c
operator|-
literal|'a'
index|]
operator|++
operator|&&
name|testklt
operator|++
condition|)
name|fatal
argument_list|(
literal|"key letter twice (cm2)"
argument_list|)
expr_stmt|;
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|num_files
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"missing file arg (cm3)"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|HADC
operator|&&
name|HADR
condition|)
name|fatal
argument_list|(
literal|"both 'c' and 'r' keyletters specified (pr2)"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Change flags for 'fatal' so that it will return to this 	routine (main) instead of terminating processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|&=
operator|~
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator||=
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Call 'prt' routine for each file argument. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|j
index|]
condition|)
name|do_file
argument_list|(
name|p
argument_list|,
name|prt
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* 	Routine that actually performs the 'prt' functions. */
end_comment

begin_expr_stmt
unit|prt
operator|(
name|file
operator|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|stopdel
decl_stmt|;
name|int
name|user
decl_stmt|,
name|flag
decl_stmt|,
name|text
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|bindate
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
comment|/* set up to return here from 'fatal' */
return|return;
comment|/* and return to caller of prt */
if|if
condition|(
name|HADE
condition|)
name|HADD
operator|=
name|HADI
operator|=
name|HADU
operator|=
name|HADF
operator|=
name|HADT
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|HADU
operator|&&
operator|!
name|HADF
operator|&&
operator|!
name|HADT
operator|&&
operator|!
name|HADB
condition|)
name|HADD
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|HADD
condition|)
name|HADR
operator|=
name|HADS
operator|=
name|HADA
operator|=
name|HADI
operator|=
name|HADY
operator|=
name|HADC
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HADS
operator|&&
name|HADI
condition|)
name|fatal
argument_list|(
literal|"s and i conflict (pr1)"
argument_list|)
expr_stmt|;
name|iptr
operator|=
name|xfopen
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|CTLCHAR
operator|||
operator|*
name|p
operator|!=
name|HEAD
condition|)
name|fatal
argument_list|(
literal|"not an sccs file (co2)"
argument_list|)
expr_stmt|;
name|stopdel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADD
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|++
operator|==
name|CTLCHAR
operator|&&
operator|*
name|p
operator|++
operator|==
name|STATS
operator|&&
operator|!
name|stopdel
condition|)
block|{
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|p
argument_list|,
name|statistics
argument_list|)
expr_stmt|;
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
expr_stmt|;
name|getdel
argument_list|(
operator|&
name|del
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HADA
operator|&&
name|del
operator|.
name|type
operator|!=
literal|'D'
condition|)
block|{
name|read_to
argument_list|(
name|EDELTAB
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|HADC
condition|)
block|{
name|date_ab
argument_list|(
name|del
operator|.
name|datetime
argument_list|,
operator|&
name|bindate
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindate
operator|<
name|cutoff
condition|)
block|{
name|stopdel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|HADR
condition|)
block|{
name|date_ab
argument_list|(
name|del
operator|.
name|datetime
argument_list|,
operator|&
name|bindate
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindate
operator|>=
name|revcut
condition|)
block|{
name|read_to
argument_list|(
name|EDELTAB
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|HADY
operator|&&
operator|(
name|equal
argument_list|(
name|del
operator|.
name|osid
argument_list|,
name|ysid
argument_list|)
operator|||
operator|!
operator|(
operator|*
name|ysid
operator|)
operator|)
condition|)
name|stopdel
operator|=
literal|1
expr_stmt|;
name|printdel
argument_list|(
name|file
argument_list|,
operator|&
name|del
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|++
operator|==
name|CTLCHAR
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|EDELTAB
condition|)
break|break;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|INCLUDE
case|:
if|if
condition|(
name|HADI
condition|)
name|printit
argument_list|(
name|file
argument_list|,
literal|"Included:\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCLUDE
case|:
if|if
condition|(
name|HADI
condition|)
name|printit
argument_list|(
name|file
argument_list|,
literal|"Excluded:\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
if|if
condition|(
name|HADI
condition|)
name|printit
argument_list|(
name|file
argument_list|,
literal|"Ignored:\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRNUM
case|:
if|if
condition|(
operator|!
name|HADS
condition|)
name|printit
argument_list|(
name|file
argument_list|,
literal|"MRs:\t"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMENTS
case|:
if|if
condition|(
operator|!
name|HADS
condition|)
name|printit
argument_list|(
name|file
argument_list|,
literal|""
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"format error at line %d (co4)"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|Error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prefix
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopdel
operator|&&
operator|!
operator|(
name|line
index|[
literal|0
index|]
operator|==
name|CTLCHAR
operator|&&
name|line
index|[
literal|1
index|]
operator|==
name|BUSERNAM
operator|)
condition|)
name|read_to
argument_list|(
name|BUSERNAM
argument_list|)
expr_stmt|;
block|}
else|else
name|read_to
argument_list|(
name|BUSERNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADU
condition|)
block|{
name|user
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nUsers allowed to make deltas --\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
name|CTLCHAR
condition|)
block|{
name|user
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|user
condition|)
name|printf
argument_list|(
literal|"\teveryone\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|read_to
argument_list|(
name|EUSERNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADF
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nFlags --\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|++
operator|==
name|CTLCHAR
operator|&&
operator|*
name|p
operator|++
operator|==
name|FLAG
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|flagdesc
index|[
operator|*
name|p
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|p
condition|)
block|{
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag
condition|)
name|printf
argument_list|(
literal|"\tnone\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|read_to
argument_list|(
name|BUSERTXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADT
condition|)
block|{
name|text
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nDescription --\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
name|CTLCHAR
condition|)
block|{
name|text
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|text
condition|)
name|printf
argument_list|(
literal|"\tnone\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|read_to
argument_list|(
name|EUSERTXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADB
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|lineread
argument_list|(
name|EOF
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|==
name|CTLCHAR
condition|)
name|printf
argument_list|(
literal|"*** %s"
argument_list|,
operator|++
name|p
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|iptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getdel
argument_list|(
name|delp
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|delent
operator|*
name|delp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lp
operator|+=
literal|2
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|type
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|osid
operator|=
name|lp
expr_stmt|;
name|BLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|datetime
operator|=
name|lp
expr_stmt|;
name|BLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|BLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|pgmr
operator|=
name|lp
expr_stmt|;
name|BLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|serial
operator|=
name|lp
expr_stmt|;
name|BLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|NONBLANK
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|delp
operator|->
name|pred
operator|=
name|lp
expr_stmt|;
name|repl
argument_list|(
name|lp
argument_list|,
literal|'\n'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|read_to
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|lineread
argument_list|(
name|NOEOF
argument_list|)
operator|)
operator|&&
operator|!
operator|(
operator|*
name|n
operator|++
operator|==
name|CTLCHAR
operator|&&
operator|*
name|n
operator|==
name|ch
operator|)
condition|)
empty_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|lineread
argument_list|(
name|eof
argument_list|)
specifier|register
name|int
name|eof
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|k
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
operator|&&
operator|!
name|eof
condition|)
name|fatal
argument_list|(
literal|"premature eof (co5)"
argument_list|)
expr_stmt|;
name|linenum
operator|++
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|printdel
argument_list|(
name|file
argument_list|,
name|delp
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|delent
modifier|*
name|delp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|statistics
index|[
name|length
argument_list|(
name|statistics
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%c %s\t%s\t%s\t%s\t%s\t%s"
argument_list|,
name|delp
operator|->
name|type
argument_list|,
name|delp
operator|->
name|osid
argument_list|,
name|delp
operator|->
name|datetime
argument_list|,
name|delp
operator|->
name|pgmr
argument_list|,
name|delp
operator|->
name|serial
argument_list|,
name|delp
operator|->
name|pred
argument_list|,
name|statistics
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|printit
argument_list|(
name|file
argument_list|,
name|str
argument_list|,
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cp
operator|++
expr_stmt|;
name|NONBLANK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|cp
index|[
name|length
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|str
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

