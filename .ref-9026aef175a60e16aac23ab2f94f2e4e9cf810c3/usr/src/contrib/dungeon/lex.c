begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_macro
name|lex_
argument_list|(
argument|inbuf
argument_list|,
argument|inlnt
argument_list|,
argument|outbuf
argument_list|,
argument|op
argument_list|,
argument|vbflag
argument_list|,
argument|lprscon
argument_list|)
end_macro

begin_decl_stmt
name|char
name|inbuf
index|[
literal|78
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outbuf
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|inlnt
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
name|vbflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|lprscon
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* added */
end_comment

begin_block
block|{
comment|/* 	 * lex - lexical analyzer, converted from fortran 	 * 	 * input: one line of ascii characters 	 * output: tokenized input, packed in radix-50 format 	 */
name|char
name|j
decl_stmt|;
name|int
name|cp
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|,
name|prsptr
decl_stmt|;
specifier|static
name|int
name|num601
init|=
block|{
literal|601
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|++
control|)
name|outbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|op
operator|=
operator|-
literal|1
expr_stmt|;
name|prsptr
operator|=
operator|*
name|lprscon
operator|-
literal|1
expr_stmt|;
comment|/* printf("lex: inbuf=%s, inlnt=%d\n", inbuf, *inlnt); */
name|toknlp
label|:
operator|*
name|op
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|lprscon
operator|)
operator|++
operator|<=
operator|*
name|inlnt
condition|)
block|{
name|j
operator|=
name|inbuf
index|[
name|prsptr
operator|++
index|]
expr_stmt|;
comment|/* printf("lex: chr=%c\n", j); */
if|if
condition|(
operator|(
name|j
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|j
operator|==
literal|','
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|j
operator|==
literal|' '
condition|)
if|if
condition|(
name|cp
condition|)
comment|/* if (cp != 0) */
goto|goto
name|toknlp
goto|;
else|else
continue|continue;
comment|/* first token */
elseif|else
if|if
condition|(
operator|(
name|j
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|j
operator|<=
literal|'Z'
operator|)
condition|)
name|j
operator|-=
literal|'@'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|j
operator|>=
literal|'1'
operator|)
operator|&&
operator|(
name|j
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
name|j
operator|==
literal|'-'
operator|)
condition|)
name|j
operator|-=
literal|0x12
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|vbflag
condition|)
name|rspeak_
argument_list|(
operator|&
name|num601
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|>=
literal|6
condition|)
comment|/* 			 * ignore remainder of any token> 6 chars 			 */
continue|continue;
comment|/* 		 * pack three chars per word in radix-50 format 		 */
name|k
operator|=
operator|*
name|op
operator|+
operator|(
name|cp
operator|/
literal|3
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* printf("*op=%d, cp=%d, k=%d\n", *op, cp, k); */
switch|switch
condition|(
name|cp
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|outbuf
index|[
name|k
index|]
operator|+=
name|j
operator|*
literal|1560
expr_stmt|;
case|case
literal|1
case|:
name|outbuf
index|[
name|k
index|]
operator|+=
name|j
operator|*
literal|39
expr_stmt|;
case|case
literal|2
case|:
name|outbuf
index|[
name|k
index|]
operator|+=
name|j
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|lprscon
operator|>
operator|*
name|inlnt
condition|)
operator|*
name|lprscon
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
comment|/* if (cp == 0) */
if|if
condition|(
operator|*
name|op
operator|==
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* no valid tokens */
else|else
block|{
operator|*
name|op
operator|-=
literal|2
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
empty_stmt|;
block|}
end_block

end_unit

