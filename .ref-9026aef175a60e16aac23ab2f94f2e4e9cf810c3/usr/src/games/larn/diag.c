begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	diag.c		Larn is copyrighted 1986 by Noah Morgan. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_decl_stmt
specifier|extern
name|long
name|int
name|initialtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rmst
decl_stmt|,
name|maxitm
decl_stmt|,
name|lasttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|nosignal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tms
name|cputime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	*************************** 	DIAG -- dungeon diagnostics 	***************************  	subroutine to print out data for debugging  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|rndcount
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|diag
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|hit
decl_stmt|,
name|dam
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lwclose
argument_list|()
expr_stmt|;
if|if
condition|(
name|lcreat
argument_list|(
name|diagfile
argument_list|)
operator|<
literal|0
condition|)
comment|/*	open the diagnostic file	*/
block|{
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\ndiagnostic failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|write
argument_list|(
literal|1
argument_list|,
literal|"\nDiagnosing . . .\n"
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n\nBeginning of DIAG diagnostics ----------\n"
argument_list|)
expr_stmt|;
comment|/*	for the character attributes	*/
name|lprintf
argument_list|(
literal|"\n\nPlayer attributes:\n\nHit points: %2d(%2d)"
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|HP
index|]
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|HPMAX
index|]
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"\ngold: %d  Experience: %d  Character level: %d  Level in caverns: %d"
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|GOLD
index|]
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|EXPERIENCE
index|]
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|LEVEL
index|]
argument_list|,
operator|(
name|long
operator|)
name|level
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nTotal types of monsters: %d"
argument_list|,
operator|(
name|long
operator|)
name|MAXMONST
operator|+
literal|8
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\f\nHere's the dungeon:\n\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|level
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXLEVEL
operator|+
name|MAXVLEVEL
condition|;
name|j
operator|++
control|)
block|{
name|newcavelevel
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nMaze for level %s:\n"
argument_list|,
name|levelname
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|diagdrawscreen
argument_list|()
expr_stmt|;
block|}
name|newcavelevel
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\f\nNow for the monster data:\n\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"   Monster Name      LEV  AC   DAM  ATT  DEF    GOLD   HP     EXP   \n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"--------------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXMONST
operator|+
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|lprintf
argument_list|(
literal|"%19s  %2d  %3d "
argument_list|,
name|monster
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|level
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|armorclass
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|" %3d  %3d  %3d  "
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|damage
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|attack
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|defense
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"%6d  %3d   %6d\n"
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|gold
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|hitpoints
argument_list|,
operator|(
name|long
operator|)
name|monster
index|[
name|i
index|]
operator|.
name|experience
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\nHere's a Table for the to hit percentages\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n     We will be assuming that players level = 2 * monster level"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n     and that the players dexterity and strength are 16."
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n    to hit: if (rnd(22)< (2[monst AC] + your level + dex + WC/8 -1)/2) then hit"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n    damage = rund(8) + WC/2 + STR - c[HARDGAME] - 4"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n    to hit:  if rnd(22)< to hit  then player hits\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n    Each entry is as follows:  to hit / damage / number hits to kill\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n          monster     WC = 4         WC = 20        WC = 40"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n---------------------------------------------------------------"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXMONST
operator|+
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|hit
operator|=
literal|2
operator|*
name|monster
index|[
name|i
index|]
operator|.
name|armorclass
operator|+
literal|2
operator|*
name|monster
index|[
name|i
index|]
operator|.
name|level
operator|+
literal|16
expr_stmt|;
name|dam
operator|=
literal|16
operator|-
name|c
index|[
name|HARDGAME
index|]
expr_stmt|;
name|lprintf
argument_list|(
literal|"\n%20s   %2d/%2d/%2d       %2d/%2d/%2d       %2d/%2d/%2d"
argument_list|,
name|monster
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|long
call|)
argument_list|(
name|hit
operator|/
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|max
argument_list|(
literal|0
argument_list|,
name|dam
operator|+
literal|2
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|monster
index|[
name|i
index|]
operator|.
name|hitpoints
operator|/
operator|(
name|dam
operator|+
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|hit
operator|+
literal|2
operator|)
operator|/
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|max
argument_list|(
literal|0
argument_list|,
name|dam
operator|+
literal|10
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|monster
index|[
name|i
index|]
operator|.
name|hitpoints
operator|/
operator|(
name|dam
operator|+
literal|10
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|hit
operator|+
literal|5
operator|)
operator|/
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|max
argument_list|(
literal|0
argument_list|,
name|dam
operator|+
literal|20
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|monster
index|[
name|i
index|]
operator|.
name|hitpoints
operator|/
operator|(
name|dam
operator|+
literal|20
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\nHere's the list of available potions:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPOTION
condition|;
name|i
operator|++
control|)
name|lprintf
argument_list|(
literal|"%20s\n"
argument_list|,
operator|&
name|potionname
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n\nHere's the list of available scrolls:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSCROLL
condition|;
name|i
operator|++
control|)
name|lprintf
argument_list|(
literal|"%20s\n"
argument_list|,
operator|&
name|scrollname
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n\nHere's the spell list:\n\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"spell          name           description\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"-------------------------------------------------------------------------------------------\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SPNUM
condition|;
name|j
operator|++
control|)
block|{
name|lprc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
name|spelcode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|" %21s  %s\n"
argument_list|,
name|spelname
index|[
name|j
index|]
argument_list|,
name|speldescript
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\nFor the c[] array:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|+=
literal|10
control|)
block|{
name|lprintf
argument_list|(
literal|"\nc[%2d] = "
argument_list|,
operator|(
name|long
operator|)
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|lprintf
argument_list|(
literal|"%5d "
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\nTest of random number generator ----------------"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n    for 25,000 calls divided into 16 slots\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|rndcount
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25000
condition|;
name|i
operator|++
control|)
name|rndcount
index|[
name|rund
argument_list|(
literal|16
argument_list|)
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|lprintf
argument_list|(
literal|"  %5d"
argument_list|,
operator|(
name|long
operator|)
name|rndcount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|7
condition|)
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|lwclose
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"Done Diagnosing . . ."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	subroutine to count the number of occurrences of an object  */
end_comment

begin_macro
name|dcount
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|int
name|k
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXY
condition|;
name|j
operator|++
control|)
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|MAXLEVEL
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|cell
index|[
name|p
operator|*
name|MAXX
operator|*
name|MAXY
operator|+
name|i
operator|*
name|MAXY
operator|+
name|j
index|]
operator|.
name|item
operator|==
name|l
condition|)
name|k
operator|++
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	subroutine to draw the whole screen as the player knows it  */
end_comment

begin_macro
name|diagdrawscreen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
comment|/*	for the east west walls of this line	*/
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|k
operator|=
name|mitem
index|[
name|j
index|]
index|[
name|i
index|]
condition|)
name|lprc
argument_list|(
name|monstnamelist
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
name|lprc
argument_list|(
name|objnamelist
index|[
name|item
index|[
name|j
index|]
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* 	to save the game in a file  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|zzz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|savegame
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|struct
name|sphere
modifier|*
name|sp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|savelevel
argument_list|()
expr_stmt|;
name|ointerest
argument_list|()
expr_stmt|;
if|if
condition|(
name|lcreat
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nCan't open file<%s> to save game\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|nosignal
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|set_score_output
argument_list|()
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beenhere
argument_list|,
name|MAXLEVEL
operator|+
name|MAXVLEVEL
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXLEVEL
operator|+
name|MAXVLEVEL
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|beenhere
index|[
name|k
index|]
condition|)
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cell
index|[
name|k
operator|*
name|MAXX
operator|*
name|MAXY
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cel
argument_list|)
operator|*
name|MAXY
operator|*
name|MAXX
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|cputime
argument_list|)
expr_stmt|;
comment|/* get cpu time */
name|c
index|[
name|CPUTIME
index|]
operator|+=
operator|(
name|cputime
operator|.
name|tms_utime
operator|+
name|cputime
operator|.
name|tms_stime
operator|)
operator|/
literal|60
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|c
index|[
literal|0
index|]
argument_list|,
literal|100
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|lprint
argument_list|(
operator|(
name|long
operator|)
name|gtime
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|playerx
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|playery
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iven
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ivenarg
argument_list|,
literal|26
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXSCROLL
condition|;
name|k
operator|++
control|)
name|lprc
argument_list|(
name|scrollname
index|[
name|k
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXPOTION
condition|;
name|k
operator|++
control|)
name|lprc
argument_list|(
name|potionname
index|[
name|k
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spelknow
argument_list|,
name|SPNUM
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|wizard
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|rmst
argument_list|)
expr_stmt|;
comment|/*	random monster generation counter */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|90
condition|;
name|i
operator|++
control|)
name|lprc
argument_list|(
name|itm
index|[
name|i
index|]
operator|.
name|qty
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|course
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|cheat
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMONST
condition|;
name|i
operator|++
control|)
name|lprc
argument_list|(
name|monster
index|[
name|i
index|]
operator|.
name|genocided
argument_list|)
expr_stmt|;
comment|/* genocide info */
for|for
control|(
name|sp
operator|=
name|spheres
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|p
control|)
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sphere
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save spheres of annihilation */
name|time
argument_list|(
operator|&
name|zzz
argument_list|)
expr_stmt|;
name|lprint
argument_list|(
call|(
name|long
call|)
argument_list|(
name|zzz
operator|-
name|initialtime
argument_list|)
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zzz
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|lfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|lprint
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
else|else
name|lprint
argument_list|(
operator|(
name|long
operator|)
name|statbuf
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* inode # */
name|lwclose
argument_list|()
expr_stmt|;
name|lastmonst
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|VT100
name|setscroll
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|VT100
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nosignal
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|restoregame
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|struct
name|sphere
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp2
decl_stmt|;
name|struct
name|stat
name|filetimes
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nRestoring . . ."
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|lopen
argument_list|(
name|fname
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nCan't open file<%s>to restore game\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|c
index|[
name|GOLD
index|]
operator|=
name|c
index|[
name|BANKACCOUNT
index|]
operator|=
literal|0
expr_stmt|;
name|died
argument_list|(
operator|-
literal|265
argument_list|)
expr_stmt|;
return|return;
block|}
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beenhere
argument_list|,
name|MAXLEVEL
operator|+
name|MAXVLEVEL
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXLEVEL
operator|+
name|MAXVLEVEL
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|beenhere
index|[
name|k
index|]
condition|)
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cell
index|[
name|k
operator|*
name|MAXX
operator|*
name|MAXY
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cel
argument_list|)
operator|*
name|MAXY
operator|*
name|MAXX
argument_list|)
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|c
index|[
literal|0
index|]
argument_list|,
literal|100
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|gtime
operator|=
name|lrint
argument_list|()
expr_stmt|;
name|level
operator|=
name|c
index|[
name|CAVELEVEL
index|]
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|playerx
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|playery
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iven
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ivenarg
argument_list|,
literal|26
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXSCROLL
condition|;
name|k
operator|++
control|)
name|scrollname
index|[
name|k
index|]
index|[
literal|0
index|]
operator|=
name|lgetc
argument_list|()
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXPOTION
condition|;
name|k
operator|++
control|)
name|potionname
index|[
name|k
index|]
index|[
literal|0
index|]
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spelknow
argument_list|,
name|SPNUM
argument_list|)
expr_stmt|;
name|wizard
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|rmst
operator|=
name|lgetc
argument_list|()
expr_stmt|;
comment|/*	random monster creation flag */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|90
condition|;
name|i
operator|++
control|)
name|itm
index|[
name|i
index|]
operator|.
name|qty
operator|=
name|lgetc
argument_list|()
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|course
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|cheat
operator|=
name|lgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|VERSION
operator|!=
name|lgetc
argument_list|()
condition|)
comment|/*  version number  */
block|{
name|cheat
operator|=
literal|1
expr_stmt|;
name|lprcat
argument_list|(
literal|"Sorry, But your save file is for an older version of larn\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|c
index|[
name|GOLD
index|]
operator|=
name|c
index|[
name|BANKACCOUNT
index|]
operator|=
literal|0
expr_stmt|;
name|died
argument_list|(
operator|-
literal|266
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMONST
condition|;
name|i
operator|++
control|)
name|monster
index|[
name|i
index|]
operator|.
name|genocided
operator|=
name|lgetc
argument_list|()
expr_stmt|;
comment|/* genocide info */
for|for
control|(
name|sp
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
index|[
name|SPHCAST
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sp2
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|sphere
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sphere
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Can't malloc() for sphere space\n"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
block|}
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sphere
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get spheres of annihilation */
name|sp
operator|->
name|p
operator|=
literal|0
expr_stmt|;
comment|/* null out pointer */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|spheres
operator|=
name|sp
expr_stmt|;
comment|/* beginning of list */
else|else
name|sp2
operator|->
name|p
operator|=
name|sp
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|zzz
argument_list|)
expr_stmt|;
name|initialtime
operator|=
name|zzz
operator|-
name|lrint
argument_list|()
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|filetimes
argument_list|)
expr_stmt|;
comment|/*	get the creation and modification time of file	*/
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zzz
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|zzz
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|filetimes
operator|.
name|st_ctime
operator|>
name|zzz
condition|)
name|fsorry
argument_list|()
expr_stmt|;
comment|/*	file create time	*/
elseif|else
if|if
condition|(
name|filetimes
operator|.
name|st_mtime
operator|>
name|zzz
condition|)
name|fsorry
argument_list|()
expr_stmt|;
comment|/*	file modify time	*/
if|if
condition|(
name|c
index|[
name|HP
index|]
operator|<
literal|0
condition|)
block|{
name|died
argument_list|(
literal|284
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* died a post mortem death */
name|oldx
operator|=
name|oldy
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|lrint
argument_list|()
expr_stmt|;
comment|/* inode # */
if|if
condition|(
name|i
operator|&&
operator|(
name|filetimes
operator|.
name|st_ino
operator|!=
name|i
operator|)
condition|)
name|fsorry
argument_list|()
expr_stmt|;
name|lrclose
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|ckpfile
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lappend
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|fcheat
argument_list|()
expr_stmt|;
else|else
block|{
name|lprc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lwclose
argument_list|()
expr_stmt|;
block|}
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|fcheat
argument_list|()
expr_stmt|;
comment|/* can't unlink save file */
comment|/*	for the greedy cheater checker	*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|6
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|c
index|[
name|k
index|]
operator|>
literal|99
condition|)
name|greedy
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HPMAX
index|]
operator|>
literal|999
operator|||
name|c
index|[
name|SPELLMAX
index|]
operator|>
literal|125
condition|)
name|greedy
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|==
literal|25
operator|&&
name|c
index|[
name|EXPERIENCE
index|]
operator|>
name|skill
index|[
literal|24
index|]
condition|)
comment|/* if patch up lev 25 player */
block|{
name|long
name|tmp
decl_stmt|;
name|tmp
operator|=
name|c
index|[
name|EXPERIENCE
index|]
operator|-
name|skill
index|[
literal|24
index|]
expr_stmt|;
comment|/* amount to go up */
name|c
index|[
name|EXPERIENCE
index|]
operator|=
name|skill
index|[
literal|24
index|]
expr_stmt|;
name|raiseexperience
argument_list|(
operator|(
name|long
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
name|getlevel
argument_list|()
expr_stmt|;
name|lasttime
operator|=
name|gtime
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	subroutine to not allow greedy cheaters  */
end_comment

begin_macro
name|greedy
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|WIZID
if|if
condition|(
name|wizard
condition|)
return|return;
endif|#
directive|endif
name|lprcat
argument_list|(
literal|"\n\nI am so sorry, but your character is a little TOO good!  Since this\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"cannot normally happen from an honest game, I must assume that you cheated.\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"In that you are GREEDY as well as a CHEATER, I cannot allow this game\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"to continue.\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|c
index|[
name|GOLD
index|]
operator|=
name|c
index|[
name|BANKACCOUNT
index|]
operator|=
literal|0
expr_stmt|;
name|died
argument_list|(
operator|-
literal|267
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* 	subroutine to not allow altered save files and terminate the attempted 	restart  */
end_comment

begin_macro
name|fsorry
argument_list|()
end_macro

begin_block
block|{
name|lprcat
argument_list|(
literal|"\nSorry, but your savefile has been altered.\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"However, seeing as I am a good sport, I will let you play.\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"Be advised though, you won't be placed on the normal scoreboard."
argument_list|)
expr_stmt|;
name|cheat
operator|=
literal|1
expr_stmt|;
name|nap
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	subroutine to not allow game if save file can't be deleted  */
end_comment

begin_macro
name|fcheat
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|WIZID
if|if
condition|(
name|wizard
condition|)
return|return;
endif|#
directive|endif
name|lprcat
argument_list|(
literal|"\nSorry, but your savefile can't be deleted.  This can only mean\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"that you tried to CHEAT by protecting the directory the savefile\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"is in.  Since this is unfair to the rest of the larn community, I\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"cannot let you play this game.\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|c
index|[
name|GOLD
index|]
operator|=
name|c
index|[
name|BANKACCOUNT
index|]
operator|=
literal|0
expr_stmt|;
name|died
argument_list|(
operator|-
literal|268
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

