begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pickmove.c	8.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|"gomoku.h"
end_include

begin_define
define|#
directive|define
name|BITS_PER_INT
value|(sizeof(int) * CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|MAPSZ
value|(BAREA / BITS_PER_INT)
end_define

begin_define
define|#
directive|define
name|BIT_SET
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)[(b)/BITS_PER_INT] |= (1<< ((b) % BITS_PER_INT)))
end_define

begin_define
define|#
directive|define
name|BIT_CLR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)[(b)/BITS_PER_INT]&= ~(1<< ((b) % BITS_PER_INT)))
end_define

begin_define
define|#
directive|define
name|BIT_TEST
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)[(b)/BITS_PER_INT]& (1<< ((b) % BITS_PER_INT)))
end_define

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|hashcombos
index|[
name|FAREA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash list for finding duplicates */
end_comment

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|sortcombos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* combos at higher levels */
end_comment

begin_decl_stmt
name|int
name|combolen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of combos in sortcombos */
end_comment

begin_decl_stmt
name|int
name|nextcolor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of next move */
end_comment

begin_decl_stmt
name|int
name|elistcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of struct elist allocated */
end_comment

begin_decl_stmt
name|int
name|combocnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of struct combostr allocated */
end_comment

begin_decl_stmt
name|int
name|forcemap
index|[
name|MAPSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map for blocking<1,x> combos */
end_comment

begin_decl_stmt
name|int
name|tmpmap
index|[
name|MAPSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map for blocking<1,x> combos */
end_comment

begin_decl_stmt
name|int
name|nforce
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of opponent<1,x> combos */
end_comment

begin_macro
name|pickmove
argument_list|(
argument|us
argument_list|)
end_macro

begin_decl_stmt
name|int
name|us
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|union
name|comboval
modifier|*
name|Ocp
decl_stmt|,
modifier|*
name|Tcp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
comment|/* first move is easy */
if|if
condition|(
name|movenum
operator|==
literal|1
condition|)
return|return
operator|(
name|PT
argument_list|(
name|K
argument_list|,
literal|10
argument_list|)
operator|)
return|;
comment|/* initialize all the board values */
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
operator|=
name|MAXCOMBO
operator|+
literal|1
expr_stmt|;
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
operator|=
name|MAXCOMBO
operator|+
literal|1
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|BLACK
index|]
operator|=
literal|255
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|WHITE
index|]
operator|=
literal|255
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|BLACK
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|WHITE
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_flg
operator|&=
operator|~
operator|(
name|FFLAGALL
operator||
name|MFLAGALL
operator|)
expr_stmt|;
block|}
name|nforce
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|forcemap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|forcemap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute new values */
name|nextcolor
operator|=
name|us
expr_stmt|;
name|scanframes
argument_list|(
name|BLACK
argument_list|)
expr_stmt|;
name|scanframes
argument_list|(
name|WHITE
argument_list|)
expr_stmt|;
comment|/* find the spot with the highest value */
for|for
control|(
name|sp
operator|=
name|sp1
operator|=
name|sp2
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|19
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
if|if
condition|(
name|debug
operator|&&
operator|(
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|c
operator|.
name|a
operator|==
literal|1
operator|||
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|c
operator|.
name|a
operator|==
literal|1
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"- %s %x/%d %d %x/%d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp
operator|-
name|board
argument_list|)
argument_list|,
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp
operator|->
name|s_wval
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* pick the best black move */
if|if
condition|(
name|better
argument_list|(
name|sp
argument_list|,
name|sp1
argument_list|,
name|BLACK
argument_list|)
condition|)
name|sp1
operator|=
name|sp
expr_stmt|;
comment|/* pick the best white move */
if|if
condition|(
name|better
argument_list|(
name|sp
argument_list|,
name|sp2
argument_list|,
name|WHITE
argument_list|)
condition|)
name|sp2
operator|=
name|sp
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"B %s %x/%d %d %x/%d %d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp1
operator|-
name|board
argument_list|)
argument_list|,
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp1
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp1
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp1
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp1
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp1
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp1
operator|->
name|s_wval
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"W %s %x/%d %d %x/%d %d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp2
operator|-
name|board
argument_list|)
argument_list|,
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp2
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp2
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp2
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp2
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp2
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp2
operator|->
name|s_wval
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
comment|/* 		 * Check for more than one force that can't 		 * all be blocked with one move. 		 */
name|sp
operator|=
operator|(
name|us
operator|==
name|BLACK
operator|)
condition|?
name|sp2
else|:
name|sp1
expr_stmt|;
name|m
operator|=
name|sp
operator|-
name|board
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
operator|!
name|us
index|]
operator|.
name|c
operator|.
name|a
operator|==
literal|1
operator|&&
operator|!
name|BIT_TEST
argument_list|(
name|forcemap
argument_list|,
name|m
argument_list|)
condition|)
name|dlog
argument_list|(
literal|"*** Can't be blocked"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|us
operator|==
name|BLACK
condition|)
block|{
name|Ocp
operator|=
operator|&
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
expr_stmt|;
name|Tcp
operator|=
operator|&
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
expr_stmt|;
block|}
else|else
block|{
name|Tcp
operator|=
operator|&
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
expr_stmt|;
name|Ocp
operator|=
operator|&
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
expr_stmt|;
name|sp
operator|=
name|sp1
expr_stmt|;
name|sp1
operator|=
name|sp2
expr_stmt|;
name|sp2
operator|=
name|sp
expr_stmt|;
block|}
comment|/* 	 * Block their combo only if we have to (i.e., if they are one move 	 * away from completing a force and we don't have a force that 	 * we can complete which takes fewer moves to win). 	 */
if|if
condition|(
name|Tcp
operator|->
name|c
operator|.
name|a
operator|<=
literal|1
operator|&&
operator|(
name|Ocp
operator|->
name|c
operator|.
name|a
operator|>
literal|1
operator|||
name|Tcp
operator|->
name|c
operator|.
name|a
operator|+
name|Tcp
operator|->
name|c
operator|.
name|b
operator|<
name|Ocp
operator|->
name|c
operator|.
name|a
operator|+
name|Ocp
operator|->
name|c
operator|.
name|b
operator|)
condition|)
return|return
operator|(
name|sp2
operator|-
name|board
operator|)
return|;
return|return
operator|(
name|sp1
operator|-
name|board
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return true if spot 'sp' is better than spot 'sp1' for color 'us'.  */
end_comment

begin_macro
name|better
argument_list|(
argument|sp
argument_list|,
argument|sp1
argument_list|,
argument|us
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|sp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|us
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|them
decl_stmt|,
name|s
decl_stmt|,
name|s1
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
operator|<
name|sp1
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
operator|!=
name|sp1
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|us
index|]
operator|<
name|sp1
operator|->
name|s_level
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|us
index|]
operator|!=
name|sp1
operator|->
name|s_level
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|us
index|]
operator|>
name|sp1
operator|->
name|s_nforce
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|us
index|]
operator|!=
name|sp1
operator|->
name|s_nforce
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|them
operator|=
operator|!
name|us
expr_stmt|;
name|s
operator|=
name|sp
operator|-
name|board
expr_stmt|;
name|s1
operator|=
name|sp1
operator|-
name|board
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|forcemap
argument_list|,
name|s
argument_list|)
operator|&&
operator|!
name|BIT_TEST
argument_list|(
name|forcemap
argument_list|,
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|BIT_TEST
argument_list|(
name|forcemap
argument_list|,
name|s
argument_list|)
operator|&&
name|BIT_TEST
argument_list|(
name|forcemap
argument_list|,
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
operator|<
name|sp1
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
operator|!=
name|sp1
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|them
index|]
operator|<
name|sp1
operator|->
name|s_level
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|them
index|]
operator|!=
name|sp1
operator|->
name|s_level
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|them
index|]
operator|>
name|sp1
operator|->
name|s_nforce
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|them
index|]
operator|!=
name|sp1
operator|->
name|s_nforce
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_wval
operator|>
name|sp1
operator|->
name|s_wval
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_wval
operator|!=
name|sp1
operator|->
name|s_wval
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|SVR4
return|return
operator|(
name|rand
argument_list|()
operator|&
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|random
argument_list|()
operator|&
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|int
name|curcolor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* implicit parameter to makecombo() */
end_comment

begin_decl_stmt
name|int
name|curlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* implicit parameter to makecombo() */
end_comment

begin_comment
comment|/*  * Scan the sorted list of non-empty frames and  * update the minimum combo values for each empty spot.  * Also, try to combine frames to find more complex (chained) moves.  */
end_comment

begin_macro
name|scanframes
argument_list|(
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|union
name|comboval
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|,
name|n
decl_stmt|;
name|union
name|comboval
name|cb
decl_stmt|;
name|curcolor
operator|=
name|color
expr_stmt|;
comment|/* check for empty list of frames */
name|cbp
operator|=
name|sortframes
index|[
name|color
index|]
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* quick check for four in a row */
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|cb
operator|.
name|s
operator|=
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|d
operator|=
name|cbp
operator|->
name|c_dir
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
literal|0x101
condition|)
block|{
name|d
operator|=
name|dd
index|[
name|d
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
operator|+
name|cb
operator|.
name|c
operator|.
name|b
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Update the minimum combo value for each spot in the frame 	 * and try making all combinations of two frames intersecting at 	 * an empty spot. 	 */
name|n
operator|=
name|combolen
expr_stmt|;
name|ecbp
operator|=
name|cbp
expr_stmt|;
do|do
block|{
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|cp
operator|=
operator|&
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|r
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c
operator|.
name|b
condition|)
block|{
comment|/* 			 * Since this is the first spot of an open ended 			 * frame, we treat it as a closed frame. 			 */
name|cb
operator|.
name|c
operator|.
name|a
operator|=
name|cp
operator|->
name|c
operator|.
name|a
operator|+
literal|1
expr_stmt|;
name|cb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Try combining other frames that intersect 			 * at this spot. 			 */
name|makecombo2
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|s
operator|!=
literal|0x101
condition|)
name|cb
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|color
operator|!=
name|nextcolor
condition|)
name|memset
argument_list|(
name|tmpmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpmap
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|d
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
block|{
comment|/* for each spot */
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|s
operator|==
literal|0x101
condition|)
block|{
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|color
operator|!=
name|nextcolor
condition|)
block|{
name|n
operator|=
name|sp
operator|-
name|board
expr_stmt|;
name|BIT_SET
argument_list|(
name|tmpmap
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Try combining other frames that intersect 			 * at this spot. 			 */
name|makecombo2
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
name|i
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|s
operator|==
literal|0x101
operator|&&
name|color
operator|!=
name|nextcolor
condition|)
block|{
if|if
condition|(
name|nforce
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|forcemap
argument_list|,
name|tmpmap
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpmap
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAPSZ
condition|;
name|i
operator|++
control|)
name|forcemap
index|[
name|i
index|]
operator|&=
name|tmpmap
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* mark frame as having been processed */
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|MFLAG
operator|<<
name|r
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
comment|/* 	 * Try to make new 3rd level combos, 4th level, etc. 	 * Limit the search depth early in the game. 	 */
name|d
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|d
operator|<=
operator|(
operator|(
name|movenum
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|&&
name|combolen
operator|>
name|n
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%cL%d %d %d %d"
argument_list|,
literal|"BW"
index|[
name|color
index|]
argument_list|,
name|d
argument_list|,
name|combolen
operator|-
name|n
argument_list|,
name|combocnt
argument_list|,
name|elistcnt
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
name|combolen
expr_stmt|;
name|addframes
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
comment|/* scan for combos at empty spots */
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|s_empty
init|;
name|ep
condition|;
name|ep
operator|=
name|nep
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
name|nep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|elistcnt
operator|--
expr_stmt|;
block|}
name|sp
operator|->
name|s_empty
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|s_nempty
init|;
name|ep
condition|;
name|ep
operator|=
name|nep
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
name|nep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|elistcnt
operator|--
expr_stmt|;
block|}
name|sp
operator|->
name|s_nempty
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* remove old combos */
if|if
condition|(
operator|(
name|cbp
operator|=
name|sortcombos
operator|)
operator|!=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|combostr
modifier|*
name|ncbp
decl_stmt|;
comment|/* scan the list */
name|ecbp
operator|=
name|cbp
expr_stmt|;
do|do
block|{
name|ncbp
operator|=
name|cbp
operator|->
name|c_next
expr_stmt|;
name|free
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|combocnt
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|ncbp
operator|)
operator|!=
name|ecbp
condition|)
do|;
name|sortcombos
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|combolen
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|combocnt
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"scanframes: %c combocnt %d"
argument_list|,
literal|"BW"
index|[
name|color
index|]
argument_list|,
name|combocnt
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elistcnt
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"scanframes: %c elistcnt %d"
argument_list|,
literal|"BW"
index|[
name|color
index|]
argument_list|,
name|elistcnt
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Compute all level 2 combos of frames intersecting spot 'osp'  * within the frame 'ocbp' and combo value 's'.  */
end_comment

begin_macro
name|makecombo2
argument_list|(
argument|ocbp
argument_list|,
argument|osp
argument_list|,
argument|off
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|fsp
decl_stmt|;
specifier|register
name|struct
name|combostr
modifier|*
name|ncbp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|,
name|c
decl_stmt|;
name|int
name|baseB
decl_stmt|,
name|fcnt
decl_stmt|,
name|emask
decl_stmt|,
name|bmask
decl_stmt|,
name|n
decl_stmt|;
name|union
name|comboval
name|ocb
decl_stmt|,
name|fcb
decl_stmt|;
name|struct
name|combostr
modifier|*
modifier|*
name|scbpp
decl_stmt|,
modifier|*
name|fcbp
decl_stmt|;
comment|/* try to combine a new frame with those found so far */
name|ocb
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|baseB
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
name|fcnt
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
literal|2
expr_stmt|;
name|emask
operator|=
name|fcnt
condition|?
operator|(
operator|(
name|ocb
operator|.
name|c
operator|.
name|b
condition|?
literal|0x1E
else|:
literal|0x1F
operator|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|off
operator|)
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|4
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* for each direction */
comment|/* don't include frames that overlap in the same direction */
if|if
condition|(
name|r
operator|==
name|ocbp
operator|->
name|c_dir
condition|)
continue|continue;
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
comment|/* 	     * Frame A combined with B is the same value as B combined with A 	     * so skip frames that have already been processed (MFLAG). 	     * Also skip blocked frames (BFLAG) and frames that are<1,x> 	     * since combining another frame with it isn't valid. 	     */
name|bmask
operator|=
operator|(
name|BFLAG
operator||
name|FFLAG
operator||
name|MFLAG
operator|)
operator|<<
name|r
expr_stmt|;
name|fsp
operator|=
name|osp
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|5
condition|;
name|f
operator|++
operator|,
name|fsp
operator|-=
name|d
control|)
block|{
comment|/* for each frame */
if|if
condition|(
name|fsp
operator|->
name|s_occ
operator|==
name|BORDER
condition|)
break|break;
if|if
condition|(
name|fsp
operator|->
name|s_flg
operator|&
name|bmask
condition|)
continue|continue;
comment|/* don't include frames of the wrong color */
name|fcb
operator|.
name|s
operator|=
name|fsp
operator|->
name|s_fval
index|[
name|curcolor
index|]
index|[
name|r
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|a
operator|>=
name|MAXA
condition|)
continue|continue;
comment|/* 		 * Get the combo value for this frame. 		 * If this is the end point of the frame, 		 * use the closed ended value for the frame. 		 */
if|if
condition|(
name|f
operator|==
literal|0
operator|&&
name|fcb
operator|.
name|c
operator|.
name|b
operator|||
name|fcb
operator|.
name|s
operator|==
literal|0x101
condition|)
block|{
name|fcb
operator|.
name|c
operator|.
name|a
operator|++
expr_stmt|;
name|fcb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute combo value */
name|c
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|4
condition|)
continue|continue;
name|n
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
name|fcb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|baseB
operator|<
name|n
condition|)
name|n
operator|=
name|baseB
expr_stmt|;
comment|/* make a new combo! */
name|ncbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scbpp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|*
operator|)
operator|(
name|ncbp
operator|+
literal|1
operator|)
expr_stmt|;
name|fcbp
operator|=
name|fsp
operator|->
name|s_frame
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|ocbp
operator|<
name|fcbp
condition|)
block|{
name|scbpp
index|[
literal|0
index|]
operator|=
name|ocbp
expr_stmt|;
name|scbpp
index|[
literal|1
index|]
operator|=
name|fcbp
expr_stmt|;
block|}
else|else
block|{
name|scbpp
index|[
literal|0
index|]
operator|=
name|fcbp
expr_stmt|;
name|scbpp
index|[
literal|1
index|]
operator|=
name|ocbp
expr_stmt|;
block|}
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|=
name|c
expr_stmt|;
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|b
operator|=
name|n
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|0
index|]
operator|=
name|ocbp
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|=
name|fcbp
expr_stmt|;
name|ncbp
operator|->
name|c_linkv
index|[
literal|0
index|]
operator|.
name|s
operator|=
name|ocb
operator|.
name|s
expr_stmt|;
name|ncbp
operator|->
name|c_linkv
index|[
literal|1
index|]
operator|.
name|s
operator|=
name|fcb
operator|.
name|s
expr_stmt|;
name|ncbp
operator|->
name|c_voff
index|[
literal|0
index|]
operator|=
name|off
expr_stmt|;
name|ncbp
operator|->
name|c_voff
index|[
literal|1
index|]
operator|=
name|f
expr_stmt|;
name|ncbp
operator|->
name|c_vertex
operator|=
name|osp
operator|-
name|board
expr_stmt|;
name|ncbp
operator|->
name|c_nframes
operator|=
literal|2
expr_stmt|;
name|ncbp
operator|->
name|c_dir
operator|=
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_frameindex
operator|=
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_flg
operator|=
operator|(
name|ocb
operator|.
name|c
operator|.
name|b
operator|)
condition|?
name|C_OPEN_0
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|b
condition|)
name|ncbp
operator|->
name|c_flg
operator||=
name|C_OPEN_1
expr_stmt|;
name|ncbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
operator|=
name|fcnt
expr_stmt|;
name|ncbp
operator|->
name|c_emask
index|[
literal|0
index|]
operator|=
name|emask
expr_stmt|;
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|-
literal|2
expr_stmt|;
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
operator|=
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
condition|?
operator|(
operator|(
name|fcb
operator|.
name|c
operator|.
name|b
condition|?
literal|0x1E
else|:
literal|0x1F
operator|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|f
operator|)
operator|)
else|:
literal|0
expr_stmt|;
name|combocnt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%c c %d %d m %x %x o %d %d"
argument_list|,
literal|"bw"
index|[
name|curcolor
index|]
argument_list|,
name|ncbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
argument_list|,
name|ncbp
operator|->
name|c_emask
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
argument_list|,
name|ncbp
operator|->
name|c_voff
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_voff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|printcombo
argument_list|(
name|ncbp
argument_list|,
name|fmtbuf
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
comment|/* record the empty spots that will complete this combo */
name|makeempty
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
comment|/* add the new combo to the end of the list */
name|appendcombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updatecombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
name|combocnt
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|5
condition|)
block|{
name|markcombo
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
name|bdisp
argument_list|()
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearcombo
argument_list|(
name|ncbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Scan the sorted list of frames and try to add a frame to  * combinations of 'level' number of frames.  */
end_comment

begin_macro
name|addframes
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|fsp
decl_stmt|;
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|;
name|struct
name|combostr
modifier|*
modifier|*
name|cbpp
decl_stmt|,
modifier|*
name|pcbp
decl_stmt|;
name|union
name|comboval
name|fcb
decl_stmt|,
name|cb
decl_stmt|;
name|curlevel
operator|=
name|level
expr_stmt|;
comment|/* scan for combos at empty spots */
name|i
operator|=
name|curcolor
expr_stmt|;
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|s_empty
init|;
name|ep
condition|;
name|ep
operator|=
name|nep
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|i
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|i
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|i
index|]
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|i
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|i
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|i
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
name|nep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|elistcnt
operator|--
expr_stmt|;
block|}
name|sp
operator|->
name|s_empty
operator|=
name|sp
operator|->
name|s_nempty
expr_stmt|;
name|sp
operator|->
name|s_nempty
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* try to add frames to the uncompleted combos at level curlevel */
name|cbp
operator|=
name|ecbp
operator|=
name|sortframes
index|[
name|curcolor
index|]
expr_stmt|;
do|do
block|{
name|fsp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|r
operator|=
name|cbp
operator|->
name|c_dir
expr_stmt|;
comment|/* skip frames that are part of a<1,x> combo */
if|if
condition|(
name|fsp
operator|->
name|s_flg
operator|&
operator|(
name|FFLAG
operator|<<
name|r
operator|)
condition|)
continue|continue;
comment|/* 		 * Don't include<1,x> combo frames, 		 * treat it as a closed three in a row instead. 		 */
name|fcb
operator|.
name|s
operator|=
name|fsp
operator|->
name|s_fval
index|[
name|curcolor
index|]
index|[
name|r
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|s
operator|==
literal|0x101
condition|)
name|fcb
operator|.
name|s
operator|=
literal|0x200
expr_stmt|;
comment|/* 		 * If this is an open ended frame, use 		 * the combo value with the end closed. 		 */
if|if
condition|(
name|fsp
operator|->
name|s_occ
operator|==
name|EMPTY
condition|)
block|{
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|b
condition|)
block|{
name|cb
operator|.
name|c
operator|.
name|a
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
literal|1
expr_stmt|;
name|cb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cb
operator|.
name|s
operator|=
name|fcb
operator|.
name|s
expr_stmt|;
name|makecombo
argument_list|(
name|cbp
argument_list|,
name|fsp
argument_list|,
literal|0
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The next four spots are handled the same for both 		 * open and closed ended frames. 		 */
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
name|sp
operator|=
name|fsp
operator|+
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|makecombo
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
name|i
argument_list|,
name|fcb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
comment|/* put all the combos in the hash list on the sorted list */
name|cbpp
operator|=
operator|&
name|hashcombos
index|[
name|FAREA
index|]
expr_stmt|;
do|do
block|{
name|cbp
operator|=
operator|*
operator|--
name|cbpp
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
continue|continue;
operator|*
name|cbpp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
expr_stmt|;
name|ecbp
operator|=
name|sortcombos
expr_stmt|;
if|if
condition|(
name|ecbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
name|sortcombos
operator|=
name|cbp
expr_stmt|;
else|else
block|{
comment|/* append to sort list */
name|pcbp
operator|=
name|ecbp
operator|->
name|c_prev
expr_stmt|;
name|pcbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
name|ecbp
operator|->
name|c_prev
operator|=
name|cbp
operator|->
name|c_prev
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|->
name|c_next
operator|=
name|ecbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|pcbp
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cbpp
operator|!=
name|hashcombos
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Compute all level N combos of frames intersecting spot 'osp'  * within the frame 'ocbp' and combo value 's'.  */
end_comment

begin_macro
name|makecombo
argument_list|(
argument|ocbp
argument_list|,
argument|osp
argument_list|,
argument|off
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ncbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elist
modifier|*
name|nep
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|combostr
modifier|*
modifier|*
name|scbpp
decl_stmt|;
name|int
name|baseB
decl_stmt|,
name|fcnt
decl_stmt|,
name|emask
decl_stmt|,
name|verts
decl_stmt|,
name|d
decl_stmt|;
name|union
name|comboval
name|ocb
decl_stmt|,
name|cb
decl_stmt|;
name|struct
name|ovlp_info
name|vertices
index|[
literal|1
index|]
decl_stmt|;
name|ocb
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|baseB
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
name|fcnt
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
literal|2
expr_stmt|;
name|emask
operator|=
name|fcnt
condition|?
operator|(
operator|(
name|ocb
operator|.
name|c
operator|.
name|b
condition|?
literal|0x1E
else|:
literal|0x1F
operator|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|off
operator|)
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|osp
operator|->
name|s_empty
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
block|{
comment|/* check for various kinds of overlap */
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
name|verts
operator|=
name|checkframes
argument_list|(
name|cbp
argument_list|,
name|ocbp
argument_list|,
name|osp
argument_list|,
name|s
argument_list|,
name|vertices
argument_list|)
expr_stmt|;
if|if
condition|(
name|verts
operator|<
literal|0
condition|)
continue|continue;
comment|/* check to see if this frame forms a valid loop */
if|if
condition|(
name|verts
condition|)
block|{
name|sp
operator|=
operator|&
name|board
index|[
name|vertices
index|[
literal|0
index|]
operator|.
name|o_intersect
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"loop: %c %s"
argument_list|,
literal|"BW"
index|[
name|curcolor
index|]
argument_list|,
name|stoc
argument_list|(
name|sp
operator|-
name|board
argument_list|)
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * It is a valid loop if the intersection spot 		 * of the frame we are trying to attach is one 		 * of the completion spots of the combostr 		 * we are trying to attach the frame to. 		 */
for|for
control|(
name|nep
operator|=
name|sp
operator|->
name|s_empty
init|;
name|nep
condition|;
name|nep
operator|=
name|nep
operator|->
name|e_next
control|)
block|{
if|if
condition|(
name|nep
operator|->
name|e_combo
operator|==
name|cbp
condition|)
goto|goto
name|fnd
goto|;
if|if
condition|(
name|nep
operator|->
name|e_combo
operator|->
name|c_nframes
operator|<
name|cbp
operator|->
name|c_nframes
condition|)
break|break;
block|}
comment|/* frame overlaps but not at a valid spot */
continue|continue;
name|fnd
label|:
empty_stmt|;
block|}
comment|/* compute the first half of the combo value */
name|c
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
name|verts
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|4
condition|)
continue|continue;
comment|/* compute the second half of the combo value */
name|n
operator|=
name|ep
operator|->
name|e_fval
operator|.
name|c
operator|.
name|a
operator|+
name|ep
operator|->
name|e_fval
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|baseB
operator|<
name|n
condition|)
name|n
operator|=
name|baseB
expr_stmt|;
comment|/* make a new combo! */
name|ncbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
operator|+
operator|(
name|cbp
operator|->
name|c_nframes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|scbpp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|*
operator|)
operator|(
name|ncbp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sortcombo
argument_list|(
name|scbpp
argument_list|,
operator|(
expr|struct
name|combostr
operator|*
operator|*
operator|)
operator|(
name|cbp
operator|+
literal|1
operator|)
argument_list|,
name|ocbp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|combocnt
operator|++
expr_stmt|;
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|=
name|c
expr_stmt|;
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|b
operator|=
name|n
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|0
index|]
operator|=
name|cbp
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|=
name|ocbp
expr_stmt|;
name|ncbp
operator|->
name|c_linkv
index|[
literal|1
index|]
operator|.
name|s
operator|=
name|ocb
operator|.
name|s
expr_stmt|;
name|ncbp
operator|->
name|c_voff
index|[
literal|1
index|]
operator|=
name|off
expr_stmt|;
name|ncbp
operator|->
name|c_vertex
operator|=
name|osp
operator|-
name|board
expr_stmt|;
name|ncbp
operator|->
name|c_nframes
operator|=
name|cbp
operator|->
name|c_nframes
operator|+
literal|1
expr_stmt|;
name|ncbp
operator|->
name|c_flg
operator|=
name|ocb
operator|.
name|c
operator|.
name|b
condition|?
name|C_OPEN_1
else|:
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_frameindex
operator|=
name|ep
operator|->
name|e_frameindex
expr_stmt|;
comment|/* 	     * Update the completion spot mask of the frame we 	     * are attaching 'ocbp' to so the intersection isn't 	     * listed twice. 	     */
name|ncbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
operator|=
name|ep
operator|->
name|e_framecnt
expr_stmt|;
name|ncbp
operator|->
name|c_emask
index|[
literal|0
index|]
operator|=
name|ep
operator|->
name|e_emask
expr_stmt|;
if|if
condition|(
name|verts
condition|)
block|{
name|ncbp
operator|->
name|c_flg
operator||=
name|C_LOOP
expr_stmt|;
name|ncbp
operator|->
name|c_dir
operator|=
name|vertices
index|[
literal|0
index|]
operator|.
name|o_frameindex
expr_stmt|;
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
operator|=
name|fcnt
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
condition|)
block|{
name|n
operator|=
operator|(
name|vertices
index|[
literal|0
index|]
operator|.
name|o_intersect
operator|-
name|ocbp
operator|->
name|c_vertex
operator|)
operator|/
name|dd
index|[
name|ocbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
operator|=
name|emask
operator|&
operator|~
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
else|else
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_voff
index|[
literal|0
index|]
operator|=
name|vertices
index|[
literal|0
index|]
operator|.
name|o_off
expr_stmt|;
block|}
else|else
block|{
name|ncbp
operator|->
name|c_dir
operator|=
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
operator|=
name|fcnt
expr_stmt|;
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
operator|=
name|emask
expr_stmt|;
name|ncbp
operator|->
name|c_voff
index|[
literal|0
index|]
operator|=
name|ep
operator|->
name|e_off
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%c v%d i%d d%d c %d %d m %x %x o %d %d"
argument_list|,
literal|"bw"
index|[
name|curcolor
index|]
argument_list|,
name|verts
argument_list|,
name|ncbp
operator|->
name|c_frameindex
argument_list|,
name|ncbp
operator|->
name|c_dir
argument_list|,
name|ncbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
argument_list|,
name|ncbp
operator|->
name|c_emask
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_emask
index|[
literal|1
index|]
argument_list|,
name|ncbp
operator|->
name|c_voff
index|[
literal|0
index|]
argument_list|,
name|ncbp
operator|->
name|c_voff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|printcombo
argument_list|(
name|ncbp
argument_list|,
name|fmtbuf
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
comment|/* record the empty spots that will complete this combo */
name|makeempty
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
name|combolen
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* update board values */
name|updatecombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|4
condition|)
block|{
name|markcombo
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
name|bdisp
argument_list|()
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearcombo
argument_list|(
name|ncbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MAXDEPTH
value|100
end_define

begin_decl_stmt
name|struct
name|elist
name|einfo
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ecombo
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* separate from elist to save space */
end_comment

begin_comment
comment|/*  * Add the combostr 'ocbp' to the empty spots list for each empty spot  * in 'ocbp' that will complete the combo.  */
end_comment

begin_macro
name|makeempty
argument_list|(
argument|ocbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|tcbp
decl_stmt|,
modifier|*
modifier|*
name|cbpp
decl_stmt|;
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|d
decl_stmt|,
name|m
decl_stmt|,
name|emask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nframes
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"E%c "
argument_list|,
literal|"bw"
index|[
name|curcolor
index|]
argument_list|)
expr_stmt|;
name|printcombo
argument_list|(
name|ocbp
argument_list|,
name|fmtbuf
operator|+
literal|3
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* should never happen but check anyway */
if|if
condition|(
operator|(
name|nframes
operator|=
name|ocbp
operator|->
name|c_nframes
operator|)
operator|>=
name|MAXDEPTH
condition|)
return|return;
comment|/* 	 * The lower level combo can be pointed to by more than one 	 * higher level 'struct combostr' so we can't modify the 	 * lower level. Therefore, higher level combos store the 	 * real mask of the lower level frame in c_emask[0] and the 	 * frame number in c_frameindex. 	 * 	 * First we traverse the tree from top to bottom and save the 	 * connection info. Then we traverse the tree from bottom to 	 * top overwriting lower levels with the newer emask information. 	 */
name|ep
operator|=
operator|&
name|einfo
index|[
name|nframes
index|]
expr_stmt|;
name|cbpp
operator|=
operator|&
name|ecombo
index|[
name|nframes
index|]
expr_stmt|;
for|for
control|(
name|cbp
operator|=
name|ocbp
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|ep
operator|--
expr_stmt|;
name|ep
operator|->
name|e_combo
operator|=
name|cbp
expr_stmt|;
operator|*
operator|--
name|cbpp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_off
operator|=
name|cbp
operator|->
name|c_voff
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_frameindex
operator|=
name|cbp
operator|->
name|c_frameindex
expr_stmt|;
name|ep
operator|->
name|e_fval
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_linkv
index|[
literal|1
index|]
operator|.
name|s
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|1
index|]
expr_stmt|;
block|}
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
name|ep
operator|--
expr_stmt|;
name|ep
operator|->
name|e_combo
operator|=
name|cbp
expr_stmt|;
operator|*
operator|--
name|cbpp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_off
operator|=
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_frameindex
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|e_fval
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_linkv
index|[
literal|0
index|]
operator|.
name|s
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|0
index|]
expr_stmt|;
comment|/* now update the emask info */
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|ep
operator|+=
literal|2
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ep
operator|++
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
name|nep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
name|nep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_flg
operator|&
name|C_LOOP
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 			 * Account for the fact that this frame connects 			 * to a previous one (thus forming a loop). 			 */
name|nep
operator|=
operator|&
name|einfo
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|nep
operator|->
name|e_framecnt
condition|)
name|nep
operator|->
name|e_emask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|nep
operator|->
name|e_emask
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * We only need to update the emask values of "complete" loops 	 * to include the intersection spots. 	 */
if|if
condition|(
name|s
operator|&&
name|ocbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|==
literal|2
condition|)
block|{
comment|/* process loops from the top down */
name|ep
operator|=
operator|&
name|einfo
index|[
name|nframes
index|]
expr_stmt|;
do|do
block|{
name|ep
operator|--
expr_stmt|;
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cbp
operator|->
name|c_flg
operator|&
name|C_LOOP
operator|)
condition|)
continue|continue;
comment|/* 			 * Update the emask values to include the 			 * intersection spots. 			 */
name|nep
operator|=
operator|&
name|einfo
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|nep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|ep
operator|->
name|e_off
expr_stmt|;
name|ep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
do|do
block|{
name|ep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|ep
operator|->
name|e_off
expr_stmt|;
name|ep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ep
operator|>
name|nep
condition|)
do|;
block|}
do|while
condition|(
name|ep
operator|!=
name|einfo
condition|)
do|;
block|}
comment|/* check all the frames for completion spots */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|einfo
operator|,
name|cbpp
operator|=
name|ecombo
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ep
operator|++
operator|,
name|cbpp
operator|++
control|)
block|{
comment|/* skip this frame if there are no incomplete spots in it */
if|if
condition|(
operator|(
name|emask
operator|=
name|ep
operator|->
name|e_emask
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|cbp
operator|=
operator|*
name|cbpp
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
operator|,
name|m
operator|=
literal|1
init|;
name|s
operator|<
literal|5
condition|;
name|s
operator|++
operator|,
name|sp
operator|+=
name|d
operator|,
name|m
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
operator|||
operator|!
operator|(
name|emask
operator|&
name|m
operator|)
condition|)
continue|continue;
comment|/* add the combo to the list of empty spots */
name|nep
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elist
argument_list|)
argument_list|)
expr_stmt|;
name|nep
operator|->
name|e_combo
operator|=
name|ocbp
expr_stmt|;
name|nep
operator|->
name|e_off
operator|=
name|s
expr_stmt|;
name|nep
operator|->
name|e_frameindex
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_framecnt
operator|>
literal|1
condition|)
block|{
name|nep
operator|->
name|e_framecnt
operator|=
name|ep
operator|->
name|e_framecnt
operator|-
literal|1
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
name|emask
operator|&
operator|~
name|m
expr_stmt|;
block|}
else|else
block|{
name|nep
operator|->
name|e_framecnt
operator|=
literal|0
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
literal|0
expr_stmt|;
block|}
name|nep
operator|->
name|e_fval
operator|.
name|s
operator|=
name|ep
operator|->
name|e_fval
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"e %s o%d i%d c%d m%x %x"
argument_list|,
name|stoc
argument_list|(
name|sp
operator|-
name|board
argument_list|)
argument_list|,
name|nep
operator|->
name|e_off
argument_list|,
name|nep
operator|->
name|e_frameindex
argument_list|,
name|nep
operator|->
name|e_framecnt
argument_list|,
name|nep
operator|->
name|e_emask
argument_list|,
name|nep
operator|->
name|e_fval
operator|.
name|s
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* sort by the number of frames in the combo */
name|nep
operator|->
name|e_next
operator|=
name|sp
operator|->
name|s_nempty
expr_stmt|;
name|sp
operator|->
name|s_nempty
operator|=
name|nep
expr_stmt|;
name|elistcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Update the board value based on the combostr.  * This is called only if 'cbp' is a<1,x> combo.  * We handle things differently depending on whether the next move  * would be trying to "complete" the combo or trying to block it.  */
end_comment

begin_macro
name|updatecombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|framestr
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
name|int
name|nframes
decl_stmt|,
name|flg
decl_stmt|,
name|s
decl_stmt|;
name|union
name|comboval
name|cb
decl_stmt|;
comment|/* save the top level value for the whole combo */
name|cb
operator|.
name|c
operator|.
name|a
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
expr_stmt|;
name|nframes
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
if|if
condition|(
name|color
operator|!=
name|nextcolor
condition|)
name|memset
argument_list|(
name|tmpmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|flg
operator|=
name|cbp
operator|->
name|c_flg
expr_stmt|;
name|cb
operator|.
name|c
operator|.
name|b
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|b
expr_stmt|;
if|if
condition|(
name|color
operator|==
name|nextcolor
condition|)
block|{
comment|/* update the board value for the vertex */
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* update the board values for each spot in frame */
name|sp
operator|=
operator|&
name|board
index|[
name|s
operator|=
name|tcbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|tcbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|flg
operator|&
name|C_OPEN_1
operator|)
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
operator|,
name|s
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
name|BIT_SET
argument_list|(
name|tmpmap
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mark the frame as being part of a<1,x> combo */
name|board
index|[
name|tcbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|FFLAG
operator|<<
name|tcbp
operator|->
name|c_dir
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|!=
name|nextcolor
condition|)
block|{
comment|/* update the board values for each spot in frame */
name|sp
operator|=
operator|&
name|board
index|[
name|s
operator|=
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|flg
operator|&
name|C_OPEN_0
operator|)
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
operator|,
name|s
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|s
operator|!=
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
name|BIT_SET
argument_list|(
name|tmpmap
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nforce
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|forcemap
argument_list|,
name|tmpmap
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpmap
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAPSZ
condition|;
name|i
operator|++
control|)
name|forcemap
index|[
name|i
index|]
operator|&=
name|tmpmap
index|[
name|i
index|]
expr_stmt|;
block|}
name|nforce
operator|++
expr_stmt|;
block|}
comment|/* mark the frame as being part of a<1,x> combo */
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|FFLAG
operator|<<
name|cbp
operator|->
name|c_dir
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add combo to the end of the list.  */
end_comment

begin_macro
name|appendcombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|pcbp
decl_stmt|,
modifier|*
name|ncbp
decl_stmt|;
name|combolen
operator|++
expr_stmt|;
name|ncbp
operator|=
name|sortcombos
expr_stmt|;
if|if
condition|(
name|ncbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
block|{
name|sortcombos
operator|=
name|cbp
expr_stmt|;
name|cbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|cbp
expr_stmt|;
return|return;
block|}
name|pcbp
operator|=
name|ncbp
operator|->
name|c_prev
expr_stmt|;
name|cbp
operator|->
name|c_next
operator|=
name|ncbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|pcbp
expr_stmt|;
name|ncbp
operator|->
name|c_prev
operator|=
name|cbp
expr_stmt|;
name|pcbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return zero if it is valid to combine frame 'fcbp' with the frames  * in 'cbp' and forms a linked chain of frames (i.e., a tree; no loops).  * Return positive if combining frame 'fcbp' to the frames in 'cbp'  * would form some kind of valid loop. Also return the intersection spots  * in 'vertices[]' beside the known intersection at spot 'osp'.  * Return -1 if 'fcbp' should not be combined with 'cbp'.  * 's' is the combo value for frame 'fcpb'.  */
end_comment

begin_macro
name|checkframes
argument_list|(
argument|cbp
argument_list|,
argument|fcbp
argument_list|,
argument|osp
argument_list|,
argument|s
argument_list|,
argument|vertices
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|fcbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ovlp_info
modifier|*
name|vertices
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|,
modifier|*
name|lcbp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|mask
decl_stmt|,
name|flg
decl_stmt|,
name|verts
decl_stmt|,
name|loop
decl_stmt|,
name|index
decl_stmt|,
name|fcnt
decl_stmt|;
name|union
name|comboval
name|cb
decl_stmt|;
name|u_char
modifier|*
name|str
decl_stmt|;
name|short
modifier|*
name|ip
decl_stmt|;
name|cb
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|fcnt
operator|=
name|cb
operator|.
name|c
operator|.
name|a
operator|-
literal|2
expr_stmt|;
name|verts
operator|=
literal|0
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
name|n
operator|=
operator|(
name|fcbp
operator|-
name|frames
operator|)
operator|*
name|FAREA
expr_stmt|;
name|str
operator|=
operator|&
name|overlap
index|[
name|n
index|]
expr_stmt|;
name|ip
operator|=
operator|&
name|intersect
index|[
name|n
index|]
expr_stmt|;
comment|/* 	 * i == which overlap bit to test based on whether 'fcbp' is 	 * an open or closed frame. 	 */
name|i
operator|=
name|cb
operator|.
name|c
operator|.
name|b
condition|?
literal|2
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|lcbp
operator|=
name|cbp
operator|,
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
if|if
condition|(
name|tcbp
operator|==
name|fcbp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* fcbp is already included */
comment|/* check for intersection of 'tcbp' with 'fcbp' */
name|index
operator|--
expr_stmt|;
name|mask
operator|=
name|str
index|[
name|tcbp
operator|-
name|frames
index|]
expr_stmt|;
name|flg
operator|=
name|cbp
operator|->
name|c_flg
expr_stmt|;
name|n
operator|=
name|i
operator|+
operator|(
operator|(
name|flg
operator|&
name|C_OPEN_1
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
comment|/* 			 * The two frames are not independent if they 			 * both lie in the same line and intersect at 			 * more than one point. 			 */
if|if
condition|(
name|tcbp
operator|->
name|c_dir
operator|==
name|fcbp
operator|->
name|c_dir
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|0x10
operator|<<
name|n
operator|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * If this is not the spot we are attaching 			 * 'fcbp' to and it is a reasonable intersection 			 * spot, then there might be a loop. 			 */
name|n
operator|=
name|ip
index|[
name|tcbp
operator|-
name|frames
index|]
expr_stmt|;
if|if
condition|(
name|osp
operator|!=
operator|&
name|board
index|[
name|n
index|]
condition|)
block|{
comment|/* check to see if this is a valid loop */
if|if
condition|(
name|verts
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fcnt
operator|==
literal|0
operator|||
name|cbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 				 * Check to be sure the intersection is not 				 * one of the end points if it is an open 				 * ended frame. 				 */
if|if
condition|(
operator|(
name|flg
operator|&
name|C_OPEN_1
operator|)
operator|&&
operator|(
name|n
operator|==
name|tcbp
operator|->
name|c_vertex
operator|||
name|n
operator|==
name|tcbp
operator|->
name|c_vertex
operator|+
literal|5
operator|*
name|dd
index|[
name|tcbp
operator|->
name|c_dir
index|]
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid overlap */
if|if
condition|(
name|cb
operator|.
name|c
operator|.
name|b
operator|&&
operator|(
name|n
operator|==
name|fcbp
operator|->
name|c_vertex
operator|||
name|n
operator|==
name|fcbp
operator|->
name|c_vertex
operator|+
literal|5
operator|*
name|dd
index|[
name|fcbp
operator|->
name|c_dir
index|]
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid overlap */
name|vertices
operator|->
name|o_intersect
operator|=
name|n
expr_stmt|;
name|vertices
operator|->
name|o_fcombo
operator|=
name|cbp
expr_stmt|;
name|vertices
operator|->
name|o_link
operator|=
literal|1
expr_stmt|;
name|vertices
operator|->
name|o_off
operator|=
operator|(
name|n
operator|-
name|tcbp
operator|->
name|c_vertex
operator|)
operator|/
name|dd
index|[
name|tcbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|vertices
operator|->
name|o_frameindex
operator|=
name|index
expr_stmt|;
name|verts
operator|++
expr_stmt|;
block|}
block|}
name|n
operator|=
name|i
operator|+
operator|(
operator|(
name|flg
operator|&
name|C_OPEN_0
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|==
name|fcbp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* fcbp is already included */
comment|/* check for intersection of 'cbp' with 'fcbp' */
name|mask
operator|=
name|str
index|[
name|cbp
operator|-
name|frames
index|]
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
block|{
comment|/* 		 * The two frames are not independent if they 		 * both lie in the same line and intersect at 		 * more than one point. 		 */
if|if
condition|(
name|cbp
operator|->
name|c_dir
operator|==
name|fcbp
operator|->
name|c_dir
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|0x10
operator|<<
name|n
operator|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If this is not the spot we are attaching 		 * 'fcbp' to and it is a reasonable intersection 		 * spot, then there might be a loop. 		 */
name|n
operator|=
name|ip
index|[
name|cbp
operator|-
name|frames
index|]
expr_stmt|;
if|if
condition|(
name|osp
operator|!=
operator|&
name|board
index|[
name|n
index|]
condition|)
block|{
comment|/* check to see if this is a valid loop */
if|if
condition|(
name|verts
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fcnt
operator|==
literal|0
operator|||
name|lcbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * Check to be sure the intersection is not 			 * one of the end points if it is an open 			 * ended frame. 			 */
if|if
condition|(
operator|(
name|flg
operator|&
name|C_OPEN_0
operator|)
operator|&&
operator|(
name|n
operator|==
name|cbp
operator|->
name|c_vertex
operator|||
name|n
operator|==
name|cbp
operator|->
name|c_vertex
operator|+
literal|5
operator|*
name|dd
index|[
name|cbp
operator|->
name|c_dir
index|]
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid overlap */
if|if
condition|(
name|cb
operator|.
name|c
operator|.
name|b
operator|&&
operator|(
name|n
operator|==
name|fcbp
operator|->
name|c_vertex
operator|||
name|n
operator|==
name|fcbp
operator|->
name|c_vertex
operator|+
literal|5
operator|*
name|dd
index|[
name|fcbp
operator|->
name|c_dir
index|]
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid overlap */
name|vertices
operator|->
name|o_intersect
operator|=
name|n
expr_stmt|;
name|vertices
operator|->
name|o_fcombo
operator|=
name|lcbp
expr_stmt|;
name|vertices
operator|->
name|o_link
operator|=
literal|0
expr_stmt|;
name|vertices
operator|->
name|o_off
operator|=
operator|(
name|n
operator|-
name|cbp
operator|->
name|c_vertex
operator|)
operator|/
name|dd
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|vertices
operator|->
name|o_frameindex
operator|=
literal|0
expr_stmt|;
name|verts
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|verts
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Merge sort the frame 'fcbp' and the sorted list of frames 'cbpp' and  * store the result in 'scbpp'. 'curlevel' is the size of the 'cbpp' array.  * Return true if this list of frames is already in the hash list.  * Otherwise, add the new combo to the hash list.  */
end_comment

begin_macro
name|sortcombo
argument_list|(
argument|scbpp
argument_list|,
argument|cbpp
argument_list|,
argument|fcbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
modifier|*
name|scbpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
modifier|*
name|cbpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|fcbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
modifier|*
name|spp
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|inx
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"sortc: %s%c l%d"
argument_list|,
name|stoc
argument_list|(
name|fcbp
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|fcbp
operator|->
name|c_dir
index|]
argument_list|,
name|curlevel
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|str
operator|=
name|fmtbuf
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|cbpp
init|;
name|cpp
operator|<
name|cbpp
operator|+
name|curlevel
condition|;
name|cpp
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* first build the new sorted list */
name|n
operator|=
name|curlevel
operator|+
literal|1
expr_stmt|;
name|spp
operator|=
name|scbpp
operator|+
name|n
expr_stmt|;
name|cpp
operator|=
name|cbpp
operator|+
name|curlevel
expr_stmt|;
do|do
block|{
name|cpp
operator|--
expr_stmt|;
if|if
condition|(
name|fcbp
operator|>
operator|*
name|cpp
condition|)
block|{
operator|*
operator|--
name|spp
operator|=
name|fcbp
expr_stmt|;
do|do
operator|*
operator|--
name|spp
operator|=
operator|*
name|cpp
expr_stmt|;
do|while
condition|(
name|cpp
operator|--
operator|!=
name|cbpp
condition|)
do|;
goto|goto
name|inserted
goto|;
block|}
operator|*
operator|--
name|spp
operator|=
operator|*
name|cpp
expr_stmt|;
block|}
do|while
condition|(
name|cpp
operator|!=
name|cbpp
condition|)
do|;
operator|*
operator|--
name|spp
operator|=
name|fcbp
expr_stmt|;
name|inserted
label|:
comment|/* now check to see if this list of frames has already been seen */
name|cbp
operator|=
name|hashcombos
index|[
name|inx
operator|=
operator|*
name|scbpp
operator|-
name|frames
index|]
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 		 * Easy case, this list hasn't been seen. 		 * Add it to the hash list. 		 */
name|fcbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|scbpp
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
operator|)
expr_stmt|;
name|hashcombos
index|[
name|inx
index|]
operator|=
name|fcbp
expr_stmt|;
name|fcbp
operator|->
name|c_next
operator|=
name|fcbp
operator|->
name|c_prev
operator|=
name|fcbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ecbp
operator|=
name|cbp
expr_stmt|;
do|do
block|{
name|cbpp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|*
operator|)
operator|(
name|cbp
operator|+
literal|1
operator|)
expr_stmt|;
name|cpp
operator|=
name|cbpp
operator|+
name|n
expr_stmt|;
name|spp
operator|=
name|scbpp
operator|+
name|n
expr_stmt|;
name|cbpp
operator|++
expr_stmt|;
comment|/* first frame is always the same */
do|do
block|{
if|if
condition|(
operator|*
operator|--
name|spp
operator|!=
operator|*
operator|--
name|cpp
condition|)
goto|goto
name|next
goto|;
block|}
do|while
condition|(
name|cpp
operator|!=
name|cbpp
condition|)
do|;
comment|/* we found a match */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"sort1: n%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|str
operator|=
name|fmtbuf
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|scbpp
init|;
name|cpp
operator|<
name|scbpp
operator|+
name|n
condition|;
name|cpp
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|printcombo
argument_list|(
name|cbp
argument_list|,
name|fmtbuf
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|str
operator|=
name|fmtbuf
expr_stmt|;
name|cbpp
operator|--
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|cbpp
init|;
name|cpp
operator|<
name|cbpp
operator|+
name|n
condition|;
name|cpp
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
operator|(
operator|*
name|cpp
operator|)
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|1
operator|)
return|;
name|next
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
comment|/* 	 * This list of frames hasn't been seen. 	 * Add it to the hash list. 	 */
name|ecbp
operator|=
name|cbp
operator|->
name|c_prev
expr_stmt|;
name|fcbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|scbpp
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
operator|)
expr_stmt|;
name|fcbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
name|fcbp
operator|->
name|c_prev
operator|=
name|ecbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|fcbp
expr_stmt|;
name|ecbp
operator|->
name|c_next
operator|=
name|fcbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the combo into string 'str'.  */
end_comment

begin_macro
name|printcombo
argument_list|(
argument|cbp
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%x/%d"
argument_list|,
name|cbp
operator|->
name|c_combo
operator|.
name|s
argument_list|,
name|cbp
operator|->
name|c_nframes
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c%x"
argument_list|,
name|stoc
argument_list|(
name|tcbp
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|tcbp
operator|->
name|c_dir
index|]
argument_list|,
name|cbp
operator|->
name|c_flg
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
name|cbp
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|cbp
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|markcombo
argument_list|(
argument|ocbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|tcbp
decl_stmt|,
modifier|*
modifier|*
name|cbpp
decl_stmt|;
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|d
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nframes
decl_stmt|;
name|int
name|r
decl_stmt|,
name|n
decl_stmt|,
name|flg
decl_stmt|,
name|cmask
decl_stmt|,
name|omask
decl_stmt|;
comment|/* should never happen but check anyway */
if|if
condition|(
operator|(
name|nframes
operator|=
name|ocbp
operator|->
name|c_nframes
operator|)
operator|>=
name|MAXDEPTH
condition|)
return|return;
comment|/* 	 * The lower level combo can be pointed to by more than one 	 * higher level 'struct combostr' so we can't modify the 	 * lower level. Therefore, higher level combos store the 	 * real mask of the lower level frame in c_emask[0] and the 	 * frame number in c_frameindex. 	 * 	 * First we traverse the tree from top to bottom and save the 	 * connection info. Then we traverse the tree from bottom to 	 * top overwriting lower levels with the newer emask information. 	 */
name|ep
operator|=
operator|&
name|einfo
index|[
name|nframes
index|]
expr_stmt|;
name|cbpp
operator|=
operator|&
name|ecombo
index|[
name|nframes
index|]
expr_stmt|;
for|for
control|(
name|cbp
operator|=
name|ocbp
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|ep
operator|--
expr_stmt|;
name|ep
operator|->
name|e_combo
operator|=
name|cbp
expr_stmt|;
operator|*
operator|--
name|cbpp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_off
operator|=
name|cbp
operator|->
name|c_voff
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_frameindex
operator|=
name|cbp
operator|->
name|c_frameindex
expr_stmt|;
name|ep
operator|->
name|e_fval
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_linkv
index|[
literal|1
index|]
operator|.
name|s
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|1
index|]
expr_stmt|;
block|}
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
name|ep
operator|--
expr_stmt|;
name|ep
operator|->
name|e_combo
operator|=
name|cbp
expr_stmt|;
operator|*
operator|--
name|cbpp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_off
operator|=
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_frameindex
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|e_fval
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_linkv
index|[
literal|0
index|]
operator|.
name|s
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|0
index|]
expr_stmt|;
comment|/* now update the emask info */
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|ep
operator|+=
literal|2
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ep
operator|++
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
name|nep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
name|nep
operator|->
name|e_framecnt
operator|=
name|cbp
operator|->
name|c_framecnt
index|[
literal|0
index|]
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
name|cbp
operator|->
name|c_emask
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_flg
operator|&
name|C_LOOP
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* 			 * Account for the fact that this frame connects 			 * to a previous one (thus forming a loop). 			 */
name|nep
operator|=
operator|&
name|einfo
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|nep
operator|->
name|e_framecnt
condition|)
name|nep
operator|->
name|e_emask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|nep
operator|->
name|e_emask
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * We only need to update the emask values of "complete" loops 	 * to include the intersection spots. 	 */
if|if
condition|(
name|s
operator|&&
name|ocbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|==
literal|2
condition|)
block|{
comment|/* process loops from the top down */
name|ep
operator|=
operator|&
name|einfo
index|[
name|nframes
index|]
expr_stmt|;
do|do
block|{
name|ep
operator|--
expr_stmt|;
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cbp
operator|->
name|c_flg
operator|&
name|C_LOOP
operator|)
condition|)
continue|continue;
comment|/* 			 * Update the emask values to include the 			 * intersection spots. 			 */
name|nep
operator|=
operator|&
name|einfo
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|nep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|nep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|cbp
operator|->
name|c_voff
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|ep
operator|->
name|e_off
expr_stmt|;
name|ep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
do|do
block|{
name|ep
operator|->
name|e_framecnt
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|e_emask
operator|=
literal|1
operator|<<
name|ep
operator|->
name|e_off
expr_stmt|;
name|ep
operator|=
operator|&
name|einfo
index|[
name|ep
operator|->
name|e_frameindex
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ep
operator|>
name|nep
condition|)
do|;
block|}
do|while
condition|(
name|ep
operator|!=
name|einfo
condition|)
do|;
block|}
comment|/* mark all the frames with the completion spots */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|einfo
operator|,
name|cbpp
operator|=
name|ecombo
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
operator|,
name|ep
operator|++
operator|,
name|cbpp
operator|++
control|)
block|{
name|m
operator|=
name|ep
operator|->
name|e_emask
expr_stmt|;
name|cbp
operator|=
operator|*
name|cbpp
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|s
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|cmask
operator|=
name|CFLAG
operator|<<
name|s
expr_stmt|;
name|omask
operator|=
operator|(
name|IFLAG
operator||
name|CFLAG
operator|)
operator|<<
name|s
expr_stmt|;
name|s
operator|=
name|ep
operator|->
name|e_fval
operator|.
name|c
operator|.
name|b
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
init|;
operator|--
name|s
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
operator|,
name|m
operator|>>=
literal|1
control|)
name|sp
operator|->
name|s_flg
operator||=
operator|(
name|m
operator|&
literal|1
operator|)
condition|?
name|omask
else|:
name|cmask
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clearcombo
argument_list|(
argument|cbp
argument_list|,
argument|open
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|open
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
name|int
name|d
decl_stmt|,
name|n
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|clearcombo
argument_list|(
name|tcbp
argument_list|,
name|cbp
operator|->
name|c_flg
operator|&
name|C_OPEN_1
argument_list|)
expr_stmt|;
name|open
operator|=
name|cbp
operator|->
name|c_flg
operator|&
name|C_OPEN_0
expr_stmt|;
block|}
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|n
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
name|IFLAG
operator||
name|CFLAG
operator|)
operator|<<
name|n
operator|)
expr_stmt|;
name|n
operator|=
name|open
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
name|sp
operator|->
name|s_flg
operator|&=
name|mask
expr_stmt|;
block|}
end_block

begin_macro
name|list_eq
argument_list|(
argument|scbpp
argument_list|,
argument|cbpp
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
modifier|*
name|scbpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
modifier|*
name|cbpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
modifier|*
name|spp
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|spp
operator|=
name|scbpp
operator|+
name|n
expr_stmt|;
name|cpp
operator|=
name|cbpp
operator|+
name|n
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
operator|--
name|spp
operator|!=
operator|*
operator|--
name|cpp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
name|cpp
operator|!=
name|cbpp
condition|)
do|;
comment|/* we found a match */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

