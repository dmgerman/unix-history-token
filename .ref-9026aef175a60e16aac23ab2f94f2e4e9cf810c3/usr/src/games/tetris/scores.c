begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek and Darren F. Provine.  *  * %sccs.include.redist.c%  *  *	@(#)scores.c	8.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Score code for Tetris, by Darren Provine (kilroy@gboro.glassboro.edu)  * modified 22 January 1992, to limit the number of entries any one  * person has.  *  * Major whacks since then.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * XXX - need a<termcap.h>  */
end_comment

begin_decl_stmt
name|int
name|tputs
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"scores.h"
end_include

begin_include
include|#
directive|include
file|"tetris.h"
end_include

begin_comment
comment|/*  * Within this code, we can hang onto one extra "high score", leaving  * room for our current score (whether or not it is high).  *  * We also sometimes keep tabs on the "highest" score on each level.  * As long as the scores are kept sorted, this is simply the first one at  * that level.  */
end_comment

begin_define
define|#
directive|define
name|NUMSPOTS
value|(MAXHISCORES + 1)
end_define

begin_define
define|#
directive|define
name|NLEVELS
value|(MAXLEVEL + 1)
end_define

begin_decl_stmt
specifier|static
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nscores
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gotscores
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|highscore
name|scores
index|[
name|NUMSPOTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkscores
name|__P
argument_list|(
operator|(
expr|struct
name|highscore
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmpscores
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getscores
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printem
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|highscore
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|thisuser
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the score file.  Can be called from savescore (before showscores)  * or showscores (if savescore will not be called).  If the given pointer  * is not NULL, sets *fpp to an open file pointer that corresponds to a  * read/write score file that is locked with LOCK_EX.  Otherwise, the  * file is locked with LOCK_SH for the read and closed before return.  *  * Note, we assume closing the stdio file releases the lock.  */
end_comment

begin_function
specifier|static
name|void
name|getscores
parameter_list|(
name|fpp
parameter_list|)
name|FILE
modifier|*
modifier|*
name|fpp
decl_stmt|;
block|{
name|int
name|sd
decl_stmt|,
name|mint
decl_stmt|,
name|lck
decl_stmt|;
name|char
modifier|*
name|mstr
decl_stmt|,
modifier|*
name|human
decl_stmt|;
name|FILE
modifier|*
name|sf
decl_stmt|;
if|if
condition|(
name|fpp
operator|!=
name|NULL
condition|)
block|{
name|mint
operator|=
name|O_RDWR
operator||
name|O_CREAT
expr_stmt|;
name|mstr
operator|=
literal|"r+"
expr_stmt|;
name|human
operator|=
literal|"read/write"
expr_stmt|;
name|lck
operator|=
name|LOCK_EX
expr_stmt|;
block|}
else|else
block|{
name|mint
operator|=
name|O_RDONLY
expr_stmt|;
name|mstr
operator|=
literal|"r"
expr_stmt|;
name|human
operator|=
literal|"reading"
expr_stmt|;
name|lck
operator|=
name|LOCK_SH
expr_stmt|;
block|}
name|sd
operator|=
name|open
argument_list|(
name|_PATH_SCOREFILE
argument_list|,
name|mint
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fpp
operator|==
name|NULL
condition|)
block|{
name|nscores
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tetris: cannot open %s for %s: %s\n"
argument_list|,
name|_PATH_SCOREFILE
argument_list|,
name|human
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sf
operator|=
name|fdopen
argument_list|(
name|sd
argument_list|,
name|mstr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tetris: cannot fdopen %s for %s: %s\n"
argument_list|,
name|_PATH_SCOREFILE
argument_list|,
name|human
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Grab a lock. 	 */
if|if
condition|(
name|flock
argument_list|(
name|sd
argument_list|,
name|lck
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tetris: warning: score file %s cannot be locked: %s\n"
argument_list|,
name|_PATH_SCOREFILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nscores
operator|=
name|fread
argument_list|(
name|scores
argument_list|,
sizeof|sizeof
argument_list|(
name|scores
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MAXHISCORES
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|sf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tetris: error reading %s: %s\n"
argument_list|,
name|_PATH_SCOREFILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fpp
condition|)
operator|*
name|fpp
operator|=
name|sf
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savescore
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|highscore
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|change
decl_stmt|;
name|FILE
modifier|*
name|sf
decl_stmt|;
specifier|const
name|char
modifier|*
name|me
decl_stmt|;
name|getscores
argument_list|(
operator|&
name|sf
argument_list|)
expr_stmt|;
name|gotscores
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Allow at most one score per person per level -- see if we 	 * can replace an existing score, or (easiest) do nothing. 	 * Otherwise add new score at end (there is always room). 	 */
name|change
operator|=
literal|0
expr_stmt|;
name|me
operator|=
name|thisuser
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
operator|&
name|scores
index|[
literal|0
index|]
init|;
name|i
operator|<
name|nscores
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|hs_level
operator|!=
name|level
operator|||
name|strcmp
argument_list|(
name|sp
operator|->
name|hs_name
argument_list|,
name|me
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|score
operator|>
name|sp
operator|->
name|hs_score
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s bettered %s %d score of %d!\n"
argument_list|,
literal|"\nYou"
argument_list|,
literal|"your old level"
argument_list|,
name|level
argument_list|,
name|sp
operator|->
name|hs_score
operator|*
name|sp
operator|->
name|hs_level
argument_list|)
expr_stmt|;
name|sp
operator|->
name|hs_score
operator|=
name|score
expr_stmt|;
comment|/* new score */
name|sp
operator|->
name|hs_time
operator|=
name|now
expr_stmt|;
comment|/* and time */
name|change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|==
name|sp
operator|->
name|hs_score
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s tied %s %d high score.\n"
argument_list|,
literal|"\nYou"
argument_list|,
literal|"your old level"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|sp
operator|->
name|hs_time
operator|=
name|now
expr_stmt|;
comment|/* renew it */
name|change
operator|=
literal|1
expr_stmt|;
comment|/* gotta rewrite, sigh */
block|}
comment|/* else new score< old score: do nothing */
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|nscores
condition|)
block|{
name|strcpy
argument_list|(
name|sp
operator|->
name|hs_name
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|sp
operator|->
name|hs_level
operator|=
name|level
expr_stmt|;
name|sp
operator|->
name|hs_score
operator|=
name|score
expr_stmt|;
name|sp
operator|->
name|hs_time
operator|=
name|now
expr_stmt|;
name|nscores
operator|++
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|change
condition|)
block|{
comment|/* 		 * Sort& clean the scores, then rewrite. 		 */
name|nscores
operator|=
name|checkscores
argument_list|(
name|scores
argument_list|,
name|nscores
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|scores
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|nscores
argument_list|,
name|sf
argument_list|)
operator|!=
name|nscores
operator|||
name|fflush
argument_list|(
name|sf
argument_list|)
operator|==
name|EOF
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tetris: error writing %s: %s -- %s\n"
argument_list|,
name|_PATH_SCOREFILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
literal|"high scores may be damaged"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
comment|/* releases lock */
block|}
end_function

begin_comment
comment|/*  * Get login name, or if that fails, get something suitable.  * The result is always trimmed to fit in a score.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|thisuser
parameter_list|()
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|size_t
name|l
decl_stmt|;
specifier|static
name|char
name|u
index|[
sizeof|sizeof
argument_list|(
name|scores
index|[
literal|0
index|]
operator|.
name|hs_name
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|u
operator|)
return|;
name|p
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
name|p
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|else
name|p
operator|=
literal|"  ???"
expr_stmt|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
sizeof|sizeof
argument_list|(
name|u
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|u
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|u
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Score comparison function for qsort.  *  * If two scores are equal, the person who had the score first is  * listed first in the highscore file.  */
end_comment

begin_function
specifier|static
name|int
name|cmpscores
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
specifier|const
name|struct
name|highscore
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
specifier|register
name|long
name|l
decl_stmt|;
name|a
operator|=
name|x
expr_stmt|;
name|b
operator|=
name|y
expr_stmt|;
name|l
operator|=
operator|(
name|long
operator|)
name|b
operator|->
name|hs_level
operator|*
name|b
operator|->
name|hs_score
operator|-
operator|(
name|long
operator|)
name|a
operator|->
name|hs_level
operator|*
name|a
operator|->
name|hs_score
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|hs_time
operator|<
name|b
operator|->
name|hs_time
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|hs_time
operator|>
name|b
operator|->
name|hs_time
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * If we've added a score to the file, we need to check the file and ensure  * that this player has only a few entries.  The number of entries is  * controlled by MAXSCORES, and is to ensure that the highscore file is not  * monopolised by just a few people.  People who no longer have accounts are  * only allowed the highest score.  Scores older than EXPIRATION seconds are  * removed, unless they are someone's personal best.  * Caveat:  the highest score on each level is always kept.  */
end_comment

begin_function
specifier|static
name|int
name|checkscores
parameter_list|(
name|hs
parameter_list|,
name|num
parameter_list|)
specifier|register
name|struct
name|highscore
modifier|*
name|hs
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|highscore
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|numnames
decl_stmt|;
name|int
name|levelfound
index|[
name|NLEVELS
index|]
decl_stmt|;
struct|struct
name|peruser
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|times
decl_stmt|;
block|}
name|count
index|[
name|NUMSPOTS
index|]
struct|;
specifier|register
name|struct
name|peruser
modifier|*
name|pu
decl_stmt|;
comment|/* 	 * Sort so that highest totals come first. 	 * 	 * levelfound[i] becomes set when the first high score for that 	 * level is encountered.  By definition this is the highest score. 	 */
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hs
argument_list|,
name|nscores
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hs
argument_list|)
argument_list|,
name|cmpscores
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MINLEVEL
init|;
name|i
operator|<
name|NLEVELS
condition|;
name|i
operator|++
control|)
name|levelfound
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|numnames
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|hs
init|;
name|i
operator|<
name|num
condition|;
control|)
block|{
comment|/* 		 * This is O(n^2), but do you think we care? 		 */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|pu
operator|=
name|count
init|;
name|j
operator|<
name|numnames
condition|;
name|j
operator|++
operator|,
name|pu
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|hs_name
argument_list|,
name|pu
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|numnames
condition|)
block|{
comment|/* 			 * Add new user, set per-user count to 1. 			 */
name|pu
operator|->
name|name
operator|=
name|sp
operator|->
name|hs_name
expr_stmt|;
name|pu
operator|->
name|times
operator|=
literal|1
expr_stmt|;
name|numnames
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Two ways to keep this score: 			 * - Not too many (per user), still has acct,& 			 *	score not dated; or 			 * - High score on this level. 			 */
if|if
condition|(
operator|(
name|pu
operator|->
name|times
operator|<
name|MAXSCORES
operator|&&
name|getpwnam
argument_list|(
name|sp
operator|->
name|hs_name
argument_list|)
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|hs_time
operator|+
name|EXPIRATION
operator|>=
name|now
operator|)
operator|||
name|levelfound
index|[
name|sp
operator|->
name|hs_level
index|]
operator|==
literal|0
condition|)
name|pu
operator|->
name|times
operator|++
expr_stmt|;
else|else
block|{
comment|/* 				 * Delete this score, do not count it, 				 * do not pass go, do not collect $200. 				 */
name|num
operator|--
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|num
condition|;
name|k
operator|++
control|)
name|hs
index|[
name|k
index|]
operator|=
name|hs
index|[
name|k
operator|+
literal|1
index|]
expr_stmt|;
continue|continue;
block|}
block|}
name|levelfound
index|[
name|sp
operator|->
name|hs_level
index|]
operator|=
literal|1
expr_stmt|;
name|i
operator|++
operator|,
name|sp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|>
name|MAXHISCORES
condition|?
name|MAXHISCORES
else|:
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Show current scores.  This must be called after savescore, if  * savescore is called at all, for two reasons:  * - Showscores munches the time field.  * - Even if that were not the case, a new score must be recorded  *   before it can be shown anyway.  */
end_comment

begin_function
name|void
name|showscores
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|highscore
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|me
decl_stmt|;
name|int
name|levelfound
index|[
name|NLEVELS
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|gotscores
condition|)
name|getscores
argument_list|(
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\t\t\t    Tetris High Scores\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If level == 0, the person has not played a game but just asked for 	 * the high scores; we do not need to check for printing in highlight 	 * mode.  If SOstr is null, we can't do highlighting anyway. 	 */
name|me
operator|=
name|level
operator|&&
name|SOstr
condition|?
name|thisuser
argument_list|()
else|:
name|NULL
expr_stmt|;
comment|/* 	 * Set times to 0 except for high score on each level. 	 */
for|for
control|(
name|i
operator|=
name|MINLEVEL
init|;
name|i
operator|<
name|NLEVELS
condition|;
name|i
operator|++
control|)
name|levelfound
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|scores
init|;
name|i
operator|<
name|nscores
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|levelfound
index|[
name|sp
operator|->
name|hs_level
index|]
condition|)
name|sp
operator|->
name|hs_time
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|hs_time
operator|=
literal|1
expr_stmt|;
name|levelfound
index|[
name|sp
operator|->
name|hs_level
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Page each screenful of scores. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|scores
init|;
name|i
operator|<
name|nscores
condition|;
name|sp
operator|+=
name|n
control|)
block|{
name|n
operator|=
literal|40
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|n
operator|>
name|nscores
condition|)
name|n
operator|=
name|nscores
operator|-
name|i
expr_stmt|;
name|printem
argument_list|(
name|level
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sp
argument_list|,
name|n
argument_list|,
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+=
name|n
operator|)
operator|<
name|nscores
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nHit RETURN to continue."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printem
parameter_list|(
name|level
parameter_list|,
name|offset
parameter_list|,
name|hs
parameter_list|,
name|n
parameter_list|,
name|me
parameter_list|)
name|int
name|level
decl_stmt|,
name|offset
decl_stmt|;
specifier|register
name|struct
name|highscore
modifier|*
name|hs
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|me
decl_stmt|;
block|{
specifier|register
name|struct
name|highscore
modifier|*
name|sp
decl_stmt|;
name|int
name|nrows
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|,
name|item
decl_stmt|,
name|i
decl_stmt|,
name|highlight
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
define|#
directive|define
name|TITLE
value|"Rank  Score   Name     (points/level)"
comment|/* 	 * This makes a nice two-column sort with headers, but it's a bit 	 * convoluted... 	 */
name|printf
argument_list|(
literal|"%s   %s\n"
argument_list|,
name|TITLE
argument_list|,
name|n
operator|>
literal|1
condition|?
name|TITLE
else|:
literal|""
argument_list|)
expr_stmt|;
name|highlight
operator|=
literal|0
expr_stmt|;
name|nrows
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
literal|2
condition|;
name|col
operator|++
control|)
block|{
name|item
operator|=
name|col
operator|*
name|nrows
operator|+
name|row
expr_stmt|;
if|if
condition|(
name|item
operator|>=
name|n
condition|)
block|{
comment|/* 				 * Can only occur on trailing columns. 				 */
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|item
operator|+
name|offset
operator|<
literal|10
condition|?
literal|"  "
else|:
literal|" "
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|hs
index|[
name|item
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d%c %6d  %-11s (%d on %d)"
argument_list|,
name|item
operator|+
name|offset
argument_list|,
name|sp
operator|->
name|hs_time
condition|?
literal|'*'
else|:
literal|' '
argument_list|,
name|sp
operator|->
name|hs_score
operator|*
name|sp
operator|->
name|hs_level
argument_list|,
name|sp
operator|->
name|hs_name
argument_list|,
name|sp
operator|->
name|hs_score
argument_list|,
name|sp
operator|->
name|hs_level
argument_list|)
expr_stmt|;
comment|/* 			 * Highlight if appropriate.  This works because 			 * we only get one score per level. 			 */
if|if
condition|(
name|me
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|hs_level
operator|==
name|level
operator|&&
name|sp
operator|->
name|hs_score
operator|==
name|score
operator|&&
name|strcmp
argument_list|(
name|sp
operator|->
name|hs_name
argument_list|,
name|me
argument_list|)
operator|==
literal|0
condition|)
block|{
name|putpad
argument_list|(
name|SOstr
argument_list|)
expr_stmt|;
name|highlight
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|highlight
condition|)
block|{
name|putpad
argument_list|(
name|SEstr
argument_list|)
expr_stmt|;
name|highlight
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fill in spaces so column 1 lines up */
if|if
condition|(
name|col
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|40
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
comment|/* col == 1 */
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

