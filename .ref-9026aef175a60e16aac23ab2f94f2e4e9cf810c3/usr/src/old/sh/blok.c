begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)blok.c	4.3 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	UNIX shell  *  *	S. R. Bourne  *	Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  *	storage allocator  *	(circular first fit strategy)  */
end_comment

begin_define
define|#
directive|define
name|BUSY
value|01
end_define

begin_define
define|#
directive|define
name|busy
parameter_list|(
name|x
parameter_list|)
value|(Rcheat((x)->word)&BUSY)
end_define

begin_decl_stmt
name|POS
name|brkincr
init|=
name|BRKINCR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BLKPTR
name|blokp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current search pointer*/
end_comment

begin_decl_stmt
name|BLKPTR
name|bloktop
init|=
name|BLK
argument_list|(
name|end
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*top of arena (last blok)*/
end_comment

begin_function
name|ADDRESS
name|alloc
parameter_list|(
name|nbytes
parameter_list|)
name|POS
name|nbytes
decl_stmt|;
block|{
name|REG
name|POS
name|rbytes
init|=
name|round
argument_list|(
name|nbytes
operator|+
name|BYTESPERWORD
argument_list|,
name|BYTESPERWORD
argument_list|)
decl_stmt|;
name|LOOP
name|INT
name|c
init|=
literal|0
decl_stmt|;
name|REG
name|BLKPTR
name|p
init|=
name|blokp
decl_stmt|;
name|REG
name|BLKPTR
name|q
decl_stmt|;
name|REP
name|IF
operator|!
name|busy
argument_list|(
argument|p
argument_list|)
name|THEN
name|WHILE
operator|!
name|busy
argument_list|(
argument|q = p->word
argument_list|)
name|DO
name|p
operator|->
name|word
operator|=
name|q
operator|->
name|word
name|OD
name|IF
name|ADR
argument_list|(
name|q
argument_list|)
operator|-
name|ADR
argument_list|(
name|p
argument_list|)
operator|>=
name|rbytes
name|THEN
name|blokp
operator|=
name|BLK
argument_list|(
name|ADR
argument_list|(
name|p
argument_list|)
operator|+
name|rbytes
argument_list|)
expr_stmt|;
name|IF
name|q
operator|>
name|blokp
name|THEN
name|blokp
operator|->
name|word
operator|=
name|p
operator|->
name|word
expr_stmt|;
name|FI
name|p
operator|->
name|word
init|=
name|BLK
argument_list|(
name|Rcheat
argument_list|(
name|blokp
argument_list|)
operator||
name|BUSY
argument_list|)
decl_stmt|;
return|return
operator|(
name|ADR
argument_list|(
name|p
operator|+
literal|1
argument_list|)
operator|)
return|;
name|FI
name|FI
name|q
init|=
name|p
decl_stmt|;
name|p
operator|=
name|BLK
argument_list|(
name|Rcheat
argument_list|(
name|p
operator|->
name|word
argument_list|)
operator|&
operator|~
name|BUSY
argument_list|)
expr_stmt|;
name|PER
name|p
operator|>
name|q
name|ORF
argument_list|(
name|c
operator|++
argument_list|)
operator|==
literal|0
name|DONE
name|addblok
argument_list|(
name|rbytes
argument_list|)
expr_stmt|;
name|POOL
block|}
end_function

begin_function
name|VOID
name|addblok
parameter_list|(
name|reqd
parameter_list|)
name|POS
name|reqd
decl_stmt|;
block|{
name|IF
name|stakbas
operator|!=
name|staktop
name|THEN
name|REG
name|STKPTR
name|rndstak
expr_stmt|;
name|REG
name|BLKPTR
name|blokstak
decl_stmt|;
name|pushstak
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rndstak
operator|=
name|round
argument_list|(
name|staktop
argument_list|,
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|blokstak
operator|=
name|BLK
argument_list|(
name|stakbas
argument_list|)
operator|-
literal|1
expr_stmt|;
name|blokstak
operator|->
name|word
operator|=
name|stakbsy
expr_stmt|;
name|stakbsy
operator|=
name|blokstak
expr_stmt|;
name|bloktop
operator|->
name|word
operator|=
name|BLK
argument_list|(
name|Rcheat
argument_list|(
name|rndstak
argument_list|)
operator||
name|BUSY
argument_list|)
expr_stmt|;
name|bloktop
operator|=
name|BLK
argument_list|(
name|rndstak
argument_list|)
expr_stmt|;
name|FI
name|reqd
operator|+=
name|brkincr
expr_stmt|;
name|reqd
operator|&=
operator|~
operator|(
name|brkincr
operator|-
literal|1
operator|)
expr_stmt|;
name|blokp
operator|=
name|bloktop
expr_stmt|;
name|bloktop
operator|=
name|bloktop
operator|->
name|word
operator|=
name|BLK
argument_list|(
name|Rcheat
argument_list|(
name|bloktop
argument_list|)
operator|+
name|reqd
argument_list|)
expr_stmt|;
name|bloktop
operator|->
name|word
operator|=
name|BLK
argument_list|(
name|ADR
argument_list|(
name|end
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BEGIN
name|REG
name|STKPTR
name|stakadr
init|=
name|STK
argument_list|(
name|bloktop
operator|+
literal|2
argument_list|)
decl_stmt|;
name|staktop
operator|=
name|movstr
argument_list|(
name|stakbot
argument_list|,
name|stakadr
argument_list|)
expr_stmt|;
name|stakbas
operator|=
name|stakbot
operator|=
name|stakadr
expr_stmt|;
name|END
block|}
end_function

begin_function
name|VOID
name|free
parameter_list|(
name|ap
parameter_list|)
name|BLKPTR
name|ap
decl_stmt|;
block|{
name|REG
name|BLKPTR
name|p
decl_stmt|;
name|IF
argument_list|(
argument|p=ap
argument_list|)
name|ANDF
name|p
operator|<
name|bloktop
name|THEN
name|Lcheat
argument_list|(
operator|(
operator|--
name|p
operator|)
operator|->
name|word
argument_list|)
operator|&=
operator|~
name|BUSY
expr_stmt|;
name|FI
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|chkbptr
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|BLKPTR
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INT
name|exf
init|=
literal|0
decl_stmt|;
name|REG
name|BLKPTR
name|p
init|=
name|end
decl_stmt|;
name|REG
name|BLKPTR
name|q
decl_stmt|;
name|INT
name|us
init|=
literal|0
decl_stmt|,
name|un
init|=
literal|0
decl_stmt|;
name|LOOP
name|q
init|=
name|Rcheat
argument_list|(
name|p
operator|->
name|word
argument_list|)
operator|&
operator|~
name|BUSY
decl_stmt|;
name|IF
name|p
operator|==
name|ptr
name|THEN
name|exf
operator|++
name|FI
name|IF
name|q
operator|<
name|end
name|ORF
name|q
operator|>
name|bloktop
name|THEN
name|abort
argument_list|(
literal|3
argument_list|)
name|FI
name|IF
name|p
operator|==
name|bloktop
name|THEN
break|break
name|FI
name|IF
name|busy
break|(
name|p
block|)
end_block

begin_expr_stmt
name|THEN
name|us
operator|+=
name|q
operator|-
name|p
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ELSE
name|un
operator|+=
name|q
operator|-
name|p
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FI
name|IF
name|p
operator|>=
name|q
name|THEN
name|abort
argument_list|(
literal|4
argument_list|)
name|FI
name|p
operator|=
name|q
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|POOL
name|IF
name|exf
operator|==
literal|0
name|THEN
name|abort
argument_list|(
literal|1
argument_list|)
name|FI
name|prn
argument_list|(
name|un
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prc
argument_list|(
name|SP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prn
argument_list|(
name|us
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prc
argument_list|(
name|NL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|void
operator|*
name|realloc
argument_list|(
argument|cp
argument_list|,
argument|nbytes
argument_list|)
name|void
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
name|new
operator|)
return|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|new
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_block

end_unit

