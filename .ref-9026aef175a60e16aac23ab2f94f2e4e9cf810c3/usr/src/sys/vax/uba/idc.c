begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)idc.c	7.10 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"rb.h"
end_include

begin_if
if|#
directive|if
name|NIDC
operator|>
literal|0
end_if

begin_decl_stmt
name|int
name|idcdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|printd
value|if(idcdebug)printf
end_define

begin_decl_stmt
name|int
name|idctrb
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|trp
init|=
name|idctrb
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|trace
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{*trp++ = *(int*)a; *trp++ = (int)b; if(trp>&idctrb[998])trp=idctrb;}
end_define

begin_comment
comment|/*  * IDC (RB730) disk driver  *  * There can only ever be one IDC on a machine,  * and only on a VAX-11/730.  We take advantage  * of that to simplify the driver.  *  * TODO:  *	ecc  */
end_comment

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/conf.h"
end_include

begin_include
include|#
directive|include
file|"sys/user.h"
end_include

begin_include
include|#
directive|include
file|"sys/map.h"
end_include

begin_include
include|#
directive|include
file|"sys/vm.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"sys/disklabel.h"
end_include

begin_include
include|#
directive|include
file|"sys/dkstat.h"
end_include

begin_include
include|#
directive|include
file|"sys/cmap.h"
end_include

begin_include
include|#
directive|include
file|"sys/dkbad.h"
end_include

begin_include
include|#
directive|include
file|"sys/uio.h"
end_include

begin_include
include|#
directive|include
file|"sys/kernel.h"
end_include

begin_include
include|#
directive|include
file|"sys/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"idcreg.h"
end_include

begin_struct
struct|struct
name|idc_softc
block|{
name|int
name|sc_bcnt
decl_stmt|;
comment|/* number of bytes to transfer */
name|int
name|sc_resid
decl_stmt|;
comment|/* total number of bytes to transfer */
name|int
name|sc_ubaddr
decl_stmt|;
comment|/* Unibus address of data */
name|short
name|sc_unit
decl_stmt|;
comment|/* unit doing transfer */
name|short
name|sc_softas
decl_stmt|;
comment|/* software attention summary bits */
union|union
name|idc_dar
block|{
name|long
name|dar_l
decl_stmt|;
name|u_short
name|dar_w
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|dar_b
index|[
literal|4
index|]
decl_stmt|;
block|}
name|sc_un
union|;
comment|/* prototype disk address register */
block|}
name|idc_softc
struct|;
end_struct

begin_define
define|#
directive|define
name|dar_dar
value|dar_l
end_define

begin_comment
comment|/* the whole disk address */
end_comment

begin_define
define|#
directive|define
name|dar_cyl
value|dar_w[1]
end_define

begin_comment
comment|/* cylinder address */
end_comment

begin_define
define|#
directive|define
name|dar_trk
value|dar_b[1]
end_define

begin_comment
comment|/* track */
end_comment

begin_define
define|#
directive|define
name|dar_sect
value|dar_b[0]
end_define

begin_comment
comment|/* sector */
end_comment

begin_define
define|#
directive|define
name|sc_dar
value|sc_un.dar_dar
end_define

begin_define
define|#
directive|define
name|sc_cyl
value|sc_un.dar_cyl
end_define

begin_define
define|#
directive|define
name|sc_trk
value|sc_un.dar_trk
end_define

begin_define
define|#
directive|define
name|sc_sect
value|sc_un.dar_sect
end_define

begin_define
define|#
directive|define
name|idcunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 3)
end_define

begin_comment
comment|/* THIS SHOULD BE READ OFF THE PACK, PER DRIVE */
end_comment

begin_struct
struct|struct
name|size
block|{
name|daddr_t
name|nblocks
decl_stmt|;
name|int
name|cyloff
decl_stmt|;
block|}
name|rb02_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=cyl 0 thru 399 */
literal|4480
block|,
literal|400
block|,
comment|/* B=cyl 400 thru 510 */
literal|20480
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 511 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
struct|,
name|rb80_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=cyl 0 thru 36 */
literal|33440
block|,
literal|37
block|,
comment|/* B=cyl 37 thru 114 */
literal|242606
block|,
literal|0
block|,
comment|/* C=cyl 0 thru 558 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|82080
block|,
literal|115
block|,
comment|/* G=cyl 115 thru 304 */
literal|110143
block|,
literal|305
block|,
comment|/* H=cyl 305 thru 558 */
block|}
struct|;
end_struct

begin_comment
comment|/* END OF STUFF WHICH SHOULD BE READ IN PER DISK */
end_comment

begin_decl_stmt
name|int
name|idcprobe
argument_list|()
decl_stmt|,
name|idcslave
argument_list|()
decl_stmt|,
name|idcattach
argument_list|()
decl_stmt|,
name|idcdgo
argument_list|()
decl_stmt|,
name|idcintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|idcminfo
index|[
name|NIDC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|idcdinfo
index|[
name|NRB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|idcstd
index|[]
init|=
block|{
literal|0174400
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|idcdriver
init|=
block|{
name|idcprobe
block|,
name|idcslave
block|,
name|idcattach
block|,
name|idcdgo
block|,
name|idcstd
block|,
literal|"rb"
block|,
name|idcdinfo
block|,
literal|"idc"
block|,
name|idcminfo
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|idcutab
index|[
name|NRB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|idc_dar
name|idccyl
index|[
name|NRB
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|idcst
block|{
name|short
name|nbps
decl_stmt|;
name|short
name|nsect
decl_stmt|;
name|short
name|ntrak
decl_stmt|;
name|short
name|nspc
decl_stmt|;
name|short
name|ncyl
decl_stmt|;
name|struct
name|size
modifier|*
name|sizes
decl_stmt|;
block|}
name|idcst
index|[]
init|=
block|{
literal|256
block|,
name|NRB02SECT
block|,
name|NRB02TRK
block|,
name|NRB02SECT
operator|*
name|NRB02TRK
block|,
name|NRB02CYL
block|,
name|rb02_sizes
block|,
literal|512
block|,
name|NRB80SECT
block|,
name|NRB80TRK
block|,
name|NRB80SECT
operator|*
name|NRB80TRK
block|,
name|NRB80CYL
block|,
name|rb80_sizes
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_decl_stmt
name|int
name|idcwstart
decl_stmt|,
name|idcwticks
decl_stmt|,
name|idcwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|idcprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
name|idcaddr
operator|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_uba
operator|+
literal|0x200
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_ATTN
operator||
name|IDC_IE
expr_stmt|;
while|while
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_CRDY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_ATTN
operator||
name|IDC_CRDY
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|idcdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|idcslave
argument_list|(
argument|ui
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|idcaddr
operator|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_uba
operator|+
literal|0x200
operator|)
expr_stmt|;
name|ui
operator|->
name|ui_type
operator|=
literal|0
expr_stmt|;
name|idcaddr
operator|->
name|idcmpr
operator|=
name|IDCGS_GETSTAT
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_GETSTAT
operator||
operator|(
name|ui
operator|->
name|ui_slave
operator|<<
literal|8
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|idcaddr
operator|->
name|idcmpr
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
operator|(
literal|1
operator|<<
operator|(
name|ui
operator|->
name|ui_slave
operator|+
literal|16
operator|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read header to synchronize microcode */
name|idcaddr
operator|->
name|idccsr
operator|=
operator|(
name|ui
operator|->
name|ui_slave
operator|<<
literal|8
operator|)
operator||
name|IDC_RHDR
expr_stmt|;
operator|(
name|void
operator|)
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|idcaddr
operator|->
name|idcmpr
expr_stmt|;
comment|/* read header word 1 */
name|i
operator|=
name|idcaddr
operator|->
name|idcmpr
expr_stmt|;
comment|/* read header word 2 */
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
operator|(
name|IDC_ERR
operator||
name|IDC_R80
operator|)
operator|)
operator|==
name|IDC_R80
condition|)
name|ui
operator|->
name|ui_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
operator|(
name|IDC_DE
operator||
name|IDC_R80
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* 		 * RB02 may not have pack spun up, just look for drive error. 		 */
name|ui
operator|->
name|ui_type
operator|=
literal|0
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|idcattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	 * Fix all addresses to correspond 	 * to the "real" IDC address. 	 */
name|ui
operator|->
name|ui_mi
operator|->
name|um_addr
operator|=
name|ui
operator|->
name|ui_addr
operator|=
operator|(
name|caddr_t
operator|)
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_uba
operator|+
literal|0x200
expr_stmt|;
name|ui
operator|->
name|ui_physaddr
operator|=
operator|(
name|caddr_t
operator|)
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_physuba
operator|+
literal|0x200
expr_stmt|;
if|if
condition|(
name|idcwstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|idcwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|idcwstart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
if|if
condition|(
name|ui
operator|->
name|ui_type
condition|)
name|dk_wpms
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|=
operator|(
literal|60
operator|*
name|NRB80SECT
operator|*
literal|256
operator|)
expr_stmt|;
else|else
name|dk_wpms
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|=
operator|(
literal|60
operator|*
name|NRB02SECT
operator|*
literal|128
operator|)
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
operator|-
literal|1
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|idcopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|idcunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRB
operator|||
operator|(
name|ui
operator|=
name|idcdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|idcstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|xunit
init|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|07
decl_stmt|;
name|long
name|bn
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|511
operator|)
operator|>>
literal|9
expr_stmt|;
name|unit
operator|=
name|idcunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRB
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ui
operator|=
name|idcdinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|st
operator|=
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
operator|(
name|bn
operator|=
name|bp
operator|->
name|b_blkno
operator|)
operator|+
name|sz
operator|>
name|st
operator|->
name|sizes
index|[
name|xunit
index|]
operator|.
name|nblocks
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|st
operator|->
name|sizes
index|[
name|xunit
index|]
operator|.
name|nblocks
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ui
operator|->
name|ui_type
operator|==
literal|0
condition|)
name|bn
operator|*=
literal|2
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
name|bn
operator|/
name|st
operator|->
name|nspc
operator|+
name|st
operator|->
name|sizes
index|[
name|xunit
index|]
operator|.
name|cyloff
expr_stmt|;
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
name|trace
argument_list|(
literal|"strt"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|idcutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|trace
argument_list|(
literal|"!act"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|idcustart
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|ui
operator|->
name|ui_mi
operator|->
name|um_tab
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_actf
operator|&&
name|bp
operator|->
name|b_active
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|idcstart
argument_list|(
name|ui
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|idcustart
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
decl_stmt|;
specifier|register
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
name|union
name|idc_dar
name|cyltrk
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ui
operator|->
name|ui_dk
operator|)
expr_stmt|;
name|dp
operator|=
operator|&
name|idcutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|um
operator|=
name|ui
operator|->
name|ui_mi
expr_stmt|;
name|unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|trace
argument_list|(
literal|"ust"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|idcaddr
operator|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|idc_softc
operator|.
name|sc_softas
operator||=
literal|1
operator|<<
name|unit
expr_stmt|;
name|trace
argument_list|(
literal|"umac"
argument_list|,
name|idc_softc
operator|.
name|sc_softas
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|trace
argument_list|(
literal|"!bp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
block|{
name|trace
argument_list|(
literal|"dpac"
argument_list|,
name|dp
operator|->
name|b_active
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* CHECK DRIVE READY? */
name|bn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|trace
argument_list|(
literal|"seek"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_type
operator|==
literal|0
condition|)
name|bn
operator|*=
literal|2
expr_stmt|;
name|st
operator|=
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
expr_stmt|;
name|cyltrk
operator|.
name|dar_cyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|cyltrk
operator|.
name|dar_trk
operator|=
operator|(
name|bn
operator|/
name|st
operator|->
name|nsect
operator|)
operator|%
name|st
operator|->
name|ntrak
expr_stmt|;
name|cyltrk
operator|.
name|dar_sect
operator|=
literal|0
expr_stmt|;
name|printd
argument_list|(
literal|"idcustart, unit %d, cyltrk 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|cyltrk
operator|.
name|dar_dar
argument_list|)
expr_stmt|;
comment|/* 	 * If on cylinder, no need to seek. 	 */
if|if
condition|(
name|cyltrk
operator|.
name|dar_dar
operator|==
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * RB80 can change heads (tracks) just by loading 	 * the disk address register, perform optimization 	 * here instead of doing a full seek. 	 */
if|if
condition|(
name|ui
operator|->
name|ui_type
operator|&&
name|cyltrk
operator|.
name|dar_cyl
operator|==
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_cyl
condition|)
block|{
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|IDC_IE
operator||
name|IDC_SEEK
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|cyltrk
operator|.
name|dar_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
name|cyltrk
operator|.
name|dar_dar
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Need to do a full seek.  Select the unit, clear 	 * its attention bit, set the command, load the 	 * disk address register, and then go. 	 */
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|IDC_IE
operator||
name|IDC_SEEK
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|unit
operator|+
literal|16
operator|)
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|cyltrk
operator|.
name|dar_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
name|cyltrk
operator|.
name|dar_dar
expr_stmt|;
name|printd
argument_list|(
literal|"  seek"
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_SEEK
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|ui
operator|->
name|ui_dk
expr_stmt|;
name|dk_seek
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
block|}
comment|/* 	 * RB80's initiate seeks very quickly.  Wait for it 	 * to come ready rather than taking the interrupt. 	 */
if|if
condition|(
name|ui
operator|->
name|ui_type
condition|)
block|{
if|if
condition|(
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|idcaddr
operator|->
name|idccsr
operator|&=
operator|~
name|IDC_ATTN
expr_stmt|;
comment|/* has the seek completed? */
if|if
condition|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
condition|)
block|{
name|printd
argument_list|(
literal|", drdy"
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|IDC_IE
operator||
name|IDC_SEEK
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|unit
operator|+
literal|16
operator|)
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|printd
argument_list|(
literal|", idccsr = 0x%x\n"
argument_list|,
name|idcaddr
operator|->
name|idccsr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|done
label|:
if|if
condition|(
name|dp
operator|->
name|b_active
operator|!=
literal|2
condition|)
block|{
name|trace
argument_list|(
literal|"!=2"
argument_list|,
name|dp
operator|->
name|b_active
argument_list|)
expr_stmt|;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
block|{
name|trace
argument_list|(
literal|"!NUL"
argument_list|,
name|um
operator|->
name|um_tab
operator|.
name|b_actl
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
block|}
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|idcstart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
decl_stmt|;
specifier|register
name|struct
name|idc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|sn
decl_stmt|,
name|tn
decl_stmt|,
name|cmd
decl_stmt|;
name|loop
label|:
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|trace
argument_list|(
literal|"nodp"
argument_list|,
name|um
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|trace
argument_list|(
literal|"nobp"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
name|ui
operator|=
name|idcdinfo
index|[
name|idcunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|bn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|trace
argument_list|(
literal|"star"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_type
operator|==
literal|0
condition|)
name|bn
operator|*=
literal|2
expr_stmt|;
name|sc
operator|=
operator|&
name|idc_softc
expr_stmt|;
name|st
operator|=
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
expr_stmt|;
name|sn
operator|=
name|bn
operator|%
name|st
operator|->
name|nspc
expr_stmt|;
name|tn
operator|=
name|sn
operator|/
name|st
operator|->
name|nsect
expr_stmt|;
name|sn
operator|%=
name|st
operator|->
name|nsect
expr_stmt|;
name|sc
operator|->
name|sc_sect
operator|=
name|sn
expr_stmt|;
name|sc
operator|->
name|sc_trk
operator|=
name|tn
expr_stmt|;
name|sc
operator|->
name|sc_cyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|idcaddr
operator|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|printd
argument_list|(
literal|"idcstart, unit %d, dar 0x%x"
argument_list|,
name|ui
operator|->
name|ui_slave
argument_list|,
name|sc
operator|->
name|sc_dar
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|cmd
operator|=
name|IDC_IE
operator||
name|IDC_READ
operator||
operator|(
name|ui
operator|->
name|ui_slave
operator|<<
literal|8
operator|)
expr_stmt|;
else|else
name|cmd
operator|=
name|IDC_IE
operator||
name|IDC_WRITE
operator||
operator|(
name|ui
operator|->
name|ui_slave
operator|<<
literal|8
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|cmd
expr_stmt|;
if|if
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rb%d: not ready\n"
argument_list|,
name|idcunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_sect
operator|=
literal|0
expr_stmt|;
name|sn
operator|=
operator|(
name|st
operator|->
name|nsect
operator|-
name|sn
operator|)
operator|*
name|st
operator|->
name|nbps
expr_stmt|;
if|if
condition|(
name|sn
operator|>
name|bp
operator|->
name|b_bcount
condition|)
name|sn
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|sc
operator|->
name|sc_bcnt
operator|=
name|sn
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|printd
argument_list|(
literal|", bcr 0x%x, cmd 0x%x\n"
argument_list|,
name|sn
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_cmd
operator|=
name|cmd
expr_stmt|;
operator|(
name|void
operator|)
name|ubago
argument_list|(
name|ui
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|idcdgo
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
init|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|idc_softc
modifier|*
name|sc
init|=
operator|&
name|idc_softc
decl_stmt|;
comment|/* 	 * VERY IMPORTANT: must load registers in this order. 	 */
name|idcaddr
operator|->
name|idcbar
operator|=
name|sc
operator|->
name|sc_ubaddr
operator|=
name|UBAI_ADDR
argument_list|(
name|um
operator|->
name|um_ubinfo
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idcbcr
operator|=
operator|-
name|sc
operator|->
name|sc_bcnt
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|printd
argument_list|(
literal|"idcdgo, ubinfo 0x%x, cmd 0x%x\n"
argument_list|,
name|um
operator|->
name|um_ubinfo
argument_list|,
name|um
operator|->
name|um_cmd
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|um
operator|->
name|um_cmd
expr_stmt|;
name|trace
argument_list|(
literal|"go"
argument_list|,
name|um
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
comment|/*** CLEAR SPURIOUS ATTN ON R80? ***/
block|}
end_block

begin_macro
name|idcintr
argument_list|(
argument|idc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|idc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|idcminfo
index|[
name|idc
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|idcdevice
modifier|*
name|idcaddr
init|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|idc_softc
modifier|*
name|sc
init|=
operator|&
name|idc_softc
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|as
decl_stmt|,
name|er
decl_stmt|,
name|cmd
decl_stmt|,
name|ds
init|=
literal|0
decl_stmt|;
name|printd
argument_list|(
literal|"idcintr, idccsr 0x%x"
argument_list|,
name|idcaddr
operator|->
name|idccsr
argument_list|)
expr_stmt|;
name|top
label|:
name|idcwticks
operator|=
literal|0
expr_stmt|;
name|trace
argument_list|(
literal|"intr"
argument_list|,
name|um
operator|->
name|um_tab
operator|.
name|b_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|2
condition|)
block|{
comment|/* 		 * Process a data transfer complete interrupt. 		 */
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|ui
operator|=
name|idcdinfo
index|[
name|idcunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|st
operator|=
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_CRDY
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|er
operator|=
name|idcaddr
operator|->
name|idccsr
operator|)
operator|&
name|IDC_ERR
condition|)
block|{
if|if
condition|(
name|er
operator|&
name|IDC_DE
condition|)
block|{
name|idcaddr
operator|->
name|idcmpr
operator|=
name|IDCGS_GETSTAT
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_GETSTAT
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ds
operator|=
name|idcaddr
operator|->
name|idcmpr
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_CRDY
operator||
operator|(
literal|1
operator|<<
operator|(
name|unit
operator|+
literal|16
operator|)
operator|)
expr_stmt|;
block|}
name|printd
argument_list|(
literal|", er 0x%x, ds 0x%x"
argument_list|,
name|er
argument_list|,
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|IDCDS_WL
condition|)
block|{
name|printf
argument_list|(
literal|"rb%d: write locked\n"
argument_list|,
name|idcunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|>
literal|28
operator|||
name|er
operator|&
name|IDC_HARD
condition|)
block|{
name|hard
label|:
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"rb"
argument_list|,
literal|"hard error"
argument_list|,
name|LOG_PRINTF
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" csr=%b ds=%b\n"
argument_list|,
name|er
argument_list|,
name|IDCCSR_BITS
argument_list|,
name|ds
argument_list|,
name|ui
operator|->
name|ui_type
condition|?
name|IDCRB80DS_BITS
else|:
name|IDCRB02DS_BITS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|er
operator|&
name|IDC_DCK
condition|)
block|{
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|er
operator|&
name|IDC_ECS
argument_list|)
condition|)
block|{
case|case
name|IDC_ECS_NONE
case|:
break|break;
case|case
name|IDC_ECS_SOFT
case|:
name|idcecc
argument_list|(
name|ui
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDC_ECS_HARD
case|:
default|default:
goto|goto
name|hard
goto|;
block|}
block|}
else|else
comment|/* recoverable error, set up for retry */
goto|goto
name|seek
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_resid
operator|-=
name|sc
operator|->
name|sc_bcnt
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ubaddr
operator|+=
name|sc
operator|->
name|sc_bcnt
expr_stmt|;
comment|/* 			 * Current transfer is complete, have 			 * we overflowed to the next track? 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_sect
operator|+=
name|sc
operator|->
name|sc_bcnt
operator|/
name|st
operator|->
name|nbps
operator|)
operator|==
name|st
operator|->
name|nsect
condition|)
block|{
name|sc
operator|->
name|sc_sect
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_trk
operator|==
name|st
operator|->
name|ntrak
condition|)
block|{
name|sc
operator|->
name|sc_trk
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_cyl
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ui
operator|->
name|ui_type
condition|)
block|{
comment|/* 					 * RB80 can change heads just by 					 * loading the disk address register. 					 */
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_SEEK
operator||
name|IDC_CRDY
operator||
name|IDC_IE
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
name|printd
argument_list|(
literal|", change to track 0x%x"
argument_list|,
name|sc
operator|->
name|sc_dar
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_sect
operator|=
literal|0
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
comment|/* 				 * Changing tracks on RB02 or cylinders 				 * on RB80, start a seek. 				 */
name|seek
label|:
name|cmd
operator|=
name|IDC_IE
operator||
name|IDC_SEEK
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|cmd
operator||
name|IDC_CRDY
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|printd
argument_list|(
literal|", seek to 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dar
argument_list|)
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_dar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|idccyl
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|dar_sect
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bcnt
operator|=
literal|0
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_type
condition|)
block|{
if|if
condition|(
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|idcaddr
operator|->
name|idccsr
operator|&=
operator|~
name|IDC_ATTN
expr_stmt|;
if|if
condition|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
condition|)
goto|goto
name|top
goto|;
block|}
block|}
else|else
block|{
comment|/* 				 * Continue transfer on current track. 				 */
name|cont
label|:
name|sc
operator|->
name|sc_bcnt
operator|=
operator|(
name|st
operator|->
name|nsect
operator|-
name|sc
operator|->
name|sc_sect
operator|)
operator|*
name|st
operator|->
name|nbps
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bcnt
operator|>
name|sc
operator|->
name|sc_resid
condition|)
name|sc
operator|->
name|sc_bcnt
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|cmd
operator|=
name|IDC_IE
operator||
name|IDC_READ
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
else|else
name|cmd
operator|=
name|IDC_IE
operator||
name|IDC_WRITE
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|cmd
operator||
name|IDC_CRDY
expr_stmt|;
name|idcaddr
operator|->
name|idcbar
operator|=
name|sc
operator|->
name|sc_ubaddr
expr_stmt|;
name|idcaddr
operator|->
name|idcbcr
operator|=
operator|-
name|sc
operator|->
name|sc_bcnt
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|sc
operator|->
name|sc_dar
expr_stmt|;
name|printd
argument_list|(
literal|", continue I/O 0x%x, 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_dar
argument_list|,
name|sc
operator|->
name|sc_bcnt
argument_list|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|cmd
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
block|}
return|return;
block|}
comment|/* 		 * Entire transfer is done, clean up. 		 */
name|ubadone
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ui
operator|->
name|ui_dk
operator|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|trace
argument_list|(
literal|"done"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|trace
argument_list|(
operator|&
name|um
operator|->
name|um_tab
operator|.
name|b_actf
argument_list|,
name|dp
operator|->
name|b_actf
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
name|printd
argument_list|(
literal|", iodone, resid 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
if|if
condition|(
name|idcustart
argument_list|(
name|ui
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Got an interrupt while setting up for a command 		 * or doing a mid-transfer seek.  Save any attentions 		 * for later and process a mid-transfer seek complete. 		 */
name|as
operator|=
name|idcaddr
operator|->
name|idccsr
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_CRDY
operator||
operator|(
name|as
operator|&
name|IDC_ATTN
operator|)
expr_stmt|;
name|as
operator|=
operator|(
name|as
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|sc
operator|->
name|sc_softas
operator||=
name|as
operator|&
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
if|if
condition|(
name|as
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|printd
argument_list|(
literal|", seek1 complete"
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|printd
argument_list|(
literal|", as1 %o\n"
argument_list|,
name|as
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process any seek initiated or complete interrupts. 	 */
name|as
operator|=
name|idcaddr
operator|->
name|idccsr
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_CRDY
operator||
operator|(
name|as
operator|&
name|IDC_ATTN
operator|)
expr_stmt|;
name|as
operator|=
operator|(
operator|(
name|as
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator||
name|sc
operator|->
name|sc_softas
expr_stmt|;
name|sc
operator|->
name|sc_softas
operator|=
literal|0
expr_stmt|;
name|trace
argument_list|(
literal|"as"
argument_list|,
name|as
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|", as %o"
argument_list|,
name|as
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NRB
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|as
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|as
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_IE
operator||
name|IDC_CRDY
operator||
operator|(
name|unit
operator|<<
literal|8
operator|)
expr_stmt|;
name|ui
operator|=
name|idcdinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ui
condition|)
block|{
name|printd
argument_list|(
literal|", attn unit %d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
condition|)
if|if
condition|(
name|idcustart
argument_list|(
name|ui
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_softas
operator|=
name|as
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|printd
argument_list|(
literal|", unsol. intr. unit %d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
name|printd
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|&&
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
block|{
name|trace
argument_list|(
literal|"stum"
argument_list|,
name|um
operator|->
name|um_tab
operator|.
name|b_actf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|idcstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|idcwait
argument_list|(
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|idcdevice
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|&&
operator|(
name|addr
operator|->
name|idccsr
operator|&
name|IDC_CRDY
operator|)
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
condition|;
name|i
operator|--
control|)
empty_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|idcecc
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|idcdevice
modifier|*
name|idc
init|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|idcutab
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|ui
operator|->
name|ui_mi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|uba_regs
modifier|*
name|ubp
init|=
name|ui
operator|->
name|ui_hd
operator|->
name|uh_uba
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|byte
decl_stmt|,
name|mask
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|npf
decl_stmt|,
name|o
decl_stmt|;
name|npf
operator|=
name|btop
argument_list|(
name|idc
operator|->
name|idcbcr
operator|+
name|idc_softc
operator|.
name|sc_bcnt
argument_list|)
operator|-
literal|1
expr_stmt|;
empty_stmt|;
name|reg
operator|=
name|btop
argument_list|(
name|idc_softc
operator|.
name|sc_ubaddr
argument_list|)
operator|+
name|npf
expr_stmt|;
name|o
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
name|PGOFSET
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* Either complete or continuing... */
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"rb"
argument_list|,
literal|"soft ecc"
argument_list|,
name|LOG_WARNING
argument_list|,
name|npf
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|addlog
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|idc
operator|->
name|idceccpat
expr_stmt|;
name|i
operator|=
name|idc
operator|->
name|idceccpos
operator|-
literal|1
expr_stmt|;
comment|/* -1 makes 0 origin */
name|bit
operator|=
name|i
operator|&
literal|07
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|&
operator|~
literal|07
operator|)
operator|>>
literal|3
expr_stmt|;
name|byte
operator|=
name|i
operator|+
name|o
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|512
operator|&&
operator|(
name|int
operator|)
name|ptob
argument_list|(
name|npf
argument_list|)
operator|+
name|i
operator|<
name|idc_softc
operator|.
name|sc_bcnt
operator|&&
name|bit
operator|>
operator|-
literal|11
condition|)
block|{
comment|/* 		 * should be: 		 *	addr = ptob(ubp->uba_map[reg+btop(byte)].pg_pfnum)+ 		 *		(byte& PGOFSET); 		 * but this generates an extzv which hangs the UNIBUS. 		 */
name|addr
operator|=
name|ptob
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|ubp
operator|->
name|uba_map
index|[
name|reg
operator|+
name|btop
argument_list|(
name|byte
argument_list|)
index|]
operator|&
literal|0x1fffff
argument_list|)
operator|+
operator|(
name|byte
operator|&
name|PGOFSET
operator|)
expr_stmt|;
name|putmemc
argument_list|(
name|addr
argument_list|,
name|getmemc
argument_list|(
name|addr
argument_list|)
operator|^
operator|(
name|mask
operator|<<
name|bit
operator|)
argument_list|)
expr_stmt|;
name|byte
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|bit
operator|-=
literal|8
expr_stmt|;
block|}
name|idc_softc
operator|.
name|sc_bcnt
operator|+=
name|idc
operator|->
name|idcbcr
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* error has been corrected */
return|return;
block|}
end_block

begin_macro
name|idcreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
if|if
condition|(
operator|(
name|um
operator|=
name|idcminfo
index|[
literal|0
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|" idc0"
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_ubinfo
condition|)
block|{
name|printf
argument_list|(
literal|"<%d>"
argument_list|,
operator|(
name|um
operator|->
name|um_ubinfo
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_ubinfo
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NRB
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|idcdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|idcutab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|idcustart
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|idcstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|idcwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
name|timeout
argument_list|(
name|idcwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|um
operator|=
name|idcminfo
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|um
operator|==
literal|0
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NRB
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|idcutab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
goto|goto
name|active
goto|;
name|idcwticks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|active
label|:
name|idcwticks
operator|++
expr_stmt|;
if|if
condition|(
name|idcwticks
operator|>=
literal|20
condition|)
block|{
name|idcwticks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"idc0: lost interrupt\n"
argument_list|)
expr_stmt|;
name|idcintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|idcdump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|idcdevice
modifier|*
name|idcaddr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|num
decl_stmt|,
name|blk
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|size
modifier|*
name|sizes
decl_stmt|;
specifier|register
name|struct
name|uba_regs
modifier|*
name|uba
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
name|union
name|idc_dar
name|dar
decl_stmt|;
name|int
name|nspg
decl_stmt|;
name|unit
operator|=
name|idcunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRB
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
define|#
directive|define
name|phys
parameter_list|(
name|cast
parameter_list|,
name|addr
parameter_list|)
value|((cast)((int)addr& 0x7fffffff))
name|ui
operator|=
name|phys
argument_list|(
expr|struct
name|uba_device
operator|*
argument_list|,
name|idcdinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|uba
operator|=
name|phys
argument_list|(
expr|struct
name|uba_hd
operator|*
argument_list|,
name|ui
operator|->
name|ui_hd
argument_list|)
operator|->
name|uh_physuba
expr_stmt|;
name|ubainit
argument_list|(
name|uba
argument_list|)
expr_stmt|;
name|idcaddr
operator|=
operator|(
expr|struct
name|idcdevice
operator|*
operator|)
name|ui
operator|->
name|ui_physaddr
expr_stmt|;
if|if
condition|(
name|idcwait
argument_list|(
name|idcaddr
argument_list|,
literal|100
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Since we can only transfer one track at a time, and 	 * the rl02 has 256 byte sectors, all the calculations 	 * are done in terms of physical sectors (i.e. num and blk 	 * are in sectors not NBPG blocks. 	 */
name|st
operator|=
name|phys
argument_list|(
expr|struct
name|idcst
operator|*
argument_list|,
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
argument_list|)
expr_stmt|;
name|sizes
operator|=
name|phys
argument_list|(
expr|struct
name|size
operator|*
argument_list|,
name|st
operator|->
name|sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumplo
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dumplo
operator|+
name|maxfree
operator|>=
name|sizes
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|07
index|]
operator|.
name|nblocks
condition|)
name|num
operator|=
name|sizes
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|07
index|]
operator|.
name|nblocks
operator|-
name|dumplo
expr_stmt|;
name|nspg
operator|=
name|NBPG
operator|/
name|st
operator|->
name|nbps
expr_stmt|;
name|num
operator|=
name|num
operator|*
name|nspg
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|pte
modifier|*
name|io
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|bn
operator|=
operator|(
name|dumplo
operator|+
name|btop
argument_list|(
name|start
argument_list|)
operator|)
operator|*
name|nspg
expr_stmt|;
name|dar
operator|.
name|dar_cyl
operator|=
name|bn
operator|/
name|st
operator|->
name|nspc
operator|+
name|sizes
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|07
index|]
operator|.
name|cyloff
expr_stmt|;
name|bn
operator|%=
name|st
operator|->
name|nspc
expr_stmt|;
name|dar
operator|.
name|dar_trk
operator|=
name|bn
operator|/
name|st
operator|->
name|nsect
expr_stmt|;
name|dar
operator|.
name|dar_sect
operator|=
name|bn
operator|%
name|st
operator|->
name|nsect
expr_stmt|;
name|blk
operator|=
name|st
operator|->
name|nsect
operator|-
name|dar
operator|.
name|dar_sect
expr_stmt|;
if|if
condition|(
name|num
operator|<
name|blk
condition|)
name|blk
operator|=
name|num
expr_stmt|;
name|io
operator|=
name|uba
operator|->
name|uba_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|blk
operator|+
name|nspg
operator|-
literal|1
operator|)
operator|/
name|nspg
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
operator|(
name|btop
argument_list|(
name|start
argument_list|)
operator|+
name|i
operator|)
operator||
operator|(
literal|1
operator|<<
literal|21
operator|)
operator||
name|UBAMR_MRV
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|=
literal|0
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|IDC_SEEK
operator||
name|unit
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|dar
operator|.
name|dar_dar
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_SEEK
operator||
name|unit
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
operator|(
name|IDC_CRDY
operator||
name|IDC_DRDY
operator|)
operator|)
operator|!=
operator|(
name|IDC_CRDY
operator||
name|IDC_DRDY
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"rb%d: seek, csr=%b\n"
argument_list|,
name|unit
argument_list|,
name|idcaddr
operator|->
name|idccsr
argument_list|,
name|IDCCSR_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_CRDY
operator||
name|IDC_WRITE
operator||
name|unit
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_DRDY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|idcaddr
operator|->
name|idcbar
operator|=
literal|0
expr_stmt|;
comment|/* start addr 0 */
name|idcaddr
operator|->
name|idcbcr
operator|=
operator|-
operator|(
name|blk
operator|*
name|st
operator|->
name|nbps
operator|)
expr_stmt|;
name|idcaddr
operator|->
name|idcdar
operator|=
name|dar
operator|.
name|dar_dar
expr_stmt|;
name|idcaddr
operator|->
name|idccsr
operator|=
name|IDC_WRITE
operator||
name|unit
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
operator|(
name|idcaddr
operator|->
name|idccsr
operator|&
operator|(
name|IDC_CRDY
operator||
name|IDC_DRDY
operator|)
operator|)
operator|!=
operator|(
name|IDC_CRDY
operator||
name|IDC_DRDY
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|idcaddr
operator|->
name|idccsr
operator|&
name|IDC_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"rb%d: write, csr=%b\n"
argument_list|,
name|unit
argument_list|,
name|idcaddr
operator|->
name|idccsr
argument_list|,
name|IDCCSR_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|start
operator|+=
name|blk
operator|*
name|st
operator|->
name|nbps
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|idcsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|idcunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|idcst
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRB
operator|||
operator|(
name|ui
operator|=
name|idcdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|st
operator|=
operator|&
name|idcst
index|[
name|ui
operator|->
name|ui_type
index|]
expr_stmt|;
return|return
operator|(
name|st
operator|->
name|sizes
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|07
index|]
operator|.
name|nblocks
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

