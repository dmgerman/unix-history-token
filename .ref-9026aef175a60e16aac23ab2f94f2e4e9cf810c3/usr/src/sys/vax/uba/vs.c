begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)vs.c	7.8 (MIT) %G% */
end_comment

begin_comment
comment|/****************************************************************************  *									    *  *  Copyright (c) 1983, 1984 by						    *  *  DIGITAL EQUIPMENT CORPORATION, Maynard, Massachusetts.		    *  *  All rights reserved.						    *  * 									    *  *  This software is furnished on an as-is basis and may be used and copied *  *  only with inclusion of the above copyright notice. This software or any *  *  other copies thereof may be provided or otherwise made available to     *  *  others only for non-commercial purposes.  No title to or ownership of   *  *  the software is hereby transferred.					    *  * 									    *  *  The information in this software is  subject to change without notice   *  *  and  should  not  be  construed as  a commitment by DIGITAL EQUIPMENT   *  *  CORPORATION.							    *  * 									    *  *  DIGITAL assumes no responsibility for the use  or  reliability of its   *  *  software on equipment which is not supplied by DIGITAL.		    *  * 									    *  *									    *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"vs.h"
end_include

begin_if
if|#
directive|if
name|NVS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/user.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/map.h"
end_include

begin_include
include|#
directive|include
file|"sys/kernel.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"vsio.h"
end_include

begin_include
include|#
directive|include
file|"sys/proc.h"
end_include

begin_include
include|#
directive|include
file|"sys/uio.h"
end_include

begin_include
include|#
directive|include
file|"sys/vmmac.h"
end_include

begin_include
include|#
directive|include
file|"sys/file.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_include
include|#
directive|include
file|"vsreg.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_define
define|#
directive|define
name|VSWAITPRI
value|(PZERO+1)
end_define

begin_define
define|#
directive|define
name|VSMAXEVQ
value|64
end_define

begin_comment
comment|/* must be power of 2 */
end_comment

begin_define
define|#
directive|define
name|EVROUND
parameter_list|(
name|x
parameter_list|)
value|((x)& (VSMAXEVQ - 1))
end_define

begin_define
define|#
directive|define
name|VSBUFFSIZE
value|3072
end_define

begin_struct
struct|struct
name|vsBuffArea
block|{
name|vsIoAddr
name|vsioa
decl_stmt|;
name|char
name|obuff
index|[
name|VSBUFFSIZE
index|]
decl_stmt|;
name|vsEvent
name|ibuff
index|[
name|VSMAXEVQ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|vsBuffArea
name|vsBuff
index|[
name|NVS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vsprobe
argument_list|()
decl_stmt|,
name|vsattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|vsdinfo
index|[
name|NVS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|vsstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|vsdriver
init|=
block|{
name|vsprobe
block|,
literal|0
block|,
name|vsattach
block|,
literal|0
block|,
name|vsstd
block|,
literal|"vs"
block|,
name|vsdinfo
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VSUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev))
end_define

begin_struct
struct|struct
name|vs_softc
block|{
name|unsigned
name|inited
range|:
literal|1
decl_stmt|;
comment|/* has this ever been inited? */
name|unsigned
name|open
range|:
literal|1
decl_stmt|;
comment|/* only one open, please */
name|unsigned
name|linkAvail
range|:
literal|1
decl_stmt|;
comment|/* link is up */
name|short
name|pgrp
decl_stmt|;
comment|/* process group for SIGHUP */
name|int
name|romVersion
decl_stmt|;
comment|/* rom version */
name|struct
name|vs_fparm
name|offset
decl_stmt|;
comment|/* address base */
name|struct
name|vs_csr
name|csr
decl_stmt|;
comment|/* saved csr0 */
name|struct
name|vs_intr
name|irr
decl_stmt|;
comment|/* saved interrupt reason */
name|struct
name|vs_kbd
name|krr
decl_stmt|;
comment|/* saved keyboard */
name|struct
name|vs_fparm
name|pr
decl_stmt|;
comment|/* saved parameter regs */
name|struct
name|proc
modifier|*
name|rsel
decl_stmt|;
comment|/* process waiting for select */
name|struct
name|vs_fparm
name|vs_nextgo
decl_stmt|;
comment|/* next packet to go */
name|short
name|vs_status
decl_stmt|;
comment|/* status from previous packet */
name|vsStats
name|stats
decl_stmt|;
comment|/* statistics */
name|int
name|vsBuff_ubinfo
decl_stmt|;
comment|/* ubinfo for vsBuff */
block|}
name|vs_softc
index|[
name|NVS
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|printI
value|if (vsIntrPrintfs)printf
end_define

begin_define
define|#
directive|define
name|printD
value|if (vsDebugPrintfs)printf
end_define

begin_define
define|#
directive|define
name|printM
value|if (vsMlpPrintfs) vsMlpPrintfs--,printf
end_define

begin_decl_stmt
name|int
name|vsIntrPrintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vsDebugPrintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vsMlpPrintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Tell the system that it's out there, and set up the device's interrupt  * vector. Since we are supporting vs100s and vs125s,  * this is a bit kludgey. The vs100 works much  * as one expects, but the vs125 tries to set all the fiber link  * related bits when you hit VS_IE, ignoring the way the 100 works.  * Also, the vs100 will let you set the interrupt vector, but  * the vs125 ignores this and uses its hard-wired value.  * And there's no sure fire to tell which variant it is.  * Ugh. Ugh. Ugh.  */
end_comment

begin_macro
name|vsprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value-result */
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
init|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vsintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x15
expr_stmt|;
name|cvec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|*
literal|8
operator|)
expr_stmt|;
comment|/*  	 * uh_lastiv is the last free interrupt vector in the 	 * unibus addapter header (uba_hd). 	 */
name|vsaddr
operator|->
name|vs_csr0
operator|=
name|cvec
operator|>>
literal|2
expr_stmt|;
comment|/* Save the vector for use on next device */
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
comment|/* Csr will only be read if irr == 0 */
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
comment|/* Clear interrupt reason register */
name|vsaddr
operator|->
name|vs_pr1
operator|=
literal|0
expr_stmt|;
comment|/* Clear function parameter */
name|vsaddr
operator|->
name|vs_pr2
operator|=
literal|0
expr_stmt|;
comment|/* Clear function parameter */
name|vsaddr
operator|->
name|vs_ivr
operator|=
name|cvec
expr_stmt|;
comment|/* set up vector (no-op for vs125) */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsaddr
operator|->
name|vs_csr0
operator|&
name|VS_LNK_AVL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* light won't go off! */
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_LNK_TRNS
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
name|VS_IE
expr_stmt|;
comment|/* enable interrupts */
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|vsdevice
argument_list|)
return|;
block|}
end_block

begin_macro
name|vsattach
argument_list|(
argument|uip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|uip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
decl_stmt|;
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
decl_stmt|;
name|vsp
operator|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|uip
operator|->
name|ui_unit
argument_list|)
index|]
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
name|vsp
operator|->
name|open
operator|=
name|FALSE
expr_stmt|;
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|uip
operator|->
name|ui_unit
argument_list|)
index|]
operator|.
name|vsioa
operator|.
name|mbox
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|linkAvail
operator|=
name|FALSE
expr_stmt|;
name|vsp
operator|->
name|romVersion
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|=
name|NULL
expr_stmt|;
name|vsaddr
operator|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|uip
operator|->
name|ui_addr
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
name|VS_XMIT_ON
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|vsopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|uip
decl_stmt|;
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|buf
name|vsbuf
decl_stmt|;
name|struct
name|vsBuffArea
modifier|*
name|vsb
decl_stmt|;
name|caddr_t
name|vsBuffpage
decl_stmt|;
name|int
name|vsBuffnpages
decl_stmt|;
if|if
condition|(
name|VSUNIT
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVS
operator|||
operator|(
name|vsp
operator|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|)
operator|->
name|open
operator|||
operator|(
name|uip
operator|=
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|)
operator|==
literal|0
operator|||
name|uip
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vsaddr
operator|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|uip
operator|->
name|ui_addr
expr_stmt|;
name|vsb
operator|=
operator|&
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|printM
argument_list|(
literal|"vsopen csr0=%x, csr1=%x, csr2=%x, csr3=%x, csr4=%x, csr5=%x, csr6=%x, csr7=%x\n"
argument_list|,
name|vsaddr
operator|->
name|vs_csr0
argument_list|,
name|vsaddr
operator|->
name|vs_csr1
argument_list|,
name|vsaddr
operator|->
name|vs_csr2
argument_list|,
name|vsaddr
operator|->
name|vs_csr3
argument_list|,
name|vsaddr
operator|->
name|vs_csr4
argument_list|,
name|vsaddr
operator|->
name|vs_csr5
argument_list|,
name|vsaddr
operator|->
name|vs_csr6
argument_list|,
name|vsaddr
operator|->
name|vs_csr7
argument_list|)
expr_stmt|;
comment|/*  	 * Finally! We can now set up the device. 	 */
if|if
condition|(
operator|!
name|vsp
operator|->
name|inited
operator|&&
operator|!
operator|(
name|flag
operator|&
name|FNDELAY
operator|)
condition|)
block|{
name|ret
operator|=
name|vsInitDev
argument_list|(
name|dev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ret
operator|=
name|vsError
argument_list|(
name|vsp
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|vsp
operator|->
name|open
operator|=
name|TRUE
expr_stmt|;
comment|/* we're open */
name|vsp
operator|->
name|pgrp
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pgrp
expr_stmt|;
comment|/* reset statistics */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vsp
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|vsStats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize user I/O addresses */
name|vsb
operator|->
name|vsioa
operator|.
name|ioreg
operator|=
operator|(
name|short
operator|*
operator|)
name|vsaddr
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|obuff
operator|=
name|vsb
operator|->
name|obuff
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|obufflen
operator|=
name|VSBUFFSIZE
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|ibuff
operator|=
name|vsb
operator|->
name|ibuff
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|=
literal|0
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|=
literal|0
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|iqsize
operator|=
name|VSMAXEVQ
expr_stmt|;
comment|/* map io regs into user address space (assume they don't cross a page) */
name|maptouser
argument_list|(
name|vsaddr
argument_list|)
expr_stmt|;
comment|/* map vsBuff into user address space */
name|vsBuffpage
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|vsb
operator|&
operator|~
name|PGOFSET
argument_list|)
expr_stmt|;
name|vsBuffnpages
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|vsb
operator|&
name|PGOFSET
operator|)
operator|+
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vsBuffArea
argument_list|)
operator|)
operator|>>
name|PGSHIFT
expr_stmt|;
while|while
condition|(
name|vsBuffnpages
operator|>
literal|0
condition|)
block|{
name|maptouser
argument_list|(
name|vsBuffpage
argument_list|)
expr_stmt|;
name|vsBuffpage
operator|+=
name|NBPG
expr_stmt|;
name|vsBuffnpages
operator|--
expr_stmt|;
block|}
comment|/* lock in the buffer */
name|vsbuf
operator|.
name|b_error
operator|=
literal|0
expr_stmt|;
name|vsbuf
operator|.
name|b_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|vsbuf
operator|.
name|b_un
operator|.
name|b_addr
operator|=
name|vsb
operator|->
name|obuff
expr_stmt|;
name|vsbuf
operator|.
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
name|vsbuf
operator|.
name|b_bcount
operator|=
name|VSBUFFSIZE
expr_stmt|;
name|vsp
operator|->
name|vsBuff_ubinfo
operator|=
name|ubasetup
argument_list|(
name|uip
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|vsbuf
argument_list|,
name|UBA_CANTWAIT
argument_list|)
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|reloc
operator|=
call|(
name|int
call|)
argument_list|(
name|vsp
operator|->
name|offset
operator|.
name|fparm_all
operator|+
name|UBAI_ADDR
argument_list|(
name|vsp
operator|->
name|vsBuff_ubinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vsclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|uip
init|=
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
init|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|vsdevice
modifier|*
name|vsaddr
decl_stmt|;
name|struct
name|vsBuffArea
modifier|*
name|vsb
decl_stmt|;
name|caddr_t
name|vsBuffpage
decl_stmt|;
name|int
name|vsBuffnpages
decl_stmt|;
name|vsaddr
operator|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|uip
operator|->
name|ui_addr
expr_stmt|;
name|printM
argument_list|(
literal|"vsclose csr0=%x, csr1=%x, csr2=%x, csr3=%x, csr4=%x, csr5=%x, csr6=%x, csr7=%x\n"
argument_list|,
name|vsaddr
operator|->
name|vs_csr0
argument_list|,
name|vsaddr
operator|->
name|vs_csr1
argument_list|,
name|vsaddr
operator|->
name|vs_csr2
argument_list|,
name|vsaddr
operator|->
name|vs_csr3
argument_list|,
name|vsaddr
operator|->
name|vs_csr4
argument_list|,
name|vsaddr
operator|->
name|vs_csr5
argument_list|,
name|vsaddr
operator|->
name|vs_csr6
argument_list|,
name|vsaddr
operator|->
name|vs_csr7
argument_list|)
expr_stmt|;
name|vsb
operator|=
operator|&
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|vsDebugPrintfs
condition|)
block|{
name|printf
argument_list|(
literal|"vs%d: %d errors, %d unsolicited interrupts"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|vsp
operator|->
name|stats
operator|.
name|errors
argument_list|,
name|vsp
operator|->
name|stats
operator|.
name|unsolIntr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d link errors"
argument_list|,
name|vsp
operator|->
name|stats
operator|.
name|linkErrors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d overruns"
argument_list|,
name|vsp
operator|->
name|stats
operator|.
name|overruns
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", csr0 %x, csr1 %x"
argument_list|,
name|vsaddr
operator|->
name|vs_csr0
argument_list|,
name|vsaddr
operator|->
name|vs_csr1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|vsp
operator|->
name|open
operator|=
name|FALSE
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
comment|/* init on every open */
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|=
name|NULL
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
comment|/* release the buffer */
if|if
condition|(
name|vsp
operator|->
name|vsBuff_ubinfo
operator|!=
literal|0
condition|)
block|{
name|ubarelse
argument_list|(
name|uip
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|vsp
operator|->
name|vsBuff_ubinfo
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* unmap io regs into user address space (assume they don't cross a page) */
name|unmaptouser
argument_list|(
name|vsaddr
argument_list|)
expr_stmt|;
comment|/* unmap vsBuff into user address space */
name|vsBuffpage
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|vsb
operator|&
operator|~
name|PGOFSET
argument_list|)
expr_stmt|;
name|vsBuffnpages
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|vsb
operator|&
name|PGOFSET
operator|)
operator|+
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vsBuffArea
argument_list|)
operator|)
operator|>>
name|PGSHIFT
expr_stmt|;
while|while
condition|(
name|vsBuffnpages
operator|>
literal|0
condition|)
block|{
name|unmaptouser
argument_list|(
name|vsBuffpage
argument_list|)
expr_stmt|;
name|vsBuffpage
operator|+=
name|NBPG
expr_stmt|;
name|vsBuffnpages
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vsread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|vswrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vsioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|uip
init|=
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
init|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
init|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|uip
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|vsBuffArea
modifier|*
name|vsb
init|=
operator|&
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|vs_fparm
name|vsAddr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|func
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* things that don't need the device */
case|case
name|VSIOWAITGO
case|:
comment|/* wait for user I/O operation to complete, then go */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|)
operator|==
literal|0
condition|)
block|{
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|=
operator|(
operator|(
expr|struct
name|vs_fparm
operator|*
operator|)
name|addr
operator|)
operator|->
name|fparm_all
expr_stmt|;
do|do
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|&&
name|error
operator|==
literal|0
condition|)
do|;
name|ret
operator|=
name|vsp
operator|->
name|vs_status
expr_stmt|;
block|}
else|else
block|{
name|vsaddr
operator|->
name|vs_pr1
operator|=
operator|(
operator|(
expr|struct
name|vs_fparm
operator|*
operator|)
name|addr
operator|)
operator|->
name|fparm_low
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr2
operator|=
operator|(
operator|(
expr|struct
name|vs_fparm
operator|*
operator|)
name|addr
operator|)
operator|->
name|fparm_high
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
comment|/* clear bits */
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_SEND
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ret
operator|&
name|VS_ERROR
condition|)
return|return
operator|(
operator|(
name|ret
operator|&
name|VS_REASON
operator|)
operator|+
literal|128
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VSIOUSERWAIT
case|:
comment|/* wait for user I/O operation to complete */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|VSIOGETVER
case|:
comment|/* get ROM version */
if|if
condition|(
operator|!
name|vsp
operator|->
name|inited
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|vsp
operator|->
name|romVersion
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VSIOGETSTATS
case|:
comment|/* get statistics block */
operator|*
operator|(
name|vsStats
operator|*
operator|)
name|addr
operator|=
name|vsp
operator|->
name|stats
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VSIOGETIOA
case|:
comment|/* get io addresses */
if|if
condition|(
name|vsp
operator|->
name|vsBuff_ubinfo
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
operator|*
operator|(
operator|(
name|vsIoAddrAddr
operator|*
operator|)
name|addr
operator|)
operator|=
operator|&
name|vsb
operator|->
name|vsioa
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* a command that could block */
if|if
condition|(
name|ret
operator|=
name|vsError
argument_list|(
name|vsp
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Commands that cause an interrupt */
case|case
name|VSIOINIT
case|:
comment|/* initialize device */
name|vsInitDev
argument_list|(
name|dev
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOSTART
case|:
comment|/* start microcode */
name|vsAddr
operator|.
name|fparm_all
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|addr
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr1
operator|=
name|vsAddr
operator|.
name|fparm_low
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr2
operator|=
name|vsAddr
operator|.
name|fparm_high
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
comment|/* clear bits */
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_START
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
comment|/* synchronous */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOABORT
case|:
comment|/* abort a command chain */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_ABORT
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOPWRUP
case|:
comment|/* power-up reset */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_PWRUP
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOBBACTL
case|:
comment|/* enable/disable BBA */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
name|func
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|==
name|VSIO_ON
condition|?
name|VS_ENABBA
else|:
name|VS_DISBBA
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|func
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOFIBCTL
case|:
comment|/* turn the fiber lamp on/off */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|==
name|VSIO_OFF
condition|)
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_XMIT_ON
expr_stmt|;
else|else
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
name|VS_XMIT_ON
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOFIBRETRY
case|:
comment|/* set fiber retries */
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
name|func
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|==
name|VS_FIB_FINITE
condition|?
name|VS_FINITE
else|:
name|VS_INFINITE
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|func
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|vsError
argument_list|(
name|vsp
argument_list|)
operator|)
return|;
case|case
name|VSIOSYNC
case|:
comment|/* get synchronized with device */
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vsintr
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
decl_stmt|;
specifier|register
name|vsEvent
modifier|*
name|vep
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|uip
decl_stmt|;
specifier|register
name|struct
name|vsBuffArea
modifier|*
name|vsb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vsCursor
name|cur
decl_stmt|;
if|if
condition|(
name|VSUNIT
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVS
operator|||
operator|(
name|uip
operator|=
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|)
operator|==
literal|0
operator|||
name|uip
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|printI
argument_list|(
literal|"vs%d stray interrupt\n"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|vsaddr
operator|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|uip
operator|->
name|ui_addr
expr_stmt|;
name|vsp
operator|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|vsb
operator|=
operator|&
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|printM
argument_list|(
literal|"vsintr csr0=%x, csr1=%x, csr2=%x, csr3=%x, csr4=%x, csr5=%x, csr6=%x, csr7=%x\n"
argument_list|,
name|vsaddr
operator|->
name|vs_csr0
argument_list|,
name|vsaddr
operator|->
name|vs_csr1
argument_list|,
name|vsaddr
operator|->
name|vs_csr2
argument_list|,
name|vsaddr
operator|->
name|vs_csr3
argument_list|,
name|vsaddr
operator|->
name|vs_csr4
argument_list|,
name|vsaddr
operator|->
name|vs_csr5
argument_list|,
name|vsaddr
operator|->
name|vs_csr6
argument_list|,
name|vsaddr
operator|->
name|vs_csr7
argument_list|)
expr_stmt|;
name|printI
argument_list|(
literal|"vs%dintr "
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * get the information out of the soft registers 	 */
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
operator|=
name|vsaddr
operator|->
name|vs_irr
expr_stmt|;
name|vsp
operator|->
name|krr
operator|.
name|kbd_reg
operator|=
name|vsaddr
operator|->
name|vs_krr
expr_stmt|;
name|vsp
operator|->
name|pr
operator|.
name|fparm_low
operator|=
name|vsaddr
operator|->
name|vs_pr1
expr_stmt|;
name|vsp
operator|->
name|pr
operator|.
name|fparm_high
operator|=
name|vsaddr
operator|->
name|vs_pr2
expr_stmt|;
name|cur
operator|.
name|x
operator|=
name|vsaddr
operator|->
name|vs_cxr
expr_stmt|;
name|cur
operator|.
name|y
operator|=
name|vsaddr
operator|->
name|vs_cyr
expr_stmt|;
name|vsp
operator|->
name|csr
operator|.
name|csr_reg
operator|=
name|vsaddr
operator|->
name|vs_csr0
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|irr
operator|.
name|intr_reason
condition|)
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
comment|/* clear int reason, if any */
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_OWN
expr_stmt|;
comment|/* clear owner bit */
if|if
condition|(
name|vsp
operator|->
name|csr
operator|.
name|csr_linkTran
condition|)
block|{
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_LNK_TRNS
expr_stmt|;
comment|/* clear the bit */
name|printI
argument_list|(
literal|"link transition: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|csr
operator|.
name|csr_linkErr
condition|)
name|vsp
operator|->
name|stats
operator|.
name|linkErrors
operator|++
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|csr
operator|.
name|csr_linkAvail
operator|==
name|vsp
operator|->
name|linkAvail
condition|)
block|{
comment|/* flash */
name|vsp
operator|->
name|stats
operator|.
name|flashes
operator|++
expr_stmt|;
name|printI
argument_list|(
literal|"flash\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vsp
operator|->
name|csr
operator|.
name|csr_linkAvail
operator|&&
name|vsp
operator|->
name|linkAvail
condition|)
block|{
comment|/* on -> off */
name|vsp
operator|->
name|stats
operator|.
name|douses
operator|++
expr_stmt|;
name|printI
argument_list|(
literal|"douse\n"
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|open
operator|&&
name|vsp
operator|->
name|pgrp
condition|)
name|gsignal
argument_list|(
name|vsp
operator|->
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* off -> on */
name|vsp
operator|->
name|stats
operator|.
name|ignites
operator|++
expr_stmt|;
name|printI
argument_list|(
literal|"ignite\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|200
expr_stmt|;
while|while
condition|(
operator|(
name|vsaddr
operator|->
name|vs_csr0
operator|&
name|VS_LNK_TRNS
operator|)
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* bit stuck */
name|printI
argument_list|(
literal|"vs%d: Link Transition bit stuck\n"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|open
operator|&&
name|vsp
operator|->
name|pgrp
condition|)
name|gsignal
argument_list|(
name|vsp
operator|->
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_XMIT_ON
expr_stmt|;
name|vsp
operator|->
name|csr
operator|.
name|csr_linkAvail
operator|=
name|FALSE
expr_stmt|;
block|}
name|vsp
operator|->
name|linkAvail
operator|=
name|vsp
operator|->
name|csr
operator|.
name|csr_linkAvail
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vsp
operator|->
name|irr
operator|.
name|intr_error
condition|)
block|{
name|printI
argument_list|(
literal|"error 0x%x\n"
argument_list|,
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|stats
operator|.
name|errors
operator|++
expr_stmt|;
comment|/* set status and wake up user if necessary */
if|if
condition|(
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
condition|)
block|{
name|vsp
operator|->
name|vs_status
operator|=
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr1
operator|=
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_low
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr2
operator|=
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_high
expr_stmt|;
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|=
name|NULL
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
comment|/* clear bits */
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_SEND
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
block|}
else|else
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|=
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notdef
name|printI
argument_list|(
literal|"reason is %b\n"
argument_list|,
name|vsp
operator|->
name|irr
operator|.
name|intr_reason
argument_list|,
name|VSIRR_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|vsp
operator|->
name|irr
operator|.
name|intr_reason
condition|)
block|{
case|case
name|VS_INT_CD
case|:
comment|/* command done */
comment|/* set status and start a new command if necessary */
if|if
condition|(
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
condition|)
block|{
name|vsp
operator|->
name|vs_status
operator|=
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr1
operator|=
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_low
expr_stmt|;
name|vsaddr
operator|->
name|vs_pr2
operator|=
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_high
expr_stmt|;
name|vsp
operator|->
name|vs_nextgo
operator|.
name|fparm_all
operator|=
name|NULL
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
comment|/* clear bits */
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_SEND
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
block|}
else|else
name|vsb
operator|->
name|vsioa
operator|.
name|status
operator|=
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
expr_stmt|;
break|break;
case|case
name|VS_INT_MM
case|:
comment|/* mouse moved */
name|vsb
operator|->
name|vsioa
operator|.
name|mouse
operator|=
name|cur
expr_stmt|;
if|if
condition|(
operator|!
name|vsp
operator|->
name|open
condition|)
return|return;
comment|/* ignore on closed device */
comment|/* no event if inside box */
if|if
condition|(
name|cur
operator|.
name|y
operator|<
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|bottom
operator|&&
name|cur
operator|.
name|y
operator|>=
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|top
operator|&&
name|cur
operator|.
name|x
operator|<
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|right
operator|&&
name|cur
operator|.
name|x
operator|>=
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|left
condition|)
return|return;
comment|/* trash box */
name|vsb
operator|->
name|vsioa
operator|.
name|mbox
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|+
literal|1
argument_list|)
operator|==
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
condition|)
return|return;
name|i
operator|=
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|!=
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|)
operator|&&
operator|(
name|i
operator|!=
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|)
condition|)
block|{
name|vep
operator|=
operator|&
name|vsb
operator|->
name|ibuff
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vep
operator|->
name|vse_type
operator|==
name|VSE_MMOTION
condition|)
block|{
name|vep
operator|->
name|vse_x
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|cur
operator|.
name|y
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* put event into queue and do select */
name|vep
operator|=
operator|&
name|vsb
operator|->
name|ibuff
index|[
name|vsb
operator|->
name|vsioa
operator|.
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|cur
operator|.
name|y
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|=
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|rsel
condition|)
block|{
name|selwakeup
argument_list|(
name|vsp
operator|->
name|rsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|rsel
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|VS_INT_BE
case|:
comment|/* button event */
if|if
condition|(
operator|!
name|vsp
operator|->
name|open
condition|)
return|return;
comment|/* ignore on closed device */
if|if
condition|(
name|vsp
operator|->
name|krr
operator|.
name|kbd_device
operator|==
name|VSE_MOUSE
condition|)
block|{
name|vsb
operator|->
name|vsioa
operator|.
name|mouse
operator|.
name|x
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|mouse
operator|.
name|y
operator|=
name|cur
operator|.
name|y
expr_stmt|;
block|}
comment|/* check for room in the queue */
if|if
condition|(
operator|(
name|i
operator|=
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
condition|)
return|return;
comment|/* put event into queue and do select */
name|vep
operator|=
operator|&
name|vsb
operator|->
name|ibuff
index|[
name|vsb
operator|->
name|vsioa
operator|.
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|vep
operator|->
name|vse_key
operator|=
name|vsp
operator|->
name|krr
operator|.
name|kbd_key
expr_stmt|;
name|vep
operator|->
name|vse_direction
operator|=
name|vsp
operator|->
name|krr
operator|.
name|kbd_transition
expr_stmt|;
name|vep
operator|->
name|vse_device
operator|=
name|vsp
operator|->
name|krr
operator|.
name|kbd_device
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|vsb
operator|->
name|vsioa
operator|.
name|mouse
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|vsb
operator|->
name|vsioa
operator|.
name|mouse
operator|.
name|y
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|rsel
condition|)
block|{
name|selwakeup
argument_list|(
name|vsp
operator|->
name|rsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|rsel
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|VS_INT_TM
case|:
comment|/* tablet moved */
if|if
condition|(
operator|!
name|vsp
operator|->
name|open
condition|)
return|return;
comment|/* ignore on closed device */
if|if
condition|(
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|+
literal|1
argument_list|)
operator|==
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
condition|)
return|return;
name|i
operator|=
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|!=
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|)
operator|&&
operator|(
name|i
operator|!=
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|)
condition|)
block|{
name|vep
operator|=
operator|&
name|vsb
operator|->
name|ibuff
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vep
operator|->
name|vse_type
operator|==
name|VSE_TMOTION
condition|)
block|{
name|vep
operator|->
name|vse_x
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|cur
operator|.
name|y
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* put event into queue and do select */
name|vep
operator|=
operator|&
name|vsb
operator|->
name|ibuff
index|[
name|vsb
operator|->
name|vsioa
operator|.
name|itail
index|]
expr_stmt|;
name|vep
operator|->
name|vse_type
operator|=
name|VSE_TMOTION
expr_stmt|;
name|vep
operator|->
name|vse_x
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vep
operator|->
name|vse_y
operator|=
name|cur
operator|.
name|y
expr_stmt|;
name|vep
operator|->
name|vse_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
expr_stmt|;
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|=
name|EVROUND
argument_list|(
name|vsb
operator|->
name|vsioa
operator|.
name|itail
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|rsel
condition|)
block|{
name|selwakeup
argument_list|(
name|vsp
operator|->
name|rsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|rsel
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|VS_INT_US
case|:
comment|/* unsolicited */
name|vsp
operator|->
name|stats
operator|.
name|unsolIntr
operator|++
expr_stmt|;
return|return;
case|case
name|VS_INT_ID
case|:
comment|/* Initialization done */
comment|/* save offset from device */
name|vsp
operator|->
name|offset
operator|.
name|fparm_all
operator|=
name|vsp
operator|->
name|pr
operator|.
name|fparm_all
expr_stmt|;
comment|/* save rom version */
name|vsp
operator|->
name|romVersion
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|VS_INT_SE
case|:
comment|/* ucode started */
break|break;
case|case
name|VS_INT_PWR
case|:
comment|/* power up complete */
comment|/* save rom version */
name|vsp
operator|->
name|romVersion
operator|=
name|cur
operator|.
name|x
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|open
operator|&&
name|vsp
operator|->
name|pgrp
condition|)
name|gsignal
argument_list|(
name|vsp
operator|->
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printI
argument_list|(
literal|"vs%d: unknown interrupt %b\n"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|vsp
operator|->
name|irr
operator|.
name|intr_reason
argument_list|,
name|VSIRR_BITS
argument_list|)
expr_stmt|;
return|return;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vsreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|uip
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
init|=
name|vs_softc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVS
condition|;
name|i
operator|++
operator|,
name|vsp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uip
operator|=
name|vsdinfo
index|[
name|i
index|]
operator|)
operator|==
literal|0
operator|||
name|uip
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|uip
operator|->
name|ui_ubanum
operator|!=
name|uban
operator|||
name|vsp
operator|->
name|open
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" vs%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|inited
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|open
operator|&&
name|vsp
operator|->
name|pgrp
condition|)
name|gsignal
argument_list|(
name|vsp
operator|->
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|vsselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vsBuffArea
modifier|*
name|vsb
init|=
operator|&
name|vsBuff
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
if|if
condition|(
name|vsb
operator|->
name|vsioa
operator|.
name|ihead
operator|!=
name|vsb
operator|->
name|vsioa
operator|.
name|itail
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|rsel
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* can never write */
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize VS100 or SBO.  * Set XMITON.  VS100 will respond with link available.  SBO won't, so  * don't wait forever; assume everything is OK and warn user.  */
end_comment

begin_macro
name|vsInitFiber
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|vsdevice
modifier|*
name|vsaddr
init|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
init|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
name|VS_XMIT_ON
operator|)
expr_stmt|;
comment|/* turn link on */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
argument_list|,
name|SLP_VS_INITF
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
comment|/* timeout */
name|error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VSSBO
if|if
condition|(
operator|!
name|vsp
operator|->
name|linkAvail
condition|)
block|{
name|uprintf
argument_list|(
literal|"\007This had better be a vs125!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vs%d must be a vs125\n"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|linkAvail
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|vsInitDev
argument_list|(
argument|dev
argument_list|,
argument|retry
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|retry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vsdevice
modifier|*
name|vsaddr
decl_stmt|;
specifier|register
name|struct
name|vs_softc
modifier|*
name|vsp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|vsaddr
operator|=
operator|(
expr|struct
name|vsdevice
operator|*
operator|)
name|vsdinfo
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ui_addr
expr_stmt|;
name|vsp
operator|=
operator|&
name|vs_softc
index|[
name|VSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vsp
operator|->
name|linkAvail
condition|)
if|if
condition|(
name|error
operator|=
name|vsInitFiber
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|vsaddr
operator|->
name|vs_irr
operator|=
literal|0
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator|&=
operator|~
name|VS_FCN
expr_stmt|;
name|vsaddr
operator|->
name|vs_csr0
operator||=
operator|(
name|VS_IE
operator||
operator|(
name|VS_INIT
operator|<<
name|VS_FCSHIFT
operator|)
operator||
name|VS_GO
operator|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsp
argument_list|,
name|VSWAITPRI
operator||
name|PCATCH
argument_list|,
name|devwait
argument_list|,
name|retry
condition|?
literal|10
operator|*
name|hz
else|:
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vsp
operator|->
name|inited
condition|)
break|break;
name|printM
argument_list|(
literal|"vs%d: VS_INIT fails\n"
argument_list|,
name|VSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"vsInitDev %x %x\n"
argument_list|,
name|vsaddr
operator|->
name|vs_csr0
argument_list|,
name|vsaddr
operator|->
name|vs_csr1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vsError
argument_list|(
name|vsp
argument_list|)
specifier|register
expr|struct
name|vs_softc
operator|*
name|vsp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|vsp
operator|->
name|irr
operator|.
name|intr_error
condition|)
block|{
specifier|register
name|int
name|ret
init|=
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
decl_stmt|;
name|printD
argument_list|(
literal|"\treturning 0x%x\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|irr
operator|.
name|intr_reg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|+
literal|128
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

