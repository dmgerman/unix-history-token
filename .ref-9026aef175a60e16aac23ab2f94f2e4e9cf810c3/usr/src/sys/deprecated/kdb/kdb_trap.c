begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986, 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)kdb_trap.c	7.8 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Trap handler - command loop entry point.  */
end_comment

begin_include
include|#
directive|include
file|"../kdb/defs.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|kdbNOEOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kdbexecuting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kdblp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|kdblastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|kdbuserpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kdblastcom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|kdbmaxoff
init|=
name|MAXOFF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|kdbmaxpos
init|=
name|MAXPOS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kdb trap handler; entered on all fatal  * and/or debugger related traps or faults.  */
end_comment

begin_macro
name|kdb
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|curproc
argument_list|,
argument|kstack
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|curproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kstack
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'t'
argument_list|)
index|]
operator|=
name|type
expr_stmt|;
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'c'
argument_list|)
index|]
operator|=
name|code
expr_stmt|;
name|kdbvar
index|[
name|kdbvarchk
argument_list|(
literal|'p'
argument_list|)
index|]
operator|=
operator|(
name|int
operator|)
name|curproc
expr_stmt|;
if|if
condition|(
name|kdbexecuting
condition|)
name|kdbdelbp
argument_list|()
expr_stmt|;
name|kdbexecuting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kstack
condition|)
name|kdbprintf
argument_list|(
literal|"(from kernel stack)\n"
argument_list|)
expr_stmt|;
comment|/* after delbp() */
name|kdbprinttrap
argument_list|(
operator|(
name|long
operator|)
name|type
argument_list|,
operator|(
name|long
operator|)
name|code
argument_list|)
expr_stmt|;
name|kdbuserpc
operator|=
name|kdbdot
operator|=
name|kdbpcb
operator|.
name|pcb_pc
expr_stmt|;
switch|switch
condition|(
name|setexit
argument_list|()
condition|)
block|{
case|case
name|SINGLE
case|:
name|setsstep
argument_list|()
expr_stmt|;
comment|/* hardware single step */
comment|/* fall thru... */
case|case
name|CONTIN
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PANIC
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0
case|:
if|if
condition|(
name|kdbnextpcs
argument_list|(
name|type
argument_list|)
condition|)
name|kdbprintf
argument_list|(
literal|"breakpoint%16t"
argument_list|)
expr_stmt|;
else|else
name|kdbprintf
argument_list|(
literal|"stopped at%16t"
argument_list|)
expr_stmt|;
name|kdbprintpc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kdbexecuting
condition|)
name|kdbdelbp
argument_list|()
expr_stmt|;
name|kdbexecuting
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|kdbflushbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|kdberrflg
condition|)
block|{
name|kdbprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|kdberrflg
argument_list|)
expr_stmt|;
name|kdberrflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|kdbmkfault
condition|)
block|{
name|kdbmkfault
operator|=
literal|0
expr_stmt|;
name|kdbprintc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|kdbprintf
argument_list|(
name|DBNAME
argument_list|)
expr_stmt|;
block|}
name|kdbwrite
argument_list|(
literal|"kdb> "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|kdblp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|kdbrdc
argument_list|()
expr_stmt|;
name|kdblp
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|kdbcommand
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|kdblastcom
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdblp
operator|&&
name|kdblastc
operator|!=
literal|'\n'
condition|)
name|kdberror
argument_list|(
name|kdbNOEOR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * If there has been an error or a fault, take the error.  */
end_comment

begin_macro
name|kdbchkerr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kdberrflg
operator|||
name|kdbmkfault
condition|)
name|kdberror
argument_list|(
name|kdberrflg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An error occurred; save the message for  * later printing, and reset to main command loop.  */
end_comment

begin_macro
name|kdberror
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kdberrflg
operator|=
name|n
expr_stmt|;
name|reset
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

