begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Ralph Campbell.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.32 91/04/06$  *  *	@(#)trap.c	8.7 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/mips_opcode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/clockreg.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kn01.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kn02.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kmin.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/maxine.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/kn03.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/asic.h>
end_include

begin_include
include|#
directive|include
file|<pmax/pmax/turbochannel.h>
end_include

begin_include
include|#
directive|include
file|<pmax/stand/dec_prom.h>
end_include

begin_include
include|#
directive|include
file|<asc.h>
end_include

begin_include
include|#
directive|include
file|<sii.h>
end_include

begin_include
include|#
directive|include
file|<le.h>
end_include

begin_include
include|#
directive|include
file|<dc.h>
end_include

begin_decl_stmt
name|struct
name|proc
modifier|*
name|machFPCurProcPtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last proc to use FP */
end_comment

begin_function_decl
specifier|extern
name|void
name|MachKernGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserGenException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachKernIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachUserIntr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBModException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|MachTLBMissException
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|MachEmulateBranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|machExceptionTable
index|[]
function_decl|)
parameter_list|()
init|=
block|{
comment|/*  * The kernel exception handlers.  */
name|MachKernIntr
operator|,
comment|/* external interrupt */
function_decl|MachKernGenException
operator|,
comment|/* TLB modification */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (load or instr. fetch) */
function_decl|MachTLBMissException
operator|,
comment|/* TLB miss (store) */
function_decl|MachKernGenException
operator|,
comment|/* address error (load or I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* address error (store) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (I-fetch) */
function_decl|MachKernGenException
operator|,
comment|/* bus error (load or store) */
function_decl|MachKernGenException
operator|,
comment|/* system call */
function_decl|MachKernGenException
operator|,
comment|/* breakpoint */
function_decl|MachKernGenException
operator|,
comment|/* reserved instruction */
function_decl|MachKernGenException
operator|,
comment|/* coprocessor unusable */
function_decl|MachKernGenException
operator|,
comment|/* arithmetic overflow */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
function_decl|MachKernGenException
operator|,
comment|/* reserved */
comment|/*  * The user exception handlers.  */
function_decl|MachUserIntr
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
function_decl|MachUserGenException
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"external interrupt"
block|,
literal|"TLB modification"
block|,
literal|"TLB miss (load or instr. fetch)"
block|,
literal|"TLB miss (store)"
block|,
literal|"address error (load or I-fetch)"
block|,
literal|"address error (store)"
block|,
literal|"bus error (I-fetch)"
block|,
literal|"bus error (load or store)"
block|,
literal|"system call"
block|,
literal|"breakpoint"
block|,
literal|"reserved instruction"
block|,
literal|"coprocessor unusable"
block|,
literal|"arithmetic overflow"
block|,
literal|"reserved 13"
block|,
literal|"reserved 14"
block|,
literal|"reserved 15"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|TRAPSIZE
value|10
end_define

begin_struct
struct|struct
name|trapdebug
block|{
comment|/* trap history buffer for debugging */
name|u_int
name|status
decl_stmt|;
name|u_int
name|cause
decl_stmt|;
name|u_int
name|vadr
decl_stmt|;
name|u_int
name|pc
decl_stmt|;
name|u_int
name|ra
decl_stmt|;
name|u_int
name|code
decl_stmt|;
block|}
name|trapdebug
index|[
name|TRAPSIZE
index|]
struct|,
modifier|*
name|trp
init|=
name|trapdebug
struct|;
end_struct

begin_decl_stmt
name|u_int
name|intr_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nested interrupts */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|pmax_errintr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|kn02_errintr
argument_list|()
decl_stmt|,
name|kn02ba_errintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DS5000_240
end_ifdef

begin_function_decl
specifier|static
name|void
name|kn03_errintr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|unsigned
name|kn02ba_recover_erradr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|tc_option_t
name|tc_slot_info
index|[
name|TC_MAX_LOGICAL_SLOTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|kmin_tc3_imask
decl_stmt|,
name|xine_tc3_imask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|callback
modifier|*
name|callv
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DS5000_240
end_ifdef

begin_decl_stmt
specifier|extern
name|u_long
name|kn03_tc3_imask
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
function_decl|(
modifier|*
name|pmax_hardware_intr
function_decl|)
parameter_list|()
init|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
operator|(
operator|)
operator|)
literal|0
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
specifier|volatile
name|struct
name|chiptime
modifier|*
name|Mach_clock_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|intrcnt
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle an exception.  * Called from MachKernGenException() or MachUserGenException()  * when a processor trap occurs.  * In the case of a kernel trap, we return the pc where to resume if  * ((struct pcb *)UADDR)->pcb_onfault is set, otherwise, return old pc.  */
end_comment

begin_function
name|unsigned
name|trap
parameter_list|(
name|statusReg
parameter_list|,
name|causeReg
parameter_list|,
name|vadr
parameter_list|,
name|pc
parameter_list|,
name|args
parameter_list|)
name|unsigned
name|statusReg
decl_stmt|;
comment|/* status register at time of the exception */
name|unsigned
name|causeReg
decl_stmt|;
comment|/* cause register at time of exception */
name|unsigned
name|vadr
decl_stmt|;
comment|/* address (if any) the fault occured on */
name|unsigned
name|pc
decl_stmt|;
comment|/* program counter where to continue */
block|{
specifier|register
name|int
name|type
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|unsigned
name|onfault_table
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|vadr
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|?
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
else|:
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|type
operator|=
operator|(
name|causeReg
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
block|}
comment|/* 	 * Enable hardware interrupts if they were on before. 	 * We only respond to software interrupts when returning to user mode. 	 */
if|if
condition|(
name|statusReg
operator|&
name|MACH_SR_INT_ENA_PREV
condition|)
name|splx
argument_list|(
operator|(
name|statusReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_TLB_MOD
case|:
comment|/* check for kernel address */
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|pte
operator|=
name|kvtopte
argument_list|(
name|vadr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_M
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|PG_RO
condition|)
block|{
comment|/* write to read only page in the kernel */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|kernel_fault
goto|;
block|}
name|entry
operator||=
name|PG_M
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|vadr
operator|&=
operator|~
name|PGOFSET
expr_stmt|;
name|MachTLBUpdate
argument_list|(
name|vadr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pa
operator|=
name|entry
operator|&
name|PG_FRAME
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: ktlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pc
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|T_TLB_MOD
operator|+
name|T_USER
case|:
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|pmap_t
name|pmap
init|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pte
operator|=
name|pmap_segmap
argument_list|(
name|pmap
argument_list|,
name|vadr
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: invalid segmap"
argument_list|)
expr_stmt|;
name|pte
operator|+=
operator|(
name|vadr
operator|>>
name|PGSHIFT
operator|)
operator|&
operator|(
name|NPTEPG
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
name|pte
operator|->
name|pt_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|entry
operator|&
name|PG_V
operator|)
operator|||
operator|(
name|entry
operator|&
name|PG_M
operator|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: invalid pte"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&
name|PG_RO
condition|)
block|{
comment|/* write to read only page */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
goto|goto
name|dofault
goto|;
block|}
name|entry
operator||=
name|PG_M
expr_stmt|;
name|pte
operator|->
name|pt_entry
operator|=
name|entry
expr_stmt|;
name|vadr
operator|=
operator|(
name|vadr
operator|&
operator|~
name|PGOFSET
operator|)
operator||
operator|(
name|pmap
operator|->
name|pm_tlbpid
operator|<<
name|VMMACH_TLB_PID_SHIFT
operator|)
expr_stmt|;
name|MachTLBUpdate
argument_list|(
name|vadr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pa
operator|=
name|entry
operator|&
name|PG_FRAME
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTR
name|pmap_attributes
index|[
name|atop
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|PMAP_ATTR_MOD
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IS_VM_PHYSADDR
argument_list|(
name|pa
argument_list|)
condition|)
name|panic
argument_list|(
literal|"trap: utlbmod: unmanaged page"
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|PG_CLEAN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
case|case
name|T_TLB_LD_MISS
case|:
case|case
name|T_TLB_ST_MISS
case|:
name|ftype
operator|=
operator|(
name|type
operator|==
name|T_TLB_ST_MISS
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
comment|/* check for kernel address */
if|if
condition|(
operator|(
name|int
operator|)
name|vadr
operator|<
literal|0
condition|)
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|kernel_fault
label|:
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|kernel_map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|pc
operator|)
return|;
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
comment|/* 		 * It is an error for the kernel to access user space except 		 * through the copyin/copyout routines. 		 */
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|)
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* check for fuswintr() or suswintr() getting a page fault */
if|if
condition|(
name|i
operator|==
literal|4
condition|)
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_LD_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
goto|goto
name|dofault
goto|;
case|case
name|T_TLB_ST_MISS
operator|+
name|T_USER
case|:
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|dofault
label|:
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vadr
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
return|return
operator|(
name|pc
operator|)
return|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
goto|goto
name|err
goto|;
block|}
name|ucode
operator|=
name|vadr
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
case|case
name|T_ADDR_ERR_LD
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_ADDR_ERR_ST
operator|+
name|T_USER
case|:
comment|/* misaligned or kseg access */
case|case
name|T_BUS_ERR_IFETCH
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
case|case
name|T_BUS_ERR_LD_ST
operator|+
name|T_USER
case|:
comment|/* BERR asserted to cpu */
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
case|case
name|T_SYSCALL
operator|+
name|T_USER
case|:
block|{
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|;
name|int
name|numsys
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sysent
modifier|*
name|systab
decl_stmt|;
specifier|extern
name|int
name|nsysent
decl_stmt|;
ifdef|#
directive|ifdef
name|ULTRIXCOMPAT
specifier|extern
name|struct
name|sysent
name|ultrixsysent
index|[]
decl_stmt|;
specifier|extern
name|int
name|ultrixnsysent
decl_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
comment|/* compute next PC after syscall instruction */
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|locr0
index|[
name|PC
index|]
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|locr0
index|[
name|PC
index|]
operator|+=
literal|4
expr_stmt|;
name|systab
operator|=
name|sysent
expr_stmt|;
name|numsys
operator|=
name|nsysent
expr_stmt|;
ifdef|#
directive|ifdef
name|ULTRIXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_ULTRIX
condition|)
block|{
name|systab
operator|=
name|ultrixsysent
expr_stmt|;
name|numsys
operator|=
name|ultrixnsysent
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|locr0
index|[
name|V0
index|]
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYS_syscall
case|:
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_syscall
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_argsize
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_argsize
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
break|break;
case|case
name|SYS___syscall
case|:
comment|/* 			 * Like syscall, but code is a quad, so as to maintain 			 * quad alignment for the rest of the arguments. 			 */
name|code
operator|=
name|locr0
index|[
name|A0
operator|+
name|_QUAD_LOWWORD
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_syscall
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_argsize
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_argsize
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
name|SYS_syscall
index|]
expr_stmt|;
comment|/* (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
name|i
operator|=
name|callp
operator|->
name|sy_argsize
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|locr0
index|[
name|A0
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|A1
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|2
index|]
operator|=
name|locr0
index|[
name|A2
index|]
expr_stmt|;
name|args
operator|.
name|i
index|[
literal|3
index|]
operator|=
name|locr0
index|[
name|A3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
condition|)
block|{
name|i
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|locr0
index|[
name|SP
index|]
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
operator|.
name|i
index|[
literal|4
index|]
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|i
operator|-
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_argsize
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_argsize
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|locr0
index|[
name|V1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
else|else
name|trp
index|[
operator|-
literal|1
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|locr0
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
name|locr0
index|[
name|SP
index|]
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|locr0
index|[
name|PC
index|]
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
name|locr0
index|[
name|RA
index|]
expr_stmt|;
name|trp
operator|->
name|code
operator|=
operator|-
name|code
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|locr0
index|[
name|V0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|locr0
index|[
name|V1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|locr0
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
comment|/* nothing to do */
default|default:
name|locr0
index|[
name|V0
index|]
operator|=
name|i
expr_stmt|;
name|locr0
index|[
name|A3
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|i
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
case|case
name|T_BREAK
operator|+
name|T_USER
case|:
block|{
specifier|register
name|unsigned
name|va
decl_stmt|,
name|instr
decl_stmt|;
comment|/* compute address of break instruction */
name|va
operator|=
name|pc
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|causeReg
operator|<
literal|0
condition|)
name|va
operator|+=
literal|4
expr_stmt|;
comment|/* read break instruction */
name|instr
operator|=
name|fuiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n", 			p->p_comm, p->p_pid, instr, pc, 			p->p_md.md_ss_addr, p->p_md.md_ss_instr);
comment|/* XXX */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KADB
if|if
condition|(
name|instr
operator|==
name|MACH_BREAK_BRKPT
operator|||
name|instr
operator|==
name|MACH_BREAK_SSTEP
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|!=
name|va
operator|||
name|instr
operator|!=
name|MACH_BREAK_SSTEP
condition|)
block|{
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
comment|/* restore original instruction and clear BP  */
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Warning: can't restore instruction at %x: %x\n"
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
block|}
case|case
name|T_RES_INST
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_COP_UNUSABLE
operator|+
name|T_USER
case|:
if|if
condition|(
operator|(
name|causeReg
operator|&
name|MACH_CR_COP_ERR
operator|)
operator|!=
literal|0x10000000
condition|)
block|{
name|i
operator|=
name|SIGILL
expr_stmt|;
comment|/* only FPU instructions allowed */
break|break;
block|}
name|MachSwitchFPState
argument_list|(
name|machFPCurProcPtr
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_regs
argument_list|)
expr_stmt|;
name|machFPCurProcPtr
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|PS
index|]
operator||=
name|MACH_SR_COP_1_BIT
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator||=
name|MDP_FPUSED
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_OVFLOW
operator|+
name|T_USER
case|:
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_ADDR_ERR_LD
case|:
comment|/* misaligned access */
case|case
name|T_ADDR_ERR_ST
case|:
comment|/* misaligned access */
case|case
name|T_BUS_ERR_LD_ST
case|:
comment|/* BERR asserted to cpu */
if|if
condition|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|UADDR
operator|)
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|onfault_table
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|err
label|:
ifdef|#
directive|ifdef
name|KADB
block|{
specifier|extern
name|struct
name|pcb
name|kdbpcb
decl_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
name|kdbpcb
operator|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
expr_stmt|;
else|else
block|{
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|ZERO
index|]
operator|=
literal|0
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|AST
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|V1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|4
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|5
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|6
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|7
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|A3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|8
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T0
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|9
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T1
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|10
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T2
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|11
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T3
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|12
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T4
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|13
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T5
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|14
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T6
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|15
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T7
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|16
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T8
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|17
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|T9
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|18
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|RA
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|19
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULLO
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|21
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|MULHI
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|args
operator|)
index|[
literal|22
index|]
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|=
name|pc
expr_stmt|;
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|SR
index|]
operator|=
name|statusReg
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|F0
index|]
argument_list|,
literal|33
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kdb
argument_list|(
name|causeReg
argument_list|,
name|vadr
argument_list|,
name|p
argument_list|,
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|kdbpcb
operator|.
name|pcb_regs
index|[
name|PC
index|]
operator|)
return|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|DEBUG
name|trapDump
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Note: we should only get here if returning to user mode. 	 */
comment|/* take pending signals */
while|while
condition|(
operator|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_priority
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
name|astpending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we put ourselves on the run queue 		 * but before we switched, we might not be on the queue 		 * indicated by our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If profiling, charge system time to the trapped pc. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFIL
condition|)
block|{
specifier|extern
name|int
name|psratio
decl_stmt|;
name|addupc_task
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|sticks
argument_list|)
operator|*
name|psratio
argument_list|)
expr_stmt|;
block|}
name|curpriority
operator|=
name|p
operator|->
name|p_priority
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an interrupt.  * Called from MachKernIntr() or MachUserIntr()  * Note: curproc might be NULL.  */
end_comment

begin_macro
name|interrupt
argument_list|(
argument|statusReg
argument_list|,
argument|causeReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cause register at time of exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|mask
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|trp
operator|->
name|status
operator|=
name|statusReg
expr_stmt|;
name|trp
operator|->
name|cause
operator|=
name|causeReg
expr_stmt|;
name|trp
operator|->
name|vadr
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|trp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|trp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|trp
operator|==
operator|&
name|trapdebug
index|[
name|TRAPSIZE
index|]
condition|)
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|intr_level
operator|++
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_intr
operator|++
expr_stmt|;
name|mask
operator|=
name|causeReg
operator|&
name|statusReg
expr_stmt|;
comment|/* pending interrupts& enable mask */
if|if
condition|(
name|pmax_hardware_intr
condition|)
name|splx
argument_list|(
call|(
modifier|*
name|pmax_hardware_intr
call|)
argument_list|(
name|mask
argument_list|,
name|pc
argument_list|,
name|statusReg
argument_list|,
name|causeReg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_5
condition|)
block|{
name|intrcnt
index|[
literal|7
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|statusReg
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trapDump
argument_list|(
literal|"fpintr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"FPU interrupt: PC %x CR %x SR %x\n"
argument_list|,
name|pc
argument_list|,
name|causeReg
argument_list|,
name|statusReg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|MachFPInterrupt
argument_list|(
name|statusReg
argument_list|,
name|causeReg
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_0
condition|)
block|{
name|clearsoftclock
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|intrcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|softclock
argument_list|()
expr_stmt|;
block|}
comment|/* process network interrupt if we trapped or will very soon */
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
operator|||
name|netisr
operator|&&
operator|(
name|statusReg
operator|&
name|MACH_SOFT_INT_MASK_1
operator|)
condition|)
block|{
name|clearsoftnet
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|intrcnt
index|[
literal|1
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ARP
operator|)
expr_stmt|;
name|arpintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
expr_stmt|;
name|ipintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
expr_stmt|;
name|nsintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISO
if|if
condition|(
name|netisr
operator|&
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
condition|)
block|{
name|netisr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|NETISR_ISO
operator|)
expr_stmt|;
name|clnlintr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|intr_level
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Handle pmax (DECstation 2100/3100) interrupts.  */
end_comment

begin_macro
name|pmax_intr
argument_list|(
argument|mask
argument_list|,
argument|pc
argument_list|,
argument|statusReg
argument_list|,
argument|causeReg
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
name|Mach_clock_addr
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
name|intrcnt
index|[
literal|6
index|]
operator|++
expr_stmt|;
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* XXX clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
comment|/* keep clock interrupts enabled */
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_3
expr_stmt|;
block|}
comment|/* Re-enable clock interrupts */
name|splx
argument_list|(
name|MACH_INT_MASK_3
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
if|#
directive|if
name|NSII
operator|>
literal|0
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
block|{
name|intrcnt
index|[
literal|2
index|]
operator|++
expr_stmt|;
name|siiintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NLE
operator|>
literal|0
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
name|intrcnt
index|[
literal|3
index|]
operator|++
expr_stmt|;
name|leintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NDC
operator|>
literal|0
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_2
condition|)
block|{
name|intrcnt
index|[
literal|4
index|]
operator|++
expr_stmt|;
name|dcintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
block|{
name|intrcnt
index|[
literal|5
index|]
operator|++
expr_stmt|;
name|pmax_errintr
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Handle hardware interrupts for the KN02. (DECstation 5000/200)  * Returns spl value.  */
end_comment

begin_macro
name|kn02_intr
argument_list|(
argument|mask
argument_list|,
argument|pc
argument_list|,
argument|statusReg
argument_list|,
argument|causeReg
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|i
decl_stmt|,
name|m
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
name|Mach_clock_addr
decl_stmt|;
specifier|register
name|unsigned
name|csr
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
name|csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_CSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|KN02_CSR_PSWARN
operator|)
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: power supply is overheating!\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warned
operator|&&
operator|!
operator|(
name|csr
operator|&
name|KN02_CSR_PSWARN
operator|)
condition|)
block|{
name|warned
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: power supply is OK again\n"
argument_list|)
expr_stmt|;
block|}
name|intrcnt
index|[
literal|6
index|]
operator|++
expr_stmt|;
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* XXX clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
comment|/* keep clock interrupts enabled */
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_1
expr_stmt|;
block|}
comment|/* Re-enable clock interrupts */
name|splx
argument_list|(
name|MACH_INT_MASK_1
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
block|{
specifier|static
name|int
name|map
index|[
literal|8
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|}
decl_stmt|;
name|csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_CSR
argument_list|)
expr_stmt|;
name|m
operator|=
name|csr
operator|&
operator|(
name|csr
operator|>>
name|KN02_CSR_IOINTEN_SHIFT
operator|)
operator|&
name|KN02_CSR_IOINT
expr_stmt|;
if|#
directive|if
literal|0
block|*(unsigned *)MACHPHYS_TO_UNCACHED(KN02_SYS_CSR) = 			(csr& ~(KN02_CSR_WRESERVED | 0xFF)) | 			(m<< KN02_CSR_IOINTEN_SHIFT);
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m
condition|;
name|i
operator|++
operator|,
name|m
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|intrcnt
index|[
name|map
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|tc_slot_info
index|[
name|i
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
name|tc_slot_info
index|[
name|i
index|]
operator|.
name|intr
operator|)
operator|(
name|tc_slot_info
index|[
name|i
index|]
operator|.
name|unit
operator|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"spurious interrupt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|*(unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR) = 			csr& ~(KN02_CSR_WRESERVED | 0xFF);
endif|#
directive|endif
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
name|intrcnt
index|[
literal|5
index|]
operator|++
expr_stmt|;
name|kn02_errintr
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * 3min hardware interrupts. (DECstation 5000/1xx)  */
end_comment

begin_macro
name|kmin_intr
argument_list|(
argument|mask
argument_list|,
argument|pc
argument_list|,
argument|statusReg
argument_list|,
argument|causeReg
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int
name|intr
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
name|Mach_clock_addr
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|imaskp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_IMSK
argument_list|)
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|intrp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_INTR
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|old_mask
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
name|int
name|temp
decl_stmt|;
specifier|static
name|int
name|user_warned
init|=
literal|0
decl_stmt|;
name|old_mask
operator|=
operator|*
name|imaskp
operator|&
name|kmin_tc3_imask
expr_stmt|;
operator|*
name|imaskp
operator|=
name|old_mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
call|(
modifier|*
name|callv
operator|->
name|halt
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
name|intr
operator|=
operator|*
name|intrp
expr_stmt|;
comment|/* masked interrupts are still observable */
name|intr
operator|&=
name|old_mask
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KMIN_INTR_SCSI_PTR_LOAD
condition|)
block|{
operator|*
name|intrp
operator|&=
operator|~
name|KMIN_INTR_SCSI_PTR_LOAD
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|asc_dma_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intr
operator|&
operator|(
name|KMIN_INTR_SCSI_OVRUN
operator||
name|KMIN_INTR_SCSI_READ_E
operator|)
condition|)
operator|*
name|intrp
operator|&=
operator|~
operator|(
name|KMIN_INTR_SCSI_OVRUN
operator||
name|KMIN_INTR_SCSI_READ_E
operator|)
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KMIN_INTR_LANCE_READ_E
condition|)
operator|*
name|intrp
operator|&=
operator|~
name|KMIN_INTR_LANCE_READ_E
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KMIN_INTR_TIMEOUT
condition|)
name|kn02ba_errintr
argument_list|()
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KMIN_INTR_CLOCK
condition|)
block|{
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* XXX clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intr
operator|&
name|KMIN_INTR_SCC_0
operator|)
operator|&&
name|tc_slot_info
index|[
name|KMIN_SCC0_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KMIN_SCC0_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KMIN_SCC0_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KMIN_INTR_SCC_1
operator|)
operator|&&
name|tc_slot_info
index|[
name|KMIN_SCC1_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KMIN_SCC1_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KMIN_SCC1_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KMIN_INTR_SCSI
operator|)
operator|&&
name|tc_slot_info
index|[
name|KMIN_SCSI_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KMIN_SCSI_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KMIN_SCSI_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KMIN_INTR_LANCE
operator|)
operator|&&
name|tc_slot_info
index|[
name|KMIN_LANCE_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KMIN_LANCE_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KMIN_LANCE_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
name|user_warned
operator|&&
operator|(
operator|(
name|intr
operator|&
name|KMIN_INTR_PSWARN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"Power supply ok now."
argument_list|)
expr_stmt|;
name|user_warned
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intr
operator|&
name|KMIN_INTR_PSWARN
operator|)
operator|&&
operator|(
name|user_warned
operator|<
literal|3
operator|)
condition|)
block|{
name|user_warned
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"Power supply overheating"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_INT_MASK_0
operator|)
operator|&&
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
operator|)
operator|(
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_INT_MASK_1
operator|)
operator|&&
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
operator|)
operator|(
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|MACH_INT_MASK_2
operator|)
operator|&&
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|intr
operator|)
operator|(
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|unit
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Maxine hardware interrupts. (Personal DECstation 5000/xx)  */
end_comment

begin_macro
name|xine_intr
argument_list|(
argument|mask
argument_list|,
argument|pc
argument_list|,
argument|statusReg
argument_list|,
argument|causeReg
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int
name|intr
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
name|Mach_clock_addr
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|imaskp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|XINE_REG_IMSK
argument_list|)
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|intrp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|XINE_REG_INTR
argument_list|)
decl_stmt|;
name|u_int
name|old_mask
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|old_mask
operator|=
operator|*
name|imaskp
operator|&
name|xine_tc3_imask
expr_stmt|;
operator|*
name|imaskp
operator|=
name|old_mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
call|(
modifier|*
name|callv
operator|->
name|halt
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* XXX clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_1
expr_stmt|;
comment|/* reenable clock interrupts */
name|splx
argument_list|(
name|MACH_INT_MASK_1
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
block|{
name|intr
operator|=
operator|*
name|intrp
expr_stmt|;
comment|/* masked interrupts are still observable */
name|intr
operator|&=
name|old_mask
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|XINE_INTR_SCSI_PTR_LOAD
condition|)
block|{
operator|*
name|intrp
operator|&=
operator|~
name|XINE_INTR_SCSI_PTR_LOAD
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|asc_dma_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intr
operator|&
operator|(
name|XINE_INTR_SCSI_OVRUN
operator||
name|XINE_INTR_SCSI_READ_E
operator|)
condition|)
operator|*
name|intrp
operator|&=
operator|~
operator|(
name|XINE_INTR_SCSI_OVRUN
operator||
name|XINE_INTR_SCSI_READ_E
operator|)
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|XINE_INTR_LANCE_READ_E
condition|)
operator|*
name|intrp
operator|&=
operator|~
name|XINE_INTR_LANCE_READ_E
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_SCC_0
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_SCC0_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_SCC0_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_SCC0_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_DTOP_RX
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_DTOP_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_DTOP_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_DTOP_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_FLOPPY
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_FLOPPY_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_FLOPPY_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_FLOPPY_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_TC_0
operator|)
operator|&&
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_TC_1
operator|)
operator|&&
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_ISDN
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_ISDN_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_ISDN_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_ISDN_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_SCSI
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_SCSI_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_SCSI_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_SCSI_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|XINE_INTR_LANCE
operator|)
operator|&&
name|tc_slot_info
index|[
name|XINE_LANCE_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|XINE_LANCE_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|XINE_LANCE_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_2
condition|)
name|kn02ba_errintr
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DS5000_240
end_ifdef

begin_comment
comment|/*  * 3Max+ hardware interrupts. (DECstation 5000/240) UNTESTED!!  */
end_comment

begin_macro
name|kn03_intr
argument_list|(
argument|mask
argument_list|,
argument|pc
argument_list|,
argument|statusReg
argument_list|,
argument|causeReg
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|causeReg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int
name|intr
decl_stmt|;
specifier|register
specifier|volatile
name|struct
name|chiptime
modifier|*
name|c
init|=
name|Mach_clock_addr
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|imaskp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN03_REG_IMSK
argument_list|)
decl_stmt|;
specifier|volatile
name|u_int
modifier|*
name|intrp
init|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN03_REG_INTR
argument_list|)
decl_stmt|;
name|u_int
name|old_mask
decl_stmt|;
name|struct
name|clockframe
name|cf
decl_stmt|;
name|int
name|temp
decl_stmt|;
specifier|static
name|int
name|user_warned
init|=
literal|0
decl_stmt|;
name|old_mask
operator|=
operator|*
name|imaskp
operator|&
name|kn03_tc3_imask
expr_stmt|;
operator|*
name|imaskp
operator|=
name|old_mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_4
condition|)
call|(
modifier|*
name|callv
operator|->
name|halt
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* handle clock interrupts ASAP */
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_1
condition|)
block|{
name|temp
operator|=
name|c
operator|->
name|regc
expr_stmt|;
comment|/* XXX clear interrupt bits */
name|cf
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|cf
operator|.
name|sr
operator|=
name|statusReg
expr_stmt|;
name|hardclock
argument_list|(
operator|&
name|cf
argument_list|)
expr_stmt|;
name|causeReg
operator|&=
operator|~
name|MACH_INT_MASK_1
expr_stmt|;
comment|/* reenable clock interrupts */
name|splx
argument_list|(
name|MACH_INT_MASK_1
operator||
name|MACH_SR_INT_ENA_CUR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_0
condition|)
block|{
name|intr
operator|=
operator|*
name|intrp
expr_stmt|;
comment|/* masked interrupts are still observable */
name|intr
operator|&=
name|old_mask
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KN03_INTR_SCSI_PTR_LOAD
condition|)
block|{
operator|*
name|intrp
operator|&=
operator|~
name|KN03_INTR_SCSI_PTR_LOAD
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|asc_dma_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intr
operator|&
operator|(
name|KN03_INTR_SCSI_OVRUN
operator||
name|KN03_INTR_SCSI_READ_E
operator|)
condition|)
operator|*
name|intrp
operator|&=
operator|~
operator|(
name|KN03_INTR_SCSI_OVRUN
operator||
name|KN03_INTR_SCSI_READ_E
operator|)
expr_stmt|;
if|if
condition|(
name|intr
operator|&
name|KN03_INTR_LANCE_READ_E
condition|)
operator|*
name|intrp
operator|&=
operator|~
name|KN03_INTR_LANCE_READ_E
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_SCC_0
operator|)
operator|&&
name|tc_slot_info
index|[
name|KN03_SCC0_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KN03_SCC0_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KN03_SCC0_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_SCC_1
operator|)
operator|&&
name|tc_slot_info
index|[
name|KN03_SCC1_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KN03_SCC1_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KN03_SCC1_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_TC_0
operator|)
operator|&&
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
literal|0
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_TC_1
operator|)
operator|&&
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
literal|1
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_TC_2
operator|)
operator|&&
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
literal|2
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_SCSI
operator|)
operator|&&
name|tc_slot_info
index|[
name|KN03_SCSI_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KN03_SCSI_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KN03_SCSI_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_LANCE
operator|)
operator|&&
name|tc_slot_info
index|[
name|KN03_LANCE_SLOT
index|]
operator|.
name|intr
condition|)
operator|(
operator|*
operator|(
name|tc_slot_info
index|[
name|KN03_LANCE_SLOT
index|]
operator|.
name|intr
operator|)
operator|)
operator|(
name|tc_slot_info
index|[
name|KN03_LANCE_SLOT
index|]
operator|.
name|unit
operator|)
expr_stmt|;
if|if
condition|(
name|user_warned
operator|&&
operator|(
operator|(
name|intr
operator|&
name|KN03_INTR_PSWARN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"Power supply ok now."
argument_list|)
expr_stmt|;
name|user_warned
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intr
operator|&
name|KN03_INTR_PSWARN
operator|)
operator|&&
operator|(
name|user_warned
operator|<
literal|3
operator|)
condition|)
block|{
name|user_warned
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"Power supply overheating"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|MACH_INT_MASK_3
condition|)
name|kn03_errintr
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|statusReg
operator|&
operator|~
name|causeReg
operator|&
name|MACH_HARD_INT_MASK
operator|)
operator||
name|MACH_SR_INT_ENA_CUR
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DS5000_240 */
end_comment

begin_comment
comment|/*  * This is called from MachUserIntr() if astpending is set.  * This is very similar to the tail of trap().  */
end_comment

begin_macro
name|softintr
argument_list|(
argument|statusReg
argument_list|,
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|statusReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status register at time of the exception */
end_comment

begin_decl_stmt
name|unsigned
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program counter where to continue */
end_comment

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
comment|/* take pending signals */
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_priority
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
name|astpending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_OWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_OWEUPC
expr_stmt|;
name|ADDUPROF
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_resched
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we put ourselves on the run queue 		 * but before we switched, we might not be on the queue 		 * indicated by our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|curpriority
operator|=
name|p
operator|->
name|p_priority
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|trapDump
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"trapDump(%s)\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRAPSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trp
operator|==
name|trapdebug
condition|)
name|trp
operator|=
operator|&
name|trapdebug
index|[
name|TRAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|trp
operator|--
expr_stmt|;
if|if
condition|(
name|trp
operator|->
name|cause
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s: ADR %x PC %x CR %x SR %x\n"
argument_list|,
name|trap_type
index|[
operator|(
name|trp
operator|->
name|cause
operator|&
name|MACH_CR_EXC_CODE
operator|)
operator|>>
name|MACH_CR_EXC_CODE_SHIFT
index|]
argument_list|,
name|trp
operator|->
name|vadr
argument_list|,
name|trp
operator|->
name|pc
argument_list|,
name|trp
operator|->
name|cause
argument_list|,
name|trp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   RA %x code %d\n"
argument_list|,
name|trp
operator|->
name|ra
argument_list|,
name|trp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|trapdebug
argument_list|,
sizeof|sizeof
argument_list|(
name|trapdebug
argument_list|)
argument_list|)
expr_stmt|;
name|trp
operator|=
name|trapdebug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *----------------------------------------------------------------------  *  * MemErrorInterrupts --  *   pmax_errintr - for the DS2100/DS3100  *   kn02_errintr - for the DS5000/200  *   kn02ba_errintr - for the DS5000/1xx and DS5000/xx  *  *	Handler an interrupt for the control register.  *  * Results:  *	None.  *  * Side effects:  *	None.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|pmax_errintr
parameter_list|()
block|{
specifier|volatile
name|u_short
modifier|*
name|sysCSRPtr
init|=
operator|(
name|u_short
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN01_SYS_CSR
argument_list|)
decl_stmt|;
name|u_short
name|csr
decl_stmt|;
name|csr
operator|=
operator|*
name|sysCSRPtr
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|KN01_CSR_MERR
condition|)
block|{
name|printf
argument_list|(
literal|"Memory error at 0x%x\n"
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN01_SYS_ERRADR
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Mem error interrupt"
argument_list|)
expr_stmt|;
block|}
operator|*
name|sysCSRPtr
operator|=
operator|(
name|csr
operator|&
operator|~
name|KN01_CSR_MBZ
operator|)
operator||
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kn02_errintr
parameter_list|()
block|{
name|u_int
name|erradr
decl_stmt|,
name|chksyn
decl_stmt|,
name|physadr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|erradr
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_ERRADR
argument_list|)
expr_stmt|;
name|chksyn
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_CHKSYN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_ERRADR
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|erradr
operator|&
name|KN02_ERR_VALID
operator|)
condition|)
return|return;
comment|/* extract the physical word address and compensate for pipelining */
name|physadr
operator|=
name|erradr
operator|&
name|KN02_ERR_ADDRESS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|erradr
operator|&
name|KN02_ERR_WRITE
operator|)
condition|)
name|physadr
operator|=
operator|(
name|physadr
operator|&
operator|~
literal|0xfff
operator|)
operator||
operator|(
operator|(
name|physadr
operator|&
literal|0xfff
operator|)
operator|-
literal|5
operator|)
expr_stmt|;
name|physadr
operator|<<=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%s memory %s %s error at 0x%x\n"
argument_list|,
operator|(
name|erradr
operator|&
name|KN02_ERR_CPU
operator|)
condition|?
literal|"CPU"
else|:
literal|"DMA"
argument_list|,
operator|(
name|erradr
operator|&
name|KN02_ERR_WRITE
operator|)
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
operator|(
name|erradr
operator|&
name|KN02_ERR_ECCERR
operator|)
condition|?
literal|"ECC"
else|:
literal|"timeout"
argument_list|,
name|physadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|erradr
operator|&
name|KN02_ERR_ECCERR
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN02_SYS_CHKSYN
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ECC 0x%x\n"
argument_list|,
name|chksyn
argument_list|)
expr_stmt|;
comment|/* check for a corrected, single bit, read error */
if|if
condition|(
operator|!
operator|(
name|erradr
operator|&
name|KN02_ERR_WRITE
operator|)
condition|)
block|{
if|if
condition|(
name|physadr
operator|&
literal|0x4
condition|)
block|{
comment|/* check high word */
if|if
condition|(
name|chksyn
operator|&
name|KN02_ECC_SNGHI
condition|)
return|return;
block|}
else|else
block|{
comment|/* check low word */
if|if
condition|(
name|chksyn
operator|&
name|KN02_ECC_SNGLO
condition|)
return|return;
block|}
block|}
block|}
name|panic
argument_list|(
literal|"Mem error interrupt"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DS5000_240
end_ifdef

begin_function
specifier|static
name|void
name|kn03_errintr
parameter_list|()
block|{
name|printf
argument_list|(
literal|"erradr %x\n"
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN03_SYS_ERRADR
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KN03_SYS_ERRADR
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MachEmptyWriteBuffer
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DS5000_240 */
end_comment

begin_function
specifier|static
name|void
name|kn02ba_errintr
parameter_list|()
block|{
specifier|register
name|int
name|mer
decl_stmt|,
name|adr
decl_stmt|,
name|siz
decl_stmt|;
specifier|static
name|int
name|errintr_cnt
init|=
literal|0
decl_stmt|;
name|siz
operator|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_MSR
argument_list|)
expr_stmt|;
name|mer
operator|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_MER
argument_list|)
expr_stmt|;
name|adr
operator|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_AER
argument_list|)
expr_stmt|;
comment|/* clear interrupt bit */
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|MACH_PHYS_TO_UNCACHED
argument_list|(
name|KMIN_REG_TIMEOUT
argument_list|)
operator|=
literal|0
expr_stmt|;
name|errintr_cnt
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(%d)%s%x [%x %x %x]\n"
argument_list|,
name|errintr_cnt
argument_list|,
literal|"Bad memory chip at phys "
argument_list|,
name|kn02ba_recover_erradr
argument_list|(
name|adr
argument_list|,
name|mer
argument_list|)
argument_list|,
name|mer
argument_list|,
name|siz
argument_list|,
name|adr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|kn02ba_recover_erradr
parameter_list|(
name|phys
parameter_list|,
name|mer
parameter_list|)
specifier|register
name|unsigned
name|phys
decl_stmt|,
name|mer
decl_stmt|;
block|{
comment|/* phys holds bits 28:2, mer knows which byte */
switch|switch
condition|(
name|mer
operator|&
name|KMIN_MER_LASTBYTE
condition|)
block|{
case|case
name|KMIN_LASTB31
case|:
name|mer
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|KMIN_LASTB23
case|:
name|mer
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|KMIN_LASTB15
case|:
name|mer
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KMIN_LASTB07
case|:
name|mer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|(
name|phys
operator|&
name|KMIN_AER_ADDR_MASK
operator|)
operator||
name|mer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the resulting PC as if the branch was executed.  */
end_comment

begin_function
name|unsigned
name|MachEmulateBranch
parameter_list|(
name|regsPtr
parameter_list|,
name|instPC
parameter_list|,
name|fpcCSR
parameter_list|,
name|allowNonBranch
parameter_list|)
name|unsigned
modifier|*
name|regsPtr
decl_stmt|;
name|unsigned
name|instPC
decl_stmt|;
name|unsigned
name|fpcCSR
decl_stmt|;
name|int
name|allowNonBranch
decl_stmt|;
block|{
name|InstFmt
name|inst
decl_stmt|;
name|unsigned
name|retAddr
decl_stmt|;
name|int
name|condition
decl_stmt|;
specifier|extern
name|unsigned
name|GetBranchDest
parameter_list|()
function_decl|;
name|inst
operator|=
operator|*
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
expr_stmt|;
if|#
directive|if
literal|0
block|printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC, 		inst.word, fpcCSR);
comment|/* XXX */
endif|#
directive|endif
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|retAddr
operator|=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_BCOND
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|inst
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
name|OP_BLTZ
case|:
case|case
name|OP_BLTZAL
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGEZAL
case|:
case|case
name|OP_BGEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad branch cond"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
name|retAddr
operator|=
operator|(
name|inst
operator|.
name|JType
operator|.
name|target
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|instPC
operator|&
literal|0xF0000000
operator|)
expr_stmt|;
break|break;
case|case
name|OP_BEQ
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|==
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BNE
case|:
if|if
condition|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
operator|!=
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rt
index|]
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BLEZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|<=
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_BGTZ
case|:
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|regsPtr
index|[
name|inst
operator|.
name|RType
operator|.
name|rs
index|]
argument_list|)
operator|>
literal|0
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|OP_COP1
case|:
switch|switch
condition|(
name|inst
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
if|if
condition|(
operator|(
name|inst
operator|.
name|RType
operator|.
name|rt
operator|&
name|COPz_BC_TF_MASK
operator|)
operator|==
name|COPz_BC_TRUE
condition|)
name|condition
operator|=
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
expr_stmt|;
else|else
name|condition
operator|=
operator|!
operator|(
name|fpcCSR
operator|&
name|MACH_FPC_COND_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|condition
condition|)
name|retAddr
operator|=
name|GetBranchDest
argument_list|(
operator|(
name|InstFmt
operator|*
operator|)
name|instPC
argument_list|)
expr_stmt|;
else|else
name|retAddr
operator|=
name|instPC
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Bad coproc branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|allowNonBranch
condition|)
name|panic
argument_list|(
literal|"MachEmulateBranch: Non-branch instruction"
argument_list|)
expr_stmt|;
name|retAddr
operator|=
name|instPC
operator|+
literal|4
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("Target addr=%x\n", retAddr);
comment|/* XXX */
endif|#
directive|endif
return|return
operator|(
name|retAddr
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|GetBranchDest
parameter_list|(
name|InstPtr
parameter_list|)
name|InstFmt
modifier|*
name|InstPtr
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|unsigned
operator|)
name|InstPtr
operator|+
literal|4
operator|+
operator|(
operator|(
name|short
operator|)
name|InstPtr
operator|->
name|IType
operator|.
name|imm
operator|<<
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called by procxmt() to single step one instruction.  * We do this by storing a break instruction after the current instruction,  * resuming execution, and then restoring the old instruction.  */
end_comment

begin_expr_stmt
name|cpu_singlestep
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|va
decl_stmt|;
specifier|register
name|int
modifier|*
name|locr0
init|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* compute next address after current location */
name|va
operator|=
name|MachEmulateBranch
argument_list|(
name|locr0
argument_list|,
name|locr0
index|[
name|PC
index|]
argument_list|,
name|locr0
index|[
name|FSR
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|||
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|==
name|va
operator|||
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
literal|4
argument_list|,
name|B_READ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SS %s (%d): breakpoint already set at %x (va %x)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|p
operator|->
name|p_md
operator|.
name|md_ss_addr
operator|=
name|va
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_ss_instr
operator|=
name|fuiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|vm_offset_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sa
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|ea
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|i
operator|=
name|suiword
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|MACH_BREAK_SSTEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_protect
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|sa
argument_list|,
name|ea
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|#
directive|if
literal|0
block|printf("SS %s (%d): breakpoint set at %x: %x (pc %x) br %x\n", 		p->p_comm, p->p_pid, p->p_md.md_ss_addr, 		p->p_md.md_ss_instr, locr0[PC], fuword((caddr_t)va));
comment|/* XXX */
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|kdbpeek
argument_list|(
argument|addr
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|addr
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"kdbpeek: unaligned address %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MIPS_JR_RA
value|0x03e00008
end_define

begin_comment
comment|/* instruction code for jr ra */
end_comment

begin_comment
comment|/*  * Print a stack backtrace.  */
end_comment

begin_function
name|void
name|stacktrace
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
name|int
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
block|{
name|unsigned
name|pc
decl_stmt|,
name|sp
decl_stmt|,
name|fp
decl_stmt|,
name|ra
decl_stmt|,
name|va
decl_stmt|,
name|subr
decl_stmt|;
name|unsigned
name|instr
decl_stmt|,
name|mask
decl_stmt|;
name|InstFmt
name|i
decl_stmt|;
name|int
name|more
decl_stmt|,
name|stksize
decl_stmt|;
name|int
name|regs
index|[
literal|3
index|]
decl_stmt|;
extern|extern setsoftclock(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|char
name|start
index|[]
decl_stmt|,
name|edata
index|[]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|cpu_getregs
argument_list|(
name|regs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* get initial values from the exception frame */
end_comment

begin_expr_stmt
name|sp
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pc
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ra
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
end_expr_stmt

begin_label
name|loop
label|:
end_label

begin_comment
comment|/* check for current PC in the kernel interrupt handler code */
end_comment

begin_if
if|if
condition|(
name|pc
operator|>=
operator|(
name|unsigned
operator|)
name|MachKernIntr
operator|&&
name|pc
operator|<
operator|(
name|unsigned
operator|)
name|MachUserIntr
condition|)
block|{
comment|/* NOTE: the offsets depend on the code in locore.s */
name|printf
argument_list|(
literal|"interrupt\n"
argument_list|)
expr_stmt|;
name|a0
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|36
argument_list|)
expr_stmt|;
name|a1
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|40
argument_list|)
expr_stmt|;
name|a2
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|44
argument_list|)
expr_stmt|;
name|a3
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|48
argument_list|)
expr_stmt|;
name|pc
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|20
argument_list|)
expr_stmt|;
name|ra
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|92
argument_list|)
expr_stmt|;
name|sp
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|100
argument_list|)
expr_stmt|;
name|fp
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
literal|104
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check for current PC in the exception handler code */
end_comment

begin_if
if|if
condition|(
name|pc
operator|>=
literal|0x80000000
operator|&&
name|pc
operator|<
operator|(
name|unsigned
operator|)
name|setsoftclock
condition|)
block|{
name|ra
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_if

begin_comment
comment|/* check for bad PC */
end_comment

begin_if
if|if
condition|(
name|pc
operator|&
literal|3
operator|||
name|pc
operator|<
literal|0x80000000
operator|||
name|pc
operator|>=
operator|(
name|unsigned
operator|)
name|edata
condition|)
block|{
name|printf
argument_list|(
literal|"PC 0x%x: not in kernel\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
name|subr
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_if

begin_comment
comment|/* 	 * Find the beginning of the current subroutine by scanning backwards 	 * from the current PC for the end of the previous subroutine. 	 */
end_comment

begin_expr_stmt
name|va
operator|=
name|pc
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbpeek
argument_list|(
name|va
argument_list|)
operator|)
operator|!=
name|MIPS_JR_RA
condition|)
name|va
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|va
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* skip back over branch& delay slot */
end_comment

begin_comment
comment|/* skip over nulls which might separate .o files */
end_comment

begin_while
while|while
condition|(
operator|(
name|instr
operator|=
name|kdbpeek
argument_list|(
name|va
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|subr
operator|=
name|va
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* scan forwards to find stack size and any saved registers */
end_comment

begin_expr_stmt
name|stksize
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|more
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mask
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|more
condition|;
name|va
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|,
name|more
operator|=
operator|(
name|more
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
name|more
operator|-
literal|1
control|)
block|{
comment|/* stop if hit our current position */
if|if
condition|(
name|va
operator|>=
name|pc
condition|)
break|break;
name|instr
operator|=
name|kdbpeek
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|i
operator|.
name|word
operator|=
name|instr
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|JType
operator|.
name|op
condition|)
block|{
case|case
name|OP_SPECIAL
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|func
condition|)
block|{
case|case
name|OP_JR
case|:
case|case
name|OP_JALR
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_SYSCALL
case|:
case|case
name|OP_BREAK
case|:
name|more
operator|=
literal|1
expr_stmt|;
comment|/* stop now */
block|}
empty_stmt|;
break|break;
case|case
name|OP_BCOND
case|:
case|case
name|OP_J
case|:
case|case
name|OP_JAL
case|:
case|case
name|OP_BEQ
case|:
case|case
name|OP_BNE
case|:
case|case
name|OP_BLEZ
case|:
case|case
name|OP_BGTZ
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
break|break;
case|case
name|OP_COP0
case|:
case|case
name|OP_COP1
case|:
case|case
name|OP_COP2
case|:
case|case
name|OP_COP3
case|:
switch|switch
condition|(
name|i
operator|.
name|RType
operator|.
name|rs
condition|)
block|{
case|case
name|OP_BCx
case|:
case|case
name|OP_BCy
case|:
name|more
operator|=
literal|2
expr_stmt|;
comment|/* stop after next instruction */
block|}
empty_stmt|;
break|break;
case|case
name|OP_SW
case|:
comment|/* look for saved registers on the stack */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
condition|)
break|break;
comment|/* only restore the first one */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
operator|)
condition|)
break|break;
name|mask
operator||=
literal|1
operator|<<
name|i
operator|.
name|IType
operator|.
name|rt
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|IType
operator|.
name|rt
condition|)
block|{
case|case
literal|4
case|:
comment|/* a0 */
name|a0
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* a1 */
name|a1
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* a2 */
name|a2
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* a3 */
name|a3
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
comment|/* fp */
name|fp
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ra */
name|ra
operator|=
name|kdbpeek
argument_list|(
name|sp
operator|+
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ADDI
case|:
case|case
name|OP_ADDIU
case|:
comment|/* look for stack pointer adjustment */
if|if
condition|(
name|i
operator|.
name|IType
operator|.
name|rs
operator|!=
literal|29
operator|||
name|i
operator|.
name|IType
operator|.
name|rt
operator|!=
literal|29
condition|)
break|break;
name|stksize
operator|=
operator|(
name|short
operator|)
name|i
operator|.
name|IType
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_for

begin_label
name|done
label|:
end_label

begin_expr_stmt
name|printf
argument_list|(
literal|"%x+%x (%x,%x,%x,%x) ra %x sz %d\n"
argument_list|,
name|subr
argument_list|,
name|pc
operator|-
name|subr
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|ra
argument_list|,
name|stksize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ra
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|ra
operator|&&
name|stksize
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"stacktrace: loop!\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|pc
operator|=
name|ra
expr_stmt|;
name|sp
operator|-=
name|stksize
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
end_if

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

