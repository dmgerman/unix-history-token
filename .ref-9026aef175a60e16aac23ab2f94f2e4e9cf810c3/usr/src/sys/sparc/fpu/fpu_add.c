begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)fpu_add.c	8.1 (Berkeley) %G%  *  * from: $Header: fpu_add.c,v 1.4 92/11/26 01:39:46 torek Exp $  */
end_comment

begin_comment
comment|/*  * Perform an FPU add (return x + y).  *  * To subtract, negate y and call add.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sparc/fpu/fpu_arith.h>
end_include

begin_include
include|#
directive|include
file|<sparc/fpu/fpu_emu.h>
end_include

begin_function
name|struct
name|fpn
modifier|*
name|fpu_add
parameter_list|(
name|fe
parameter_list|)
specifier|register
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
block|{
specifier|register
name|struct
name|fpn
modifier|*
name|x
init|=
operator|&
name|fe
operator|->
name|fe_f1
decl_stmt|,
modifier|*
name|y
init|=
operator|&
name|fe
operator|->
name|fe_f2
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|u_int
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|;
specifier|register
name|int
name|rd
decl_stmt|;
comment|/* 	 * Put the `heavier' operand on the right (see fpu_emu.h). 	 * Then we will have one of the following cases, taken in the 	 * following order: 	 * 	 *  - y = NaN.  Implied: if only one is a signalling NaN, y is. 	 *	The result is y. 	 *  - y = Inf.  Implied: x != NaN (is 0, number, or Inf: the NaN 	 *    case was taken care of earlier). 	 *	If x = -y, the result is NaN.  Otherwise the result 	 *	is y (an Inf of whichever sign). 	 *  - y is 0.  Implied: x = 0. 	 *	If x and y differ in sign (one positive, one negative), 	 *	the result is +0 except when rounding to -Inf.  If same: 	 *	+0 + +0 = +0; -0 + -0 = -0. 	 *  - x is 0.  Implied: y != 0. 	 *	Result is y. 	 *  - other.  Implied: both x and y are numbers. 	 *	Do addition a la Hennessey& Patterson. 	 */
name|ORDER
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISNAN
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|ISINF
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINF
argument_list|(
name|x
argument_list|)
operator|&&
name|x
operator|->
name|fp_sign
operator|!=
name|y
operator|->
name|fp_sign
condition|)
return|return
operator|(
name|fpu_newnan
argument_list|(
name|fe
argument_list|)
operator|)
return|;
return|return
operator|(
name|y
operator|)
return|;
block|}
name|rd
operator|=
operator|(
operator|(
name|fe
operator|->
name|fe_fsr
operator|>>
name|FSR_RD_SHIFT
operator|)
operator|&
name|FSR_RD_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|ISZERO
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|rd
operator|!=
name|FSR_RD_RM
condition|)
comment|/* only -0 + -0 gives -0 */
name|y
operator|->
name|fp_sign
operator|&=
name|x
operator|->
name|fp_sign
expr_stmt|;
else|else
comment|/* any -0 operand gives -0 */
name|y
operator|->
name|fp_sign
operator||=
name|x
operator|->
name|fp_sign
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|ISZERO
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* 	 * We really have two numbers to add, although their signs may 	 * differ.  Make the exponents match, by shifting the smaller 	 * number right (e.g., 1.011 => 0.1011) and increasing its 	 * exponent (2^3 => 2^4).  Note that we do not alter the exponents 	 * of x and y here. 	 */
name|r
operator|=
operator|&
name|fe
operator|->
name|fe_f3
expr_stmt|;
name|r
operator|->
name|fp_class
operator|=
name|FPC_NUM
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|fp_exp
operator|==
name|y
operator|->
name|fp_exp
condition|)
block|{
name|r
operator|->
name|fp_exp
operator|=
name|x
operator|->
name|fp_exp
expr_stmt|;
name|r
operator|->
name|fp_sticky
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|->
name|fp_exp
operator|<
name|y
operator|->
name|fp_exp
condition|)
block|{
comment|/* 			 * Try to avoid subtract case iii (see below). 			 * This also guarantees that x->fp_sticky = 0. 			 */
name|SWAP
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* now x->fp_exp> y->fp_exp */
name|r
operator|->
name|fp_exp
operator|=
name|x
operator|->
name|fp_exp
expr_stmt|;
name|r
operator|->
name|fp_sticky
operator|=
name|fpu_shr
argument_list|(
name|y
argument_list|,
name|x
operator|->
name|fp_exp
operator|-
name|y
operator|->
name|fp_exp
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|fp_sign
operator|=
name|x
operator|->
name|fp_sign
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|fp_sign
operator|==
name|y
operator|->
name|fp_sign
condition|)
block|{
name|FPU_DECL_CARRY
comment|/* 		 * The signs match, so we simply add the numbers.  The result 		 * may be `supernormal' (as big as 1.111...1 + 1.111...1, or 		 * 11.111...0).  If so, a single bit shift-right will fix it 		 * (but remember to adjust the exponent). 		 */
comment|/* r->fp_mant = x->fp_mant + y->fp_mant */
name|FPU_ADDS
argument_list|(
name|r
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|FPU_ADDCS
argument_list|(
name|r
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|FPU_ADDCS
argument_list|(
name|r
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FPU_ADDC
argument_list|(
name|r0
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|0
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|=
name|r0
operator|)
operator|>=
name|FP_2
condition|)
block|{
operator|(
name|void
operator|)
name|fpu_shr
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|fp_exp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|FPU_DECL_CARRY
comment|/* 		 * The signs differ, so things are rather more difficult. 		 * H&P would have us negate the negative operand and add; 		 * this is the same as subtracting the negative operand. 		 * This is quite a headache.  Instead, we will subtract 		 * y from x, regardless of whether y itself is the negative 		 * operand.  When this is done one of three conditions will 		 * hold, depending on the magnitudes of x and y: 		 *   case i)   |x|> |y|.  The result is just x - y, 		 *	with x's sign, but it may need to be normalized. 		 *   case ii)  |x| = |y|.  The result is 0 (maybe -0) 		 *	so must be fixed up. 		 *   case iii) |x|< |y|.  We goofed; the result should 		 *	be (y - x), with the same sign as y. 		 * We could compare |x| and |y| here and avoid case iii, 		 * but that would take just as much work as the subtract. 		 * We can tell case iii has occurred by an overflow. 		 * 		 * N.B.: since x->fp_exp>= y->fp_exp, x->fp_sticky = 0. 		 */
comment|/* r->fp_mant = x->fp_mant - y->fp_mant */
name|FPU_SET_CARRY
argument_list|(
name|y
operator|->
name|fp_sticky
argument_list|)
decl_stmt|;
name|FPU_SUBCS
argument_list|(
name|r3
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|FPU_SUBCS
argument_list|(
name|r2
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|FPU_SUBCS
argument_list|(
name|r1
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FPU_SUBC
argument_list|(
name|r0
argument_list|,
name|x
operator|->
name|fp_mant
index|[
literal|0
index|]
argument_list|,
name|y
operator|->
name|fp_mant
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r0
operator|<
name|FP_2
condition|)
block|{
comment|/* cases i and ii */
if|if
condition|(
operator|(
name|r0
operator||
name|r1
operator||
name|r2
operator||
name|r3
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* case ii */
name|r
operator|->
name|fp_class
operator|=
name|FPC_ZERO
expr_stmt|;
name|r
operator|->
name|fp_sign
operator|=
name|rd
operator|==
name|FSR_RD_RM
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Oops, case iii.  This can only occur when the 			 * exponents were equal, in which case neither 			 * x nor y have sticky bits set.  Flip the sign 			 * (to y's sign) and negate the result to get y - x. 			 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|x
operator|->
name|fp_exp
operator|!=
name|y
operator|->
name|fp_exp
operator|||
name|r
operator|->
name|fp_sticky
condition|)
name|panic
argument_list|(
literal|"fpu_add"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|fp_sign
operator|=
name|y
operator|->
name|fp_sign
expr_stmt|;
name|FPU_SUBS
argument_list|(
name|r3
argument_list|,
literal|0
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|FPU_SUBCS
argument_list|(
name|r2
argument_list|,
literal|0
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|FPU_SUBCS
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|FPU_SUBC
argument_list|(
name|r0
argument_list|,
literal|0
argument_list|,
name|r0
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|=
name|r3
expr_stmt|;
name|r
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|=
name|r2
expr_stmt|;
name|r
operator|->
name|fp_mant
index|[
literal|1
index|]
operator|=
name|r1
expr_stmt|;
name|r
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|=
name|r0
expr_stmt|;
if|if
condition|(
name|r0
operator|<
name|FP_1
condition|)
name|fpu_norm
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

