begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: grf_machdep.c 1.1 92/01/21  *  *	@(#)grf_machdep.c	8.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Graphics display driver for the HP300/400 DIO/DIO-II based machines.  * This is the hardware-dependent configuration portion of the driver.  */
end_comment

begin_include
include|#
directive|include
file|"grf.h"
end_include

begin_if
if|#
directive|if
name|NGRF
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/grfioctl.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/grfvar.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/grfreg.h>
end_include

begin_function_decl
name|int
name|grfprobe
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|grfdriver
init|=
block|{
name|grfprobe
block|,
literal|"grf"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX called from ite console init routine.  * Does just what configure will do later but without printing anything.  */
end_comment

begin_macro
name|grfconfig
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|struct
name|hp_hw
modifier|*
name|hw
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|,
modifier|*
name|nhd
decl_stmt|;
for|for
control|(
name|hw
operator|=
name|sc_table
init|;
name|hw
operator|->
name|hw_type
condition|;
name|hw
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|HW_ISDEV
argument_list|(
name|hw
argument_list|,
name|D_BITMAP
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Found one, now match up with a logical unit number 		 */
name|nhd
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|hw
operator|->
name|hw_kva
expr_stmt|;
for|for
control|(
name|hd
operator|=
name|hp_dinit
init|;
name|hd
operator|->
name|hp_driver
condition|;
name|hd
operator|++
control|)
block|{
if|if
condition|(
name|hd
operator|->
name|hp_driver
operator|!=
operator|&
name|grfdriver
operator|||
name|hd
operator|->
name|hp_alive
condition|)
continue|continue;
comment|/* 			 * Wildcarded.  If first, remember as possible match. 			 */
if|if
condition|(
name|hd
operator|->
name|hp_addr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nhd
operator|==
name|NULL
condition|)
name|nhd
operator|=
name|hd
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Not wildcarded. 			 * If exact match done searching, else keep looking. 			 */
if|if
condition|(
name|sctova
argument_list|(
name|hd
operator|->
name|hp_addr
argument_list|)
operator|==
name|addr
condition|)
block|{
name|nhd
operator|=
name|hd
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Found a match, initialize 		 */
if|if
condition|(
name|nhd
operator|&&
name|grfinit
argument_list|(
name|addr
argument_list|,
name|nhd
operator|->
name|hp_unit
argument_list|)
condition|)
name|nhd
operator|->
name|hp_addr
operator|=
name|addr
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Normal init routine called by configure() code  */
end_comment

begin_macro
name|grfprobe
argument_list|(
argument|hd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|grf_softc
modifier|*
name|gp
init|=
operator|&
name|grf_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|gp
operator|->
name|g_flags
operator|&
name|GF_ALIVE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|grfinit
argument_list|(
name|hd
operator|->
name|hp_addr
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"grf%d: %d x %d "
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
name|gp
operator|->
name|g_display
operator|.
name|gd_dwidth
argument_list|,
name|gp
operator|->
name|g_display
operator|.
name|gd_dheight
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|g_display
operator|.
name|gd_colors
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"monochrome"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d color"
argument_list|,
name|gp
operator|->
name|g_display
operator|.
name|gd_colors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s display\n"
argument_list|,
name|gp
operator|->
name|g_sw
operator|->
name|gd_desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|grfinit
argument_list|(
argument|addr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|grf_softc
modifier|*
name|gp
init|=
operator|&
name|grf_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|grfsw
modifier|*
name|gsw
decl_stmt|;
name|struct
name|grfreg
modifier|*
name|gr
decl_stmt|;
name|gr
operator|=
operator|(
expr|struct
name|grfreg
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_id
operator|!=
name|GRFHWID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|gsw
operator|=
name|grfsw
init|;
name|gsw
operator|<
operator|&
name|grfsw
index|[
name|ngrfsw
index|]
condition|;
name|gsw
operator|++
control|)
if|if
condition|(
name|gsw
operator|->
name|gd_hwid
operator|==
name|gr
operator|->
name|gr_id2
condition|)
break|break;
if|if
condition|(
name|gsw
operator|<
operator|&
name|grfsw
index|[
name|ngrfsw
index|]
operator|&&
call|(
modifier|*
name|gsw
operator|->
name|gd_init
call|)
argument_list|(
name|gp
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|gp
operator|->
name|g_sw
operator|=
name|gsw
expr_stmt|;
name|gp
operator|->
name|g_display
operator|.
name|gd_id
operator|=
name|gsw
operator|->
name|gd_swid
expr_stmt|;
name|gp
operator|->
name|g_flags
operator|=
name|GF_ALIVE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

