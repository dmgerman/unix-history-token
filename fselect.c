begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: fselect.c,v 1.93 2012/12/30 20:52:25 tom Exp $  *  *  fselect.c -- implements the file-selector box  *  *  Copyright 2000-2011,2012	Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|NAMLEN
parameter_list|(
name|dirent
parameter_list|)
value|strlen((dirent)->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_define
define|#
directive|define
name|NAMLEN
parameter_list|(
name|dirent
parameter_list|)
value|(dirent)->d_namlen
end_define

begin_if
if|#
directive|if
name|HAVE_SYS_NDIR_H
end_if

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_DIR_H
end_if

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_NDIR_H
end_if

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_FILE_OFFSET_BITS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_STRUCT_DIRENT64
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|&&
operator|(
name|_FILE_OFFSET_BITS
operator|==
literal|64
operator|)
end_if

begin_define
define|#
directive|define
name|DIRENT
value|struct dirent64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DIRENT
value|struct dirent
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DIRENT
value|struct dirent
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EXT_WIDE
value|1
end_define

begin_define
define|#
directive|define
name|HDR_HIGH
value|1
end_define

begin_define
define|#
directive|define
name|BTN_HIGH
value|(1 + 2 * MARGIN)
end_define

begin_comment
comment|/* Ok/Cancel, also input-box */
end_comment

begin_define
define|#
directive|define
name|MIN_HIGH
value|(HDR_HIGH - MARGIN + (BTN_HIGH * 2) + 4 * MARGIN)
end_define

begin_define
define|#
directive|define
name|MIN_WIDE
value|(2 * MAX(dlg_count_columns(d_label), dlg_count_columns(f_label)) + 6 * MARGIN + 2 * EXT_WIDE)
end_define

begin_define
define|#
directive|define
name|MOUSE_D
value|(KEY_MAX + 0)
end_define

begin_define
define|#
directive|define
name|MOUSE_F
value|(KEY_MAX + 10000)
end_define

begin_define
define|#
directive|define
name|MOUSE_T
value|(KEY_MAX + 20000)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|sDIRS
init|=
operator|-
literal|3
block|,
name|sFILES
init|=
operator|-
literal|2
block|,
name|sTEXT
init|=
operator|-
literal|1
block|}
name|STATES
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|WINDOW
modifier|*
name|par
decl_stmt|;
comment|/* parent window */
name|WINDOW
modifier|*
name|win
decl_stmt|;
comment|/* this window */
name|int
name|length
decl_stmt|;
comment|/* length of the data[] array */
name|int
name|offset
decl_stmt|;
comment|/* index of first item on screen */
name|int
name|choice
decl_stmt|;
comment|/* index of the selection */
name|int
name|mousex
decl_stmt|;
comment|/* base of mouse-code return-values */
name|unsigned
name|allocd
decl_stmt|;
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
block|}
name|LIST
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
block|}
name|MATCH
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|init_list
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|,
name|WINDOW
modifier|*
name|par
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|mousex
parameter_list|)
block|{
name|list
operator|->
name|par
operator|=
name|par
expr_stmt|;
name|list
operator|->
name|win
operator|=
name|win
expr_stmt|;
name|list
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|choice
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|mousex
operator|=
name|mousex
expr_stmt|;
name|list
operator|->
name|allocd
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|dlg_mouse_mkbigregion
argument_list|(
name|getbegy
argument_list|(
name|win
argument_list|)
argument_list|,
name|getbegx
argument_list|(
name|win
argument_list|)
argument_list|,
name|getmaxy
argument_list|(
name|win
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|win
argument_list|)
argument_list|,
name|mousex
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
comment|/* by lines */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|leaf_of
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|leaf
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaf
operator|!=
literal|0
condition|)
name|leaf
operator|++
expr_stmt|;
else|else
name|leaf
operator|=
name|path
expr_stmt|;
return|return
name|leaf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|data_of
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
literal|0
operator|&&
name|list
operator|->
name|data
operator|!=
literal|0
condition|)
return|return
name|list
operator|->
name|data
index|[
name|list
operator|->
name|choice
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_list
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|,
name|int
name|reinit
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|data
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|list
operator|->
name|data
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
name|free
argument_list|(
name|list
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
name|list
operator|->
name|data
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|reinit
condition|)
name|init_list
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|par
argument_list|,
name|list
operator|->
name|win
argument_list|,
name|list
operator|->
name|mousex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_to_list
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|unsigned
name|need
decl_stmt|;
name|need
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|list
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|need
operator|+
literal|1
operator|>
name|list
operator|->
name|allocd
condition|)
block|{
name|list
operator|->
name|allocd
operator|=
literal|2
operator|*
operator|(
name|need
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|data
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|data
operator|=
name|dlg_malloc
argument_list|(
name|char
operator|*
argument_list|,
name|list
operator|->
name|allocd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|->
name|data
operator|=
name|dlg_realloc
argument_list|(
name|char
operator|*
argument_list|,
name|list
operator|->
name|allocd
argument_list|,
name|list
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|assert_ptr
argument_list|(
name|list
operator|->
name|data
argument_list|,
literal|"add_to_list"
argument_list|)
expr_stmt|;
block|}
name|list
operator|->
name|data
index|[
name|list
operator|->
name|length
operator|++
index|]
operator|=
name|dlg_strclone
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|list
operator|->
name|data
index|[
name|list
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keep_visible
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|high
init|=
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|choice
operator|<
name|list
operator|->
name|offset
condition|)
block|{
name|list
operator|->
name|offset
operator|=
name|list
operator|->
name|choice
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|->
name|choice
operator|-
name|list
operator|->
name|offset
operator|>=
name|high
condition|)
name|list
operator|->
name|offset
operator|=
name|list
operator|->
name|choice
operator|-
name|high
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|Value
parameter_list|(
name|c
parameter_list|)
value|(int)((c)& 0xff)
end_define

begin_function
specifier|static
name|int
name|find_choice
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|choice
init|=
name|list
operator|->
name|choice
decl_stmt|;
name|int
name|len_1
decl_stmt|,
name|len_2
decl_stmt|,
name|cmp_1
decl_stmt|,
name|cmp_2
decl_stmt|;
if|if
condition|(
operator|*
name|target
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|choice
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* find the match with the longest length.  If more than one has the 	 * same length, choose the one with the closest match of the final 	 * character. 	 */
name|len_1
operator|=
literal|0
expr_stmt|;
name|cmp_1
operator|=
literal|256
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|list
operator|->
name|length
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
name|a
init|=
name|target
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|list
operator|->
name|data
index|[
name|n
index|]
decl_stmt|;
name|len_2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|a
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|b
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|a
operator|==
operator|*
name|b
operator|)
condition|)
block|{
name|a
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|len_2
operator|++
expr_stmt|;
block|}
name|cmp_2
operator|=
name|Value
argument_list|(
operator|*
name|a
argument_list|)
operator|-
name|Value
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_2
operator|<
literal|0
condition|)
name|cmp_2
operator|=
operator|-
name|cmp_2
expr_stmt|;
if|if
condition|(
operator|(
name|len_2
operator|>
name|len_1
operator|)
operator|||
operator|(
name|len_1
operator|==
name|len_2
operator|&&
name|cmp_2
operator|<
name|cmp_1
operator|)
condition|)
block|{
name|len_1
operator|=
name|len_2
expr_stmt|;
name|cmp_1
operator|=
name|cmp_2
expr_stmt|;
name|list
operator|->
name|choice
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|choice
operator|!=
name|list
operator|->
name|choice
condition|)
block|{
name|keep_visible
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|choice
operator|!=
name|list
operator|->
name|choice
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_list
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|bottom
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|win
operator|!=
literal|0
condition|)
block|{
name|dlg_attr_clear
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|list
operator|->
name|win
argument_list|)
argument_list|,
name|item_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|list
operator|->
name|offset
init|;
name|n
operator|<
name|list
operator|->
name|length
operator|&&
name|list
operator|->
name|data
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|y
operator|=
name|n
operator|-
name|list
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
condition|)
break|break;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|list
operator|->
name|choice
condition|)
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|item_selected_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|list
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|item_attr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|item_attr
argument_list|)
expr_stmt|;
name|getparyx
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|top
operator|=
name|y
operator|-
literal|1
expr_stmt|;
name|bottom
operator|=
name|y
operator|+
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
expr_stmt|;
name|dlg_draw_scrollbar
argument_list|(
name|list
operator|->
name|par
argument_list|,
operator|(
name|long
operator|)
name|list
operator|->
name|offset
argument_list|,
operator|(
name|long
operator|)
name|list
operator|->
name|offset
argument_list|,
call|(
name|long
call|)
argument_list|(
name|list
operator|->
name|offset
operator|+
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|list
operator|->
name|length
argument_list|)
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|x
operator|+
name|getmaxx
argument_list|(
name|list
operator|->
name|win
argument_list|)
argument_list|,
name|top
argument_list|,
name|bottom
argument_list|,
name|menubox_border2_attr
argument_list|,
name|menubox_border_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|list
operator|->
name|choice
operator|-
name|list
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wnoutrefresh
argument_list|(
name|list
operator|->
name|win
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME: see arrows.c  * This workaround is used to allow two lists to have scroll-tabs at the same  * time, by reassigning their return-values to be different.  Just for  * readability, we use the names of keys with similar connotations, though all  * that is really required is that they're distinct, so we can put them in a  * switch statement.  */
end_comment

begin_function
specifier|static
name|void
name|fix_arrows
parameter_list|(
name|LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|right
decl_stmt|;
name|int
name|bottom
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|win
operator|!=
literal|0
condition|)
block|{
name|getparyx
argument_list|(
name|list
operator|->
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|top
operator|=
name|y
operator|-
literal|1
expr_stmt|;
name|right
operator|=
name|getmaxx
argument_list|(
name|list
operator|->
name|win
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|y
operator|+
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
expr_stmt|;
name|mouse_mkbutton
argument_list|(
name|top
argument_list|,
name|x
argument_list|,
name|right
argument_list|,
operator|(
operator|(
name|list
operator|->
name|mousex
operator|==
name|MOUSE_D
operator|)
condition|?
name|KEY_PREVIOUS
else|:
name|KEY_PPAGE
operator|)
argument_list|)
expr_stmt|;
name|mouse_mkbutton
argument_list|(
name|bottom
argument_list|,
name|x
argument_list|,
name|right
argument_list|,
operator|(
operator|(
name|list
operator|->
name|mousex
operator|==
name|MOUSE_D
operator|)
condition|?
name|KEY_NEXT
else|:
name|KEY_NPAGE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|show_list
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|LIST
modifier|*
name|list
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
name|int
name|changed
init|=
name|keep
operator|||
name|find_choice
argument_list|(
name|target
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|display_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/*  * Highlight the closest match to 'target' in the given list, setting offset  * to match.  */
end_comment

begin_function
specifier|static
name|int
name|show_both_lists
parameter_list|(
name|char
modifier|*
name|input
parameter_list|,
name|LIST
modifier|*
name|d_list
parameter_list|,
name|LIST
modifier|*
name|f_list
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
name|char
modifier|*
name|leaf
init|=
name|leaf_of
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|show_list
argument_list|(
name|leaf
argument_list|,
name|d_list
argument_list|,
name|keep
argument_list|)
operator||
name|show_list
argument_list|(
name|leaf
argument_list|,
name|f_list
argument_list|,
name|keep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move up/down in the given list  */
end_comment

begin_function
specifier|static
name|bool
name|change_list
parameter_list|(
name|int
name|choice
parameter_list|,
name|LIST
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|data_of
argument_list|(
name|list
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|last
init|=
name|list
operator|->
name|length
operator|-
literal|1
decl_stmt|;
name|choice
operator|+=
name|list
operator|->
name|choice
expr_stmt|;
if|if
condition|(
name|choice
operator|<
literal|0
condition|)
name|choice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|choice
operator|>
name|last
condition|)
name|choice
operator|=
name|last
expr_stmt|;
name|list
operator|->
name|choice
operator|=
name|choice
expr_stmt|;
name|keep_visible
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|display_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scroll_list
parameter_list|(
name|int
name|direction
parameter_list|,
name|LIST
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|data_of
argument_list|(
name|list
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|length
init|=
name|getmaxy
argument_list|(
name|list
operator|->
name|win
argument_list|)
decl_stmt|;
if|if
condition|(
name|change_list
argument_list|(
name|direction
operator|*
name|length
argument_list|,
name|list
argument_list|)
condition|)
return|return;
block|}
name|beep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|compar
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|a
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|b
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|match
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LIST
modifier|*
name|d_list
parameter_list|,
name|LIST
modifier|*
name|f_list
parameter_list|,
name|MATCH
modifier|*
name|match_list
parameter_list|)
block|{
name|char
modifier|*
name|test
init|=
name|leaf_of
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|size_t
name|test_len
init|=
name|strlen
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|matches
init|=
name|dlg_malloc
argument_list|(
name|char
operator|*
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|d_list
operator|->
name|length
operator|+
name|f_list
operator|->
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|data_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|d_list
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|test
argument_list|,
name|d_list
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|test_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|matches
index|[
name|data_len
operator|++
index|]
operator|=
name|d_list
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f_list
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|test
argument_list|,
name|f_list
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|test_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|matches
index|[
name|data_len
operator|++
index|]
operator|=
name|f_list
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|matches
operator|=
name|dlg_realloc
argument_list|(
name|char
operator|*
argument_list|,
name|data_len
operator|+
literal|1
argument_list|,
name|matches
argument_list|)
expr_stmt|;
name|match_list
operator|->
name|data
operator|=
name|matches
expr_stmt|;
name|match_list
operator|->
name|length
operator|=
operator|(
name|int
operator|)
name|data_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_match
parameter_list|(
name|MATCH
modifier|*
name|match_list
parameter_list|)
block|{
name|free
argument_list|(
name|match_list
operator|->
name|data
argument_list|)
expr_stmt|;
name|match_list
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|complete
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|LIST
modifier|*
name|d_list
parameter_list|,
name|LIST
modifier|*
name|f_list
parameter_list|,
name|char
modifier|*
modifier|*
name|buff_ptr
parameter_list|)
block|{
name|MATCH
name|match_list
decl_stmt|;
name|char
modifier|*
name|test
decl_stmt|;
name|size_t
name|test_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|match
argument_list|(
name|name
argument_list|,
name|d_list
argument_list|,
name|f_list
argument_list|,
operator|&
name|match_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_list
operator|.
name|length
operator|==
literal|0
condition|)
block|{
operator|*
name|buff_ptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|test
operator|=
name|match_list
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
name|test_len
operator|=
name|strlen
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|buff
operator|=
name|dlg_malloc
argument_list|(
name|char
argument_list|,
name|test_len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_list
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
name|test
argument_list|)
expr_stmt|;
name|i
operator|=
name|test_len
expr_stmt|;
if|if
condition|(
name|test
operator|==
name|data_of
argument_list|(
name|d_list
argument_list|)
condition|)
block|{
name|buff
index|[
name|test_len
index|]
operator|=
literal|'/'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|test_len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|test_char
init|=
name|test
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|test_char
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|match_list
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|match_list
operator|.
name|data
index|[
name|j
index|]
index|[
name|i
index|]
operator|!=
name|test_char
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
name|match_list
operator|.
name|length
condition|)
block|{
operator|(
name|buff
operator|)
index|[
name|i
index|]
operator|=
name|test_char
expr_stmt|;
block|}
else|else
break|break;
block|}
name|buff
operator|=
name|dlg_realloc
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
name|free_match
argument_list|(
operator|&
name|match_list
argument_list|)
expr_stmt|;
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|buff_ptr
operator|=
name|buff
expr_stmt|;
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|fill_lists
parameter_list|(
name|char
modifier|*
name|current
parameter_list|,
name|char
modifier|*
name|input
parameter_list|,
name|LIST
modifier|*
name|d_list
parameter_list|,
name|LIST
modifier|*
name|f_list
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
name|bool
name|rescan
init|=
name|FALSE
decl_stmt|;
name|DIR
modifier|*
name|dp
decl_stmt|;
name|DIRENT
modifier|*
name|de
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|path
index|[
name|MAX_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|leaf
decl_stmt|;
comment|/* check if we've updated the lists */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|current
index|[
name|n
index|]
operator|&&
name|input
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|current
index|[
name|n
index|]
operator|!=
name|input
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|current
index|[
name|n
index|]
operator|==
name|input
index|[
name|n
index|]
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
name|rescan
operator|=
operator|(
name|n
operator|==
literal|0
operator|&&
name|d_list
operator|->
name|length
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|current
operator|+
name|n
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|input
operator|+
name|n
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|show_both_lists
argument_list|(
name|input
argument_list|,
name|d_list
argument_list|,
name|f_list
argument_list|,
name|keep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rescan
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|rescan
condition|)
block|{
name|size_t
name|have
init|=
name|strlen
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|have
operator|>
name|MAX_LEN
condition|)
name|have
operator|=
name|MAX_LEN
expr_stmt|;
name|memcpy
argument_list|(
name|current
argument_list|,
name|input
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|current
index|[
name|have
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* refill the lists */
name|free_list
argument_list|(
name|d_list
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|f_list
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|current
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|path
index|[
name|have
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|leaf
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
operator|++
name|leaf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|dlg_trace_msg
argument_list|(
literal|"opendir '%s'\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|leaf
argument_list|,
name|de
operator|->
name|d_name
argument_list|,
name|NAMLEN
argument_list|(
name|de
argument_list|)
argument_list|)
index|[
name|NAMLEN
argument_list|(
name|de
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
name|add_to_list
argument_list|(
name|d_list
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f_list
operator|->
name|win
condition|)
name|add_to_list
argument_list|(
name|f_list
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* sort the lists */
if|if
condition|(
name|d_list
operator|->
name|data
operator|!=
literal|0
operator|&&
name|d_list
operator|->
name|length
operator|>
literal|1
condition|)
block|{
name|qsort
argument_list|(
name|d_list
operator|->
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|d_list
operator|->
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|d_list
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_list
operator|->
name|data
operator|!=
literal|0
operator|&&
name|f_list
operator|->
name|length
operator|>
literal|1
condition|)
block|{
name|qsort
argument_list|(
name|f_list
operator|->
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|f_list
operator|->
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|f_list
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|show_both_lists
argument_list|(
name|input
argument_list|,
name|d_list
argument_list|,
name|f_list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|d_list
operator|->
name|offset
operator|=
name|d_list
operator|->
name|choice
expr_stmt|;
name|f_list
operator|->
name|offset
operator|=
name|f_list
operator|->
name|choice
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|usable_state
parameter_list|(
name|int
name|state
parameter_list|,
name|LIST
modifier|*
name|dirs
parameter_list|,
name|LIST
modifier|*
name|files
parameter_list|)
block|{
name|bool
name|result
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|sDIRS
case|:
name|result
operator|=
operator|(
name|dirs
operator|->
name|win
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|data_of
argument_list|(
name|dirs
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|sFILES
case|:
name|result
operator|=
operator|(
name|files
operator|->
name|win
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|data_of
argument_list|(
name|files
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|which_list
parameter_list|()
value|((state == sFILES) \ 			?&f_list \ 			: ((state == sDIRS) \ 			  ?&d_list \ 			  : 0))
end_define

begin_define
define|#
directive|define
name|NAVIGATE_BINDINGS
define|\
value|DLG_KEYS_DATA( DLGK_FIELD_NEXT, KEY_RIGHT ), \ 	DLG_KEYS_DATA( DLGK_FIELD_NEXT, TAB ), \ 	DLG_KEYS_DATA( DLGK_FIELD_PREV, KEY_BTAB ), \ 	DLG_KEYS_DATA( DLGK_ITEM_NEXT,  KEY_DOWN ), \ 	DLG_KEYS_DATA( DLGK_ITEM_NEXT,  CHR_NEXT ), \ 	DLG_KEYS_DATA( DLGK_ITEM_NEXT,  KEY_NEXT ), \ 	DLG_KEYS_DATA( DLGK_ITEM_PREV,  CHR_PREVIOUS ), \ 	DLG_KEYS_DATA( DLGK_ITEM_PREV,  KEY_UP ), \ 	DLG_KEYS_DATA( DLGK_PAGE_NEXT,  KEY_NPAGE ), \ 	DLG_KEYS_DATA( DLGK_PAGE_PREV,  KEY_PPAGE )
end_define

begin_comment
comment|/*  * Display a dialog box for entering a filename  */
end_comment

begin_function
specifier|static
name|int
name|dlg_fselect
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|dselect
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
name|DLG_KEYS_BINDING
name|binding
index|[]
init|=
block|{
name|HELPKEY_BINDINGS
block|,
name|ENTERKEY_BINDINGS
block|,
name|NAVIGATE_BINDINGS
block|,
name|END_KEYS_BINDING
block|}
decl_stmt|;
specifier|static
name|DLG_KEYS_BINDING
name|binding2
index|[]
init|=
block|{
name|INPUTSTR_BINDINGS
block|,
name|HELPKEY_BINDINGS
block|,
name|ENTERKEY_BINDINGS
block|,
name|NAVIGATE_BINDINGS
block|,
name|END_KEYS_BINDING
block|}
decl_stmt|;
comment|/* *INDENT-ON* */
ifdef|#
directive|ifdef
name|KEY_RESIZE
name|int
name|old_height
init|=
name|height
decl_stmt|;
name|int
name|old_width
init|=
name|width
decl_stmt|;
name|bool
name|resized
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|tbox_y
decl_stmt|,
name|tbox_x
decl_stmt|,
name|tbox_width
decl_stmt|,
name|tbox_height
decl_stmt|;
name|int
name|dbox_y
decl_stmt|,
name|dbox_x
decl_stmt|,
name|dbox_width
decl_stmt|,
name|dbox_height
decl_stmt|;
name|int
name|fbox_y
decl_stmt|,
name|fbox_x
decl_stmt|,
name|fbox_width
decl_stmt|,
name|fbox_height
decl_stmt|;
name|int
name|show_buttons
init|=
name|TRUE
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|key
init|=
literal|0
decl_stmt|;
name|int
name|fkey
init|=
name|FALSE
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|result
init|=
name|DLG_EXIT_UNKNOWN
decl_stmt|;
name|int
name|state
init|=
name|dialog_vars
operator|.
name|default_button
operator|>=
literal|0
condition|?
name|dlg_default_button
argument_list|()
else|:
name|sTEXT
decl_stmt|;
name|int
name|button
decl_stmt|;
name|int
name|first
init|=
operator|(
name|state
operator|==
name|sTEXT
operator|)
decl_stmt|;
name|int
name|first_trace
init|=
name|TRUE
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|completed
decl_stmt|;
name|char
name|current
index|[
name|MAX_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|dialog
init|=
literal|0
decl_stmt|;
name|WINDOW
modifier|*
name|w_text
init|=
literal|0
decl_stmt|;
name|WINDOW
modifier|*
name|w_work
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|buttons
init|=
name|dlg_ok_labels
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|d_label
init|=
name|_
argument_list|(
literal|"Directories"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|f_label
init|=
name|_
argument_list|(
literal|"Files"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|partial
init|=
literal|0
decl_stmt|;
name|int
name|min_wide
init|=
name|MIN_WIDE
decl_stmt|;
name|int
name|min_items
init|=
name|height
condition|?
literal|0
else|:
literal|4
decl_stmt|;
name|LIST
name|d_list
decl_stmt|,
name|f_list
decl_stmt|;
name|dlg_does_output
argument_list|()
expr_stmt|;
comment|/* Set up the initial value */
name|input
operator|=
name|dlg_set_result
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|input
argument_list|)
expr_stmt|;
operator|*
name|current
operator|=
literal|0
expr_stmt|;
name|dlg_button_layout
argument_list|(
name|buttons
argument_list|,
operator|&
name|min_wide
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KEY_RESIZE
name|retry
label|:
endif|#
directive|endif
name|dlg_auto_size
argument_list|(
name|title
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|width
argument_list|,
literal|6
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|height
operator|+=
name|MIN_HIGH
operator|+
name|min_items
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|min_wide
condition|)
name|width
operator|=
name|min_wide
expr_stmt|;
name|dlg_print_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|dlg_ctl_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|dialog
operator|=
name|dlg_new_window
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
name|dlg_box_y_ordinate
argument_list|(
name|height
argument_list|)
argument_list|,
name|dlg_box_x_ordinate
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|dlg_register_window
argument_list|(
name|dialog
argument_list|,
literal|"fselect"
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|dlg_register_buttons
argument_list|(
name|dialog
argument_list|,
literal|"fselect"
argument_list|,
name|buttons
argument_list|)
expr_stmt|;
name|dlg_mouse_setbase
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dlg_draw_box2
argument_list|(
name|dialog
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|dialog_attr
argument_list|,
name|border_attr
argument_list|,
name|border2_attr
argument_list|)
expr_stmt|;
name|dlg_draw_bottom_box2
argument_list|(
name|dialog
argument_list|,
name|border_attr
argument_list|,
name|border2_attr
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
name|dlg_draw_title
argument_list|(
name|dialog
argument_list|,
name|title
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|dialog
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
comment|/* Draw the input field box */
name|tbox_height
operator|=
literal|1
expr_stmt|;
name|tbox_width
operator|=
name|width
operator|-
operator|(
literal|4
operator|*
name|MARGIN
operator|+
literal|2
operator|)
expr_stmt|;
name|tbox_y
operator|=
name|height
operator|-
operator|(
name|BTN_HIGH
operator|*
literal|2
operator|)
operator|+
name|MARGIN
expr_stmt|;
name|tbox_x
operator|=
operator|(
name|width
operator|-
name|tbox_width
operator|)
operator|/
literal|2
expr_stmt|;
name|w_text
operator|=
name|derwin
argument_list|(
name|dialog
argument_list|,
name|tbox_height
argument_list|,
name|tbox_width
argument_list|,
name|tbox_y
argument_list|,
name|tbox_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|w_text
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_ERROR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|w_text
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dlg_draw_box
argument_list|(
name|dialog
argument_list|,
name|tbox_y
operator|-
name|MARGIN
argument_list|,
name|tbox_x
operator|-
name|MARGIN
argument_list|,
operator|(
literal|2
operator|*
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|tbox_width
operator|+
operator|(
name|MARGIN
operator|+
name|EXT_WIDE
operator|)
argument_list|,
name|menubox_border_attr
argument_list|,
name|menubox_border2_attr
argument_list|)
expr_stmt|;
name|dlg_mouse_mkbigregion
argument_list|(
name|getbegy
argument_list|(
name|dialog
argument_list|)
operator|+
name|tbox_y
operator|-
name|MARGIN
argument_list|,
name|getbegx
argument_list|(
name|dialog
argument_list|)
operator|+
name|tbox_x
operator|-
name|MARGIN
argument_list|,
literal|1
operator|+
operator|(
literal|2
operator|*
name|MARGIN
operator|)
argument_list|,
name|tbox_width
operator|+
operator|(
name|MARGIN
operator|+
name|EXT_WIDE
operator|)
argument_list|,
name|MOUSE_T
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|3
comment|/* doesn't matter */
argument_list|)
expr_stmt|;
name|dlg_register_window
argument_list|(
name|w_text
argument_list|,
literal|"fselect2"
argument_list|,
name|binding2
argument_list|)
expr_stmt|;
comment|/* Draw the directory listing box */
if|if
condition|(
name|dselect
condition|)
name|dbox_width
operator|=
operator|(
name|width
operator|-
operator|(
literal|6
operator|*
name|MARGIN
operator|)
operator|)
expr_stmt|;
else|else
name|dbox_width
operator|=
operator|(
name|width
operator|-
operator|(
literal|6
operator|*
name|MARGIN
operator|+
literal|2
operator|*
name|EXT_WIDE
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|dbox_height
operator|=
name|height
operator|-
name|MIN_HIGH
expr_stmt|;
name|dbox_y
operator|=
operator|(
literal|2
operator|*
name|MARGIN
operator|+
literal|1
operator|)
expr_stmt|;
name|dbox_x
operator|=
name|tbox_x
expr_stmt|;
name|w_work
operator|=
name|derwin
argument_list|(
name|dialog
argument_list|,
name|dbox_height
argument_list|,
name|dbox_width
argument_list|,
name|dbox_y
argument_list|,
name|dbox_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|w_work
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_ERROR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|w_work
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddstr
argument_list|(
name|dialog
argument_list|,
name|dbox_y
operator|-
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|dbox_x
operator|-
name|MARGIN
argument_list|,
name|d_label
argument_list|)
expr_stmt|;
name|dlg_draw_box
argument_list|(
name|dialog
argument_list|,
name|dbox_y
operator|-
name|MARGIN
argument_list|,
name|dbox_x
operator|-
name|MARGIN
argument_list|,
name|dbox_height
operator|+
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|dbox_width
operator|+
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|menubox_border_attr
argument_list|,
name|menubox_border2_attr
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|d_list
argument_list|,
name|dialog
argument_list|,
name|w_work
argument_list|,
name|MOUSE_D
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dselect
condition|)
block|{
comment|/* Draw the filename listing box */
name|fbox_height
operator|=
name|dbox_height
expr_stmt|;
name|fbox_width
operator|=
name|dbox_width
expr_stmt|;
name|fbox_y
operator|=
name|dbox_y
expr_stmt|;
name|fbox_x
operator|=
name|tbox_x
operator|+
name|dbox_width
operator|+
operator|(
literal|2
operator|*
name|MARGIN
operator|)
expr_stmt|;
name|w_work
operator|=
name|derwin
argument_list|(
name|dialog
argument_list|,
name|fbox_height
argument_list|,
name|fbox_width
argument_list|,
name|fbox_y
argument_list|,
name|fbox_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|w_work
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_ERROR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|w_work
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddstr
argument_list|(
name|dialog
argument_list|,
name|fbox_y
operator|-
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|fbox_x
operator|-
name|MARGIN
argument_list|,
name|f_label
argument_list|)
expr_stmt|;
name|dlg_draw_box
argument_list|(
name|dialog
argument_list|,
name|fbox_y
operator|-
name|MARGIN
argument_list|,
name|fbox_x
operator|-
name|MARGIN
argument_list|,
name|fbox_height
operator|+
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|fbox_width
operator|+
operator|(
name|MARGIN
operator|+
literal|1
operator|)
argument_list|,
name|menubox_border_attr
argument_list|,
name|menubox_border2_attr
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|f_list
argument_list|,
name|dialog
argument_list|,
name|w_work
argument_list|,
name|MOUSE_F
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|f_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|f_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|==
name|DLG_EXIT_UNKNOWN
condition|)
block|{
if|if
condition|(
name|fill_lists
argument_list|(
name|current
argument_list|,
name|input
argument_list|,
operator|&
name|d_list
argument_list|,
operator|&
name|f_list
argument_list|,
name|state
operator|<
name|sTEXT
argument_list|)
condition|)
name|show_buttons
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|KEY_RESIZE
if|if
condition|(
name|resized
condition|)
block|{
name|resized
operator|=
name|FALSE
expr_stmt|;
name|dlg_show_string
argument_list|(
name|w_text
argument_list|,
name|input
argument_list|,
name|offset
argument_list|,
name|inputbox_attr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tbox_width
argument_list|,
operator|(
name|bool
operator|)
literal|0
argument_list|,
operator|(
name|bool
operator|)
name|first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The last field drawn determines where the cursor is shown: 	 */
if|if
condition|(
name|show_buttons
condition|)
block|{
name|show_buttons
operator|=
name|FALSE
expr_stmt|;
name|button
operator|=
operator|(
name|state
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|state
expr_stmt|;
name|dlg_draw_buttons
argument_list|(
name|dialog
argument_list|,
name|height
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
name|buttons
argument_list|,
name|button
argument_list|,
name|FALSE
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_trace
condition|)
block|{
name|first_trace
operator|=
name|FALSE
expr_stmt|;
name|dlg_trace_win
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|sTEXT
case|:
name|dlg_set_focus
argument_list|(
name|dialog
argument_list|,
name|w_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|sFILES
case|:
name|dlg_set_focus
argument_list|(
name|dialog
argument_list|,
name|f_list
operator|.
name|win
argument_list|)
expr_stmt|;
break|break;
case|case
name|sDIRS
case|:
name|dlg_set_focus
argument_list|(
name|dialog
argument_list|,
name|d_list
operator|.
name|win
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_arrows
argument_list|(
operator|&
name|d_list
argument_list|)
expr_stmt|;
name|fix_arrows
argument_list|(
operator|&
name|f_list
argument_list|)
expr_stmt|;
name|key
operator|=
name|dlg_mouse_wgetch
argument_list|(
operator|(
name|state
operator|==
name|sTEXT
operator|)
condition|?
name|w_text
else|:
name|dialog
argument_list|,
operator|&
name|fkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlg_result_key
argument_list|(
name|key
argument_list|,
name|fkey
argument_list|,
operator|&
name|result
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|fkey
operator|&&
name|key
operator|==
literal|' '
condition|)
block|{
name|key
operator|=
name|DLGK_SELECT
expr_stmt|;
name|fkey
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fkey
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|DLGK_MOUSE
argument_list|(
name|KEY_PREVIOUS
argument_list|)
case|:
name|state
operator|=
name|sDIRS
expr_stmt|;
name|scroll_list
argument_list|(
operator|-
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_MOUSE
argument_list|(
name|KEY_NEXT
argument_list|)
case|:
name|state
operator|=
name|sDIRS
expr_stmt|;
name|scroll_list
argument_list|(
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_MOUSE
argument_list|(
name|KEY_PPAGE
argument_list|)
case|:
name|state
operator|=
name|sFILES
expr_stmt|;
name|scroll_list
argument_list|(
operator|-
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_MOUSE
argument_list|(
name|KEY_NPAGE
argument_list|)
case|:
name|state
operator|=
name|sFILES
expr_stmt|;
name|scroll_list
argument_list|(
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_PAGE_PREV
case|:
name|scroll_list
argument_list|(
operator|-
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_PAGE_NEXT
case|:
name|scroll_list
argument_list|(
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLGK_ITEM_PREV
case|:
if|if
condition|(
name|change_list
argument_list|(
operator|-
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
condition|)
continue|continue;
comment|/* FALLTHRU */
case|case
name|DLGK_FIELD_PREV
case|:
name|show_buttons
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
name|state
operator|=
name|dlg_prev_ok_buttonindex
argument_list|(
name|state
argument_list|,
name|sDIRS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|usable_state
argument_list|(
name|state
argument_list|,
operator|&
name|d_list
argument_list|,
operator|&
name|f_list
argument_list|)
condition|)
do|;
continue|continue;
case|case
name|DLGK_ITEM_NEXT
case|:
if|if
condition|(
name|change_list
argument_list|(
literal|1
argument_list|,
name|which_list
argument_list|()
argument_list|)
condition|)
continue|continue;
comment|/* FALLTHRU */
case|case
name|DLGK_FIELD_NEXT
case|:
name|show_buttons
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
name|state
operator|=
name|dlg_next_ok_buttonindex
argument_list|(
name|state
argument_list|,
name|sDIRS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|usable_state
argument_list|(
name|state
argument_list|,
operator|&
name|d_list
argument_list|,
operator|&
name|f_list
argument_list|)
condition|)
do|;
continue|continue;
case|case
name|DLGK_SELECT
case|:
name|completed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|partial
argument_list|)
expr_stmt|;
name|partial
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|sFILES
operator|&&
operator|!
name|dselect
condition|)
block|{
name|completed
operator|=
name|data_of
argument_list|(
operator|&
name|f_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|sDIRS
condition|)
block|{
name|completed
operator|=
name|data_of
argument_list|(
operator|&
name|d_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|complete
argument_list|(
name|input
argument_list|,
operator|&
name|d_list
argument_list|,
operator|&
name|f_list
argument_list|,
operator|&
name|partial
argument_list|)
condition|)
block|{
name|completed
operator|=
name|partial
expr_stmt|;
block|}
block|}
if|if
condition|(
name|completed
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|sTEXT
expr_stmt|;
name|show_buttons
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
name|leaf_of
argument_list|(
name|input
argument_list|)
argument_list|,
name|completed
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|dlg_show_string
argument_list|(
name|w_text
argument_list|,
name|input
argument_list|,
name|offset
argument_list|,
name|inputbox_attr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tbox_width
argument_list|,
literal|0
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|partial
argument_list|)
expr_stmt|;
name|partial
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
comment|/* if (state< sTEXT) */
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* FALLTHRU */
case|case
name|DLGK_ENTER
case|:
name|result
operator|=
operator|(
name|state
operator|>
literal|0
operator|)
condition|?
name|dlg_enter_buttoncode
argument_list|(
name|state
argument_list|)
else|:
name|DLG_EXIT_OK
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|KEY_RESIZE
case|case
name|KEY_RESIZE
case|:
comment|/* reset data */
name|height
operator|=
name|old_height
expr_stmt|;
name|width
operator|=
name|old_width
expr_stmt|;
name|show_buttons
operator|=
name|TRUE
expr_stmt|;
operator|*
name|current
operator|=
literal|0
expr_stmt|;
name|resized
operator|=
name|TRUE
expr_stmt|;
comment|/* repaint */
name|dlg_clear
argument_list|()
expr_stmt|;
name|dlg_del_window
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|dlg_mouse_free_regions
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
endif|#
directive|endif
default|default:
if|if
condition|(
name|key
operator|>=
name|DLGK_MOUSE
argument_list|(
name|MOUSE_T
argument_list|)
condition|)
block|{
name|state
operator|=
name|sTEXT
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|key
operator|>=
name|DLGK_MOUSE
argument_list|(
name|MOUSE_F
argument_list|)
condition|)
block|{
if|if
condition|(
name|f_list
operator|.
name|win
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|sFILES
expr_stmt|;
name|f_list
operator|.
name|choice
operator|=
operator|(
name|key
operator|-
name|DLGK_MOUSE
argument_list|(
name|MOUSE_F
argument_list|)
operator|)
operator|+
name|f_list
operator|.
name|offset
expr_stmt|;
name|display_list
argument_list|(
operator|&
name|f_list
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|key
operator|>=
name|DLGK_MOUSE
argument_list|(
name|MOUSE_D
argument_list|)
condition|)
block|{
if|if
condition|(
name|d_list
operator|.
name|win
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|sDIRS
expr_stmt|;
name|d_list
operator|.
name|choice
operator|=
operator|(
name|key
operator|-
name|DLGK_MOUSE
argument_list|(
name|MOUSE_D
argument_list|)
operator|)
operator|+
name|d_list
operator|.
name|offset
expr_stmt|;
name|display_list
argument_list|(
operator|&
name|d_list
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|is_DLGK_MOUSE
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|code
operator|=
name|dlg_ok_buttoncode
argument_list|(
name|key
operator|-
name|M_EVENT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|result
operator|=
name|code
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|<
literal|0
condition|)
block|{
comment|/* Input box selected if we're editing */
name|int
name|edit
init|=
name|dlg_edit_string
argument_list|(
name|input
argument_list|,
operator|&
name|offset
argument_list|,
name|key
argument_list|,
name|fkey
argument_list|,
name|first
argument_list|)
decl_stmt|;
if|if
condition|(
name|edit
condition|)
block|{
name|dlg_show_string
argument_list|(
name|w_text
argument_list|,
name|input
argument_list|,
name|offset
argument_list|,
name|inputbox_attr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tbox_width
argument_list|,
literal|0
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
name|state
operator|=
name|sTEXT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|>=
literal|0
operator|&&
operator|(
name|code
operator|=
name|dlg_char_to_button
argument_list|(
name|key
argument_list|,
name|buttons
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|result
operator|=
name|dlg_ok_buttoncode
argument_list|(
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dlg_unregister_window
argument_list|(
name|w_text
argument_list|)
expr_stmt|;
name|dlg_del_window
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|dlg_mouse_free_regions
argument_list|()
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|d_list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|f_list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|partial
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Display a dialog box for entering a filename  */
end_comment

begin_function
name|int
name|dialog_fselect
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
return|return
name|dlg_fselect
argument_list|(
name|title
argument_list|,
name|path
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display a dialog box for entering a directory  */
end_comment

begin_function
name|int
name|dialog_dselect
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
return|return
name|dlg_fselect
argument_list|(
name|title
argument_list|,
name|path
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

end_unit

