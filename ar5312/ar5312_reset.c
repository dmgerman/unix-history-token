begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: ar5312_reset.c,v 1.9 2008/11/10 04:08:04 sam Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR5312
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ar5312/ar5312.h"
end_include

begin_include
include|#
directive|include
file|"ar5312/ar5312reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5312/ar5312phy.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_comment
comment|/* Additional Time delay to wait after activiting the Base band */
end_comment

begin_define
define|#
directive|define
name|BASE_ACTIVATE_DELAY
value|100
end_define

begin_comment
comment|/* 100 usec */
end_comment

begin_define
define|#
directive|define
name|PLL_SETTLE_DELAY
value|300
end_define

begin_comment
comment|/* 300 usec */
end_comment

begin_function_decl
specifier|extern
name|int16_t
name|ar5212GetNf
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212SetRateDurationTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|HAL_BOOL
name|ar5212SetTransmitPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212SetDeltaSlope
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|HAL_BOOL
name|ar5212SetBoardValues
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212SetIFSTiming
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|HAL_BOOL
name|ar5212IsSpurChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|HAL_BOOL
name|ar5212ChannelChange
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5312SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|write_common
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_INI_ARRAY
modifier|*
name|ia
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
define|#
directive|define
name|IS_NO_RESET_TIMER_ADDR
parameter_list|(
name|x
parameter_list|)
define|\
value|( (((x)>= AR_BEACON)&& ((x)<= AR_CFP_DUR)) || \       (((x)>= AR_SLEEP1)&& ((x)<= AR_SLEEP3)))
define|#
directive|define
name|V
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|(ia)->data[((r)*(ia)->cols) + (c)]
name|int
name|i
decl_stmt|;
comment|/* Write Common Array Parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ia
operator|->
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg
init|=
name|V
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* XXX timer/beacon setup registers? */
comment|/* On channel change, don't reset the PCU registers */
if|if
condition|(
operator|!
operator|(
name|bChannelChange
operator|&&
name|IS_NO_RESET_TIMER_ADDR
argument_list|(
name|reg
argument_list|)
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|V
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|DMA_YIELD
argument_list|(
name|writes
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|writes
return|;
undef|#
directive|undef
name|IS_NO_RESET_TIMER_ADDR
undef|#
directive|undef
name|V
block|}
end_function

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * bChannelChange is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5312Reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|bChannelChange
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
decl_stmt|;
name|uint32_t
name|saveFrameSeqCount
decl_stmt|,
name|saveDefAntenna
decl_stmt|;
name|uint32_t
name|macStaId1
decl_stmt|,
name|synthDelay
decl_stmt|,
name|txFrm2TxDStart
decl_stmt|;
name|uint16_t
name|rfXpdGain
index|[
name|MAX_NUM_PDGAINS_PER_CHANNEL
index|]
decl_stmt|;
name|int16_t
name|cckOfdmPwrDelta
init|=
literal|0
decl_stmt|;
name|u_int
name|modesIndex
decl_stmt|,
name|freqIndex
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regWrites
init|=
literal|0
decl_stmt|;
name|uint32_t
name|testReg
decl_stmt|;
name|uint32_t
name|saveLedState
init|=
literal|0
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|ee
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET
argument_list|,
name|bChannelChange
argument_list|)
expr_stmt|;
define|#
directive|define
name|IS
parameter_list|(
name|_c
parameter_list|,
name|_f
parameter_list|)
value|(((_c)->channelFlags& _f) || 0)
if|if
condition|(
operator|(
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_2GHZ
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_5GHZ
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; not marked as 2GHz or 5GHz\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_OFDM
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_CCK
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; not marked as OFDM or CCK\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|IS
comment|/* 	 * Map public channel to private. 	 */
name|ichan
operator|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_IBSS
case|:
case|case
name|HAL_M_HOSTAP
case|:
case|case
name|HAL_M_MONITOR
case|:
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid operating mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER3
argument_list|)
expr_stmt|;
comment|/* Preserve certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
block|{
comment|/* 		 * On Venice, the TSF is almost preserved across a reset; 		 * it requires the doubling writes to the RESET_TSF 		 * bit in the AR_BEACON register; it also has the quirk 		 * of the TSF going back in time on the station (station 		 * latches onto the last beacon's tsf during a reset 50% 		 * of the times); the latter is not a problem for adhoc 		 * stations since as long as the TSF is behind, it will 		 * get resynchronized on receiving the next beacon; the 		 * TSF going backwards in time could be a problem for the 		 * sleep operation (supported on infrastructure stations 		 * only) - the best and most general fix for this situation 		 * is to resynchronize the various sleep/beacon timers on 		 * the receipt of the next beacon i.e. when the TSF itself 		 * gets resynchronized to the AP's TSF - power save is 		 * needed to be temporarily disabled until that time 		 * 		 * Need to save the sequence number to restore it after 		 * the reset! 		 */
name|saveFrameSeqCount
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_SEQNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|saveFrameSeqCount
operator|=
literal|0
expr_stmt|;
comment|/* NB: silence compiler */
comment|/* If the channel change is across the same mode - perform a fast channel change */
if|if
condition|(
operator|(
name|IS_2413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Channel change can only be used when: 		 *  -channel change requested - so it's not the initial reset. 		 *  -it's not a change to the current channel - often called when switching modes 		 *   on a channel 		 *  -the modes of the previous and requested channel are the same 		 */
if|if
condition|(
name|bChannelChange
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|!=
name|AH_NULL
operator|)
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|!=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel
operator|)
operator|&&
operator|(
operator|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
operator|)
operator|==
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ar5212ChannelChange
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
comment|/* If ChannelChange completed - skip the rest of reset */
return|return
name|AH_TRUE
return|;
block|}
block|}
comment|/* 	 * Preserve the antenna on a channel change 	 */
name|saveDefAntenna
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveDefAntenna
operator|==
literal|0
condition|)
comment|/* XXX magic constants */
name|saveDefAntenna
operator|=
literal|1
expr_stmt|;
comment|/* Save hardware flag before chip reset clears the register */
name|macStaId1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
operator|(
name|AR_STA_ID1_BASE_RATE_11B
operator||
name|AR_STA_ID1_USE_DEFANT
operator|)
expr_stmt|;
comment|/* Save led state from pci config register */
if|if
condition|(
operator|!
name|IS_5315
argument_list|(
name|ah
argument_list|)
condition|)
name|saveLedState
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR5312_PCICFG
argument_list|)
operator|&
operator|(
name|AR_PCICFG_LEDCTL
operator||
name|AR_PCICFG_LEDMODE
operator||
name|AR_PCICFG_LEDBLINK
operator||
name|AR_PCICFG_LEDSLOW
operator|)
expr_stmt|;
name|ar5312RestoreClock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* move to refclk operation */
comment|/* 	 * Adjust gain parameters before reset if 	 * there's an outstanding gain updated. 	 */
operator|(
name|void
operator|)
name|ar5212GetRfgain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar5312ChipReset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the indices for the next set of register array writes */
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
condition|)
block|{
case|case
name|CHANNEL_A
case|:
name|modesIndex
operator|=
literal|1
expr_stmt|;
name|freqIndex
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CHANNEL_T
case|:
name|modesIndex
operator|=
literal|2
expr_stmt|;
name|freqIndex
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CHANNEL_B
case|:
name|modesIndex
operator|=
literal|3
expr_stmt|;
name|freqIndex
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHANNEL_PUREG
case|:
name|modesIndex
operator|=
literal|4
expr_stmt|;
name|freqIndex
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHANNEL_108G
case|:
name|modesIndex
operator|=
literal|5
expr_stmt|;
name|freqIndex
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00000007
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|ath_hal_ini_write
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_modes
argument_list|,
name|modesIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regWrites
operator|=
name|write_common
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_common
argument_list|,
name|bChannelChange
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|->
name|writeRegs
argument_list|(
name|ah
argument_list|,
name|modesIndex
argument_list|,
name|freqIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212SetIFSTiming
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
comment|/* Overwrite INI values for revised chipsets */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_2
condition|)
block|{
comment|/* ADC_CTL */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ADC_CTL
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_PHY_ADC_CTL_OFF_INBUFGAIN
argument_list|)
operator||
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_PHY_ADC_CTL_ON_INBUFGAIN
argument_list|)
operator||
name|AR_PHY_ADC_CTL_OFF_PWDDAC
operator||
name|AR_PHY_ADC_CTL_OFF_PWDADC
argument_list|)
expr_stmt|;
comment|/* TX_PWR_ADJ */
if|if
condition|(
name|chan
operator|->
name|channel
operator|==
literal|2484
condition|)
block|{
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
operator|-
name|ee
operator|->
name|ee_scaledCh14FilterCckDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cckOfdmPwrDelta
operator|=
name|SCALE_OC_DELTA
argument_list|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TXPWRADJ
argument_list|,
name|SM
argument_list|(
operator|(
name|ee
operator|->
name|ee_cckOfdmPwrDelta
operator|*
operator|-
literal|1
operator|)
argument_list|,
name|AR_PHY_TXPWRADJ_CCK_GAIN_DELTA
argument_list|)
operator||
name|SM
argument_list|(
operator|(
name|cckOfdmPwrDelta
operator|*
operator|-
literal|1
operator|)
argument_list|,
name|AR_PHY_TXPWRADJ_CCK_PCDAC_INDEX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TXPWRADJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add barker RSSI thresh enable as disabled */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DAG_CTRLCCK
argument_list|,
name|AR_PHY_DAG_CTRLCCK_EN_RSSI_THR
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_DAG_CTRLCCK
argument_list|,
name|AR_PHY_DAG_CTRLCCK_RSSI_THR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set the mute mask to the correct default */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SEQ_MASK
argument_list|,
literal|0x0000000F
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_3
condition|)
block|{
comment|/* Clear reg to alllow RX_CLEAR line debug */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BLUETOOTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyRev
operator|>=
name|AR_PHY_CHIP_ID_REV_4
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* Enable burst prefetch for the data queues */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_D_FPCTL
argument_list|,
operator|...
argument_list|)
expr_stmt|;
comment|/* Enable double-buffering */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
name|AR_TXCFG_DBL_BUF_DIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|IS_5312_2_X
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* ADC_CTRL */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SIGMA_DELTA
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_PHY_SIGMA_DELTA_ADC_SEL
argument_list|)
operator||
name|SM
argument_list|(
literal|4
argument_list|,
name|AR_PHY_SIGMA_DELTA_FILT2
argument_list|)
operator||
name|SM
argument_list|(
literal|0x16
argument_list|,
name|AR_PHY_SIGMA_DELTA_FILT1
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_PHY_SIGMA_DELTA_ADC_CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RXGAIN
argument_list|,
name|AR_PHY_RXGAIN_TXRX_RF_MAX
argument_list|,
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* CCK Short parameter adjustment in 11B mode */
if|if
condition|(
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_RXCTRL4
argument_list|,
name|AR_PHY_CCK_RXCTRL4_FREQ_EST_SHORT
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* Set ADC/DAC select values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Increase 11A AGC Settling */
if|if
condition|(
operator|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
operator|)
operator|==
name|CHANNEL_A
condition|)
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SETTLING
argument_list|,
name|AR_PHY_SETTLING_AGC
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set ADC/DAC select values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the transmit power values. */
if|if
condition|(
operator|!
name|ar5212SetTransmitPower
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write the analog registers */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rfHal
operator|->
name|setRfRegs
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|modesIndex
argument_list|,
name|rfXpdGain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5212SetRfRegs failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
if|if
condition|(
name|IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeversion
operator|>=
name|AR_EEPROM_VER5_3
operator|)
operator|)
operator|&&
operator|(
operator|!
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
name|ar5212SetSpurMitigation
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|ar5212SetDeltaSlope
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
comment|/* Setup board specific options for EEPROM version 3 */
if|if
condition|(
operator|!
name|ar5212SetBoardValues
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: error setting board options\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
comment|/* Restore certain DMA hardware registers on a channel change */
if|if
condition|(
name|bChannelChange
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_SEQNUM
argument_list|,
name|saveFrameSeqCount
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
operator||
name|macStaId1
operator||
name|AR_STA_ID1_RTS_USE_DEF
operator||
name|ahp
operator|->
name|ah_staId1Defaults
argument_list|)
expr_stmt|;
name|ar5212SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Set Venice BSSID mask according to current state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKL
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKU
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore previous led state */
if|if
condition|(
operator|!
name|IS_5315
argument_list|(
name|ah
argument_list|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR5312_PCICFG
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
operator||
name|saveLedState
argument_list|)
expr_stmt|;
comment|/* Restore previous antenna */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
name|saveDefAntenna
argument_list|)
expr_stmt|;
comment|/* then our BSSID */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore bmiss rssi& count thresholds */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|ahp
operator|->
name|ah_rssiThr
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* cleared on write */
if|if
condition|(
operator|!
name|ar5212SetChannel
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|ar5212SetCoverageClass
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_coverageClass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ar5212SetRateDurationTable
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Set Tx frame start to tx data start delay */
if|if
condition|(
name|IS_5112
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
operator|||
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
operator|)
condition|)
block|{
name|txFrm2TxDStart
operator|=
operator|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
operator|)
condition|?
name|TX_FRAME_D_START_HALF_RATE
else|:
name|TX_FRAME_D_START_QUARTER_RATE
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_CTL
argument_list|,
name|AR_PHY_TX_FRAME_TO_TX_DATA_START
argument_list|,
name|txFrm2TxDStart
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup fast diversity. 	 * Fast diversity can be enabled or disabled via regadd.txt. 	 * Default is enabled. 	 * For reference, 	 *    Disable: reg        val 	 *             0x00009860 0x00009d18 (if 11a / 11g, else no change) 	 *             0x00009970 0x192bb514 	 *             0x0000a208 0xd03e4648 	 * 	 *    Enable:  0x00009860 0x00009d10 (if 11a / 11g, else no change) 	 *             0x00009970 0x192fb514 	 *             0x0000a208 0xd03e6788 	 */
comment|/* XXX Setup pre PHY ENABLE EAR additions */
comment|/* flush SCAL reg */
if|if
condition|(
name|IS_5312_2_X
argument_list|(
name|ah
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the frequency synth to settle (synth goes on 	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register. 	 * Value is in 100ns increments. 	 */
name|synthDelay
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synthDelay
operator|=
operator|(
literal|4
operator|*
name|synthDelay
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synthDelay
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Activate the PHY (includes baseband activate and synthesizer on) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
comment|/*  	 * There is an issue if the AP starts the calibration before 	 * the base band timeout completes.  This could result in the 	 * rx_clear false triggering.  As a workaround we add delay an 	 * extra BASE_ACTIVATE_DELAY usecs to ensure this condition 	 * does not happen. 	 */
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|1
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
block|{
name|OS_DELAY
argument_list|(
operator|(
name|synthDelay
operator|<<
literal|2
operator|)
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_DELAY
argument_list|(
name|synthDelay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The udelay method is not reliable with notebooks. 	 * Need to check to see if the baseband is ready 	 */
name|testReg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|)
expr_stmt|;
comment|/* Selects the Tx hold */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|,
name|AR_PHY_TESTCTRL_TXHOLD
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|++
operator|<
literal|20
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
literal|0x9c24
argument_list|)
operator|&
literal|0x10
operator|)
condition|)
comment|/* test if baseband not ready */
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TESTCTRL
argument_list|,
name|testReg
argument_list|)
expr_stmt|;
comment|/* Calibrate the AGC and start a NF calculation */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
operator||
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
operator|&&
name|ahp
operator|->
name|ah_bIQCalibration
operator|!=
name|IQ_CAL_DONE
condition|)
block|{
comment|/* Start IQ calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX
argument_list|,
name|INIT_IQCAL_LOG_COUNT_MAX
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING_CTRL4
argument_list|,
name|AR_PHY_TIMING_CTRL4_DO_IQCAL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_RUNNING
expr_stmt|;
block|}
else|else
name|ahp
operator|->
name|ah_bIQCalibration
operator|=
name|IQ_CAL_INACTIVE
expr_stmt|;
comment|/* Setup compression registers */
name|ar5212SetCompRegs
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Set 1:1 QCU to DCU mapping for all queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DQCUMASK
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intrTxqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
condition|;
name|i
operator|++
control|)
name|ar5212ResetTxQueue
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Setup interrupt handling.  Note that ar5212ResetTxQueue 	 * manipulates the secondary IMR's as queues are enabled 	 * and disabled.  This is done with RMW ops to insure the 	 * settings we make here are preserved. 	 */
name|ahp
operator|->
name|ah_maskReg
operator|=
name|AR_IMR_TXOK
operator||
name|AR_IMR_TXERR
operator||
name|AR_IMR_TXURN
operator||
name|AR_IMR_RXOK
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXORN
operator||
name|AR_IMR_HIUERR
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|HAL_M_HOSTAP
condition|)
name|ahp
operator|->
name|ah_maskReg
operator||=
name|AR_IMR_MIB
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|ahp
operator|->
name|ah_maskReg
argument_list|)
expr_stmt|;
comment|/* Enable bus errors that are OR'd to set the HIUERR bit */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator||
name|AR_IMR_S2_MCABT
operator||
name|AR_IMR_S2_SSERR
operator||
name|AR_IMR_S2_DPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfkillEnabled
condition|)
name|ar5212EnableRfKill
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: offset calibration failed to complete in 1ms;"
literal|" noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set clocks back to 32kHz if they had been using refClk, then 	 * use an external 32kHz crystal when sleeping, if one exists. 	 */
name|ar5312SetupClock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* 	 * Writing to AR_BEACON will start timers. Hence it should 	 * be the last register to be written. Do not reset tsf, do 	 * not enable beacons at this point, but preserve other values 	 * like beaconInterval. 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
operator|&
operator|~
operator|(
name|AR_BEACON_EN
operator||
name|AR_BEACON_RESET_TSF
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Setup post reset EAR additions */
comment|/*  QoS support */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|>
name|AR_SREV_VERSION_VENICE
operator|||
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|>=
name|AR_SREV_GRIFFIN_LITE
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_CONTROL
argument_list|,
literal|0x100aa
argument_list|)
expr_stmt|;
comment|/* XXX magic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_SELECT
argument_list|,
literal|0x3210
argument_list|)
expr_stmt|;
comment|/* XXX magic */
block|}
comment|/* Turn on NOACK Support for QoS packets */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NOACK
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_NOACK_2BIT_VALUE
argument_list|)
operator||
name|SM
argument_list|(
literal|5
argument_list|,
name|AR_NOACK_BIT_OFFSET
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_NOACK_BYTE_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore user-specified settings */
if|if
condition|(
name|ahp
operator|->
name|ah_miscMode
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_slottime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSlotTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_acktimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetAckTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_acktimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_ctstimeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetCTSTimeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ctstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_sifstime
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ar5212SetSifsTime
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sifstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
if|if
condition|(
name|bChannelChange
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ichan
operator|->
name|privFlags
operator|&
name|CHANNEL_DFS
operator|)
condition|)
name|ichan
operator|->
name|privFlags
operator|&=
operator|~
name|CHANNEL_INTERFERENCE
expr_stmt|;
name|chan
operator|->
name|channelFlags
operator|=
name|ichan
operator|->
name|channelFlags
expr_stmt|;
name|chan
operator|->
name|privFlags
operator|=
name|ichan
operator|->
name|privFlags
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5312PhyDisable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar5312SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_BB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar5312Disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar5312SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
comment|/* 	 * Reset the HW - PCI must be reset after the rest of the 	 * device has been reset. 	 */
return|return
name|ar5312SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  *  * TODO: Only write the PLL if we're changing to or from CCK mode  *   * WARNING: The order of the PLL and mode registers must be correct.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5312ChipReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIPRESET
argument_list|,
name|chan
condition|?
name|chan
operator|->
name|channel
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the HW  	 */
if|if
condition|(
operator|!
name|ar5312SetResetReg
argument_list|(
name|ah
argument_list|,
name|AR_RC_MAC
operator||
name|AR_RC_BB
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5312SetResetReg failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Bring out of sleep mode (AGAIN) */
if|if
condition|(
operator|!
name|ar5312SetPowerMode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5312SetPowerMode failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Clear warm reset register */
if|if
condition|(
operator|!
name|ar5312SetResetReg
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: ar5312SetResetReg failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* 	 * Perform warm reset before the mode/PLL/turbo registers 	 * are changed in order to deactivate the radio.  Mode changes 	 * with an active radio can result in corrupted shifts to the 	 * radio device. 	 */
comment|/* 	 * Set CCK and Turbo modes correctly. 	 */
if|if
condition|(
name|chan
operator|!=
name|AH_NULL
condition|)
block|{
comment|/* NB: can be null during attach */
name|uint32_t
name|rfMode
decl_stmt|,
name|phyPLL
init|=
literal|0
decl_stmt|,
name|curPhyPLL
decl_stmt|,
name|turbo
decl_stmt|;
if|if
condition|(
name|IS_5112
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2413
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|rfMode
operator|=
name|AR_PHY_MODE_AR5112
expr_stmt|;
if|if
condition|(
operator|!
name|IS_5315
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44_5312
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5312_HALF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5312_QUARTER
expr_stmt|;
block|}
else|else
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5312
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44_5112
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5112_HALF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5112_QUARTER
expr_stmt|;
block|}
else|else
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_5112
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|rfMode
operator|=
name|AR_PHY_MODE_AR5111
expr_stmt|;
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_44
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_HALF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40_QUARTER
expr_stmt|;
block|}
else|else
block|{
name|phyPLL
operator|=
name|AR_PHY_PLL_CTL_40
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
operator|&&
operator|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_OFDM
expr_stmt|;
else|else
name|rfMode
operator||=
name|AR_PHY_MODE_CCK
expr_stmt|;
if|if
condition|(
name|IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|rfMode
operator||=
name|AR_PHY_MODE_RF5GHZ
expr_stmt|;
else|else
name|rfMode
operator||=
name|AR_PHY_MODE_RF2GHZ
expr_stmt|;
name|turbo
operator|=
name|IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|?
operator|(
name|AR_PHY_FC_TURBO_MODE
operator||
name|AR_PHY_FC_TURBO_SHORT
operator|)
else|:
literal|0
expr_stmt|;
name|curPhyPLL
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|)
expr_stmt|;
comment|/* 		 * PLL, Mode, and Turbo values must be written in the correct 		 * order to ensure: 		 * - The PLL cannot be set to 44 unless the CCK or DYNAMIC 		 *   mode bit is set 		 * - Turbo cannot be set at the same time as CCK or DYNAMIC 		 */
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|turbo
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rfMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPhyPLL
operator|!=
name|phyPLL
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|phyPLL
argument_list|)
expr_stmt|;
comment|/* Wait for the PLL to settle */
name|OS_DELAY
argument_list|(
name|PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curPhyPLL
operator|!=
name|phyPLL
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CTL
argument_list|,
name|phyPLL
argument_list|)
expr_stmt|;
comment|/* Wait for the PLL to settle */
name|OS_DELAY
argument_list|(
name|PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TURBO
argument_list|,
name|turbo
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rfMode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Write the given reset bit mask into the reset register  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5312SetResetReg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|resetMask
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|resetMask
condition|?
name|resetMask
else|:
operator|~
literal|0
decl_stmt|;
name|HAL_BOOL
name|rt
decl_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|ar5312MacReset
argument_list|(
name|ah
argument_list|,
name|mask
argument_list|)
operator|)
operator|==
name|AH_FALSE
condition|)
block|{
return|return
name|rt
return|;
block|}
if|if
condition|(
operator|(
name|resetMask
operator|&
name|AR_RC_MAC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isBigEndian
argument_list|()
condition|)
block|{
comment|/* 			 * Set CFG, little-endian for register 			 * and descriptor accesses. 			 */
ifdef|#
directive|ifdef
name|AH_NEED_DESC_SWAP
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWRD
expr_stmt|;
else|#
directive|else
name|mask
operator|=
name|INIT_CONFIG_STATUS
operator||
name|AR_CFG_SWTD
operator||
name|AR_CFG_SWRD
expr_stmt|;
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|INIT_CONFIG_STATUS
argument_list|)
expr_stmt|;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/*  * ar5312MacReset resets (and then un-resets) the specified  * wireless components.  * Note: The RCMask cannot be zero on entering from ar5312SetResetReg.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5312MacReset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|unsigned
name|int
name|RCMask
parameter_list|)
block|{
name|int
name|wlanNum
init|=
name|AR5312_UNIT
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|uint32_t
name|resetBB
decl_stmt|,
name|resetBits
decl_stmt|,
name|regMask
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
if|if
condition|(
name|RCMask
operator|==
literal|0
condition|)
return|return
operator|(
name|AH_FALSE
operator|)
return|;
if|#
directive|if
operator|(
name|AH_SUPPORT_2316
operator|||
name|AH_SUPPORT_2317
operator|)
if|if
condition|(
name|IS_5315
argument_list|(
name|ah
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|wlanNum
condition|)
block|{
case|case
literal|0
case|:
name|resetBB
operator|=
name|AR5315_RC_BB0_CRES
operator||
name|AR5315_RC_WBB0_RES
expr_stmt|;
comment|/* Warm and cold reset bits for wbb */
name|resetBits
operator|=
name|AR5315_RC_WMAC0_RES
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|resetBB
operator|=
name|AR5315_RC_BB1_CRES
operator||
name|AR5315_RC_WBB1_RES
expr_stmt|;
comment|/* Warm and cold reset bits for wbb */
name|resetBits
operator|=
name|AR5315_RC_WMAC1_RES
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|AH_FALSE
operator|)
return|;
block|}
name|regMask
operator|=
operator|~
operator|(
name|resetBB
operator||
name|resetBits
operator|)
expr_stmt|;
comment|/* read before */
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCMask
operator|==
name|AR_RC_BB
condition|)
block|{
comment|/* Put baseband in reset */
name|reg
operator||=
name|resetBB
expr_stmt|;
comment|/* Cold and warm reset the baseband bits */
block|}
else|else
block|{
comment|/* 				 * Reset the MAC and baseband.  This is a bit different than 				 * the PCI version, but holding in reset causes problems. 				 */
name|reg
operator|&=
name|regMask
expr_stmt|;
name|reg
operator||=
operator|(
name|resetBits
operator||
name|resetBB
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read after */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Bring MAC and baseband out of reset */
name|reg
operator|&=
name|regMask
expr_stmt|;
comment|/* read before */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read after */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5315_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5315_RESET
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
switch|switch
condition|(
name|wlanNum
condition|)
block|{
case|case
literal|0
case|:
name|resetBB
operator|=
name|AR5312_RC_BB0_CRES
operator||
name|AR5312_RC_WBB0_RES
expr_stmt|;
comment|/* Warm and cold reset bits for wbb */
name|resetBits
operator|=
name|AR5312_RC_WMAC0_RES
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|resetBB
operator|=
name|AR5312_RC_BB1_CRES
operator||
name|AR5312_RC_WBB1_RES
expr_stmt|;
comment|/* Warm and cold reset bits for wbb */
name|resetBits
operator|=
name|AR5312_RC_WMAC1_RES
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|AH_FALSE
operator|)
return|;
block|}
name|regMask
operator|=
operator|~
operator|(
name|resetBB
operator||
name|resetBits
operator|)
expr_stmt|;
comment|/* read before */
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCMask
operator|==
name|AR_RC_BB
condition|)
block|{
comment|/* Put baseband in reset */
name|reg
operator||=
name|resetBB
expr_stmt|;
comment|/* Cold and warm reset the baseband bits */
block|}
else|else
block|{
comment|/* 				 * Reset the MAC and baseband.  This is a bit different than 				 * the PCI version, but holding in reset causes problems. 				 */
name|reg
operator|&=
name|regMask
expr_stmt|;
name|reg
operator||=
operator|(
name|resetBits
operator||
name|resetBB
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read after */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Bring MAC and baseband out of reset */
name|reg
operator|&=
name|regMask
expr_stmt|;
comment|/* read before */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* read after */
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
operator|(
name|AR5312_RSTIMER_BASE
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|ah
operator|->
name|ah_sh
operator|)
operator|+
name|AR5312_RESET
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_AR5312 */
end_comment

end_unit

