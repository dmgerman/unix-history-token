begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*-************************************ *  Dependencies **************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* SET_BINARY_MODE */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* FILE, fwrite, fprintf */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* U32 */
end_comment

begin_comment
comment|/*-************************************ *  Macros **************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( (a)< (b) ? (a) : (b) )
end_define

begin_define
define|#
directive|define
name|RDG_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
modifier|...
parameter_list|)
value|if (RDG_DEBUG) fprintf(stderr, __VA_ARGS__ )
end_define

begin_comment
comment|/*-************************************ *  Local constants **************************************/
end_comment

begin_define
define|#
directive|define
name|LTLOG
value|13
end_define

begin_define
define|#
directive|define
name|LTSIZE
value|(1<<LTLOG)
end_define

begin_define
define|#
directive|define
name|LTMASK
value|(LTSIZE-1)
end_define

begin_comment
comment|/*-******************************************************* *  Local Functions *********************************************************/
end_comment

begin_define
define|#
directive|define
name|RDG_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_function
specifier|static
name|U32
name|RDG_rand
parameter_list|(
name|U32
modifier|*
name|src
parameter_list|)
block|{
specifier|static
specifier|const
name|U32
name|prime1
init|=
literal|2654435761U
decl_stmt|;
specifier|static
specifier|const
name|U32
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|U32
name|rand32
init|=
operator|*
name|src
decl_stmt|;
name|rand32
operator|*=
name|prime1
expr_stmt|;
name|rand32
operator|^=
name|prime2
expr_stmt|;
name|rand32
operator|=
name|RDG_rotl32
argument_list|(
name|rand32
argument_list|,
literal|13
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|rand32
expr_stmt|;
return|return
name|rand32
operator|>>
literal|5
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RDG_fillLiteralDistrib
parameter_list|(
name|BYTE
modifier|*
name|ldt
parameter_list|,
name|double
name|ld
parameter_list|)
block|{
name|BYTE
specifier|const
name|firstChar
init|=
operator|(
name|ld
operator|<=
literal|0.0
operator|)
condition|?
literal|0
else|:
literal|'('
decl_stmt|;
name|BYTE
specifier|const
name|lastChar
init|=
operator|(
name|ld
operator|<=
literal|0.0
operator|)
condition|?
literal|255
else|:
literal|'}'
decl_stmt|;
name|BYTE
name|character
init|=
operator|(
name|ld
operator|<=
literal|0.0
operator|)
condition|?
literal|0
else|:
literal|'0'
decl_stmt|;
name|U32
name|u
decl_stmt|;
if|if
condition|(
name|ld
operator|<=
literal|0.0
condition|)
name|ld
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|LTSIZE
condition|;
control|)
block|{
name|U32
specifier|const
name|weight
init|=
call|(
name|U32
call|)
argument_list|(
call|(
name|double
call|)
argument_list|(
name|LTSIZE
operator|-
name|u
argument_list|)
operator|*
name|ld
argument_list|)
operator|+
literal|1
decl_stmt|;
name|U32
specifier|const
name|end
init|=
name|MIN
argument_list|(
name|u
operator|+
name|weight
argument_list|,
name|LTSIZE
argument_list|)
decl_stmt|;
while|while
condition|(
name|u
operator|<
name|end
condition|)
name|ldt
index|[
name|u
operator|++
index|]
operator|=
name|character
expr_stmt|;
name|character
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|>
name|lastChar
condition|)
name|character
operator|=
name|firstChar
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|BYTE
name|RDG_genChar
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ldt
parameter_list|)
block|{
name|U32
specifier|const
name|id
init|=
name|RDG_rand
argument_list|(
name|seed
argument_list|)
operator|&
name|LTMASK
decl_stmt|;
return|return
name|ldt
index|[
name|id
index|]
return|;
comment|/* memory-sanitizer fails here, stating "uninitialized value" when table initialized with P==0.0. Checked : table is fully initialized */
block|}
end_function

begin_function
specifier|static
name|U32
name|RDG_rand15Bits
parameter_list|(
name|unsigned
modifier|*
name|seedPtr
parameter_list|)
block|{
return|return
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|0x7FFF
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|RDG_randLength
parameter_list|(
name|unsigned
modifier|*
name|seedPtr
parameter_list|)
block|{
if|if
condition|(
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|7
condition|)
return|return
operator|(
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|0xF
operator|)
return|;
comment|/* small length */
return|return
operator|(
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|0x1FF
operator|)
operator|+
literal|0xF
return|;
block|}
end_function

begin_function
name|void
name|RDG_genBlock
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|buffSize
parameter_list|,
name|size_t
name|prefixSize
parameter_list|,
name|double
name|matchProba
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ldt
parameter_list|,
name|unsigned
modifier|*
name|seedPtr
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|buffPtr
init|=
operator|(
name|BYTE
operator|*
operator|)
name|buffer
decl_stmt|;
name|U32
specifier|const
name|matchProba32
init|=
call|(
name|U32
call|)
argument_list|(
literal|32768
operator|*
name|matchProba
argument_list|)
decl_stmt|;
name|size_t
name|pos
init|=
name|prefixSize
decl_stmt|;
name|U32
name|prevOffset
init|=
literal|1
decl_stmt|;
comment|/* special case : sparse content */
while|while
condition|(
name|matchProba
operator|>=
literal|1.0
condition|)
block|{
name|size_t
name|size0
init|=
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|3
decl_stmt|;
name|size0
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
literal|16
operator|+
name|size0
operator|*
literal|2
operator|)
expr_stmt|;
name|size0
operator|+=
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
operator|(
name|size0
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* because size0 is power of 2*/
if|if
condition|(
name|buffSize
operator|<
name|pos
operator|+
name|size0
condition|)
block|{
name|memset
argument_list|(
name|buffPtr
operator|+
name|pos
argument_list|,
literal|0
argument_list|,
name|buffSize
operator|-
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|buffPtr
operator|+
name|pos
argument_list|,
literal|0
argument_list|,
name|size0
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|size0
expr_stmt|;
name|buffPtr
index|[
name|pos
operator|-
literal|1
index|]
operator|=
name|RDG_genChar
argument_list|(
name|seedPtr
argument_list|,
name|ldt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* init */
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
name|buffPtr
index|[
literal|0
index|]
operator|=
name|RDG_genChar
argument_list|(
name|seedPtr
argument_list|,
name|ldt
argument_list|)
operator|,
name|pos
operator|=
literal|1
expr_stmt|;
comment|/* Generate compressible data */
while|while
condition|(
name|pos
operator|<
name|buffSize
condition|)
block|{
comment|/* Select : Literal (char) or Match (within 32K) */
if|if
condition|(
name|RDG_rand15Bits
argument_list|(
name|seedPtr
argument_list|)
operator|<
name|matchProba32
condition|)
block|{
comment|/* Copy (within 32K) */
name|U32
specifier|const
name|length
init|=
name|RDG_randLength
argument_list|(
name|seedPtr
argument_list|)
operator|+
literal|4
decl_stmt|;
name|U32
specifier|const
name|d
init|=
operator|(
name|U32
operator|)
name|MIN
argument_list|(
name|pos
operator|+
name|length
argument_list|,
name|buffSize
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|repeatOffset
init|=
operator|(
name|RDG_rand
argument_list|(
name|seedPtr
argument_list|)
operator|&
literal|15
operator|)
operator|==
literal|2
decl_stmt|;
name|U32
specifier|const
name|randOffset
init|=
name|RDG_rand15Bits
argument_list|(
name|seedPtr
argument_list|)
operator|+
literal|1
decl_stmt|;
name|U32
specifier|const
name|offset
init|=
name|repeatOffset
condition|?
name|prevOffset
else|:
operator|(
name|U32
operator|)
name|MIN
argument_list|(
name|randOffset
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|size_t
name|match
init|=
name|pos
operator|-
name|offset
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|d
condition|)
name|buffPtr
index|[
name|pos
operator|++
index|]
operator|=
name|buffPtr
index|[
name|match
operator|++
index|]
expr_stmt|;
comment|/* correctly manages overlaps */
name|prevOffset
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Literal (noise) */
name|U32
specifier|const
name|length
init|=
name|RDG_randLength
argument_list|(
name|seedPtr
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|d
init|=
operator|(
name|U32
operator|)
name|MIN
argument_list|(
name|pos
operator|+
name|length
argument_list|,
name|buffSize
argument_list|)
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|d
condition|)
name|buffPtr
index|[
name|pos
operator|++
index|]
operator|=
name|RDG_genChar
argument_list|(
name|seedPtr
argument_list|,
name|ldt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|RDG_genBuffer
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
name|double
name|matchProba
parameter_list|,
name|double
name|litProba
parameter_list|,
name|unsigned
name|seed
parameter_list|)
block|{
name|BYTE
name|ldt
index|[
name|LTSIZE
index|]
decl_stmt|;
name|memset
argument_list|(
name|ldt
argument_list|,
literal|'0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ldt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* yes, character '0', this is intentional */
if|if
condition|(
name|litProba
operator|<=
literal|0.0
condition|)
name|litProba
operator|=
name|matchProba
operator|/
literal|4.5
expr_stmt|;
name|RDG_fillLiteralDistrib
argument_list|(
name|ldt
argument_list|,
name|litProba
argument_list|)
expr_stmt|;
name|RDG_genBlock
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|matchProba
argument_list|,
name|ldt
argument_list|,
operator|&
name|seed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RDG_genStdout
parameter_list|(
name|unsigned
name|long
name|long
name|size
parameter_list|,
name|double
name|matchProba
parameter_list|,
name|double
name|litProba
parameter_list|,
name|unsigned
name|seed
parameter_list|)
block|{
name|size_t
specifier|const
name|stdBlockSize
init|=
literal|128
name|KB
decl_stmt|;
name|size_t
specifier|const
name|stdDictSize
init|=
literal|32
name|KB
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|buff
init|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|stdDictSize
operator|+
name|stdBlockSize
argument_list|)
decl_stmt|;
name|U64
name|total
init|=
literal|0
decl_stmt|;
name|BYTE
name|ldt
index|[
name|LTSIZE
index|]
decl_stmt|;
comment|/* literals distribution table */
comment|/* init */
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"datagen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|litProba
operator|<=
literal|0.0
condition|)
name|litProba
operator|=
name|matchProba
operator|/
literal|4.5
expr_stmt|;
name|memset
argument_list|(
name|ldt
argument_list|,
literal|'0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ldt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* yes, character '0', this is intentional */
name|RDG_fillLiteralDistrib
argument_list|(
name|ldt
argument_list|,
name|litProba
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Generate initial dict */
name|RDG_genBlock
argument_list|(
name|buff
argument_list|,
name|stdDictSize
argument_list|,
literal|0
argument_list|,
name|matchProba
argument_list|,
name|ldt
argument_list|,
operator|&
name|seed
argument_list|)
expr_stmt|;
comment|/* Generate compressible data */
while|while
condition|(
name|total
operator|<
name|size
condition|)
block|{
name|size_t
specifier|const
name|genBlockSize
init|=
call|(
name|size_t
call|)
argument_list|(
name|MIN
argument_list|(
name|stdBlockSize
argument_list|,
name|size
operator|-
name|total
argument_list|)
argument_list|)
decl_stmt|;
name|RDG_genBlock
argument_list|(
name|buff
argument_list|,
name|stdDictSize
operator|+
name|stdBlockSize
argument_list|,
name|stdDictSize
argument_list|,
name|matchProba
argument_list|,
name|ldt
argument_list|,
operator|&
name|seed
argument_list|)
expr_stmt|;
name|total
operator|+=
name|genBlockSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|unused
init|=
name|fwrite
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|genBlockSize
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|unused
expr_stmt|;
block|}
comment|/* update dict */
name|memcpy
argument_list|(
name|buff
argument_list|,
name|buff
operator|+
name|stdBlockSize
argument_list|,
name|stdDictSize
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup */
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

