begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: exregion - ACPI default OpRegion (address space) handlers  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2013, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|__EXREGION_C__
end_define

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|"accommon.h"
end_include

begin_include
include|#
directive|include
file|"acinterp.h"
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_EXECUTER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"exregion"
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExSystemMemorySpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the System Memory address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExSystemMemorySpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|void
modifier|*
name|LogicalAddrPtr
init|=
name|NULL
decl_stmt|;
name|ACPI_MEM_SPACE_CONTEXT
modifier|*
name|MemInfo
init|=
name|RegionContext
decl_stmt|;
name|UINT32
name|Length
decl_stmt|;
name|ACPI_SIZE
name|MapLength
decl_stmt|;
name|ACPI_SIZE
name|PageBoundaryMapLength
decl_stmt|;
ifdef|#
directive|ifdef
name|ACPI_MISALIGNMENT_NOT_SUPPORTED
name|UINT32
name|Remainder
decl_stmt|;
endif|#
directive|endif
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExSystemMemorySpaceHandler
argument_list|)
expr_stmt|;
comment|/* Validate and translate the bit width */
switch|switch
condition|(
name|BitWidth
condition|)
block|{
case|case
literal|8
case|:
name|Length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|Length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|Length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|Length
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Invalid SystemMemory width %u"
operator|,
name|BitWidth
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_AML_OPERAND_VALUE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACPI_MISALIGNMENT_NOT_SUPPORTED
comment|/*      * Hardware does not support non-aligned data transfers, we must verify      * the request.      */
operator|(
name|void
operator|)
name|AcpiUtShortDivide
argument_list|(
operator|(
name|UINT64
operator|)
name|Address
argument_list|,
name|Length
argument_list|,
name|NULL
argument_list|,
operator|&
name|Remainder
argument_list|)
expr_stmt|;
if|if
condition|(
name|Remainder
operator|!=
literal|0
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_AML_ALIGNMENT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Does the request fit into the cached memory mapping?      * Is 1) Address below the current mapping? OR      *    2) Address beyond the current mapping?      */
if|if
condition|(
operator|(
name|Address
operator|<
name|MemInfo
operator|->
name|MappedPhysicalAddress
operator|)
operator|||
operator|(
operator|(
operator|(
name|UINT64
operator|)
name|Address
operator|+
name|Length
operator|)
operator|>
operator|(
operator|(
name|UINT64
operator|)
name|MemInfo
operator|->
name|MappedPhysicalAddress
operator|+
name|MemInfo
operator|->
name|MappedLength
operator|)
operator|)
condition|)
block|{
comment|/*          * The request cannot be resolved by the current memory mapping;          * Delete the existing mapping and create a new one.          */
if|if
condition|(
name|MemInfo
operator|->
name|MappedLength
condition|)
block|{
comment|/* Valid mapping, delete it */
name|AcpiOsUnmapMemory
argument_list|(
name|MemInfo
operator|->
name|MappedLogicalAddress
argument_list|,
name|MemInfo
operator|->
name|MappedLength
argument_list|)
expr_stmt|;
block|}
comment|/*          * October 2009: Attempt to map from the requested address to the          * end of the region. However, we will never map more than one          * page, nor will we cross a page boundary.          */
name|MapLength
operator|=
call|(
name|ACPI_SIZE
call|)
argument_list|(
operator|(
name|MemInfo
operator|->
name|Address
operator|+
name|MemInfo
operator|->
name|Length
operator|)
operator|-
name|Address
argument_list|)
expr_stmt|;
comment|/*          * If mapping the entire remaining portion of the region will cross          * a page boundary, just map up to the page boundary, do not cross.          * On some systems, crossing a page boundary while mapping regions          * can cause warnings if the pages have different attributes          * due to resource management.          *          * This has the added benefit of constraining a single mapping to          * one page, which is similar to the original code that used a 4k          * maximum window.          */
name|PageBoundaryMapLength
operator|=
name|ACPI_ROUND_UP
argument_list|(
name|Address
argument_list|,
name|ACPI_DEFAULT_PAGE_SIZE
argument_list|)
operator|-
name|Address
expr_stmt|;
if|if
condition|(
name|PageBoundaryMapLength
operator|==
literal|0
condition|)
block|{
name|PageBoundaryMapLength
operator|=
name|ACPI_DEFAULT_PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|MapLength
operator|>
name|PageBoundaryMapLength
condition|)
block|{
name|MapLength
operator|=
name|PageBoundaryMapLength
expr_stmt|;
block|}
comment|/* Create a new mapping starting at the address given */
name|MemInfo
operator|->
name|MappedLogicalAddress
operator|=
name|AcpiOsMapMemory
argument_list|(
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|Address
argument_list|,
name|MapLength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MemInfo
operator|->
name|MappedLogicalAddress
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Could not map memory at 0x%8.8X%8.8X, size %u"
operator|,
name|ACPI_FORMAT_NATIVE_UINT
argument_list|(
name|Address
argument_list|)
operator|,
operator|(
name|UINT32
operator|)
name|MapLength
operator|)
argument_list|)
expr_stmt|;
name|MemInfo
operator|->
name|MappedLength
operator|=
literal|0
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
block|}
comment|/* Save the physical address and mapping size */
name|MemInfo
operator|->
name|MappedPhysicalAddress
operator|=
name|Address
expr_stmt|;
name|MemInfo
operator|->
name|MappedLength
operator|=
name|MapLength
expr_stmt|;
block|}
comment|/*      * Generate a logical pointer corresponding to the address we want to      * access      */
name|LogicalAddrPtr
operator|=
name|MemInfo
operator|->
name|MappedLogicalAddress
operator|+
operator|(
operator|(
name|UINT64
operator|)
name|Address
operator|-
operator|(
name|UINT64
operator|)
name|MemInfo
operator|->
name|MappedPhysicalAddress
operator|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n"
operator|,
name|BitWidth
operator|,
name|Function
operator|,
name|ACPI_FORMAT_NATIVE_UINT
argument_list|(
name|Address
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Perform the memory read or write      *      * Note: For machines that do not support non-aligned transfers, the target      * address was checked for alignment above. We do not attempt to break the      * transfer up into smaller (byte-size) chunks because the AML specifically      * asked for a transfer width that the hardware may require.      */
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
operator|*
name|Value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|BitWidth
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|Value
operator|=
operator|(
name|UINT64
operator|)
name|ACPI_GET8
argument_list|(
name|LogicalAddrPtr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|*
name|Value
operator|=
operator|(
name|UINT64
operator|)
name|ACPI_GET16
argument_list|(
name|LogicalAddrPtr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
operator|*
name|Value
operator|=
operator|(
name|UINT64
operator|)
name|ACPI_GET32
argument_list|(
name|LogicalAddrPtr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
operator|*
name|Value
operator|=
operator|(
name|UINT64
operator|)
name|ACPI_GET64
argument_list|(
name|LogicalAddrPtr
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* BitWidth was already validated */
break|break;
block|}
break|break;
case|case
name|ACPI_WRITE
case|:
switch|switch
condition|(
name|BitWidth
condition|)
block|{
case|case
literal|8
case|:
name|ACPI_SET8
argument_list|(
name|LogicalAddrPtr
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|ACPI_SET16
argument_list|(
name|LogicalAddrPtr
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|ACPI_SET32
argument_list|(
name|LogicalAddrPtr
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ACPI_SET64
argument_list|(
name|LogicalAddrPtr
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* BitWidth was already validated */
break|break;
block|}
break|break;
default|default:
name|Status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExSystemIoSpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the System IO address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExSystemIoSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|UINT32
name|Value32
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExSystemIoSpaceHandler
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"System-IO (width %u) R/W %u Address=%8.8X%8.8X\n"
operator|,
name|BitWidth
operator|,
name|Function
operator|,
name|ACPI_FORMAT_NATIVE_UINT
argument_list|(
name|Address
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Decode the function parameter */
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
name|Status
operator|=
name|AcpiHwReadPort
argument_list|(
operator|(
name|ACPI_IO_ADDRESS
operator|)
name|Address
argument_list|,
operator|&
name|Value32
argument_list|,
name|BitWidth
argument_list|)
expr_stmt|;
operator|*
name|Value
operator|=
name|Value32
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|Status
operator|=
name|AcpiHwWritePort
argument_list|(
operator|(
name|ACPI_IO_ADDRESS
operator|)
name|Address
argument_list|,
operator|(
name|UINT32
operator|)
operator|*
name|Value
argument_list|,
name|BitWidth
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExPciConfigSpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the PCI Config address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExPciConfigSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_PCI_ID
modifier|*
name|PciId
decl_stmt|;
name|UINT16
name|PciRegister
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExPciConfigSpaceHandler
argument_list|)
expr_stmt|;
comment|/*      *  The arguments to AcpiOs(Read|Write)PciConfiguration are:      *      *  PciSegment  is the PCI bus segment range 0-31      *  PciBus      is the PCI bus number range 0-255      *  PciDevice   is the PCI device number range 0-31      *  PciFunction is the PCI device function number      *  PciRegister is the Config space register range 0-255 bytes      *      *  Value - input value for write, output address for read      *      */
name|PciId
operator|=
operator|(
name|ACPI_PCI_ID
operator|*
operator|)
name|RegionContext
expr_stmt|;
name|PciRegister
operator|=
operator|(
name|UINT16
operator|)
operator|(
name|UINT32
operator|)
name|Address
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"Pci-Config %u (%u) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n"
operator|,
name|Function
operator|,
name|BitWidth
operator|,
name|PciId
operator|->
name|Segment
operator|,
name|PciId
operator|->
name|Bus
operator|,
name|PciId
operator|->
name|Device
operator|,
name|PciId
operator|->
name|Function
operator|,
name|PciRegister
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
operator|*
name|Value
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|AcpiOsReadPciConfiguration
argument_list|(
name|PciId
argument_list|,
name|PciRegister
argument_list|,
name|Value
argument_list|,
name|BitWidth
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|Status
operator|=
name|AcpiOsWritePciConfiguration
argument_list|(
name|PciId
argument_list|,
name|PciRegister
argument_list|,
operator|*
name|Value
argument_list|,
name|BitWidth
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Status
operator|=
name|AE_BAD_PARAMETER
expr_stmt|;
break|break;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExCmosSpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the CMOS address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExCmosSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExCmosSpaceHandler
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExPciBarSpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the PCI BarTarget address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExPciBarSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExPciBarSpaceHandler
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiExDataTableSpaceHandler  *  * PARAMETERS:  Function            - Read or Write operation  *              Address             - Where in the space to read or write  *              BitWidth            - Field width in bits (8, 16, or 32)  *              Value               - Pointer to in or out value  *              HandlerContext      - Pointer to Handler's context  *              RegionContext       - Pointer to context specific to the  *                                    accessed region  *  * RETURN:      Status  *  * DESCRIPTION: Handler for the Data Table address space (Op Region)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiExDataTableSpaceHandler
parameter_list|(
name|UINT32
name|Function
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|UINT32
name|BitWidth
parameter_list|,
name|UINT64
modifier|*
name|Value
parameter_list|,
name|void
modifier|*
name|HandlerContext
parameter_list|,
name|void
modifier|*
name|RegionContext
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
name|ExDataTableSpaceHandler
argument_list|)
expr_stmt|;
comment|/*      * Perform the memory read or write. The BitWidth was already      * validated.      */
switch|switch
condition|(
name|Function
condition|)
block|{
case|case
name|ACPI_READ
case|:
name|ACPI_MEMCPY
argument_list|(
name|ACPI_CAST_PTR
argument_list|(
name|char
argument_list|,
name|Value
argument_list|)
argument_list|,
name|ACPI_PHYSADDR_TO_PTR
argument_list|(
name|Address
argument_list|)
argument_list|,
name|ACPI_DIV_8
argument_list|(
name|BitWidth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_WRITE
case|:
name|ACPI_MEMCPY
argument_list|(
name|ACPI_PHYSADDR_TO_PTR
argument_list|(
name|Address
argument_list|)
argument_list|,
name|ACPI_CAST_PTR
argument_list|(
name|char
argument_list|,
name|Value
argument_list|)
argument_list|,
name|ACPI_DIV_8
argument_list|(
name|BitWidth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

