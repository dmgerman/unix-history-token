begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: ahdecode - Operator/Opcode decoding for acpihelp utility  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2013, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|"acpihelp.h"
end_include

begin_define
define|#
directive|define
name|ACPI_CREATE_PREDEFINED_TABLE
end_define

begin_include
include|#
directive|include
file|"acpredef.h"
end_include

begin_comment
comment|/* Device IDs defined in the ACPI specification */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|AH_DEVICE_ID
name|AhDeviceIds
index|[]
init|=
block|{
block|{
literal|"PNP0A05"
block|,
literal|"Generic Container Device"
block|}
block|,
block|{
literal|"PNP0A06"
block|,
literal|"Generic Container Device"
block|}
block|,
block|{
literal|"PNP0C08"
block|,
literal|"ACPI core hardware"
block|}
block|,
block|{
literal|"PNP0C09"
block|,
literal|"Embedded Controller Device"
block|}
block|,
block|{
literal|"PNP0C0A"
block|,
literal|"Control Method Battery"
block|}
block|,
block|{
literal|"PNP0C0B"
block|,
literal|"Fan"
block|}
block|,
block|{
literal|"PNP0C0C"
block|,
literal|"Power Button Device"
block|}
block|,
block|{
literal|"PNP0C0D"
block|,
literal|"Lid Device"
block|}
block|,
block|{
literal|"PNP0C0E"
block|,
literal|"Sleep Button Device"
block|}
block|,
block|{
literal|"PNP0C0F"
block|,
literal|"PCI Interrupt Link Device"
block|}
block|,
block|{
literal|"PNP0C80"
block|,
literal|"Memory Device"
block|}
block|,
block|{
literal|"ACPI0001"
block|,
literal|"SMBus 1.0 Host Controller"
block|}
block|,
block|{
literal|"ACPI0002"
block|,
literal|"Smart Battery Subsystem"
block|}
block|,
block|{
literal|"ACPI0003"
block|,
literal|"Power Source Device"
block|}
block|,
block|{
literal|"ACPI0004"
block|,
literal|"Module Device"
block|}
block|,
block|{
literal|"ACPI0005"
block|,
literal|"SMBus 2.0 Host Controller"
block|}
block|,
block|{
literal|"ACPI0006"
block|,
literal|"GPE Block Device"
block|}
block|,
block|{
literal|"ACPI0007"
block|,
literal|"Processor Device"
block|}
block|,
block|{
literal|"ACPI0008"
block|,
literal|"Ambient Light Sensor Device"
block|}
block|,
block|{
literal|"ACPI0009"
block|,
literal|"I/O xAPIC Device"
block|}
block|,
block|{
literal|"ACPI000A"
block|,
literal|"I/O APIC Device"
block|}
block|,
block|{
literal|"ACPI000B"
block|,
literal|"I/O SAPIC Device"
block|}
block|,
block|{
literal|"ACPI000C"
block|,
literal|"Processor Aggregator Device"
block|}
block|,
block|{
literal|"ACPI000D"
block|,
literal|"Power Meter Device"
block|}
block|,
block|{
literal|"ACPI000E"
block|,
literal|"Time/Alarm Device"
block|}
block|,
block|{
literal|"ACPI000F"
block|,
literal|"User Presence Detection Device"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AH_DISPLAY_EXCEPTION
parameter_list|(
name|Status
parameter_list|,
name|Name
parameter_list|)
define|\
value|printf ("%.4X: %s\n", Status, Name)
end_define

begin_define
define|#
directive|define
name|AH_DISPLAY_EXCEPTION_TEXT
parameter_list|(
name|Status
parameter_list|,
name|Exception
parameter_list|)
define|\
value|printf ("%.4X: %-28s (%s)\n", Status, Exception->Name, Exception->Description)
end_define

begin_define
define|#
directive|define
name|BUFFER_LENGTH
value|128
end_define

begin_define
define|#
directive|define
name|LINE_BUFFER_LENGTH
value|512
end_define

begin_decl_stmt
specifier|static
name|char
name|Gbl_Buffer
index|[
name|BUFFER_LENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Gbl_LineBuffer
index|[
name|LINE_BUFFER_LENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|AcpiRtypeNames
index|[]
init|=
block|{
literal|"/Integer"
block|,
literal|"/String"
block|,
literal|"/Buffer"
block|,
literal|"/Package"
block|,
literal|"/Reference"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|BOOLEAN
name|AhDisplayPredefinedName
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|,
name|UINT32
name|Length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayPredefinedInfo
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhGetExpectedTypes
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|ExpectedBtypes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAmlOpcode
parameter_list|(
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAslOperator
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayOperatorKeywords
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAslKeyword
parameter_list|(
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhPrintOneField
parameter_list|(
name|UINT32
name|Indent
parameter_list|,
name|UINT32
name|CurrentPosition
parameter_list|,
name|UINT32
name|MaxPosition
parameter_list|,
specifier|const
name|char
modifier|*
name|Field
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindPredefinedNames (entry point for predefined name search)  *  * PARAMETERS:  NamePrefix          - Name or prefix to find. Must start with  *                                    an underscore. NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find and display all ACPI predefined names that match the  *              input name or prefix. Includes the required number of arguments  *              and the expected return type, if any.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindPredefinedNames
parameter_list|(
name|char
modifier|*
name|NamePrefix
parameter_list|)
block|{
name|UINT32
name|Length
decl_stmt|;
name|BOOLEAN
name|Found
decl_stmt|;
name|char
name|Name
index|[
literal|9
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|NamePrefix
condition|)
block|{
name|Found
operator|=
name|AhDisplayPredefinedName
argument_list|(
name|Name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Contruct a local name or name prefix */
name|AhStrupr
argument_list|(
name|NamePrefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|NamePrefix
operator|==
literal|'_'
condition|)
block|{
name|NamePrefix
operator|++
expr_stmt|;
block|}
name|Name
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|Name
index|[
literal|1
index|]
argument_list|,
name|NamePrefix
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|Length
operator|=
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: Predefined name must be 4 characters maximum\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
return|return;
block|}
name|Found
operator|=
name|AhDisplayPredefinedName
argument_list|(
name|Name
argument_list|,
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching predefined names\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayPredefinedName  *  * PARAMETERS:  Name                - Name or name prefix  *  * RETURN:      TRUE if any names matched, FALSE otherwise  *  * DESCRIPTION: Display information about ACPI predefined names that match  *              the input name or name prefix.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|AhDisplayPredefinedName
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|,
name|UINT32
name|Length
parameter_list|)
block|{
specifier|const
name|AH_PREDEFINED_NAME
modifier|*
name|Info
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|BOOLEAN
name|Matched
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/* Find/display all names that match the input name prefix */
for|for
control|(
name|Info
operator|=
name|AslPredefinedInfo
init|;
name|Info
operator|->
name|Name
condition|;
name|Info
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s:<%s>\n"
argument_list|,
name|Info
operator|->
name|Name
argument_list|,
name|Info
operator|->
name|Description
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|Info
operator|->
name|Action
argument_list|)
expr_stmt|;
name|AhDisplayPredefinedInfo
argument_list|(
name|Info
operator|->
name|Name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Matched
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Info
operator|->
name|Name
index|[
name|i
index|]
operator|!=
name|Name
index|[
name|i
index|]
condition|)
block|{
name|Matched
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Matched
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s:<%s>\n"
argument_list|,
name|Info
operator|->
name|Name
argument_list|,
name|Info
operator|->
name|Description
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|Info
operator|->
name|Action
argument_list|)
expr_stmt|;
name|AhDisplayPredefinedInfo
argument_list|(
name|Info
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|Found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayPredefinedInfo  *  * PARAMETERS:  Name                - Exact 4-character ACPI name.  *  * RETURN:      None  *  * DESCRIPTION: Find the name in the main ACPICA predefined info table and  *              display the # of arguments and the return value type.  *  *              Note: Resource Descriptor field names do not appear in this  *              table -- thus, nothing will be displayed for them.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayPredefinedInfo
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|ACPI_PREDEFINED_INFO
modifier|*
name|ThisName
decl_stmt|;
name|BOOLEAN
name|Matched
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/* Find/display only the exact input name */
for|for
control|(
name|ThisName
operator|=
name|PredefinedNames
init|;
name|ThisName
operator|->
name|Info
operator|.
name|Name
index|[
literal|0
index|]
condition|;
name|ThisName
operator|++
control|)
block|{
name|Matched
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_NAME_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ThisName
operator|->
name|Info
operator|.
name|Name
index|[
name|i
index|]
operator|!=
name|Name
index|[
name|i
index|]
condition|)
block|{
name|Matched
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Matched
condition|)
block|{
name|AhGetExpectedTypes
argument_list|(
name|Gbl_Buffer
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%4.4s has %u arguments, returns: %s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|Name
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ParamCount
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
condition|?
name|Gbl_Buffer
else|:
literal|"-Nothing-"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
operator|&
name|ACPI_RTYPE_PACKAGE
condition|)
block|{
name|ThisName
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhGetExpectedTypes  *  * PARAMETERS:  Buffer              - Where the formatted string is returned  *              ExpectedBTypes      - Bitfield of expected data types  *  * RETURN:      Formatted string in Buffer.  *  * DESCRIPTION: Format the expected object types into a printable string.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhGetExpectedTypes
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|ExpectedBtypes
parameter_list|)
block|{
name|UINT32
name|ThisRtype
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|UINT32
name|j
decl_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
name|Buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ThisRtype
operator|=
name|ACPI_RTYPE_INTEGER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_NUM_RTYPES
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one of the expected types, concatenate the name of this type */
if|if
condition|(
name|ExpectedBtypes
operator|&
name|ThisRtype
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
operator|&
name|AcpiRtypeNames
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* Use name separator from now on */
block|}
name|ThisRtype
operator|<<=
literal|1
expr_stmt|;
comment|/* Next Rtype */
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAmlOpcode (entry point for AML opcode name search)  *  * PARAMETERS:  Name                - Name or prefix for an AML opcode.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all AML opcodes that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAmlOpcode
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* Find/display all opcode names that match the input name prefix */
for|for
control|(
name|Op
operator|=
name|AmlOpcodeInfo
init|;
name|Op
operator|->
name|OpcodeString
condition|;
name|Op
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|OpcodeName
condition|)
comment|/* Unused opcodes */
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the opcode name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Op
operator|->
name|OpcodeName
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching AML operators\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDecodeAmlOpcode (entry point for AML opcode search)  *  * PARAMETERS:  OpcodeString        - String version of AML opcode  *  * RETURN:      None  *  * DESCRIPTION: Display information about the input AML opcode  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhDecodeAmlOpcode
parameter_list|(
name|char
modifier|*
name|OpcodeString
parameter_list|)
block|{
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
decl_stmt|;
name|UINT32
name|Opcode
decl_stmt|;
name|UINT8
name|Prefix
decl_stmt|;
if|if
condition|(
operator|!
name|OpcodeString
condition|)
block|{
name|AhFindAmlOpcode
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|Opcode
operator|=
name|ACPI_STRTOUL
argument_list|(
name|OpcodeString
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|Opcode
operator|>
name|ACPI_UINT16_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid opcode (more than 16 bits)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only valid opcode extension is 0x5B */
name|Prefix
operator|=
operator|(
name|Opcode
operator|&
literal|0x0000FF00
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|Prefix
operator|&&
operator|(
name|Prefix
operator|!=
literal|0x5B
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid opcode (invalid extension prefix 0x%X)\n"
argument_list|,
name|Prefix
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find/Display the opcode. May fall within an opcode range */
for|for
control|(
name|Op
operator|=
name|AmlOpcodeInfo
init|;
name|Op
operator|->
name|OpcodeString
condition|;
name|Op
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Opcode
operator|>=
name|Op
operator|->
name|OpcodeRangeStart
operator|)
operator|&&
operator|(
name|Opcode
operator|<=
name|Op
operator|->
name|OpcodeRangeEnd
operator|)
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAmlOpcode  *  * PARAMETERS:  Op                  - An opcode info struct  *  * RETURN:      None  *  * DESCRIPTION: Display the contents of an AML opcode information struct  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAmlOpcode
parameter_list|(
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|OpcodeName
condition|)
block|{
name|printf
argument_list|(
literal|"%18s: Opcode=%-9s\n"
argument_list|,
literal|"Reserved opcode"
argument_list|,
name|Op
operator|->
name|OpcodeString
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Opcode name and value(s) */
name|printf
argument_list|(
literal|"%18s: Opcode=%-9s Type (%s)"
argument_list|,
name|Op
operator|->
name|OpcodeName
argument_list|,
name|Op
operator|->
name|OpcodeString
argument_list|,
name|Op
operator|->
name|Type
argument_list|)
expr_stmt|;
comment|/* Optional fixed/static arguments */
if|if
condition|(
name|Op
operator|->
name|FixedArguments
condition|)
block|{
name|printf
argument_list|(
literal|" FixedArgs ("
argument_list|)
expr_stmt|;
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|36
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|Op
operator|->
name|Type
argument_list|)
operator|+
literal|12
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|FixedArguments
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* Optional variable-length argument list */
if|if
condition|(
name|Op
operator|->
name|VariableArguments
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|FixedArguments
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
literal|36
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" VariableArgs ("
argument_list|)
expr_stmt|;
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|15
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|VariableArguments
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Grammar specification */
if|if
condition|(
name|Op
operator|->
name|Grammar
condition|)
block|{
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|0
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|Grammar
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAslKeywords (entry point for ASL keyword search)  *  * PARAMETERS:  Name                - Name or prefix for an ASL keyword.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all ASL keywords that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAslKeywords
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Keyword
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|Keyword
operator|=
name|AslKeywordInfo
init|;
name|Keyword
operator|->
name|Name
condition|;
name|Keyword
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAslKeyword
argument_list|(
name|Keyword
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the operator name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Keyword
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAslKeyword
argument_list|(
name|Keyword
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching ASL keywords\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAslKeyword  *  * PARAMETERS:  Op                  - Pointer to ASL keyword with syntax info  *  * RETURN:      None  *  * DESCRIPTION: Format and display syntax info for an ASL keyword. Splits  *              long lines appropriately for reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAslKeyword
parameter_list|(
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Op
parameter_list|)
block|{
comment|/* ASL keyword name and description */
name|printf
argument_list|(
literal|"%22s: %s\n"
argument_list|,
name|Op
operator|->
name|Name
argument_list|,
name|Op
operator|->
name|Description
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Op
operator|->
name|KeywordList
condition|)
block|{
return|return;
block|}
comment|/* List of actual keywords */
name|AhPrintOneField
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|,
name|AH_MAX_ASL_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|KeywordList
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAslOperators (entry point for ASL operator search)  *  * PARAMETERS:  Name                - Name or prefix for an ASL operator.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all ASL operators that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAslOperators
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Operator
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* Find/display all names that match the input name prefix */
for|for
control|(
name|Operator
operator|=
name|AslOperatorInfo
init|;
name|Operator
operator|->
name|Name
condition|;
name|Operator
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAslOperator
argument_list|(
name|Operator
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the operator name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Operator
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAslOperator
argument_list|(
name|Operator
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching ASL operators\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAslOperator  *  * PARAMETERS:  Op                  - Pointer to ASL operator with syntax info  *  * RETURN:      None  *  * DESCRIPTION: Format and display syntax info for an ASL operator. Splits  *              long lines appropriately for reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAslOperator
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
block|{
comment|/* ASL operator name and description */
name|printf
argument_list|(
literal|"%16s: %s\n"
argument_list|,
name|Op
operator|->
name|Name
argument_list|,
name|Op
operator|->
name|Description
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Op
operator|->
name|Syntax
condition|)
block|{
return|return;
block|}
comment|/* Syntax for the operator */
name|AhPrintOneField
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|,
name|AH_MAX_ASL_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|Syntax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|AhDisplayOperatorKeywords
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayOperatorKeywords  *  * PARAMETERS:  Op                  - Pointer to ASL keyword with syntax info  *  * RETURN:      None  *  * DESCRIPTION: Display any/all keywords that are associated with the ASL  *              operator.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayOperatorKeywords
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
block|{
name|char
modifier|*
name|Token
decl_stmt|;
name|char
modifier|*
name|Separators
init|=
literal|"(){}, "
decl_stmt|;
name|BOOLEAN
name|FirstKeyword
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|Op
operator|||
operator|!
name|Op
operator|->
name|Syntax
condition|)
block|{
return|return;
block|}
comment|/*      * Find all parameters that have the word "keyword" within, and then      * display the info about that keyword      */
name|strcpy
argument_list|(
name|Gbl_LineBuffer
argument_list|,
name|Op
operator|->
name|Syntax
argument_list|)
expr_stmt|;
name|Token
operator|=
name|strtok
argument_list|(
name|Gbl_LineBuffer
argument_list|,
name|Separators
argument_list|)
expr_stmt|;
while|while
condition|(
name|Token
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|Token
argument_list|,
literal|"Keyword"
argument_list|)
condition|)
block|{
if|if
condition|(
name|FirstKeyword
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|FirstKeyword
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Found a keyword, display keyword information */
name|AhFindAslKeywords
argument_list|(
name|Token
argument_list|)
expr_stmt|;
block|}
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|Separators
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhPrintOneField  *  * PARAMETERS:  Indent              - Indent length for new line(s)  *              CurrentPosition     - Position on current line  *              MaxPosition         - Max allowed line length  *              Field               - Data to output  *  * RETURN:      Line position after field is written  *  * DESCRIPTION: Split long lines appropriately for ease of reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhPrintOneField
parameter_list|(
name|UINT32
name|Indent
parameter_list|,
name|UINT32
name|CurrentPosition
parameter_list|,
name|UINT32
name|MaxPosition
parameter_list|,
specifier|const
name|char
modifier|*
name|Field
parameter_list|)
block|{
name|UINT32
name|Position
decl_stmt|;
name|UINT32
name|TokenLength
decl_stmt|;
specifier|const
name|char
modifier|*
name|This
decl_stmt|;
specifier|const
name|char
modifier|*
name|Next
decl_stmt|;
specifier|const
name|char
modifier|*
name|Last
decl_stmt|;
name|This
operator|=
name|Field
expr_stmt|;
name|Position
operator|=
name|CurrentPosition
expr_stmt|;
if|if
condition|(
name|Position
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|Position
operator|=
name|Indent
expr_stmt|;
block|}
name|Last
operator|=
name|This
operator|+
name|strlen
argument_list|(
name|This
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|Next
operator|=
name|strpbrk
argument_list|(
name|This
argument_list|,
literal|" "
argument_list|)
operator|)
condition|)
block|{
name|TokenLength
operator|=
name|Next
operator|-
name|This
expr_stmt|;
name|Position
operator|+=
name|TokenLength
expr_stmt|;
comment|/* Split long lines */
if|if
condition|(
name|Position
operator|>
name|MaxPosition
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|Position
operator|=
name|TokenLength
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%.*s "
argument_list|,
operator|(
name|int
operator|)
name|TokenLength
argument_list|,
name|This
argument_list|)
expr_stmt|;
name|This
operator|=
name|Next
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Handle last token on the input line */
name|TokenLength
operator|=
name|Last
operator|-
name|This
expr_stmt|;
if|if
condition|(
name|TokenLength
operator|>
literal|0
condition|)
block|{
name|Position
operator|+=
name|TokenLength
expr_stmt|;
if|if
condition|(
name|Position
operator|>
name|MaxPosition
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|This
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayDeviceIds  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Display all PNP* and ACPI* device IDs defined in the ACPI spec.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhDisplayDeviceIds
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|AH_DEVICE_ID
modifier|*
name|DeviceId
init|=
name|AhDeviceIds
decl_stmt|;
name|printf
argument_list|(
literal|"ACPI and PNP Device IDs defined in the ACPI specification:\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|DeviceId
operator|->
name|Name
condition|)
block|{
name|printf
argument_list|(
literal|"%8s   %s\n"
argument_list|,
name|DeviceId
operator|->
name|Name
argument_list|,
name|DeviceId
operator|->
name|Description
argument_list|)
expr_stmt|;
name|DeviceId
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDecodeException  *  * PARAMETERS:  HexString           - ACPI status string from command line, in  *                                    hex. If null, display all exceptions.  *  * RETURN:      None  *  * DESCRIPTION: Decode and display an ACPI_STATUS exception code.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhDecodeException
parameter_list|(
name|char
modifier|*
name|HexString
parameter_list|)
block|{
specifier|const
name|ACPI_EXCEPTION_INFO
modifier|*
name|ExceptionInfo
decl_stmt|;
name|UINT32
name|Status
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/*      * A null input string means to decode and display all known      * exception codes.      */
if|if
condition|(
operator|!
name|HexString
condition|)
block|{
name|printf
argument_list|(
literal|"All defined ACPICA exception codes:\n\n"
argument_list|)
expr_stmt|;
name|AH_DISPLAY_EXCEPTION
argument_list|(
literal|0
argument_list|,
literal|"AE_OK                        (No error occurred)"
argument_list|)
expr_stmt|;
comment|/* Display codes in each block of exception types */
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|&
name|AE_CODE_MASK
operator|)
operator|<=
name|AE_CODE_MAX
condition|;
name|i
operator|+=
literal|0x1000
control|)
block|{
name|Status
operator|=
name|i
expr_stmt|;
do|do
block|{
name|ExceptionInfo
operator|=
name|AcpiUtValidateException
argument_list|(
operator|(
name|ACPI_STATUS
operator|)
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ExceptionInfo
condition|)
block|{
name|AH_DISPLAY_EXCEPTION_TEXT
argument_list|(
name|Status
argument_list|,
name|ExceptionInfo
argument_list|)
expr_stmt|;
block|}
name|Status
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ExceptionInfo
condition|)
do|;
block|}
return|return;
block|}
comment|/* Decode a single user-supplied exception code */
name|Status
operator|=
name|ACPI_STRTOUL
argument_list|(
name|HexString
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Status
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Invalid hexadecimal exception code value\n"
argument_list|,
name|HexString
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Status
operator|>
name|ACPI_UINT16_MAX
condition|)
block|{
name|AH_DISPLAY_EXCEPTION
argument_list|(
name|Status
argument_list|,
literal|"Invalid exception code (more than 16 bits)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ExceptionInfo
operator|=
name|AcpiUtValidateException
argument_list|(
operator|(
name|ACPI_STATUS
operator|)
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExceptionInfo
condition|)
block|{
name|AH_DISPLAY_EXCEPTION
argument_list|(
name|Status
argument_list|,
literal|"Unknown exception code"
argument_list|)
expr_stmt|;
return|return;
block|}
name|AH_DISPLAY_EXCEPTION_TEXT
argument_list|(
name|Status
argument_list|,
name|ExceptionInfo
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

