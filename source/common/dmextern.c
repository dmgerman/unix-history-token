begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: dmextern - Support for External() ASL statements  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  * 1. Copyright Notice  *  * Some or all of this work - Copyright (c) 1999 - 2017, Intel Corp.  * All rights reserved.  *  * 2. License  *  * 2.1. This is your license from Intel Corp. under its intellectual property  * rights. You may have additional license terms from the party that provided  * you this software, covering your right to use that party's intellectual  * property rights.  *  * 2.2. Intel grants, free of charge, to any person ("Licensee") obtaining a  * copy of the source code appearing in this file ("Covered Code") an  * irrevocable, perpetual, worldwide license under Intel's copyrights in the  * base code distributed originally by Intel ("Original Intel Code") to copy,  * make derivatives, distribute, use and display any portion of the Covered  * Code in any form, with the right to sublicense such rights; and  *  * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent  * license (with the right to sublicense), under only those claims of Intel  * patents that are infringed by the Original Intel Code, to make, use, sell,  * offer to sell, and import the Covered Code and derivative works thereof  * solely to the minimum extent necessary to exercise the above copyright  * license, and in no event shall the patent license extend to any additions  * to or modifications of the Original Intel Code. No other license or right  * is granted directly or by implication, estoppel or otherwise;  *  * The above copyright and patent license is granted only if the following  * conditions are met:  *  * 3. Conditions  *  * 3.1. Redistribution of Source with Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification with rights to further distribute source must include  * the above Copyright Notice, the above License, this list of Conditions,  * and the following Disclaimer and Export Compliance provision. In addition,  * Licensee must cause all Covered Code to which Licensee contributes to  * contain a file documenting the changes Licensee made to create that Covered  * Code and the date of any change. Licensee must include in that file the  * documentation of any changes made by any predecessor Licensee. Licensee  * must include a prominent statement that the modification is derived,  * directly or indirectly, from Original Intel Code.  *  * 3.2. Redistribution of Source with no Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification without rights to further distribute source must  * include the following Disclaimer and Export Compliance provision in the  * documentation and/or other materials provided with distribution. In  * addition, Licensee may not authorize further sublicense of source of any  * portion of the Covered Code, and must include terms to the effect that the  * license from Licensee to its licensee is limited to the intellectual  * property embodied in the software Licensee provides to its licensee, and  * not to intellectual property embodied in modifications its licensee may  * make.  *  * 3.3. Redistribution of Executable. Redistribution in executable form of any  * substantial portion of the Covered Code or modification must reproduce the  * above Copyright Notice, and the following Disclaimer and Export Compliance  * provision in the documentation and/or other materials provided with the  * distribution.  *  * 3.4. Intel retains all right, title, and interest in and to the Original  * Intel Code.  *  * 3.5. Neither the name Intel nor any other trademark owned or controlled by  * Intel shall be used in advertising or otherwise to promote the sale, use or  * other dealings in products derived from or relating to the Covered Code  * without prior written authorization from Intel.  *  * 4. Disclaimer and Export Compliance  *  * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED  * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE  * IS PROVIDED "AS IS," AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,  * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY  * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY  * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A  * PARTICULAR PURPOSE.  *  * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES  * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR  * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,  * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY  * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL  * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS  * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY  * LIMITED REMEDY.  *  * 4.3. Licensee shall not export, either directly or indirectly, any of this  * software or system incorporating such software without first obtaining any  * required license or other approval from the U. S. Department of Commerce or  * any other agency or department of the United States Government. In the  * event Licensee exports any such software from the United States or  * re-exports any such software from a foreign destination, Licensee shall  * ensure that the distribution and export/re-export of the software is in  * compliance with all laws, regulations, orders, or other restrictions of the  * U.S. Export Administration Regulations. Licensee agrees that neither it nor  * any of its subsidiaries will export/re-export any technical data, process,  * software, or service, directly or indirectly, to any country for which the  * United States government or any agency thereof requires an export license,  * other governmental approval, or letter of assurance, without first obtaining  * such license, approval or letter.  *  *****************************************************************************  *  * Alternatively, you may choose to be licensed under the terms of the  * following license:  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Alternatively, you may choose to be licensed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|"accommon.h"
end_include

begin_include
include|#
directive|include
file|"amlcode.h"
end_include

begin_include
include|#
directive|include
file|"acnamesp.h"
end_include

begin_include
include|#
directive|include
file|"acdisasm.h"
end_include

begin_include
include|#
directive|include
file|"aslcompiler.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * This module is used for application-level code (iASL disassembler) only.  *  * It contains the code to create and emit any necessary External() ASL  * statements for the module being disassembled.  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DISASSEMBLER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dmextern"
argument_list|)
end_macro

begin_comment
comment|/*  * This table maps ACPI_OBJECT_TYPEs to the corresponding ASL  * ObjectTypeKeyword. Used to generate typed external declarations  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|AcpiGbl_DmTypeNames
index|[]
init|=
block|{
comment|/* 00 */
literal|", UnknownObj"
block|,
comment|/* Type ANY */
comment|/* 01 */
literal|", IntObj"
block|,
comment|/* 02 */
literal|", StrObj"
block|,
comment|/* 03 */
literal|", BuffObj"
block|,
comment|/* 04 */
literal|", PkgObj"
block|,
comment|/* 05 */
literal|", FieldUnitObj"
block|,
comment|/* 06 */
literal|", DeviceObj"
block|,
comment|/* 07 */
literal|", EventObj"
block|,
comment|/* 08 */
literal|", MethodObj"
block|,
comment|/* 09 */
literal|", MutexObj"
block|,
comment|/* 10 */
literal|", OpRegionObj"
block|,
comment|/* 11 */
literal|", PowerResObj"
block|,
comment|/* 12 */
literal|", ProcessorObj"
block|,
comment|/* 13 */
literal|", ThermalZoneObj"
block|,
comment|/* 14 */
literal|", BuffFieldObj"
block|,
comment|/* 15 */
literal|", DDBHandleObj"
block|,
comment|/* 16 */
literal|""
block|,
comment|/* Debug object */
comment|/* 17 */
literal|", FieldUnitObj"
block|,
comment|/* 18 */
literal|", FieldUnitObj"
block|,
comment|/* 19 */
literal|", FieldUnitObj"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METHOD_SEPARATORS
value|" \t,()\n"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ExternalConflictMessage
init|=
literal|"    // Conflicts with a later declaration"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDmGetExternalAndInternalPath
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|char
modifier|*
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
modifier|*
name|InternalPath
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDmRemoveRootPrefix
parameter_list|(
name|char
modifier|*
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDmAddPathToExternalList
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDmCreateNewExternal
parameter_list|(
name|char
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
name|InternalPath
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDmCheckForExternalConflict
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDmResolveExternal
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
modifier|*
name|Node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDmConflictingDeclaration
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetObjectTypeName  *  * PARAMETERS:  Type                - An ACPI_OBJECT_TYPE  *  * RETURN:      Pointer to a string  *  * DESCRIPTION: Map an object type to the ASL object type string.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
block|{
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_LOCAL_SCOPE
condition|)
block|{
name|Type
operator|=
name|ACPI_TYPE_DEVICE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Type
operator|>
name|ACPI_TYPE_LOCAL_INDEX_FIELD
condition|)
block|{
return|return
operator|(
literal|""
operator|)
return|;
block|}
return|return
operator|(
name|AcpiGbl_DmTypeNames
index|[
name|Type
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmNormalizeParentPrefix  *  * PARAMETERS:  Op                  - Parse op  *              Path                - Path with parent prefix  *  * RETURN:      The full pathname to the object (from the namespace root)  *  * DESCRIPTION: Returns the full pathname of a path with parent prefix  *              The caller must free the fullpath returned.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|char
modifier|*
name|Fullpath
decl_stmt|;
name|char
modifier|*
name|ParentPath
decl_stmt|;
name|ACPI_SIZE
name|Length
decl_stmt|;
name|UINT32
name|Index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Search upwards in the parse tree until we reach the next namespace node */
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
while|while
condition|(
name|Op
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|Common
operator|.
name|Node
condition|)
block|{
break|break;
block|}
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Find the actual parent node for the reference:      * Remove all carat prefixes from the input path.      * There may be multiple parent prefixes (For example, ^^^M000)      */
name|Node
operator|=
name|Op
operator|->
name|Common
operator|.
name|Node
expr_stmt|;
while|while
condition|(
name|Node
operator|&&
operator|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
operator|)
condition|)
block|{
name|Node
operator|=
name|Node
operator|->
name|Parent
expr_stmt|;
name|Path
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Node
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get the full pathname for the parent node */
name|ParentPath
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ParentPath
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|Length
operator|=
operator|(
name|strlen
argument_list|(
name|ParentPath
argument_list|)
operator|+
name|strlen
argument_list|(
name|Path
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
comment|/*          * If ParentPath is not just a simple '\', increment the length          * for the required dot separator (ParentPath.Path)          */
name|Length
operator|++
expr_stmt|;
comment|/* For External() statements, we do not want a leading '\' */
if|if
condition|(
operator|*
name|ParentPath
operator|==
name|AML_ROOT_PREFIX
condition|)
block|{
name|Index
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|Fullpath
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fullpath
condition|)
block|{
goto|goto
name|Cleanup
goto|;
block|}
comment|/*      * Concatenate parent fullpath and path. For example,      * parent fullpath "\_SB_", Path "^INIT", Fullpath "\_SB_.INIT"      *      * Copy the parent path      */
name|strcpy
argument_list|(
name|Fullpath
argument_list|,
operator|&
name|ParentPath
index|[
name|Index
index|]
argument_list|)
expr_stmt|;
comment|/*      * Add dot separator      * (don't need dot if parent fullpath is a single backslash)      */
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
name|strcat
argument_list|(
name|Fullpath
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* Copy child path (carat parent prefix(es) were skipped above) */
name|strcat
argument_list|(
name|Fullpath
argument_list|,
name|Path
argument_list|)
expr_stmt|;
name|Cleanup
label|:
name|ACPI_FREE
argument_list|(
name|ParentPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Fullpath
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddToExternalFileList  *  * PARAMETERS:  PathList            - Single path or list separated by comma  *  * RETURN:      None  *  * DESCRIPTION: Add external files to global list  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiDmAddToExternalFileList
parameter_list|(
name|char
modifier|*
name|Pathname
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|ExternalFile
decl_stmt|;
name|char
modifier|*
name|LocalPathname
decl_stmt|;
if|if
condition|(
operator|!
name|Pathname
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|LocalPathname
operator|=
name|ACPI_ALLOCATE
argument_list|(
name|strlen
argument_list|(
name|Pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LocalPathname
condition|)
block|{
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
name|ExternalFile
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalFile
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|LocalPathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
comment|/* Take a copy of the file pathname */
name|strcpy
argument_list|(
name|LocalPathname
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
name|ExternalFile
operator|->
name|Path
operator|=
name|LocalPathname
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|ExternalFile
operator|->
name|Next
operator|=
name|AcpiGbl_ExternalFileList
expr_stmt|;
block|}
name|AcpiGbl_ExternalFileList
operator|=
name|ExternalFile
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalFileList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Clear the external file list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalFileList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalFileList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalFileList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalsFromFile  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Process the optional external reference file.  *  * Each line in the file should be of the form:  *      External (<Method namepath>, MethodObj,<ArgCount>)  *  * Example:  *      External (_SB_.PCI0.XHC_.PS0X, MethodObj, 4)  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmGetExternalsFromFile
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|ExternalRefFile
decl_stmt|;
name|char
modifier|*
name|Token
decl_stmt|;
name|char
modifier|*
name|MethodName
decl_stmt|;
name|UINT32
name|ArgCount
decl_stmt|;
name|UINT32
name|ImportCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Gbl_ExternalRefFilename
condition|)
block|{
return|return;
block|}
comment|/* Open the file */
name|ExternalRefFile
operator|=
name|fopen
argument_list|(
name|Gbl_ExternalRefFilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalRefFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open external reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
name|AslAbort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Each line defines a method */
while|while
condition|(
name|fgets
argument_list|(
name|StringBuffer
argument_list|,
name|ASL_MSG_BUFFER_SIZE
argument_list|,
name|ExternalRefFile
argument_list|)
condition|)
block|{
name|Token
operator|=
name|strtok
argument_list|(
name|StringBuffer
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "External" */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"External"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|MethodName
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Method namepath */
if|if
condition|(
operator|!
name|MethodName
condition|)
block|{
continue|continue;
block|}
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "MethodObj" */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"MethodObj"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Arg count */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
comment|/* Convert arg count string to an integer */
name|errno
operator|=
literal|0
expr_stmt|;
name|ArgCount
operator|=
name|strtoul
argument_list|(
name|Token
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%s)\n"
argument_list|,
name|Token
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ArgCount
operator|>
literal|7
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%u)\n"
argument_list|,
name|ArgCount
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add this external to the global list */
name|AcpiOsPrintf
argument_list|(
literal|"%s: Importing method external (%u arguments) %s\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ArgCount
argument_list|,
name|MethodName
argument_list|)
expr_stmt|;
name|AcpiDmAddPathToExternalList
argument_list|(
name|MethodName
argument_list|,
name|ACPI_TYPE_METHOD
argument_list|,
name|ArgCount
argument_list|,
operator|(
name|ACPI_EXT_RESOLVED_REFERENCE
operator||
name|ACPI_EXT_ORIGIN_FROM_FILE
operator|)
argument_list|)
expr_stmt|;
name|ImportCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ImportCount
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Did not find any external methods in reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the external(s) to the namespace */
name|AcpiDmAddExternalListToNamespace
argument_list|()
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%s: Imported %u external method definitions\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ImportCount
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ExternalRefFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddOpToExternalList  *  * PARAMETERS:  Op                  - Current parser Op  *              Path                - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function handles the most common case where the referenced  *              name is simply not found in the constructed namespace.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddOpToExternalList
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|InternalPath
init|=
name|Path
decl_stmt|;
name|char
modifier|*
name|Temp
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddOpToExternalList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove a root backslash if present */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Externalize the pathname */
name|Status
operator|=
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|Path
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/*      * Get the full pathname from the root if "Path" has one or more      * parent prefixes (^). Note: path will not contain a leading '\'.      */
if|if
condition|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
condition|)
block|{
name|Temp
operator|=
name|AcpiDmNormalizeParentPrefix
argument_list|(
name|Op
argument_list|,
name|ExternalPath
argument_list|)
expr_stmt|;
comment|/* Set new external path */
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ExternalPath
operator|=
name|Temp
expr_stmt|;
if|if
condition|(
operator|!
name|Temp
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Create the new internal pathname */
name|Flags
operator||=
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
expr_stmt|;
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|ExternalPath
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
name|Flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalAndInternalPath  *  * PARAMETERS:  Node                - Namespace node for object to be added  *              ExternalPath        - Will contain the external path of the node  *              InternalPath        - Will contain the internal path of the node  *  * RETURN:      None  *  * DESCRIPTION: Get the External and Internal path from the given node.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDmGetExternalAndInternalPath
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|char
modifier|*
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
modifier|*
name|InternalPath
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
comment|/* Get the full external and internal pathnames to the node */
operator|*
name|ExternalPath
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ExternalPath
condition|)
block|{
return|return
operator|(
name|AE_BAD_PATHNAME
operator|)
return|;
block|}
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
operator|*
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
operator|*
name|ExternalPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmRemoveRootPrefix  *  * PARAMETERS:  Path                - Remove Root prefix from this Path  *  * RETURN:      None  *  * DESCRIPTION: Remove the root prefix character '\' from Path.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDmRemoveRootPrefix
parameter_list|(
name|char
modifier|*
modifier|*
name|Path
parameter_list|)
block|{
name|char
modifier|*
name|InputPath
init|=
operator|*
name|Path
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|InputPath
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|InputPath
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|memmove
argument_list|(
name|InputPath
argument_list|,
name|InputPath
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|InputPath
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
operator|*
name|Path
operator|=
name|InputPath
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddNodeToExternalList  *  * PARAMETERS:  Node                - Namespace node for object to be added  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function handles the case where the referenced name has  *              been found in the namespace, but the name originated in a  *              table other than the one that is being disassembled (such  *              as a table that is added via the iASL -e option).  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddNodeToExternalList
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddNodeToExternalList
argument_list|)
expr_stmt|;
comment|/* Get the full external and internal pathnames to the node */
name|Status
operator|=
name|AcpiDmGetExternalAndInternalPath
argument_list|(
name|Node
argument_list|,
operator|&
name|ExternalPath
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove the root backslash */
name|Status
operator|=
name|AcpiDmRemoveRootPrefix
argument_list|(
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
operator|(
name|Flags
operator||
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddPathToExternalList  *  * PARAMETERS:  Path                - External name of the object to be added  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function currently is used to add externals via a  *              reference file (via the -fe iASL option).  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDmAddPathToExternalList
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddPathToExternalList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove a root backslash if present */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Create the internal and external pathnames */
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|Path
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
name|Status
operator|=
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|InternalPath
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
operator|(
name|Flags
operator||
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCreateNewExternal  *  * PARAMETERS:  ExternalPath        - External path to the object  *              InternalPath        - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      Status  *  * DESCRIPTION: Common low-level function to insert a new name into the global  *              list of Externals which will in turn be later emitted as  *              External() declarations in the disassembled output.  *  *              Note: The external name should not include a root prefix  *              (backslash). We do not want External() statements to contain  *              a leading '\', as this prevents duplicate external statements  *              of the form:  *  *                  External (\ABCD)  *                  External (ABCD)  *  *              This would cause a compile time error when the disassembled  *              output file is recompiled.  *  *              There are two cases that are handled here. For both, we emit  *              an External() statement:  *              1) The name was simply not found in the namespace.  *              2) The name was found, but it originated in a table other than  *              the table that is being disassembled.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDmCreateNewExternal
parameter_list|(
name|char
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
name|InternalPath
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NewExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|PrevExternal
init|=
name|NULL
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmCreateNewExternal
argument_list|)
expr_stmt|;
comment|/* Check all existing externals to ensure no duplicates */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
comment|/* Check for duplicates */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ExternalPath
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
condition|)
block|{
comment|/*              * If this external came from an External() opcode, we are              * finished with this one. (No need to check any further).              */
if|if
condition|(
name|NextExternal
operator|->
name|Flags
operator|&
name|ACPI_EXT_ORIGIN_FROM_OPCODE
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_ALREADY_EXISTS
argument_list|)
expr_stmt|;
block|}
comment|/* Allow upgrade of type from ANY */
elseif|else
if|if
condition|(
operator|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_ANY
operator|)
operator|&&
operator|(
name|Type
operator|!=
name|ACPI_TYPE_ANY
operator|)
condition|)
block|{
name|NextExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
block|}
comment|/* Update the argument count as necessary */
if|if
condition|(
name|Value
operator|<
name|NextExternal
operator|->
name|Value
condition|)
block|{
name|NextExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
block|}
comment|/* Update flags. */
name|NextExternal
operator|->
name|Flags
operator||=
name|Flags
expr_stmt|;
name|NextExternal
operator|->
name|Flags
operator|&=
operator|~
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_ALREADY_EXISTS
argument_list|)
expr_stmt|;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Allocate and init a new External() descriptor */
name|NewExternal
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_LIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewExternal
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_NAMES
operator|,
literal|"Adding external reference node (%s) type [%s]\n"
operator|,
name|ExternalPath
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|Flags
operator|=
name|Flags
expr_stmt|;
name|NewExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
name|NewExternal
operator|->
name|Path
operator|=
name|ExternalPath
expr_stmt|;
name|NewExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NewExternal
operator|->
name|Length
operator|=
operator|(
name|UINT16
operator|)
name|strlen
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|InternalPath
operator|=
name|InternalPath
expr_stmt|;
comment|/* Link the new descriptor into the global list, alphabetically ordered */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|AcpiUtStricmp
argument_list|(
name|NewExternal
operator|->
name|Path
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|NewExternal
operator|->
name|Next
operator|=
name|NextExternal
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
name|PrevExternal
operator|=
name|NextExternal
expr_stmt|;
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmResolveExternal  *  * PARAMETERS:  Path               - Path of the external  *              Type               - Type of the external  *              Node               - Input node for AcpiNsLookup  *  * RETURN:      Status  *  * DESCRIPTION: Resolve the external within the namespace by AcpiNsLookup.  *              If the returned node is an external and has the same type  *              we assume that it was either an existing external or a  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDmResolveExternal
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
modifier|*
name|Node
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|Status
operator|=
name|AcpiNsLookup
argument_list|(
name|NULL
argument_list|,
name|Path
argument_list|,
name|Type
argument_list|,
name|ACPI_IMODE_LOAD_PASS1
argument_list|,
name|ACPI_NS_ERROR_IF_FOUND
operator||
name|ACPI_NS_EXTERNAL
operator||
name|ACPI_NS_DONT_OPEN_SCOPE
argument_list|,
name|NULL
argument_list|,
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"while adding external to namespace [%s]"
operator|,
name|Path
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note the asl code "external(a) external(a)" is acceptable ASL */
elseif|else
if|if
condition|(
operator|(
operator|*
name|Node
operator|)
operator|->
name|Type
operator|==
name|Type
operator|&&
operator|(
operator|*
name|Node
operator|)
operator|->
name|Flags
operator|&
name|ANOBJ_IS_EXTERNAL
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
else|else
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|AE_ERROR
operator|,
literal|"[%s] has conflicting declarations"
operator|,
name|Path
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCreateSubobjectForExternal  *  * PARAMETERS:  Type                  - Type of the external  *              Node                  - Namespace node from AcpiNsLookup  *              ParamCount            - Value to be used for Method  *  * RETURN:      None  *  * DESCRIPTION: Add one external to the namespace. Allows external to be  *              "resolved".  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmCreateSubobjectForExternal
parameter_list|(
name|UINT8
name|Type
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
modifier|*
name|Node
parameter_list|,
name|UINT32
name|ParamCount
parameter_list|)
block|{
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_METHOD
case|:
comment|/* For methods, we need to save the argument count */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_METHOD
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Method
operator|.
name|ParamCount
operator|=
operator|(
name|UINT8
operator|)
name|ParamCount
expr_stmt|;
operator|(
operator|*
name|Node
operator|)
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_REGION
case|:
comment|/* Regions require a region sub-object */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_REGION
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Region
operator|.
name|Node
operator|=
operator|*
name|Node
expr_stmt|;
operator|(
operator|*
name|Node
operator|)
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddOneExternalToNamespace  *  * PARAMETERS:  Path                   - External parse object  *              Type                   - Type of parse object  *              ParamCount             - External method parameter count  *  * RETURN:      None  *  * DESCRIPTION: Add one external to the namespace by resolvign the external  *              (by performing a namespace lookup) and annotating the resulting  *              namespace node with the approperiate information if the type  *              is ACPI_TYPE_REGION or ACPI_TYPE_METHOD.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddOneExternalToNamespace
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|ParamCount
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|Status
operator|=
name|AcpiDmResolveExternal
argument_list|(
name|Path
argument_list|,
name|Type
argument_list|,
operator|&
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return;
block|}
name|AcpiDmCreateSubobjectForExternal
argument_list|(
name|Type
argument_list|,
operator|&
name|Node
argument_list|,
name|ParamCount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddExternalListToNamespace  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Add all externals within AcpiGbl_ExternalList to the namespace.  *              Allows externals to be "resolved".  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddExternalListToNamespace
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
name|AcpiDmAddOneExternalToNamespace
argument_list|(
name|External
operator|->
name|InternalPath
argument_list|,
name|External
operator|->
name|Type
argument_list|,
name|External
operator|->
name|Value
argument_list|)
expr_stmt|;
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetUnresolvedExternalMethodCount  *  * PARAMETERS:  None  *  * RETURN:      The number of unresolved control method externals in the  *              external list  *  * DESCRIPTION: Return the number of unresolved external methods that have been  *              generated. If any unresolved control method externals have been  *              found, we must re-parse the entire definition block with the new  *              information (number of arguments for the methods.)  *              This is limitation of AML, we don't know the number of arguments  *              from the control method invocation itself.  *  *              Note: resolved external control methods are external control  *              methods encoded with the AML_EXTERNAL_OP bytecode within the  *              AML being disassembled.  *  ******************************************************************************/
end_comment

begin_function
name|UINT32
name|AcpiDmGetUnresolvedExternalMethodCount
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
name|UINT32
name|Count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
if|if
condition|(
name|External
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|&&
operator|!
operator|(
name|External
operator|->
name|Flags
operator|&
name|ACPI_EXT_ORIGIN_FROM_OPCODE
operator|)
condition|)
block|{
name|Count
operator|++
expr_stmt|;
block|}
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
return|return
operator|(
name|Count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Free the entire External info list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmEmitExternals  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Emit an External() ASL statement for each of the externals in  *              the global external info list.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmEmitExternals
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_ExternalList
condition|)
block|{
return|return;
block|}
comment|/*      * Determine the number of control methods in the external list, and      * also how many of those externals were resolved via the namespace.      */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiGbl_NumExternalMethods
operator|++
expr_stmt|;
if|if
condition|(
name|NextExternal
operator|->
name|Flags
operator|&
name|ACPI_EXT_RESOLVED_REFERENCE
condition|)
block|{
name|AcpiGbl_ResolvedExternalMethods
operator|++
expr_stmt|;
block|}
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Check if any control methods were unresolved */
name|AcpiDmUnresolvedWarning
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gbl_ExternalRefFilename
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n     * External declarations were imported from\n"
literal|"     * a reference file -- %s\n     */\n\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
block|}
comment|/*      * Walk and emit the list of externals found during the AML parsing      */
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_EXTERNAL_EMITTED
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    External (%s%s)"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for "unresolved" method reference */
if|if
condition|(
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
operator|!
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_RESOLVED_REFERENCE
operator|)
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // Warning: Unknown method, "
literal|"guessing %u arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
comment|/* Check for external from a external references file */
elseif|else
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_ORIGIN_FROM_FILE
condition|)
block|{
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // %u Arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"    // From external reference file"
argument_list|)
expr_stmt|;
block|}
comment|/* This is the normal external case */
else|else
block|{
comment|/* For methods, add a comment with the number of arguments */
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // %u Arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&=
name|ACPI_EXT_CONFLICTING_DECLARATION
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"%s"
argument_list|,
name|ExternalConflictMessage
argument_list|)
expr_stmt|;
name|AcpiDmConflictingDeclaration
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Free this external info block and move on to next external */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmMarkExternalConflict  *  * PARAMETERS:  Path          - Namepath to search  *  * RETURN:      ExternalList  *  * DESCRIPTION: Search the AcpiGbl_ExternalList for a matching path  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmMarkExternalConflict
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|ExternalList
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|char
modifier|*
name|Temp
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmMarkExternalConflict
argument_list|)
expr_stmt|;
if|if
condition|(
name|Node
operator|->
name|Flags
operator|&
name|ANOBJ_IS_EXTERNAL
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Get the full external and internal pathnames to the node */
name|Status
operator|=
name|AcpiDmGetExternalAndInternalPath
argument_list|(
name|Node
argument_list|,
operator|&
name|ExternalPath
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove the root backslash */
name|Status
operator|=
name|AcpiDmRemoveRootPrefix
argument_list|(
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
while|while
condition|(
name|ExternalList
condition|)
block|{
name|Temp
operator|=
name|ExternalList
operator|->
name|InternalPath
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ExternalList
operator|->
name|InternalPath
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|ExternalList
operator|->
name|InternalPath
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Temp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ExternalList
operator|->
name|InternalPath
argument_list|,
name|InternalPath
argument_list|)
condition|)
block|{
name|ExternalList
operator|->
name|Flags
operator||=
name|ACPI_EXT_CONFLICTING_DECLARATION
expr_stmt|;
block|}
name|ExternalList
operator|=
name|ExternalList
operator|->
name|Next
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmConflictingDeclaration  *  * PARAMETERS:  Path                - Path with conflicting declaration  *  * RETURN:      None  *  * DESCRIPTION: Emit a warning when printing conflicting ASL external  *              declarations.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDmConflictingDeclaration
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Warning - Emitting ASL code \"External (%s)\"\n"
literal|"           This is a conflicting declaration with some "
literal|"other declaration within the ASL code.\n"
literal|"           This external declaration may need to be "
literal|"deleted in order to recompile the dsl file.\n\n"
argument_list|,
name|Path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmEmitExternal  *  * PARAMETERS:  Op                  External Parse Object  *  * RETURN:      None  *  * DESCRIPTION: Emit an External() ASL statement for the current External  *              parse object. Note: External Ops are named types so the  *              namepath is contained within NameOp->Name.Path.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmEmitExternal
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|NameOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|TypeOp
parameter_list|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"External ("
argument_list|)
expr_stmt|;
name|AcpiDmNamestring
argument_list|(
name|NameOp
operator|->
name|Named
operator|.
name|Path
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%s)"
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
operator|(
name|ACPI_OBJECT_TYPE
operator|)
name|TypeOp
operator|->
name|Common
operator|.
name|Value
operator|.
name|Integer
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiDmCheckForExternalConflict
argument_list|(
name|NameOp
operator|->
name|Named
operator|.
name|Path
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCheckForExternalConflict  *  * PARAMETERS:  Path                - Path to check  *  * RETURN:      None  *  * DESCRIPTION: Search the External List to see if the input Path has a  *              conflicting declaration.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDmCheckForExternalConflict
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|ExternalList
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
name|char
modifier|*
name|ListItemPath
decl_stmt|;
name|char
modifier|*
name|InputPath
decl_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
return|return;
block|}
comment|/* Move past the root prefix '\' */
name|InputPath
operator|=
name|Path
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|InputPath
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
name|InputPath
index|[
literal|1
index|]
condition|)
block|{
name|InputPath
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ExternalList
condition|)
block|{
name|ListItemPath
operator|=
name|ExternalList
operator|->
name|Path
expr_stmt|;
if|if
condition|(
name|ListItemPath
condition|)
block|{
comment|/* Move past the root prefix '\' */
if|if
condition|(
operator|(
operator|*
name|ListItemPath
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
name|ListItemPath
index|[
literal|1
index|]
condition|)
block|{
name|ListItemPath
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ListItemPath
argument_list|,
name|InputPath
argument_list|)
operator|&&
operator|(
name|ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_CONFLICTING_DECLARATION
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"%s"
argument_list|,
name|ExternalConflictMessage
argument_list|)
expr_stmt|;
name|AcpiDmConflictingDeclaration
argument_list|(
name|Path
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ExternalList
operator|=
name|ExternalList
operator|->
name|Next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmUnresolvedWarning  *  * PARAMETERS:  Type                - Where to output the warning.  *                                    0 means write to stderr  *                                    1 means write to AcpiOsPrintf  *  * RETURN:      None  *  * DESCRIPTION: Issue warning message if there are unresolved external control  *              methods within the disassembly.  *  ******************************************************************************/
end_comment

begin_comment
comment|/* Summary of the external control method problem:  When the -e option is used with disassembly, the various SSDTs are simply loaded into a global namespace for the disassembler to use in order to resolve control method references (invocations).  The disassembler tracks any such references, and will emit an External() statement for these types of methods, with the proper number of arguments .  Without the SSDTs, the AML does not contain enough information to properly disassemble the control method invocation -- because the disassembler does not know how many arguments to parse.  An example: Assume we have two control methods. ABCD has one argument, and EFGH has zero arguments. Further, we have two additional control methods that invoke ABCD and EFGH, named T1 and T2:      Method (ABCD, 1)     {     }     Method (EFGH, 0)     {     }     Method (T1)     {         ABCD (Add (2, 7, Local0))     }     Method (T2)     {         EFGH ()         Add (2, 7, Local0)     }  Here is the AML code that is generated for T1 and T2:       185:      Method (T1)  0000034C:  14 10 54 31 5F 5F 00 ...    "..T1__."       186:      {      187:          ABCD (Add (2, 7, Local0))  00000353:  41 42 43 44 ............    "ABCD" 00000357:  72 0A 02 0A 07 60 ......    "r....`"       188:      }       190:      Method (T2)  0000035D:  14 10 54 32 5F 5F 00 ...    "..T2__."       191:      {      192:          EFGH ()  00000364:  45 46 47 48 ............    "EFGH"       193:          Add (2, 7, Local0)  00000368:  72 0A 02 0A 07 60 ......    "r....`"      194:      }  Note that the AML code for T1 and T2 is essentially identical. When disassembling this code, the methods ABCD and EFGH must be known to the disassembler, otherwise it does not know how to handle the method invocations.  In other words, if ABCD and EFGH are actually external control methods appearing in an SSDT, the disassembler does not know what to do unless the owning SSDT has been loaded via the -e option. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart1
index|[
literal|600
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart2
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart3
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart4
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|AcpiDmUnresolvedWarning
parameter_list|(
name|UINT8
name|Type
parameter_list|)
block|{
name|char
modifier|*
name|Format
decl_stmt|;
name|char
name|Pad
index|[]
init|=
literal|"     *"
decl_stmt|;
name|char
name|NoPad
index|[]
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_NumExternalMethods
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|AcpiGbl_NumExternalMethods
operator|==
name|AcpiGbl_ResolvedExternalMethods
condition|)
block|{
return|return;
block|}
name|Format
operator|=
name|Type
condition|?
name|Pad
else|:
name|NoPad
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart1
argument_list|,
literal|"%s iASL Warning: There %s %u external control method%s found during\n"
literal|"%s disassembly, but only %u %s resolved (%u unresolved). Additional\n"
literal|"%s ACPI tables may be required to properly disassemble the code. This\n"
literal|"%s resulting disassembler output file may not compile because the\n"
literal|"%s disassembler did not know how many arguments to assign to the\n"
literal|"%s unresolved methods. Note: SSDTs can be dynamically loaded at\n"
literal|"%s runtime and may or may not be available via the host OS.\n"
argument_list|,
name|Format
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|!=
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
operator|)
argument_list|,
name|Format
argument_list|,
name|AcpiGbl_ResolvedExternalMethods
argument_list|,
operator|(
name|AcpiGbl_ResolvedExternalMethods
operator|!=
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|-
name|AcpiGbl_ResolvedExternalMethods
operator|)
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart2
argument_list|,
literal|"%s To specify the tables needed to resolve external control method\n"
literal|"%s references, the -e option can be used to specify the filenames.\n"
literal|"%s Example iASL invocations:\n"
literal|"%s     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml\n"
literal|"%s     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml\n"
literal|"%s     iasl -e ssdt*.aml -d dsdt.aml\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart3
argument_list|,
literal|"%s In addition, the -fe option can be used to specify a file containing\n"
literal|"%s control method external declarations with the associated method\n"
literal|"%s argument counts. Each line of the file must be of the form:\n"
literal|"%s     External (<method pathname>, MethodObj,<argument count>)\n"
literal|"%s Invocation:\n"
literal|"%s     iasl -fe refs.txt -d dsdt.aml\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart4
argument_list|,
literal|"%s The following methods were unresolved and many not compile properly\n"
literal|"%s because the disassembler had to guess at the number of arguments\n"
literal|"%s required for each:\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
condition|)
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n%s     *\n%s     *\n%s     *\n%s     */\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart2
argument_list|,
name|ExternalWarningPart3
argument_list|,
name|ExternalWarningPart4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n%s     *\n%s     *\n%s     */\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart3
argument_list|,
name|ExternalWarningPart4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s\n%s\n%s\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart2
argument_list|,
name|ExternalWarningPart3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s\n%s\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

