begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: dtio.c - File I/O support for data table compiler  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2014, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|__DTIO_C__
end_define

begin_include
include|#
directive|include
file|"aslcompiler.h"
end_include

begin_include
include|#
directive|include
file|"dtcompiler.h"
end_include

begin_include
include|#
directive|include
file|"acapps.h"
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|DT_COMPILER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dtio"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|DtTrim
parameter_list|(
name|char
modifier|*
name|String
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DtLinkField
parameter_list|(
name|DT_FIELD
modifier|*
name|Field
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|DtParseLine
parameter_list|(
name|char
modifier|*
name|LineBuffer
parameter_list|,
name|UINT32
name|Line
parameter_list|,
name|UINT32
name|Offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DtWriteBinary
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DtDumpBuffer
parameter_list|(
name|UINT32
name|FileId
parameter_list|,
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|Offset
parameter_list|,
name|UINT32
name|Length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DtDumpSubtableInfo
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DtDumpSubtableTree
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* States for DtGetNextLine */
end_comment

begin_define
define|#
directive|define
name|DT_NORMAL_TEXT
value|0
end_define

begin_define
define|#
directive|define
name|DT_START_QUOTED_STRING
value|1
end_define

begin_define
define|#
directive|define
name|DT_START_COMMENT
value|2
end_define

begin_define
define|#
directive|define
name|DT_SLASH_ASTERISK_COMMENT
value|3
end_define

begin_define
define|#
directive|define
name|DT_SLASH_SLASH_COMMENT
value|4
end_define

begin_define
define|#
directive|define
name|DT_END_COMMENT
value|5
end_define

begin_define
define|#
directive|define
name|DT_MERGE_LINES
value|6
end_define

begin_define
define|#
directive|define
name|DT_ESCAPE_SEQUENCE
value|7
end_define

begin_decl_stmt
specifier|static
name|UINT32
name|Gbl_NextLineOffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtTrim  *  * PARAMETERS:  String              - Current source code line to trim  *  * RETURN:      Trimmed line. Must be freed by caller.  *  * DESCRIPTION: Trim left and right spaces  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DtTrim
parameter_list|(
name|char
modifier|*
name|String
parameter_list|)
block|{
name|char
modifier|*
name|Start
decl_stmt|;
name|char
modifier|*
name|End
decl_stmt|;
name|char
modifier|*
name|ReturnString
decl_stmt|;
name|ACPI_SIZE
name|Length
decl_stmt|;
comment|/* Skip lines that start with a space */
if|if
condition|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|String
argument_list|,
literal|" "
argument_list|)
condition|)
block|{
name|ReturnString
operator|=
name|UtStringCacheCalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ReturnString
operator|)
return|;
block|}
comment|/* Setup pointers to start and end of input string */
name|Start
operator|=
name|String
expr_stmt|;
name|End
operator|=
name|String
operator|+
name|ACPI_STRLEN
argument_list|(
name|String
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Find first non-whitespace character */
while|while
condition|(
operator|(
name|Start
operator|<=
name|End
operator|)
operator|&&
operator|(
operator|(
operator|*
name|Start
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|Start
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
name|Start
operator|++
expr_stmt|;
block|}
comment|/* Find last non-space character */
while|while
condition|(
name|End
operator|>=
name|Start
condition|)
block|{
if|if
condition|(
operator|*
name|End
operator|==
literal|'\r'
operator|||
operator|*
name|End
operator|==
literal|'\n'
condition|)
block|{
name|End
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|End
operator|!=
literal|' '
condition|)
block|{
break|break;
block|}
name|End
operator|--
expr_stmt|;
block|}
comment|/* Remove any quotes around the string */
if|if
condition|(
operator|*
name|Start
operator|==
literal|'\"'
condition|)
block|{
name|Start
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|End
operator|==
literal|'\"'
condition|)
block|{
name|End
operator|--
expr_stmt|;
block|}
comment|/* Create the trimmed return string */
name|Length
operator|=
name|ACPI_PTR_DIFF
argument_list|(
name|End
argument_list|,
name|Start
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ReturnString
operator|=
name|UtStringCacheCalloc
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_STRLEN
argument_list|(
name|Start
argument_list|)
condition|)
block|{
name|ACPI_STRNCPY
argument_list|(
name|ReturnString
argument_list|,
name|Start
argument_list|,
name|Length
argument_list|)
expr_stmt|;
block|}
name|ReturnString
index|[
name|Length
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ReturnString
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtLinkField  *  * PARAMETERS:  Field               - New field object to link  *  * RETURN:      None  *  * DESCRIPTION: Link one field name and value to the list  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|DtLinkField
parameter_list|(
name|DT_FIELD
modifier|*
name|Field
parameter_list|)
block|{
name|DT_FIELD
modifier|*
name|Prev
decl_stmt|;
name|DT_FIELD
modifier|*
name|Next
decl_stmt|;
name|Prev
operator|=
name|Next
operator|=
name|Gbl_FieldList
expr_stmt|;
while|while
condition|(
name|Next
condition|)
block|{
name|Prev
operator|=
name|Next
expr_stmt|;
name|Next
operator|=
name|Next
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|Prev
condition|)
block|{
name|Prev
operator|->
name|Next
operator|=
name|Field
expr_stmt|;
block|}
else|else
block|{
name|Gbl_FieldList
operator|=
name|Field
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtParseLine  *  * PARAMETERS:  LineBuffer          - Current source code line  *              Line                - Current line number in the source  *              Offset              - Current byte offset of the line  *  * RETURN:      Status  *  * DESCRIPTION: Parse one source line  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|DtParseLine
parameter_list|(
name|char
modifier|*
name|LineBuffer
parameter_list|,
name|UINT32
name|Line
parameter_list|,
name|UINT32
name|Offset
parameter_list|)
block|{
name|char
modifier|*
name|Start
decl_stmt|;
name|char
modifier|*
name|End
decl_stmt|;
name|char
modifier|*
name|TmpName
decl_stmt|;
name|char
modifier|*
name|TmpValue
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
name|Value
decl_stmt|;
name|char
modifier|*
name|Colon
decl_stmt|;
name|UINT32
name|Length
decl_stmt|;
name|DT_FIELD
modifier|*
name|Field
decl_stmt|;
name|UINT32
name|Column
decl_stmt|;
name|UINT32
name|NameColumn
decl_stmt|;
name|BOOLEAN
name|IsNullString
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|LineBuffer
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* All lines after "Raw Table Data" are ingored */
if|if
condition|(
name|strstr
argument_list|(
name|LineBuffer
argument_list|,
name|ACPI_RAW_TABLE_DATA_HEADER
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_NOT_FOUND
operator|)
return|;
block|}
name|Colon
operator|=
name|strchr
argument_list|(
name|LineBuffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Colon
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Start
operator|=
name|LineBuffer
expr_stmt|;
name|End
operator|=
name|Colon
expr_stmt|;
while|while
condition|(
name|Start
operator|<
name|Colon
condition|)
block|{
if|if
condition|(
operator|*
name|Start
operator|==
literal|'['
condition|)
block|{
comment|/* Found left bracket, go to the right bracket */
while|while
condition|(
name|Start
operator|<
name|Colon
operator|&&
operator|*
name|Start
operator|!=
literal|']'
condition|)
block|{
name|Start
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|Start
operator|!=
literal|' '
condition|)
block|{
break|break;
block|}
name|Start
operator|++
expr_stmt|;
block|}
comment|/*      * There are two column values. One for the field name,      * and one for the field value.      */
name|Column
operator|=
name|ACPI_PTR_DIFF
argument_list|(
name|Colon
argument_list|,
name|LineBuffer
argument_list|)
operator|+
literal|3
expr_stmt|;
name|NameColumn
operator|=
name|ACPI_PTR_DIFF
argument_list|(
name|Start
argument_list|,
name|LineBuffer
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Length
operator|=
name|ACPI_PTR_DIFF
argument_list|(
name|End
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|TmpName
operator|=
name|UtLocalCalloc
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ACPI_STRNCPY
argument_list|(
name|TmpName
argument_list|,
name|Start
argument_list|,
name|Length
argument_list|)
expr_stmt|;
name|Name
operator|=
name|DtTrim
argument_list|(
name|TmpName
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|TmpName
argument_list|)
expr_stmt|;
name|Start
operator|=
name|End
operator|=
operator|(
name|Colon
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|End
condition|)
block|{
comment|/* Found left quotation, go to the right quotation and break */
if|if
condition|(
operator|*
name|End
operator|==
literal|'"'
condition|)
block|{
name|End
operator|++
expr_stmt|;
comment|/* Check for an explicit null string */
if|if
condition|(
operator|*
name|End
operator|==
literal|'"'
condition|)
block|{
name|IsNullString
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|End
operator|&&
operator|(
operator|*
name|End
operator|!=
literal|'"'
operator|)
condition|)
block|{
name|End
operator|++
expr_stmt|;
block|}
name|End
operator|++
expr_stmt|;
break|break;
block|}
comment|/*          * Special "comment" fields at line end, ignore them.          * Note: normal slash-slash and slash-asterisk comments are          * stripped already by the DtGetNextLine parser.          *          * TBD: Perhaps DtGetNextLine should parse the following type          * of comments also.          */
if|if
condition|(
operator|*
name|End
operator|==
literal|'['
condition|)
block|{
name|End
operator|--
expr_stmt|;
break|break;
block|}
name|End
operator|++
expr_stmt|;
block|}
name|Length
operator|=
name|ACPI_PTR_DIFF
argument_list|(
name|End
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|TmpValue
operator|=
name|UtLocalCalloc
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ACPI_STRNCPY
argument_list|(
name|TmpValue
argument_list|,
name|Start
argument_list|,
name|Length
argument_list|)
expr_stmt|;
name|Value
operator|=
name|DtTrim
argument_list|(
name|TmpValue
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|TmpValue
argument_list|)
expr_stmt|;
comment|/* Create a new field object only if we have a valid value field */
if|if
condition|(
operator|(
name|Value
operator|&&
operator|*
name|Value
operator|)
operator|||
name|IsNullString
condition|)
block|{
name|Field
operator|=
name|UtFieldCacheCalloc
argument_list|()
expr_stmt|;
name|Field
operator|->
name|Name
operator|=
name|Name
expr_stmt|;
name|Field
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
name|Field
operator|->
name|Line
operator|=
name|Line
expr_stmt|;
name|Field
operator|->
name|ByteOffset
operator|=
name|Offset
expr_stmt|;
name|Field
operator|->
name|NameColumn
operator|=
name|NameColumn
expr_stmt|;
name|Field
operator|->
name|Column
operator|=
name|Column
expr_stmt|;
name|DtLinkField
argument_list|(
name|Field
argument_list|)
expr_stmt|;
block|}
comment|/* Else -- Ignore this field, it has no valid data */
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtGetNextLine  *  * PARAMETERS:  Handle              - Open file handle for the source file  *  * RETURN:      Filled line buffer and offset of start-of-line (ASL_EOF on EOF)  *  * DESCRIPTION: Get the next valid source line. Removes all comments.  *              Ignores empty lines.  *  * Handles both slash-asterisk and slash-slash comments.  * Also, quoted strings, but no escapes within.  *  * Line is returned in Gbl_CurrentLineBuffer.  * Line number in original file is returned in Gbl_CurrentLineNumber.  *  *****************************************************************************/
end_comment

begin_function
name|UINT32
name|DtGetNextLine
parameter_list|(
name|FILE
modifier|*
name|Handle
parameter_list|)
block|{
name|BOOLEAN
name|LineNotAllBlanks
init|=
name|FALSE
decl_stmt|;
name|UINT32
name|State
init|=
name|DT_NORMAL_TEXT
decl_stmt|;
name|UINT32
name|CurrentLineOffset
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/*          * If line is too long, expand the line buffers. Also increases          * Gbl_LineBufferSize.          */
if|if
condition|(
name|i
operator|>=
name|Gbl_LineBufferSize
condition|)
block|{
name|UtExpandLineBuffers
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|DT_START_QUOTED_STRING
case|:
case|case
name|DT_SLASH_ASTERISK_COMMENT
case|:
name|AcpiOsPrintf
argument_list|(
literal|"**** EOF within comment/string %u\n"
argument_list|,
name|State
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Standalone EOF is OK */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ASL_EOF
operator|)
return|;
block|}
comment|/*              * Received an EOF in the middle of a line. Terminate the              * line with a newline. The next call to this function will              * return a standalone EOF. Thus, the upper parsing software              * never has to deal with an EOF within a valid line (or              * the last line does not get tossed on the floor.)              */
name|c
operator|=
literal|'\n'
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
block|}
switch|switch
condition|(
name|State
condition|)
block|{
case|case
name|DT_NORMAL_TEXT
case|:
comment|/* Normal text, insert char into line buffer */
name|Gbl_CurrentLineBuffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
name|State
operator|=
name|DT_START_COMMENT
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|State
operator|=
name|DT_START_QUOTED_STRING
expr_stmt|;
name|LineNotAllBlanks
operator|=
name|TRUE
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/*                  * The continuation char MUST be last char on this line.                  * Otherwise, it will be assumed to be a valid ASL char.                  */
name|State
operator|=
name|DT_MERGE_LINES
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|CurrentLineOffset
operator|=
name|Gbl_NextLineOffset
expr_stmt|;
name|Gbl_NextLineOffset
operator|=
operator|(
name|UINT32
operator|)
name|ftell
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
name|Gbl_CurrentLineNumber
operator|++
expr_stmt|;
comment|/*                  * Exit if line is complete. Ignore empty lines (only \n)                  * or lines that contain nothing but blanks.                  */
if|if
condition|(
operator|(
name|i
operator|!=
literal|0
operator|)
operator|&&
name|LineNotAllBlanks
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>=
name|Gbl_LineBufferSize
condition|)
block|{
name|UtExpandLineBuffers
argument_list|()
expr_stmt|;
block|}
name|Gbl_CurrentLineBuffer
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Terminate string */
return|return
operator|(
name|CurrentLineOffset
operator|)
return|;
block|}
comment|/* Toss this line and start a new one */
name|i
operator|=
literal|0
expr_stmt|;
name|LineNotAllBlanks
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
block|{
name|LineNotAllBlanks
operator|=
name|TRUE
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DT_START_QUOTED_STRING
case|:
comment|/* Insert raw chars until end of quoted string */
name|Gbl_CurrentLineBuffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|State
operator|=
name|DT_ESCAPE_SEQUENCE
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|AcpiOsPrintf
argument_list|(
literal|"ERROR at line %u: Unterminated quoted string\n"
argument_list|,
name|Gbl_CurrentLineNumber
operator|++
argument_list|)
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
break|break;
default|default:
comment|/* Get next character */
break|break;
block|}
break|break;
case|case
name|DT_ESCAPE_SEQUENCE
case|:
comment|/* Just copy the escaped character. TBD: sufficient for table compiler? */
name|Gbl_CurrentLineBuffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|State
operator|=
name|DT_START_QUOTED_STRING
expr_stmt|;
break|break;
case|case
name|DT_START_COMMENT
case|:
comment|/* Open comment if this character is an asterisk or slash */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
name|State
operator|=
name|DT_SLASH_ASTERISK_COMMENT
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|State
operator|=
name|DT_SLASH_SLASH_COMMENT
expr_stmt|;
break|break;
default|default:
comment|/* Not a comment */
name|i
operator|++
expr_stmt|;
comment|/* Save the preceding slash */
if|if
condition|(
name|i
operator|>=
name|Gbl_LineBufferSize
condition|)
block|{
name|UtExpandLineBuffers
argument_list|()
expr_stmt|;
block|}
name|Gbl_CurrentLineBuffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DT_SLASH_ASTERISK_COMMENT
case|:
comment|/* Ignore chars until an asterisk-slash is found */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|Gbl_NextLineOffset
operator|=
operator|(
name|UINT32
operator|)
name|ftell
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
name|Gbl_CurrentLineNumber
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|State
operator|=
name|DT_END_COMMENT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|DT_SLASH_SLASH_COMMENT
case|:
comment|/* Ignore chars until end-of-line */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* We will exit via the NORMAL_TEXT path */
name|ungetc
argument_list|(
name|c
argument_list|,
name|Handle
argument_list|)
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
block|}
break|break;
case|case
name|DT_END_COMMENT
case|:
comment|/* End comment if this char is a slash */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|CurrentLineOffset
operator|=
name|Gbl_NextLineOffset
expr_stmt|;
name|Gbl_NextLineOffset
operator|=
operator|(
name|UINT32
operator|)
name|ftell
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
name|Gbl_CurrentLineNumber
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* Consume all adjacent asterisks */
break|break;
default|default:
name|State
operator|=
name|DT_SLASH_ASTERISK_COMMENT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DT_MERGE_LINES
case|:
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
comment|/*                  * This is not a continuation backslash, it is a normal                  * normal ASL backslash - for example: Scope(\_SB_)                  */
name|i
operator|++
expr_stmt|;
comment|/* Keep the backslash that is already in the buffer */
name|ungetc
argument_list|(
name|c
argument_list|,
name|Handle
argument_list|)
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * This is a continuation line -- a backlash followed                  * immediately by a newline. Insert a space between the                  * lines (overwrite the backslash)                  */
name|Gbl_CurrentLineBuffer
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* Ignore newline, this will merge the lines */
name|CurrentLineOffset
operator|=
name|Gbl_NextLineOffset
expr_stmt|;
name|Gbl_NextLineOffset
operator|=
operator|(
name|UINT32
operator|)
name|ftell
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
name|Gbl_CurrentLineNumber
operator|++
expr_stmt|;
name|State
operator|=
name|DT_NORMAL_TEXT
expr_stmt|;
block|}
break|break;
default|default:
name|DtFatal
argument_list|(
name|ASL_MSG_COMPILER_INTERNAL
argument_list|,
name|NULL
argument_list|,
literal|"Unknown input state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASL_EOF
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtScanFile  *  * PARAMETERS:  Handle              - Open file handle for the source file  *  * RETURN:      Pointer to start of the constructed parse tree.  *  * DESCRIPTION: Scan source file, link all field names and values  *              to the global parse tree: Gbl_FieldList  *  *****************************************************************************/
end_comment

begin_function
name|DT_FIELD
modifier|*
name|DtScanFile
parameter_list|(
name|FILE
modifier|*
name|Handle
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT32
name|Offset
decl_stmt|;
name|ACPI_FUNCTION_NAME
argument_list|(
name|DtScanFile
argument_list|)
expr_stmt|;
comment|/* Get the file size */
name|Gbl_InputByteCount
operator|=
name|CmGetFileSize
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gbl_InputByteCount
operator|==
name|ACPI_UINT32_MAX
condition|)
block|{
name|AslAbort
argument_list|()
expr_stmt|;
block|}
name|Gbl_CurrentLineNumber
operator|=
literal|0
expr_stmt|;
name|Gbl_CurrentLineOffset
operator|=
literal|0
expr_stmt|;
name|Gbl_NextLineOffset
operator|=
literal|0
expr_stmt|;
comment|/* Scan line-by-line */
while|while
condition|(
operator|(
name|Offset
operator|=
name|DtGetNextLine
argument_list|(
name|Handle
argument_list|)
operator|)
operator|!=
name|ASL_EOF
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_PARSE
operator|,
literal|"Line %2.2u/%4.4X - %s"
operator|,
name|Gbl_CurrentLineNumber
operator|,
name|Offset
operator|,
name|Gbl_CurrentLineBuffer
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|DtParseLine
argument_list|(
name|Gbl_CurrentLineBuffer
argument_list|,
name|Gbl_CurrentLineNumber
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|AE_NOT_FOUND
condition|)
block|{
break|break;
block|}
block|}
comment|/* Dump the parse tree if debug enabled */
name|DtDumpFieldList
argument_list|(
name|Gbl_FieldList
argument_list|)
expr_stmt|;
return|return
operator|(
name|Gbl_FieldList
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output functions  */
end_comment

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtWriteBinary  *  * PARAMETERS:  DT_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Write one subtable of a binary ACPI table  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|DtWriteBinary
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|FlWriteFile
argument_list|(
name|ASL_FILE_AML_OUTPUT
argument_list|,
name|Subtable
operator|->
name|Buffer
argument_list|,
name|Subtable
operator|->
name|Length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtOutputBinary  *  * PARAMETERS:  *  * RETURN:      Status  *  * DESCRIPTION: Write entire binary ACPI table (result of compilation)  *  *****************************************************************************/
end_comment

begin_function
name|void
name|DtOutputBinary
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|RootTable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|RootTable
condition|)
block|{
return|return;
block|}
comment|/* Walk the entire parse tree, emitting the binary data */
name|DtWalkTableTree
argument_list|(
name|RootTable
argument_list|,
name|DtWriteBinary
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Gbl_TableLength
operator|=
name|CmGetFileSize
argument_list|(
name|Gbl_Files
index|[
name|ASL_FILE_AML_OUTPUT
index|]
operator|.
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gbl_TableLength
operator|==
name|ACPI_UINT32_MAX
condition|)
block|{
name|AslAbort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Listing support  */
end_comment

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtDumpBuffer  *  * PARAMETERS:  FileID              - Where to write buffer data  *              Buffer              - Buffer to dump  *              Offset              - Offset in current table  *              Length              - Buffer Length  *  * RETURN:      None  *  * DESCRIPTION: Another copy of DumpBuffer routine (unfortunately).  *  * TBD: merge dump buffer routines  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|DtDumpBuffer
parameter_list|(
name|UINT32
name|FileId
parameter_list|,
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|Offset
parameter_list|,
name|UINT32
name|Length
parameter_list|)
block|{
name|UINT32
name|i
decl_stmt|;
name|UINT32
name|j
decl_stmt|;
name|UINT8
name|BufChar
decl_stmt|;
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"Output: [%3.3Xh %4.4d %3d] "
argument_list|,
name|Offset
argument_list|,
name|Offset
argument_list|,
name|Length
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|Length
condition|)
block|{
if|if
condition|(
name|i
operator|>=
literal|16
condition|)
block|{
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"%24s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Print 16 hex chars */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|+
name|j
operator|>=
name|Length
condition|)
block|{
comment|/* Dump fill spaces */
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
continue|continue;
block|}
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"%02X "
argument_list|,
name|Buffer
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|j
operator|>=
name|Length
condition|)
block|{
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|BufChar
operator|=
name|Buffer
index|[
operator|(
name|ACPI_SIZE
operator|)
name|i
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ACPI_IS_PRINT
argument_list|(
name|BufChar
argument_list|)
condition|)
block|{
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"%c"
argument_list|,
name|BufChar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Done with that line. */
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|16
expr_stmt|;
block|}
name|FlPrintFile
argument_list|(
name|FileId
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtDumpFieldList  *  * PARAMETERS:  Field               - Root field  *  * RETURN:      None  *  * DESCRIPTION: Dump the entire field list  *  *****************************************************************************/
end_comment

begin_function
name|void
name|DtDumpFieldList
parameter_list|(
name|DT_FIELD
modifier|*
name|Field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Gbl_DebugFlag
operator|||
operator|!
name|Field
condition|)
block|{
return|return;
block|}
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"\nField List:\n"
literal|"LineNo   ByteOff  NameCol  Column   TableOff "
literal|"Flags    %32s : %s\n\n"
argument_list|,
literal|"Name"
argument_list|,
literal|"Value"
argument_list|)
expr_stmt|;
while|while
condition|(
name|Field
condition|)
block|{
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"%.08X %.08X %.08X %.08X %.08X %.08X %32s : %s\n"
argument_list|,
name|Field
operator|->
name|Line
argument_list|,
name|Field
operator|->
name|ByteOffset
argument_list|,
name|Field
operator|->
name|NameColumn
argument_list|,
name|Field
operator|->
name|Column
argument_list|,
name|Field
operator|->
name|TableOffset
argument_list|,
name|Field
operator|->
name|Flags
argument_list|,
name|Field
operator|->
name|Name
argument_list|,
name|Field
operator|->
name|Value
argument_list|)
expr_stmt|;
name|Field
operator|=
name|Field
operator|->
name|Next
expr_stmt|;
block|}
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtDumpSubtableInfo, DtDumpSubtableTree  *  * PARAMETERS:  DT_WALK_CALLBACK  *  * RETURN:      None  *  * DESCRIPTION: Info - dump a subtable tree entry with extra information.  *              Tree - dump a subtable tree formatted by depth indentation.  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|DtDumpSubtableInfo
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"[%.04X] %.08X %.08X %.08X %.08X %.08X %p %p %p\n"
argument_list|,
name|Subtable
operator|->
name|Depth
argument_list|,
name|Subtable
operator|->
name|Length
argument_list|,
name|Subtable
operator|->
name|TotalLength
argument_list|,
name|Subtable
operator|->
name|SizeOfLengthField
argument_list|,
name|Subtable
operator|->
name|Flags
argument_list|,
name|Subtable
argument_list|,
name|Subtable
operator|->
name|Parent
argument_list|,
name|Subtable
operator|->
name|Child
argument_list|,
name|Subtable
operator|->
name|Peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DtDumpSubtableTree
parameter_list|(
name|DT_SUBTABLE
modifier|*
name|Subtable
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"[%.04X] %*s%08X (%.02X) - (%.02X)\n"
argument_list|,
name|Subtable
operator|->
name|Depth
argument_list|,
operator|(
literal|4
operator|*
name|Subtable
operator|->
name|Depth
operator|)
argument_list|,
literal|" "
argument_list|,
name|Subtable
argument_list|,
name|Subtable
operator|->
name|Length
argument_list|,
name|Subtable
operator|->
name|TotalLength
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtDumpSubtableList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Dump the raw list of subtables with information, and also  *              dump the subtable list in formatted tree format. Assists with  *              the development of new table code.  *  *****************************************************************************/
end_comment

begin_function
name|void
name|DtDumpSubtableList
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Gbl_DebugFlag
operator|||
operator|!
name|Gbl_RootTable
condition|)
block|{
return|return;
block|}
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"Subtable Info:\n"
literal|"Depth  Length   TotalLen LenSize  Flags    "
literal|"This     Parent   Child    Peer\n\n"
argument_list|)
expr_stmt|;
name|DtWalkTableTree
argument_list|(
name|Gbl_RootTable
argument_list|,
name|DtDumpSubtableInfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"\nSubtable Tree: (Depth, Subtable, Length, TotalLength)\n\n"
argument_list|)
expr_stmt|;
name|DtWalkTableTree
argument_list|(
name|Gbl_RootTable
argument_list|,
name|DtDumpSubtableTree
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtWriteFieldToListing  *  * PARAMETERS:  Buffer              - Contains the compiled data  *              Field               - Field node for the input line  *              Length              - Length of the output data  *  * RETURN:      None  *  * DESCRIPTION: Write one field to the listing file (if listing is enabled).  *  *****************************************************************************/
end_comment

begin_function
name|void
name|DtWriteFieldToListing
parameter_list|(
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|DT_FIELD
modifier|*
name|Field
parameter_list|,
name|UINT32
name|Length
parameter_list|)
block|{
name|UINT8
name|FileByte
decl_stmt|;
if|if
condition|(
operator|!
name|Gbl_ListingFlag
operator|||
operator|!
name|Field
condition|)
block|{
return|return;
block|}
comment|/* Dump the original source line */
name|FlPrintFile
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
literal|"Input:  "
argument_list|)
expr_stmt|;
name|FlSeekFile
argument_list|(
name|ASL_FILE_INPUT
argument_list|,
name|Field
operator|->
name|ByteOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|FlReadFile
argument_list|(
name|ASL_FILE_INPUT
argument_list|,
operator|&
name|FileByte
argument_list|,
literal|1
argument_list|)
operator|==
name|AE_OK
condition|)
block|{
name|FlWriteFile
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
operator|&
name|FileByte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileByte
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
block|}
comment|/* Dump the line as parsed and represented internally */
name|FlPrintFile
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
literal|"Parsed: %*s : %.64s"
argument_list|,
name|Field
operator|->
name|Column
operator|-
literal|4
argument_list|,
name|Field
operator|->
name|Name
argument_list|,
name|Field
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|Field
operator|->
name|Value
argument_list|)
operator|>
literal|64
condition|)
block|{
name|FlPrintFile
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
literal|"...Additional data, length 0x%X\n"
argument_list|,
name|strlen
argument_list|(
name|Field
operator|->
name|Value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FlPrintFile
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Dump the hex data that will be output for this field */
name|DtDumpBuffer
argument_list|(
name|ASL_FILE_LISTING_OUTPUT
argument_list|,
name|Buffer
argument_list|,
name|Field
operator|->
name|TableOffset
argument_list|,
name|Length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * FUNCTION:    DtWriteTableToListing  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Write the entire compiled table to the listing file  *              in hex format  *  *****************************************************************************/
end_comment

begin_function
name|void
name|DtWriteTableToListing
parameter_list|(
name|void
parameter_list|)
block|{
name|UINT8
modifier|*
name|Buffer
decl_stmt|;
if|if
condition|(
operator|!
name|Gbl_ListingFlag
condition|)
block|{
return|return;
block|}
comment|/* Read the entire table from the output file */
name|Buffer
operator|=
name|UtLocalCalloc
argument_list|(
name|Gbl_TableLength
argument_list|)
expr_stmt|;
name|FlSeekFile
argument_list|(
name|ASL_FILE_AML_OUTPUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FlReadFile
argument_list|(
name|ASL_FILE_AML_OUTPUT
argument_list|,
name|Buffer
argument_list|,
name|Gbl_TableLength
argument_list|)
expr_stmt|;
comment|/* Dump the raw table data */
name|AcpiOsRedirectOutput
argument_list|(
name|Gbl_Files
index|[
name|ASL_FILE_LISTING_OUTPUT
index|]
operator|.
name|Handle
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\n%s: Length %d (0x%X)\n\n"
argument_list|,
name|ACPI_RAW_TABLE_DATA_HEADER
argument_list|,
name|Gbl_TableLength
argument_list|,
name|Gbl_TableLength
argument_list|)
expr_stmt|;
name|AcpiUtDumpBuffer
argument_list|(
name|Buffer
argument_list|,
name|Gbl_TableLength
argument_list|,
name|DB_BYTE_DISPLAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AcpiOsRedirectOutput
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

