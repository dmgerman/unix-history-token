begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: aslxref - Namespace cross-reference  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2016, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|"aslcompiler.h"
end_include

begin_include
include|#
directive|include
file|"aslcompiler.y.h"
end_include

begin_include
include|#
directive|include
file|"acparser.h"
end_include

begin_include
include|#
directive|include
file|"amlcode.h"
end_include

begin_include
include|#
directive|include
file|"acnamesp.h"
end_include

begin_include
include|#
directive|include
file|"acdispat.h"
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_COMPILER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"aslxref"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|ACPI_STATUS
name|XfNamespaceLocateBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|XfNamespaceLocateEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_PARSE_OBJECT
modifier|*
name|XfGetParentMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|XfObjectExists
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|XfCompareOneNamespaceObject
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|XfCheckFieldRange
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|RegionBitLength
parameter_list|,
name|UINT32
name|FieldBitOffset
parameter_list|,
name|UINT32
name|FieldBitLength
parameter_list|,
name|UINT32
name|AccessBitWidth
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__UNDER_DEVELOPMENT
end_ifdef

begin_function_decl
specifier|static
name|ACPI_PARSE_OBJECT
modifier|*
name|XfGetParentMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|XfCheckIllegalReference
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|XfIsObjectParental
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|MethodOp1
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|MethodOp2
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfCrossReferenceNamespace  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Perform a cross reference check of the parse tree against the  *              namespace. Every named referenced within the parse tree  *              should be get resolved with a namespace lookup. If not, the  *              original reference in the ASL code is invalid -- i.e., refers  *              to a non-existent object.  *  * NOTE:  The ASL "External" operator causes the name to be inserted into the  *        namespace so that references to the external name will be resolved  *        correctly here.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|XfCrossReferenceNamespace
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_WALK_STATE
modifier|*
name|WalkState
decl_stmt|;
comment|/*      * Create a new walk state for use when looking up names      * within the namespace (Passed as context to the callbacks)      */
name|WalkState
operator|=
name|AcpiDsCreateWalkState
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WalkState
condition|)
block|{
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
comment|/* Walk the entire parse tree */
name|TrWalkParseTree
argument_list|(
name|Gbl_ParseTreeRoot
argument_list|,
name|ASL_WALK_VISIT_TWICE
argument_list|,
name|XfNamespaceLocateBegin
argument_list|,
name|XfNamespaceLocateEnd
argument_list|,
name|WalkState
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|WalkState
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfObjectExists  *  * PARAMETERS:  Name            - 4 char ACPI name  *  * RETURN:      TRUE if name exists in namespace  *  * DESCRIPTION: Walk the namespace to find an object  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|XfObjectExists
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
comment|/* Walk entire namespace from the supplied root */
name|Status
operator|=
name|AcpiNsWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|FALSE
argument_list|,
name|XfCompareOneNamespaceObject
argument_list|,
name|NULL
argument_list|,
name|Name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|AE_CTRL_TRUE
condition|)
block|{
comment|/* At least one instance of the name was found */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfCompareOneNamespaceObject  *  * PARAMETERS:  ACPI_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Compare name of one object.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|XfCompareOneNamespaceObject
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
comment|/* Simply check the name */
if|if
condition|(
operator|*
operator|(
operator|(
name|UINT32
operator|*
operator|)
operator|(
name|Context
operator|)
operator|)
operator|==
name|Node
operator|->
name|Name
operator|.
name|Integer
condition|)
block|{
comment|/* Abort walk if we found one instance */
return|return
operator|(
name|AE_CTRL_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfCheckFieldRange  *  * PARAMETERS:  RegionBitLength     - Length of entire parent region  *              FieldBitOffset      - Start of the field unit (within region)  *              FieldBitLength      - Entire length of field unit  *              AccessBitWidth      - Access width of the field unit  *  * RETURN:      None  *  * DESCRIPTION: Check one field unit to make sure it fits in the parent  *              op region.  *  * Note: AccessBitWidth must be either 8,16,32, or 64  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|XfCheckFieldRange
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|RegionBitLength
parameter_list|,
name|UINT32
name|FieldBitOffset
parameter_list|,
name|UINT32
name|FieldBitLength
parameter_list|,
name|UINT32
name|AccessBitWidth
parameter_list|)
block|{
name|UINT32
name|FieldEndBitOffset
decl_stmt|;
comment|/*      * Check each field unit against the region size. The entire      * field unit (start offset plus length) must fit within the      * region.      */
name|FieldEndBitOffset
operator|=
name|FieldBitOffset
operator|+
name|FieldBitLength
expr_stmt|;
if|if
condition|(
name|FieldEndBitOffset
operator|>
name|RegionBitLength
condition|)
block|{
comment|/* Field definition itself is beyond the end-of-region */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_FIELD_UNIT_OFFSET
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Now check that the field plus AccessWidth doesn't go beyond      * the end-of-region. Assumes AccessBitWidth is a power of 2      */
name|FieldEndBitOffset
operator|=
name|ACPI_ROUND_UP
argument_list|(
name|FieldEndBitOffset
argument_list|,
name|AccessBitWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|FieldEndBitOffset
operator|>
name|RegionBitLength
condition|)
block|{
comment|/* Field definition combined with the access is beyond EOR */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_FIELD_UNIT_ACCESS_WIDTH
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfGetParentMethod  *  * PARAMETERS:  Op                      - Parse Op to be checked  *  * RETURN:      Control method Op if found. NULL otherwise  *  * DESCRIPTION: Find the control method parent of a parse op. Returns NULL if  *              the input Op is not within a control method.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_PARSE_OBJECT
modifier|*
name|XfGetParentMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|NextOp
decl_stmt|;
name|NextOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
while|while
condition|(
name|NextOp
condition|)
block|{
if|if
condition|(
name|NextOp
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_METHOD_OP
condition|)
block|{
return|return
operator|(
name|NextOp
operator|)
return|;
block|}
name|NextOp
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* No parent method found */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfNamespaceLocateBegin  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Descending callback used during cross-reference. For named  *              object references, attempt to locate the name in the  *              namespace.  *  * NOTE: ASL references to named fields within resource descriptors are  *       resolved to integer values here. Therefore, this step is an  *       important part of the code generation. We don't know that the  *       name refers to a resource descriptor until now.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|XfNamespaceLocateBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|ACPI_WALK_STATE
modifier|*
name|WalkState
init|=
operator|(
name|ACPI_WALK_STATE
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|ObjectType
decl_stmt|;
name|char
modifier|*
name|Path
decl_stmt|;
name|UINT8
name|PassedArgs
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|NextOp
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|OwningOp
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|SpaceIdOp
decl_stmt|;
name|UINT32
name|MinimumLength
decl_stmt|;
name|UINT32
name|Offset
decl_stmt|;
name|UINT32
name|FieldBitLength
decl_stmt|;
name|UINT32
name|TagBitLength
decl_stmt|;
name|UINT8
name|Message
init|=
literal|0
decl_stmt|;
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
decl_stmt|;
name|UINT32
name|Flags
decl_stmt|;
name|ASL_METHOD_LOCAL
modifier|*
name|MethodLocals
init|=
name|NULL
decl_stmt|;
name|ASL_METHOD_LOCAL
modifier|*
name|MethodArgs
init|=
name|NULL
decl_stmt|;
name|int
name|RegisterNumber
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|ACPI_FUNCTION_TRACE_PTR
argument_list|(
name|XfNamespaceLocateBegin
argument_list|,
name|Op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_METHOD_OP
operator|)
operator|&&
name|Op
operator|->
name|Asl
operator|.
name|Node
condition|)
block|{
name|Node
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
comment|/* Support for method LocalX/ArgX analysis */
if|if
condition|(
operator|!
name|Node
operator|->
name|MethodLocals
condition|)
block|{
comment|/* Create local/arg info blocks */
name|MethodLocals
operator|=
name|UtLocalCalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASL_METHOD_LOCAL
argument_list|)
operator|*
name|ACPI_METHOD_NUM_LOCALS
argument_list|)
expr_stmt|;
name|Node
operator|->
name|MethodLocals
operator|=
name|MethodLocals
expr_stmt|;
name|MethodArgs
operator|=
name|UtLocalCalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASL_METHOD_LOCAL
argument_list|)
operator|*
name|ACPI_METHOD_NUM_ARGS
argument_list|)
expr_stmt|;
name|Node
operator|->
name|MethodArgs
operator|=
name|MethodArgs
expr_stmt|;
comment|/*              * Get the method argument count              * First, get the name node              */
name|NextOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
comment|/* Get the NumArguments node */
name|NextOp
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|Node
operator|->
name|ArgCount
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
operator|(
name|UINT8
operator|)
name|NextOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
comment|/* We will track all posible ArgXs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_METHOD_NUM_ARGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|Node
operator|->
name|ArgCount
condition|)
block|{
comment|/* Real Args are always "initialized" */
name|MethodArgs
index|[
name|i
index|]
operator|.
name|Flags
operator|=
name|ASL_ARG_INITIALIZED
expr_stmt|;
block|}
else|else
block|{
comment|/* Other ArgXs can be used as locals */
name|MethodArgs
index|[
name|i
index|]
operator|.
name|Flags
operator|=
name|ASL_ARG_IS_LOCAL
expr_stmt|;
block|}
name|MethodArgs
index|[
name|i
index|]
operator|.
name|Op
operator|=
name|Op
expr_stmt|;
block|}
block|}
block|}
comment|/*      * If this node is the actual declaration of a name      * [such as the XXXX name in "Method (XXXX)"],      * we are not interested in it here. We only care about names that are      * references to other objects within the namespace and the parent objects      * of name declarations      */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_NAME_DECLARATION
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
name|OpInfo
operator|=
name|AcpiPsGetOpcodeInfo
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
expr_stmt|;
comment|/* Check method LocalX variables */
if|if
condition|(
name|OpInfo
operator|->
name|Type
operator|==
name|AML_TYPE_LOCAL_VARIABLE
condition|)
block|{
comment|/* Find parent method Op */
name|NextOp
operator|=
name|XfGetParentMethod
argument_list|(
name|Op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NextOp
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Get method node */
name|Node
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
name|RegisterNumber
operator|=
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|&
literal|0x0007
expr_stmt|;
comment|/* 0x60 through 0x67 */
name|MethodLocals
operator|=
name|Node
operator|->
name|MethodLocals
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_TARGET
condition|)
block|{
comment|/* Local is being initialized */
name|MethodLocals
index|[
name|RegisterNumber
index|]
operator|.
name|Flags
operator||=
name|ASL_LOCAL_INITIALIZED
expr_stmt|;
name|MethodLocals
index|[
name|RegisterNumber
index|]
operator|.
name|Op
operator|=
name|Op
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Mark this Local as referenced */
name|MethodLocals
index|[
name|RegisterNumber
index|]
operator|.
name|Flags
operator||=
name|ASL_LOCAL_REFERENCED
expr_stmt|;
name|MethodLocals
index|[
name|RegisterNumber
index|]
operator|.
name|Op
operator|=
name|Op
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Check method ArgX variables */
if|if
condition|(
name|OpInfo
operator|->
name|Type
operator|==
name|AML_TYPE_METHOD_ARGUMENT
condition|)
block|{
comment|/* Find parent method Op */
name|NextOp
operator|=
name|XfGetParentMethod
argument_list|(
name|Op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NextOp
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Get method node */
name|Node
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
comment|/* Get Arg # */
name|RegisterNumber
operator|=
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|-
name|AML_ARG0
expr_stmt|;
comment|/* 0x68 through 0x6F */
name|MethodArgs
operator|=
name|Node
operator|->
name|MethodArgs
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_TARGET
condition|)
block|{
comment|/* Arg is being initialized */
name|MethodArgs
index|[
name|RegisterNumber
index|]
operator|.
name|Flags
operator||=
name|ASL_ARG_INITIALIZED
expr_stmt|;
name|MethodArgs
index|[
name|RegisterNumber
index|]
operator|.
name|Op
operator|=
name|Op
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Mark this Arg as referenced */
name|MethodArgs
index|[
name|RegisterNumber
index|]
operator|.
name|Flags
operator||=
name|ASL_ARG_REFERENCED
expr_stmt|;
name|MethodArgs
index|[
name|RegisterNumber
index|]
operator|.
name|Op
operator|=
name|Op
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/*      * After method ArgX and LocalX, we are only interested in opcodes      * that have an associated name      */
if|if
condition|(
operator|(
operator|!
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_NAMED
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_CREATE
operator|)
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_NAMESTRING
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_NAMESEG
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_METHODCALL
operator|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/*      * One special case: CondRefOf operator - we don't care if the name exists      * or not at this point, just ignore it, the point of the operator is to      * determine if the name exists at runtime.      */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_CONDREFOF
operator|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/*      * We must enable the "search-to-root" for single NameSegs, but      * we have to be very careful about opening up scopes      */
name|Flags
operator|=
name|ACPI_NS_SEARCH_PARENT
expr_stmt|;
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESTRING
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESEG
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
condition|)
block|{
comment|/*          * These are name references, do not push the scope stack          * for them.          */
name|Flags
operator||=
name|ACPI_NS_DONT_OPEN_SCOPE
expr_stmt|;
block|}
comment|/* Get the NamePath from the appropriate place */
if|if
condition|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_NAMED
condition|)
block|{
comment|/* For nearly all NAMED operators, the name reference is the first child */
name|Path
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_ALIAS_OP
condition|)
block|{
comment|/*              * ALIAS is the only oddball opcode, the name declaration              * (alias name) is the second operand              */
name|Path
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_CREATE
condition|)
block|{
comment|/* Name must appear as the last parameter */
name|NextOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|NextOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_NAME_DECLARATION
operator|)
condition|)
block|{
name|NextOp
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
name|Path
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
expr_stmt|;
block|}
else|else
block|{
name|Path
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
expr_stmt|;
block|}
name|ObjectType
operator|=
name|AslMapNamedOpcodeToDataType
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_DISPATCH
operator|,
literal|"Type=%s\n"
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|ObjectType
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Lookup the name in the namespace. Name must exist at this point, or it      * is an invalid reference.      *      * The namespace is also used as a lookup table for references to resource      * descriptors and the fields within them.      */
name|Gbl_NsLookupCount
operator|++
expr_stmt|;
name|Status
operator|=
name|AcpiNsLookup
argument_list|(
name|WalkState
operator|->
name|ScopeInfo
argument_list|,
name|Path
argument_list|,
name|ObjectType
argument_list|,
name|ACPI_IMODE_EXECUTE
argument_list|,
name|Flags
argument_list|,
name|WalkState
argument_list|,
operator|&
operator|(
name|Node
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
if|if
condition|(
name|Status
operator|==
name|AE_NOT_FOUND
condition|)
block|{
comment|/*              * We didn't find the name reference by path -- we can qualify this              * a little better before we print an error message              */
if|if
condition|(
name|strlen
argument_list|(
name|Path
argument_list|)
operator|==
name|ACPI_NAME_SIZE
condition|)
block|{
comment|/* A simple, one-segment ACPI name */
if|if
condition|(
name|XfObjectExists
argument_list|(
name|Path
argument_list|)
condition|)
block|{
comment|/*                      * There exists such a name, but we couldn't get to it                      * from this scope                      */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NOT_REACHABLE
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The name doesn't exist, period */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NOT_EXIST
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check for a fully qualified path */
if|if
condition|(
name|Path
index|[
literal|0
index|]
operator|==
name|AML_ROOT_PREFIX
condition|)
block|{
comment|/* Gave full path, the object does not exist */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NOT_EXIST
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                      * We can't tell whether it doesn't exist or just                      * can't be reached.                      */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NOT_FOUND
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
name|Status
operator|=
name|AE_OK
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Check for a reference vs. name declaration */
if|if
condition|(
operator|!
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_NAMED
operator|)
operator|&&
operator|!
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_CREATE
operator|)
condition|)
block|{
comment|/* This node has been referenced, mark it for reference check */
name|Node
operator|->
name|Flags
operator||=
name|ANOBJ_IS_REFERENCED
expr_stmt|;
ifdef|#
directive|ifdef
name|__UNDER_DEVELOPMENT
comment|/* Check for an illegal reference */
name|XfCheckIllegalReference
argument_list|(
name|Op
argument_list|,
name|Node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Attempt to optimize the NamePath */
name|OptOptimizeNamePath
argument_list|(
name|Op
argument_list|,
name|OpInfo
operator|->
name|Flags
argument_list|,
name|WalkState
argument_list|,
name|Path
argument_list|,
name|Node
argument_list|)
expr_stmt|;
comment|/*      * 1) Dereference an alias (A name reference that is an alias)      *    Aliases are not nested, the alias always points to the final object      */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_ALIAS
operator|)
operator|&&
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_ALIAS
operator|)
condition|)
block|{
comment|/* This node points back to the original PARSEOP_ALIAS */
name|NextOp
operator|=
name|Node
operator|->
name|Op
expr_stmt|;
comment|/* The first child is the alias target op */
name|NextOp
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
comment|/* That in turn points back to original target alias node */
if|if
condition|(
name|NextOp
operator|->
name|Asl
operator|.
name|Node
condition|)
block|{
name|Node
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
block|}
comment|/* Else - forward reference to alias, will be resolved later */
block|}
comment|/* 2) Check for a reference to a resource descriptor */
if|if
condition|(
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_RESOURCE_FIELD
operator|)
operator|||
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_RESOURCE
operator|)
condition|)
block|{
comment|/*          * This was a reference to a field within a resource descriptor.          * Extract the associated field offset (either a bit or byte          * offset depending on the field type) and change the named          * reference into an integer for AML code generation          */
name|Offset
operator|=
name|Node
operator|->
name|Value
expr_stmt|;
name|TagBitLength
operator|=
name|Node
operator|->
name|Length
expr_stmt|;
comment|/*          * If a field is being created, generate the length (in bits) of          * the field. Note: Opcodes other than CreateXxxField and Index          * can come through here. For other opcodes, we just need to          * convert the resource tag reference to an integer offset.          */
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|AmlOpcode
condition|)
block|{
case|case
name|AML_CREATE_FIELD_OP
case|:
comment|/* Variable "Length" field, in bits */
comment|/*              * We know the length operand is an integer constant because              * we know that it contains a reference to a resource              * descriptor tag.              */
name|FieldBitLength
operator|=
operator|(
name|UINT32
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
expr_stmt|;
break|break;
case|case
name|AML_CREATE_BIT_FIELD_OP
case|:
name|FieldBitLength
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AML_CREATE_BYTE_FIELD_OP
case|:
case|case
name|AML_INDEX_OP
case|:
name|FieldBitLength
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AML_CREATE_WORD_FIELD_OP
case|:
name|FieldBitLength
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AML_CREATE_DWORD_FIELD_OP
case|:
name|FieldBitLength
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AML_CREATE_QWORD_FIELD_OP
case|:
name|FieldBitLength
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|FieldBitLength
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Check the field length against the length of the resource tag */
if|if
condition|(
name|FieldBitLength
condition|)
block|{
if|if
condition|(
name|TagBitLength
operator|<
name|FieldBitLength
condition|)
block|{
name|Message
operator|=
name|ASL_MSG_TAG_SMALLER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TagBitLength
operator|>
name|FieldBitLength
condition|)
block|{
name|Message
operator|=
name|ASL_MSG_TAG_LARGER
expr_stmt|;
block|}
if|if
condition|(
name|Message
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"Size mismatch, Tag: %u bit%s, Field: %u bit%s"
argument_list|,
name|TagBitLength
argument_list|,
operator|(
name|TagBitLength
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|FieldBitLength
argument_list|,
operator|(
name|FieldBitLength
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|Message
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the BitOffset to a ByteOffset for certain opcodes */
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|AmlOpcode
condition|)
block|{
case|case
name|AML_CREATE_BYTE_FIELD_OP
case|:
case|case
name|AML_CREATE_WORD_FIELD_OP
case|:
case|case
name|AML_CREATE_DWORD_FIELD_OP
case|:
case|case
name|AML_CREATE_QWORD_FIELD_OP
case|:
case|case
name|AML_INDEX_OP
case|:
name|Offset
operator|=
name|ACPI_DIV_8
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now convert this node to an integer whose value is the field offset */
name|Op
operator|->
name|Asl
operator|.
name|AmlLength
operator|=
literal|0
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_INTEGER
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|=
operator|(
name|UINT64
operator|)
name|Offset
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_RESOURCE_FIELD
expr_stmt|;
name|OpcGenerateAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
block|}
comment|/* 3) Check for a method invocation */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESTRING
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESEG
operator|)
operator|)
operator|&&
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_METHOD
operator|)
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
condition|)
block|{
comment|/*          * A reference to a method within one of these opcodes is not an          * invocation of the method, it is simply a reference to the method.          */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|)
operator|&&
operator|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_REFOF
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_DEREFOF
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_PACKAGE
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_VAR_PACKAGE
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_OBJECTTYPE
operator|)
operator|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/*          * There are two types of method invocation:          * 1) Invocation with arguments -- the parser recognizes this          *    as a METHODCALL.          * 2) Invocation with no arguments --the parser cannot determine that          *    this is a method invocation, therefore we have to figure it out          *    here.          */
if|if
condition|(
name|Node
operator|->
name|Type
operator|!=
name|ACPI_TYPE_METHOD
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"%s is a %s"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Node
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NOT_METHOD
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Save the method node in the caller's op */
name|Op
operator|->
name|Asl
operator|.
name|Node
operator|=
name|Node
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_CONDREFOF
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/*          * This is a method invocation, with or without arguments.          * Count the number of arguments, each appears as a child          * under the parent node          */
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_METHODCALL
expr_stmt|;
name|UtSetParseOpName
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|PassedArgs
operator|=
literal|0
expr_stmt|;
name|NextOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
name|NextOp
condition|)
block|{
name|PassedArgs
operator|++
expr_stmt|;
name|NextOp
operator|=
name|NextOp
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|Node
operator|->
name|Value
operator|!=
name|ASL_EXTERNAL_METHOD
operator|&&
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_EXTERNAL
condition|)
block|{
comment|/*              * Check the parsed arguments with the number expected by the              * method declaration itself              */
if|if
condition|(
name|PassedArgs
operator|!=
name|Node
operator|->
name|Value
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"%s requires %u"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
name|Node
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|PassedArgs
operator|<
name|Node
operator|->
name|Value
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ARG_COUNT_LO
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ARG_COUNT_HI
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 4) Check for an ASL Field definition */
elseif|else
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|)
operator|&&
operator|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_FIELD
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_BANKFIELD
operator|)
operator|)
condition|)
block|{
comment|/*          * Offset checking for fields. If the parent operation region has a          * constant length (known at compile time), we can check fields          * defined in that region against the region length. This will catch          * fields and field units that cannot possibly fit within the region.          *          * Note: Index fields do not directly reference an operation region,          * thus they are not included in this check.          */
if|if
condition|(
name|Op
operator|==
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|Child
condition|)
block|{
comment|/*              * This is the first child of the field node, which is              * the name of the region. Get the parse node for the              * region -- which contains the length of the region.              */
name|OwningOp
operator|=
name|Node
operator|->
name|Op
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ExtraValue
operator|=
name|ACPI_MUL_8
argument_list|(
operator|(
name|UINT32
operator|)
name|OwningOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
argument_list|)
expr_stmt|;
comment|/* Examine the field access width */
switch|switch
condition|(
operator|(
name|UINT8
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
condition|)
block|{
case|case
name|AML_FIELD_ACCESS_ANY
case|:
case|case
name|AML_FIELD_ACCESS_BYTE
case|:
case|case
name|AML_FIELD_ACCESS_BUFFER
case|:
default|default:
name|MinimumLength
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ACCESS_WORD
case|:
name|MinimumLength
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ACCESS_DWORD
case|:
name|MinimumLength
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ACCESS_QWORD
case|:
name|MinimumLength
operator|=
literal|8
expr_stmt|;
break|break;
block|}
comment|/*              * Is the region at least as big as the access width?              * Note: DataTableRegions have 0 length              */
if|if
condition|(
operator|(
operator|(
name|UINT32
operator|)
name|OwningOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|)
operator|&&
operator|(
operator|(
name|UINT32
operator|)
name|OwningOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|<
name|MinimumLength
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_FIELD_ACCESS_WIDTH
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*              * Check EC/CMOS/SMBUS fields to make sure that the correct              * access type is used (BYTE for EC/CMOS, BUFFER for SMBUS)              */
name|SpaceIdOp
operator|=
name|OwningOp
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
switch|switch
condition|(
operator|(
name|UINT32
operator|)
name|SpaceIdOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
condition|)
block|{
case|case
name|ACPI_ADR_SPACE_EC
case|:
case|case
name|ACPI_ADR_SPACE_CMOS
case|:
case|case
name|ACPI_ADR_SPACE_GPIO
case|:
if|if
condition|(
operator|(
name|UINT8
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|!=
name|AML_FIELD_ACCESS_BYTE
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_REGION_BYTE_ACCESS
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_ADR_SPACE_SMBUS
case|:
case|case
name|ACPI_ADR_SPACE_IPMI
case|:
case|case
name|ACPI_ADR_SPACE_GSBUS
case|:
if|if
condition|(
operator|(
name|UINT8
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|!=
name|AML_FIELD_ACCESS_BUFFER
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_REGION_BUFFER_ACCESS
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Nothing to do for other address spaces */
break|break;
block|}
block|}
else|else
block|{
comment|/*              * This is one element of the field list. Check to make sure              * that it does not go beyond the end of the parent operation region.              *              * In the code below:              *    Op->Asl.Parent->Asl.ExtraValue      - Region Length (bits)              *    Op->Asl.ExtraValue                  - Field start offset (bits)              *    Op->Asl.Child->Asl.Value.Integer32  - Field length (bits)              *    Op->Asl.Child->Asl.ExtraValue       - Field access width (bits)              */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ExtraValue
operator|&&
name|Op
operator|->
name|Asl
operator|.
name|Child
condition|)
block|{
name|XfCheckFieldRange
argument_list|(
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ExtraValue
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExtraValue
argument_list|,
operator|(
name|UINT32
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|ExtraValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 5) Check for a connection object */
if|#
directive|if
literal|0
block|else if (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONNECTION)     {         return_ACPI_STATUS (Status);     }
endif|#
directive|endif
name|Op
operator|->
name|Asl
operator|.
name|Node
operator|=
name|Node
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfNamespaceLocateEnd  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Ascending callback used during cross reference. We only  *              need to worry about scope management here.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|XfNamespaceLocateEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|ACPI_WALK_STATE
modifier|*
name|WalkState
init|=
operator|(
name|ACPI_WALK_STATE
operator|*
operator|)
name|Context
decl_stmt|;
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|XfNamespaceLocateEnd
argument_list|)
expr_stmt|;
comment|/* We are only interested in opcodes that have an associated name */
name|OpInfo
operator|=
name|AcpiPsGetOpcodeInfo
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_NAMED
operator|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Not interested in name references, we did not open a scope for them */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESTRING
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESEG
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the scope stack if necessary */
if|if
condition|(
name|AcpiNsOpensScope
argument_list|(
name|AslMapNamedOpcodeToDataType
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
argument_list|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_DISPATCH
operator|,
literal|"%s: Popping scope for Op %p\n"
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|OpInfo
operator|->
name|ObjectType
argument_list|)
operator|,
name|Op
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiDsScopeStackPop
argument_list|(
name|WalkState
argument_list|)
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__UNDER_DEVELOPMENT
end_ifdef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfIsObjectParental  *  * PARAMETERS:  ChildOp                 - Op to be checked  *              PossibleParentOp        - Determine if this op is in the family  *  * RETURN:      TRUE if ChildOp is a descendent of PossibleParentOp  *  * DESCRIPTION: Determine if an Op is a descendent of another Op. Used to  *              detect if a method is declared within another method.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|XfIsObjectParental
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|ChildOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|PossibleParentOp
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|ParentOp
decl_stmt|;
comment|/* Search upwards through the tree for possible parent */
name|ParentOp
operator|=
name|ChildOp
expr_stmt|;
while|while
condition|(
name|ParentOp
condition|)
block|{
if|if
condition|(
name|ParentOp
operator|==
name|PossibleParentOp
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|ParentOp
operator|=
name|ParentOp
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfGetParentMethod  *  * PARAMETERS:  Op                      - Op to be checked  *  * RETURN:      Op for parent method. NULL if object is not within a method.  *  * DESCRIPTION: Determine if an object is within a control method. Used to  *              implement special rules for named references from within a  *              control method.  *  * NOTE: It would be better to have the parser set a flag in the Op if possible.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_PARSE_OBJECT
modifier|*
name|XfGetParentMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|ParentOp
decl_stmt|;
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHOD
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Walk upwards through the parse tree, up to the root if necessary */
name|ParentOp
operator|=
name|Op
expr_stmt|;
while|while
condition|(
name|ParentOp
condition|)
block|{
if|if
condition|(
name|ParentOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHOD
condition|)
block|{
return|return
operator|(
name|ParentOp
operator|)
return|;
block|}
name|ParentOp
operator|=
name|ParentOp
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
comment|/* Object is not within a method */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    XfCheckIllegalReference  *  * PARAMETERS:  Op                      - Op referring to the target  *              TargetNode              - Target of the reference  *  * RETURN:      None. Emits error message for an illegal reference  *  * DESCRIPTION: Determine if a named reference is legal. A "named" reference  *              is something like: Store(ABCD, ...), where ABCD is an AML  *              Nameseg or Namepath.  *  * NOTE: Caller must ensure that the name Op is in fact a reference, and not  *       an actual name declaration (creation of a named object).  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|XfCheckIllegalReference
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
name|TargetNode
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|MethodOp1
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|MethodOp2
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|TargetOp
decl_stmt|;
comment|/*      * Check for an illegal reference to a named object:      *      * 1) References from one control method to another, non-parent      *    method are not allowed, they will fail at runtime.      *      * 2) Forward references within a control method are not allowed.      *    AML interpreters use a one-pass parse of control methods      *    so these forward references will fail at runtime.      */
name|TargetOp
operator|=
name|TargetNode
operator|->
name|Op
expr_stmt|;
name|MethodOp1
operator|=
name|XfGetParentMethod
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|MethodOp2
operator|=
name|XfGetParentMethod
argument_list|(
name|TargetOp
argument_list|)
expr_stmt|;
comment|/* Are both objects within control method(s)? */
if|if
condition|(
operator|!
name|MethodOp1
operator|||
operator|!
name|MethodOp2
condition|)
block|{
return|return;
block|}
comment|/* Objects not in the same method? */
if|if
condition|(
name|MethodOp1
operator|!=
name|MethodOp2
condition|)
block|{
comment|/*          * 1) Cross-method named reference          *          * This is OK if and only if the target reference is within in a          * method that is a parent of current method          */
if|if
condition|(
operator|!
name|XfIsObjectParental
argument_list|(
name|MethodOp1
argument_list|,
name|MethodOp2
argument_list|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ILLEGAL_METHOD_REF
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * 2) Both reference and target are in the same method. Check if this is      * an (illegal) forward reference by examining the exact source code      * location of each (the referenced object and the object declaration).      * This is a bit nasty, yet effective.      */
elseif|else
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|LogicalByteOffset
operator|<
name|TargetOp
operator|->
name|Asl
operator|.
name|LogicalByteOffset
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ILLEGAL_FORWARD_REF
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

