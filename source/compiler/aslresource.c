begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: aslresource - Resource template/descriptor utilities  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  * 1. Copyright Notice  *  * Some or all of this work - Copyright (c) 1999 - 2017, Intel Corp.  * All rights reserved.  *  * 2. License  *  * 2.1. This is your license from Intel Corp. under its intellectual property  * rights. You may have additional license terms from the party that provided  * you this software, covering your right to use that party's intellectual  * property rights.  *  * 2.2. Intel grants, free of charge, to any person ("Licensee") obtaining a  * copy of the source code appearing in this file ("Covered Code") an  * irrevocable, perpetual, worldwide license under Intel's copyrights in the  * base code distributed originally by Intel ("Original Intel Code") to copy,  * make derivatives, distribute, use and display any portion of the Covered  * Code in any form, with the right to sublicense such rights; and  *  * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent  * license (with the right to sublicense), under only those claims of Intel  * patents that are infringed by the Original Intel Code, to make, use, sell,  * offer to sell, and import the Covered Code and derivative works thereof  * solely to the minimum extent necessary to exercise the above copyright  * license, and in no event shall the patent license extend to any additions  * to or modifications of the Original Intel Code. No other license or right  * is granted directly or by implication, estoppel or otherwise;  *  * The above copyright and patent license is granted only if the following  * conditions are met:  *  * 3. Conditions  *  * 3.1. Redistribution of Source with Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification with rights to further distribute source must include  * the above Copyright Notice, the above License, this list of Conditions,  * and the following Disclaimer and Export Compliance provision. In addition,  * Licensee must cause all Covered Code to which Licensee contributes to  * contain a file documenting the changes Licensee made to create that Covered  * Code and the date of any change. Licensee must include in that file the  * documentation of any changes made by any predecessor Licensee. Licensee  * must include a prominent statement that the modification is derived,  * directly or indirectly, from Original Intel Code.  *  * 3.2. Redistribution of Source with no Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification without rights to further distribute source must  * include the following Disclaimer and Export Compliance provision in the  * documentation and/or other materials provided with distribution. In  * addition, Licensee may not authorize further sublicense of source of any  * portion of the Covered Code, and must include terms to the effect that the  * license from Licensee to its licensee is limited to the intellectual  * property embodied in the software Licensee provides to its licensee, and  * not to intellectual property embodied in modifications its licensee may  * make.  *  * 3.3. Redistribution of Executable. Redistribution in executable form of any  * substantial portion of the Covered Code or modification must reproduce the  * above Copyright Notice, and the following Disclaimer and Export Compliance  * provision in the documentation and/or other materials provided with the  * distribution.  *  * 3.4. Intel retains all right, title, and interest in and to the Original  * Intel Code.  *  * 3.5. Neither the name Intel nor any other trademark owned or controlled by  * Intel shall be used in advertising or otherwise to promote the sale, use or  * other dealings in products derived from or relating to the Covered Code  * without prior written authorization from Intel.  *  * 4. Disclaimer and Export Compliance  *  * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED  * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE  * IS PROVIDED "AS IS," AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,  * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY  * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY  * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A  * PARTICULAR PURPOSE.  *  * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES  * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR  * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,  * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY  * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL  * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS  * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY  * LIMITED REMEDY.  *  * 4.3. Licensee shall not export, either directly or indirectly, any of this  * software or system incorporating such software without first obtaining any  * required license or other approval from the U. S. Department of Commerce or  * any other agency or department of the United States Government. In the  * event Licensee exports any such software from the United States or  * re-exports any such software from a foreign destination, Licensee shall  * ensure that the distribution and export/re-export of the software is in  * compliance with all laws, regulations, orders, or other restrictions of the  * U.S. Export Administration Regulations. Licensee agrees that neither it nor  * any of its subsidiaries will export/re-export any technical data, process,  * software, or service, directly or indirectly, to any country for which the  * United States government or any agency thereof requires an export license,  * other governmental approval, or letter of assurance, without first obtaining  * such license, approval or letter.  *  *****************************************************************************  *  * Alternatively, you may choose to be licensed under the terms of the  * following license:  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Alternatively, you may choose to be licensed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"aslcompiler.h"
end_include

begin_include
include|#
directive|include
file|"aslcompiler.y.h"
end_include

begin_include
include|#
directive|include
file|"amlcode.h"
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_COMPILER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"aslresource"
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsSmallAddressCheck  *  * PARAMETERS:  Minimum             - Address Min value  *              Maximum             - Address Max value  *              Length              - Address range value  *              Alignment           - Address alignment value  *              MinOp               - Original Op for Address Min  *              MaxOp               - Original Op for Address Max  *              LengthOp            - Original Op for address range  *              AlignOp             - Original Op for address alignment. If  *                                    NULL, means "zero value for alignment is  *                                    OK, and means 64K alignment" (for  *                                    Memory24 descriptor)  *              Op                  - Parent Op for entire construct  *  * RETURN:      None. Adds error messages to error log if necessary  *  * DESCRIPTION: Perform common value checks for "small" address descriptors.  *              Currently:  *                  Io, Memory24, Memory32  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsSmallAddressCheck
parameter_list|(
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Minimum
parameter_list|,
name|UINT32
name|Maximum
parameter_list|,
name|UINT32
name|Length
parameter_list|,
name|UINT32
name|Alignment
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|MinOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|MaxOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|LengthOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|AlignOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
name|Gbl_NoResourceChecking
condition|)
block|{
return|return;
block|}
comment|/*      * Check for a so-called "null descriptor". These are descriptors that are      * created with most fields set to zero. The intent is that the descriptor      * will be updated/completed at runtime via a BufferField.      *      * If the descriptor does NOT have a resource tag, it cannot be referenced      * by a BufferField and we will flag this as an error. Conversely, if      * the descriptor has a resource tag, we will assume that a BufferField      * will be used to dynamically update it, so no error.      *      * A possible enhancement to this check would be to verify that in fact      * a BufferField is created using the resource tag, and perhaps even      * verify that a Store is performed to the BufferField.      *      * Note: for these descriptors, Alignment is allowed to be zero      */
if|if
condition|(
operator|!
name|Minimum
operator|&&
operator|!
name|Maximum
operator|&&
operator|!
name|Length
condition|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
condition|)
block|{
comment|/* No resource tag. Descriptor is fixed and is also illegal */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NULL_DESCRIPTOR
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*      * Range checks for Memory24 and Memory32.      * IO descriptor has different definition of min/max, don't check.      */
if|if
condition|(
name|Type
operator|!=
name|ACPI_RESOURCE_NAME_IO
condition|)
block|{
comment|/* Basic checks on Min/Max/Length */
if|if
condition|(
name|Minimum
operator|>
name|Maximum
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_MIN_MAX
argument_list|,
name|MinOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Length
operator|>
operator|(
name|Maximum
operator|-
name|Minimum
operator|+
literal|1
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_LENGTH
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Special case for Memory24, min/max values are compressed */
if|if
condition|(
name|Type
operator|==
name|ACPI_RESOURCE_NAME_MEMORY24
condition|)
block|{
if|if
condition|(
operator|!
name|Alignment
condition|)
comment|/* Alignment==0 means 64K alignment */
block|{
name|Alignment
operator|=
name|ACPI_UINT16_MAX
operator|+
literal|1
expr_stmt|;
block|}
name|Minimum
operator|<<=
literal|8
expr_stmt|;
name|Maximum
operator|<<=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Alignment of zero is not in ACPI spec, but is used to mean byte acc */
if|if
condition|(
operator|!
name|Alignment
condition|)
block|{
name|Alignment
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Addresses must be an exact multiple of the alignment value */
if|if
condition|(
name|Minimum
operator|%
name|Alignment
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALIGNMENT
argument_list|,
name|MinOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Maximum
operator|%
name|Alignment
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALIGNMENT
argument_list|,
name|MaxOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsLargeAddressCheck  *  * PARAMETERS:  Minimum             - Address Min value  *              Maximum             - Address Max value  *              Length              - Address range value  *              Granularity         - Address granularity value  *              Flags               - General flags for address descriptors:  *                                    _MIF, _MAF, _DEC  *              MinOp               - Original Op for Address Min  *              MaxOp               - Original Op for Address Max  *              LengthOp            - Original Op for address range  *              GranOp              - Original Op for address granularity  *              Op                  - Parent Op for entire construct  *  * RETURN:      None. Adds error messages to error log if necessary  *  * DESCRIPTION: Perform common value checks for "large" address descriptors.  *              Currently:  *                  WordIo,     WordBusNumber,  WordSpace  *                  DWordIo,    DWordMemory,    DWordSpace  *                  QWordIo,    QWordMemory,    QWordSpace  *                  ExtendedIo, ExtendedMemory, ExtendedSpace  *  * _MIF flag set means that the minimum address is fixed and is not relocatable  * _MAF flag set means that the maximum address is fixed and is not relocatable  * Length of zero means that the record size is variable  *  * This function implements the LEN/MIF/MAF/MIN/MAX/GRA rules within Table 6-40  * of the ACPI 4.0a specification. Added 04/2010.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsLargeAddressCheck
parameter_list|(
name|UINT64
name|Minimum
parameter_list|,
name|UINT64
name|Maximum
parameter_list|,
name|UINT64
name|Length
parameter_list|,
name|UINT64
name|Granularity
parameter_list|,
name|UINT8
name|Flags
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|MinOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|MaxOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|LengthOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|GranOp
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
name|Gbl_NoResourceChecking
condition|)
block|{
return|return;
block|}
comment|/*      * Check for a so-called "null descriptor". These are descriptors that are      * created with most fields set to zero. The intent is that the descriptor      * will be updated/completed at runtime via a BufferField.      *      * If the descriptor does NOT have a resource tag, it cannot be referenced      * by a BufferField and we will flag this as an error. Conversely, if      * the descriptor has a resource tag, we will assume that a BufferField      * will be used to dynamically update it, so no error.      *      * A possible enhancement to this check would be to verify that in fact      * a BufferField is created using the resource tag, and perhaps even      * verify that a Store is performed to the BufferField.      */
if|if
condition|(
operator|!
name|Minimum
operator|&&
operator|!
name|Maximum
operator|&&
operator|!
name|Length
operator|&&
operator|!
name|Granularity
condition|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
condition|)
block|{
comment|/* No resource tag. Descriptor is fixed and is also illegal */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NULL_DESCRIPTOR
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Basic checks on Min/Max/Length */
if|if
condition|(
name|Minimum
operator|>
name|Maximum
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_MIN_MAX
argument_list|,
name|MinOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Length
operator|>
operator|(
name|Maximum
operator|-
name|Minimum
operator|+
literal|1
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_LENGTH
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If specified (non-zero), ensure granularity is a power-of-two minus one */
if|if
condition|(
name|Granularity
condition|)
block|{
if|if
condition|(
operator|(
name|Granularity
operator|+
literal|1
operator|)
operator|&
name|Granularity
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_GRANULARITY
argument_list|,
name|GranOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * Check the various combinations of Length, MinFixed, and MaxFixed      */
if|if
condition|(
name|Length
condition|)
block|{
comment|/* Fixed non-zero length */
switch|switch
condition|(
name|Flags
operator|&
operator|(
name|ACPI_RESOURCE_FLAG_MIF
operator||
name|ACPI_RESOURCE_FLAG_MAF
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/*              * Fixed length, variable locations (both _MIN and _MAX).              * Length must be a multiple of granularity              */
if|if
condition|(
name|Granularity
operator|&
name|Length
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALIGNMENT
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|ACPI_RESOURCE_FLAG_MIF
operator||
name|ACPI_RESOURCE_FLAG_MAF
operator|)
case|:
comment|/* Fixed length, fixed location. Granularity must be zero */
if|if
condition|(
name|Granularity
operator|!=
literal|0
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_GRAN_FIXED
argument_list|,
name|GranOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Length must be exactly the size of the min/max window */
if|if
condition|(
name|Length
operator|!=
operator|(
name|Maximum
operator|-
name|Minimum
operator|+
literal|1
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_LENGTH_FIXED
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* All other combinations are invalid */
case|case
name|ACPI_RESOURCE_FLAG_MIF
case|:
case|case
name|ACPI_RESOURCE_FLAG_MAF
case|:
default|default:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_ADDR_FLAGS
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Variable length (length==0) */
switch|switch
condition|(
name|Flags
operator|&
operator|(
name|ACPI_RESOURCE_FLAG_MIF
operator||
name|ACPI_RESOURCE_FLAG_MAF
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/*              * Both _MIN and _MAX are variable.              * No additional requirements, just exit              */
break|break;
case|case
name|ACPI_RESOURCE_FLAG_MIF
case|:
comment|/* _MIN is fixed. _MIN must be multiple of _GRA */
comment|/*              * The granularity is defined by the ACPI specification to be a              * power-of-two minus one, therefore the granularity is a              * bitmask which can be used to easily validate the addresses.              */
if|if
condition|(
name|Granularity
operator|&
name|Minimum
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALIGNMENT
argument_list|,
name|MinOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_RESOURCE_FLAG_MAF
case|:
comment|/* _MAX is fixed. (_MAX + 1) must be multiple of _GRA */
if|if
condition|(
name|Granularity
operator|&
operator|(
name|Maximum
operator|+
literal|1
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALIGNMENT
argument_list|,
name|MaxOp
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Both MIF/MAF set is invalid if length is zero */
case|case
operator|(
name|ACPI_RESOURCE_FLAG_MIF
operator||
name|ACPI_RESOURCE_FLAG_MAF
operator|)
case|:
default|default:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_ADDR_FLAGS
argument_list|,
name|LengthOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsGetStringDataLength  *  * PARAMETERS:  InitializerOp     - Start of a subtree of init nodes  *  * RETURN:      Valid string length if a string node is found (otherwise 0)  *  * DESCRIPTION: In a list of peer nodes, find the first one that contains a  *              string and return the length of the string.  *  ******************************************************************************/
end_comment

begin_function
name|UINT16
name|RsGetStringDataLength
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|InitializerOp
parameter_list|)
block|{
while|while
condition|(
name|InitializerOp
condition|)
block|{
if|if
condition|(
name|InitializerOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_STRING_LITERAL
condition|)
block|{
return|return
operator|(
call|(
name|UINT16
call|)
argument_list|(
name|strlen
argument_list|(
name|InitializerOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
name|InitializerOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|InitializerOp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsAllocateResourceNode  *  * PARAMETERS:  Size        - Size of node in bytes  *  * RETURN:      The allocated node - aborts on allocation failure  *  * DESCRIPTION: Allocate a resource description node and the resource  *              descriptor itself (the nodes are used to link descriptors).  *  ******************************************************************************/
end_comment

begin_function
name|ASL_RESOURCE_NODE
modifier|*
name|RsAllocateResourceNode
parameter_list|(
name|UINT32
name|Size
parameter_list|)
block|{
name|ASL_RESOURCE_NODE
modifier|*
name|Rnode
decl_stmt|;
comment|/* Allocate the node */
name|Rnode
operator|=
name|UtLocalCalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASL_RESOURCE_NODE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the resource descriptor itself */
name|Rnode
operator|->
name|Buffer
operator|=
name|UtLocalCalloc
argument_list|(
name|Size
argument_list|)
expr_stmt|;
name|Rnode
operator|->
name|BufferLength
operator|=
name|Size
expr_stmt|;
return|return
operator|(
name|Rnode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsCreateResourceField  *  * PARAMETERS:  Op              - Resource field node  *              Name            - Name of the field (Used only to reference  *                                the field in the ASL, not in the AML)  *              ByteOffset      - Offset from the field start  *              BitOffset       - Additional bit offset  *              BitLength       - Number of bits in the field  *  * RETURN:      None, sets fields within the input node  *  * DESCRIPTION: Utility function to generate a named bit field within a  *              resource descriptor. Mark a node as 1) a field in a resource  *              descriptor, and 2) set the value to be a BIT offset  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsCreateResourceField
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Name
parameter_list|,
name|UINT32
name|ByteOffset
parameter_list|,
name|UINT32
name|BitOffset
parameter_list|,
name|UINT32
name|BitLength
parameter_list|)
block|{
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
operator|=
name|Name
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_RESOURCE_FIELD
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Tag
operator|.
name|BitOffset
operator|=
operator|(
name|ByteOffset
operator|*
literal|8
operator|)
operator|+
name|BitOffset
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Tag
operator|.
name|BitLength
operator|=
name|BitLength
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsSetFlagBits  *  * PARAMETERS:  *Flags          - Pointer to the flag byte  *              Op              - Flag initialization node  *              Position        - Bit position within the flag byte  *              Default         - Used if the node is DEFAULT.  *  * RETURN:      Sets bits within the *Flags output byte.  *  * DESCRIPTION: Set a bit in a cumulative flags word from an initialization  *              node. Will use a default value if the node is DEFAULT, meaning  *              that no value was specified in the ASL. Used to merge multiple  *              keywords into a single flags byte.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsSetFlagBits
parameter_list|(
name|UINT8
modifier|*
name|Flags
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT8
name|Position
parameter_list|,
name|UINT8
name|DefaultBit
parameter_list|)
block|{
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_DEFAULT_ARG
condition|)
block|{
comment|/* Use the default bit */
operator|*
name|Flags
operator||=
operator|(
name|DefaultBit
operator|<<
name|Position
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the bit specified in the initialization node */
operator|*
name|Flags
operator||=
operator|(
operator|(
operator|(
name|UINT8
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|)
operator|<<
name|Position
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|RsSetFlagBits16
parameter_list|(
name|UINT16
modifier|*
name|Flags
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT8
name|Position
parameter_list|,
name|UINT8
name|DefaultBit
parameter_list|)
block|{
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_DEFAULT_ARG
condition|)
block|{
comment|/* Use the default bit */
operator|*
name|Flags
operator||=
operator|(
name|DefaultBit
operator|<<
name|Position
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the bit specified in the initialization node */
operator|*
name|Flags
operator||=
operator|(
operator|(
operator|(
name|UINT16
operator|)
name|Op
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|)
operator|<<
name|Position
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsCompleteNodeAndGetNext  *  * PARAMETERS:  Op            - Resource node to be completed  *  * RETURN:      The next peer to the input node.  *  * DESCRIPTION: Mark the current node completed and return the next peer.  *              The node ParseOpcode is set to DEFAULT_ARG, meaning that  *              this node is to be ignored from now on.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_PARSE_OBJECT
modifier|*
name|RsCompleteNodeAndGetNext
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
comment|/* Mark this node unused */
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_DEFAULT_ARG
expr_stmt|;
comment|/* Move on to the next peer node in the initializer list */
return|return
operator|(
name|ASL_GET_PEER_NODE
argument_list|(
name|Op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsCheckListForDuplicates  *  * PARAMETERS:  Op                  - First op in the initializer list  *  * RETURN:      None  *  * DESCRIPTION: Check an initializer list for duplicate values. Emits an error  *              if any duplicates are found.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsCheckListForDuplicates
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|NextValueOp
init|=
name|Op
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|NextOp
decl_stmt|;
name|UINT32
name|Value
decl_stmt|;
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return;
block|}
comment|/* Search list once for each value in the list */
while|while
condition|(
name|NextValueOp
condition|)
block|{
name|Value
operator|=
operator|(
name|UINT32
operator|)
name|NextValueOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
expr_stmt|;
comment|/* Compare this value to all remaining values in the list */
name|NextOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|NextValueOp
argument_list|)
expr_stmt|;
while|while
condition|(
name|NextOp
condition|)
block|{
if|if
condition|(
name|NextOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_DEFAULT_ARG
condition|)
block|{
comment|/* Compare values */
if|if
condition|(
name|Value
operator|==
operator|(
name|UINT32
operator|)
name|NextOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
condition|)
block|{
comment|/* Emit error only once per duplicate node */
if|if
condition|(
operator|!
operator|(
name|NextOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_DUPLICATE
operator|)
condition|)
block|{
name|NextOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_DUPLICATE
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_DUPLICATE_ITEM
argument_list|,
name|NextOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NextOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|NextOp
argument_list|)
expr_stmt|;
block|}
name|NextValueOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|NextValueOp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsDoOneResourceDescriptor  *  * PARAMETERS:  DescriptorTypeOp    - Parent parse node of the descriptor  *              CurrentByteOffset   - Offset in the resource descriptor  *                                    buffer.  *  * RETURN:      A valid resource node for the descriptor  *  * DESCRIPTION: Dispatches the processing of one resource descriptor  *  ******************************************************************************/
end_comment

begin_function
name|ASL_RESOURCE_NODE
modifier|*
name|RsDoOneResourceDescriptor
parameter_list|(
name|ASL_RESOURCE_INFO
modifier|*
name|Info
parameter_list|,
name|UINT8
modifier|*
name|State
parameter_list|)
block|{
name|ASL_RESOURCE_NODE
modifier|*
name|Rnode
init|=
name|NULL
decl_stmt|;
comment|/* Construct the resource */
switch|switch
condition|(
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_DMA
case|:
name|Rnode
operator|=
name|RsDoDmaDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_FIXEDDMA
case|:
name|Rnode
operator|=
name|RsDoFixedDmaDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_DWORDIO
case|:
name|Rnode
operator|=
name|RsDoDwordIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_DWORDMEMORY
case|:
name|Rnode
operator|=
name|RsDoDwordMemoryDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_DWORDSPACE
case|:
name|Rnode
operator|=
name|RsDoDwordSpaceDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_ENDDEPENDENTFN
case|:
switch|switch
condition|(
operator|*
name|State
condition|)
block|{
case|case
name|ACPI_RSTATE_NORMAL
case|:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_MISSING_STARTDEPENDENT
argument_list|,
name|Info
operator|->
name|DescriptorTypeOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_RSTATE_START_DEPENDENT
case|:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_DEPENDENT_NESTING
argument_list|,
name|Info
operator|->
name|DescriptorTypeOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_RSTATE_DEPENDENT_LIST
case|:
default|default:
break|break;
block|}
operator|*
name|State
operator|=
name|ACPI_RSTATE_NORMAL
expr_stmt|;
name|Rnode
operator|=
name|RsDoEndDependentDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_ENDTAG
case|:
name|Rnode
operator|=
name|RsDoEndTagDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_EXTENDEDIO
case|:
name|Rnode
operator|=
name|RsDoExtendedIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_EXTENDEDMEMORY
case|:
name|Rnode
operator|=
name|RsDoExtendedMemoryDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_EXTENDEDSPACE
case|:
name|Rnode
operator|=
name|RsDoExtendedSpaceDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_FIXEDIO
case|:
name|Rnode
operator|=
name|RsDoFixedIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_INTERRUPT
case|:
name|Rnode
operator|=
name|RsDoInterruptDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_IO
case|:
name|Rnode
operator|=
name|RsDoIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_IRQ
case|:
name|Rnode
operator|=
name|RsDoIrqDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_IRQNOFLAGS
case|:
name|Rnode
operator|=
name|RsDoIrqNoFlagsDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_MEMORY24
case|:
name|Rnode
operator|=
name|RsDoMemory24Descriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_MEMORY32
case|:
name|Rnode
operator|=
name|RsDoMemory32Descriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_MEMORY32FIXED
case|:
name|Rnode
operator|=
name|RsDoMemory32FixedDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_QWORDIO
case|:
name|Rnode
operator|=
name|RsDoQwordIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_QWORDMEMORY
case|:
name|Rnode
operator|=
name|RsDoQwordMemoryDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_QWORDSPACE
case|:
name|Rnode
operator|=
name|RsDoQwordSpaceDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_REGISTER
case|:
name|Rnode
operator|=
name|RsDoGeneralRegisterDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_STARTDEPENDENTFN
case|:
switch|switch
condition|(
operator|*
name|State
condition|)
block|{
case|case
name|ACPI_RSTATE_START_DEPENDENT
case|:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_DEPENDENT_NESTING
argument_list|,
name|Info
operator|->
name|DescriptorTypeOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_RSTATE_NORMAL
case|:
case|case
name|ACPI_RSTATE_DEPENDENT_LIST
case|:
default|default:
break|break;
block|}
operator|*
name|State
operator|=
name|ACPI_RSTATE_START_DEPENDENT
expr_stmt|;
name|Rnode
operator|=
name|RsDoStartDependentDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
operator|*
name|State
operator|=
name|ACPI_RSTATE_DEPENDENT_LIST
expr_stmt|;
break|break;
case|case
name|PARSEOP_STARTDEPENDENTFN_NOPRI
case|:
switch|switch
condition|(
operator|*
name|State
condition|)
block|{
case|case
name|ACPI_RSTATE_START_DEPENDENT
case|:
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_DEPENDENT_NESTING
argument_list|,
name|Info
operator|->
name|DescriptorTypeOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_RSTATE_NORMAL
case|:
case|case
name|ACPI_RSTATE_DEPENDENT_LIST
case|:
default|default:
break|break;
block|}
operator|*
name|State
operator|=
name|ACPI_RSTATE_START_DEPENDENT
expr_stmt|;
name|Rnode
operator|=
name|RsDoStartDependentNoPriDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
operator|*
name|State
operator|=
name|ACPI_RSTATE_DEPENDENT_LIST
expr_stmt|;
break|break;
case|case
name|PARSEOP_VENDORLONG
case|:
name|Rnode
operator|=
name|RsDoVendorLargeDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_VENDORSHORT
case|:
name|Rnode
operator|=
name|RsDoVendorSmallDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_WORDBUSNUMBER
case|:
name|Rnode
operator|=
name|RsDoWordBusNumberDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_WORDIO
case|:
name|Rnode
operator|=
name|RsDoWordIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_WORDSPACE
case|:
name|Rnode
operator|=
name|RsDoWordSpaceDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_GPIO_INT
case|:
name|Rnode
operator|=
name|RsDoGpioIntDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_GPIO_IO
case|:
name|Rnode
operator|=
name|RsDoGpioIoDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_I2C_SERIALBUS
case|:
case|case
name|PARSEOP_I2C_SERIALBUS_V2
case|:
name|Rnode
operator|=
name|RsDoI2cSerialBusDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_SPI_SERIALBUS
case|:
case|case
name|PARSEOP_SPI_SERIALBUS_V2
case|:
name|Rnode
operator|=
name|RsDoSpiSerialBusDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_UART_SERIALBUS
case|:
case|case
name|PARSEOP_UART_SERIALBUS_V2
case|:
name|Rnode
operator|=
name|RsDoUartSerialBusDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_PINCONFIG
case|:
name|Rnode
operator|=
name|RsDoPinConfigDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_PINFUNCTION
case|:
name|Rnode
operator|=
name|RsDoPinFunctionDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_PINGROUP
case|:
name|Rnode
operator|=
name|RsDoPinGroupDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_PINGROUPFUNCTION
case|:
name|Rnode
operator|=
name|RsDoPinGroupFunctionDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_PINGROUPCONFIG
case|:
name|Rnode
operator|=
name|RsDoPinGroupConfigDescriptor
argument_list|(
name|Info
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_DEFAULT_ARG
case|:
comment|/* Just ignore any of these, they are used as fillers/placeholders */
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown resource descriptor type [%s]\n"
argument_list|,
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|ParseOpName
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Mark original node as unused, but head of a resource descriptor.      * This allows the resource to be installed in the namespace so that      * references to the descriptor can be resolved.      */
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_DEFAULT_ARG
expr_stmt|;
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator|=
name|NODE_IS_RESOURCE_DESC
expr_stmt|;
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|=
name|Info
operator|->
name|CurrentByteOffset
expr_stmt|;
if|if
condition|(
name|Rnode
condition|)
block|{
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|FinalAmlLength
operator|=
name|Rnode
operator|->
name|BufferLength
expr_stmt|;
name|Info
operator|->
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|Extra
operator|=
operator|(
operator|(
name|AML_RESOURCE
operator|*
operator|)
name|Rnode
operator|->
name|Buffer
operator|)
operator|->
name|DescriptorType
expr_stmt|;
block|}
return|return
operator|(
name|Rnode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsLinkDescriptorChain  *  * PARAMETERS:  PreviousRnode       - Pointer to the node that will be previous  *                                    to the linked node,  At exit, set to the  *                                    last node in the new chain.  *              Rnode               - Resource node to link into the list  *  * RETURN:      Cumulative buffer byte offset of the new segment of chain  *  * DESCRIPTION: Link a descriptor chain at the end of an existing chain.  *  ******************************************************************************/
end_comment

begin_function
name|UINT32
name|RsLinkDescriptorChain
parameter_list|(
name|ASL_RESOURCE_NODE
modifier|*
modifier|*
name|PreviousRnode
parameter_list|,
name|ASL_RESOURCE_NODE
modifier|*
name|Rnode
parameter_list|)
block|{
name|ASL_RESOURCE_NODE
modifier|*
name|LastRnode
decl_stmt|;
name|UINT32
name|CurrentByteOffset
decl_stmt|;
comment|/* Anything to do? */
if|if
condition|(
operator|!
name|Rnode
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Point the previous node to the new node */
operator|(
operator|*
name|PreviousRnode
operator|)
operator|->
name|Next
operator|=
name|Rnode
expr_stmt|;
name|CurrentByteOffset
operator|=
name|Rnode
operator|->
name|BufferLength
expr_stmt|;
comment|/* Walk to the end of the chain headed by Rnode */
name|LastRnode
operator|=
name|Rnode
expr_stmt|;
while|while
condition|(
name|LastRnode
operator|->
name|Next
condition|)
block|{
name|LastRnode
operator|=
name|LastRnode
operator|->
name|Next
expr_stmt|;
name|CurrentByteOffset
operator|+=
name|LastRnode
operator|->
name|BufferLength
expr_stmt|;
block|}
comment|/* Previous node becomes the last node in the chain */
operator|*
name|PreviousRnode
operator|=
name|LastRnode
expr_stmt|;
return|return
operator|(
name|CurrentByteOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    RsDoResourceTemplate  *  * PARAMETERS:  Op        - Parent of a resource template list  *  * RETURN:      None. Sets input node to point to a list of AML code  *  * DESCRIPTION: Merge a list of resource descriptors into a single AML buffer,  *              in preparation for output to the AML output file.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|RsDoResourceTemplate
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|BufferLengthOp
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|BufferOp
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|DescriptorTypeOp
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|LastOp
init|=
name|NULL
decl_stmt|;
name|UINT32
name|CurrentByteOffset
init|=
literal|0
decl_stmt|;
name|ASL_RESOURCE_NODE
name|HeadRnode
decl_stmt|;
name|ASL_RESOURCE_NODE
modifier|*
name|PreviousRnode
decl_stmt|;
name|ASL_RESOURCE_NODE
modifier|*
name|Rnode
decl_stmt|;
name|ASL_RESOURCE_INFO
name|Info
decl_stmt|;
name|UINT8
name|State
decl_stmt|;
comment|/* Mark parent as containing a resource template */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
condition|)
block|{
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_RESOURCE_DESC
expr_stmt|;
block|}
comment|/* ResourceTemplate Opcode is first (Op) */
comment|/* Buffer Length node is first child */
name|BufferLengthOp
operator|=
name|ASL_GET_CHILD_NODE
argument_list|(
name|Op
argument_list|)
expr_stmt|;
comment|/* Buffer Op is first peer */
name|BufferOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|BufferLengthOp
argument_list|)
expr_stmt|;
comment|/* First Descriptor type is next */
name|DescriptorTypeOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|BufferOp
argument_list|)
expr_stmt|;
comment|/*      * Process all resource descriptors in the list      * Note: It is assumed that the EndTag node has been automatically      * inserted at the end of the template by the parser.      */
name|State
operator|=
name|ACPI_RSTATE_NORMAL
expr_stmt|;
name|PreviousRnode
operator|=
operator|&
name|HeadRnode
expr_stmt|;
while|while
condition|(
name|DescriptorTypeOp
condition|)
block|{
comment|/* Save information for optional mapfile */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_CONNECTION
condition|)
block|{
name|Info
operator|.
name|MappingOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
else|else
block|{
name|Info
operator|.
name|MappingOp
operator|=
name|DescriptorTypeOp
expr_stmt|;
block|}
name|Info
operator|.
name|DescriptorTypeOp
operator|=
name|DescriptorTypeOp
expr_stmt|;
name|Info
operator|.
name|CurrentByteOffset
operator|=
name|CurrentByteOffset
expr_stmt|;
name|DescriptorTypeOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_RESOURCE_DESC
expr_stmt|;
name|Rnode
operator|=
name|RsDoOneResourceDescriptor
argument_list|(
operator|&
name|Info
argument_list|,
operator|&
name|State
argument_list|)
expr_stmt|;
comment|/*          * Update current byte offset to indicate the number of bytes from the          * start of the buffer. Buffer can include multiple descriptors, we          * must keep track of the offset of not only each descriptor, but each          * element (field) within each descriptor as well.          */
name|CurrentByteOffset
operator|+=
name|RsLinkDescriptorChain
argument_list|(
operator|&
name|PreviousRnode
argument_list|,
name|Rnode
argument_list|)
expr_stmt|;
comment|/* Get the next descriptor in the list */
name|LastOp
operator|=
name|DescriptorTypeOp
expr_stmt|;
name|DescriptorTypeOp
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|DescriptorTypeOp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|State
operator|==
name|ACPI_RSTATE_DEPENDENT_LIST
condition|)
block|{
if|if
condition|(
name|LastOp
condition|)
block|{
name|LastOp
operator|=
name|LastOp
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_MISSING_ENDDEPENDENT
argument_list|,
name|LastOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Transform the nodes into the following      *      * Op           -> AML_BUFFER_OP      * First Child  -> BufferLength      * Second Child -> Descriptor Buffer (raw byte data)      */
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_BUFFER
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|=
name|AML_BUFFER_OP
expr_stmt|;
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|=
name|NODE_AML_PACKAGE
operator||
name|NODE_IS_RESOURCE_DESC
expr_stmt|;
name|UtSetParseOpName
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|BufferLengthOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_INTEGER
expr_stmt|;
name|BufferLengthOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|=
name|CurrentByteOffset
expr_stmt|;
operator|(
name|void
operator|)
name|OpcSetOptimalIntegerSize
argument_list|(
name|BufferLengthOp
argument_list|)
expr_stmt|;
name|UtSetParseOpName
argument_list|(
name|BufferLengthOp
argument_list|)
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_RAW_DATA
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|=
name|AML_RAW_DATA_CHAIN
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|AmlOpcodeLength
operator|=
literal|0
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|AmlLength
operator|=
name|CurrentByteOffset
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Buffer
operator|=
operator|(
name|UINT8
operator|*
operator|)
name|HeadRnode
operator|.
name|Next
expr_stmt|;
name|BufferOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IS_RESOURCE_DATA
expr_stmt|;
name|UtSetParseOpName
argument_list|(
name|BufferOp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

