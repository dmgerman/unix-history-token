begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- Target.h -------------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_ELF_TARGET_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_ELF_TARGET_H
end_define

begin_include
include|#
directive|include
file|"Error.h"
end_include

begin_include
include|#
directive|include
file|"InputSection.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ELF.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|std
operator|::
name|string
name|toString
argument_list|(
argument|uint32_t RelType
argument_list|)
expr_stmt|;
name|namespace
name|elf
block|{
name|class
name|InputFile
decl_stmt|;
name|class
name|SymbolBody
decl_stmt|;
name|class
name|TargetInfo
block|{
name|public
label|:
name|virtual
name|bool
name|isPicRel
argument_list|(
name|uint32_t
name|Type
argument_list|)
decl|const
block|{
return|return
name|true
return|;
block|}
name|virtual
name|uint32_t
name|getDynRel
argument_list|(
name|uint32_t
name|Type
argument_list|)
decl|const
block|{
return|return
name|Type
return|;
block|}
name|virtual
name|void
name|writeGotPltHeader
argument_list|(
name|uint8_t
operator|*
name|Buf
argument_list|)
decl|const
block|{}
name|virtual
name|void
name|writeGotPlt
argument_list|(
name|uint8_t
operator|*
name|Buf
argument_list|,
specifier|const
name|SymbolBody
operator|&
name|S
argument_list|)
decl|const
block|{}
empty_stmt|;
name|virtual
name|void
name|writeIgotPlt
argument_list|(
name|uint8_t
operator|*
name|Buf
argument_list|,
specifier|const
name|SymbolBody
operator|&
name|S
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|int64_t
name|getImplicitAddend
argument_list|(
specifier|const
name|uint8_t
operator|*
name|Buf
argument_list|,
name|uint32_t
name|Type
argument_list|)
decl|const
decl_stmt|;
comment|// If lazy binding is supported, the first entry of the PLT has code
comment|// to call the dynamic linker to resolve PLT entries the first time
comment|// they are called. This function writes that code.
name|virtual
name|void
name|writePltHeader
argument_list|(
name|uint8_t
operator|*
name|Buf
argument_list|)
decl|const
block|{}
name|virtual
name|void
name|writePlt
argument_list|(
name|uint8_t
operator|*
name|Buf
argument_list|,
name|uint64_t
name|GotEntryAddr
argument_list|,
name|uint64_t
name|PltEntryAddr
argument_list|,
name|int32_t
name|Index
argument_list|,
name|unsigned
name|RelOff
argument_list|)
decl|const
block|{}
name|virtual
name|void
name|addPltHeaderSymbols
argument_list|(
name|InputSectionBase
operator|*
name|IS
argument_list|)
decl|const
block|{}
name|virtual
name|void
name|addPltSymbols
argument_list|(
name|InputSectionBase
operator|*
name|IS
argument_list|,
name|uint64_t
name|Off
argument_list|)
decl|const
block|{}
comment|// Returns true if a relocation only uses the low bits of a value such that
comment|// all those bits are in in the same page. For example, if the relocation
comment|// only uses the low 12 bits in a system with 4k pages. If this is true, the
comment|// bits will always have the same value at runtime and we don't have to emit
comment|// a dynamic relocation.
name|virtual
name|bool
name|usesOnlyLowPageBits
argument_list|(
name|uint32_t
name|Type
argument_list|)
decl|const
decl_stmt|;
comment|// Decide whether a Thunk is needed for the relocation from File
comment|// targeting S.
name|virtual
name|bool
name|needsThunk
argument_list|(
name|RelExpr
name|Expr
argument_list|,
name|uint32_t
name|RelocType
argument_list|,
specifier|const
name|InputFile
operator|*
name|File
argument_list|,
specifier|const
name|SymbolBody
operator|&
name|S
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|RelExpr
name|getRelExpr
argument_list|(
name|uint32_t
name|Type
argument_list|,
specifier|const
name|SymbolBody
operator|&
name|S
argument_list|,
specifier|const
name|uint8_t
operator|*
name|Loc
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
name|void
name|relocateOne
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint32_t
name|Type
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|virtual
operator|~
name|TargetInfo
argument_list|()
expr_stmt|;
name|unsigned
name|TlsGdRelaxSkip
init|=
literal|1
decl_stmt|;
name|unsigned
name|PageSize
init|=
literal|4096
decl_stmt|;
name|unsigned
name|DefaultMaxPageSize
init|=
literal|4096
decl_stmt|;
comment|// On FreeBSD x86_64 the first page cannot be mmaped.
comment|// On Linux that is controled by vm.mmap_min_addr. At least on some x86_64
comment|// installs that is 65536, so the first 15 pages cannot be used.
comment|// Given that, the smallest value that can be used in here is 0x10000.
name|uint64_t
name|DefaultImageBase
init|=
literal|0x10000
decl_stmt|;
comment|// Offset of _GLOBAL_OFFSET_TABLE_ from base of .got section. Use -1 for
comment|// end of .got
name|uint64_t
name|GotBaseSymOff
init|=
literal|0
decl_stmt|;
name|uint32_t
name|CopyRel
decl_stmt|;
name|uint32_t
name|GotRel
decl_stmt|;
name|uint32_t
name|PltRel
decl_stmt|;
name|uint32_t
name|RelativeRel
decl_stmt|;
name|uint32_t
name|IRelativeRel
decl_stmt|;
name|uint32_t
name|TlsDescRel
decl_stmt|;
name|uint32_t
name|TlsGotRel
decl_stmt|;
name|uint32_t
name|TlsModuleIndexRel
decl_stmt|;
name|uint32_t
name|TlsOffsetRel
decl_stmt|;
name|unsigned
name|GotEntrySize
init|=
literal|0
decl_stmt|;
name|unsigned
name|GotPltEntrySize
init|=
literal|0
decl_stmt|;
name|unsigned
name|PltEntrySize
decl_stmt|;
name|unsigned
name|PltHeaderSize
decl_stmt|;
comment|// At least on x86_64 positions 1 and 2 are used by the first plt entry
comment|// to support lazy loading.
name|unsigned
name|GotPltHeaderEntriesNum
init|=
literal|3
decl_stmt|;
comment|// Set to 0 for variant 2
name|unsigned
name|TcbSize
init|=
literal|0
decl_stmt|;
name|bool
name|NeedsThunks
init|=
name|false
decl_stmt|;
comment|// A 4-byte field corresponding to one or more trap instructions, used to pad
comment|// executable OutputSections.
name|uint32_t
name|TrapInstr
init|=
literal|0
decl_stmt|;
name|virtual
name|RelExpr
name|adjustRelaxExpr
argument_list|(
name|uint32_t
name|Type
argument_list|,
specifier|const
name|uint8_t
operator|*
name|Data
argument_list|,
name|RelExpr
name|Expr
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|relaxGot
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|relaxTlsGdToIe
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint32_t
name|Type
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|relaxTlsGdToLe
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint32_t
name|Type
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|relaxTlsIeToLe
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint32_t
name|Type
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
decl_stmt|;
name|virtual
name|void
name|relaxTlsLdToLe
argument_list|(
name|uint8_t
operator|*
name|Loc
argument_list|,
name|uint32_t
name|Type
argument_list|,
name|uint64_t
name|Val
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
name|TargetInfo
modifier|*
name|getAArch64TargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getAMDGPUTargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getARMTargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getAVRTargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getPPC64TargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getPPCTargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getX32TargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getX86TargetInfo
parameter_list|()
function_decl|;
name|TargetInfo
modifier|*
name|getX86_64TargetInfo
parameter_list|()
function_decl|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|TargetInfo
operator|*
name|getMipsTargetInfo
argument_list|()
expr_stmt|;
name|std
operator|::
name|string
name|getErrorLocation
argument_list|(
specifier|const
name|uint8_t
operator|*
name|Loc
argument_list|)
expr_stmt|;
name|uint64_t
name|getPPC64TocBase
parameter_list|()
function_decl|;
name|uint64_t
name|getAArch64Page
parameter_list|(
name|uint64_t
name|Expr
parameter_list|)
function_decl|;
specifier|extern
name|TargetInfo
modifier|*
name|Target
decl_stmt|;
name|TargetInfo
modifier|*
name|getTarget
parameter_list|()
function_decl|;
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|static
name|void
name|checkInt
argument_list|(
argument|uint8_t *Loc
argument_list|,
argument|int64_t V
argument_list|,
argument|uint32_t Type
argument_list|)
block|{
if|if
condition|(
operator|!
name|llvm
operator|::
name|isInt
operator|<
name|N
operator|>
operator|(
name|V
operator|)
condition|)
name|error
argument_list|(
name|getErrorLocation
argument_list|(
name|Loc
argument_list|)
operator|+
literal|"relocation "
operator|+
name|lld
operator|::
name|toString
argument_list|(
name|Type
argument_list|)
operator|+
literal|" out of range"
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|static
name|void
name|checkUInt
argument_list|(
argument|uint8_t *Loc
argument_list|,
argument|uint64_t V
argument_list|,
argument|uint32_t Type
argument_list|)
block|{
if|if
condition|(
operator|!
name|llvm
operator|::
name|isUInt
operator|<
name|N
operator|>
operator|(
name|V
operator|)
condition|)
name|error
argument_list|(
name|getErrorLocation
argument_list|(
name|Loc
argument_list|)
operator|+
literal|"relocation "
operator|+
name|lld
operator|::
name|toString
argument_list|(
name|Type
argument_list|)
operator|+
literal|" out of range"
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|static
name|void
name|checkIntUInt
argument_list|(
argument|uint8_t *Loc
argument_list|,
argument|uint64_t V
argument_list|,
argument|uint32_t Type
argument_list|)
block|{
if|if
condition|(
operator|!
name|llvm
operator|::
name|isInt
operator|<
name|N
operator|>
operator|(
name|V
operator|)
operator|&&
operator|!
name|llvm
operator|::
name|isUInt
operator|<
name|N
operator|>
operator|(
name|V
operator|)
condition|)
name|error
argument_list|(
name|getErrorLocation
argument_list|(
name|Loc
argument_list|)
operator|+
literal|"relocation "
operator|+
name|lld
operator|::
name|toString
argument_list|(
name|Type
argument_list|)
operator|+
literal|" out of range"
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|unsigned
name|N
operator|>
specifier|static
name|void
name|checkAlignment
argument_list|(
argument|uint8_t *Loc
argument_list|,
argument|uint64_t V
argument_list|,
argument|uint32_t Type
argument_list|)
block|{
if|if
condition|(
operator|(
name|V
operator|&
operator|(
name|N
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|getErrorLocation
argument_list|(
name|Loc
argument_list|)
operator|+
literal|"improper alignment for relocation "
operator|+
name|lld
operator|::
name|toString
argument_list|(
name|Type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// namespace elf
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

