begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- LinkerScript.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_ELF_LINKER_SCRIPT_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_ELF_LINKER_SCRIPT_H
end_define

begin_include
include|#
directive|include
file|"Config.h"
end_include

begin_include
include|#
directive|include
file|"Strings.h"
end_include

begin_include
include|#
directive|include
file|"Writer.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MemoryBuffer.h"
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|class
name|DefinedCommon
decl_stmt|;
name|class
name|ScriptParser
decl_stmt|;
name|class
name|SymbolBody
decl_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|InputSectionBase
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|InputSection
expr_stmt|;
name|class
name|OutputSectionBase
decl_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|OutputSectionFactory
expr_stmt|;
name|class
name|InputSectionData
decl_stmt|;
comment|// This represents an expression in the linker script.
comment|// ScriptParser::readExpr reads an expression and returns an Expr.
comment|// Later, we evaluate the expression by calling the function
comment|// with the value of special context variable ".".
struct|struct
name|Expr
block|{
name|std
operator|::
name|function
operator|<
name|uint64_t
argument_list|(
name|uint64_t
argument_list|)
operator|>
name|Val
expr_stmt|;
name|std
operator|::
name|function
operator|<
name|bool
argument_list|()
operator|>
name|IsAbsolute
expr_stmt|;
comment|// If expression is section-relative the function below is used
comment|// to get the output section pointer.
name|std
operator|::
name|function
operator|<
specifier|const
name|OutputSectionBase
operator|*
operator|(
operator|)
operator|>
name|Section
expr_stmt|;
name|uint64_t
name|operator
argument_list|()
operator|(
name|uint64_t
name|Dot
operator|)
specifier|const
block|{
return|return
name|Val
argument_list|(
name|Dot
argument_list|)
return|;
block|}
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|Val
return|;
block|}
name|Expr
argument_list|(
name|std
operator|::
name|function
operator|<
name|uint64_t
argument_list|(
name|uint64_t
argument_list|)
operator|>
name|Val
argument_list|,
name|std
operator|::
name|function
operator|<
name|bool
argument_list|()
operator|>
name|IsAbsolute
argument_list|,
name|std
operator|::
name|function
operator|<
specifier|const
name|OutputSectionBase
operator|*
operator|(
operator|)
operator|>
name|Section
argument_list|)
operator|:
name|Val
argument_list|(
name|Val
argument_list|)
operator|,
name|IsAbsolute
argument_list|(
name|IsAbsolute
argument_list|)
operator|,
name|Section
argument_list|(
argument|Section
argument_list|)
block|{}
name|template
operator|<
name|typename
name|T
operator|>
name|Expr
argument_list|(
argument|T V
argument_list|)
operator|:
name|Expr
argument_list|(
argument|V
argument_list|,
argument|[] { return true; }
argument_list|,
argument|[] { return nullptr; }
argument_list|)
block|{}
name|Expr
argument_list|()
operator|:
name|Expr
argument_list|(
argument|nullptr
argument_list|)
block|{}
block|}
struct|;
comment|// Parses a linker script. Calling this function updates
comment|// Config and ScriptConfig.
name|void
name|readLinkerScript
parameter_list|(
name|MemoryBufferRef
name|MB
parameter_list|)
function_decl|;
comment|// Parses a version script.
name|void
name|readVersionScript
parameter_list|(
name|MemoryBufferRef
name|MB
parameter_list|)
function_decl|;
name|void
name|readDynamicList
parameter_list|(
name|MemoryBufferRef
name|MB
parameter_list|)
function_decl|;
comment|// This enum is used to implement linker script SECTIONS command.
comment|// https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS
enum|enum
name|SectionsCommandKind
block|{
name|AssignmentKind
block|,
comment|// . = expr or<sym> = expr
name|OutputSectionKind
block|,
name|InputSectionKind
block|,
name|AssertKind
block|,
comment|// ASSERT(expr)
name|BytesDataKind
comment|// BYTE(expr), SHORT(expr), LONG(expr) or QUAD(expr)
block|}
enum|;
struct|struct
name|BaseCommand
block|{
name|BaseCommand
argument_list|(
argument|int K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|virtual
operator|~
name|BaseCommand
argument_list|()
operator|=
expr|default
expr_stmt|;
name|int
name|Kind
decl_stmt|;
block|}
struct|;
comment|// This represents ". =<expr>" or "<symbol> =<expr>".
name|struct
name|SymbolAssignment
range|:
name|BaseCommand
block|{
name|SymbolAssignment
argument_list|(
argument|StringRef Name
argument_list|,
argument|Expr E
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|AssignmentKind
argument_list|)
block|,
name|Name
argument_list|(
name|Name
argument_list|)
block|,
name|Expression
argument_list|(
argument|E
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
comment|// The LHS of an expression. Name is either a symbol name or ".".
name|StringRef
name|Name
block|;
name|SymbolBody
operator|*
name|Sym
operator|=
name|nullptr
block|;
comment|// The RHS of an expression.
name|Expr
name|Expression
block|;
comment|// Command attributes for PROVIDE, HIDDEN and PROVIDE_HIDDEN.
name|bool
name|Provide
operator|=
name|false
block|;
name|bool
name|Hidden
operator|=
name|false
block|; }
decl_stmt|;
comment|// Linker scripts allow additional constraints to be put on ouput sections.
comment|// If an output section is marked as ONLY_IF_RO, the section is created
comment|// only if its input sections are read-only. Likewise, an output section
comment|// with ONLY_IF_RW is created if all input sections are RW.
name|enum
name|class
name|ConstraintKind
block|{
name|NoConstraint
operator|,
name|ReadOnly
operator|,
name|ReadWrite
block|}
empty_stmt|;
name|struct
name|OutputSectionCommand
range|:
name|BaseCommand
block|{
name|OutputSectionCommand
argument_list|(
argument|StringRef Name
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|OutputSectionKind
argument_list|)
block|,
name|Name
argument_list|(
argument|Name
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|StringRef
name|Name
block|;
name|Expr
name|AddrExpr
block|;
name|Expr
name|AlignExpr
block|;
name|Expr
name|LMAExpr
block|;
name|Expr
name|SubalignExpr
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|BaseCommand
operator|>>
name|Commands
block|;
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|Phdrs
block|;
name|uint32_t
name|Filler
operator|=
literal|0
block|;
name|ConstraintKind
name|Constraint
operator|=
name|ConstraintKind
operator|::
name|NoConstraint
block|;
name|std
operator|::
name|string
name|Location
block|; }
decl_stmt|;
comment|// This struct represents one section match pattern in SECTIONS() command.
comment|// It can optionally have negative match pattern for EXCLUDED_FILE command.
comment|// Also it may be surrounded with SORT() command, so contains sorting rules.
struct|struct
name|SectionPattern
block|{
name|SectionPattern
argument_list|(
name|StringMatcher
operator|&&
name|Pat1
argument_list|,
name|StringMatcher
operator|&&
name|Pat2
argument_list|)
operator|:
name|ExcludedFilePat
argument_list|(
name|Pat1
argument_list|)
operator|,
name|SectionPat
argument_list|(
argument|Pat2
argument_list|)
block|{}
name|StringMatcher
name|ExcludedFilePat
expr_stmt|;
name|StringMatcher
name|SectionPat
decl_stmt|;
name|SortSectionPolicy
name|SortOuter
decl_stmt|;
name|SortSectionPolicy
name|SortInner
decl_stmt|;
block|}
struct|;
name|struct
name|InputSectionDescription
range|:
name|BaseCommand
block|{
name|InputSectionDescription
argument_list|(
argument|StringRef FilePattern
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|InputSectionKind
argument_list|)
block|,
name|FilePat
argument_list|(
argument|FilePattern
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|StringMatcher
name|FilePat
block|;
comment|// Input sections that matches at least one of SectionPatterns
comment|// will be associated with this InputSectionDescription.
name|std
operator|::
name|vector
operator|<
name|SectionPattern
operator|>
name|SectionPatterns
block|;
name|std
operator|::
name|vector
operator|<
name|InputSectionData
operator|*
operator|>
name|Sections
block|; }
decl_stmt|;
comment|// Represents an ASSERT().
name|struct
name|AssertCommand
range|:
name|BaseCommand
block|{
name|AssertCommand
argument_list|(
argument|Expr E
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|AssertKind
argument_list|)
block|,
name|Expression
argument_list|(
argument|E
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|Expr
name|Expression
block|; }
decl_stmt|;
comment|// Represents BYTE(), SHORT(), LONG(), or QUAD().
name|struct
name|BytesDataCommand
range|:
name|BaseCommand
block|{
name|BytesDataCommand
argument_list|(
argument|Expr E
argument_list|,
argument|unsigned Size
argument_list|)
operator|:
name|BaseCommand
argument_list|(
name|BytesDataKind
argument_list|)
block|,
name|Expression
argument_list|(
name|E
argument_list|)
block|,
name|Size
argument_list|(
argument|Size
argument_list|)
block|{}
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|BaseCommand
operator|*
name|C
argument_list|)
block|;
name|Expr
name|Expression
block|;
name|unsigned
name|Offset
block|;
name|unsigned
name|Size
block|; }
decl_stmt|;
struct|struct
name|PhdrsCommand
block|{
name|StringRef
name|Name
decl_stmt|;
name|unsigned
name|Type
decl_stmt|;
name|bool
name|HasFilehdr
decl_stmt|;
name|bool
name|HasPhdrs
decl_stmt|;
name|unsigned
name|Flags
decl_stmt|;
name|Expr
name|LMAExpr
decl_stmt|;
block|}
struct|;
name|class
name|LinkerScriptBase
block|{
name|protected
label|:
operator|~
name|LinkerScriptBase
argument_list|()
operator|=
expr|default
expr_stmt|;
name|public
label|:
name|virtual
name|uint64_t
name|getHeaderSize
parameter_list|()
init|=
literal|0
function_decl|;
name|virtual
name|uint64_t
name|getSymbolValue
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|isDefined
parameter_list|(
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|bool
name|isAbsolute
parameter_list|(
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
specifier|const
name|OutputSectionBase
modifier|*
name|getSymbolSection
parameter_list|(
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
specifier|const
name|OutputSectionBase
modifier|*
name|getOutputSection
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|uint64_t
name|getOutputSectionSize
parameter_list|(
name|StringRef
name|S
parameter_list|)
init|=
literal|0
function_decl|;
block|}
empty_stmt|;
comment|// ScriptConfiguration holds linker script parse results.
struct|struct
name|ScriptConfiguration
block|{
comment|// Used to assign addresses to sections.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|BaseCommand
operator|>>
name|Commands
expr_stmt|;
comment|// Used to assign sections to headers.
name|std
operator|::
name|vector
operator|<
name|PhdrsCommand
operator|>
name|PhdrsCommands
expr_stmt|;
name|bool
name|HasSections
init|=
name|false
decl_stmt|;
comment|// List of section patterns specified with KEEP commands. They will
comment|// be kept even if they are unused and --gc-sections is specified.
name|std
operator|::
name|vector
operator|<
name|InputSectionDescription
operator|*
operator|>
name|KeptSections
expr_stmt|;
block|}
struct|;
specifier|extern
name|ScriptConfiguration
modifier|*
name|ScriptConfig
decl_stmt|;
comment|// This is a runner of the linker script.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|LinkerScript
name|final
operator|:
name|public
name|LinkerScriptBase
block|{
typedef|typedef
name|typename
name|ELFT
operator|::
name|uint
name|uintX_t
expr_stmt|;
name|public
operator|:
name|LinkerScript
argument_list|()
expr_stmt|;
operator|~
name|LinkerScript
argument_list|()
expr_stmt|;
name|void
name|processCommands
argument_list|(
name|OutputSectionFactory
operator|<
name|ELFT
operator|>
operator|&
name|Factory
argument_list|)
decl_stmt|;
name|void
name|addOrphanSections
argument_list|(
name|OutputSectionFactory
operator|<
name|ELFT
operator|>
operator|&
name|Factory
argument_list|)
decl_stmt|;
name|void
name|removeEmptyCommands
parameter_list|()
function_decl|;
name|void
name|adjustSectionsBeforeSorting
parameter_list|()
function_decl|;
name|void
name|adjustSectionsAfterSorting
parameter_list|()
function_decl|;
name|std
operator|::
name|vector
operator|<
name|PhdrEntry
operator|>
name|createPhdrs
argument_list|()
expr_stmt|;
name|bool
name|ignoreInterpSection
parameter_list|()
function_decl|;
name|uint32_t
name|getFiller
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|void
name|writeDataBytes
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
modifier|*
name|Buf
parameter_list|)
function_decl|;
name|bool
name|hasLMA
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|bool
name|shouldKeep
argument_list|(
name|InputSectionBase
operator|<
name|ELFT
operator|>
operator|*
name|S
argument_list|)
decl_stmt|;
name|void
name|assignOffsets
parameter_list|(
name|OutputSectionCommand
modifier|*
name|Cmd
parameter_list|)
function_decl|;
name|void
name|placeOrphanSections
parameter_list|()
function_decl|;
name|void
name|assignAddresses
argument_list|(
name|std
operator|::
name|vector
operator|<
name|PhdrEntry
operator|>
operator|&
name|Phdrs
argument_list|)
decl_stmt|;
name|bool
name|hasPhdrsCommands
parameter_list|()
function_decl|;
name|uint64_t
name|getHeaderSize
argument_list|()
name|override
expr_stmt|;
name|uint64_t
name|getSymbolValue
argument_list|(
specifier|const
name|Twine
operator|&
name|Loc
argument_list|,
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
name|bool
name|isDefined
argument_list|(
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
name|bool
name|isAbsolute
argument_list|(
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
specifier|const
name|OutputSectionBase
modifier|*
name|getSymbolSection
argument_list|(
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
specifier|const
name|OutputSectionBase
modifier|*
name|getOutputSection
argument_list|(
specifier|const
name|Twine
operator|&
name|Loc
argument_list|,
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
name|uint64_t
name|getOutputSectionSize
argument_list|(
name|StringRef
name|S
argument_list|)
name|override
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|OutputSectionBase
operator|*
operator|>
operator|*
name|OutputSections
expr_stmt|;
name|int
name|getSectionIndex
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|computeInputSections
parameter_list|(
name|InputSectionDescription
modifier|*
parameter_list|)
function_decl|;
name|void
name|addSection
argument_list|(
name|OutputSectionFactory
operator|<
name|ELFT
operator|>
operator|&
name|Factory
argument_list|,
name|InputSectionBase
operator|<
name|ELFT
operator|>
operator|*
name|Sec
argument_list|,
name|StringRef
name|Name
argument_list|)
decl_stmt|;
name|void
name|discard
argument_list|(
name|ArrayRef
operator|<
name|InputSectionBase
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|V
argument_list|)
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|InputSectionBase
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|createInputSectionList
argument_list|(
name|OutputSectionCommand
operator|&
name|Cmd
argument_list|)
expr_stmt|;
comment|// "ScriptConfig" is a bit too long, so define a short name for it.
name|ScriptConfiguration
modifier|&
name|Opt
init|=
operator|*
name|ScriptConfig
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|size_t
operator|>
name|getPhdrIndices
argument_list|(
argument|StringRef SectionName
argument_list|)
expr_stmt|;
name|size_t
name|getPhdrIndex
parameter_list|(
specifier|const
name|Twine
modifier|&
name|Loc
parameter_list|,
name|StringRef
name|PhdrName
parameter_list|)
function_decl|;
name|uintX_t
name|Dot
decl_stmt|;
name|uintX_t
name|LMAOffset
init|=
literal|0
decl_stmt|;
name|OutputSectionBase
modifier|*
name|CurOutSec
init|=
name|nullptr
decl_stmt|;
name|uintX_t
name|ThreadBssOffset
init|=
literal|0
decl_stmt|;
name|void
name|switchTo
parameter_list|(
name|OutputSectionBase
modifier|*
name|Sec
parameter_list|)
function_decl|;
name|void
name|flush
parameter_list|()
function_decl|;
name|void
name|output
argument_list|(
name|InputSection
operator|<
name|ELFT
operator|>
operator|*
name|Sec
argument_list|)
decl_stmt|;
name|void
name|process
parameter_list|(
name|BaseCommand
modifier|&
name|Base
parameter_list|)
function_decl|;
name|llvm
operator|::
name|DenseSet
operator|<
name|OutputSectionBase
operator|*
operator|>
name|AlreadyOutputOS
expr_stmt|;
name|llvm
operator|::
name|DenseSet
operator|<
name|InputSectionData
operator|*
operator|>
name|AlreadyOutputIS
expr_stmt|;
block|}
empty_stmt|;
comment|// Variable template is a C++14 feature, so we can't template
comment|// a global variable. Use a struct to workaround.
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Script
block|{
specifier|static
name|LinkerScript
operator|<
name|ELFT
operator|>
operator|*
name|X
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|LinkerScript
operator|<
name|ELFT
operator|>
operator|*
name|Script
operator|<
name|ELFT
operator|>
operator|::
name|X
expr_stmt|;
specifier|extern
name|LinkerScriptBase
modifier|*
name|ScriptBase
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_ELF_LINKER_SCRIPT_H
end_comment

end_unit

