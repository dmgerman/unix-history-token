begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- SymbolTable.h --------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_ELF_SYMBOL_TABLE_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_ELF_SYMBOL_TABLE_H
end_define

begin_include
include|#
directive|include
file|"InputFiles.h"
end_include

begin_include
include|#
directive|include
file|"LTO.h"
end_include

begin_include
include|#
directive|include
file|"Strings.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/CachedHashString.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|class
name|Lazy
decl_stmt|;
struct_decl|struct
name|Symbol
struct_decl|;
comment|// SymbolTable is a bucket of all known symbols, including defined,
comment|// undefined, or lazy symbols (the last one is symbols in archive
comment|// files whose archive members are not yet loaded).
comment|//
comment|// We put all symbols of all files to a SymbolTable, and the
comment|// SymbolTable selects the "best" symbols if there are name
comment|// conflicts. For example, obviously, a defined symbol is better than
comment|// an undefined symbol. Or, if there's a conflict between a lazy and a
comment|// undefined, it'll read an archive member to read a real definition
comment|// to replace the lazy symbol. The logic is implemented in the
comment|// add*() functions, which are called by input files as they are parsed. There
comment|// is one add* function per symbol type.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|SymbolTable
block|{
typedef|typedef
name|typename
name|ELFT
operator|::
name|Sym
name|Elf_Sym
expr_stmt|;
name|public
operator|:
name|void
name|addFile
argument_list|(
name|InputFile
operator|*
name|File
argument_list|)
expr_stmt|;
name|void
name|addCombinedLTOObject
parameter_list|()
function_decl|;
name|ArrayRef
operator|<
name|Symbol
operator|*
operator|>
name|getSymbols
argument_list|()
specifier|const
block|{
return|return
name|SymVector
return|;
block|}
name|ArrayRef
operator|<
name|ObjectFile
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|getObjectFiles
argument_list|()
specifier|const
block|{
return|return
name|ObjectFiles
return|;
block|}
name|ArrayRef
operator|<
name|BinaryFile
operator|*
operator|>
name|getBinaryFiles
argument_list|()
specifier|const
block|{
return|return
name|BinaryFiles
return|;
block|}
name|ArrayRef
operator|<
name|SharedFile
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|getSharedFiles
argument_list|()
specifier|const
block|{
return|return
name|SharedFiles
return|;
block|}
name|DefinedRegular
modifier|*
name|addAbsolute
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
name|Visibility
init|=
name|llvm
operator|::
name|ELF
operator|::
name|STV_HIDDEN
parameter_list|,
name|uint8_t
name|Binding
init|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
parameter_list|)
function_decl|;
name|DefinedRegular
modifier|*
name|addIgnored
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
name|Visibility
init|=
name|llvm
operator|::
name|ELF
operator|::
name|STV_HIDDEN
parameter_list|)
function_decl|;
name|Symbol
modifier|*
name|addUndefined
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|Symbol
modifier|*
name|addUndefined
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|bool
name|IsLocal
parameter_list|,
name|uint8_t
name|Binding
parameter_list|,
name|uint8_t
name|StOther
parameter_list|,
name|uint8_t
name|Type
parameter_list|,
name|bool
name|CanOmitFromDynSym
parameter_list|,
name|InputFile
modifier|*
name|File
parameter_list|)
function_decl|;
name|Symbol
modifier|*
name|addRegular
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
name|StOther
parameter_list|,
name|uint8_t
name|Type
parameter_list|,
name|uint64_t
name|Value
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|uint8_t
name|Binding
parameter_list|,
name|SectionBase
modifier|*
name|Section
parameter_list|,
name|InputFile
modifier|*
name|File
parameter_list|)
function_decl|;
name|void
name|addShared
argument_list|(
name|SharedFile
operator|<
name|ELFT
operator|>
operator|*
name|F
argument_list|,
name|StringRef
name|Name
argument_list|,
specifier|const
name|Elf_Sym
operator|&
name|Sym
argument_list|,
specifier|const
name|typename
name|ELFT
operator|::
name|Verdef
operator|*
name|Verdef
argument_list|)
decl_stmt|;
name|void
name|addLazyArchive
argument_list|(
name|ArchiveFile
operator|*
name|F
argument_list|,
specifier|const
name|llvm
operator|::
name|object
operator|::
name|Archive
operator|::
name|Symbol
name|S
argument_list|)
decl_stmt|;
name|void
name|addLazyObject
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|LazyObjectFile
modifier|&
name|Obj
parameter_list|)
function_decl|;
name|Symbol
modifier|*
name|addBitcode
parameter_list|(
name|StringRef
name|Name
parameter_list|,
name|uint8_t
name|Binding
parameter_list|,
name|uint8_t
name|StOther
parameter_list|,
name|uint8_t
name|Type
parameter_list|,
name|bool
name|CanOmitFromDynSym
parameter_list|,
name|BitcodeFile
modifier|*
name|File
parameter_list|)
function_decl|;
name|Symbol
modifier|*
name|addCommon
parameter_list|(
name|StringRef
name|N
parameter_list|,
name|uint64_t
name|Size
parameter_list|,
name|uint32_t
name|Alignment
parameter_list|,
name|uint8_t
name|Binding
parameter_list|,
name|uint8_t
name|StOther
parameter_list|,
name|uint8_t
name|Type
parameter_list|,
name|InputFile
modifier|*
name|File
parameter_list|)
function_decl|;
name|std
operator|::
name|pair
operator|<
name|Symbol
operator|*
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|StringRef Name
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|Symbol
operator|*
operator|,
name|bool
operator|>
name|insert
argument_list|(
argument|StringRef Name
argument_list|,
argument|uint8_t Type
argument_list|,
argument|uint8_t Visibility
argument_list|,
argument|bool CanOmitFromDynSym
argument_list|,
argument|InputFile *File
argument_list|)
expr_stmt|;
name|void
name|scanUndefinedFlags
parameter_list|()
function_decl|;
name|void
name|scanShlibUndefined
parameter_list|()
function_decl|;
name|void
name|scanVersionScript
parameter_list|()
function_decl|;
name|SymbolBody
modifier|*
name|find
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|SymbolBody
modifier|*
name|findInCurrentDSO
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|void
name|trace
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|void
name|wrap
parameter_list|(
name|StringRef
name|Name
parameter_list|)
function_decl|;
name|private
label|:
name|std
operator|::
name|vector
operator|<
name|SymbolBody
operator|*
operator|>
name|findByVersion
argument_list|(
argument|SymbolVersion Ver
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SymbolBody
operator|*
operator|>
name|findAllByVersion
argument_list|(
argument|SymbolVersion Ver
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|StringMap
operator|<
name|std
operator|::
name|vector
operator|<
name|SymbolBody
operator|*
operator|>>
operator|&
name|getDemangledSyms
argument_list|()
expr_stmt|;
name|void
name|handleAnonymousVersion
parameter_list|()
function_decl|;
name|void
name|assignExactVersion
parameter_list|(
name|SymbolVersion
name|Ver
parameter_list|,
name|uint16_t
name|VersionId
parameter_list|,
name|StringRef
name|VersionName
parameter_list|)
function_decl|;
name|void
name|assignWildcardVersion
parameter_list|(
name|SymbolVersion
name|Ver
parameter_list|,
name|uint16_t
name|VersionId
parameter_list|)
function_decl|;
struct|struct
name|SymIndex
block|{
name|SymIndex
argument_list|(
argument|int Idx
argument_list|,
argument|bool Traced
argument_list|)
block|:
name|Idx
argument_list|(
name|Idx
argument_list|)
operator|,
name|Traced
argument_list|(
argument|Traced
argument_list|)
block|{}
name|int
name|Idx
operator|:
literal|31
expr_stmt|;
name|unsigned
name|Traced
range|:
literal|1
decl_stmt|;
block|}
struct|;
comment|// The order the global symbols are in is not defined. We can use an arbitrary
comment|// order, but it has to be reproducible. That is true even when cross linking.
comment|// The default hashing of StringRef produces different results on 32 and 64
comment|// bit systems so we use a map to a vector. That is arbitrary, deterministic
comment|// but a bit inefficient.
comment|// FIXME: Experiment with passing in a custom hashing or sorting the symbols
comment|// once symbol resolution is finished.
name|llvm
operator|::
name|DenseMap
operator|<
name|llvm
operator|::
name|CachedHashStringRef
operator|,
name|SymIndex
operator|>
name|Symtab
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Symbol
operator|*
operator|>
name|SymVector
expr_stmt|;
comment|// Comdat groups define "link once" sections. If two comdat groups have the
comment|// same name, only one of them is linked, and the other is ignored. This set
comment|// is used to uniquify them.
name|llvm
operator|::
name|DenseSet
operator|<
name|llvm
operator|::
name|CachedHashStringRef
operator|>
name|ComdatGroups
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|ObjectFile
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|ObjectFiles
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|SharedFile
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|SharedFiles
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BitcodeFile
operator|*
operator|>
name|BitcodeFiles
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|BinaryFile
operator|*
operator|>
name|BinaryFiles
expr_stmt|;
comment|// Set of .so files to not link the same shared object file more than once.
name|llvm
operator|::
name|DenseSet
operator|<
name|StringRef
operator|>
name|SoNames
expr_stmt|;
comment|// A map from demangled symbol names to their symbol objects.
comment|// This mapping is 1:N because two symbols with different versions
comment|// can have the same name. We use this map to handle "extern C++ {}"
comment|// directive in version scripts.
name|llvm
operator|::
name|Optional
operator|<
name|llvm
operator|::
name|StringMap
operator|<
name|std
operator|::
name|vector
operator|<
name|SymbolBody
operator|*
operator|>>>
name|DemangledSyms
expr_stmt|;
comment|// For LTO.
name|std
operator|::
name|unique_ptr
operator|<
name|BitcodeCompiler
operator|>
name|LTO
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
expr|struct
name|Symtab
block|{
specifier|static
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|X
block|; }
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|Symtab
operator|<
name|ELFT
operator|>
operator|::
name|X
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// namespace elf
end_comment

begin_comment
unit|}
comment|// namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

