begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2017  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Prompting and other messages.  * There are three flavors of prompts, SHORT, MEDIUM and LONG,  * selected by the -m/-M options.  * There is also the "equals message", printed by the = command.  * A prompt is a message composed of various pieces, such as the   * name of the file being viewed, the percentage into the file, etc.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|pr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|new_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hshift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|less_is_more
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|EDITOR
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|editor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|editproto
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes for the three flavors of prompts.  * These strings are expanded by pr_expand().  */
end_comment

begin_decl_stmt
specifier|static
name|constant
name|char
name|s_proto
index|[]
init|=
literal|"?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|m_proto
index|[]
init|=
literal|"?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|M_proto
index|[]
init|=
literal|"?f%f .?n?m(%T %i of %m) ..?ltlines %lt-%lb?L/%L. :byte %bB?s/%s. .?e(END) ?x- Next\\: %x.:?pB%pB\\%..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|e_proto
index|[]
init|=
literal|"?f%f .?m(%T %i of %m) .?ltlines %lt-%lb?L/%L. .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|h_proto
index|[]
init|=
literal|"HELP -- ?eEND -- Press g to see it again:Press RETURN for more., or q when done"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|w_proto
index|[]
init|=
literal|"Waiting for data"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|constant
name|char
name|more_proto
index|[]
init|=
literal|"--More--(?eEND ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
name|prproto
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|constant
modifier|*
name|eqproto
init|=
name|e_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|constant
modifier|*
name|hproto
init|=
name|h_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|constant
modifier|*
name|wproto
init|=
name|w_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|message
index|[
name|PROMPT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the prompt prototype strings.  */
end_comment

begin_function
name|public
name|void
name|init_prompt
parameter_list|()
block|{
name|prproto
index|[
literal|0
index|]
operator|=
name|save
argument_list|(
name|s_proto
argument_list|)
expr_stmt|;
name|prproto
index|[
literal|1
index|]
operator|=
name|save
argument_list|(
name|less_is_more
condition|?
name|more_proto
else|:
name|m_proto
argument_list|)
expr_stmt|;
name|prproto
index|[
literal|2
index|]
operator|=
name|save
argument_list|(
name|M_proto
argument_list|)
expr_stmt|;
name|eqproto
operator|=
name|save
argument_list|(
name|e_proto
argument_list|)
expr_stmt|;
name|hproto
operator|=
name|save
argument_list|(
name|h_proto
argument_list|)
expr_stmt|;
name|wproto
operator|=
name|save
argument_list|(
name|w_proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a string to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_str
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|+
name|len
operator|>=
name|message
operator|+
name|PROMPT_SIZE
condition|)
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|message
operator|+
name|PROMPT_SIZE
operator|-
name|mp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mp
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a character to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_char
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ap_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a POSITION (as a decimal integer) to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_pos
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|pos
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
name|postoa
argument_list|(
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ap_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a line number to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_linenum
parameter_list|(
name|linenum
parameter_list|)
name|LINENUM
name|linenum
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|linenum
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
name|linenumtoa
argument_list|(
name|linenum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ap_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append an integer to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_int
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|num
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
name|inttoa
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ap_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a question mark to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_quest
parameter_list|()
block|{
name|ap_str
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the "current" byte offset in the file.  */
end_comment

begin_function
specifier|static
name|POSITION
name|curr_byte
parameter_list|(
name|where
parameter_list|)
name|int
name|where
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|where
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|==
name|NULL_POSITION
operator|&&
name|where
operator|>=
literal|0
operator|&&
name|where
operator|<
name|sc_height
operator|-
literal|1
condition|)
name|pos
operator|=
name|position
argument_list|(
operator|++
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the value of a prototype conditional.  * A prototype string may include conditionals which consist of a   * question mark followed by a single letter.  * Here we decode that letter and return the appropriate boolean value.  */
end_comment

begin_function
specifier|static
name|int
name|cond
parameter_list|(
name|c
parameter_list|,
name|where
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|POSITION
name|len
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Anything in the message yet? */
return|return
operator|(
name|mp
operator|>
name|message
operator|)
return|;
case|case
literal|'b'
case|:
comment|/* Current byte offset known? */
return|return
operator|(
name|curr_byte
argument_list|(
name|where
argument_list|)
operator|!=
name|NULL_POSITION
operator|)
return|;
case|case
literal|'c'
case|:
return|return
operator|(
name|hshift
operator|!=
literal|0
operator|)
return|;
case|case
literal|'e'
case|:
comment|/* At end of file? */
return|return
operator|(
name|eof_displayed
argument_list|()
operator|)
return|;
case|case
literal|'f'
case|:
comment|/* Filename known? */
return|return
operator|(
name|strcmp
argument_list|(
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|)
return|;
case|case
literal|'l'
case|:
comment|/* Line number known? */
case|case
literal|'d'
case|:
comment|/* Same as l */
return|return
operator|(
name|linenums
operator|)
return|;
case|case
literal|'L'
case|:
comment|/* Final line number known? */
case|case
literal|'D'
case|:
comment|/* Final page number known? */
return|return
operator|(
name|linenums
operator|&&
name|ch_length
argument_list|()
operator|!=
name|NULL_POSITION
operator|)
return|;
case|case
literal|'m'
case|:
comment|/* More than one file? */
if|#
directive|if
name|TAGS
return|return
operator|(
name|ntags
argument_list|()
condition|?
operator|(
name|ntags
argument_list|()
operator|>
literal|1
operator|)
else|:
operator|(
name|nifile
argument_list|()
operator|>
literal|1
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|nifile
argument_list|()
operator|>
literal|1
operator|)
return|;
endif|#
directive|endif
case|case
literal|'n'
case|:
comment|/* First prompt in a new file? */
if|#
directive|if
name|TAGS
return|return
operator|(
name|ntags
argument_list|()
condition|?
literal|1
else|:
name|new_file
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|new_file
operator|)
return|;
endif|#
directive|endif
case|case
literal|'p'
case|:
comment|/* Percent into file (bytes) known? */
return|return
operator|(
name|curr_byte
argument_list|(
name|where
argument_list|)
operator|!=
name|NULL_POSITION
operator|&&
name|ch_length
argument_list|()
operator|>
literal|0
operator|)
return|;
case|case
literal|'P'
case|:
comment|/* Percent into file (lines) known? */
return|return
operator|(
name|currline
argument_list|(
name|where
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|>
literal|0
operator|&&
name|find_linenum
argument_list|(
name|len
argument_list|)
operator|!=
literal|0
operator|)
return|;
case|case
literal|'s'
case|:
comment|/* Size of file known? */
case|case
literal|'B'
case|:
return|return
operator|(
name|ch_length
argument_list|()
operator|!=
name|NULL_POSITION
operator|)
return|;
case|case
literal|'x'
case|:
comment|/* Is there a "next" file? */
if|#
directive|if
name|TAGS
if|if
condition|(
name|ntags
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|next_ifile
argument_list|(
name|curr_ifile
argument_list|)
operator|!=
name|NULL_IFILE
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode a "percent" prototype character.  * A prototype string may include various "percent" escapes;  * that is, a percent sign followed by a single letter.  * Here we decode that letter and take the appropriate action,  * usually by appending something to the message being built.  */
end_comment

begin_function
specifier|static
name|void
name|protochar
parameter_list|(
name|c
parameter_list|,
name|where
parameter_list|,
name|iseditproto
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|iseditproto
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|int
name|n
decl_stmt|;
name|LINENUM
name|linenum
decl_stmt|;
name|LINENUM
name|last_linenum
decl_stmt|;
name|IFILE
name|h
decl_stmt|;
undef|#
directive|undef
name|PAGE_NUM
define|#
directive|define
name|PAGE_NUM
parameter_list|(
name|linenum
parameter_list|)
value|((((linenum) - 1) / (sc_height - 1)) + 1)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Current byte offset */
name|pos
operator|=
name|curr_byte
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|NULL_POSITION
condition|)
name|ap_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ap_int
argument_list|(
name|hshift
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Current page number */
name|linenum
operator|=
name|currline
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|>
literal|0
operator|&&
name|sc_height
operator|>
literal|1
condition|)
name|ap_linenum
argument_list|(
name|PAGE_NUM
argument_list|(
name|linenum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Final page number */
comment|/* Find the page number of the last byte in the file (len-1). */
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NULL_POSITION
condition|)
name|ap_quest
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
comment|/* An empty file has no pages. */
name|ap_linenum
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|linenum
operator|=
name|find_linenum
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|<=
literal|0
condition|)
name|ap_quest
argument_list|()
expr_stmt|;
else|else
name|ap_linenum
argument_list|(
name|PAGE_NUM
argument_list|(
name|linenum
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|EDITOR
case|case
literal|'E'
case|:
comment|/* Editor name */
name|ap_str
argument_list|(
name|editor
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
comment|/* File name */
name|ap_str
argument_list|(
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Last component of file name */
name|ap_str
argument_list|(
name|last_component
argument_list|(
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Index into list of files */
if|#
directive|if
name|TAGS
if|if
condition|(
name|ntags
argument_list|()
condition|)
name|ap_int
argument_list|(
name|curr_tag
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ap_int
argument_list|(
name|get_index
argument_list|(
name|curr_ifile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Current line number */
name|linenum
operator|=
name|currline
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|ap_linenum
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Final line number */
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NULL_POSITION
operator|||
name|len
operator|==
name|ch_zero
argument_list|()
operator|||
operator|(
name|linenum
operator|=
name|find_linenum
argument_list|(
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|ap_quest
argument_list|()
expr_stmt|;
else|else
name|ap_linenum
argument_list|(
name|linenum
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Number of files */
if|#
directive|if
name|TAGS
name|n
operator|=
name|ntags
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|ap_int
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ap_int
argument_list|(
name|nifile
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Percent into file (bytes) */
name|pos
operator|=
name|curr_byte
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|NULL_POSITION
operator|&&
name|len
operator|>
literal|0
condition|)
name|ap_int
argument_list|(
name|percentage
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Percent into file (lines) */
name|linenum
operator|=
name|currline
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|==
literal|0
operator|||
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|==
name|NULL_POSITION
operator|||
name|len
operator|==
name|ch_zero
argument_list|()
operator|||
operator|(
name|last_linenum
operator|=
name|find_linenum
argument_list|(
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|ap_quest
argument_list|()
expr_stmt|;
else|else
name|ap_int
argument_list|(
name|percentage
argument_list|(
name|linenum
argument_list|,
name|last_linenum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Size of file */
case|case
literal|'B'
case|:
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL_POSITION
condition|)
name|ap_pos
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Truncate trailing spaces in the message */
while|while
condition|(
name|mp
operator|>
name|message
operator|&&
name|mp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|mp
operator|--
expr_stmt|;
operator|*
name|mp
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Type of list */
if|#
directive|if
name|TAGS
if|if
condition|(
name|ntags
argument_list|()
condition|)
name|ap_str
argument_list|(
literal|"tag"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ap_str
argument_list|(
literal|"file"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Name of next file */
name|h
operator|=
name|next_ifile
argument_list|(
name|curr_ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL_IFILE
condition|)
name|ap_str
argument_list|(
name|get_filename
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip a false conditional.  * When a false condition is found (either a false IF or the ELSE part   * of a true IF), this routine scans the prototype string to decide  * where to resume parsing the string.  * We must keep track of nested IFs and skip them properly.  */
end_comment

begin_function
specifier|static
name|constant
name|char
modifier|*
name|skipcond
parameter_list|(
name|p
parameter_list|)
name|constant
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|iflevel
decl_stmt|;
comment|/* 	 * We came in here after processing a ? or :, 	 * so we start nested one level deep. 	 */
name|iflevel
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* 		 * Start of a nested IF. 		 */
name|iflevel
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* 		 * Else. 		 * If this matches the IF we came in here with, 		 * then we're done. 		 */
if|if
condition|(
name|iflevel
operator|==
literal|1
condition|)
return|return
operator|(
name|p
operator|)
return|;
break|break;
case|case
literal|'.'
case|:
comment|/* 		 * Endif. 		 * If this matches the IF we came in here with, 		 * then we're done. 		 */
if|if
condition|(
operator|--
name|iflevel
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* 		 * Backslash escapes the next character. 		 */
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* 		 * Whoops.  Hit end of string. 		 * This is a malformed conditional, but just treat it 		 * as if all active conditionals ends here. 		 */
return|return
operator|(
name|p
operator|-
literal|1
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Decode a char that represents a position on the screen.  */
end_comment

begin_function
specifier|static
name|constant
name|char
modifier|*
name|wherechar
parameter_list|(
name|p
parameter_list|,
name|wp
parameter_list|)
name|char
name|constant
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|wp
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'l'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|wp
operator|=
name|TOP
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
operator|*
name|wp
operator|=
name|MIDDLE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|wp
operator|=
name|BOTTOM
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|*
name|wp
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
operator|*
name|wp
operator|=
name|adjsline
argument_list|(
name|jump_sline
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|wp
operator|=
name|TOP
expr_stmt|;
name|p
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a message based on a prototype string.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|pr_expand
parameter_list|(
name|proto
parameter_list|,
name|maxwidth
parameter_list|)
name|constant
name|char
modifier|*
name|proto
decl_stmt|;
name|int
name|maxwidth
decl_stmt|;
block|{
name|constant
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
name|mp
operator|=
name|message
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|""
operator|)
return|;
for|for
control|(
name|p
operator|=
name|proto
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
comment|/* Just put the character in the message */
name|ap_char
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash escapes the next character */
name|p
operator|++
expr_stmt|;
name|ap_char
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Conditional (IF) */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
block|{
name|where
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|wherechar
argument_list|(
name|p
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
argument_list|(
name|c
argument_list|,
name|where
argument_list|)
condition|)
name|p
operator|=
name|skipcond
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
comment|/* ELSE */
name|p
operator|=
name|skipcond
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* ENDIF */
break|break;
case|case
literal|'%'
case|:
comment|/* Percent escape */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
block|{
name|where
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|wherechar
argument_list|(
name|p
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|protochar
argument_list|(
name|c
argument_list|,
name|where
argument_list|,
if|#
directive|if
name|EDITOR
operator|(
name|proto
operator|==
name|editproto
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
literal|0
block|)
empty_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
end_function

begin_if
if|if
condition|(
name|mp
operator|==
name|message
condition|)
return|return
operator|(
literal|""
operator|)
return|;
end_if

begin_if
if|if
condition|(
name|maxwidth
operator|>
literal|0
operator|&&
name|mp
operator|>=
name|message
operator|+
name|maxwidth
condition|)
block|{
comment|/* 		 * Message is too long. 		 * Return just the final portion of it. 		 */
return|return
operator|(
name|mp
operator|-
name|maxwidth
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
name|message
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Return a message suitable for printing by the "=" command.  */
end_comment

begin_function
unit|public
name|char
modifier|*
name|eq_message
parameter_list|()
block|{
return|return
operator|(
name|pr_expand
argument_list|(
name|eqproto
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a prompt.  * This depends on the prompt type (SHORT, MEDIUM, LONG), etc.  * If we can't come up with an appropriate prompt, return NULL  * and the caller will prompt with a colon.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|pr_string
parameter_list|()
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
operator|!
name|less_is_more
operator|)
condition|?
name|pr_type
else|:
name|pr_type
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|prompt
operator|=
name|pr_expand
argument_list|(
operator|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
operator|)
condition|?
name|hproto
else|:
name|prproto
index|[
name|type
index|]
argument_list|,
name|sc_width
operator|-
name|so_s_width
operator|-
name|so_e_width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|new_file
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|prompt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a message suitable for printing while waiting in the F command.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|wait_message
parameter_list|()
block|{
return|return
operator|(
name|pr_expand
argument_list|(
name|wproto
argument_list|,
name|sc_width
operator|-
name|so_s_width
operator|-
name|so_e_width
operator|-
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

