begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_SUPPORT_DEBUG_MODE_HELPER_H
end_ifndef

begin_define
define|#
directive|define
name|TEST_SUPPORT_DEBUG_MODE_HELPER_H
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBCPP_DEBUG
end_ifndef

begin_error
error|#
directive|error
error|_LIBCPP_DEBUG must be defined before including this header
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBCPP_DEBUG_USE_EXCEPTIONS
end_ifndef

begin_error
error|#
directive|error
error|_LIBCPP_DEBUG_USE_EXCEPTIONS must be defined before including this header
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ciso646>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBCPP_VERSION
end_ifndef

begin_error
error|#
directive|error
error|This header may only be used for libc++ tests" #endif
end_error

begin_include
include|#
directive|include
file|<__debug>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|"test_macros.h"
end_include

begin_include
include|#
directive|include
file|"assert_checkpoint.h"
end_include

begin_include
include|#
directive|include
file|"test_allocator.h"
end_include

begin_comment
comment|// These test make use of 'if constexpr'.
end_comment

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|<=
literal|14
end_if

begin_error
error|#
directive|error
error|This header may only be used in C++17 and greater
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_HAS_NO_EXCEPTIONS
end_ifdef

begin_error
error|#
directive|error
error|These tests require exceptions
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__cpp_if_constexpr
end_ifndef

begin_error
error|#
directive|error
error|These tests require if constexpr
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// Assert that the specified expression throws a libc++ debug exception.
end_comment

begin_define
define|#
directive|define
name|CHECK_DEBUG_THROWS
parameter_list|(
modifier|...
parameter_list|)
value|assert((CheckDebugThrows( [&]() { __VA_ARGS__; } )))
end_define

begin_expr_stmt
name|template
operator|<
name|class
name|Func
operator|>
specifier|inline
name|bool
name|CheckDebugThrows
argument_list|(
argument|Func&& func
argument_list|)
block|{
name|try
block|{
name|func
argument_list|()
block|;   }
name|catch
argument_list|(
argument|std::__libcpp_debug_exception const&
argument_list|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_macro
unit|}  namespace
name|IteratorDebugChecks
end_macro

begin_block
block|{
enum|enum
name|ContainerType
block|{
name|CT_None
block|,
name|CT_String
block|,
name|CT_Vector
block|,
name|CT_VectorBool
block|,
name|CT_List
block|,
name|CT_Deque
block|,
name|CT_ForwardList
block|,
name|CT_Map
block|,
name|CT_Set
block|,
name|CT_MultiMap
block|,
name|CT_MultiSet
block|,
name|CT_UnorderedMap
block|,
name|CT_UnorderedSet
block|,
name|CT_UnorderedMultiMap
block|,
name|CT_UnorderedMultiSet
block|}
enum|;
name|constexpr
name|bool
name|isSequential
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT_Vector
operator|>=
name|CT
operator|&&
name|CT_ForwardList
operator|<=
name|CT
return|;
block|}
name|constexpr
name|bool
name|isAssociative
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT_Map
operator|>=
name|CT
operator|&&
name|CT_MultiSet
operator|<=
name|CT
return|;
block|}
name|constexpr
name|bool
name|isUnordered
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT_UnorderedMap
operator|>=
name|CT
operator|&&
name|CT_UnorderedMultiSet
operator|<=
name|CT
return|;
block|}
name|constexpr
name|bool
name|isSet
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT
operator|==
name|CT_Set
operator|||
name|CT
operator|==
name|CT_MultiSet
operator|||
name|CT
operator|==
name|CT_UnorderedSet
operator|||
name|CT
operator|==
name|CT_UnorderedMultiSet
return|;
block|}
name|constexpr
name|bool
name|isMap
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT
operator|==
name|CT_Map
operator|||
name|CT
operator|==
name|CT_MultiMap
operator|||
name|CT
operator|==
name|CT_UnorderedMap
operator|||
name|CT
operator|==
name|CT_UnorderedMultiMap
return|;
block|}
name|constexpr
name|bool
name|isMulti
parameter_list|(
name|ContainerType
name|CT
parameter_list|)
block|{
return|return
name|CT
operator|==
name|CT_MultiMap
operator|||
name|CT
operator|==
name|CT_MultiSet
operator|||
name|CT
operator|==
name|CT_UnorderedMultiMap
operator|||
name|CT
operator|==
name|CT_UnorderedMultiSet
return|;
block|}
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|ValueType
operator|=
name|typename
name|Container
operator|::
name|value_type
operator|>
expr|struct
name|ContainerDebugHelper
block|{
name|static_assert
argument_list|(
name|std
operator|::
name|is_constructible
operator|<
name|ValueType
argument_list|,
name|int
operator|>
operator|::
name|value
argument_list|,
literal|"must be constructible from int"
argument_list|)
block|;
specifier|static
name|ValueType
name|makeValueType
argument_list|(
argument|int val =
literal|0
argument_list|,
argument|int =
literal|0
argument_list|)
block|{
return|return
name|ValueType
argument_list|(
name|val
argument_list|)
return|;
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Container
operator|>
expr|struct
name|ContainerDebugHelper
operator|<
name|Container
operator|,
name|char
operator|>
block|{
specifier|static
name|char
name|makeValueType
argument_list|(
argument|int =
literal|0
argument_list|,
argument|int =
literal|0
argument_list|)
block|{
return|return
literal|'A'
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|Key
operator|,
name|class
name|Value
operator|>
expr|struct
name|ContainerDebugHelper
operator|<
name|Container
operator|,
name|std
operator|::
name|pair
operator|<
specifier|const
name|Key
operator|,
name|Value
operator|>
expr|>
block|{
name|using
name|ValueType
operator|=
name|std
operator|::
name|pair
operator|<
specifier|const
name|Key
block|,
name|Value
operator|>
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_constructible
operator|<
name|Key
argument_list|,
name|int
operator|>
operator|::
name|value
argument_list|,
literal|"must be constructible from int"
argument_list|)
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_constructible
operator|<
name|Value
argument_list|,
name|int
operator|>
operator|::
name|value
argument_list|,
literal|"must be constructible from int"
argument_list|)
block|;
specifier|static
name|ValueType
name|makeValueType
argument_list|(
argument|int key =
literal|0
argument_list|,
argument|int val =
literal|0
argument_list|)
block|{
return|return
name|ValueType
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Container
operator|,
name|ContainerType
name|CT
operator|,
name|class
name|Helper
operator|=
name|ContainerDebugHelper
operator|<
name|Container
operator|>
expr|> struct
name|BasicContainerChecks
block|{
name|using
name|value_type
operator|=
name|typename
name|Container
operator|::
name|value_type
block|;
name|using
name|iterator
operator|=
name|typename
name|Container
operator|::
name|iterator
block|;
name|using
name|const_iterator
operator|=
name|typename
name|Container
operator|::
name|const_iterator
block|;
name|using
name|allocator_type
operator|=
name|typename
name|Container
operator|::
name|allocator_type
block|;
name|using
name|traits
operator|=
name|std
operator|::
name|iterator_traits
operator|<
name|iterator
operator|>
block|;
name|using
name|category
operator|=
name|typename
name|traits
operator|::
name|iterator_category
block|;
name|static_assert
argument_list|(
name|std
operator|::
name|is_same
operator|<
name|test_allocator
operator|<
name|value_type
operator|>
argument_list|,
name|allocator_type
operator|>
operator|::
name|value
argument_list|,
literal|"the container must use a test allocator"
argument_list|)
block|;
specifier|static
name|constexpr
name|bool
name|IsBiDir
operator|=
name|std
operator|::
name|is_convertible
operator|<
name|category
block|,
name|std
operator|::
name|bidirectional_iterator_tag
operator|>
operator|::
name|value
block|;
name|public
operator|:
specifier|static
name|void
name|run
argument_list|()
block|{
name|run_iterator_tests
argument_list|()
block|;
name|run_container_tests
argument_list|()
block|;
name|run_allocator_aware_tests
argument_list|()
block|;   }
specifier|static
name|void
name|run_iterator_tests
argument_list|()
block|{
name|try
block|{
name|TestNullIterators
operator|<
name|iterator
operator|>
operator|(
operator|)
block|;
name|TestNullIterators
operator|<
name|const_iterator
operator|>
operator|(
operator|)
block|;
if|if constexpr
condition|(
name|IsBiDir
condition|)
block|{
name|DecrementBegin
argument_list|()
expr_stmt|;
block|}
name|IncrementEnd
argument_list|()
block|;
name|DerefEndIterator
argument_list|()
block|;     }
name|catch
argument_list|(
argument|...
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"uncaught debug exception"
argument_list|)
block|;     }
block|}
specifier|static
name|void
name|run_container_tests
argument_list|()
block|{
name|try
block|{
name|CopyInvalidatesIterators
argument_list|()
block|;
name|MoveInvalidatesIterators
argument_list|()
block|;
if|if constexpr
condition|(
name|CT
operator|!=
name|CT_ForwardList
condition|)
block|{
name|EraseIter
argument_list|()
expr_stmt|;
name|EraseIterIter
argument_list|()
expr_stmt|;
block|}
block|}
name|catch
argument_list|(
argument|...
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"uncaught debug exception"
argument_list|)
block|;     }
end_expr_stmt

begin_function
unit|}    static
name|void
name|run_allocator_aware_tests
parameter_list|()
block|{
name|try
block|{
name|SwapNonEqualAllocators
argument_list|()
expr_stmt|;
if|if constexpr
condition|(
name|CT
operator|!=
name|CT_ForwardList
condition|)
block|{
name|SwapInvalidatesIterators
argument_list|()
expr_stmt|;
comment|// FIXME: This should work
block|}
block|}
name|catch
argument_list|(
argument|...
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"uncaught debug exception"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|Container
name|makeContainer
parameter_list|(
name|int
name|size
parameter_list|,
name|allocator_type
name|A
init|=
name|allocator_type
argument_list|()
parameter_list|)
block|{
name|Container
name|C
argument_list|(
name|A
argument_list|)
decl_stmt|;
if|if constexpr
condition|(
name|CT
operator|==
name|CT_ForwardList
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|C
operator|.
name|insert_after
argument_list|(
name|C
operator|.
name|before_begin
argument_list|()
argument_list|,
name|Helper
operator|::
name|makeValueType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|C
operator|.
name|insert
argument_list|(
name|C
operator|.
name|end
argument_list|()
argument_list|,
name|Helper
operator|::
name|makeValueType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|C
operator|.
name|size
argument_list|()
operator|==
name|static_cast
operator|<
name|std
operator|::
name|size_t
operator|>
operator|(
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|C
return|;
block|}
end_function

begin_function
specifier|static
name|value_type
name|makeValueType
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
name|Helper
operator|::
name|makeValueType
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|// Iterator tests
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Iter
operator|>
specifier|static
name|void
name|TestNullIterators
argument_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing null iterator"
argument_list|)
block|;
name|Iter
name|it
block|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|++
name|it
argument_list|)
block|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|it
operator|++
argument_list|)
block|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|it
argument_list|)
block|;
if|if constexpr
condition|(
name|CT
operator|!=
name|CT_VectorBool
condition|)
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
name|it
operator|.
name|operator
operator|->
expr|(
argument_list|)
block|)
empty_stmt|;
block|}
end_expr_stmt

begin_if
if|if constexpr
condition|(
name|IsBiDir
condition|)
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
operator|--
name|it
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|it
operator|--
argument_list|)
expr_stmt|;
block|}
end_if

begin_function
unit|}    static
name|void
name|DecrementBegin
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing decrement on begin"
argument_list|)
expr_stmt|;
name|Container
name|C
init|=
name|makeContainer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|iterator
name|i
init|=
name|C
operator|.
name|end
argument_list|()
decl_stmt|;
name|const_iterator
name|ci
init|=
name|C
operator|.
name|cend
argument_list|()
decl_stmt|;
operator|--
name|i
expr_stmt|;
operator|--
name|ci
expr_stmt|;
name|assert
argument_list|(
name|i
operator|==
name|C
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|--
name|i
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|i
operator|--
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|--
name|ci
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|ci
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|IncrementEnd
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing increment on end"
argument_list|)
expr_stmt|;
name|Container
name|C
init|=
name|makeContainer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|iterator
name|i
init|=
name|C
operator|.
name|begin
argument_list|()
decl_stmt|;
name|const_iterator
name|ci
init|=
name|C
operator|.
name|begin
argument_list|()
decl_stmt|;
operator|++
name|i
expr_stmt|;
operator|++
name|ci
expr_stmt|;
name|assert
argument_list|(
name|i
operator|==
name|C
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|++
name|i
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|++
name|ci
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|ci
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DerefEndIterator
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing deref end iterator"
argument_list|)
expr_stmt|;
name|Container
name|C
init|=
name|makeContainer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|iterator
name|i
init|=
name|C
operator|.
name|begin
argument_list|()
decl_stmt|;
name|const_iterator
name|ci
init|=
name|C
operator|.
name|cbegin
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
operator|*
name|i
expr_stmt|;
operator|(
name|void
operator|)
operator|*
name|ci
expr_stmt|;
if|if constexpr
condition|(
name|CT
operator|!=
name|CT_VectorBool
condition|)
block|{
name|i
operator|.
name|operator
operator|->
expr|(
block|)
empty_stmt|;
name|ci
operator|.
name|operator
operator|->
expr|(
block|)
function|;
end_function

begin_expr_stmt
unit|}     ++
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|ci
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|assert
argument_list|(
name|i
operator|==
name|C
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|ci
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if constexpr
condition|(
name|CT
operator|!=
name|CT_VectorBool
condition|)
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
name|i
operator|.
name|operator
operator|->
expr|(
argument_list|)
block|)
empty_stmt|;
end_if

begin_expr_stmt
name|CHECK_DEBUG_THROWS
argument_list|(
name|ci
operator|.
name|operator
operator|->
expr|(
argument_list|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}   }
comment|// Container tests
end_comment

begin_function
specifier|static
name|void
name|CopyInvalidatesIterators
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"copy invalidates iterators"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|iterator
name|i
init|=
name|C1
operator|.
name|begin
argument_list|()
decl_stmt|;
name|Container
name|C2
init|=
name|C1
decl_stmt|;
if|if constexpr
condition|(
name|CT
operator|==
name|CT_ForwardList
condition|)
block|{
name|iterator
name|i_next
init|=
name|i
decl_stmt|;
operator|++
name|i_next
expr_stmt|;
operator|(
name|void
operator|)
operator|*
name|i_next
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase_after
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|C1
operator|.
name|erase_after
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|i_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
operator|*
name|i
expr_stmt|;
name|C1
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|MoveInvalidatesIterators
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"copy move invalidates iterators"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|iterator
name|i
init|=
name|C1
operator|.
name|begin
argument_list|()
decl_stmt|;
name|Container
name|C2
init|=
name|std
operator|::
name|move
argument_list|(
name|C1
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
operator|*
name|i
expr_stmt|;
if|if constexpr
condition|(
name|CT
operator|==
name|CT_ForwardList
condition|)
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase_after
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|C2
operator|.
name|erase_after
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|C2
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|EraseIter
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing erase invalidation"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|iterator
name|it1
init|=
name|C1
operator|.
name|begin
argument_list|()
decl_stmt|;
name|iterator
name|it1_next
init|=
name|it1
decl_stmt|;
operator|++
name|it1_next
expr_stmt|;
name|Container
name|C2
init|=
name|C1
decl_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
argument_list|)
expr_stmt|;
comment|// wrong container
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|C2
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// erase with end
name|C1
operator|.
name|erase
argument_list|(
name|it1_next
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase
argument_list|(
name|it1_next
argument_list|)
argument_list|)
expr_stmt|;
comment|// invalidated iterator
name|C1
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
argument_list|)
expr_stmt|;
comment|// invalidated iterator
block|}
end_function

begin_function
specifier|static
name|void
name|EraseIterIter
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing erase iter iter invalidation"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|iterator
name|it1
init|=
name|C1
operator|.
name|begin
argument_list|()
decl_stmt|;
name|iterator
name|it1_next
init|=
name|it1
decl_stmt|;
operator|++
name|it1_next
expr_stmt|;
name|Container
name|C2
init|=
name|C1
decl_stmt|;
name|iterator
name|it2
init|=
name|C2
operator|.
name|begin
argument_list|()
decl_stmt|;
name|iterator
name|it2_next
init|=
name|it2
decl_stmt|;
operator|++
name|it2_next
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|it1
argument_list|,
name|it1_next
argument_list|)
argument_list|)
expr_stmt|;
comment|// begin from wrong container
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|it1
argument_list|,
name|it2_next
argument_list|)
argument_list|)
expr_stmt|;
comment|// end   from wrong container
name|CHECK_DEBUG_THROWS
argument_list|(
name|C2
operator|.
name|erase
argument_list|(
name|it2
argument_list|,
name|it1_next
argument_list|)
argument_list|)
expr_stmt|;
comment|// both  from wrong container
name|C2
operator|.
name|erase
argument_list|(
name|it2
argument_list|,
name|it2_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Allocator aware tests
end_comment

begin_function
specifier|static
name|void
name|SwapInvalidatesIterators
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing swap invalidates iterators"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Container
name|C2
init|=
name|makeContainer
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|iterator
name|it1
init|=
name|C1
operator|.
name|begin
argument_list|()
decl_stmt|;
name|iterator
name|it2
init|=
name|C2
operator|.
name|begin
argument_list|()
decl_stmt|;
name|swap
argument_list|(
name|C1
argument_list|,
name|C2
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
argument_list|)
expr_stmt|;
name|C1
operator|.
name|erase
argument_list|(
name|it2
argument_list|)
expr_stmt|;
comment|//C2.erase(it1);
name|CHECK_DEBUG_THROWS
argument_list|(
name|C1
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SwapNonEqualAllocators
parameter_list|()
block|{
name|CHECKPOINT
argument_list|(
literal|"testing swap with non-equal allocators"
argument_list|)
expr_stmt|;
name|Container
name|C1
init|=
name|makeContainer
argument_list|(
literal|3
argument_list|,
name|allocator_type
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Container
name|C2
init|=
name|makeContainer
argument_list|(
literal|1
argument_list|,
name|allocator_type
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|Container
name|C3
init|=
name|makeContainer
argument_list|(
literal|2
argument_list|,
name|allocator_type
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|swap
argument_list|(
name|C2
argument_list|,
name|C3
argument_list|)
expr_stmt|;
name|CHECK_DEBUG_THROWS
argument_list|(
name|swap
argument_list|(
name|C1
argument_list|,
name|C2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|BasicContainerChecks
argument_list|()
operator|=
name|delete
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// namespace IteratorDebugChecks
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// TEST_SUPPORT_DEBUG_MODE_HELPER_H
end_comment

end_unit

