begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|TEST_ALLOCATOR_H
end_define

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<utility>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|"test_macros.h"
end_include

begin_expr_stmt
name|template
operator|<
name|class
name|Alloc
operator|>
specifier|inline
name|typename
name|std
operator|::
name|allocator_traits
operator|<
name|Alloc
operator|>
operator|::
name|size_type
name|alloc_max_size
argument_list|(
argument|Alloc const&a
argument_list|)
block|{
typedef|typedef
name|std
operator|::
name|allocator_traits
operator|<
name|Alloc
operator|>
name|AT
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|AT
operator|::
name|max_size
argument_list|(
name|a
argument_list|)
return|;
end_return

begin_macro
unit|}  class
name|test_alloc_base
end_macro

begin_block
block|{
name|protected
label|:
specifier|static
name|int
name|time_to_throw
decl_stmt|;
name|public
label|:
specifier|static
name|int
name|throw_after
decl_stmt|;
specifier|static
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|alloc_count
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|time_to_throw
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|alloc_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|throw_after
operator|=
name|INT_MAX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|test_allocator
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
comment|// participates in equality
name|int
name|id_
block|;
comment|// unique identifier, doesn't participate in equality
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|T
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
name|value_type
operator|>
operator|::
name|type
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
specifier|const
name|value_type
operator|>
operator|::
name|type
name|const_reference
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|test_allocator
argument_list|()
end_macro

begin_label
name|TEST_NOEXCEPT
label|:
end_label

begin_expr_stmt
name|data_
argument_list|(
literal|0
argument_list|)
operator|,
name|id_
argument_list|(
literal|0
argument_list|)
block|{
operator|++
name|count
block|;}
name|explicit
name|test_allocator
argument_list|(
argument|int i
argument_list|,
argument|int id =
literal|0
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|i
argument_list|)
operator|,
name|id_
argument_list|(
argument|id
argument_list|)
block|{
operator|++
name|count
block|;}
name|test_allocator
argument_list|(
argument|const test_allocator& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|a
operator|.
name|data_
argument_list|)
operator|,
name|id_
argument_list|(
argument|a.id_
argument_list|)
block|{
operator|++
name|count
block|;}
name|template
operator|<
name|class
name|U
operator|>
name|test_allocator
argument_list|(
argument|const test_allocator<U>& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|a
operator|.
name|data_
argument_list|)
operator|,
name|id_
argument_list|(
argument|a.id_
argument_list|)
block|{
operator|++
name|count
block|;}
operator|~
name|test_allocator
argument_list|()
name|TEST_NOEXCEPT
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
block|;
name|assert
argument_list|(
name|id_
operator|>=
literal|0
argument_list|)
block|;
operator|--
name|count
block|;
name|data_
operator|=
operator|-
literal|1
block|;
name|id_
operator|=
operator|-
literal|1
block|;     }
name|pointer
name|address
argument_list|(
argument|reference x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|x
argument_list|)
decl|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_decl_stmt

begin_function
name|pointer
name|allocate
parameter_list|(
name|size_type
name|n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_to_throw
operator|>=
name|throw_after
condition|)
block|{
ifndef|#
directive|ifndef
name|TEST_HAS_NO_EXCEPTIONS
name|throw
name|std
operator|::
name|bad_alloc
argument_list|()
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|terminate
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|++
name|time_to_throw
expr_stmt|;
operator|++
name|alloc_count
expr_stmt|;
return|return
operator|(
name|pointer
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|p
parameter_list|,
name|size_type
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|--
name|alloc_count
expr_stmt|;
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|TEST_NOEXCEPT
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|<
literal|11
end_if

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|p
parameter_list|,
specifier|const
name|T
modifier|&
name|val
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|static_cast<void*>(p)
argument_list|)
name|T
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
name|void
name|construct
argument_list|(
argument|pointer p
argument_list|,
argument|U&& val
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|static_cast<void*>(p)
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|U
operator|>
operator|(
name|val
operator|)
argument_list|)
block|;}
endif|#
directive|endif
name|void
name|destroy
argument_list|(
argument|pointer p
argument_list|)
block|{
name|p
operator|->
expr|~
name|T
argument_list|()
block|;}
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|get_data
argument_list|()
specifier|const
block|{
return|return
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|get_id
argument_list|()
specifier|const
block|{
return|return
name|id_
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|class
name|non_default_test_allocator
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|non_default_test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|T
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
name|value_type
operator|>
operator|::
name|type
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
specifier|const
name|value_type
operator|>
operator|::
name|type
name|const_reference
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|non_default_test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//    non_default_test_allocator() TEST_NOEXCEPT : data_(0) {++count;}
end_comment

begin_decl_stmt
name|explicit
name|non_default_test_allocator
argument_list|(
name|int
name|i
argument_list|)
name|TEST_NOEXCEPT
range|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{
operator|++
name|count
block|;}
name|non_default_test_allocator
argument_list|(
argument|const non_default_test_allocator& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
name|template
operator|<
name|class
name|U
operator|>
name|non_default_test_allocator
argument_list|(
argument|const non_default_test_allocator<U>& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
operator|~
name|non_default_test_allocator
argument_list|()
name|TEST_NOEXCEPT
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
block|;
operator|--
name|count
block|;
name|data_
operator|=
operator|-
literal|1
block|;}
name|pointer
name|address
argument_list|(
argument|reference x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|x
argument_list|)
decl|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_decl_stmt

begin_function
name|pointer
name|allocate
parameter_list|(
name|size_type
name|n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_to_throw
operator|>=
name|throw_after
condition|)
block|{
ifndef|#
directive|ifndef
name|TEST_HAS_NO_EXCEPTIONS
name|throw
name|std
operator|::
name|bad_alloc
argument_list|()
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|terminate
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|++
name|time_to_throw
expr_stmt|;
operator|++
name|alloc_count
expr_stmt|;
return|return
operator|(
name|pointer
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|p
parameter_list|,
name|size_type
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|--
name|alloc_count
expr_stmt|;
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|TEST_NOEXCEPT
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|<
literal|11
end_if

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|p
parameter_list|,
specifier|const
name|T
modifier|&
name|val
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|static_cast<void*>(p)
argument_list|)
name|T
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
name|void
name|construct
argument_list|(
argument|pointer p
argument_list|,
argument|U&& val
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|static_cast<void*>(p)
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|forward
operator|<
name|U
operator|>
operator|(
name|val
operator|)
argument_list|)
block|;}
endif|#
directive|endif
name|void
name|destroy
argument_list|(
argument|pointer p
argument_list|)
block|{
name|p
operator|->
expr|~
name|T
argument_list|()
block|;}
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|non_default_test_allocator
operator|&
name|x
operator|,
specifier|const
name|non_default_test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|non_default_test_allocator
operator|&
name|x
operator|,
specifier|const
name|non_default_test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
name|class
name|test_allocator
operator|<
name|void
operator|>
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
name|int
name|id_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|test_allocator
argument_list|()
end_macro

begin_label
name|TEST_NOEXCEPT
label|:
end_label

begin_expr_stmt
name|data_
argument_list|(
literal|0
argument_list|)
operator|,
name|id_
argument_list|(
literal|0
argument_list|)
block|{}
name|explicit
name|test_allocator
argument_list|(
argument|int i
argument_list|,
argument|int id =
literal|0
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|i
argument_list|)
operator|,
name|id_
argument_list|(
argument|id
argument_list|)
block|{}
name|test_allocator
argument_list|(
argument|const test_allocator& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|a
operator|.
name|data_
argument_list|)
operator|,
name|id_
argument_list|(
argument|a.id_
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|test_allocator
argument_list|(
argument|const test_allocator<U>& a
argument_list|)
name|TEST_NOEXCEPT
operator|:
name|data_
argument_list|(
name|a
operator|.
name|data_
argument_list|)
operator|,
name|id_
argument_list|(
argument|a.id_
argument_list|)
block|{}
operator|~
name|test_allocator
argument_list|()
name|TEST_NOEXCEPT
block|{
name|data_
operator|=
operator|-
literal|1
block|;
name|id_
operator|=
operator|-
literal|1
block|; }
name|int
name|get_id
argument_list|()
specifier|const
block|{
return|return
name|id_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|get_data
argument_list|()
specifier|const
block|{
return|return
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|class
name|other_allocator
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|other_allocator
block|;
name|public
operator|:
typedef|typedef
name|T
name|value_type
typedef|;
name|other_allocator
argument_list|()
operator|:
name|data_
argument_list|(
argument|-
literal|1
argument_list|)
block|{}
name|explicit
name|other_allocator
argument_list|(
argument|int i
argument_list|)
operator|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|other_allocator
argument_list|(
specifier|const
name|other_allocator
operator|<
name|U
operator|>
operator|&
name|a
argument_list|)
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{}
name|T
operator|*
name|allocate
argument_list|(
argument|std::size_t n
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|deallocate
argument_list|(
name|T
operator|*
name|p
argument_list|,
name|std
operator|::
name|size_t
argument_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|other_allocator
name|select_on_container_copy_construction
argument_list|()
specifier|const
block|{
return|return
name|other_allocator
argument_list|(
operator|-
literal|2
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|other_allocator
operator|&
name|x
operator|,
specifier|const
name|other_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|other_allocator
operator|&
name|x
operator|,
specifier|const
name|other_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_copy_assignment
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_move_assignment
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_swap
expr_stmt|;
end_typedef

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|<
literal|11
end_if

begin_expr_stmt
name|std
operator|::
name|size_t
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
unit|};
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
end_if

begin_struct
struct|struct
name|Ctor_Tag
block|{}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|TaggingAllocator
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|Tag_X
block|{
comment|// All constructors must be passed the Tag type.
comment|// DefaultInsertable into vector<X, TaggingAllocator<X>>,
name|Tag_X
argument_list|(
argument|Ctor_Tag
argument_list|)
block|{}
comment|// CopyInsertable into vector<X, TaggingAllocator<X>>,
name|Tag_X
argument_list|(
argument|Ctor_Tag
argument_list|,
argument|const Tag_X&
argument_list|)
block|{}
comment|// MoveInsertable into vector<X, TaggingAllocator<X>>, and
name|Tag_X
argument_list|(
argument|Ctor_Tag
argument_list|,
argument|Tag_X&&
argument_list|)
block|{}
comment|// EmplaceConstructible into vector<X, TaggingAllocator<X>> from args.
name|template
operator|<
name|typename
operator|...
name|Args
operator|>
name|Tag_X
argument_list|(
argument|Ctor_Tag
argument_list|,
argument|Args&&...
argument_list|)
block|{ }
comment|// not DefaultConstructible, CopyConstructible or MoveConstructible.
name|Tag_X
argument_list|()
operator|=
name|delete
expr_stmt|;
name|Tag_X
argument_list|(
specifier|const
name|Tag_X
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|Tag_X
argument_list|(
name|Tag_X
operator|&&
argument_list|)
operator|=
name|delete
expr_stmt|;
comment|// CopyAssignable.
name|Tag_X
modifier|&
name|operator
init|=
operator|(
specifier|const
name|Tag_X
operator|&
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
comment|// MoveAssignable.
name|Tag_X
modifier|&
name|operator
init|=
operator|(
name|Tag_X
operator|&&
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
name|private
label|:
comment|// Not Destructible.
operator|~
name|Tag_X
argument_list|()
block|{ }
comment|// Erasable from vector<X, TaggingAllocator<X>>.
name|friend
name|class
name|TaggingAllocator
operator|<
name|Tag_X
operator|>
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|TaggingAllocator
block|{
name|public
operator|:
name|using
name|value_type
operator|=
name|T
block|;
name|TaggingAllocator
argument_list|()
operator|=
expr|default
block|;
name|template
operator|<
name|typename
name|U
operator|>
name|TaggingAllocator
argument_list|(
argument|const TaggingAllocator<U>&
argument_list|)
block|{ }
name|T
operator|*
name|allocate
argument_list|(
argument|std::size_t n
argument_list|)
block|{
return|return
name|std
operator|::
name|allocator
operator|<
name|T
operator|>
block|{}
operator|.
name|allocate
argument_list|(
name|n
argument_list|)
return|;
block|}
name|void
name|deallocate
argument_list|(
argument|T* p
argument_list|,
argument|std::size_t n
argument_list|)
block|{
name|std
operator|::
name|allocator
operator|<
name|T
operator|>
block|{}
operator|.
name|deallocate
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
block|; }
name|template
operator|<
name|typename
operator|...
name|Args
operator|>
name|void
name|construct
argument_list|(
argument|Tag_X* p
argument_list|,
argument|Args&&... args
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|(void*)p
argument_list|)
name|Tag_X
argument_list|(
name|Ctor_Tag
block|{}
argument_list|,
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
block|; }
name|template
operator|<
name|typename
name|U
operator|,
name|typename
operator|...
name|Args
operator|>
name|void
name|construct
argument_list|(
argument|U* p
argument_list|,
argument|Args&&... args
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|(void*)p
argument_list|)
name|U
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|args
operator|)
operator|...
argument_list|)
block|; }
name|template
operator|<
name|typename
name|U
operator|,
name|typename
operator|...
name|Args
operator|>
name|void
name|destroy
argument_list|(
argument|U* p
argument_list|)
block|{
name|p
operator|->
expr|~
name|U
argument_list|()
block|; }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TaggingAllocator
operator|<
name|T
operator|>
operator|&
operator|,
specifier|const
name|TaggingAllocator
operator|<
name|U
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TaggingAllocator
operator|<
name|T
operator|>
operator|&
operator|,
specifier|const
name|TaggingAllocator
operator|<
name|U
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|std
operator|::
name|size_t
name|MaxAllocs
operator|>
expr|struct
name|limited_alloc_handle
block|{
name|std
operator|::
name|size_t
name|outstanding_
block|;
name|void
operator|*
name|last_alloc_
block|;
name|limited_alloc_handle
argument_list|()
operator|:
name|outstanding_
argument_list|(
literal|0
argument_list|)
block|,
name|last_alloc_
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|template
operator|<
name|class
name|T
operator|>
name|T
operator|*
name|allocate
argument_list|(
argument|std::size_t N
argument_list|)
block|{
if|if
condition|(
name|N
operator|+
name|outstanding_
operator|>
name|MaxAllocs
condition|)
name|TEST_THROW
argument_list|(
name|std
operator|::
name|bad_alloc
argument_list|()
argument_list|)
expr_stmt|;
name|last_alloc_
operator|=
operator|::
name|operator
name|new
argument_list|(
name|N
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
name|outstanding_
operator|+=
name|N
block|;
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|last_alloc_
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|deallocate
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|std
operator|::
name|size_t
name|N
argument_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|last_alloc_
condition|)
block|{
name|last_alloc_
operator|=
name|nullptr
expr_stmt|;
name|assert
argument_list|(
name|outstanding_
operator|>=
name|N
argument_list|)
expr_stmt|;
name|outstanding_
operator|-=
name|N
expr_stmt|;
block|}
operator|::
name|operator
name|delete
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|,
name|std
operator|::
name|size_t
name|N
operator|>
name|class
name|limited_allocator
block|{
name|template
operator|<
name|class
name|U
block|,
name|std
operator|::
name|size_t
name|UN
operator|>
name|friend
name|class
name|limited_allocator
block|;
typedef|typedef
name|limited_alloc_handle
operator|<
name|N
operator|>
name|BuffT
expr_stmt|;
name|std
operator|::
name|shared_ptr
operator|<
name|BuffT
operator|>
name|handle_
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|T
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|size_t
name|size_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|ptrdiff_t
name|difference_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|limited_allocator
operator|<
name|U
operator|,
name|N
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|limited_allocator
argument_list|()
operator|:
name|handle_
argument_list|(
argument|new BuffT
argument_list|)
block|{}
name|limited_allocator
argument_list|(
name|limited_allocator
specifier|const
operator|&
name|other
argument_list|)
operator|:
name|handle_
argument_list|(
argument|other.handle_
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|explicit
name|limited_allocator
argument_list|(
name|limited_allocator
operator|<
name|U
argument_list|,
name|N
operator|>
specifier|const
operator|&
name|other
argument_list|)
operator|:
name|handle_
argument_list|(
argument|other.handle_
argument_list|)
block|{}
name|private
operator|:
name|limited_allocator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|limited_allocator
operator|&
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// = delete;
end_comment

begin_label
name|public
label|:
end_label

begin_function
name|pointer
name|allocate
parameter_list|(
name|size_type
name|n
parameter_list|)
block|{
return|return
name|handle_
operator|->
name|template
name|allocate
operator|<
name|T
operator|>
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|p
parameter_list|,
name|size_type
name|n
parameter_list|)
block|{
name|handle_
operator|->
name|deallocate
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|N
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|BuffT
operator|*
name|getHandle
argument_list|()
specifier|const
block|{
return|return
name|handle_
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|,
name|std
operator|::
name|size_t
name|N
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
name|limited_allocator
operator|<
name|T
operator|,
name|N
operator|>
specifier|const
operator|&
name|LHS
operator|,
name|limited_allocator
operator|<
name|U
operator|,
name|N
operator|>
specifier|const
operator|&
name|RHS
operator|)
block|{
return|return
name|LHS
operator|.
name|getHandle
argument_list|()
operator|==
name|RHS
operator|.
name|getHandle
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|,
name|std
operator|::
name|size_t
name|N
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
name|limited_allocator
operator|<
name|T
operator|,
name|N
operator|>
specifier|const
operator|&
name|LHS
operator|,
name|limited_allocator
operator|<
name|U
operator|,
name|N
operator|>
specifier|const
operator|&
name|RHS
operator|)
block|{
return|return
operator|!
operator|(
name|LHS
operator|==
name|RHS
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// TEST_ALLOCATOR_H
end_comment

end_unit

