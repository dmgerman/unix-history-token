begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|TEST_ALLOCATOR_H
end_define

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<new>
end_include

begin_include
include|#
directive|include
file|<climits>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|"test_macros.h"
end_include

begin_decl_stmt
name|class
name|test_alloc_base
block|{
name|protected
label|:
specifier|static
name|int
name|time_to_throw
decl_stmt|;
name|public
label|:
specifier|static
name|int
name|throw_after
decl_stmt|;
specifier|static
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|alloc_count
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|time_to_throw
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|alloc_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|test_alloc_base
operator|::
name|throw_after
operator|=
name|INT_MAX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|test_allocator
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|T
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
name|value_type
operator|>
operator|::
name|type
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
specifier|const
name|value_type
operator|>
operator|::
name|type
name|const_reference
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|test_allocator
argument_list|()
end_macro

begin_expr_stmt
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
literal|0
argument_list|)
block|{
operator|++
name|count
block|;}
name|explicit
name|test_allocator
argument_list|(
argument|int i
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{
operator|++
name|count
block|;}
name|test_allocator
argument_list|(
argument|const test_allocator& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
name|template
operator|<
name|class
name|U
operator|>
name|test_allocator
argument_list|(
argument|const test_allocator<U>& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
operator|~
name|test_allocator
argument_list|()
name|throw
argument_list|()
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
block|;
operator|--
name|count
block|;
name|data_
operator|=
operator|-
literal|1
block|;}
name|pointer
name|address
argument_list|(
argument|reference x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|x
argument_list|)
decl|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_decl_stmt

begin_function
name|pointer
name|allocate
parameter_list|(
name|size_type
name|n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_to_throw
operator|>=
name|throw_after
condition|)
block|{
ifndef|#
directive|ifndef
name|_LIBCPP_NO_EXCEPTIONS
name|throw
name|std
operator|::
name|bad_alloc
argument_list|()
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|terminate
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|++
name|time_to_throw
expr_stmt|;
operator|++
name|alloc_count
expr_stmt|;
return|return
operator|(
name|pointer
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|p
parameter_list|,
name|size_type
name|n
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|--
name|alloc_count
expr_stmt|;
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|p
parameter_list|,
specifier|const
name|T
modifier|&
name|val
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|p
argument_list|)
name|T
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBCPP_HAS_NO_RVALUE_REFERENCES
end_ifndef

begin_decl_stmt
name|void
name|construct
argument_list|(
name|pointer
name|p
argument_list|,
name|T
operator|&&
name|val
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|p
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _LIBCPP_HAS_NO_RVALUE_REFERENCES
end_comment

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
name|p
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|class
name|non_default_test_allocator
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|non_default_test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|T
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
name|value_type
operator|>
operator|::
name|type
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|add_lvalue_reference
operator|<
specifier|const
name|value_type
operator|>
operator|::
name|type
name|const_reference
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|non_default_test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//    non_default_test_allocator() throw() : data_(0) {++count;}
end_comment

begin_macro
name|explicit
end_macro

begin_macro
name|non_default_test_allocator
argument_list|(
argument|int i
argument_list|)
end_macro

begin_expr_stmt
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{
operator|++
name|count
block|;}
name|non_default_test_allocator
argument_list|(
argument|const non_default_test_allocator& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
name|template
operator|<
name|class
name|U
operator|>
name|non_default_test_allocator
argument_list|(
argument|const non_default_test_allocator<U>& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{
operator|++
name|count
block|;}
operator|~
name|non_default_test_allocator
argument_list|()
name|throw
argument_list|()
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
block|;
operator|--
name|count
block|;
name|data_
operator|=
operator|-
literal|1
block|;}
name|pointer
name|address
argument_list|(
argument|reference x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|x
argument_list|)
decl|const
block|{
return|return
operator|&
name|x
return|;
block|}
end_decl_stmt

begin_function
name|pointer
name|allocate
parameter_list|(
name|size_type
name|n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_to_throw
operator|>=
name|throw_after
condition|)
block|{
ifndef|#
directive|ifndef
name|_LIBCPP_NO_EXCEPTIONS
name|throw
name|std
operator|::
name|bad_alloc
argument_list|()
expr_stmt|;
else|#
directive|else
name|std
operator|::
name|terminate
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|++
name|time_to_throw
expr_stmt|;
operator|++
name|alloc_count
expr_stmt|;
return|return
operator|(
name|pointer
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|p
parameter_list|,
name|size_type
name|n
parameter_list|)
block|{
name|assert
argument_list|(
name|data_
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|--
name|alloc_count
expr_stmt|;
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|p
parameter_list|,
specifier|const
name|T
modifier|&
name|val
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|p
argument_list|)
name|T
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBCPP_HAS_NO_RVALUE_REFERENCES
end_ifndef

begin_decl_stmt
name|void
name|construct
argument_list|(
name|pointer
name|p
argument_list|,
name|T
operator|&&
name|val
argument_list|)
block|{
operator|::
name|new
argument_list|(
argument|p
argument_list|)
name|T
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _LIBCPP_HAS_NO_RVALUE_REFERENCES
end_comment

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
name|p
operator|->
expr|~
name|T
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|non_default_test_allocator
operator|&
name|x
operator|,
specifier|const
name|non_default_test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|non_default_test_allocator
operator|&
name|x
operator|,
specifier|const
name|non_default_test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
name|class
name|test_allocator
operator|<
name|void
operator|>
operator|:
name|public
name|test_alloc_base
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|test_allocator
block|;
name|public
operator|:
typedef|typedef
name|unsigned
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|int
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|value_type
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|value_type
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|U
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|test_allocator
operator|<
name|U
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|test_allocator
argument_list|()
end_macro

begin_expr_stmt
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|-
literal|1
argument_list|)
block|{}
name|explicit
name|test_allocator
argument_list|(
argument|int i
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{}
name|test_allocator
argument_list|(
argument|const test_allocator& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|test_allocator
argument_list|(
argument|const test_allocator<U>& a
argument_list|)
name|throw
argument_list|()
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{}
operator|~
name|test_allocator
argument_list|()
name|throw
argument_list|()
block|{
name|data_
operator|=
literal|0
block|;}
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|test_allocator
operator|&
name|x
operator|,
specifier|const
name|test_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|class
name|other_allocator
block|{
name|int
name|data_
block|;
name|template
operator|<
name|class
name|U
operator|>
name|friend
name|class
name|other_allocator
block|;
name|public
operator|:
typedef|typedef
name|T
name|value_type
typedef|;
name|other_allocator
argument_list|()
operator|:
name|data_
argument_list|(
argument|-
literal|1
argument_list|)
block|{}
name|explicit
name|other_allocator
argument_list|(
argument|int i
argument_list|)
operator|:
name|data_
argument_list|(
argument|i
argument_list|)
block|{}
name|template
operator|<
name|class
name|U
operator|>
name|other_allocator
argument_list|(
specifier|const
name|other_allocator
operator|<
name|U
operator|>
operator|&
name|a
argument_list|)
operator|:
name|data_
argument_list|(
argument|a.data_
argument_list|)
block|{}
name|T
operator|*
name|allocate
argument_list|(
argument|std::size_t n
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
operator|::
name|operator
name|new
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|deallocate
argument_list|(
name|T
operator|*
name|p
argument_list|,
name|std
operator|::
name|size_t
name|n
argument_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|other_allocator
name|select_on_container_copy_construction
argument_list|()
specifier|const
block|{
return|return
name|other_allocator
argument_list|(
operator|-
literal|2
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
operator|(
specifier|const
name|other_allocator
operator|&
name|x
operator|,
specifier|const
name|other_allocator
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|data_
operator|==
name|y
operator|.
name|data_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|other_allocator
operator|&
name|x
operator|,
specifier|const
name|other_allocator
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_copy_assignment
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_move_assignment
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|true_type
name|propagate_on_container_swap
expr_stmt|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBCPP_HAS_NO_ADVANCED_SFINAE
end_ifdef

begin_expr_stmt
name|std
operator|::
name|size_t
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|UINT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _LIBCPP_HAS_NO_ADVANCED_SFINAE
end_comment

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|// TEST_ALLOCATOR_H
end_comment

end_unit

