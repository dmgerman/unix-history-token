begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_SUPPORT_UNIQUE_PTR_TEST_HELPER_H
end_ifndef

begin_define
define|#
directive|define
name|TEST_SUPPORT_UNIQUE_PTR_TEST_HELPER_H
end_define

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|"test_macros.h"
end_include

begin_include
include|#
directive|include
file|"deleter_types.h"
end_include

begin_struct
struct|struct
name|A
block|{
specifier|static
name|int
name|count
decl_stmt|;
name|A
argument_list|()
block|{
operator|++
name|count
expr_stmt|;
block|}
name|A
argument_list|(
argument|const A&
argument_list|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|virtual
operator|~
name|A
argument_list|()
block|{
operator|--
name|count
block|; }
block|}
struct|;
end_struct

begin_expr_stmt
name|int
name|A
operator|::
name|count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|B
range|:
name|public
name|A
block|{
specifier|static
name|int
name|count
block|;
name|B
argument_list|()
block|{
operator|++
name|count
block|; }
name|B
argument_list|(
argument|const B&
argument_list|)
block|{
operator|++
name|count
block|; }
name|virtual
operator|~
name|B
argument_list|()
block|{
operator|--
name|count
block|; }
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|B
operator|::
name|count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
operator|!
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|T
operator|*
operator|>
operator|::
name|type
name|newValue
argument_list|(
argument|int num_elements
argument_list|)
block|{
name|assert
argument_list|(
name|num_elements
operator|==
literal|1
argument_list|)
block|;
return|return
name|new
name|T
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|std
operator|::
name|enable_if
operator|<
name|std
operator|::
name|is_array
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|typename
name|std
operator|::
name|remove_all_extents
operator|<
name|T
operator|>
operator|::
name|type
operator|*
operator|>
operator|::
name|type
name|newValue
argument_list|(
argument|int num_elements
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|remove_all_extents
operator|<
name|T
operator|>
operator|::
name|type
name|VT
expr_stmt|;
name|assert
argument_list|(
name|num_elements
operator|>=
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|new
name|VT
index|[
name|num_elements
index|]
return|;
end_return

begin_expr_stmt
unit|}  struct
name|IncompleteType
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|checkNumIncompleteTypeAlive
parameter_list|(
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|getNumIncompleteTypeAlive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IncompleteType
modifier|*
name|getNewIncomplete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IncompleteType
modifier|*
name|getNewIncompleteArray
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
end_if

begin_expr_stmt
name|template
operator|<
name|class
name|ThisT
operator|,
name|class
operator|...
name|Args
operator|>
expr|struct
name|args_is_this_type
operator|:
name|std
operator|::
name|false_type
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ThisT
operator|,
name|class
name|A1
operator|>
expr|struct
name|args_is_this_type
operator|<
name|ThisT
operator|,
name|A1
operator|>
operator|:
name|std
operator|::
name|is_same
operator|<
name|ThisT
operator|,
name|typename
name|std
operator|::
name|decay
operator|<
name|A1
operator|>
operator|::
name|type
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|IncompleteT
operator|=
name|IncompleteType
operator|,
name|class
name|Del
operator|=
name|std
operator|::
name|default_delete
operator|<
name|IncompleteT
operator|>
expr|> struct
name|StoresIncomplete
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|IncompleteT
operator|,
name|IncompleteType
operator|>
operator|::
name|value
operator|||
name|std
operator|::
name|is_same
operator|<
name|IncompleteT
operator|,
name|IncompleteType
index|[]
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|IncompleteT
block|,
name|Del
operator|>
name|m_ptr
block|;
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
name|StoresIncomplete
argument_list|(
name|StoresIncomplete
specifier|const
operator|&
argument_list|)
operator|=
name|delete
block|;
name|StoresIncomplete
argument_list|(
name|StoresIncomplete
operator|&&
argument_list|)
operator|=
expr|default
block|;
name|template
operator|<
name|class
operator|...
name|Args
operator|>
name|StoresIncomplete
argument_list|(
name|Args
operator|&&
operator|...
name|args
argument_list|)
operator|:
name|m_ptr
argument_list|(
argument|std::forward<Args>(args)...
argument_list|)
block|{
name|static_assert
argument_list|(
operator|!
name|args_is_this_type
operator|<
name|StoresIncomplete
argument_list|,
name|Args
operator|...
operator|>
operator|::
name|value
argument_list|,
literal|""
argument_list|)
block|;   }
else|#
directive|else
name|private
operator|:
name|StoresIncomplete
argument_list|()
block|;
name|StoresIncomplete
argument_list|(
name|StoresIncomplete
specifier|const
operator|&
argument_list|)
block|;
name|public
operator|:
endif|#
directive|endif
operator|~
name|StoresIncomplete
argument_list|()
block|;
name|IncompleteType
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|m_ptr
operator|.
name|get
argument_list|()
return|;
block|}
name|Del
operator|&
name|get_deleter
argument_list|()
block|{
return|return
name|m_ptr
operator|.
name|get_deleter
argument_list|()
return|;
block|}
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
end_if

begin_expr_stmt
name|template
operator|<
name|class
name|IncompleteT
operator|=
name|IncompleteType
operator|,
name|class
name|Del
operator|=
name|std
operator|::
name|default_delete
operator|<
name|IncompleteT
operator|>
operator|,
name|class
operator|...
name|Args
operator|>
name|void
name|doIncompleteTypeTest
argument_list|(
argument|int expect_alive
argument_list|,
argument|Args&&... ctor_args
argument_list|)
block|{
name|using
name|ValueT
operator|=
name|typename
name|std
operator|::
name|remove_all_extents
operator|<
name|IncompleteT
operator|>
operator|::
name|type
block|;
name|checkNumIncompleteTypeAlive
argument_list|(
name|expect_alive
argument_list|)
block|;
block|{
name|StoresIncomplete
operator|<
name|IncompleteT
block|,
name|Del
operator|>
name|sptr
argument_list|(
name|std
operator|::
name|forward
operator|<
name|Args
operator|>
operator|(
name|ctor_args
operator|)
operator|...
argument_list|)
block|;
name|checkNumIncompleteTypeAlive
argument_list|(
name|expect_alive
argument_list|)
block|;
if|if
condition|(
name|expect_alive
operator|==
literal|0
condition|)
name|assert
argument_list|(
name|sptr
operator|.
name|get
argument_list|()
operator|==
name|nullptr
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|sptr
operator|.
name|get
argument_list|()
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
block|}
name|checkNumIncompleteTypeAlive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INCOMPLETE_TEST_EPILOGUE
parameter_list|()
define|\
value|int is_incomplete_test_anchor = is_incomplete_test();                        \                                                                                \   struct IncompleteType {                                                      \     static int count;                                                          \     IncompleteType() { ++count; }                                              \     ~IncompleteType() { --count; }                                             \   };                                                                           \                                                                                \   int IncompleteType::count = 0;                                               \                                                                                \   void checkNumIncompleteTypeAlive(int i) {                                    \     assert(IncompleteType::count == i);                                        \   }                                                                            \   int getNumIncompleteTypeAlive() { return IncompleteType::count; }            \   IncompleteType* getNewIncomplete() { return new IncompleteType; }            \   IncompleteType* getNewIncompleteArray(int size) {                            \     return new IncompleteType[size];                                           \   }                                                                            \                                                                                \   template<class IncompleteT, class Del>                                      \   StoresIncomplete<IncompleteT, Del>::~StoresIncomplete() {}
end_define

begin_empty
empty|#
end_empty

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|push
end_pragma

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wvariadic-macros"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
end_if

begin_define
define|#
directive|define
name|DEFINE_AND_RUN_IS_INCOMPLETE_TEST
parameter_list|(
modifier|...
parameter_list|)
define|\
value|static int is_incomplete_test() { __VA_ARGS__ return 0; }                    \   INCOMPLETE_TEST_EPILOGUE()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFINE_AND_RUN_IS_INCOMPLETE_TEST
parameter_list|(
modifier|...
parameter_list|)
define|\
value|static int is_incomplete_test() { return 0; }                                \   INCOMPLETE_TEST_EPILOGUE()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|pop
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// TEST_SUPPORT_UNIQUE_PTR_TEST_HELPER_H
end_comment

end_unit

