begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 2006-2012,2013 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * $Id: movewindow.c,v 1.39 2013/05/04 19:41:02 tom Exp $  *  * Demonstrate move functions for windows and derived windows from the curses  * library.  *  * Author: Thomas E. Dickey  */
end_comment

begin_comment
comment|/* derwin mvderwin subwin mvwin  TODO:     add command to reset subwindow's origin to coincide with parent.     add command to delete subwindow (check if it has subwindows though)  */
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_XCURSES
end_ifdef

begin_undef
undef|#
directive|undef
name|derwin
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_VERSION
end_ifdef

begin_define
define|#
directive|define
name|CONST_FMT
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONST_FMT
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|LINE_MAX
end_undef

begin_define
define|#
directive|define
name|LINE_MIN
value|2
end_define

begin_define
define|#
directive|define
name|LINE_MAX
value|(LINES - 2)
end_define

begin_define
define|#
directive|define
name|COL_MIN
value|2
end_define

begin_define
define|#
directive|define
name|COL_MAX
value|(COLS - 2)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|}
name|PAIR
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|WINDOW
modifier|*
name|parent
decl_stmt|;
comment|/* need this since WINDOW->_parent is not portable */
name|WINDOW
modifier|*
name|child
decl_stmt|;
comment|/* the actual value */
block|}
name|FRAME
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|head_line
parameter_list|(
name|CONST_FMT
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|GCC_PRINTFLIKE
parameter_list|(
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|tail_line
parameter_list|(
name|CONST_FMT
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|GCC_PRINTFLIKE
parameter_list|(
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|num_windows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRAME
modifier|*
name|all_windows
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|failed
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|message
parameter_list|(
name|int
name|lineno
parameter_list|,
name|CONST_FMT
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|argp
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_XCURSES
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|vwprintw
argument_list|(
name|stdscr
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|head_line
parameter_list|(
name|CONST_FMT
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|0
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tail_line
parameter_list|(
name|CONST_FMT
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Arrow keys move cursor, return location at current on non-arrow key.  */
end_comment

begin_function
specifier|static
name|PAIR
modifier|*
name|selectcell
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|WINDOW
modifier|*
name|child
parameter_list|,
name|int
name|uli
parameter_list|,
name|int
name|ulj
parameter_list|,
name|int
name|lri
parameter_list|,
name|int
name|lrj
parameter_list|,
name|bool
name|relative
parameter_list|,
name|bool
modifier|*
name|more
parameter_list|)
block|{
specifier|static
name|PAIR
name|res
decl_stmt|;
comment|/* result cell */
name|int
name|si
init|=
name|lri
operator|-
name|uli
operator|+
literal|1
decl_stmt|;
comment|/* depth of the select area */
name|int
name|sj
init|=
name|lrj
operator|-
name|ulj
operator|+
literal|1
decl_stmt|;
comment|/* width of the select area */
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* offsets into the select area */
name|res
operator|.
name|y
operator|=
name|uli
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
expr_stmt|;
if|if
condition|(
name|child
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|relative
condition|)
block|{
name|getparyx
argument_list|(
name|child
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getbegyx
argument_list|(
name|child
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|i
operator|-=
name|uli
operator|+
name|getbegy
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|j
operator|-=
name|ulj
operator|+
name|getbegx
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|more
condition|)
operator|*
name|more
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|moved
init|=
name|FALSE
decl_stmt|;
name|tail_line
argument_list|(
literal|"Upper left [%2d,%2d] Lower right [%2d,%2d] -> %d,%d -> %d,%d"
argument_list|,
name|uli
argument_list|,
name|ulj
argument_list|,
name|lri
argument_list|,
name|lrj
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|parent
argument_list|,
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wgetch
argument_list|(
name|parent
argument_list|)
condition|)
block|{
case|case
name|KEY_UP
case|:
name|i
operator|+=
name|si
operator|-
literal|1
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|i
operator|++
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|j
operator|+=
name|sj
operator|-
literal|1
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|j
operator|++
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|QUIT
case|:
case|case
name|ESCAPE
case|:
return|return
operator|(
operator|(
name|PAIR
operator|*
operator|)
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
case|case
name|KEY_MOUSE
case|:
block|{
name|MEVENT
name|event
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|y
operator|>
name|uli
operator|&&
name|event
operator|.
name|x
operator|>
name|ulj
condition|)
block|{
if|if
condition|(
name|parent
operator|!=
name|stdscr
condition|)
block|{
name|i
operator|=
name|event
operator|.
name|y
operator|-
name|getbegy
argument_list|(
name|parent
argument_list|)
operator|-
name|uli
expr_stmt|;
name|j
operator|=
name|event
operator|.
name|x
operator|-
name|getbegx
argument_list|(
name|parent
argument_list|)
operator|-
name|ulj
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|event
operator|.
name|y
operator|-
name|uli
expr_stmt|;
name|j
operator|=
name|event
operator|.
name|x
operator|-
name|ulj
expr_stmt|;
block|}
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHRU */
endif|#
directive|endif
default|default:
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
if|if
condition|(
name|si
operator|<=
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|%=
name|si
expr_stmt|;
if|if
condition|(
name|sj
operator|<=
literal|0
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|%=
name|sj
expr_stmt|;
comment|/* 	 * If the caller can handle continuous movement, return the result. 	 */
if|if
condition|(
name|moved
operator|&&
name|more
condition|)
block|{
operator|*
name|more
operator|=
name|TRUE
expr_stmt|;
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Ask user for a window definition.  */
end_comment

begin_function
specifier|static
name|bool
name|getwindow
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|PAIR
modifier|*
name|ul
parameter_list|,
name|PAIR
modifier|*
name|lr
parameter_list|)
block|{
name|int
name|min_col
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
condition|?
name|COL_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_col
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
condition|?
name|COL_MAX
else|:
name|getmaxx
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|int
name|min_line
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
condition|?
name|LINE_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_line
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
condition|?
name|LINE_MAX
else|:
name|getmaxy
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|PAIR
modifier|*
name|tmp
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|head_line
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|min_line
argument_list|,
name|min_col
argument_list|,
name|max_line
argument_list|,
name|max_col
argument_list|,
name|FALSE
argument_list|,
operator|(
name|bool
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ul
operator|=
operator|*
name|tmp
expr_stmt|;
name|MvWAddCh
argument_list|(
name|parent
argument_list|,
name|ul
operator|->
name|y
argument_list|,
name|ul
operator|->
name|x
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|head_line
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|ul
operator|->
name|y
argument_list|,
name|ul
operator|->
name|x
argument_list|,
name|max_line
argument_list|,
name|max_col
argument_list|,
name|FALSE
argument_list|,
operator|(
name|bool
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|lr
operator|=
operator|*
name|tmp
expr_stmt|;
name|MvWAddCh
argument_list|(
name|parent
argument_list|,
name|lr
operator|->
name|y
argument_list|,
name|lr
operator|->
name|x
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|parent
argument_list|,
name|lr
operator|->
name|y
argument_list|,
name|lr
operator|->
name|x
argument_list|)
expr_stmt|;
name|wsyncdown
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|lr
operator|->
name|y
operator|!=
name|ul
operator|->
name|y
operator|&&
name|lr
operator|->
name|x
operator|!=
name|ul
operator|->
name|x
operator|)
expr_stmt|;
block|}
block|}
name|head_line
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Draw a box inside the given window.  */
end_comment

begin_function
specifier|static
name|void
name|box_inside
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|MvWHLine
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ACS_HLINE
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|MvWHLine
argument_list|(
name|win
argument_list|,
name|y1
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|ACS_HLINE
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|MvWVLine
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ACS_VLINE
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|MvWVLine
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|x1
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|MvWAddCh
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|MvWAddCh
argument_list|(
name|win
argument_list|,
name|y1
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|MvWAddCh
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|x1
operator|-
literal|1
argument_list|,
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|MvWAddCh
argument_list|(
name|win
argument_list|,
name|y1
operator|-
literal|1
argument_list|,
name|x1
operator|-
literal|1
argument_list|,
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
name|wsyncdown
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a window to our list.  */
end_comment

begin_function
specifier|static
name|void
name|add_window
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|WINDOW
modifier|*
name|child
parameter_list|)
block|{
specifier|static
name|unsigned
name|have
init|=
literal|0
decl_stmt|;
name|unsigned
name|need
init|=
operator|(
operator|(
name|num_windows
operator|+
literal|1
operator|)
operator||
literal|31
operator|)
operator|+
literal|1
decl_stmt|;
name|keypad
argument_list|(
name|child
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|need
operator|>
name|have
condition|)
block|{
name|all_windows
operator|=
name|typeRealloc
argument_list|(
name|FRAME
argument_list|,
name|need
argument_list|,
name|all_windows
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_windows
condition|)
name|failed
argument_list|(
literal|"add_window"
argument_list|)
expr_stmt|;
block|}
name|all_windows
index|[
name|num_windows
index|]
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|all_windows
index|[
name|num_windows
index|]
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|num_windows
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|window2num
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|num_windows
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|win
operator|==
name|all_windows
index|[
name|n
index|]
operator|.
name|child
condition|)
block|{
name|result
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|parent_of
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
name|window2num
argument_list|(
name|win
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|result
operator|=
name|all_windows
index|[
name|n
index|]
operator|.
name|parent
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|repaint_one
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|touchwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|refresh_all
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_windows
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|all_windows
index|[
name|n
index|]
operator|.
name|child
operator|!=
name|win
condition|)
block|{
name|repaint_one
argument_list|(
name|all_windows
index|[
name|n
index|]
operator|.
name|child
argument_list|)
expr_stmt|;
block|}
block|}
name|repaint_one
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|next_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|result
init|=
name|win
decl_stmt|;
name|int
name|n
init|=
name|window2num
argument_list|(
name|win
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|++
operator|>=
literal|0
condition|)
block|{
name|result
operator|=
name|all_windows
index|[
operator|(
name|unsigned
operator|)
name|n
operator|%
name|num_windows
index|]
operator|.
name|child
expr_stmt|;
name|wmove
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|prev_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|result
init|=
name|win
decl_stmt|;
name|int
name|n
init|=
name|window2num
argument_list|(
name|win
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|--
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|num_windows
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|all_windows
index|[
operator|(
name|unsigned
operator|)
name|n
operator|%
name|num_windows
index|]
operator|.
name|child
expr_stmt|;
name|wmove
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recur_move_window
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dx
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_windows
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|all_windows
index|[
name|n
index|]
operator|.
name|parent
operator|==
name|parent
condition|)
block|{
name|mvwin
argument_list|(
name|all_windows
index|[
name|n
index|]
operator|.
name|child
argument_list|,
name|dy
argument_list|,
name|dx
argument_list|)
expr_stmt|;
name|recur_move_window
argument_list|(
name|all_windows
index|[
name|n
index|]
operator|.
name|child
argument_list|,
name|dy
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * test mvwin().  */
end_comment

begin_function
specifier|static
name|bool
name|move_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|bool
name|recur
parameter_list|)
block|{
name|WINDOW
modifier|*
name|parent
init|=
name|parent_of
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|0
condition|)
block|{
name|bool
name|top
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
decl_stmt|;
name|int
name|min_col
init|=
name|top
condition|?
name|COL_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_col
init|=
name|top
condition|?
name|COL_MAX
else|:
name|getmaxx
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|int
name|min_line
init|=
name|top
condition|?
name|LINE_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_line
init|=
name|top
condition|?
name|LINE_MAX
else|:
name|getmaxy
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|PAIR
modifier|*
name|tmp
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|head_line
argument_list|(
literal|"Select new position for %swindow"
argument_list|,
name|top
condition|?
literal|""
else|:
literal|"sub"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|parent
argument_list|,
name|win
argument_list|,
name|min_line
argument_list|,
name|min_col
argument_list|,
name|max_line
argument_list|,
name|max_col
argument_list|,
name|FALSE
argument_list|,
operator|&
name|more
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|;
name|getbegyx
argument_list|(
name|parent
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
comment|/* 	     * Moving a subwindow has the effect of moving a viewport around 	     * the screen.  The parent window retains the contents of the 	     * subwindow in the original location, but the viewport will show 	     * the contents (again) at the new location.  So it will look odd 	     * when testing. 	     */
if|if
condition|(
name|mvwin
argument_list|(
name|win
argument_list|,
name|y0
operator|+
name|tmp
operator|->
name|y
argument_list|,
name|x0
operator|+
name|tmp
operator|->
name|x
argument_list|)
operator|!=
name|ERR
condition|)
block|{
if|if
condition|(
name|recur
condition|)
block|{
name|recur_move_window
argument_list|(
name|win
argument_list|,
name|tmp
operator|->
name|y
argument_list|,
name|tmp
operator|->
name|x
argument_list|)
expr_stmt|;
block|}
name|refresh_all
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|more
condition|)
break|break;
block|}
block|}
name|head_line
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_derwin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|pary
decl_stmt|,
name|parx
decl_stmt|,
name|maxy
decl_stmt|,
name|maxx
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|maxy
argument_list|,
name|maxx
argument_list|)
expr_stmt|;
name|getparyx
argument_list|(
name|win
argument_list|,
name|pary
argument_list|,
name|parx
argument_list|)
expr_stmt|;
name|head_line
argument_list|(
literal|"Select new position for derived window at %d,%d (%d,%d)"
argument_list|,
name|pary
argument_list|,
name|parx
argument_list|,
name|maxy
argument_list|,
name|maxx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * test mvderwin().  */
end_comment

begin_function
specifier|static
name|bool
name|move_derwin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|parent
init|=
name|parent_of
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|0
condition|)
block|{
name|bool
name|top
init|=
operator|(
name|parent
operator|==
name|stdscr
operator|)
decl_stmt|;
name|int
name|min_col
init|=
name|top
condition|?
name|COL_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_col
init|=
name|top
condition|?
name|COL_MAX
else|:
name|getmaxx
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|int
name|min_line
init|=
name|top
condition|?
name|LINE_MIN
else|:
literal|0
decl_stmt|;
name|int
name|max_line
init|=
name|top
condition|?
name|LINE_MAX
else|:
name|getmaxy
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|PAIR
modifier|*
name|tmp
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|show_derwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|parent
argument_list|,
name|win
argument_list|,
name|min_line
argument_list|,
name|min_col
argument_list|,
name|max_line
argument_list|,
name|max_col
argument_list|,
name|TRUE
argument_list|,
operator|&
name|more
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mvderwin
argument_list|(
name|win
argument_list|,
name|tmp
operator|->
name|y
argument_list|,
name|tmp
operator|->
name|x
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|refresh_all
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
name|repaint_one
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
name|show_derwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flash
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|more
condition|)
break|break;
block|}
block|}
name|head_line
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|chtype
name|ch
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
operator|++
name|x
control|)
block|{
name|MvWAddCh
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|wsyncdown
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_with_pattern
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|int
name|ch
init|=
literal|'a'
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
operator|++
name|x
control|)
block|{
name|MvWAddCh
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
operator|(
name|chtype
operator|)
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ch
operator|>
literal|'z'
condition|)
name|ch
operator|=
literal|'a'
expr_stmt|;
block|}
block|}
name|wsyncdown
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|lines_of
parameter_list|(
name|ul
parameter_list|,
name|lr
parameter_list|)
value|(lr.y - ul.y + 1)
end_define

begin_define
define|#
directive|define
name|cols_of
parameter_list|(
name|ul
parameter_list|,
name|lr
parameter_list|)
value|(lr.x - ul.x + 1)
end_define

begin_define
define|#
directive|define
name|pair_of
parameter_list|(
name|ul
parameter_list|)
value|ul.y, ul.x
end_define

begin_function
specifier|static
name|WINDOW
modifier|*
name|create_my_window
parameter_list|(
name|WINDOW
modifier|*
name|current
parameter_list|)
block|{
name|PAIR
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|WINDOW
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getwindow
argument_list|(
name|stdscr
argument_list|,
operator|&
name|ul
argument_list|,
operator|&
name|lr
argument_list|)
condition|)
block|{
name|result
operator|=
name|newwin
argument_list|(
name|lines_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|cols_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|pair_of
argument_list|(
name|ul
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|fill_window
argument_list|(
name|result
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|add_window
argument_list|(
name|stdscr
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|current
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|create_my_derwin
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|)
block|{
name|PAIR
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|WINDOW
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getwindow
argument_list|(
name|parent
argument_list|,
operator|&
name|ul
argument_list|,
operator|&
name|lr
argument_list|)
condition|)
block|{
name|result
operator|=
name|derwin
argument_list|(
name|parent
argument_list|,
name|lines_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|cols_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|pair_of
argument_list|(
name|ul
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|fill_window
argument_list|(
name|result
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
name|add_window
argument_list|(
name|parent
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|parent
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|create_my_subwin
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|)
block|{
name|PAIR
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|WINDOW
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getwindow
argument_list|(
name|parent
argument_list|,
operator|&
name|ul
argument_list|,
operator|&
name|lr
argument_list|)
condition|)
block|{
name|result
operator|=
name|subwin
argument_list|(
name|parent
argument_list|,
name|lines_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|cols_of
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|)
argument_list|,
name|ul
operator|.
name|y
operator|+
name|getbegy
argument_list|(
name|parent
argument_list|)
argument_list|,
name|ul
operator|.
name|x
operator|+
name|getbegx
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|fill_window
argument_list|(
name|result
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|add_window
argument_list|(
name|parent
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|parent
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_help
parameter_list|(
name|WINDOW
modifier|*
name|current
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
struct|struct
block|{
name|int
name|key
decl_stmt|;
name|CONST_FMT
name|char
modifier|*
name|msg
decl_stmt|;
block|}
name|help
index|[]
init|=
block|{
block|{
literal|'?'
block|,
literal|"Show this screen"
block|}
block|,
block|{
literal|'b'
block|,
literal|"Draw a box inside the current window"
block|}
block|,
block|{
literal|'c'
block|,
literal|"Create a new window"
block|}
block|,
block|{
literal|'d'
block|,
literal|"Create a new derived window"
block|}
block|,
block|{
literal|'D'
block|,
literal|"Move derived window (moves viewport)"
block|}
block|,
block|{
literal|'f'
block|,
literal|"Fill the current window with the next character"
block|}
block|,
block|{
literal|'F'
block|,
literal|"Fill the current window with a pattern"
block|}
block|,
block|{
literal|'m'
block|,
literal|"Move the current window"
block|}
block|,
block|{
literal|'M'
block|,
literal|"Move the current window (and its children)"
block|}
block|,
block|{
literal|'q'
block|,
literal|"Quit"
block|}
block|,
block|{
literal|'s'
block|,
literal|"Create a new subwindow"
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'L'
argument_list|)
block|,
literal|"Repaint all windows, doing current one last"
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'N'
argument_list|)
block|,
literal|"Cursor to next window"
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'P'
argument_list|)
block|,
literal|"Cursor to previous window"
block|}
block|,     }
struct|;
comment|/* *INDENT-ON* */
name|WINDOW
modifier|*
name|mywin
init|=
name|newwin
argument_list|(
name|LINES
argument_list|,
name|COLS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|LINES
operator|-
literal|2
operator|&&
name|row
operator|<
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
name|help
argument_list|)
condition|;
operator|++
name|row
control|)
block|{
name|wmove
argument_list|(
name|mywin
argument_list|,
name|row
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|mywin
argument_list|,
literal|"%s"
argument_list|,
name|keyname
argument_list|(
name|help
index|[
name|row
index|]
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|mywin
argument_list|,
name|row
operator|+
literal|1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|mywin
argument_list|,
literal|"%s"
argument_list|,
name|help
index|[
name|row
index|]
operator|.
name|msg
argument_list|)
expr_stmt|;
block|}
name|box_inside
argument_list|(
name|mywin
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|mywin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|mywin
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|mywin
argument_list|)
expr_stmt|;
name|refresh_all
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|WINDOW
modifier|*
name|current_win
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
name|intrflush
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|add_window
argument_list|(
literal|0
argument_list|,
name|current_win
operator|=
name|stdscr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
operator|(
name|void
operator|)
name|mousemask
argument_list|(
name|BUTTON1_CLICKED
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NCURSES_MOUSE_VERSION */
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
name|ch
operator|=
name|wgetch
argument_list|(
name|current_win
argument_list|)
operator|)
operator|!=
name|ERR
condition|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|current_win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'?'
case|:
name|show_help
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|box_inside
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|current_win
operator|=
name|create_my_window
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|current_win
operator|=
name|create_my_derwin
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|move_derwin
argument_list|(
name|current_win
argument_list|)
condition|)
block|{
name|tail_line
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'f'
case|:
name|fill_window
argument_list|(
name|current_win
argument_list|,
operator|(
name|chtype
operator|)
name|wgetch
argument_list|(
name|current_win
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fill_with_pattern
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|move_window
argument_list|(
name|current_win
argument_list|,
operator|(
name|ch
operator|==
literal|'M'
operator|)
argument_list|)
condition|)
block|{
name|tail_line
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'q'
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|current_win
operator|=
name|create_my_subwin
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|refresh_all
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'N'
argument_list|)
case|:
name|current_win
operator|=
name|next_window
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'P'
argument_list|)
case|:
name|current_win
operator|=
name|prev_window
argument_list|(
name|current_win
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* want to allow cursor to move around the current window too */
comment|/* want to test the resizing of windows and subwindows too */
comment|/* want to allow deleting a window also */
endif|#
directive|endif
default|default:
name|wmove
argument_list|(
name|current_win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tail_line
argument_list|(
literal|"unrecognized key (use '?' for help)"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|tail_line
argument_list|(
literal|"size [%d,%d] begin [%d,%d] parent [%d,%d]"
argument_list|,
name|getmaxy
argument_list|(
name|current_win
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|current_win
argument_list|)
argument_list|,
name|getbegy
argument_list|(
name|current_win
argument_list|)
argument_list|,
name|getbegx
argument_list|(
name|current_win
argument_list|)
argument_list|,
name|getpary
argument_list|(
name|current_win
argument_list|)
argument_list|,
name|getparx
argument_list|(
name|current_win
argument_list|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|current_win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

