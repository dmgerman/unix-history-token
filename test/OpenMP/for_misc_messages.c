begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_cc1 -fsyntax-only -fopenmp=libiomp5 -triple x86_64-unknown-unknown -verify %s
end_comment

begin_comment
comment|// expected-error@+1 {{unexpected OpenMP directive '#pragma omp for'}}
end_comment

begin_pragma
pragma|#
directive|pragma
name|omp
name|for
end_pragma

begin_comment
comment|// expected-error@+1 {{unexpected OpenMP directive '#pragma omp for'}}
end_comment

begin_pragma
pragma|#
directive|pragma
name|omp
name|for
name|foo
end_pragma

begin_function
name|void
name|test_no_clause
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error@+2 {{statement after '#pragma omp for' must be a for loop}}
pragma|#
directive|pragma
name|omp
name|for
operator|++
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_branch_protected_scope
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|L1
label|:
operator|++
name|i
expr_stmt|;
name|int
name|x
index|[
literal|24
index|]
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|5
condition|)
goto|goto
name|L1
goto|;
comment|// expected-error {{use of undeclared label 'L1'}}
elseif|else
if|if
condition|(
name|i
operator|==
literal|6
condition|)
return|return;
comment|// expected-error {{cannot return from OpenMP region}}
elseif|else
if|if
condition|(
name|i
operator|==
literal|7
condition|)
goto|goto
name|L2
goto|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
name|L2
label|:
name|x
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|L2
goto|;
comment|// expected-error {{use of undeclared label 'L2'}}
elseif|else
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
literal|1
condition|)
goto|goto
name|L1
goto|;
block|}
end_function

begin_function
name|void
name|test_invalid_clause
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
pragma|#
directive|pragma
name|omp
name|for
name|foo
name|bar
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|test_non_identifiers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
pragma|#
directive|pragma
name|omp
name|for
name|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{unexpected OpenMP clause 'linear' in directive '#pragma omp for'}}
comment|// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
pragma|#
directive|pragma
name|omp
name|for
name|linear
name|(
name|x
name|)
name|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|x
name|)
name|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-warning@+1 {{extra tokens at the end of '#pragma omp for' are ignored}}
pragma|#
directive|pragma
name|omp
name|for
name|,
name|private
name|(
name|x
name|)
name|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|foo
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|test_collapse
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected '('}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}} expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|,
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}  expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|,
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-warning@+2 {{extra tokens at the end of '#pragma omp for' are ignored}}
comment|// expected-error@+1 {{expected '('}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|4
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|,
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|,
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|4
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|,
name|,
name|4
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|)
for|for
control|(
name|int
name|i1
init|=
literal|0
init|;
name|i1
operator|<
literal|16
condition|;
operator|++
name|i1
control|)
for|for
control|(
name|int
name|i2
init|=
literal|0
init|;
name|i2
operator|<
literal|16
condition|;
operator|++
name|i2
control|)
for|for
control|(
name|int
name|i3
init|=
literal|0
init|;
name|i3
operator|<
literal|16
condition|;
operator|++
name|i3
control|)
for|for
control|(
name|int
name|i4
init|=
literal|0
init|;
name|i4
operator|<
literal|16
condition|;
operator|++
name|i4
control|)
name|foo
argument_list|()
expr_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}}
comment|// expected-note@+1 {{to match this '('}} expected-note@+1 {{as specified in 'collapse' clause}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|4
name|,
name|8
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|// expected-error {{expected 4 for loops after '#pragma omp for', but found only 1}}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expression is not an integer constant expression}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|2.5
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expression is not an integer constant expression}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|foo
name|(
name|)
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|-
name|5
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|0
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{argument to 'collapse' clause must be a positive integer value}}
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|5
name|-
name|5
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|collapse
name|(
name|2
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
comment|// expected-note@+1 {{variable with automatic storage duration is predetermined as private; perhaps you forget to enclose 'omp for' directive into a parallel or another task region?}}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
operator|++
name|j
control|)
comment|// expected-error@+2 {{private variable cannot be reduction}}
comment|// expected-error@+1 {{region cannot be closely nested inside 'for' region; perhaps you forget to enclose 'omp for' directive into a parallel region?}}
pragma|#
directive|pragma
name|omp
name|for
name|reduction
name|(
name|+
name|:
name|i
name|,
name|j
name|)
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|16
condition|;
operator|++
name|k
control|)
name|i
operator|+=
name|j
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_private
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected expression}}
comment|// expected-error@+1 {{expected ')'}} expected-note@+1 {{to match this '('}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|,
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|,
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|int
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected variable name}}
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|0
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|x
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|x
name|,
name|y
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|private
name|(
name|x
name|,
name|y
name|,
name|z
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
name|y
operator|*
name|i
operator|+
name|z
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_lastprivate
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|,
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|,
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|int
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected variable name}}
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|0
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|,
name|y
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|,
name|y
name|,
name|z
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|test_firstprivate
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{expected ')'}} expected-note@+2 {{to match this '('}}
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
name|,
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 2 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
name|,
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected expression}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
name|int
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+1 {{expected variable name}}
pragma|#
directive|pragma
name|omp
name|for
name|firstprivate
name|(
name|0
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|)
name|firstprivate
name|(
name|x
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|,
name|y
name|)
name|firstprivate
name|(
name|x
name|,
name|y
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
pragma|#
directive|pragma
name|omp
name|for
name|lastprivate
name|(
name|x
name|,
name|y
name|,
name|z
name|)
name|firstprivate
name|(
name|x
name|,
name|y
name|,
name|z
name|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|test_loop_messages
parameter_list|()
block|{
name|float
name|a
index|[
literal|100
index|]
decl_stmt|,
name|b
index|[
literal|100
index|]
decl_stmt|,
name|c
index|[
literal|100
index|]
decl_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{variable must be of integer or pointer type}}
pragma|#
directive|pragma
name|omp
name|for
for|for
control|(
name|float
name|fi
init|=
literal|0
init|;
name|fi
operator|<
literal|10.0
condition|;
name|fi
operator|++
control|)
block|{
name|c
index|[
operator|(
name|int
operator|)
name|fi
index|]
operator|=
name|a
index|[
operator|(
name|int
operator|)
name|fi
index|]
operator|+
name|b
index|[
operator|(
name|int
operator|)
name|fi
index|]
expr_stmt|;
block|}
pragma|#
directive|pragma
name|omp
name|parallel
comment|// expected-error@+2 {{variable must be of integer or pointer type}}
pragma|#
directive|pragma
name|omp
name|for
for|for
control|(
name|double
name|fi
init|=
literal|0
init|;
name|fi
operator|<
literal|10.0
condition|;
name|fi
operator|++
control|)
block|{
name|c
index|[
operator|(
name|int
operator|)
name|fi
index|]
operator|=
name|a
index|[
operator|(
name|int
operator|)
name|fi
index|]
operator|+
name|b
index|[
operator|(
name|int
operator|)
name|fi
index|]
expr_stmt|;
block|}
comment|// expected-warning@+2 {{OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed}}
pragma|#
directive|pragma
name|omp
name|for
for|for
control|(
name|__int128
name|ii
init|=
literal|0
init|;
name|ii
operator|<
literal|10
condition|;
name|ii
operator|++
control|)
block|{
name|c
index|[
name|ii
index|]
operator|=
name|a
index|[
name|ii
index|]
operator|+
name|b
index|[
name|ii
index|]
expr_stmt|;
block|}
block|}
end_function

end_unit

