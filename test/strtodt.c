begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 2001 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_comment
comment|/* Test strtod.  */
end_comment

begin_comment
comment|/* On stdin, read triples: d x y:  *	d = decimal string  *	x = high-order Hex value expected from strtod  *	y = low-order Hex value  * Complain about errors.  */
end_comment

begin_include
include|#
directive|include
file|"gdtoa.h"
end_include

begin_comment
comment|/* for ULong */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|W0
decl_stmt|,
name|W1
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
union|union
block|{
name|double
name|d
decl_stmt|;
name|ULong
name|L
index|[
literal|2
index|]
decl_stmt|;
block|}
name|U
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UL
value|(unsigned long)
end_define

begin_function
specifier|static
name|int
name|process
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|U
name|a
decl_stmt|,
name|b
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|se
decl_stmt|;
name|int
name|line
decl_stmt|,
name|n
decl_stmt|;
name|line
operator|=
name|n
operator|=
literal|0
expr_stmt|;
name|top
label|:
while|while
condition|(
name|fgets
argument_list|(
name|s
operator|=
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|<=
literal|' '
condition|)
if|if
condition|(
operator|!
operator|*
name|s
operator|++
condition|)
goto|goto
name|top
goto|;
comment|/* break 2 */
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s
operator|>
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
comment|/* if (sscanf(s,"\t%lx\t%lx",&a.L[0],&a.L[1]) != 2) */
if|if
condition|(
operator|(
name|a
operator|.
name|L
index|[
literal|0
index|]
operator|=
operator|(
name|ULong
operator|)
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|s1
argument_list|,
literal|16
argument_list|)
operator|,
name|s1
operator|<=
name|s
operator|)
operator|||
operator|(
name|a
operator|.
name|L
index|[
literal|1
index|]
operator|=
operator|(
name|ULong
operator|)
name|strtoul
argument_list|(
name|s1
argument_list|,
operator|&
name|se
argument_list|,
literal|16
argument_list|)
operator|,
name|se
operator|<=
name|s1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Badly formatted line %d of %s\n"
argument_list|,
name|line
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
continue|continue;
block|}
name|b
operator|.
name|d
operator|=
name|strtod
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|L
index|[
name|W0
index|]
operator|!=
name|a
operator|.
name|L
index|[
literal|0
index|]
operator|||
name|b
operator|.
name|L
index|[
name|W1
index|]
operator|!=
name|a
operator|.
name|L
index|[
literal|1
index|]
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Line %d of %s: got %lx %lx; expected %lx %lx\n"
argument_list|,
argument|line
argument_list|,
argument|fname
argument_list|,
argument|UL b.L[W0]
argument_list|,
argument|UL b.L[W1]
argument_list|,
argument|UL a.L[
literal|0
argument|]
argument_list|,
argument|UL a.L[
literal|1
argument|]
argument_list|)
empty_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|,
name|rc
decl_stmt|;
name|U
name|u
decl_stmt|;
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-?"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [file [file...]]\n"
literal|"\tto read data file(s) of tab-separated triples d x y with\n"
literal|"\t\td decimal string\n"
literal|"\t\tx = high-order Hex value expected from strtod\n"
literal|"\t\ty = low-order Hex value\n"
literal|"\tComplain about errors by strtod.\n"
literal|"\tIf no files, read triples from stdin.\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* determine endian-ness */
name|u
operator|.
name|d
operator|=
literal|1.
expr_stmt|;
name|W0
operator|=
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
name|W1
operator|=
literal|1
operator|-
name|W0
expr_stmt|;
comment|/* test */
name|n
operator|=
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|n
operator|=
name|process
argument_list|(
literal|"<stdin>"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|(
name|s
operator|=
operator|*
operator|++
name|argv
operator|)
condition|)
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|n
operator|+=
name|process
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d bad conversions\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|rc
operator||=
literal|1
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

end_unit

