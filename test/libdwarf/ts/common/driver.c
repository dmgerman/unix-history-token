begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: driver.c 2121 2011-11-09 08:43:56Z jkoshy $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<bsdxml.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"driver.h"
end_include

begin_include
include|#
directive|include
file|"tet_api.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TCGEN
end_ifndef

begin_define
define|#
directive|define
name|_XML_BUFSIZE
value|8192
end_define

begin_define
define|#
directive|define
name|_XML_DATABUFSZ
value|65536
end_define

begin_struct
struct|struct
name|_drv_vc
block|{
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
name|int64_t
name|i64
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|b
struct|;
block|}
name|v
union|;
enum|enum
block|{
name|_VTYPE_NONE
block|,
name|_VTYPE_INT
block|,
name|_VTYPE_UINT
block|,
name|_VTYPE_STRING
block|,
name|_VTYPE_BLOCK
block|, 	}
name|vt
enum|;
enum|enum
block|{
name|_OP_EQ
block|,
name|_OP_NE
block|, 	}
name|op
enum|;
enum|enum
block|{
name|_FAIL_CONTINUE
block|,
name|_FAIL_ABORT
block|, 	}
name|fail
enum|;
name|STAILQ_ENTRY
argument_list|(
argument|_drv_vc
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_drv_tp
block|{
name|struct
name|dwarf_tp
modifier|*
name|dtp
decl_stmt|;
name|int
name|testnum
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|_drv_vc
argument_list|)
name|vclist
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|_drv_tp
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_drv_ic
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|tpcnt
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|_drv_tp
argument_list|)
name|tplist
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|_drv_ic
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|ic_count
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|_drv_ic
argument_list|)
name|_iclist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|_drv_ic
modifier|*
name|_cur_ic
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_drv_tp
modifier|*
name|_cur_tp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_drv_vc
modifier|*
name|_cur_vc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|_xml_buf
index|[
name|_XML_BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|_xml_data
index|[
name|_XML_DATABUFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_xml_data_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_test_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|FILE
modifier|*
name|_cur_fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TCGEN */
end_comment

begin_comment
comment|/* The name of the file currently being processed. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_cur_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|driver_startup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|driver_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(unused)
argument_list|)
name|char
operator|*
name|driver_string_encode
argument_list|(
specifier|const
name|char
operator|*
name|str
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TCGEN
end_ifndef

begin_function_decl
specifier|static
name|void
name|driver_base64_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|code
parameter_list|,
name|int
name|codesize
parameter_list|,
name|char
modifier|*
modifier|*
name|plain
parameter_list|,
name|int
modifier|*
name|plainsize
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(unused)
argument_list|)
name|void
name|driver_base64_encode
argument_list|(
argument|const char *plain
argument_list|,
argument|int plainsize
argument_list|,
argument|char **code
argument_list|,
argument|int *codesize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TCGEN */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|tet_startup
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|driver_startup
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|tet_cleanup
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|driver_cleanup
function_decl|;
end_function_decl

begin_comment
comment|/*  * Functions used by TCM for supporting a dynamic test case.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCGEN
end_ifndef

begin_function
specifier|static
name|struct
name|_drv_ic
modifier|*
name|_find_ic
parameter_list|(
name|int
name|icnum
parameter_list|)
block|{
name|struct
name|_drv_ic
modifier|*
name|ic
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ic
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|_iclist
argument_list|)
init|;
name|i
operator|<
name|icnum
operator|&&
name|ic
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|ic
operator|=
name|STAILQ_NEXT
argument_list|(
name|ic
argument_list|,
name|next
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|ic
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|_drv_tp
modifier|*
name|_find_tp
parameter_list|(
name|int
name|icnum
parameter_list|,
name|int
name|tpnum
parameter_list|)
block|{
name|struct
name|_drv_ic
modifier|*
name|ic
decl_stmt|;
name|struct
name|_drv_tp
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ic
operator|=
name|_find_ic
argument_list|(
name|icnum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ic
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|tp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|tplist
argument_list|)
init|;
name|i
operator|<
name|tpnum
operator|&&
name|tp
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|tp
operator|=
name|STAILQ_NEXT
argument_list|(
name|tp
argument_list|,
name|next
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TCGEN */
end_comment

begin_function
name|int
name|tet_getminic
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* IC start with 1. */
block|}
end_function

begin_function
name|int
name|tet_getmaxic
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ic_count
operator|)
return|;
endif|#
directive|endif
comment|/* TCGEN */
block|}
end_function

begin_function
name|int
name|tet_isdefic
parameter_list|(
name|int
name|icnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
name|assert
argument_list|(
name|icnum
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|icnum
operator|>=
literal|1
operator|&&
name|icnum
operator|<=
name|ic_count
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TCGEN */
block|}
end_function

begin_function
name|int
name|tet_gettpcount
parameter_list|(
name|int
name|icnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
name|assert
argument_list|(
name|icnum
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|struct
name|_drv_ic
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
name|_find_ic
argument_list|(
name|icnum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ic
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ic
operator|->
name|tpcnt
operator|)
return|;
endif|#
directive|endif
comment|/* TCGEN */
block|}
end_function

begin_function
name|int
name|tet_gettestnum
parameter_list|(
name|int
name|icnum
parameter_list|,
name|int
name|tpnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
name|assert
argument_list|(
name|icnum
operator|==
literal|1
operator|&&
name|tpnum
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|struct
name|_drv_tp
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|_find_tp
argument_list|(
name|icnum
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|->
name|testnum
operator|)
return|;
endif|#
directive|endif
comment|/* TCGEN */
block|}
end_function

begin_function
name|int
name|tet_invoketp
parameter_list|(
name|int
name|icnum
parameter_list|,
name|int
name|tpnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
name|assert
argument_list|(
name|icnum
operator|==
literal|1
operator|&&
name|tpnum
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|struct
name|_drv_ic
modifier|*
name|ic
decl_stmt|;
name|struct
name|_drv_tp
modifier|*
name|tp
decl_stmt|;
name|ic
operator|=
name|_find_ic
argument_list|(
name|icnum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ic
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_cur_ic
operator|=
name|ic
expr_stmt|;
name|_cur_file
operator|=
name|_cur_ic
operator|->
name|file
expr_stmt|;
name|tp
operator|=
name|_find_tp
argument_list|(
name|icnum
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tp
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|dtp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tet_printf
argument_list|(
literal|"Start Test Purpose<%s> on<%s>\n"
argument_list|,
name|tp
operator|->
name|dtp
operator|->
name|tp_name
argument_list|,
name|_cur_ic
operator|->
name|file
argument_list|)
expr_stmt|;
name|_cur_vc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|tp
operator|->
name|vclist
argument_list|)
expr_stmt|;
name|tp
operator|->
name|dtp
operator|->
name|tp_func
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TCGEN */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TCGEN
end_ifndef

begin_function
specifier|static
name|void
name|_xml_start_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|el
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attr
parameter_list|)
block|{
name|XML_Parser
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"ic"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_ic
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Nested IC at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|_cur_ic
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_cur_ic
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|_cur_ic
operator|->
name|tplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_ic
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attr
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"file"
argument_list|)
condition|)
block|{
name|_cur_ic
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_ic
operator|->
name|file
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|_cur_ic
operator|->
name|file
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"IC without 'file' attribute "
literal|"at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"tp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_ic
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"TP without containing IC at "
literal|"line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_tp
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Nested TP at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|_cur_tp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_cur_tp
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|_cur_tp
operator|->
name|vclist
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_tp
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attr
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"func"
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|dwarf_tp_array
index|[
name|j
index|]
operator|.
name|tp_name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|dwarf_tp_array
index|[
name|j
index|]
operator|.
name|tp_name
argument_list|)
condition|)
block|{
name|_cur_tp
operator|->
name|dtp
operator|=
operator|&
name|dwarf_tp_array
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|_cur_tp
operator|->
name|dtp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"TP function '%s' not found"
argument_list|,
name|attr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|_cur_tp
operator|->
name|dtp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"TP without 'func' attribute at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"vc"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_tp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"VC without containing IC at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_vc
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Nested VC at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|_cur_vc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_cur_vc
argument_list|)
argument_list|)
expr_stmt|;
name|_cur_vc
operator|->
name|op
operator|=
name|_OP_EQ
expr_stmt|;
name|_cur_vc
operator|->
name|fail
operator|=
name|_FAIL_CONTINUE
expr_stmt|;
if|if
condition|(
name|_cur_vc
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attr
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"var"
argument_list|)
condition|)
block|{
name|_cur_vc
operator|->
name|var
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_vc
operator|->
name|var
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"int"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|vt
operator|=
name|_VTYPE_INT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"uint"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|vt
operator|=
name|_VTYPE_UINT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"str"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|vt
operator|=
name|_VTYPE_STRING
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"block"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|vt
operator|=
name|_VTYPE_BLOCK
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Unknown value type %s at "
literal|"line %jd"
argument_list|,
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"op"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"ne"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|op
operator|=
name|_OP_NE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"fail"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"abort"
argument_list|)
condition|)
name|_cur_vc
operator|->
name|fail
operator|=
name|_FAIL_ABORT
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Unknown attr %s at line %jd"
argument_list|,
name|attr
index|[
name|i
index|]
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_cur_vc
operator|->
name|var
operator|==
name|NULL
operator|||
name|_cur_vc
operator|->
name|vt
operator|==
name|_VTYPE_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"VC without 'var' or 'type' attribute at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Unknown element %s at line %jd"
argument_list|,
name|el
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_xml_end_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|el
parameter_list|)
block|{
name|XML_Parser
name|p
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"ic"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_ic
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"bogus IC end tag at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|_iclist
argument_list|,
name|_cur_ic
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|_cur_ic
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"tp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_tp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"bogus TP end tag at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|_cur_ic
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_test_cnt
operator|++
expr_stmt|;
name|_cur_tp
operator|->
name|testnum
operator|=
name|_test_cnt
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|_cur_ic
operator|->
name|tplist
argument_list|,
name|_cur_tp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|_cur_ic
operator|->
name|tpcnt
operator|++
expr_stmt|;
name|_cur_tp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|el
argument_list|,
literal|"vc"
argument_list|)
condition|)
block|{
if|if
condition|(
name|_cur_vc
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"bogus VC end tag at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_xml_data_pos
operator|==
literal|0
operator|&&
name|_cur_vc
operator|->
name|vt
operator|!=
name|_VTYPE_STRING
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"VC element without value defined at line %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|_xml_data
index|[
name|_xml_data_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|_cur_vc
operator|->
name|vt
condition|)
block|{
case|case
name|_VTYPE_INT
case|:
name|_cur_vc
operator|->
name|v
operator|.
name|i64
operator|=
name|strtoimax
argument_list|(
name|_xml_data
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_VTYPE_UINT
case|:
name|_cur_vc
operator|->
name|v
operator|.
name|u64
operator|=
name|strtoumax
argument_list|(
name|_xml_data
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_VTYPE_STRING
case|:
name|_cur_vc
operator|->
name|v
operator|.
name|str
operator|=
name|strdup
argument_list|(
name|_xml_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|_cur_vc
operator|->
name|v
operator|.
name|str
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
break|break;
case|case
name|_VTYPE_BLOCK
case|:
name|driver_base64_decode
argument_list|(
name|_xml_data
argument_list|,
name|_xml_data_pos
argument_list|,
operator|&
name|_cur_vc
operator|->
name|v
operator|.
name|b
operator|.
name|data
argument_list|,
operator|&
name|_cur_vc
operator|->
name|v
operator|.
name|b
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|_xml_data_pos
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|_cur_tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|_cur_tp
operator|->
name|vclist
argument_list|,
name|_cur_vc
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|_cur_vc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|_VALUE_BUFSIZE
value|1024
end_define

begin_function
specifier|static
name|void
name|_xml_data_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|_cur_vc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|_xml_data_pos
operator|+
name|len
operator|>=
name|_XML_DATABUFSZ
condition|)
block|{
name|warnx
argument_list|(
literal|"_xml_data overflowed, data(%d) discarded"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
operator|&
name|_xml_data
index|[
name|_xml_data_pos
index|]
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_xml_data_pos
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|_CMD_SIZE
value|256
end_define

begin_function
specifier|static
name|void
name|driver_parse_ic_desc
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|XML_Parser
name|p
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|final
decl_stmt|;
name|char
modifier|*
name|xml_name
decl_stmt|,
modifier|*
name|ext
decl_stmt|,
modifier|*
name|fname0
decl_stmt|;
name|char
name|cmd
index|[
name|_CMD_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fname0
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|fname0
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|_CMD_SIZE
argument_list|,
literal|"gunzip -f -c %s> %s"
argument_list|,
name|fname
argument_list|,
name|fname0
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cmd
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"system"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xml_name
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|ext
operator|=
name|strrchr
argument_list|(
name|xml_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ext
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|ext
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"XML_ParserCreate failed"
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|p
argument_list|,
name|_xml_start_cb
argument_list|,
name|_xml_end_cb
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|p
argument_list|,
name|_xml_data_cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|xml_name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open %s failed"
argument_list|,
name|xml_name
argument_list|)
expr_stmt|;
name|final
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|_xml_buf
argument_list|,
name|_XML_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"read %s failed"
argument_list|,
name|xml_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
name|final
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|XML_Parse
argument_list|(
name|p
argument_list|,
name|_xml_buf
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|,
name|final
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"XML_Parse error at line %jd: %s\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|XML_GetCurrentLineNumber
argument_list|(
name|p
argument_list|)
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
condition|)
break|break;
block|}
name|free
argument_list|(
name|xml_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|driver_parse_ic
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"opendir"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|<=
literal|7
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|dp
operator|->
name|d_name
index|[
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|-
literal|7
index|]
argument_list|,
literal|".xml.gz"
argument_list|)
condition|)
name|driver_parse_ic_desc
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !TCGEN */
end_comment

begin_function
specifier|static
name|void
name|driver_gen_tp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dwarf_tp_array
index|[
name|i
index|]
operator|.
name|tp_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<tp func='%s'>\n"
argument_list|,
name|dwarf_tp_array
index|[
name|i
index|]
operator|.
name|tp_name
argument_list|)
expr_stmt|;
name|_cur_file
operator|=
name|file
expr_stmt|;
name|_cur_fp
operator|=
name|fp
expr_stmt|;
name|dwarf_tp_array
index|[
name|i
index|]
operator|.
name|tp_func
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"</tp>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|_FILENAME_BUFSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|_CMD_SIZE
value|256
end_define

begin_function
specifier|static
name|void
name|driver_gen_ic
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|flist
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|nbuf
index|[
name|_FILENAME_BUFSIZE
index|]
decl_stmt|,
name|cmd
index|[
name|_CMD_SIZE
index|]
decl_stmt|;
name|flist
operator|=
name|getenv
argument_list|(
literal|"ICLIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flist
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Driver in TCGEN mode but ICLIST env is not defined"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flist
operator|=
name|strdup
argument_list|(
name|flist
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|flist
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
literal|"%s.xml"
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|nbuf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fopen %s failed"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<ic file='%s'>\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|driver_gen_tp
argument_list|(
name|fp
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"</ic>\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|_CMD_SIZE
argument_list|,
literal|"gzip -f %s"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cmd
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"system"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TCGEN */
end_comment

begin_define
define|#
directive|define
name|_MAX_STRING_SIZE
value|65535
end_define

begin_function
specifier|static
name|char
modifier|*
name|driver_string_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|char
name|enc
index|[
name|_MAX_STRING_SIZE
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|pos
decl_stmt|;
define|#
directive|define
name|_ENCODE_STRING
parameter_list|(
name|S
parameter_list|)
value|do {			\ 	len = strlen(S);				\ 	if (pos + len< _MAX_STRING_SIZE) {		\ 		strncpy(enc + pos, S, len);		\ 		pos += len;				\ 	} else {					\ 		assert(0);				\ 		return (NULL);				\ 	}						\ 	} while(0)
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'"'
case|:
name|_ENCODE_STRING
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|_ENCODE_STRING
argument_list|(
literal|"&apos;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|_ENCODE_STRING
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|_ENCODE_STRING
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|_ENCODE_STRING
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Normal chars. */
if|if
condition|(
name|pos
operator|<
name|_MAX_STRING_SIZE
operator|-
literal|1
condition|)
name|enc
index|[
name|pos
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
else|else
block|{
name|enc
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
block|}
name|enc
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|enc
operator|)
return|;
undef|#
directive|undef
name|_ENCODE_STRING
block|}
end_function

begin_function
specifier|static
name|void
name|driver_startup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TCGEN
name|driver_gen_ic
argument_list|()
expr_stmt|;
else|#
directive|else
name|STAILQ_INIT
argument_list|(
operator|&
name|_iclist
argument_list|)
expr_stmt|;
name|driver_parse_ic
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|driver_cleanup
parameter_list|(
name|void
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*  * Base64 encode/decode utility modified from libb64 project. It's been  * placed in the public domain. Note that this modified version doesn't  * emit newline during encoding.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCGEN
end_ifdef

begin_typedef
typedef|typedef
enum|enum
block|{
name|step_A
block|,
name|step_B
block|,
name|step_C
block|}
name|base64_encodestep
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|base64_encodestep
name|step
decl_stmt|;
name|char
name|result
decl_stmt|;
block|}
name|base64_encodestate
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|base64_init_encodestate
parameter_list|(
name|base64_encodestate
modifier|*
name|state_in
parameter_list|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_A
expr_stmt|;
name|state_in
operator|->
name|result
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|base64_encode_value
parameter_list|(
name|char
name|value_in
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|encoding
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
literal|"abcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
if|if
condition|(
name|value_in
operator|>
literal|63
condition|)
return|return
literal|'='
return|;
return|return
name|encoding
index|[
operator|(
name|int
operator|)
name|value_in
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|base64_encode_block
parameter_list|(
specifier|const
name|char
modifier|*
name|plaintext_in
parameter_list|,
name|int
name|length_in
parameter_list|,
name|char
modifier|*
name|code_out
parameter_list|,
name|base64_encodestate
modifier|*
name|state_in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|plainchar
init|=
name|plaintext_in
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|plaintextend
init|=
name|plaintext_in
operator|+
name|length_in
decl_stmt|;
name|char
modifier|*
name|codechar
init|=
name|code_out
decl_stmt|;
name|char
name|res
decl_stmt|;
name|char
name|fragment
decl_stmt|;
name|res
operator|=
name|state_in
operator|->
name|result
expr_stmt|;
switch|switch
condition|(
name|state_in
operator|->
name|step
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
case|case
name|step_A
case|:
if|if
condition|(
name|plainchar
operator|==
name|plaintextend
condition|)
block|{
name|state_in
operator|->
name|result
operator|=
name|res
expr_stmt|;
name|state_in
operator|->
name|step
operator|=
name|step_A
expr_stmt|;
return|return
name|codechar
operator|-
name|code_out
return|;
block|}
name|fragment
operator|=
operator|*
name|plainchar
operator|++
expr_stmt|;
name|res
operator|=
operator|(
name|fragment
operator|&
literal|0x0fc
operator|)
operator|>>
literal|2
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|fragment
operator|&
literal|0x003
operator|)
operator|<<
literal|4
expr_stmt|;
case|case
name|step_B
case|:
if|if
condition|(
name|plainchar
operator|==
name|plaintextend
condition|)
block|{
name|state_in
operator|->
name|result
operator|=
name|res
expr_stmt|;
name|state_in
operator|->
name|step
operator|=
name|step_B
expr_stmt|;
return|return
name|codechar
operator|-
name|code_out
return|;
block|}
name|fragment
operator|=
operator|*
name|plainchar
operator|++
expr_stmt|;
name|res
operator||=
operator|(
name|fragment
operator|&
literal|0x0f0
operator|)
operator|>>
literal|4
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|fragment
operator|&
literal|0x00f
operator|)
operator|<<
literal|2
expr_stmt|;
case|case
name|step_C
case|:
if|if
condition|(
name|plainchar
operator|==
name|plaintextend
condition|)
block|{
name|state_in
operator|->
name|result
operator|=
name|res
expr_stmt|;
name|state_in
operator|->
name|step
operator|=
name|step_C
expr_stmt|;
return|return
name|codechar
operator|-
name|code_out
return|;
block|}
name|fragment
operator|=
operator|*
name|plainchar
operator|++
expr_stmt|;
name|res
operator||=
operator|(
name|fragment
operator|&
literal|0x0c0
operator|)
operator|>>
literal|6
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|fragment
operator|&
literal|0x03f
operator|)
operator|>>
literal|0
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* control should not reach here */
return|return
name|codechar
operator|-
name|code_out
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|base64_encode_blockend
parameter_list|(
name|char
modifier|*
name|code_out
parameter_list|,
name|base64_encodestate
modifier|*
name|state_in
parameter_list|)
block|{
name|char
modifier|*
name|codechar
init|=
name|code_out
decl_stmt|;
switch|switch
condition|(
name|state_in
operator|->
name|step
condition|)
block|{
case|case
name|step_B
case|:
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|state_in
operator|->
name|result
argument_list|)
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
literal|'='
expr_stmt|;
break|break;
case|case
name|step_C
case|:
operator|*
name|codechar
operator|++
operator|=
name|base64_encode_value
argument_list|(
name|state_in
operator|->
name|result
argument_list|)
expr_stmt|;
operator|*
name|codechar
operator|++
operator|=
literal|'='
expr_stmt|;
break|break;
case|case
name|step_A
case|:
break|break;
block|}
return|return
name|codechar
operator|-
name|code_out
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|driver_base64_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|plain
parameter_list|,
name|int
name|plainsize
parameter_list|,
name|char
modifier|*
modifier|*
name|code
parameter_list|,
name|int
modifier|*
name|codesize
parameter_list|)
block|{
name|base64_encodestate
name|state
decl_stmt|;
name|assert
argument_list|(
name|plain
operator|!=
name|NULL
operator|&&
name|plainsize
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|plainsize
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|code
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|base64_init_encodestate
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
operator|*
name|codesize
operator|=
name|base64_encode_block
argument_list|(
name|plain
argument_list|,
name|plainsize
argument_list|,
operator|*
name|code
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
operator|*
name|codesize
operator|+=
name|base64_encode_blockend
argument_list|(
operator|*
name|code
operator|+
operator|*
name|codesize
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TCGEN */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|step_a
block|,
name|step_b
block|,
name|step_c
block|,
name|step_d
block|}
name|base64_decodestep
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|base64_decodestep
name|step
decl_stmt|;
name|char
name|plainchar
decl_stmt|;
block|}
name|base64_decodestate
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|base64_decode_value
parameter_list|(
name|int
name|value_in
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|decoding
index|[]
init|=
block|{
literal|62
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|63
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|decoding_size
init|=
sizeof|sizeof
argument_list|(
name|decoding
argument_list|)
decl_stmt|;
name|value_in
operator|-=
literal|43
expr_stmt|;
if|if
condition|(
name|value_in
operator|<
literal|0
operator|||
name|value_in
operator|>
name|decoding_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|decoding
index|[
name|value_in
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base64_init_decodestate
parameter_list|(
name|base64_decodestate
modifier|*
name|state_in
parameter_list|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_a
expr_stmt|;
name|state_in
operator|->
name|plainchar
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|base64_decode_block
parameter_list|(
specifier|const
name|char
modifier|*
name|code_in
parameter_list|,
specifier|const
name|int
name|length_in
parameter_list|,
name|char
modifier|*
name|plaintext_out
parameter_list|,
name|base64_decodestate
modifier|*
name|state_in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|codechar
init|=
name|code_in
decl_stmt|;
name|char
modifier|*
name|plainchar
init|=
name|plaintext_out
decl_stmt|;
name|char
name|fragment
decl_stmt|;
operator|*
name|plainchar
operator|=
name|state_in
operator|->
name|plainchar
expr_stmt|;
switch|switch
condition|(
name|state_in
operator|->
name|step
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
case|case
name|step_a
case|:
do|do
block|{
if|if
condition|(
name|codechar
operator|==
name|code_in
operator|+
name|length_in
condition|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_a
expr_stmt|;
name|state_in
operator|->
name|plainchar
operator|=
operator|*
name|plainchar
expr_stmt|;
return|return
name|plainchar
operator|-
name|plaintext_out
return|;
block|}
name|fragment
operator|=
operator|(
name|char
operator|)
name|base64_decode_value
argument_list|(
operator|*
name|codechar
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fragment
operator|<
literal|0
condition|)
do|;
operator|*
name|plainchar
operator|=
operator|(
name|fragment
operator|&
literal|0x03f
operator|)
operator|<<
literal|2
expr_stmt|;
case|case
name|step_b
case|:
do|do
block|{
if|if
condition|(
name|codechar
operator|==
name|code_in
operator|+
name|length_in
condition|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_b
expr_stmt|;
name|state_in
operator|->
name|plainchar
operator|=
operator|*
name|plainchar
expr_stmt|;
return|return
name|plainchar
operator|-
name|plaintext_out
return|;
block|}
name|fragment
operator|=
operator|(
name|char
operator|)
name|base64_decode_value
argument_list|(
operator|*
name|codechar
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fragment
operator|<
literal|0
condition|)
do|;
operator|*
name|plainchar
operator|++
operator||=
operator|(
name|fragment
operator|&
literal|0x030
operator|)
operator|>>
literal|4
expr_stmt|;
operator|*
name|plainchar
operator|=
operator|(
name|fragment
operator|&
literal|0x00f
operator|)
operator|<<
literal|4
expr_stmt|;
case|case
name|step_c
case|:
do|do
block|{
if|if
condition|(
name|codechar
operator|==
name|code_in
operator|+
name|length_in
condition|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_c
expr_stmt|;
name|state_in
operator|->
name|plainchar
operator|=
operator|*
name|plainchar
expr_stmt|;
return|return
name|plainchar
operator|-
name|plaintext_out
return|;
block|}
name|fragment
operator|=
operator|(
name|char
operator|)
name|base64_decode_value
argument_list|(
operator|*
name|codechar
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fragment
operator|<
literal|0
condition|)
do|;
operator|*
name|plainchar
operator|++
operator||=
operator|(
name|fragment
operator|&
literal|0x03c
operator|)
operator|>>
literal|2
expr_stmt|;
operator|*
name|plainchar
operator|=
operator|(
name|fragment
operator|&
literal|0x003
operator|)
operator|<<
literal|6
expr_stmt|;
case|case
name|step_d
case|:
do|do
block|{
if|if
condition|(
name|codechar
operator|==
name|code_in
operator|+
name|length_in
condition|)
block|{
name|state_in
operator|->
name|step
operator|=
name|step_d
expr_stmt|;
name|state_in
operator|->
name|plainchar
operator|=
operator|*
name|plainchar
expr_stmt|;
return|return
name|plainchar
operator|-
name|plaintext_out
return|;
block|}
name|fragment
operator|=
operator|(
name|char
operator|)
name|base64_decode_value
argument_list|(
operator|*
name|codechar
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fragment
operator|<
literal|0
condition|)
do|;
operator|*
name|plainchar
operator|++
operator||=
operator|(
name|fragment
operator|&
literal|0x03f
operator|)
expr_stmt|;
block|}
block|}
comment|/* control should not reach here */
return|return
name|plainchar
operator|-
name|plaintext_out
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|driver_base64_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|code
parameter_list|,
name|int
name|codesize
parameter_list|,
name|char
modifier|*
modifier|*
name|plain
parameter_list|,
name|int
modifier|*
name|plainsize
parameter_list|)
block|{
name|base64_decodestate
name|state
decl_stmt|;
name|assert
argument_list|(
name|code
operator|!=
name|NULL
operator|&&
name|codesize
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|*
name|plain
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|codesize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|plain
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|base64_init_decodestate
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
operator|*
name|plainsize
operator|=
name|base64_decode_block
argument_list|(
name|code
argument_list|,
name|codesize
argument_list|,
operator|*
name|plain
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCGEN */
end_comment

end_unit

