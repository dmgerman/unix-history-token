begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"test.h"
end_include

begin_include
include|#
directive|include
file|<atomic>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<sanitizer/tsan_interface.h>
end_include

begin_comment
comment|// A very primitive mutex annotated with tsan annotations.
end_comment

begin_decl_stmt
name|class
name|Mutex
block|{
name|public
label|:
name|Mutex
argument_list|(
argument|bool prof
argument_list|,
argument|unsigned flags
argument_list|)
block|:
name|prof_
argument_list|(
name|prof
argument_list|)
operator|,
name|locked_
argument_list|(
name|false
argument_list|)
operator|,
name|seq_
argument_list|(
literal|0
argument_list|)
block|{
name|__tsan_mutex_create
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
block|;   }
operator|~
name|Mutex
argument_list|()
block|{
name|__tsan_mutex_destroy
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
block|;   }
name|void
name|Lock
argument_list|()
block|{
name|__tsan_mutex_pre_lock
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
block|;
name|LockImpl
argument_list|()
block|;
name|__tsan_mutex_post_lock
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|;   }
name|bool
name|TryLock
argument_list|()
block|{
name|__tsan_mutex_pre_lock
argument_list|(
name|this
argument_list|,
name|__tsan_mutex_try_lock
argument_list|)
block|;
name|bool
name|ok
operator|=
name|TryLockImpl
argument_list|()
block|;
name|__tsan_mutex_post_lock
argument_list|(
name|this
argument_list|,
name|__tsan_mutex_try_lock
operator||
operator|(
name|ok
condition|?
literal|0
else|:
name|__tsan_mutex_try_lock_failed
operator|)
argument_list|,
literal|0
argument_list|)
block|;
return|return
name|ok
return|;
block|}
name|void
name|Unlock
parameter_list|()
block|{
name|__tsan_mutex_pre_unlock
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UnlockImpl
argument_list|()
expr_stmt|;
name|__tsan_mutex_post_unlock
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|Wait
parameter_list|()
block|{
for|for
control|(
name|int
name|seq
init|=
name|seq_
init|;
name|seq
operator|==
name|seq_
condition|;
control|)
block|{
name|Unlock
argument_list|()
expr_stmt|;
name|usleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|Lock
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|Broadcast
parameter_list|()
block|{
name|__tsan_mutex_pre_signal
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LockImpl
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|seq_
operator|++
expr_stmt|;
name|UnlockImpl
argument_list|()
expr_stmt|;
name|__tsan_mutex_post_signal
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|private
label|:
specifier|const
name|bool
name|prof_
decl_stmt|;
name|std
operator|::
name|atomic
operator|<
name|bool
operator|>
name|locked_
expr_stmt|;
name|int
name|seq_
decl_stmt|;
comment|// This models mutex profiling subsystem.
specifier|static
name|Mutex
name|prof_mu_
decl_stmt|;
specifier|static
name|int
name|prof_data_
decl_stmt|;
name|void
name|LockImpl
parameter_list|(
name|bool
name|prof
init|=
name|true
parameter_list|)
block|{
while|while
condition|(
operator|!
name|TryLockImpl
argument_list|()
condition|)
name|usleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof
operator|&&
name|prof_
condition|)
name|Prof
argument_list|()
expr_stmt|;
block|}
name|bool
name|TryLockImpl
parameter_list|()
block|{
return|return
operator|!
name|locked_
operator|.
name|exchange
argument_list|(
name|true
argument_list|)
return|;
block|}
name|void
name|UnlockImpl
parameter_list|()
block|{
name|locked_
operator|.
name|store
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|void
name|Prof
parameter_list|()
block|{
comment|// This happens inside of mutex lock annotations.
name|__tsan_mutex_pre_divert
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prof_mu_
operator|.
name|Lock
argument_list|()
expr_stmt|;
name|prof_data_
operator|++
expr_stmt|;
name|prof_mu_
operator|.
name|Unlock
argument_list|()
expr_stmt|;
name|__tsan_mutex_post_divert
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|Mutex
name|Mutex
operator|::
name|prof_mu_
argument_list|(
name|false
argument_list|,
name|__tsan_mutex_linker_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|Mutex
operator|::
name|prof_data_
expr_stmt|;
end_expr_stmt

end_unit

