begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2008,2009 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/*****************************************************************************  *                                                                           *  *                         B l u e   M o o n                                 *  *                         =================                                 *  *                               V2.2                                        *  *                   A patience game by T.A.Lister                           *  *            Integral screen support by Eric S. Raymond                     *  *                                                                           *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Compile this with the command `cc -O blue.c -lcurses -o blue'.  For best  * results, use the ncurses(3) library.  On non-Intel machines, SVr4 curses is  * just as good.  *  * $Id: blue.c,v 1.33 2009/10/24 21:03:35 tom Exp $  */
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_define
define|#
directive|define
name|NOCARD
value|(-1)
end_define

begin_define
define|#
directive|define
name|ACE
value|0
end_define

begin_define
define|#
directive|define
name|KING
value|12
end_define

begin_define
define|#
directive|define
name|SUIT_LENGTH
value|13
end_define

begin_define
define|#
directive|define
name|HEARTS
value|0
end_define

begin_define
define|#
directive|define
name|SPADES
value|1
end_define

begin_define
define|#
directive|define
name|DIAMONDS
value|2
end_define

begin_define
define|#
directive|define
name|CLUBS
value|3
end_define

begin_define
define|#
directive|define
name|NSUITS
value|4
end_define

begin_define
define|#
directive|define
name|GRID_WIDTH
value|14
end_define

begin_comment
comment|/*    13+1  */
end_comment

begin_define
define|#
directive|define
name|GRID_LENGTH
value|56
end_define

begin_comment
comment|/* 4*(13+1) */
end_comment

begin_define
define|#
directive|define
name|PACK_SIZE
value|52
end_define

begin_define
define|#
directive|define
name|BASEROW
value|1
end_define

begin_define
define|#
directive|define
name|PROMPTROW
value|11
end_define

begin_define
define|#
directive|define
name|RED_ON_WHITE
value|1
end_define

begin_define
define|#
directive|define
name|BLACK_ON_WHITE
value|2
end_define

begin_define
define|#
directive|define
name|BLUE_ON_WHITE
value|3
end_define

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|die
argument_list|(
name|int
name|onsig
argument_list|)
name|GCC_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deck_size
init|=
name|PACK_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial deck */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deck
index|[
name|PACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grid
index|[
name|GRID_LENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* card layout grid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|freeptr
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free card space pointers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deal_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|chtype
name|ranks
index|[
name|SUIT_LENGTH
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|' '
block|,
literal|'A'
block|}
block|,
block|{
literal|' '
block|,
literal|'2'
block|}
block|,
block|{
literal|' '
block|,
literal|'3'
block|}
block|,
block|{
literal|' '
block|,
literal|'4'
block|}
block|,
block|{
literal|' '
block|,
literal|'5'
block|}
block|,
block|{
literal|' '
block|,
literal|'6'
block|}
block|,
block|{
literal|' '
block|,
literal|'7'
block|}
block|,
block|{
literal|' '
block|,
literal|'8'
block|}
block|,
block|{
literal|' '
block|,
literal|'9'
block|}
block|,
block|{
literal|'1'
block|,
literal|'0'
block|}
block|,
block|{
literal|' '
block|,
literal|'J'
block|}
block|,
block|{
literal|' '
block|,
literal|'Q'
block|}
block|,
block|{
literal|' '
block|,
literal|'K'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Please note, that this is a bad example.    Color values should not be or'ed in. This    only works, because the characters used here    are plain and have no color attribute themselves. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLOR_PAIR
end_ifdef

begin_define
define|#
directive|define
name|OR_COLORS
parameter_list|(
name|value
parameter_list|,
name|pair
parameter_list|)
value|((value) | COLOR_PAIR(pair))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OR_COLORS
parameter_list|(
name|value
parameter_list|,
name|pair
parameter_list|)
value|(value)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PC_COLORS
parameter_list|(
name|value
parameter_list|,
name|pair
parameter_list|)
value|(OR_COLORS(value,pair) | A_ALTCHARSET)
end_define

begin_decl_stmt
specifier|static
name|chtype
name|letters
index|[
literal|4
index|]
init|=
block|{
name|OR_COLORS
argument_list|(
literal|'h'
argument_list|,
name|RED_ON_WHITE
argument_list|)
block|,
comment|/* hearts */
name|OR_COLORS
argument_list|(
literal|'s'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
block|,
comment|/* spades */
name|OR_COLORS
argument_list|(
literal|'d'
argument_list|,
name|RED_ON_WHITE
argument_list|)
block|,
comment|/* diamonds */
name|OR_COLORS
argument_list|(
literal|'c'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
block|,
comment|/* clubs */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
name|defined
argument_list|(
name|A_ALTCHARSET
argument_list|)
operator|&&
name|HAVE_TIGETSTR
end_if

begin_decl_stmt
specifier|static
name|chtype
name|glyphs
index|[]
init|=
block|{
name|PC_COLORS
argument_list|(
literal|'\003'
argument_list|,
name|RED_ON_WHITE
argument_list|)
block|,
comment|/* hearts */
name|PC_COLORS
argument_list|(
literal|'\006'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
block|,
comment|/* spades */
name|PC_COLORS
argument_list|(
literal|'\004'
argument_list|,
name|RED_ON_WHITE
argument_list|)
block|,
comment|/* diamonds */
name|PC_COLORS
argument_list|(
literal|'\005'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
block|,
comment|/* clubs */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_CP437
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_CP437
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_decl_stmt
specifier|static
name|chtype
modifier|*
name|suits
init|=
name|letters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this may change to glyphs below */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|die
parameter_list|(
name|int
name|onsig
parameter_list|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|onsig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|deck_size
operator|=
name|PACK_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PACK_SIZE
condition|;
name|i
operator|++
control|)
name|deck
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|freeptr
index|[
name|i
index|]
operator|=
name|i
operator|*
name|GRID_WIDTH
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shuffle
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|numswaps
decl_stmt|,
name|swapnum
decl_stmt|,
name|temp
decl_stmt|;
name|numswaps
operator|=
name|size
operator|*
literal|10
expr_stmt|;
comment|/* an arbitrary figure */
for|for
control|(
name|swapnum
operator|=
literal|0
init|;
name|swapnum
operator|<
name|numswaps
condition|;
name|swapnum
operator|++
control|)
block|{
name|i
operator|=
name|rand
argument_list|()
operator|%
name|size
expr_stmt|;
name|j
operator|=
name|rand
argument_list|()
operator|%
name|size
expr_stmt|;
name|temp
operator|=
name|deck
index|[
name|i
index|]
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|=
name|deck
index|[
name|j
index|]
expr_stmt|;
name|deck
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|deal_cards
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ptr
decl_stmt|,
name|card
init|=
literal|0
decl_stmt|,
name|value
decl_stmt|,
name|csuit
decl_stmt|,
name|crank
decl_stmt|,
name|suit
decl_stmt|,
name|aces
index|[
literal|4
index|]
decl_stmt|;
name|memset
argument_list|(
name|aces
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aces
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|suit
operator|=
name|HEARTS
init|;
name|suit
operator|<=
name|CLUBS
condition|;
name|suit
operator|++
control|)
block|{
name|ptr
operator|=
name|freeptr
index|[
name|suit
index|]
expr_stmt|;
name|grid
index|[
name|ptr
operator|++
index|]
operator|=
name|NOCARD
expr_stmt|;
comment|/* 1st card space is blank */
while|while
condition|(
operator|(
name|ptr
operator|%
name|GRID_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
name|deck
index|[
name|card
operator|++
index|]
expr_stmt|;
name|crank
operator|=
name|value
operator|%
name|SUIT_LENGTH
expr_stmt|;
name|csuit
operator|=
name|value
operator|/
name|SUIT_LENGTH
expr_stmt|;
if|if
condition|(
name|crank
operator|==
name|ACE
condition|)
name|aces
index|[
name|csuit
index|]
operator|=
name|ptr
expr_stmt|;
name|grid
index|[
name|ptr
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deal_number
operator|==
literal|1
condition|)
comment|/* shift the aces down to the 1st column */
for|for
control|(
name|suit
operator|=
name|HEARTS
init|;
name|suit
operator|<=
name|CLUBS
condition|;
name|suit
operator|++
control|)
block|{
name|grid
index|[
name|suit
operator|*
name|GRID_WIDTH
index|]
operator|=
name|suit
operator|*
name|SUIT_LENGTH
expr_stmt|;
name|grid
index|[
name|aces
index|[
name|suit
index|]
index|]
operator|=
name|NOCARD
expr_stmt|;
name|freeptr
index|[
name|suit
index|]
operator|=
name|aces
index|[
name|suit
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printcard
parameter_list|(
name|int
name|value
parameter_list|)
block|{
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NOCARD
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
else|else
block|{
name|addch
argument_list|(
name|ranks
index|[
name|value
operator|%
name|SUIT_LENGTH
index|]
index|[
literal|0
index|]
operator||
name|COLOR_PAIR
argument_list|(
name|BLUE_ON_WHITE
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ranks
index|[
name|value
operator|%
name|SUIT_LENGTH
index|]
index|[
literal|1
index|]
operator||
name|COLOR_PAIR
argument_list|(
name|BLUE_ON_WHITE
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|suits
index|[
name|value
operator|/
name|SUIT_LENGTH
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_cards
parameter_list|(
name|int
name|deal
parameter_list|)
block|{
name|int
name|row
decl_stmt|,
name|card
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Blue Moon 2.1 - by Tim Lister& Eric Raymond - Deal %d.\n"
argument_list|,
name|deal
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|HEARTS
init|;
name|row
operator|<=
name|CLUBS
condition|;
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|BASEROW
operator|+
name|row
operator|+
name|row
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|card
operator|=
literal|0
init|;
name|card
operator|<
name|GRID_WIDTH
condition|;
name|card
operator|++
control|)
name|printcard
argument_list|(
name|grid
index|[
name|row
operator|*
name|GRID_WIDTH
operator|+
name|card
index|]
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|PROMPTROW
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|(void)printw("%s\n", x)
name|P
argument_list|(
literal|"   This 52-card solitaire starts with  the entire deck shuffled and dealt"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"out in four rows.  The aces are then moved to the left end of the layout,"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"making 4 initial free spaces.  You may move to a space only the card that"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"matches the left neighbor in suit, and is one greater in rank.  Kings are"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"high, so no cards may be placed to their right (they create dead spaces)."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"  When no moves can be made,  cards still out of sequence are  reshuffled"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"and dealt face up after the ends of the partial sequences, leaving a card"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"space after each sequence, so that each row looks like a partial sequence"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"followed by a space, followed by enough cards to make a row of 14.       "
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"  A moment's reflection will show that this game cannot take more than 13"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"deals. A good score is 1-3 deals, 4-7 is average, 8 or more is poor.     "
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|P
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|find
parameter_list|(
name|int
name|card
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|card
operator|<
literal|0
operator|)
operator|||
operator|(
name|card
operator|>=
name|PACK_SIZE
operator|)
condition|)
return|return
operator|(
name|NOCARD
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GRID_LENGTH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|grid
index|[
name|i
index|]
operator|==
name|card
condition|)
return|return
name|i
return|;
return|return
operator|(
name|NOCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|movecard
parameter_list|(
name|int
name|src
parameter_list|,
name|int
name|dst
parameter_list|)
block|{
name|grid
index|[
name|dst
index|]
operator|=
name|grid
index|[
name|src
index|]
expr_stmt|;
name|grid
index|[
name|src
index|]
operator|=
name|NOCARD
expr_stmt|;
name|move
argument_list|(
name|BASEROW
operator|+
operator|(
name|dst
operator|/
name|GRID_WIDTH
operator|)
operator|*
literal|2
operator|+
literal|2
argument_list|,
operator|(
name|dst
operator|%
name|GRID_WIDTH
operator|)
operator|*
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|grid
index|[
name|dst
index|]
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|BASEROW
operator|+
operator|(
name|src
operator|/
name|GRID_WIDTH
operator|)
operator|*
literal|2
operator|+
literal|2
argument_list|,
operator|(
name|src
operator|%
name|GRID_WIDTH
operator|)
operator|*
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|grid
index|[
name|src
index|]
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|play_game
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|dead
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|selection
index|[
literal|4
index|]
decl_stmt|,
name|card
decl_stmt|;
while|while
condition|(
name|dead
operator|<
literal|4
condition|)
block|{
name|dead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|card
operator|=
name|grid
index|[
name|freeptr
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|card
operator|%
name|SUIT_LENGTH
operator|)
operator|==
name|KING
operator|)
operator|||
operator|(
name|card
operator|==
name|NOCARD
operator|)
condition|)
name|selection
index|[
name|i
index|]
operator|=
name|NOCARD
expr_stmt|;
else|else
name|selection
index|[
name|i
index|]
operator|=
name|find
argument_list|(
name|card
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|selection
index|[
name|i
index|]
operator|==
name|NOCARD
condition|)
name|dead
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|dead
operator|<
literal|4
condition|)
block|{
name|char
name|live
index|[
name|NSUITS
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|lp
init|=
name|live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|selection
index|[
name|i
index|]
operator|!=
name|NOCARD
condition|)
block|{
name|move
argument_list|(
name|BASEROW
operator|+
operator|(
name|selection
index|[
name|i
index|]
operator|/
name|GRID_WIDTH
operator|)
operator|*
literal|2
operator|+
literal|3
argument_list|,
operator|(
name|selection
index|[
name|i
index|]
operator|%
name|GRID_WIDTH
operator|)
operator|*
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"   %c "
argument_list|,
operator|(
operator|*
name|lp
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
operator|*
name|lp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|live
argument_list|)
operator|==
literal|1
condition|)
block|{
name|move
argument_list|(
name|PROMPTROW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Making forced moves...                                 "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|live
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Type [%s] to move, r to redraw, q or INTR to quit: "
argument_list|,
name|live
argument_list|)
expr_stmt|;
do|do
block|{
name|move
argument_list|(
name|PROMPTROW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|PROMPTROW
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|(
name|char
operator|)
name|getch
argument_list|()
operator|)
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'d'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'q'
operator|)
condition|)
do|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|selection
index|[
name|j
index|]
operator|!=
name|NOCARD
condition|)
block|{
name|move
argument_list|(
name|BASEROW
operator|+
operator|(
name|selection
index|[
name|j
index|]
operator|/
name|GRID_WIDTH
operator|)
operator|*
literal|2
operator|+
literal|3
argument_list|,
operator|(
name|selection
index|[
name|j
index|]
operator|%
name|GRID_WIDTH
operator|)
operator|*
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|display_cards
argument_list|(
name|deal_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'q'
condition|)
name|die
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|c
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|selection
index|[
name|i
index|]
operator|==
name|NOCARD
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|movecard
argument_list|(
name|selection
index|[
name|i
index|]
argument_list|,
name|freeptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|freeptr
index|[
name|i
index|]
operator|=
name|selection
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|move
argument_list|(
name|PROMPTROW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Finished deal %d - type any character to continue..."
argument_list|,
name|deal_number
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_discards
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|cardno
init|=
literal|0
decl_stmt|,
name|finish
decl_stmt|,
name|gridno
decl_stmt|;
for|for
control|(
name|row
operator|=
name|HEARTS
init|;
name|row
operator|<=
name|CLUBS
condition|;
name|row
operator|++
control|)
block|{
name|finish
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|1
init|;
name|col
operator|<
name|GRID_WIDTH
condition|;
name|col
operator|++
control|)
block|{
name|gridno
operator|=
name|row
operator|*
name|GRID_WIDTH
operator|+
name|col
expr_stmt|;
if|if
condition|(
operator|(
name|grid
index|[
name|gridno
index|]
operator|!=
operator|(
name|grid
index|[
name|gridno
operator|-
literal|1
index|]
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|finish
operator|==
literal|0
operator|)
condition|)
block|{
name|finish
operator|=
literal|1
expr_stmt|;
name|freeptr
index|[
name|row
index|]
operator|=
name|gridno
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|finish
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|grid
index|[
name|gridno
index|]
operator|!=
name|NOCARD
operator|)
condition|)
name|deck
index|[
name|cardno
operator|++
index|]
operator|=
name|grid
index|[
name|gridno
index|]
expr_stmt|;
block|}
block|}
return|return
name|cardno
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|game_finished
parameter_list|(
name|int
name|deal
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"You finished the game in %d deals. This is "
argument_list|,
name|deal
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
if|if
condition|(
name|deal
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"excellent"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|deal
operator|<
literal|4
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"good"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|deal
operator|<
literal|8
condition|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"average"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"poor"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|".         "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|CATCHALL
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
comment|/*      * We use COLOR_GREEN because COLOR_BLACK is wired to the wrong thing.      */
name|start_color
argument_list|()
expr_stmt|;
name|init_pair
argument_list|(
name|RED_ON_WHITE
argument_list|,
name|COLOR_RED
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|BLUE_ON_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|BLACK_ON_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COLOR_PAIR
name|letters
index|[
literal|0
index|]
operator|=
name|OR_COLORS
argument_list|(
literal|'h'
argument_list|,
name|RED_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* hearts */
name|letters
index|[
literal|1
index|]
operator|=
name|OR_COLORS
argument_list|(
literal|'s'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* spades */
name|letters
index|[
literal|2
index|]
operator|=
name|OR_COLORS
argument_list|(
literal|'d'
argument_list|,
name|RED_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* diamonds */
name|letters
index|[
literal|3
index|]
operator|=
name|OR_COLORS
argument_list|(
literal|'c'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* clubs */
if|#
directive|if
name|USE_CP437
name|glyphs
index|[
literal|0
index|]
operator|=
name|PC_COLORS
argument_list|(
literal|'\003'
argument_list|,
name|RED_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* hearts */
name|glyphs
index|[
literal|1
index|]
operator|=
name|PC_COLORS
argument_list|(
literal|'\006'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* spades */
name|glyphs
index|[
literal|2
index|]
operator|=
name|PC_COLORS
argument_list|(
literal|'\004'
argument_list|,
name|RED_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* diamonds */
name|glyphs
index|[
literal|3
index|]
operator|=
name|PC_COLORS
argument_list|(
literal|'\005'
argument_list|,
name|BLACK_ON_WHITE
argument_list|)
expr_stmt|;
comment|/* clubs */
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|USE_CP437
if|if
condition|(
name|tigetstr
argument_list|(
literal|"smpch"
argument_list|)
condition|)
name|suits
operator|=
name|glyphs
expr_stmt|;
endif|#
directive|endif
comment|/* USE_CP437 */
name|cbreak
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|srand
argument_list|(
operator|(
name|unsigned
operator|)
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|srand
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|init_vars
argument_list|()
expr_stmt|;
do|do
block|{
name|deal_number
operator|++
expr_stmt|;
name|shuffle
argument_list|(
name|deck_size
argument_list|)
expr_stmt|;
name|deal_cards
argument_list|()
expr_stmt|;
name|display_cards
argument_list|(
name|deal_number
argument_list|)
expr_stmt|;
name|play_game
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|deck_size
operator|=
name|collect_discards
argument_list|()
operator|)
operator|!=
literal|0
condition|)
do|;
name|game_finished
argument_list|(
name|deal_number
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
comment|/*NOTREACHED */
block|}
end_function

begin_comment
comment|/* blue.c ends here */
end_comment

end_unit

