begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INVOKE_HELPERS_H
end_ifndef

begin_define
define|#
directive|define
name|INVOKE_HELPERS_H
end_define

begin_include
include|#
directive|include
file|<type_traits>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|"test_macros.h"
end_include

begin_expr_stmt
name|template
operator|<
name|int
name|I
operator|>
expr|struct
name|Int
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|int
operator|,
name|I
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|P
operator|>
expr|struct
name|Bool
operator|:
name|public
name|std
operator|::
name|integral_constant
operator|<
name|bool
operator|,
name|P
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|Q_None
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|apply
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
empty_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Q_Const
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|apply
block|{
typedef|typedef
name|T
specifier|const
name|type
typedef|;
block|}
empty_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Q_Volatile
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|apply
block|{
typedef|typedef
name|T
specifier|volatile
name|type
typedef|;
block|}
empty_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Q_CV
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|apply
block|{
typedef|typedef
name|T
specifier|const
specifier|volatile
name|type
typedef|;
block|}
empty_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|// Caster - A functor object that performs cv-qualifier and value category
end_comment

begin_comment
comment|//   conversions.
end_comment

begin_comment
comment|//   QualTag - A metafunction type that applies cv-qualifiers to its argument.
end_comment

begin_comment
comment|//   RValue - True if the resulting object should be an RValue reference.
end_comment

begin_comment
comment|//            False otherwise.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|QualTag
operator|,
name|bool
name|RValue
operator|=
name|false
operator|>
expr|struct
name|Caster
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|apply
block|{
typedef|typedef
name|typename
name|std
operator|::
name|remove_reference
operator|<
name|T
operator|>
operator|::
name|type
name|RawType
expr_stmt|;
typedef|typedef
name|typename
name|QualTag
operator|::
name|template
name|apply
operator|<
name|RawType
operator|>
operator|::
name|type
name|CVType
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
end_if

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|conditional
operator|<
name|RValue
operator|,
name|CVType
operator|&&
operator|,
name|CVType
operator|&
operator|>
operator|::
name|type
name|type
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|CVType
modifier|&
name|type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|typename
name|apply
operator|<
name|T
operator|>
operator|::
name|type
name|operator
argument_list|()
operator|(
name|T
operator|&
name|obj
operator|)
specifier|const
block|{
typedef|typedef
name|typename
name|apply
operator|<
name|T
operator|>
operator|::
name|type
name|OutType
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|static_cast
operator|<
name|OutType
operator|>
operator|(
name|obj
operator|)
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_None
operator|>
name|LValueCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_Const
operator|>
name|ConstCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_Volatile
operator|>
name|VolatileCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_CV
operator|>
name|CVCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_None
operator|,
name|true
operator|>
name|MoveCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_Const
operator|,
name|true
operator|>
name|MoveConstCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_Volatile
operator|,
name|true
operator|>
name|MoveVolatileCaster
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Caster
operator|<
name|Q_CV
operator|,
name|true
operator|>
name|MoveCVCaster
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|const
operator|&
name|makeConst
argument_list|(
argument|Tp& ref
argument_list|)
block|{
return|return
name|ref
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|const
operator|*
name|makeConst
argument_list|(
argument|Tp* ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|std
operator|::
name|reference_wrapper
operator|<
specifier|const
name|Tp
operator|>
name|makeConst
argument_list|(
argument|std::reference_wrapper<Tp>& ref
argument_list|)
block|{
return|return
name|std
operator|::
name|reference_wrapper
operator|<
specifier|const
name|Tp
operator|>
operator|(
name|ref
operator|.
name|get
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|volatile
operator|&
name|makeVolatile
argument_list|(
argument|Tp& ref
argument_list|)
block|{
return|return
name|ref
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|volatile
operator|*
name|makeVolatile
argument_list|(
argument|Tp* ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|std
operator|::
name|reference_wrapper
operator|<
specifier|volatile
name|Tp
operator|>
name|makeVolatile
argument_list|(
argument|std::reference_wrapper<Tp>& ref
argument_list|)
block|{
return|return
name|std
operator|::
name|reference_wrapper
operator|<
specifier|volatile
name|Tp
operator|>
operator|(
name|ref
operator|.
name|get
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|const
specifier|volatile
operator|&
name|makeCV
argument_list|(
argument|Tp& ref
argument_list|)
block|{
return|return
name|ref
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|Tp
specifier|const
specifier|volatile
operator|*
name|makeCV
argument_list|(
argument|Tp* ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Tp
operator|>
name|std
operator|::
name|reference_wrapper
operator|<
specifier|const
specifier|volatile
name|Tp
operator|>
name|makeCV
argument_list|(
argument|std::reference_wrapper<Tp>& ref
argument_list|)
block|{
return|return
name|std
operator|::
name|reference_wrapper
operator|<
specifier|const
specifier|volatile
name|Tp
operator|>
operator|(
name|ref
operator|.
name|get
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// A shorter name for 'static_cast'
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|QualType
operator|,
name|class
name|Tp
operator|>
name|QualType
name|C_
argument_list|(
argument|Tp& v
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|QualType
operator|>
operator|(
name|v
operator|)
return|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//==============================================================================
end_comment

begin_comment
comment|// ArgType - A non-copyable type intended to be used as a dummy argument type
end_comment

begin_comment
comment|//   to test functions.
end_comment

begin_struct
struct|struct
name|ArgType
block|{
name|int
name|value
decl_stmt|;
name|explicit
name|ArgType
argument_list|(
argument|int val =
literal|0
argument_list|)
block|:
name|value
argument_list|(
argument|val
argument_list|)
block|{}
name|private
label|:
name|ArgType
argument_list|(
name|ArgType
specifier|const
operator|&
argument_list|)
expr_stmt|;
name|ArgType
modifier|&
name|operator
init|=
operator|(
name|ArgType
specifier|const
operator|&
operator|)
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|//==============================================================================
end_comment

begin_comment
comment|// DerivedFromBase - A type that derives from its template argument 'Base'
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Base
operator|>
expr|struct
name|DerivedFromType
operator|:
name|public
name|Base
block|{
name|DerivedFromType
argument_list|()
operator|:
name|Base
argument_list|()
block|{}
name|template
operator|<
name|class
name|Tp
operator|>
name|explicit
name|DerivedFromType
argument_list|(
name|Tp
specifier|const
operator|&
name|t
argument_list|)
operator|:
name|Base
argument_list|(
argument|t
argument_list|)
block|{}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|//==============================================================================
end_comment

begin_comment
comment|// DerefToType - A type that dereferences to its template argument 'To'.
end_comment

begin_comment
comment|//   The cv-ref qualifiers of the 'DerefToType' object do not propagate
end_comment

begin_comment
comment|//   to the resulting 'To' object.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|To
operator|>
expr|struct
name|DerefToType
block|{
name|To
name|object
block|;
name|DerefToType
argument_list|()
block|{}
name|template
operator|<
name|class
name|Up
operator|>
name|explicit
name|DerefToType
argument_list|(
name|Up
specifier|const
operator|&
name|val
argument_list|)
operator|:
name|object
argument_list|(
argument|val
argument_list|)
block|{}
name|To
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
specifier|volatile
block|{
return|return
name|const_cast
operator|<
name|To
operator|&
operator|>
operator|(
name|object
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|//==============================================================================
end_comment

begin_comment
comment|// DerefPropToType - A type that dereferences to its template argument 'To'.
end_comment

begin_comment
comment|//   The cv-ref qualifiers of the 'DerefPropToType' object propagate
end_comment

begin_comment
comment|//   to the resulting 'To' object.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|To
operator|>
expr|struct
name|DerefPropType
block|{
name|To
name|object
block|;
name|DerefPropType
argument_list|()
block|{}
name|template
operator|<
name|class
name|Up
operator|>
name|explicit
name|DerefPropType
argument_list|(
name|Up
specifier|const
operator|&
name|val
argument_list|)
operator|:
name|object
argument_list|(
argument|val
argument_list|)
block|{}
if|#
directive|if
name|TEST_STD_VER
operator|<
literal|11
name|To
operator|&
name|operator
operator|*
operator|(
operator|)
block|{
return|return
name|object
return|;
block|}
name|To
specifier|const
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|volatile
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|volatile
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|const
specifier|volatile
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
specifier|volatile
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|To
operator|&
name|operator
operator|*
operator|(
operator|)
operator|&
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|const
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
operator|&
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|volatile
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|volatile
operator|&
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|const
specifier|volatile
operator|&
name|operator
operator|*
operator|(
operator|)
specifier|const
specifier|volatile
operator|&
block|{
return|return
name|object
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
operator|&&
name|operator
operator|*
operator|(
operator|)
operator|&&
block|{
return|return
name|static_cast
operator|<
name|To
operator|&&
operator|>
operator|(
name|object
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|const
operator|&&
name|operator
operator|*
operator|(
operator|)
specifier|const
operator|&&
block|{
return|return
name|static_cast
operator|<
name|To
specifier|const
operator|&&
operator|>
operator|(
name|object
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|volatile
operator|&&
name|operator
operator|*
operator|(
operator|)
specifier|volatile
operator|&&
block|{
return|return
name|static_cast
operator|<
name|To
specifier|volatile
operator|&&
operator|>
operator|(
name|object
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|To
specifier|const
specifier|volatile
operator|&&
name|operator
operator|*
operator|(
operator|)
specifier|const
specifier|volatile
operator|&&
block|{
return|return
name|static_cast
operator|<
name|To
specifier|const
specifier|volatile
operator|&&
operator|>
operator|(
name|object
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|};
comment|//==============================================================================
end_comment

begin_comment
comment|// MethodID - A type that uniquely identifies a member function for a class.
end_comment

begin_comment
comment|//   This type is used to communicate between the member functions being tested
end_comment

begin_comment
comment|//   and the tests invoking them.
end_comment

begin_comment
comment|// - Test methods should call 'setUncheckedCall()' whenever they are invoked.
end_comment

begin_comment
comment|// - Tests consume the unchecked call using checkCall(<return-value>)` to assert
end_comment

begin_comment
comment|//   that the method has been called and that the return value of `__invoke`
end_comment

begin_comment
comment|//   matches what the method actually returned.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|MethodID
block|{
typedef|typedef
name|void
modifier|*
name|IDType
typedef|;
specifier|static
name|int
name|dummy
expr_stmt|;
end_expr_stmt

begin_comment
comment|// A dummy memory location.
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The "ID" is the value of this pointer.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|unchecked_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Has a call happened that has not been checked.
end_comment

begin_function
specifier|static
name|void
modifier|*
modifier|&
name|setUncheckedCall
parameter_list|()
block|{
name|assert
argument_list|(
name|unchecked_call
operator|==
name|false
argument_list|)
expr_stmt|;
name|unchecked_call
operator|=
name|true
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|checkCalled
parameter_list|(
name|void
modifier|*
modifier|&
name|return_value
parameter_list|)
block|{
name|bool
name|old
init|=
name|unchecked_call
decl_stmt|;
name|unchecked_call
operator|=
name|false
expr_stmt|;
return|return
name|old
operator|&&
name|id
operator|==
name|return_value
operator|&&
operator|&
name|id
operator|==
operator|&
name|return_value
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
name|int
name|MethodID
operator|<
name|T
operator|>
operator|::
name|dummy
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|void
operator|*
name|MethodID
operator|<
name|T
operator|>
operator|::
name|id
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|MethodID
operator|<
name|T
operator|>
operator|::
name|dummy
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|bool
name|MethodID
operator|<
name|T
operator|>
operator|::
name|unchecked_call
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_comment
comment|//==============================================================================
end_comment

begin_comment
comment|// FunctionPtrID - Like MethodID but for free function pointers.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|T
operator|*
operator|>
expr|struct
name|FunctionPtrID
block|{
specifier|static
name|int
name|dummy
block|;
comment|// A dummy memory location.
specifier|static
name|void
operator|*
name|id
block|;
comment|// The "ID" is the value of this pointer.
specifier|static
name|bool
name|unchecked_call
block|;
comment|// Has a call happened that has not been checked.
specifier|static
name|void
operator|*
operator|&
name|setUncheckedCall
argument_list|()
block|{
name|assert
argument_list|(
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|unchecked_call
operator|=
name|true
block|;
return|return
name|id
return|;
block|}
specifier|static
name|bool
name|checkCalled
argument_list|(
argument|void*& return_value
argument_list|)
block|{
name|bool
name|old
operator|=
name|unchecked_call
block|;
name|unchecked_call
operator|=
name|false
block|;
return|return
name|old
operator|&&
name|id
operator|==
name|return_value
operator|&&
operator|&
name|id
operator|==
operator|&
name|return_value
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|,
name|T
operator|*
name|Ptr
operator|>
name|int
name|FunctionPtrID
operator|<
name|T
operator|,
name|Ptr
operator|>
operator|::
name|dummy
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|T
operator|*
name|Ptr
operator|>
name|void
operator|*
name|FunctionPtrID
operator|<
name|T
operator|,
name|Ptr
operator|>
operator|::
name|id
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|FunctionPtrID
operator|<
name|T
operator|,
name|Ptr
operator|>
operator|::
name|dummy
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|T
operator|*
name|Ptr
operator|>
name|bool
name|FunctionPtrID
operator|<
name|T
operator|,
name|Ptr
operator|>
operator|::
name|unchecked_call
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_comment
comment|//==============================================================================
end_comment

begin_comment
comment|// BasicTest - The basic test structure for everything except
end_comment

begin_comment
comment|// member object pointers.
end_comment

begin_comment
comment|// ID - The "Function Identifier" type used either MethodID or FunctionPtrID.
end_comment

begin_comment
comment|// Arity - The Arity of the call signature.
end_comment

begin_comment
comment|// ObjectCaster - The object transformation functor type.
end_comment

begin_comment
comment|// ArgCaster - The extra argument transformation functor type.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ID
operator|,
name|int
name|Arity
operator|,
name|class
name|ObjectCaster
operator|=
name|LValueCaster
operator|,
name|class
name|ArgCaster
operator|=
name|LValueCaster
operator|>
expr|struct
name|BasicTest
block|{
name|template
operator|<
name|class
name|ObjectT
operator|>
name|void
name|runTest
argument_list|(
argument|ObjectT& object
argument_list|)
block|{
name|Int
operator|<
name|Arity
operator|>
name|A
block|;
name|runTestImp
argument_list|(
name|A
argument_list|,
name|object
argument_list|)
block|;     }
name|template
operator|<
name|class
name|MethodPtr
block|,
name|class
name|ObjectT
operator|>
name|void
name|runTest
argument_list|(
argument|MethodPtr ptr
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
name|Int
operator|<
name|Arity
operator|>
name|A
block|;
name|runTestImp
argument_list|(
name|A
argument_list|,
name|ptr
argument_list|,
name|object
argument_list|)
block|;     }
name|private
operator|:
typedef|typedef
name|void
modifier|*
modifier|&
name|CallRet
typedef|;
name|ObjectCaster
name|object_cast
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ArgCaster
name|arg_cast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ArgType
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_comment
comment|//==========================================================================
end_comment

begin_comment
comment|//                       BULLET 1, 2 AND 3 TEST METHODS
end_comment

begin_comment
comment|//==========================================================================
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|MethodPtr
operator|,
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|0
argument|>
argument_list|,
argument|MethodPtr ptr
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|MethodPtr
operator|,
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|1
argument|>
argument_list|,
argument|MethodPtr ptr
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|MethodPtr
operator|,
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|2
argument|>
argument_list|,
argument|MethodPtr ptr
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|MethodPtr
operator|,
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|3
argument|>
argument_list|,
argument|MethodPtr ptr
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|ptr
argument_list|,
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
comment|//==========================================================================
comment|//                       BULLET 7 TEST METHODS
comment|//==========================================================================
name|template
operator|<
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|0
argument|>
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|1
argument|>
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|2
argument|>
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
name|template
operator|<
name|class
name|ObjectT
operator|>
name|void
name|runTestImp
argument_list|(
argument|Int<
literal|3
argument|>
argument_list|,
argument|ObjectT& object
argument_list|)
block|{
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
if|#
directive|if
name|TEST_STD_VER
operator|>=
literal|11
block|{
name|static_assert
argument_list|(
operator|(
name|std
operator|::
name|is_same
operator|<
name|decltype
argument_list|(
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|)
operator|,
name|CallRet
operator|>
operator|::
name|value
operator|)
argument_list|,
literal|""
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|unchecked_call
operator|==
name|false
argument_list|)
block|;
name|CallRet
name|ret
operator|=
name|std
operator|::
name|__invoke_constexpr
argument_list|(
name|object_cast
argument_list|(
name|object
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a0
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a1
argument_list|)
argument_list|,
name|arg_cast
argument_list|(
name|a2
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|ID
operator|::
name|checkCalled
argument_list|(
name|ret
argument_list|)
argument_list|)
block|;         }
endif|#
directive|endif
block|}
end_expr_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|// INVOKE_HELPERS_H
end_comment

end_unit

