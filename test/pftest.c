begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 2009 by David M. Gay All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all source-code copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation.  THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"stdio1.h"
end_include

begin_include
include|#
directive|include
file|"gdtoa.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_undef
undef|#
directive|undef
name|allow_Quad
end_undef

begin_undef
undef|#
directive|undef
name|want_Quad
end_undef

begin_undef
undef|#
directive|undef
name|want_Ux
end_undef

begin_define
define|#
directive|define
name|want_LD
end_define

begin_typedef
typedef|typedef
union|union
name|Ud
block|{
name|double
name|x
decl_stmt|;
name|unsigned
name|int
name|u
index|[
literal|2
index|]
decl_stmt|;
block|}
name|Ud
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__x86_64
end_ifdef

begin_comment
comment|/*{{*/
end_comment

begin_define
define|#
directive|define
name|want_Ux
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_GDTOA_i386_Quad
end_ifndef

begin_comment
comment|/*{*/
end_comment

begin_typedef
typedef|typedef
union|union
name|UQ
block|{
name|__float128
name|x
decl_stmt|;
name|unsigned
name|int
name|u
index|[
literal|4
index|]
decl_stmt|;
block|}
name|UQ
typedef|;
end_typedef

begin_define
define|#
directive|define
name|allow_Quad
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|want_Quad
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*}{*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386
end_ifdef

begin_comment
comment|/*{{*/
end_comment

begin_define
define|#
directive|define
name|want_Ux
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*}{*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc
end_ifdef

begin_comment
comment|/*{{*/
end_comment

begin_typedef
typedef|typedef
union|union
name|UQ
block|{
name|long
name|double
name|x
decl_stmt|;
name|unsigned
name|int
name|u
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Ux
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*}{*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__INTEL_COMPILER
end_ifdef

begin_comment
comment|/*{*/
end_comment

begin_undef
undef|#
directive|undef
name|want_Quad
end_undef

begin_undef
undef|#
directive|undef
name|want_Ux
end_undef

begin_undef
undef|#
directive|undef
name|want_LD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|allow_Quad
end_ifndef

begin_define
define|#
directive|define
name|allow_Quad
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/*nothing*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|want_Ux
end_ifdef

begin_comment
comment|/*{{*/
end_comment

begin_typedef
typedef|typedef
union|union
name|Ux
block|{
name|long
name|double
name|x
decl_stmt|;
name|unsigned
name|short
name|u
index|[
literal|5
index|]
decl_stmt|;
block|}
name|Ux
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*}{*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc
end_ifdef

begin_define
define|#
directive|define
name|want_Ux
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|Ud
name|d
decl_stmt|;
name|allow_Quad
argument_list|(
argument|UQ q;
argument_list|)
name|char
modifier|*
name|b
decl_stmt|,
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|fmt
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|want_Ux
name|Ux
name|x
decl_stmt|;
name|x
operator|.
name|x
operator|=
literal|0.
expr_stmt|;
endif|#
directive|endif
name|int
name|k
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"%.g"
argument_list|)
expr_stmt|;
name|d
operator|.
name|x
operator|=
literal|0.
expr_stmt|;
name|allow_Quad
argument_list|(
argument|q.x =
literal|0.
argument|;
argument_list|)
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
for|for
control|(
name|b
operator|=
name|buf
init|;
operator|*
name|b
operator|&&
operator|*
name|b
operator|!=
literal|'\n'
condition|;
operator|++
name|b
control|)
empty_stmt|;
operator|*
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|buf
condition|)
continue|continue;
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|==
literal|'%'
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|*
name|b
operator|>
literal|' '
condition|;
operator|++
name|b
control|)
ifdef|#
directive|ifdef
name|want_LD
comment|/*{{*/
switch|switch
condition|(
operator|*
name|b
condition|)
block|{
case|case
literal|'L'
case|:
name|k
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|want_Quad
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|k
operator|>=
literal|1
condition|)
name|k
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/*}{*/
empty_stmt|;
endif|#
directive|endif
comment|/*}}*/
if|if
condition|(
operator|*
name|b
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|-
name|buf
operator|<
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|fmt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|b
condition|)
block|{
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
name|d
operator|.
name|x
operator|=
name|strtod
argument_list|(
name|b
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|want_Ux
ifdef|#
directive|ifdef
name|__sparc
name|strtopQ
argument_list|(
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|x
operator|.
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|strtopx
argument_list|(
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|x
operator|.
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|strtopQ
argument_list|(
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|allow_Quad
argument_list|(
argument|case
literal|2
argument|: strtopQ(b,&s,&q.x);
argument_list|)
block|}
if|if
condition|(
operator|*
name|s
condition|)
name|printf
argument_list|(
literal|"Ignoring \"%s\"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"d.x = %.g = #%x %x; %s ==> "
argument_list|,
name|d
operator|.
name|x
argument_list|,
name|d
operator|.
name|u
index|[
literal|1
index|]
argument_list|,
name|d
operator|.
name|u
index|[
literal|0
index|]
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
name|d
operator|.
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|__sparc
name|printf
argument_list|(
literal|"x.x = %.Lg = #%x %x %x %x; %s ==> "
argument_list|,
name|x
operator|.
name|x
argument_list|,
name|x
operator|.
name|u
index|[
literal|0
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|2
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|3
index|]
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"x.x = %.Lg = #%x %x %x %x %x; %s ==> "
argument_list|,
name|x
operator|.
name|x
argument_list|,
name|x
operator|.
name|u
index|[
literal|4
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|3
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|2
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|u
index|[
literal|0
index|]
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|fmt
argument_list|,
name|x
operator|.
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|want_Quad
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"q.x = %.Lqg = #%x %x %x %x; %s ==> "
argument_list|,
name|q
operator|.
name|x
argument_list|,
name|q
operator|.
name|u
index|[
literal|3
index|]
argument_list|,
name|q
operator|.
name|u
index|[
literal|2
index|]
argument_list|,
name|q
operator|.
name|u
index|[
literal|1
index|]
argument_list|,
name|q
operator|.
name|u
index|[
literal|0
index|]
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

