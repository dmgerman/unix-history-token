begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_struct
struct|struct
name|A
block|{
name|int
name|a_member
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|inline
name|int
name|use_a
parameter_list|(
name|A
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|a_member
return|;
block|}
end_function

begin_decl_stmt
name|class
name|B
block|{
struct|struct
name|Inner1
block|{}
struct|;
name|public
label|:
struct_decl|struct
name|Inner2
struct_decl|;
struct_decl|struct
name|Inner3
struct_decl|;
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|f
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|BFriend
block|{
name|friend
name|class
name|B
operator|::
name|Inner3
expr_stmt|;
name|private
label|:
struct|struct
name|Inner3Base
block|{}
struct|;
block|}
struct|;
end_struct

begin_comment
comment|// Check that lookup and access checks are performed in the right context.
end_comment

begin_expr_stmt
unit|struct
name|B
operator|::
name|Inner2
operator|:
name|Inner1
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|struct
name|B
operator|::
name|Inner3
operator|:
name|BFriend
operator|::
name|Inner3Base
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|B
operator|::
name|f
argument_list|()
block|{}
name|template
operator|<
operator|>
specifier|inline
name|void
name|B
operator|::
name|f
operator|<
name|int
operator|>
operator|(
operator|)
block|{}
comment|// Check that base-specifiers are correctly disambiguated.
name|template
operator|<
name|int
name|N
operator|>
expr|struct
name|C_Base
block|{ struct
name|D
block|{
name|constexpr
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|};
specifier|const
name|int
name|C_Const
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|C1
range|:
name|C_Base
operator|<
name|C_Base
operator|<
literal|0
operator|>
operator|::
name|D
block|{}
operator|>
block|{}
specifier|extern
name|c1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|C2
range|:
name|C_Base
operator|<
name|C_Const
operator|<
literal|0
operator|>
operator|::
name|D
block|{}
specifier|extern
name|c2
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|a
decl_stmt|;
name|void
name|f
parameter_list|()
function_decl|;
struct_decl|struct
name|X
struct_decl|;
block|}
name|D
typedef|;
end_typedef

begin_expr_stmt
unit|struct
name|D
operator|::
name|X
block|{
name|int
name|dx
block|; }
specifier|extern
name|dx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|inline
name|int
name|use_dx
argument_list|(
name|D
operator|::
name|X
name|dx
argument_list|)
block|{
return|return
name|dx
operator|.
name|dx
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|E
argument_list|(
argument|T t
argument_list|)
block|{
return|return
name|t
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|F
block|{
name|int
name|f
argument_list|()
block|;
name|template
operator|<
name|typename
name|U
operator|>
name|int
name|g
argument_list|()
block|;
specifier|static
name|int
name|n
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|F
operator|<
name|T
operator|>
operator|::
name|f
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|template
operator|<
name|typename
name|U
operator|>
name|int
name|F
operator|<
name|T
operator|>
operator|::
name|g
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|F
operator|<
name|T
operator|>
operator|::
name|n
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
specifier|inline
name|int
name|F
operator|<
name|char
operator|>
operator|::
name|f
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|U
operator|>
name|int
name|F
operator|<
name|char
operator|>
operator|::
name|g
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|F
operator|<
name|void
operator|>
block|{
name|int
name|h
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|F
operator|<
name|void
operator|>
operator|::
name|h
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|F
operator|<
name|T
operator|*
operator|>
block|{
name|int
name|i
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|int
name|F
operator|<
name|T
operator|*
operator|>
operator|::
name|i
argument_list|()
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|namespace
name|G
block|{
enum|enum
name|A
block|{
name|a
block|,
name|b
block|,
name|c
block|,
name|d
block|,
name|e
block|}
enum|;
enum|enum
block|{
name|f
block|,
name|g
block|,
name|h
block|}
enum|;
typedef|typedef
enum|enum
block|{
name|i
block|,
name|j
block|}
name|k
typedef|;
typedef|typedef
enum|enum
block|{}
name|l
typedef|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|=
name|int
operator|,
name|int
name|N
operator|=
literal|3
operator|,
name|template
operator|<
name|typename
operator|>
name|class
name|K
operator|=
name|F
operator|>
name|int
name|H
argument_list|(
argument|int a =
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|=
name|int
operator|,
name|int
name|N
operator|=
literal|3
operator|,
name|template
operator|<
name|typename
operator|>
name|class
name|K
operator|=
name|F
operator|>
name|using
name|I
operator|=
name|decltype
argument_list|(
name|H
operator|<
name|T
argument_list|,
name|N
argument_list|,
name|K
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|=
name|int
operator|,
name|int
name|N
operator|=
literal|3
operator|,
name|template
operator|<
name|typename
operator|>
name|class
name|K
operator|=
name|F
operator|>
expr|struct
name|J
block|{}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|NS
block|{
struct|struct
name|A
block|{}
struct|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|B
operator|:
name|A
block|{}
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|B
operator|<
name|T
operator|*
operator|>
operator|:
name|B
operator|<
name|char
operator|>
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|B
operator|<
name|int
operator|>
operator|:
name|B
operator|<
name|int
operator|*
operator|>
block|{}
expr_stmt|;
specifier|inline
name|void
name|f
parameter_list|()
block|{}
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|StaticInline
block|{
struct|struct
name|X
block|{}
struct|;
specifier|static
specifier|inline
name|void
name|f
parameter_list|(
name|X
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|void
name|g
parameter_list|(
name|X
name|x
parameter_list|)
block|{
name|f
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|FriendDefArg
block|{
name|template
operator|<
name|typename
operator|=
name|int
operator|>
expr|struct
name|A
expr_stmt|;
name|template
operator|<
name|int
operator|=
literal|0
operator|>
expr|struct
name|B
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|typename
operator|>
name|class
operator|=
name|A
operator|>
expr|struct
name|C
expr_stmt|;
name|template
operator|<
name|typename
operator|=
name|int
operator|,
name|int
operator|=
literal|0
operator|,
name|template
operator|<
name|typename
operator|>
name|class
operator|=
name|A
operator|>
expr|struct
name|D
block|{}
expr_stmt|;
name|template
operator|<
name|typename
name|U
operator|>
expr|struct
name|Y
block|{
name|template
operator|<
name|typename
operator|>
name|friend
expr|struct
name|A
block|;
name|template
operator|<
name|int
operator|>
name|friend
expr|struct
name|B
block|;
name|template
operator|<
name|template
operator|<
name|typename
operator|>
name|class
operator|>
name|friend
expr|struct
name|C
block|;
name|template
operator|<
name|typename
block|,
name|int
block|,
name|template
operator|<
name|typename
operator|>
name|class
operator|>
name|friend
expr|struct
name|D
block|;   }
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|SeparateInline
block|{
specifier|inline
name|void
name|f
parameter_list|()
function_decl|;
name|void
name|f
parameter_list|()
block|{}
name|constexpr
name|int
name|g
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|TrailingAttributes
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|X
block|{}
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|8
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|MergeFunctionTemplateSpecializations
block|{
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|f
argument_list|()
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|X
block|{
name|template
operator|<
name|typename
name|U
operator|>
name|using
name|Q
operator|=
name|decltype
argument_list|(
name|f
operator|<
name|T
operator|>
operator|(
operator|)
operator|+
name|U
argument_list|()
argument_list|)
block|;   }
expr_stmt|;
name|using
name|xiq
init|=
name|X
operator|<
name|int
operator|>
operator|::
name|Q
operator|<
name|int
operator|>
decl_stmt|;
block|}
end_decl_stmt

begin_enum_decl
enum_decl|enum
name|ScopedEnum
enum_decl|:
name|int
enum_decl|;
end_enum_decl

begin_enum
enum|enum
name|ScopedEnum
enum|:
name|int
block|{
name|a
block|,
name|b
block|,
name|c
block|}
enum|;
end_enum

begin_decl_stmt
name|namespace
name|RedeclDifferentDeclKind
block|{
struct|struct
name|X
block|{}
struct|;
typedef|typedef
name|X
name|X
typedef|;
name|using
name|RedeclDifferentDeclKind
operator|::
name|X
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|Anon
block|{
struct|struct
name|X
block|{
union|union
block|{
name|int
name|n
decl_stmt|;
block|}
union|;
block|}
struct|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|ClassTemplatePartialSpec
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|F
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|int
operator|>
name|class
name|A
operator|,
name|int
name|B
operator|>
expr|struct
name|F
operator|<
name|A
operator|<
name|B
operator|>>
block|{
name|template
operator|<
name|typename
name|C
operator|>
name|F
argument_list|()
block|;   }
expr_stmt|;
name|template
operator|<
name|template
operator|<
name|int
operator|>
name|class
name|A
operator|,
name|int
name|B
operator|>
name|template
operator|<
name|typename
name|C
operator|>
name|F
operator|<
name|A
operator|<
name|B
operator|>>
operator|::
name|F
argument_list|()
block|{}
name|template
operator|<
name|typename
name|A
operator|,
name|int
name|B
operator|>
expr|struct
name|F
operator|<
name|A
index|[
name|B
index|]
operator|>
block|{
name|template
operator|<
name|typename
name|C
operator|>
name|F
argument_list|()
block|;   }
expr_stmt|;
name|template
operator|<
name|typename
name|A
operator|,
name|int
name|B
operator|>
name|template
operator|<
name|typename
name|C
operator|>
name|F
operator|<
name|A
index|[
name|B
index|]
operator|>
operator|::
name|F
argument_list|()
block|{}
block|}
end_decl_stmt

begin_struct
struct|struct
name|MemberClassTemplate
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|A
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|MemberClassTemplate
operator|::
name|A
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|MemberClassTemplate
operator|::
name|A
operator|<
name|T
operator|*
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|MemberClassTemplate
operator|::
name|A
operator|<
name|int
operator|>
block|{}
expr_stmt|;
end_expr_stmt

end_unit

