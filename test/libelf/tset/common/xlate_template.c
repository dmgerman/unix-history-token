begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006,2010-2011 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: xlate_template.c 2586 2012-09-15 14:32:47Z jkoshy $  */
end_comment

begin_comment
comment|/*  * Boilerplate for testing the *_xlate() functions.  *  * Usage:  *  * #define	TS_XLATESZ	32 (or 64)  * #include	"xlate_template.c"  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_define
define|#
directive|define
name|__XCONCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__CONCAT(x,y)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__XSTRING
end_ifndef

begin_define
define|#
directive|define
name|__XSTRING
parameter_list|(
name|x
parameter_list|)
value|__STRING(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|TS_XLATETOF
value|__XCONCAT(elf,__XCONCAT(TS_XLATESZ,_xlatetof))
end_define

begin_define
define|#
directive|define
name|TS_XLATETOM
value|__XCONCAT(elf,__XCONCAT(TS_XLATESZ,_xlatetom))
end_define

begin_define
define|#
directive|define
name|BYTE_VAL
value|0xFF
end_define

begin_define
define|#
directive|define
name|BYTE_SEQ_LSB
value|0xFF,
end_define

begin_define
define|#
directive|define
name|BYTE_SEQ_MSB
value|0xFF,
end_define

begin_define
define|#
directive|define
name|HALF_VAL
value|0xFEDC
end_define

begin_define
define|#
directive|define
name|HALF_SEQ_LSB
value|0xDC,0xFE,
end_define

begin_define
define|#
directive|define
name|HALF_SEQ_MSB
value|0xFE,0xDC,
end_define

begin_define
define|#
directive|define
name|WORD_VAL
value|0xFEDCBA98UL
end_define

begin_define
define|#
directive|define
name|WORD_SEQ_LSB
value|0x98,0xBA,0xDC,0xFE,
end_define

begin_define
define|#
directive|define
name|WORD_SEQ_MSB
value|0xFE,0xDC,0xBA,0x98,
end_define

begin_define
define|#
directive|define
name|QUAD_VAL
value|0xFEDCBA9876543210ULL
end_define

begin_define
define|#
directive|define
name|QUAD_SEQ_LSB
value|0x10,0x32,0x54,0x76,\ 	0x98,0xBA,0xDC,0xFE,
end_define

begin_define
define|#
directive|define
name|QUAD_SEQ_MSB
value|0xFE,0xDC,0xBA,0x98,\ 	0x76,0x54,0x32,0x10,
end_define

begin_define
define|#
directive|define
name|IDENT_BYTES
value|46,33,46,64,46,35,46,36,46,37,46,94,46,38,46,42
end_define

begin_define
define|#
directive|define
name|IDENT_VAL
value|{ IDENT_BYTES }
end_define

begin_define
define|#
directive|define
name|IDENT_SEQ_LSB
value|IDENT_BYTES,
end_define

begin_define
define|#
directive|define
name|IDENT_SEQ_MSB
value|IDENT_BYTES,
end_define

begin_define
define|#
directive|define
name|TYPEDEFNAME
parameter_list|(
name|E
parameter_list|,
name|N
parameter_list|)
value|__XCONCAT(__XCONCAT(td_,		\ 	__XCONCAT(E,TS_XLATESZ)), __XCONCAT(_,N))
end_define

begin_define
define|#
directive|define
name|TYPEDEFINITION
parameter_list|(
name|E
parameter_list|,
name|N
parameter_list|)
value|__XCONCAT(ELF_TYPE_E,__XCONCAT(TS_XLATESZ,	\ 	__XCONCAT(_, N)))
end_define

begin_define
define|#
directive|define
name|CHKFNNAME
parameter_list|(
name|N
parameter_list|)
value|__XCONCAT(__XCONCAT(td_chk_,TS_XLATESZ),	\ 	__XCONCAT(_,N))
end_define

begin_define
define|#
directive|define
name|MEMSIZENAME
parameter_list|(
name|N
parameter_list|)
value|__XCONCAT(N,__XCONCAT(TS_XLATESZ,_SIZE))
end_define

begin_define
define|#
directive|define
name|MEMSTRUCTNAME
parameter_list|(
name|N
parameter_list|)
value|__XCONCAT(N,__XCONCAT(TS_XLATESZ,_mem))
end_define

begin_comment
comment|/*  * Definitions of 32 bit ELF file structures.  */
end_comment

begin_define
define|#
directive|define
name|ELF_TYPE_E32_CAP
parameter_list|()
define|\
value|MEMBER(c_tag,		WORD)		\ 	MEMBER(c_un.c_val,	WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_DYN
parameter_list|()
define|\
value|MEMBER(d_tag,		WORD)		\ 	MEMBER(d_un.d_val,	WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_EHDR
parameter_list|()
define|\
value|MEMBER(e_ident,		IDENT)		\ 	MEMBER(e_type,		HALF)		\ 	MEMBER(e_machine,	HALF)		\ 	MEMBER(e_version,	WORD)		\ 	MEMBER(e_entry,		WORD)		\ 	MEMBER(e_phoff,		WORD)		\ 	MEMBER(e_shoff,		WORD)		\ 	MEMBER(e_flags,		WORD)		\ 	MEMBER(e_ehsize,	HALF)		\ 	MEMBER(e_phentsize,	HALF)		\ 	MEMBER(e_phnum,		HALF)		\ 	MEMBER(e_shentsize,	HALF)		\ 	MEMBER(e_shnum,		HALF)		\ 	MEMBER(e_shstrndx,	HALF)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_MOVE
parameter_list|()
define|\
value|MEMBER(m_value,		QUAD)		\ 	MEMBER(m_info,		WORD)		\ 	MEMBER(m_poffset,	WORD)		\ 	MEMBER(m_repeat,	HALF)		\ 	MEMBER(m_stride,	HALF)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_PHDR
parameter_list|()
define|\
value|MEMBER(p_type,		WORD)		\ 	MEMBER(p_offset,	WORD)		\ 	MEMBER(p_vaddr,		WORD)		\ 	MEMBER(p_paddr,		WORD)		\ 	MEMBER(p_filesz,	WORD)		\ 	MEMBER(p_memsz,		WORD)		\ 	MEMBER(p_flags,		WORD)		\ 	MEMBER(p_align,		WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_REL
parameter_list|()
define|\
value|MEMBER(r_offset,	WORD)		\ 	MEMBER(r_info,		WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_RELA
parameter_list|()
define|\
value|MEMBER(r_offset,	WORD)		\ 	MEMBER(r_info,		WORD)		\ 	MEMBER(r_addend,	WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_SHDR
parameter_list|()
define|\
value|MEMBER(sh_name,		WORD)		\ 	MEMBER(sh_type,		WORD)		\ 	MEMBER(sh_flags,	WORD)		\ 	MEMBER(sh_addr,		WORD)		\ 	MEMBER(sh_offset,	WORD)		\ 	MEMBER(sh_size,		WORD)		\ 	MEMBER(sh_link,		WORD)		\ 	MEMBER(sh_info,		WORD)		\ 	MEMBER(sh_addralign,	WORD)		\ 	MEMBER(sh_entsize,	WORD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_SYM
parameter_list|()
define|\
value|MEMBER(st_name,		WORD)		\ 	MEMBER(st_value,	WORD)		\ 	MEMBER(st_size,		WORD)		\ 	MEMBER(st_info,		BYTE)		\ 	MEMBER(st_other,	BYTE)		\ 	MEMBER(st_shndx,	HALF)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E32_SYMINFO
parameter_list|()
define|\
value|MEMBER(si_boundto,	HALF)		\ 	MEMBER(si_flags,	HALF)
end_define

begin_comment
comment|/*  * Definitions of 64 bit ELF file structures.  */
end_comment

begin_define
define|#
directive|define
name|ELF_TYPE_E64_CAP
parameter_list|()
define|\
value|MEMBER(c_tag,		QUAD)		\ 	MEMBER(c_un.c_val,	QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_DYN
parameter_list|()
define|\
value|MEMBER(d_tag,		QUAD)		\ 	MEMBER(d_un.d_val,	QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_EHDR
parameter_list|()
define|\
value|MEMBER(e_ident,		IDENT)		\ 	MEMBER(e_type,		HALF)		\ 	MEMBER(e_machine,	HALF)		\ 	MEMBER(e_version,	WORD)		\ 	MEMBER(e_entry,		QUAD)		\ 	MEMBER(e_phoff,		QUAD)		\ 	MEMBER(e_shoff,		QUAD)		\ 	MEMBER(e_flags,		WORD)		\ 	MEMBER(e_ehsize,	HALF)		\ 	MEMBER(e_phentsize,	HALF)		\ 	MEMBER(e_phnum,		HALF)		\ 	MEMBER(e_shentsize,	HALF)		\ 	MEMBER(e_shnum,		HALF)		\ 	MEMBER(e_shstrndx,	HALF)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_MOVE
parameter_list|()
define|\
value|MEMBER(m_value,		QUAD)		\ 	MEMBER(m_info,		QUAD)		\ 	MEMBER(m_poffset,	QUAD)		\ 	MEMBER(m_repeat,	HALF)		\ 	MEMBER(m_stride,	HALF)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_PHDR
parameter_list|()
define|\
value|MEMBER(p_type,		WORD)		\ 	MEMBER(p_flags,		WORD)		\ 	MEMBER(p_offset,	QUAD)		\ 	MEMBER(p_vaddr,		QUAD)		\ 	MEMBER(p_paddr,		QUAD)		\ 	MEMBER(p_filesz,	QUAD)		\ 	MEMBER(p_memsz,		QUAD)		\ 	MEMBER(p_align,		QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_REL
parameter_list|()
define|\
value|MEMBER(r_offset,	QUAD)		\ 	MEMBER(r_info,		QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_RELA
parameter_list|()
define|\
value|MEMBER(r_offset,	QUAD)		\ 	MEMBER(r_info,		QUAD)		\ 	MEMBER(r_addend,	QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_SHDR
parameter_list|()
define|\
value|MEMBER(sh_name,		WORD)		\ 	MEMBER(sh_type,		WORD)		\ 	MEMBER(sh_flags,	QUAD)		\ 	MEMBER(sh_addr,		QUAD)		\ 	MEMBER(sh_offset,	QUAD)		\ 	MEMBER(sh_size,		QUAD)		\ 	MEMBER(sh_link,		WORD)		\ 	MEMBER(sh_info,		WORD)		\ 	MEMBER(sh_addralign,	QUAD)		\ 	MEMBER(sh_entsize,	QUAD)
end_define

begin_define
define|#
directive|define
name|ELF_TYPE_E64_SYM
parameter_list|()
define|\
value|MEMBER(st_name,		WORD)		\ 	MEMBER(st_info,		BYTE)		\ 	MEMBER(st_other,	BYTE)		\ 	MEMBER(st_shndx,	HALF)		\ 	MEMBER(st_value,	QUAD)		\ 	MEMBER(st_size,		QUAD)		\  #define	ELF_TYPE_E64_SYMINFO()			\ 	MEMBER(si_boundto,	HALF)		\ 	MEMBER(si_flags,	HALF)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|CAP
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|CAP
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|CAP
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|CAP
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|DYN
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|DYN
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|DYN
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|DYN
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|EHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|EHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|EHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|EHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|HALF
argument_list|)
decl|[]
init|=
block|{
name|HALF_SEQ_LSB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|HALF
argument_list|)
decl|[]
init|=
block|{
name|HALF_SEQ_MSB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|MOVE
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|MOVE
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|MOVE
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|MOVE
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|PHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|PHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|PHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|PHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|REL
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|REL
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|REL
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|REL
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|RELA
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|RELA
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|RELA
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|RELA
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|SHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|SHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|SHDR
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|SHDR
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|SYM
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|SYM
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|SYM
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|SYM
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|SYMINFO
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_LSB
name|TYPEDEFINITION
argument_list|(
argument|L
argument_list|,
argument|SYMINFO
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|SYMINFO
argument_list|)
decl|[]
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|K##_SEQ_MSB
name|TYPEDEFINITION
argument_list|(
argument|M
argument_list|,
argument|SYMINFO
argument_list|)
operator|(
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|QUAD
argument_list|)
decl|[]
init|=
block|{
name|QUAD_SEQ_LSB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|QUAD
argument_list|)
decl|[]
init|=
block|{
name|QUAD_SEQ_MSB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|WORD
argument_list|)
decl|[]
init|=
block|{
name|WORD_SEQ_LSB
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|WORD
argument_list|)
decl|[]
init|=
block|{
name|WORD_SEQ_MSB
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TS_XLATESZ
operator|==
literal|32
end_if

begin_comment
comment|/*  * 32 bit reference structures.  */
end_comment

begin_define
define|#
directive|define
name|td_L32_ADDR
value|td_L32_WORD
end_define

begin_define
define|#
directive|define
name|td_M32_ADDR
value|td_M32_WORD
end_define

begin_define
define|#
directive|define
name|td_L32_SWORD
value|td_L32_WORD
end_define

begin_define
define|#
directive|define
name|td_M32_SWORD
value|td_M32_WORD
end_define

begin_define
define|#
directive|define
name|td_L32_OFF
value|td_L32_WORD
end_define

begin_define
define|#
directive|define
name|td_M32_OFF
value|td_M32_WORD
end_define

begin_function_decl
specifier|static
name|Elf32_Addr
name|MEMSTRUCTNAME
parameter_list|(
name|ADDR
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ADDR32_SIZE
value|sizeof(Elf32_Addr)
end_define

begin_function_decl
specifier|static
name|Elf32_Cap
name|MEMSTRUCTNAME
parameter_list|(
name|CAP
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_CAP
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CAP32_SIZE
value|sizeof(Elf32_Cap)
end_define

begin_function_decl
specifier|static
name|Elf32_Dyn
name|MEMSTRUCTNAME
parameter_list|(
name|DYN
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_DYN
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DYN32_SIZE
value|sizeof(Elf32_Dyn)
end_define

begin_function_decl
specifier|static
name|Elf32_Ehdr
name|MEMSTRUCTNAME
parameter_list|(
name|EHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_EHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EHDR32_SIZE
value|sizeof(Elf32_Ehdr)
end_define

begin_function_decl
specifier|static
name|Elf32_Half
name|MEMSTRUCTNAME
parameter_list|(
name|HALF
parameter_list|)
init|=
name|HALF_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HALF32_SIZE
value|sizeof(Elf32_Half)
end_define

begin_function_decl
specifier|static
name|Elf32_Move
name|MEMSTRUCTNAME
parameter_list|(
name|MOVE
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_MOVE
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MOVE32_SIZE
value|sizeof(Elf32_Move)
end_define

begin_function_decl
specifier|static
name|Elf32_Off
name|MEMSTRUCTNAME
parameter_list|(
name|OFF
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OFF32_SIZE
value|sizeof(Elf32_Off)
end_define

begin_function_decl
specifier|static
name|Elf32_Phdr
name|MEMSTRUCTNAME
parameter_list|(
name|PHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_PHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PHDR32_SIZE
value|sizeof(Elf32_Phdr)
end_define

begin_function_decl
specifier|static
name|Elf32_Rel
name|MEMSTRUCTNAME
parameter_list|(
name|REL
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_REL
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|REL32_SIZE
value|sizeof(Elf32_Rel)
end_define

begin_function_decl
specifier|static
name|Elf32_Rela
name|MEMSTRUCTNAME
parameter_list|(
name|RELA
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_RELA
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RELA32_SIZE
value|sizeof(Elf32_Rela)
end_define

begin_function_decl
specifier|static
name|Elf32_Shdr
name|MEMSTRUCTNAME
parameter_list|(
name|SHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_SHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SHDR32_SIZE
value|sizeof(Elf32_Shdr)
end_define

begin_function_decl
specifier|static
name|Elf32_Sword
name|MEMSTRUCTNAME
parameter_list|(
name|SWORD
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SWORD32_SIZE
value|sizeof(Elf32_Sword)
end_define

begin_function_decl
specifier|static
name|Elf32_Sym
name|MEMSTRUCTNAME
parameter_list|(
name|SYM
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_SYM
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SYM32_SIZE
value|sizeof(Elf32_Sym)
end_define

begin_function_decl
specifier|static
name|Elf32_Syminfo
name|MEMSTRUCTNAME
parameter_list|(
name|SYMINFO
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E32_SYMINFO
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SYMINFO32_SIZE
value|sizeof(Elf32_Syminfo)
end_define

begin_function_decl
specifier|static
name|Elf32_Word
name|MEMSTRUCTNAME
parameter_list|(
name|WORD
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|WORD32_SIZE
value|sizeof(Elf32_Word)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * 64 bit reference structures.  */
end_comment

begin_define
define|#
directive|define
name|td_L64_ADDR
value|td_L64_QUAD
end_define

begin_define
define|#
directive|define
name|td_M64_ADDR
value|td_M64_QUAD
end_define

begin_define
define|#
directive|define
name|td_L64_OFF
value|td_L64_QUAD
end_define

begin_define
define|#
directive|define
name|td_M64_OFF
value|td_M64_QUAD
end_define

begin_define
define|#
directive|define
name|td_L64_SWORD
value|td_L64_WORD
end_define

begin_define
define|#
directive|define
name|td_M64_SWORD
value|td_M64_WORD
end_define

begin_define
define|#
directive|define
name|td_L64_SXWORD
value|td_L64_QUAD
end_define

begin_define
define|#
directive|define
name|td_M64_SXWORD
value|td_M64_QUAD
end_define

begin_define
define|#
directive|define
name|td_L64_XWORD
value|td_L64_QUAD
end_define

begin_define
define|#
directive|define
name|td_M64_XWORD
value|td_M64_QUAD
end_define

begin_function_decl
specifier|static
name|Elf64_Addr
name|MEMSTRUCTNAME
parameter_list|(
name|ADDR
parameter_list|)
init|=
name|QUAD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ADDR64_SIZE
value|sizeof(Elf64_Addr)
end_define

begin_function_decl
specifier|static
name|Elf64_Cap
name|MEMSTRUCTNAME
parameter_list|(
name|CAP
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_CAP
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CAP64_SIZE
value|sizeof(Elf64_Cap)
end_define

begin_function_decl
specifier|static
name|Elf64_Dyn
name|MEMSTRUCTNAME
parameter_list|(
name|DYN
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_DYN
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DYN64_SIZE
value|sizeof(Elf64_Dyn)
end_define

begin_function_decl
specifier|static
name|Elf64_Ehdr
name|MEMSTRUCTNAME
parameter_list|(
name|EHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_EHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EHDR64_SIZE
value|sizeof(Elf64_Ehdr)
end_define

begin_function_decl
specifier|static
name|Elf64_Half
name|MEMSTRUCTNAME
parameter_list|(
name|HALF
parameter_list|)
init|=
name|HALF_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HALF64_SIZE
value|sizeof(Elf64_Half)
end_define

begin_function_decl
specifier|static
name|Elf64_Move
name|MEMSTRUCTNAME
parameter_list|(
name|MOVE
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_MOVE
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MOVE64_SIZE
value|sizeof(Elf64_Move)
end_define

begin_function_decl
specifier|static
name|Elf64_Phdr
name|MEMSTRUCTNAME
parameter_list|(
name|PHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_PHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PHDR64_SIZE
value|sizeof(Elf64_Phdr)
end_define

begin_function_decl
specifier|static
name|Elf64_Off
name|MEMSTRUCTNAME
parameter_list|(
name|OFF
parameter_list|)
init|=
name|QUAD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OFF64_SIZE
value|sizeof(Elf64_Off)
end_define

begin_function_decl
specifier|static
name|Elf64_Rel
name|MEMSTRUCTNAME
parameter_list|(
name|REL
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_REL
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|REL64_SIZE
value|sizeof(Elf64_Rel)
end_define

begin_function_decl
specifier|static
name|Elf64_Rela
name|MEMSTRUCTNAME
parameter_list|(
name|RELA
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_RELA
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RELA64_SIZE
value|sizeof(Elf64_Rela)
end_define

begin_function_decl
specifier|static
name|Elf64_Shdr
name|MEMSTRUCTNAME
parameter_list|(
name|SHDR
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_SHDR
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SHDR64_SIZE
value|sizeof(Elf64_Shdr)
end_define

begin_function_decl
specifier|static
name|Elf64_Sword
name|MEMSTRUCTNAME
parameter_list|(
name|SWORD
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SWORD64_SIZE
value|sizeof(Elf64_Sword)
end_define

begin_function_decl
specifier|static
name|Elf64_Sxword
name|MEMSTRUCTNAME
parameter_list|(
name|SXWORD
parameter_list|)
init|=
name|QUAD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SXWORD64_SIZE
value|sizeof(Elf64_Sxword)
end_define

begin_function_decl
specifier|static
name|Elf64_Sym
name|MEMSTRUCTNAME
parameter_list|(
name|SYM
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_SYM
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SYM64_SIZE
value|sizeof(Elf64_Sym)
end_define

begin_function_decl
specifier|static
name|Elf64_Syminfo
name|MEMSTRUCTNAME
parameter_list|(
name|SYMINFO
parameter_list|)
init|=
block|{
undef|#
directive|undef
name|MEMBER
define|#
directive|define
name|MEMBER
parameter_list|(
name|N
parameter_list|,
name|K
parameter_list|)
value|.N = K##_VAL ,
name|ELF_TYPE_E64_SYMINFO
argument_list|()
block|}
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SYMINFO64_SIZE
value|sizeof(Elf64_Syminfo)
end_define

begin_function_decl
specifier|static
name|Elf64_Word
name|MEMSTRUCTNAME
parameter_list|(
name|WORD
parameter_list|)
init|=
name|WORD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|WORD64_SIZE
value|sizeof(Elf64_Word)
end_define

begin_function_decl
specifier|static
name|Elf64_Xword
name|MEMSTRUCTNAME
parameter_list|(
name|XWORD
parameter_list|)
init|=
name|QUAD_VAL
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|XWORD64_SIZE
value|sizeof(Elf64_Xword)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TS_XLATESZ == 32 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TESTDATA_STRUCT_
end_ifndef

begin_define
define|#
directive|define
name|_TESTDATA_STRUCT_
value|1
end_define

begin_struct
struct|struct
name|testdata
block|{
name|char
modifier|*
name|tsd_name
decl_stmt|;
name|Elf_Type
name|tsd_type
decl_stmt|;
name|void
modifier|*
name|tsd_mem
decl_stmt|;
name|size_t
name|tsd_fsz
decl_stmt|;
name|size_t
name|tsd_msz
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|tsd_lsb
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|tsd_msb
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*_TESTDATA_STRUCT_*/
end_comment

begin_define
define|#
directive|define
name|TESTDATASET
value|__XCONCAT(tests,TS_XLATESZ)
end_define

begin_decl_stmt
specifier|static
name|struct
name|testdata
name|TESTDATASET
index|[]
init|=
block|{
undef|#
directive|undef
name|DEFINE_TEST_DATA
define|#
directive|define
name|DEFINE_TEST_DATA
parameter_list|(
name|N
parameter_list|)
value|{				\ 		.tsd_name = #N,				\ 		.tsd_type = ELF_T_##N,			\ 		.tsd_fsz = sizeof(TYPEDEFNAME(L,N)),	\ 		.tsd_msz = MEMSIZENAME(N),		\ 		.tsd_mem = (void *)&MEMSTRUCTNAME(N),	\ 		.tsd_lsb = TYPEDEFNAME(L,N),		\ 		.tsd_msb = TYPEDEFNAME(M,N),		\ 	}
if|#
directive|if
name|TS_XLATESZ
operator|==
literal|32
name|DEFINE_TEST_DATA
argument_list|(
name|ADDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|CAP
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|DYN
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|EHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|HALF
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|MOVE
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|OFF
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|PHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|REL
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|RELA
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SWORD
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SYM
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SYMINFO
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|WORD
argument_list|)
block|,
else|#
directive|else
name|DEFINE_TEST_DATA
argument_list|(
name|ADDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|CAP
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|DYN
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|EHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|HALF
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|MOVE
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|OFF
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|PHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|REL
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|RELA
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SHDR
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SWORD
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SXWORD
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SYM
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|SYMINFO
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|WORD
argument_list|)
block|,
name|DEFINE_TEST_DATA
argument_list|(
name|XWORD
argument_list|)
block|,
endif|#
directive|endif
comment|/* TS_XLATESZ == 32 */
block|{
operator|.
name|tsd_name
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOPIES
value|3
end_define

begin_define
define|#
directive|define
name|NOFFSET
value|8
end_define

begin_comment
comment|/* check every alignment in a quad word */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TESTCASE_FUNCTIONS
end_ifndef

begin_function
specifier|static
name|int
name|check_xlate
parameter_list|(
name|Elf_Data
modifier|*
name|xlator
parameter_list|(
name|Elf_Data
modifier|*
name|d
parameter_list|,
specifier|const
name|Elf_Data
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
name|enc
parameter_list|)
parameter_list|,
name|int
name|ed
parameter_list|,
name|Elf_Data
modifier|*
name|dst
parameter_list|,
name|Elf_Data
modifier|*
name|src
parameter_list|,
name|struct
name|testdata
modifier|*
name|td
parameter_list|,
name|int
name|ncopies
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|dstret
decl_stmt|;
name|size_t
name|msz
decl_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
comment|/* Invoke translator */
if|if
condition|(
operator|(
name|dstret
operator|=
name|xlator
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|ed
argument_list|)
operator|)
operator|!=
name|dst
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" "
name|__XSTRING
argument_list|(
name|TC_XLATETOM
argument_list|)
literal|": %s"
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check return parameters. */
if|if
condition|(
name|dst
operator|->
name|d_type
operator|!=
name|td
operator|->
name|tsd_type
operator|||
name|dst
operator|->
name|d_size
operator|!=
name|msz
operator|*
name|ncopies
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" type(ret=%d,expected=%d) "
literal|"size (ret=%d,expected=%d)."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|dst
operator|->
name|d_type
argument_list|,
name|td
operator|->
name|tsd_type
argument_list|,
name|dst
operator|->
name|d_size
argument_list|,
name|msz
operator|*
name|ncopies
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check byte conversions:  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpByte
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|sz
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|,
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|ref
decl_stmt|;
name|ref
operator|=
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|QUAD
argument_list|)
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|QUAD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|sz
operator|*
name|NCOPIES
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|filebuf
operator|=
name|malloc
argument_list|(
name|sz
operator|*
name|NCOPIES
operator|+
name|NOFFSET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check memory to file conversions. 	 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|ref
argument_list|,
name|sz
argument_list|)
operator|+
name|sz
expr_stmt|;
name|src
operator|.
name|d_buf
operator|=
name|membuf
expr_stmt|;
name|src
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|src
operator|.
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|src
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: Byte TOF() succeeds."
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|NOFFSET
condition|;
name|offset
operator|++
control|)
block|{
comment|/* 		 * LSB 		 */
name|dst
operator|.
name|d_buf
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: LSB TOF() conversion."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|membuf
argument_list|,
name|filebuf
operator|+
name|offset
argument_list|,
name|sz
operator|*
name|NCOPIES
argument_list|)
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: LSB TOF() memcmp()."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * MSB 		 */
name|dst
operator|.
name|d_buf
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: MSB TOF() conversion."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|membuf
argument_list|,
name|filebuf
operator|+
name|offset
argument_list|,
name|sz
operator|*
name|NCOPIES
argument_list|)
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: MSB TOF() memcmp()."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Check file to memory conversions. 	 */
name|tet_infoline
argument_list|(
literal|"assertion: Byte TOM() succeeds."
argument_list|)
expr_stmt|;
name|ref
operator|=
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|QUAD
argument_list|)
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|TYPEDEFNAME
argument_list|(
name|M
argument_list|,
name|QUAD
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|NOFFSET
condition|;
name|offset
operator|++
control|)
block|{
name|src
operator|.
name|d_buf
operator|=
name|t
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|ref
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|src
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|src
operator|.
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|src
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
comment|/* 		 * LSB 		 */
name|dst
operator|.
name|d_buf
operator|=
name|membuf
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: LSB TOM() conversion."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|membuf
argument_list|,
name|filebuf
operator|+
name|offset
argument_list|,
name|sz
operator|*
name|NCOPIES
argument_list|)
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: LSB TOM() memcmp()."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * MSB 		 */
name|dst
operator|.
name|d_buf
operator|=
name|membuf
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|sz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: MSB TOM() conversion."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|membuf
argument_list|,
name|filebuf
operator|+
name|offset
argument_list|,
name|sz
operator|*
name|NCOPIES
argument_list|)
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: MSB TOM() memcmp()."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|filebuf
condition|)
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check a byte conversion on a shared buffer.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpByteShared
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|char
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|ref
decl_stmt|;
define|#
directive|define
name|PREPARE_SHARED
parameter_list|(
name|T
parameter_list|,
name|SZ
parameter_list|)
value|do {					\ 		src.d_buf     = dst.d_buf     = membuf;			\ 		src.d_size    = dst.d_size    = (SZ) * NCOPIES;		\ 		src.d_type    = dst.d_type    = (T);			\ 		src.d_version = dst.d_version = EV_CURRENT;		\ 	} while (0)
define|#
directive|define
name|VERIFY
parameter_list|(
name|R
parameter_list|,
name|SZ
parameter_list|)
value|do {						\ 		t = dst.d_buf;						\ 		for (i = 0; i< NCOPIES; i++, t += (SZ))		\ 			if (memcmp((R), t, (SZ))) {			\ 				tet_infoline("fail: LSB TOF() "		\ 				    "memcmp().");			\ 				tet_result(TET_FAIL);			\ 				goto done;				\ 			}						\ 	} while (0)
name|membuf
operator|=
name|NULL
expr_stmt|;
name|ref
operator|=
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|QUAD
argument_list|)
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|TYPEDEFNAME
argument_list|(
name|L
argument_list|,
name|QUAD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|sz
operator|*
name|NCOPIES
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|ref
argument_list|,
name|sz
argument_list|)
operator|+
name|sz
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: byte TOF() on a shared dst/src arena "
literal|"succeeds."
argument_list|)
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|ELF_T_BYTE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
operator|||
name|dst
operator|.
name|d_buf
operator|!=
name|src
operator|.
name|d_buf
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: LSB TOF() conversion: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|ref
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|ELF_T_BYTE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
operator|||
name|dst
operator|.
name|d_buf
operator|!=
name|src
operator|.
name|d_buf
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: MSB TOF() conversion: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|ref
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: byte TOM() on a shared dst/src arena "
literal|"succeeds."
argument_list|)
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|ELF_T_BYTE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
operator|||
name|dst
operator|.
name|d_buf
operator|!=
name|src
operator|.
name|d_buf
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: LSB TOM() conversion: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|ref
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|ELF_T_BYTE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
operator|&
name|dst
operator|||
name|dst
operator|.
name|d_size
operator|!=
name|sz
operator|*
name|NCOPIES
operator|||
name|dst
operator|.
name|d_buf
operator|!=
name|src
operator|.
name|d_buf
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: MSB TOM() conversion: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|ref
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check non-byte conversions from file representations to memory.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpToM
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|srcbuf
operator|=
name|NULL
expr_stmt|;
comment|/* file data (bytes) */
name|membuf
operator|=
name|NULL
expr_stmt|;
comment|/* memory data (struct) */
comment|/* Loop over all types */
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|fsz
operator|=
name|__XCONCAT
argument_list|(
name|__XCONCAT
argument_list|(
name|elf
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|,
name|_fsize
argument_list|)
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
if|if
condition|(
name|msz
operator|==
literal|0
operator|||
name|fsz
operator|!=
name|td
operator|->
name|tsd_fsz
condition|)
block|{
name|tet_printf
argument_list|(
literal|"? %s: msz=%d fsz=%d td->fsz=%d."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|msz
argument_list|,
name|fsz
argument_list|,
name|td
operator|->
name|tsd_fsz
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|fsz
operator|==
name|td
operator|->
name|tsd_fsz
argument_list|)
expr_stmt|;
comment|/* 		 * allocate space for NCOPIES of data + offset for file data and 		 * NCOPIES of memory data. 		 */
if|if
condition|(
operator|(
name|srcbuf
operator|=
name|malloc
argument_list|(
name|NCOPIES
operator|*
name|fsz
operator|+
name|NOFFSET
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|NCOPIES
operator|*
name|msz
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|srcbuf
condition|)
name|free
argument_list|(
name|srcbuf
argument_list|)
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
name|tet_printf
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|"(%s) succeeds."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|NOFFSET
condition|;
name|offset
operator|++
control|)
block|{
name|src
operator|.
name|d_buf
operator|=
name|t
operator|=
name|srcbuf
operator|+
name|offset
expr_stmt|;
name|src
operator|.
name|d_size
operator|=
name|fsz
operator|*
name|NCOPIES
expr_stmt|;
name|src
operator|.
name|d_type
operator|=
name|td
operator|->
name|tsd_type
expr_stmt|;
name|src
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|dst
operator|.
name|d_buf
operator|=
name|membuf
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|msz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
comment|/* 			 * Check conversion of LSB encoded data. 			 */
comment|/* copy `NCOPIES*fsz' bytes in `srcbuf+offset' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_lsb
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|t
operator|+=
name|fsz
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|membuf
argument_list|,
literal|0
argument_list|,
name|NCOPIES
operator|*
name|msz
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_xlate
argument_list|(
name|TS_XLATETOM
argument_list|,
name|ELFDATA2LSB
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|td
argument_list|,
name|NCOPIES
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* compare the retrieved data with the canonical value */
name|t
operator|=
name|dst
operator|.
name|d_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" LSB memory "
literal|"compare failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|+=
name|msz
expr_stmt|;
block|}
comment|/* 			 * Check conversion of MSB encoded data. 			 */
name|t
operator|=
name|srcbuf
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_msb
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|t
operator|+=
name|fsz
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|membuf
argument_list|,
literal|0
argument_list|,
name|NCOPIES
operator|*
name|msz
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_xlate
argument_list|(
name|TS_XLATETOM
argument_list|,
name|ELFDATA2MSB
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|td
argument_list|,
name|NCOPIES
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* compare the retrieved data with the canonical value */
name|t
operator|=
name|dst
operator|.
name|d_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" MSB memory "
literal|"compare failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|+=
name|msz
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|srcbuf
argument_list|)
expr_stmt|;
name|srcbuf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
block|}
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|srcbuf
condition|)
name|free
argument_list|(
name|srcbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpToMShared
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|tet_printf
argument_list|(
literal|"assertion: in-place "
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|"(\"%s\")."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|fsz
operator|=
name|__XCONCAT
argument_list|(
name|__XCONCAT
argument_list|(
name|elf
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|,
name|_fsize
argument_list|)
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
name|assert
argument_list|(
name|msz
operator|>=
name|fsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|fsz
operator|*
name|NCOPIES
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"unresolved: \"%s\" malloc() failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * In-place conversion of LSB data. 		 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_lsb
argument_list|,
name|fsz
argument_list|)
operator|+
name|fsz
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|result
operator|=
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|==
operator|&
name|dst
expr_stmt|;
if|if
condition|(
name|fsz
operator|<
name|msz
condition|)
block|{
comment|/* conversion should fail with ELF_E_DATA */
if|if
condition|(
name|result
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" LSB TOM() succeeded "
literal|"with fsz< msz"
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* conversion should have succeeded. */
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" LSB TOM() failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
expr_stmt|;
comment|/* 		 * In-place conversion of MSB data. 		 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_msb
argument_list|,
name|fsz
argument_list|)
operator|+
name|fsz
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|result
operator|=
name|TS_XLATETOM
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|==
operator|&
name|dst
expr_stmt|;
if|if
condition|(
name|fsz
operator|<
name|msz
condition|)
block|{
comment|/* conversion should fail with ELF_E_DATA */
if|if
condition|(
name|result
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" MSB TOM() succeeded "
literal|"with fsz< msz"
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* conversion should have succeeded. */
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" MSB TOM() failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
expr_stmt|;
block|}
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check non-byte conversions from memory to file.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpToF
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|,
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|filebuf
operator|=
name|NULL
expr_stmt|;
comment|/* file data (bytes) */
name|membuf
operator|=
name|NULL
expr_stmt|;
comment|/* memory data (struct) */
comment|/* Loop over all types */
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|fsz
operator|=
name|__XCONCAT
argument_list|(
name|__XCONCAT
argument_list|(
name|elf
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|,
name|_fsize
argument_list|)
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
if|if
condition|(
name|msz
operator|==
literal|0
operator|||
name|fsz
operator|!=
name|td
operator|->
name|tsd_fsz
condition|)
block|{
name|tet_printf
argument_list|(
literal|"? %s: msz=%d fsz=%d td->fsz=%d."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|msz
argument_list|,
name|fsz
argument_list|,
name|td
operator|->
name|tsd_fsz
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|msz
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsz
operator|==
name|td
operator|->
name|tsd_fsz
argument_list|)
expr_stmt|;
comment|/* 		 * allocate space for NCOPIES of data + offset for file data and 		 * NCOPIES of memory data. 		 */
if|if
condition|(
operator|(
name|filebuf
operator|=
name|malloc
argument_list|(
name|NCOPIES
operator|*
name|fsz
operator|+
name|NOFFSET
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|NCOPIES
operator|*
name|msz
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|filebuf
condition|)
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
name|tet_printf
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"(%s) succeeds."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|NOFFSET
condition|;
name|offset
operator|++
control|)
block|{
name|src
operator|.
name|d_buf
operator|=
name|membuf
expr_stmt|;
name|src
operator|.
name|d_size
operator|=
name|msz
operator|*
name|NCOPIES
expr_stmt|;
name|src
operator|.
name|d_type
operator|=
name|td
operator|->
name|tsd_type
expr_stmt|;
name|src
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
comment|/* 			 * Check LSB conversion. 			 */
comment|/* copy `NCOPIES' of canonical memory data to the src buffer */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
expr_stmt|;
name|t
operator|+=
name|msz
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|filebuf
argument_list|,
literal|0
argument_list|,
name|NCOPIES
operator|*
name|fsz
operator|+
name|NOFFSET
argument_list|)
expr_stmt|;
name|dst
operator|.
name|d_buf
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|fsz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|check_xlate
argument_list|(
name|TS_XLATETOF
argument_list|,
name|ELFDATA2LSB
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|td
argument_list|,
name|NCOPIES
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* compare converted data to canonical form */
name|t
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_lsb
argument_list|,
name|fsz
argument_list|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" LSB memory "
literal|"compare."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|+=
name|fsz
expr_stmt|;
block|}
comment|/* 			 * Check MSB conversion. 			 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
expr_stmt|;
name|t
operator|+=
name|msz
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|filebuf
argument_list|,
literal|0
argument_list|,
name|NCOPIES
operator|*
name|fsz
operator|+
name|NOFFSET
argument_list|)
expr_stmt|;
name|dst
operator|.
name|d_buf
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|fsz
operator|*
name|NCOPIES
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|check_xlate
argument_list|(
name|TS_XLATETOF
argument_list|,
name|ELFDATA2MSB
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|td
argument_list|,
name|NCOPIES
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* compare converted data to canonical form */
name|t
operator|=
name|filebuf
operator|+
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_msb
argument_list|,
name|fsz
argument_list|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" MSB memory "
literal|"compare."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|+=
name|fsz
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
name|filebuf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
block|}
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|filebuf
condition|)
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcXlate_tpToFShared
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|membuf
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|membuf
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|tet_printf
argument_list|(
literal|"assertion: in-place "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"(\"%s\")."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|fsz
operator|=
name|__XCONCAT
argument_list|(
name|__XCONCAT
argument_list|(
name|elf
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|,
name|_fsize
argument_list|)
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
name|assert
argument_list|(
name|msz
operator|>=
name|fsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|membuf
operator|=
name|malloc
argument_list|(
name|msz
operator|*
name|NCOPIES
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"unresolved: \"%s\" malloc() failed."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * In-place conversion to LSB data. 		 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
operator|+
name|msz
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
name|msz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
operator|&
name|dst
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" LSB TOF() failed: %s."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|td
operator|->
name|tsd_lsb
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
comment|/* 		 * In-place conversion to MSB data. 		 */
name|t
operator|=
name|membuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOPIES
condition|;
name|i
operator|++
control|)
name|t
operator|=
name|memcpy
argument_list|(
name|t
argument_list|,
name|td
operator|->
name|tsd_mem
argument_list|,
name|msz
argument_list|)
operator|+
name|msz
expr_stmt|;
name|PREPARE_SHARED
argument_list|(
name|td
operator|->
name|tsd_type
argument_list|,
name|msz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
operator|&
name|dst
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" MSB TOF() failed: %s."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|VERIFY
argument_list|(
name|td
operator|->
name|tsd_msb
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
block|}
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|membuf
condition|)
name|free
argument_list|(
name|membuf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Various checks for invalid arguments.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcArgs_tpNullArgs
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|;
name|int
name|result
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"/"
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|" with NULL arguments fail "
literal|"with ELF_E_ARGUMENT."
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
name|NULL
argument_list|,
operator|&
name|ed
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
name|NULL
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
name|NULL
argument_list|,
operator|&
name|ed
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
name|NULL
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcArgs_tpBadType
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"/"
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|" with an out of range type "
literal|"fails with ELF_E_DATA."
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|ed
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
name|ed
operator|.
name|d_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
operator|(
name|Elf_Type
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|ELF_T_NUM
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcArgs_tpBadEncoding
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"/"
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|" (*,*,BADENCODING) "
literal|"fails with ELF_E_ARGUMENT."
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2MSB
operator|+
literal|1
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2MSB
operator|+
literal|1
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcArg_tpDstSrcVersionToF
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"() / "
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|"() with unequal "
literal|"src,dst versions fails with ELF_E_UNIMPL."
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|ed
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
name|ed
operator|.
name|d_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ed
operator|.
name|d_version
operator|=
name|EV_NONE
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check for an unimplemented type.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcArg_tpUnimplemented
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"() on "
literal|"unimplemented types will with ELF_E_UNIMPL."
argument_list|)
expr_stmt|;
comment|/* 	 * allocate a buffer that is large enough for any potential 	 * ELF data structure. 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
name|ed
operator|.
name|d_buf
operator|=
name|es
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|ed
operator|.
name|d_size
operator|=
name|es
operator|.
name|d_size
operator|=
literal|1024
expr_stmt|;
name|ed
operator|.
name|d_version
operator|=
name|es
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ELF_T_NUM
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|ELF_T_MOVEP
case|:
if|#
directive|if
name|TS_XLATESZ
operator|==
literal|32
case|case
name|ELF_T_SXWORD
case|:
case|case
name|ELF_T_XWORD
case|:
endif|#
directive|endif
break|break;
default|default:
continue|continue;
block|}
name|es
operator|.
name|d_type
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: TOF/LSB/type=%d."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: TOF/MSB/type=%d."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2LSB
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: TOM/LSB/type=%d."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATA2MSB
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_UNIMPL
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: TOM/MSB/type=%d."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
block|}
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check for null buffer pointers.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcBuffer_tpNullDataPtr
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
literal|"() / "
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
literal|"() with a null "
literal|"src,dst buffer pointer fails with ELF_E_DATA."
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
name|ed
operator|.
name|d_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|NULL
expr_stmt|;
name|ed
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|ed
operator|.
name|d_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
name|result
operator|=
name|TET_FAIL
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Misaligned data.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcBuffer_tpMisaligned
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|char
modifier|*
name|sb
decl_stmt|,
modifier|*
name|db
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: misaligned buffers are rejected with "
literal|"ELF_E_DATA."
argument_list|)
expr_stmt|;
name|sb
operator|=
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|db
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
condition|)
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|TET_PASS
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|fsz
operator|=
name|td
operator|->
name|tsd_fsz
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|td
operator|->
name|tsd_type
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
comment|/* Misalign the destination for to-memory xfers */
name|es
operator|.
name|d_size
operator|=
operator|(
literal|1024
operator|/
name|fsz
operator|)
operator|*
name|fsz
expr_stmt|;
comment|/* round down */
name|es
operator|.
name|d_buf
operator|=
name|sb
expr_stmt|;
name|ed
operator|.
name|d_buf
operator|=
name|db
operator|+
literal|1
expr_stmt|;
comment|/* guaranteed to be misaliged */
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ed
operator|.
name|d_size
operator|=
literal|1024
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOM alignment."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
comment|/* Misalign the source for to-file xfers */
name|es
operator|.
name|d_buf
operator|=
name|sb
operator|+
literal|1
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
operator|(
literal|1024
operator|/
name|msz
operator|)
operator|*
name|msz
expr_stmt|;
comment|/* round down */
name|ed
operator|.
name|d_buf
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOF alignment."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
block|}
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Overlapping buffers.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcBuffer_tpOverlap
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: overlapping buffers are rejected with "
literal|"ELF_E_DATA."
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|ed
operator|.
name|d_buf
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
name|ed
operator|.
name|d_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: "
name|__XSTRING
argument_list|(
name|TS_XLATETOF
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: "
name|__XSTRING
argument_list|(
name|TS_XLATETOM
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Non-integral number of src elements.  */
end_comment

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcBuffer_tpSrcExtra
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|char
modifier|*
name|sb
decl_stmt|,
modifier|*
name|db
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: mis-sized buffers are rejected with "
literal|"ELF_E_DATA."
argument_list|)
expr_stmt|;
name|sb
operator|=
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|db
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"unresolved: malloc() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
condition|)
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|TET_PASS
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|fsz
operator|=
name|td
operator|->
name|tsd_fsz
expr_stmt|;
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|td
operator|->
name|tsd_type
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ed
operator|.
name|d_buf
operator|=
name|db
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|sb
expr_stmt|;
name|ed
operator|.
name|d_size
operator|=
literal|1024
expr_stmt|;
comment|/* Pad src bytes with extra bytes for to memor */
name|es
operator|.
name|d_size
operator|=
name|fsz
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOM buffer size."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
name|es
operator|.
name|d_size
operator|=
name|msz
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOF buffer size."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
block|}
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|__XCONCAT
argument_list|(
name|tcBuffer_tpDstTooSmall
argument_list|,
name|TS_XLATESZ
argument_list|)
argument_list|(
name|void
argument_list|)
block|{
name|Elf_Data
name|ed
decl_stmt|,
name|es
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|testdata
modifier|*
name|td
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|msz
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: too small destination buffers are rejected "
literal|"with ELF_E_DATA."
argument_list|)
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TESTDATASET
init|;
name|td
operator|->
name|tsd_name
condition|;
name|td
operator|++
control|)
block|{
name|msz
operator|=
name|td
operator|->
name|tsd_msz
expr_stmt|;
name|fsz
operator|=
name|td
operator|->
name|tsd_fsz
expr_stmt|;
name|es
operator|.
name|d_type
operator|=
name|td
operator|->
name|tsd_type
expr_stmt|;
name|es
operator|.
name|d_version
operator|=
name|ed
operator|.
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|es
operator|.
name|d_buf
operator|=
name|ed
operator|.
name|d_buf
operator|=
name|buf
expr_stmt|;
name|es
operator|.
name|d_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
name|msz
operator|)
operator|*
name|msz
expr_stmt|;
name|ed
operator|.
name|d_size
operator|=
literal|1
expr_stmt|;
comment|/* too small a size */
if|if
condition|(
name|TS_XLATETOF
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOF dst size."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
name|es
operator|.
name|d_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
name|fsz
operator|)
operator|*
name|fsz
expr_stmt|;
if|if
condition|(
name|TS_XLATETOM
argument_list|(
operator|&
name|ed
argument_list|,
operator|&
name|es
argument_list|,
name|ELFDATANONE
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_DATA
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" TOF dst size."
argument_list|,
name|td
operator|->
name|tsd_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
block|}
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_TESTCASE_FUNCTIONS */
end_comment

end_unit

