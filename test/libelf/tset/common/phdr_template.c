begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: phdr_template.c 1074 2010-08-09 11:43:34Z jkoshy $  */
end_comment

begin_comment
comment|/*  * Boilerplate for testing the *_getphdr and *_newphdr APIs.  *  * This template is to be used as follows:  *  * #define	TS_PHDRFUNC		_getphdr	(or _newphdr)  * #define	TS_PHDRSZ		32	(or 64)  * #include "phdr_template.c"  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* Variations of __CONCAT and __STRING which expand their arguments. */
end_comment

begin_define
define|#
directive|define
name|__XCONCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__CONCAT(x,y)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__XSTRING
end_ifndef

begin_define
define|#
directive|define
name|__XSTRING
parameter_list|(
name|x
parameter_list|)
value|__STRING(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TS_ICFUNC
value|__XCONCAT(elf,__XCONCAT(TS_PHDRSZ,TS_PHDRFUNC))
end_define

begin_define
define|#
directive|define
name|TS_PHDR
value|__XCONCAT(Elf,__XCONCAT(TS_PHDRSZ,_Phdr))
end_define

begin_define
define|#
directive|define
name|TS_ICNAME
value|__XSTRING(TS_ICFUNC)
end_define

begin_define
define|#
directive|define
name|TS_ELFCLASS
value|__XCONCAT(ELFCLASS,TS_PHDRSZ)
end_define

begin_define
define|#
directive|define
name|TS_GETEHDR
value|__XCONCAT(elf,__XCONCAT(TS_PHDRSZ,_getehdr))
end_define

begin_define
define|#
directive|define
name|TS_EHDR
value|__XCONCAT(Elf,__XCONCAT(TS_PHDRSZ,_Ehdr))
end_define

begin_define
define|#
directive|define
name|TS_NPHDR
value|3
end_define

begin_comment
comment|/* should match "phdr.yaml" */
end_comment

begin_expr_stmt
name|IC_REQUIRES_VERSION_INIT
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Reference data for the contents of an Phdr structure. The values  * here must match that in the "phdr.yaml" file.  */
end_comment

begin_decl_stmt
specifier|static
name|TS_PHDR
name|phdr_testdata
index|[
name|TS_NPHDR
index|]
init|=
block|{
block|{
operator|.
name|p_type
operator|=
name|PT_NULL
block|,
operator|.
name|p_offset
operator|=
literal|1
block|,
operator|.
name|p_vaddr
operator|=
literal|2
block|,
operator|.
name|p_paddr
operator|=
literal|3
block|,
operator|.
name|p_filesz
operator|=
literal|4
block|,
operator|.
name|p_memsz
operator|=
literal|5
block|,
operator|.
name|p_flags
operator|=
name|PF_X
block|,
operator|.
name|p_align
operator|=
literal|1
block|}
block|,
block|{
operator|.
name|p_type
operator|=
name|PT_NULL
block|,
operator|.
name|p_offset
operator|=
literal|6
block|,
operator|.
name|p_vaddr
operator|=
literal|7
block|,
operator|.
name|p_paddr
operator|=
literal|8
block|,
operator|.
name|p_filesz
operator|=
literal|9
block|,
operator|.
name|p_memsz
operator|=
literal|10
block|,
operator|.
name|p_flags
operator|=
name|PF_R
block|,
operator|.
name|p_align
operator|=
literal|4
block|}
block|,
block|{
operator|.
name|p_type
operator|=
name|PT_INTERP
block|,
operator|.
name|p_offset
operator|=
literal|11
block|,
operator|.
name|p_vaddr
operator|=
literal|12
block|,
operator|.
name|p_paddr
operator|=
literal|13
block|,
operator|.
name|p_filesz
operator|=
literal|14
block|,
operator|.
name|p_memsz
operator|=
literal|15
block|,
operator|.
name|p_flags
operator|=
name|PF_W
block|,
operator|.
name|p_align
operator|=
literal|8
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_phdr
parameter_list|(
name|TS_PHDR
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|TS_PHDR
modifier|*
name|pt
decl_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|phdr_testdata
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TS_NPHDR
condition|;
name|i
operator|++
control|)
block|{
define|#
directive|define
name|CHECK_PH_FIELD
parameter_list|(
name|FIELD
parameter_list|)
value|do {					\ 		if (p->p_##FIELD != pt->p_##FIELD) {			\ 			tet_printf("fail: [%d] field \"%s\" actual "	\ 			    "0x%jx != expected 0x%jx.", i, #FIELD, 	\ 			    (uintmax_t) p->p_##FIELD,			\ 			    (uintmax_t) pt->p_##FIELD);			\ 			result = TET_FAIL;				\ 		} \ 	} while (0)
name|CHECK_PH_FIELD
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|filesz
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|memsz
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|CHECK_PH_FIELD
argument_list|(
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TET_PASS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcNull_tpGet
parameter_list|(
name|void
parameter_list|)
block|{
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"(NULL) fails with "
literal|"ELF_E_ARGUMENT."
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_ICFUNC
argument_list|(
name|NULL
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
else|else
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|data
index|[]
init|=
literal|"This isn't an ELF file."
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tcData_tpElf
parameter_list|(
name|void
parameter_list|)
block|{
name|Elf
modifier|*
name|e
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"(E) for non-ELF (E) fails with "
literal|"ELF_E_ARGUMENT."
argument_list|)
expr_stmt|;
name|TS_OPEN_MEMORY
argument_list|(
name|e
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|!=
name|NULL
operator|||
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_ARGUMENT
condition|)
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
else|else
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A malformed (too short) ELF header.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|badelftemplate
index|[
name|EI_NIDENT
operator|+
literal|1
index|]
init|=
block|{
index|[
name|EI_MAG0
index|]
operator|=
literal|'\177'
block|,
index|[
name|EI_MAG1
index|]
operator|=
literal|'E'
block|,
index|[
name|EI_MAG2
index|]
operator|=
literal|'L'
block|,
index|[
name|EI_MAG3
index|]
operator|=
literal|'F'
block|,
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS64
block|,
index|[
name|EI_DATA
index|]
operator|=
name|ELFDATA2MSB
block|,
index|[
name|EI_NIDENT
index|]
operator|=
literal|'@'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tcBadElfVersion_tpElf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|char
name|badelf
index|[
sizeof|sizeof
argument_list|(
name|badelftemplate
argument_list|)
index|]
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"() with an unsupported version "
literal|"fails with ELF_E_VERSION."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|badelf
argument_list|,
name|badelftemplate
argument_list|,
sizeof|sizeof
argument_list|(
name|badelf
argument_list|)
argument_list|)
expr_stmt|;
name|badelf
index|[
name|EI_VERSION
index|]
operator|=
name|EV_NONE
expr_stmt|;
name|badelf
index|[
name|EI_CLASS
index|]
operator|=
name|TS_ELFCLASS
expr_stmt|;
name|TS_OPEN_MEMORY
argument_list|(
name|e
argument_list|,
name|badelf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|err
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
name|ELF_E_VERSION
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: error=%d ph=%p."
argument_list|,
name|err
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ph
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
block|}
else|else
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcBadElf_tpElf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|char
name|badelf
index|[
sizeof|sizeof
argument_list|(
name|badelftemplate
argument_list|)
index|]
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"() on a malformed ELF file "
literal|"fails with ELF_E_HEADER."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|badelf
argument_list|,
name|badelftemplate
argument_list|,
sizeof|sizeof
argument_list|(
name|badelf
argument_list|)
argument_list|)
expr_stmt|;
name|badelf
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|badelf
index|[
name|EI_CLASS
index|]
operator|=
name|TS_ELFCLASS
expr_stmt|;
name|TS_OPEN_MEMORY
argument_list|(
name|e
argument_list|,
name|badelf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|err
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
name|ELF_E_HEADER
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: error=%d ph=%p."
argument_list|,
name|err
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ph
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
block|}
else|else
name|tet_result
argument_list|(
name|TET_PASS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcElf_tpCorruptEhdr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|fd
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"(E) with corrupt phdr values "
literal|"the header returns E_HEADER."
argument_list|)
expr_stmt|;
name|fn
operator|=
literal|"ehdr.msb"
name|__XSTRING
argument_list|(
name|TS_PHDRSZ
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
name|fn
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|err
operator|=
operator|(
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_HEADER
operator|)
operator|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" (ph %p, error %d)"
argument_list|,
name|fn
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ph
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TET_PASS
condition|)
block|{
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|fn
operator|=
literal|"ehdr.lsb"
name|__XSTRING
argument_list|(
name|TS_PHDRSZ
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
name|fn
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|err
operator|=
operator|(
name|elf_errno
argument_list|()
operator|!=
name|ELF_E_HEADER
operator|)
operator|)
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" (ph %p, error %d)"
argument_list|,
name|fn
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ph
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcElf_tpElfLSB
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: "
name|TS_ICNAME
literal|"(E) returns the correct LSB phdr."
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
literal|"phdr.lsb"
name|__XSTRING
argument_list|(
name|TS_PHDRSZ
argument_list|)
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: "
name|TS_ICNAME
literal|"() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|tet_result
argument_list|(
name|check_phdr
argument_list|(
name|ph
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcElf_tpElfMSB
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion:"
name|TS_ICNAME
literal|"(E) returns the correct MSB phdr."
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
literal|"phdr.msb"
name|__XSTRING
argument_list|(
name|TS_PHDRSZ
argument_list|)
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"fail: "
name|TS_ICNAME
literal|"() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_FAIL
argument_list|)
expr_stmt|;
return|return;
block|}
name|tet_result
argument_list|(
name|check_phdr
argument_list|(
name|ph
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcElf_tpElfDup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph1
decl_stmt|,
modifier|*
name|ph2
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: successful calls to "
name|TS_ICNAME
literal|"() return "
literal|"identical pointers."
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
literal|"phdr.msb"
name|__XSTRING
argument_list|(
name|TS_PHDRSZ
argument_list|)
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph1
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ph2
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tet_infoline
argument_list|(
literal|"unresolved: "
name|TS_ICNAME
literal|"() failed."
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|TET_UNRESOLVED
argument_list|)
expr_stmt|;
return|return;
block|}
name|tet_result
argument_list|(
name|ph1
operator|==
name|ph2
condition|?
name|TET_PASS
else|:
name|TET_FAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|TS_PHDRSZ
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|TS_OTHERSIZE
value|64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TS_OTHERSIZE
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|tcElf_tpElfWrongSize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|result
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|TS_PHDR
modifier|*
name|ph
decl_stmt|;
name|TP_CHECK_INITIALIZATION
argument_list|()
expr_stmt|;
name|tet_infoline
argument_list|(
literal|"assertion: a call to "
name|TS_ICNAME
literal|"() and a mismatched "
literal|"ELF class fails with ELF_E_CLASS."
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_PASS
expr_stmt|;
name|fn
operator|=
literal|"phdr.msb"
name|__XSTRING
argument_list|(
name|TS_OTHERSIZE
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
name|fn
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|error
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
name|ELF_E_CLASS
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" opened (error %d)."
argument_list|,
name|fn
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|TET_PASS
condition|)
block|{
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|fn
operator|=
literal|"phdr.lsb"
name|__XSTRING
argument_list|(
name|TS_OTHERSIZE
argument_list|)
expr_stmt|;
name|TS_OPEN_FILE
argument_list|(
name|e
argument_list|,
name|fn
argument_list|,
name|ELF_C_READ
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|TS_ICFUNC
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|error
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
name|ELF_E_CLASS
condition|)
block|{
name|tet_printf
argument_list|(
literal|"fail: \"%s\" opened (error %d)."
argument_list|,
name|fn
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|result
operator|=
name|TET_FAIL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|tet_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

