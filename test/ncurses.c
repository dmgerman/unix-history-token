begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2010,2011 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  NAME    ncurses.c --- ncurses library exerciser  SYNOPSIS    ncurses  DESCRIPTION    An interactive test module for the ncurses library.  AUTHOR    Author: Eric S. Raymond<esr@snark.thyrsus.com> 1993            Thomas E. Dickey (beginning revision 1.27 in 1996).  $Id: ncurses.c,v 1.365 2011/01/22 19:48:33 tom Exp $  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_undef
undef|#
directive|undef
name|mvwdelch
end_undef

begin_comment
comment|/* HPUX 11.23 macro will not compile */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_GETTIMEOFDAY
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
operator|&&
name|HAVE_SYS_TIME_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_LIBPANEL
end_if

begin_include
include|#
directive|include
file|<panel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_LIBMENU
end_if

begin_include
include|#
directive|include
file|<menu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_LIBFORM
end_if

begin_include
include|#
directive|include
file|<form.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_VERSION
end_ifdef

begin_define
define|#
directive|define
name|NCURSES_CONST_PARAM
value|const void
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|save_trace
init|=
name|TRACE_ORDINARY
operator||
name|TRACE_ICALLS
operator||
name|TRACE_CALLS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|_nc_tracing
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NCURSES_CONST_PARAM
value|char
end_define

begin_define
define|#
directive|define
name|mmask_t
value|chtype
end_define

begin_comment
comment|/* not specified in XSI */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ACS_S3
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES_ACS_ARRAY
end_ifdef

begin_define
define|#
directive|define
name|ACS_S3
value|(CURSES_ACS_ARRAY['p'])
end_define

begin_comment
comment|/* scan line 3 */
end_comment

begin_define
define|#
directive|define
name|ACS_S7
value|(CURSES_ACS_ARRAY['r'])
end_define

begin_comment
comment|/* scan line 7 */
end_comment

begin_define
define|#
directive|define
name|ACS_LEQUAL
value|(CURSES_ACS_ARRAY['y'])
end_define

begin_comment
comment|/* less/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_GEQUAL
value|(CURSES_ACS_ARRAY['z'])
end_define

begin_comment
comment|/* greater/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_PI
value|(CURSES_ACS_ARRAY['{'])
end_define

begin_comment
comment|/* Pi */
end_comment

begin_define
define|#
directive|define
name|ACS_NEQUAL
value|(CURSES_ACS_ARRAY['|'])
end_define

begin_comment
comment|/* not equal */
end_comment

begin_define
define|#
directive|define
name|ACS_STERLING
value|(CURSES_ACS_ARRAY['}'])
end_define

begin_comment
comment|/* UK pound sign */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ACS_S3
value|(A_ALTCHARSET + 'p')
end_define

begin_comment
comment|/* scan line 3 */
end_comment

begin_define
define|#
directive|define
name|ACS_S7
value|(A_ALTCHARSET + 'r')
end_define

begin_comment
comment|/* scan line 7 */
end_comment

begin_define
define|#
directive|define
name|ACS_LEQUAL
value|(A_ALTCHARSET + 'y')
end_define

begin_comment
comment|/* less/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_GEQUAL
value|(A_ALTCHARSET + 'z')
end_define

begin_comment
comment|/* greater/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_PI
value|(A_ALTCHARSET + '{')
end_define

begin_comment
comment|/* Pi */
end_comment

begin_define
define|#
directive|define
name|ACS_NEQUAL
value|(A_ALTCHARSET + '|')
end_define

begin_comment
comment|/* not equal */
end_comment

begin_define
define|#
directive|define
name|ACS_STERLING
value|(A_ALTCHARSET + '}')
end_define

begin_comment
comment|/* UK pound sign */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACS_S3 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WACS_S3
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES_WACS_ARRAY
end_ifdef

begin_define
define|#
directive|define
name|WACS_S3
value|(&(CURSES_WACS_ARRAY['p']))
end_define

begin_comment
comment|/* scan line 3 */
end_comment

begin_define
define|#
directive|define
name|WACS_S7
value|(&(CURSES_WACS_ARRAY['r']))
end_define

begin_comment
comment|/* scan line 7 */
end_comment

begin_define
define|#
directive|define
name|WACS_LEQUAL
value|(&(CURSES_WACS_ARRAY['y']))
end_define

begin_comment
comment|/* less/equal */
end_comment

begin_define
define|#
directive|define
name|WACS_GEQUAL
value|(&(CURSES_WACS_ARRAY['z']))
end_define

begin_comment
comment|/* greater/equal */
end_comment

begin_define
define|#
directive|define
name|WACS_PI
value|(&(CURSES_WACS_ARRAY['{']))
end_define

begin_comment
comment|/* Pi */
end_comment

begin_define
define|#
directive|define
name|WACS_NEQUAL
value|(&(CURSES_WACS_ARRAY['|']))
end_define

begin_comment
comment|/* not equal */
end_comment

begin_define
define|#
directive|define
name|WACS_STERLING
value|(&(CURSES_WACS_ARRAY['}']))
end_define

begin_comment
comment|/* UK pound sign */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_WCSRTOMBS
end_if

begin_define
define|#
directive|define
name|count_wchars
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|wcsrtombs(0,&src, len, state)
end_define

begin_define
define|#
directive|define
name|trans_wchars
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|wcsrtombs(dst,&src, len, state)
end_define

begin_define
define|#
directive|define
name|reset_wchars
parameter_list|(
name|state
parameter_list|)
value|init_mb(state)
end_define

begin_elif
elif|#
directive|elif
name|HAVE_WCSTOMBS
operator|&&
name|HAVE_MBTOWC
operator|&&
name|HAVE_MBLEN
end_elif

begin_define
define|#
directive|define
name|count_wchars
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|wcstombs(0,   src, len)
end_define

begin_define
define|#
directive|define
name|trans_wchars
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|wcstombs(dst, src, len)
end_define

begin_define
define|#
directive|define
name|reset_wchars
parameter_list|(
name|state
parameter_list|)
value|IGNORE_RC(mblen(NULL, 0)), IGNORE_RC(mbtowc(NULL, NULL, 0))
end_define

begin_define
define|#
directive|define
name|state_unused
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_MBSRTOWCS
end_if

begin_define
define|#
directive|define
name|count_mbytes
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|mbsrtowcs(0,&src, len, state)
end_define

begin_define
define|#
directive|define
name|trans_mbytes
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|mbsrtowcs(dst,&src, len, state)
end_define

begin_define
define|#
directive|define
name|reset_mbytes
parameter_list|(
name|state
parameter_list|)
value|init_mb(state)
end_define

begin_elif
elif|#
directive|elif
name|HAVE_MBSTOWCS
operator|&&
name|HAVE_MBTOWC
operator|&&
name|HAVE_MBLEN
end_elif

begin_define
define|#
directive|define
name|count_mbytes
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|mbstowcs(0,   src, len)
end_define

begin_define
define|#
directive|define
name|trans_mbytes
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|,
name|state
parameter_list|)
value|mbstowcs(dst, src, len)
end_define

begin_define
define|#
directive|define
name|reset_mbytes
parameter_list|(
name|state
parameter_list|)
value|IGNORE_RC(mblen(NULL, 0)), IGNORE_RC(mbtowc(NULL, NULL, 0))
end_define

begin_define
define|#
directive|define
name|state_unused
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ToggleAcs
parameter_list|(
name|temp
parameter_list|,
name|real
parameter_list|)
value|temp = ((temp == real) ? 0 : real)
end_define

begin_define
define|#
directive|define
name|P
parameter_list|(
name|string
parameter_list|)
value|printw("%s\n", string)
end_define

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_comment
comment|/* this is the background character */
end_comment

begin_undef
undef|#
directive|undef
name|max_colors
end_undef

begin_decl_stmt
specifier|static
name|int
name|max_colors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the actual number of colors we'll use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|min_colors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the minimum color code */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|use_colors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we use colors */
end_comment

begin_undef
undef|#
directive|undef
name|max_pairs
end_undef

begin_decl_stmt
specifier|static
name|int
name|max_pairs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ...and the number of color pairs */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|red
decl_stmt|;
name|short
name|green
decl_stmt|;
name|short
name|blue
decl_stmt|;
block|}
name|RGB_DATA
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|RGB_DATA
modifier|*
name|all_colors
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|main_menu
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The behavior of mvhline, mvvline for negative/zero length is unspecified,  * though we can rely on negative x/y values to stop the macro.  */
end_comment

begin_function
specifier|static
name|void
name|do_h_line
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|chtype
name|c
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|(
name|to
operator|)
operator|>
operator|(
name|x
operator|)
condition|)
name|MvHLine
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|c
argument_list|,
operator|(
name|to
operator|)
operator|-
operator|(
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_v_line
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|chtype
name|c
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|(
name|to
operator|)
operator|>
operator|(
name|y
operator|)
condition|)
name|MvVLine
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|c
argument_list|,
operator|(
name|to
operator|)
operator|-
operator|(
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Repaint
parameter_list|(
name|void
parameter_list|)
block|{
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isQuit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|c
operator|)
operator|==
name|QUIT
operator|||
operator|(
name|c
operator|)
operator|==
name|ESCAPE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|case_QUIT
value|QUIT: case ESCAPE
end_define

begin_comment
comment|/* Common function to allow ^T to toggle trace-mode in the middle of a test  * so that trace-files can be made smaller.  */
end_comment

begin_function
specifier|static
name|int
name|wGetchar
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
while|while
condition|(
operator|(
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
operator|)
operator|==
name|CTRL
argument_list|(
literal|'T'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_nc_tracing
condition|)
block|{
name|save_trace
operator|=
name|_nc_tracing
expr_stmt|;
name|Trace
argument_list|(
operator|(
literal|"TOGGLE-TRACING OFF"
operator|)
argument_list|)
expr_stmt|;
name|_nc_tracing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_nc_tracing
operator|=
name|save_trace
expr_stmt|;
block|}
name|trace
argument_list|(
name|_nc_tracing
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_tracing
condition|)
name|Trace
argument_list|(
operator|(
literal|"TOGGLE-TRACING ON"
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Getchar
parameter_list|()
value|wGetchar(stdscr)
end_define

begin_comment
comment|/* replaces wgetnstr(), since we want to be able to edit values */
end_comment

begin_function
specifier|static
name|void
name|wGetstring
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|,
name|x
decl_stmt|,
name|ch
decl_stmt|;
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|x
operator|>
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
condition|)
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%-*s"
argument_list|,
name|limit
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
operator|+
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
operator|=
name|wGetchar
argument_list|(
name|win
argument_list|)
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
name|KEY_ENTER
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'U'
argument_list|)
case|:
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
case|case
name|KEY_BACKSPACE
case|:
case|case
name|KEY_DC
case|:
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
operator|--
name|x
init|;
operator|(
name|buffer
index|[
name|j
index|]
operator|=
name|buffer
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|j
control|)
block|{
empty_stmt|;
block|}
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KEY_LEFT
case|:
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
operator|--
name|x
expr_stmt|;
block|}
else|else
block|{
name|flash
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KEY_RIGHT
case|:
operator|++
name|x
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|>=
name|KEY_MIN
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|<
name|limit
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
init|;
name|j
operator|>
name|x
condition|;
operator|--
name|j
control|)
block|{
name|buffer
index|[
name|j
index|]
operator|=
name|buffer
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|buffer
index|[
name|x
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
else|else
block|{
name|flash
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|wattroff
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_function
specifier|static
name|wchar_t
name|fullwidth_of
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|+
literal|0xff10
operator|-
literal|'0'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_fullwidth_text
parameter_list|(
name|wchar_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|source
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|target
operator|++
operator|=
name|fullwidth_of
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
operator|*
name|target
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_narrow_text
parameter_list|(
name|wchar_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|source
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|target
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|target
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_LIBPANEL
end_if

begin_function
specifier|static
name|void
name|make_fullwidth_digit
parameter_list|(
name|cchar_t
modifier|*
name|target
parameter_list|,
name|int
name|digit
parameter_list|)
block|{
name|wchar_t
name|source
index|[
literal|2
index|]
decl_stmt|;
name|source
index|[
literal|0
index|]
operator|=
name|fullwidth_of
argument_list|(
name|digit
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|source
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|setcchar
argument_list|(
name|target
argument_list|,
name|source
argument_list|,
name|A_NORMAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wGet_wchar
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|wint_t
modifier|*
name|result
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
while|while
condition|(
operator|(
name|c
operator|=
name|wget_wch
argument_list|(
name|win
argument_list|,
name|result
argument_list|)
operator|)
operator|==
name|CTRL
argument_list|(
literal|'T'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_nc_tracing
condition|)
block|{
name|save_trace
operator|=
name|_nc_tracing
expr_stmt|;
name|Trace
argument_list|(
operator|(
literal|"TOGGLE-TRACING OFF"
operator|)
argument_list|)
expr_stmt|;
name|_nc_tracing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_nc_tracing
operator|=
name|save_trace
expr_stmt|;
block|}
name|trace
argument_list|(
name|_nc_tracing
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_tracing
condition|)
name|Trace
argument_list|(
operator|(
literal|"TOGGLE-TRACING ON"
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
name|wget_wch
argument_list|(
name|win
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Get_wchar
parameter_list|(
name|result
parameter_list|)
value|wGet_wchar(stdscr, result)
end_define

begin_comment
comment|/* replaces wgetn_wstr(), since we want to be able to edit values */
end_comment

begin_function
specifier|static
name|void
name|wGet_wstring
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|wchar_t
modifier|*
name|buffer
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|y0
decl_stmt|,
name|x0
decl_stmt|,
name|x
decl_stmt|;
name|wint_t
name|ch
decl_stmt|;
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|bool
name|fkey
init|=
name|FALSE
decl_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|x
operator|>
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|buffer
argument_list|)
condition|)
name|x
operator|=
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* clear the "window' */
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%*s"
argument_list|,
name|limit
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* write the existing buffer contents */
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|waddnwstr
argument_list|(
name|win
argument_list|,
name|buffer
argument_list|,
name|limit
argument_list|)
expr_stmt|;
comment|/* positions the cursor past character 'x' */
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|waddnwstr
argument_list|(
name|win
argument_list|,
name|buffer
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wGet_wchar
argument_list|(
name|win
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
block|{
case|case
name|KEY_CODE_YES
case|:
name|fkey
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|KEY_ENTER
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
name|fkey
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|KEY_BACKSPACE
case|:
case|case
name|KEY_DC
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
name|fkey
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
case|case
name|KEY_RIGHT
case|:
break|break;
default|default:
name|ch
operator|=
operator|(
name|wint_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OK
case|:
name|fkey
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|ch
operator|=
operator|(
name|wint_t
operator|)
operator|-
literal|1
expr_stmt|;
name|fkey
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'U'
argument_list|)
case|:
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
operator|--
name|x
init|;
operator|(
name|buffer
index|[
name|j
index|]
operator|=
name|buffer
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|j
control|)
block|{
empty_stmt|;
block|}
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KEY_LEFT
case|:
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
operator|--
name|x
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KEY_RIGHT
case|:
operator|++
name|x
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fkey
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|buffer
argument_list|)
operator|<
name|limit
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
init|;
name|j
operator|>
name|x
condition|;
operator|--
name|j
control|)
block|{
name|buffer
index|[
name|j
index|]
operator|=
name|buffer
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|buffer
index|[
name|x
operator|++
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|ch
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|wattroff
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|Pause
parameter_list|(
name|void
parameter_list|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Getchar
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Cannot
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|printw
argument_list|(
literal|"\nThis %s terminal %s\n\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ShellOut
parameter_list|(
name|bool
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
condition|)
name|addstr
argument_list|(
literal|"Shelling out..."
argument_list|)
expr_stmt|;
name|def_prog_mode
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__MINGW32__
name|system
argument_list|(
literal|"cmd.exe"
argument_list|)
expr_stmt|;
else|#
directive|else
name|system
argument_list|(
literal|"sh"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|message
condition|)
name|addstr
argument_list|(
literal|"returned from shellout.\n"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
end_ifdef

begin_comment
comment|/*  * This function is the same as _tracemouse(), but we cannot count on that  * being available in the non-debug library.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mouse_decode
parameter_list|(
name|MEVENT
specifier|const
modifier|*
name|ep
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
operator|+
operator|(
literal|5
operator|*
literal|10
operator|)
operator|+
operator|(
literal|32
operator|*
literal|15
operator|)
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"id %2d at (%2d, %2d, %d) state %4lx = {"
argument_list|,
name|ep
operator|->
name|id
argument_list|,
name|ep
operator|->
name|x
argument_list|,
name|ep
operator|->
name|y
argument_list|,
name|ep
operator|->
name|z
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ep
operator|->
name|bstate
argument_list|)
expr_stmt|;
define|#
directive|define
name|SHOW
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
value|if ((ep->bstate& m)==m) {strcat(buf,s); strcat(buf, ", ");}
name|SHOW
argument_list|(
name|BUTTON1_RELEASED
argument_list|,
literal|"release-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_PRESSED
argument_list|,
literal|"press-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_CLICKED
argument_list|,
literal|"click-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-1"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|1
name|SHOW
argument_list|(
name|BUTTON1_RESERVED_EVENT
argument_list|,
literal|"reserved-1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SHOW
argument_list|(
name|BUTTON2_RELEASED
argument_list|,
literal|"release-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_PRESSED
argument_list|,
literal|"press-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_CLICKED
argument_list|,
literal|"click-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-2"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|1
name|SHOW
argument_list|(
name|BUTTON2_RESERVED_EVENT
argument_list|,
literal|"reserved-2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SHOW
argument_list|(
name|BUTTON3_RELEASED
argument_list|,
literal|"release-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_PRESSED
argument_list|,
literal|"press-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_CLICKED
argument_list|,
literal|"click-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-3"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|1
name|SHOW
argument_list|(
name|BUTTON3_RESERVED_EVENT
argument_list|,
literal|"reserved-3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SHOW
argument_list|(
name|BUTTON4_RELEASED
argument_list|,
literal|"release-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_PRESSED
argument_list|,
literal|"press-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_CLICKED
argument_list|,
literal|"click-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-4"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|1
name|SHOW
argument_list|(
name|BUTTON4_RESERVED_EVENT
argument_list|,
literal|"reserved-4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|2
name|SHOW
argument_list|(
name|BUTTON5_RELEASED
argument_list|,
literal|"release-5"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON5_PRESSED
argument_list|,
literal|"press-5"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON5_CLICKED
argument_list|,
literal|"click-5"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON5_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-5"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON5_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SHOW
argument_list|(
name|BUTTON_CTRL
argument_list|,
literal|"ctrl"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON_SHIFT
argument_list|,
literal|"shift"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON_ALT
argument_list|,
literal|"alt"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
literal|"all-events"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|REPORT_MOUSE_POSITION
argument_list|,
literal|"position"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SHOW
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_mouse
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|MEVENT
name|event
decl_stmt|;
name|bool
name|outside
decl_stmt|;
name|bool
name|show_loc
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|outside
operator|=
operator|!
name|wenclose
argument_list|(
name|win
argument_list|,
name|event
operator|.
name|y
argument_list|,
name|event
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|outside
condition|)
block|{
operator|(
name|void
operator|)
name|wstandout
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"KEY_MOUSE"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wstandend
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"KEY_MOUSE"
argument_list|)
expr_stmt|;
block|}
name|wprintw
argument_list|(
name|win
argument_list|,
literal|", %s"
argument_list|,
name|mouse_decode
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outside
condition|)
name|win
operator|=
name|stdscr
expr_stmt|;
name|show_loc
operator|=
name|wmouse_trafo
argument_list|(
name|win
argument_list|,
operator|&
name|event
operator|.
name|y
argument_list|,
operator|&
name|event
operator|.
name|x
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_loc
condition|)
block|{
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|event
operator|.
name|y
argument_list|,
name|event
operator|.
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outside
condition|)
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCURSES_MOUSE_VERSION */
end_comment

begin_comment
comment|/****************************************************************************  *  * Character input test  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|NUM_GETCH_FLAGS
value|256
end_define

begin_typedef
typedef|typedef
name|bool
name|GetchFlags
index|[
name|NUM_GETCH_FLAGS
index|]
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|setup_getch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|GetchFlags
name|flags
parameter_list|)
block|{
name|keypad
argument_list|(
name|win
argument_list|,
name|flags
index|[
literal|'k'
index|]
argument_list|)
expr_stmt|;
comment|/* should be redundant, but for testing */
name|meta
argument_list|(
name|win
argument_list|,
name|flags
index|[
literal|'m'
index|]
argument_list|)
expr_stmt|;
comment|/* force this to a known state */
if|if
condition|(
name|flags
index|[
literal|'e'
index|]
condition|)
name|echo
argument_list|()
expr_stmt|;
else|else
name|noecho
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_getch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|GetchFlags
name|flags
parameter_list|)
block|{
name|memset
argument_list|(
name|flags
argument_list|,
name|FALSE
argument_list|,
name|NUM_GETCH_FLAGS
argument_list|)
expr_stmt|;
name|flags
index|[
name|UChar
argument_list|(
literal|'k'
argument_list|)
index|]
operator|=
operator|(
name|win
operator|==
name|stdscr
operator|)
expr_stmt|;
name|flags
index|[
name|UChar
argument_list|(
literal|'m'
argument_list|)
index|]
operator|=
name|TRUE
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wgetch_help
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|GetchFlags
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|help
index|[]
init|=
block|{
literal|"e  -- toggle echo mode"
block|,
literal|"g  -- triggers a getstr test"
block|,
literal|"k  -- toggle keypad/literal mode"
block|,
literal|"m  -- toggle meta (7-bit/8-bit) mode"
block|,
literal|"^q -- quit"
block|,
literal|"s  -- shell out\n"
block|,
literal|"w  -- create a new window"
ifdef|#
directive|ifdef
name|SIGTSTP
block|,
literal|"z  -- suspend this process"
endif|#
directive|endif
block|}
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|unsigned
name|chk
init|=
operator|(
operator|(
name|SIZEOF
argument_list|(
name|help
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Type any key to see its %s value.  Also:\n"
argument_list|,
name|flags
index|[
literal|'k'
index|]
condition|?
literal|"keypad"
else|:
literal|"literal"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|help
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
name|int
name|row
init|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|n
operator|%
name|chk
argument_list|)
decl_stmt|;
name|int
name|col
init|=
operator|(
name|n
operator|>=
name|chk
operator|)
condition|?
name|COLS
operator|/
literal|2
else|:
literal|0
decl_stmt|;
name|int
name|flg
init|=
operator|(
operator|(
name|strstr
argument_list|(
name|help
index|[
name|n
index|]
argument_list|,
literal|"toggle"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|flags
index|[
name|UChar
argument_list|(
operator|*
name|help
index|[
name|n
index|]
argument_list|)
index|]
operator|!=
name|FALSE
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|flg
condition|)
operator|(
name|void
operator|)
name|standout
argument_list|()
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%s"
argument_list|,
name|help
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|clrtoeol
argument_list|()
expr_stmt|;
if|if
condition|(
name|flg
condition|)
operator|(
name|void
operator|)
name|standend
argument_list|()
expr_stmt|;
block|}
name|wrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wgetch_wrap
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|first_y
parameter_list|)
block|{
name|int
name|last_y
init|=
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|y
init|=
name|getcury
argument_list|(
name|win
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|y
operator|>=
name|last_y
condition|)
name|y
operator|=
name|first_y
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
end_if

begin_typedef
typedef|typedef
struct|struct
block|{
name|WINDOW
modifier|*
name|text
decl_stmt|;
name|WINDOW
modifier|*
name|frame
decl_stmt|;
block|}
name|WINSTACK
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WINSTACK
modifier|*
name|winstack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|len_winstack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|forget_boxes
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|winstack
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|winstack
argument_list|)
expr_stmt|;
block|}
name|winstack
operator|=
literal|0
expr_stmt|;
name|len_winstack
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remember_boxes
parameter_list|(
name|unsigned
name|level
parameter_list|,
name|WINDOW
modifier|*
name|txt_win
parameter_list|,
name|WINDOW
modifier|*
name|box_win
parameter_list|)
block|{
name|unsigned
name|need
init|=
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|2
decl_stmt|;
name|assert
argument_list|(
name|level
operator|<
operator|(
name|unsigned
operator|)
name|COLS
argument_list|)
expr_stmt|;
if|if
condition|(
name|winstack
operator|==
literal|0
condition|)
block|{
name|len_winstack
operator|=
literal|20
expr_stmt|;
name|winstack
operator|=
name|typeMalloc
argument_list|(
name|WINSTACK
argument_list|,
name|len_winstack
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need
operator|>=
name|len_winstack
condition|)
block|{
name|len_winstack
operator|=
name|need
expr_stmt|;
name|winstack
operator|=
name|typeRealloc
argument_list|(
name|WINSTACK
argument_list|,
name|len_winstack
argument_list|,
name|winstack
argument_list|)
expr_stmt|;
block|}
name|winstack
index|[
name|level
index|]
operator|.
name|text
operator|=
name|txt_win
expr_stmt|;
name|winstack
index|[
name|level
index|]
operator|.
name|frame
operator|=
name|box_win
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_SOFTKEYS
operator|&&
operator|(
name|defined
argument_list|(
name|NCURSES_VERSION_PATCH
argument_list|)
operator|&&
name|NCURSES_VERSION_PATCH
operator|<
literal|20071229
operator|)
operator|&&
name|NCURSES_EXT_FUNCS
end_if

begin_function
specifier|static
name|void
name|slk_repaint
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* this chunk is now done in resize_term() */
name|slk_touch
argument_list|()
expr_stmt|;
name|slk_clear
argument_list|()
expr_stmt|;
name|slk_noutrefresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|slk_repaint
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
end_if

begin_comment
comment|/*  * For wgetch_test(), we create pairs of windows - one for a box, one for text.  * Resize both and paint the box in the parent.  */
end_comment

begin_function
specifier|static
name|void
name|resize_boxes
parameter_list|(
name|unsigned
name|level
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|base
init|=
literal|5
decl_stmt|;
name|int
name|high
init|=
name|LINES
operator|-
name|base
decl_stmt|;
name|int
name|wide
init|=
name|COLS
decl_stmt|;
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|slk_repaint
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|level
condition|;
operator|++
name|n
control|)
block|{
name|wresize
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|,
name|high
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|wresize
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|,
name|high
operator|-
literal|2
argument_list|,
name|wide
operator|-
literal|2
argument_list|)
expr_stmt|;
name|high
operator|-=
literal|2
expr_stmt|;
name|wide
operator|-=
literal|2
expr_stmt|;
name|werase
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|,
literal|"size %dx%d\n"
argument_list|,
name|getmaxy
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
operator|==
name|win
condition|)
break|break;
block|}
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* resize_boxes */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|forget_boxes
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|remember_boxes
parameter_list|(
name|level
parameter_list|,
name|text
parameter_list|,
name|frame
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|wgetch_test
parameter_list|(
name|unsigned
name|level
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|first_y
decl_stmt|,
name|first_x
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|incount
init|=
literal|0
decl_stmt|;
name|GetchFlags
name|flags
decl_stmt|;
name|bool
name|blocking
init|=
operator|(
name|delay
operator|<
literal|0
operator|)
decl_stmt|;
name|init_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wtimeout
argument_list|(
name|win
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|,
name|first_x
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wsetscrreg
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|,
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|wGetchar
argument_list|(
name|win
argument_list|)
operator|)
operator|==
name|ERR
condition|)
block|{
name|incount
operator|++
expr_stmt|;
if|if
condition|(
name|blocking
condition|)
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%05d: input error"
argument_list|,
name|incount
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%05d: input timed out"
argument_list|,
name|incount
argument_list|)
expr_stmt|;
block|}
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|ERR
operator|&&
name|blocking
condition|)
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"ERR"
argument_list|)
expr_stmt|;
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isQuit
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'e'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'e'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
block|{
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"getstr test: "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wgetnstr
argument_list|(
name|win
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"I saw %d characters:\n\t`%s'."
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'k'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'k'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'k'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'m'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'m'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|ShellOut
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'w'
condition|)
block|{
name|int
name|high
init|=
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
operator|-
name|first_y
operator|+
literal|1
decl_stmt|;
name|int
name|wide
init|=
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
name|first_x
decl_stmt|;
name|int
name|old_y
decl_stmt|,
name|old_x
decl_stmt|;
name|int
name|new_y
init|=
name|first_y
operator|+
name|getbegy
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|new_x
init|=
name|first_x
operator|+
name|getbegx
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|old_y
argument_list|,
name|old_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|>
literal|2
operator|&&
name|wide
operator|>
literal|2
condition|)
block|{
name|WINDOW
modifier|*
name|wb
init|=
name|newwin
argument_list|(
name|high
argument_list|,
name|wide
argument_list|,
name|new_y
argument_list|,
name|new_x
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|wi
init|=
name|newwin
argument_list|(
name|high
operator|-
literal|2
argument_list|,
name|wide
operator|-
literal|2
argument_list|,
name|new_y
operator|+
literal|1
argument_list|,
name|new_x
operator|+
literal|1
argument_list|)
decl_stmt|;
name|box
argument_list|(
name|wb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|wi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remember_boxes
argument_list|(
name|level
argument_list|,
name|wi
argument_list|,
name|wb
argument_list|)
expr_stmt|;
name|wgetch_test
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|wi
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|wi
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|old_y
argument_list|,
name|old_x
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTSTP
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'z'
condition|)
block|{
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Key pressed: %04o "
argument_list|,
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
if|if
condition|(
name|c
operator|==
name|KEY_MOUSE
condition|)
block|{
name|show_mouse
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NCURSES_MOUSE_VERSION */
if|if
condition|(
name|c
operator|>=
name|KEY_MIN
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
if|if
condition|(
name|c
operator|==
name|KEY_RESIZE
condition|)
block|{
name|resize_boxes
argument_list|(
name|level
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
name|keyname
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0x80
condition|)
block|{
name|unsigned
name|c2
init|=
operator|(
name|unsigned
operator|)
name|c
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|||
name|defined
argument_list|(
name|_XOPEN_CURSES
argument_list|)
operator|)
comment|/* at least Solaris SVR4 curses breaks unctrl(128), etc. */
name|c2
operator|&=
literal|0x7f
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%c"
argument_list|,
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c2
operator|!=
name|UChar
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"M-%s"
argument_list|,
name|unctrl
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%s"
argument_list|,
name|unctrl
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|" (high-half character)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%c (ASCII printable character)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%s (ASCII control character)"
argument_list|,
name|unctrl
argument_list|(
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
block|}
name|wtimeout
argument_list|(
name|win
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
name|init_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|begin_getch_test
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|delay
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Delay in 10ths of a second (<CR> for blocking input)? "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getnstr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|delay
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
operator|*
literal|100
expr_stmt|;
block|}
else|else
block|{
name|delay
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|raw
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|delay
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_getch_test
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|erase
argument_list|()
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getch_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|delay
init|=
name|begin_getch_test
argument_list|()
decl_stmt|;
name|slk_restore
argument_list|()
expr_stmt|;
name|wgetch_test
argument_list|(
literal|0
argument_list|,
name|stdscr
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|forget_boxes
argument_list|()
expr_stmt|;
name|finish_getch_test
argument_list|()
expr_stmt|;
name|slk_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_comment
comment|/*  * For wget_wch_test(), we create pairs of windows - one for a box, one for text.  * Resize both and paint the box in the parent.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
end_if

begin_function
specifier|static
name|void
name|resize_wide_boxes
parameter_list|(
name|unsigned
name|level
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|base
init|=
literal|5
decl_stmt|;
name|int
name|high
init|=
name|LINES
operator|-
name|base
decl_stmt|;
name|int
name|wide
init|=
name|COLS
decl_stmt|;
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|slk_repaint
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|level
condition|;
operator|++
name|n
control|)
block|{
name|wresize
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|,
name|high
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|wresize
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|,
name|high
operator|-
literal|2
argument_list|,
name|wide
operator|-
literal|2
argument_list|)
expr_stmt|;
name|high
operator|-=
literal|2
expr_stmt|;
name|wide
operator|-=
literal|2
expr_stmt|;
name|werase
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|box_set
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|frame
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|,
literal|"size %dx%d\n"
argument_list|,
name|getmaxy
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|winstack
index|[
name|n
index|]
operator|.
name|text
operator|==
name|win
condition|)
break|break;
block|}
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEY_RESIZE */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|wcstos
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|src
parameter_list|)
block|{
name|int
name|need
decl_stmt|;
name|char
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|tmp
init|=
name|src
decl_stmt|;
ifndef|#
directive|ifndef
name|state_unused
name|mbstate_t
name|state
decl_stmt|;
endif|#
directive|endif
name|reset_wchars
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|need
operator|=
operator|(
name|int
operator|)
name|count_wchars
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
operator|&
name|state
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|have
init|=
operator|(
name|unsigned
operator|)
name|need
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|typeCalloc
argument_list|(
name|char
argument_list|,
name|have
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|trans_wchars
argument_list|(
name|result
argument_list|,
name|tmp
argument_list|,
name|have
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
name|have
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wget_wch_test
parameter_list|(
name|unsigned
name|level
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|wchar_t
name|wchar_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|wint_t
name|wint_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|first_y
decl_stmt|,
name|first_x
decl_stmt|;
name|wint_t
name|c
decl_stmt|;
name|int
name|incount
init|=
literal|0
decl_stmt|;
name|GetchFlags
name|flags
decl_stmt|;
name|bool
name|blocking
init|=
operator|(
name|delay
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|init_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wtimeout
argument_list|(
name|win
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|,
name|first_x
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wsetscrreg
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|,
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|code
operator|=
name|wGet_wchar
argument_list|(
name|win
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|==
name|ERR
condition|)
block|{
name|incount
operator|++
expr_stmt|;
if|if
condition|(
name|blocking
condition|)
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%05d: input error"
argument_list|,
name|incount
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"%05d: input timed out"
argument_list|,
name|incount
argument_list|)
expr_stmt|;
block|}
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|ERR
operator|&&
name|blocking
condition|)
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"ERR"
argument_list|)
expr_stmt|;
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isQuit
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'e'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'e'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
block|{
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"getstr test: "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|code
operator|=
name|wgetn_wstr
argument_list|(
name|win
argument_list|,
name|wint_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|wint_buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ERR
condition|)
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"wgetn_wstr returns an error."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|wchar_buf
index|[
name|n
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|wint_buf
index|[
name|n
index|]
operator|)
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|wcstos
argument_list|(
name|wchar_buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"I saw %d characters:\n\t`%s'."
argument_list|,
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|wchar_buf
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"I saw %d characters (cannot convert)."
argument_list|,
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|wchar_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'k'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'k'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'k'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|flags
index|[
name|UChar
argument_list|(
literal|'m'
argument_list|)
index|]
operator|=
operator|!
name|flags
index|[
name|UChar
argument_list|(
literal|'m'
argument_list|)
index|]
expr_stmt|;
name|setup_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|ShellOut
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'w'
condition|)
block|{
name|int
name|high
init|=
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
operator|-
name|first_y
operator|+
literal|1
decl_stmt|;
name|int
name|wide
init|=
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
name|first_x
decl_stmt|;
name|int
name|old_y
decl_stmt|,
name|old_x
decl_stmt|;
name|int
name|new_y
init|=
name|first_y
operator|+
name|getbegy
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|new_x
init|=
name|first_x
operator|+
name|getbegx
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|old_y
argument_list|,
name|old_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|>
literal|2
operator|&&
name|wide
operator|>
literal|2
condition|)
block|{
name|WINDOW
modifier|*
name|wb
init|=
name|newwin
argument_list|(
name|high
argument_list|,
name|wide
argument_list|,
name|new_y
argument_list|,
name|new_x
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|wi
init|=
name|newwin
argument_list|(
name|high
operator|-
literal|2
argument_list|,
name|wide
operator|-
literal|2
argument_list|,
name|new_y
operator|+
literal|1
argument_list|,
name|new_x
operator|+
literal|1
argument_list|)
decl_stmt|;
name|box_set
argument_list|(
name|wb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|wi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remember_boxes
argument_list|(
name|level
argument_list|,
name|wi
argument_list|,
name|wb
argument_list|)
expr_stmt|;
name|wget_wch_test
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|wi
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|wi
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|wgetch_help
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|old_y
argument_list|,
name|old_x
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTSTP
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'z'
condition|)
block|{
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Key pressed: %04o "
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
if|if
condition|(
name|c
operator|==
name|KEY_MOUSE
condition|)
block|{
name|show_mouse
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NCURSES_MOUSE_VERSION */
if|if
condition|(
name|code
operator|==
name|KEY_CODE_YES
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
if|if
condition|(
name|c
operator|==
name|KEY_RESIZE
condition|)
block|{
name|resize_wide_boxes
argument_list|(
name|level
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
name|keyname
argument_list|(
operator|(
name|wchar_t
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
name|key_name
argument_list|(
operator|(
name|wchar_t
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|" (control character)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|" = %#x (printable character)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|wgetch_wrap
argument_list|(
name|win
argument_list|,
name|first_y
argument_list|)
expr_stmt|;
block|}
block|}
name|wtimeout
argument_list|(
name|win
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
name|init_getch
argument_list|(
name|win
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_wch_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|delay
init|=
name|begin_getch_test
argument_list|()
decl_stmt|;
name|slk_restore
argument_list|()
expr_stmt|;
name|wget_wch_test
argument_list|(
literal|0
argument_list|,
name|stdscr
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|forget_boxes
argument_list|()
expr_stmt|;
name|finish_getch_test
argument_list|()
expr_stmt|;
name|slk_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************  *  * Character attributes test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|HAVE_SETUPTERM
operator|||
name|HAVE_TGETENT
end_if

begin_define
define|#
directive|define
name|get_ncv
parameter_list|()
value|TIGETNUM("ncv","NC")
end_define

begin_define
define|#
directive|define
name|get_xmc
parameter_list|()
value|TIGETNUM("xmc","sg")
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|get_ncv
parameter_list|()
value|-1
end_define

begin_define
define|#
directive|define
name|get_xmc
parameter_list|()
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_TERMATTRS
end_if

begin_function
specifier|static
name|chtype
name|my_termattrs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|first
init|=
name|TRUE
decl_stmt|;
specifier|static
name|chtype
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_TIGETSTR
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|char
name|parsed
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|area_pointer
init|=
name|parsed
decl_stmt|;
name|tgetent
argument_list|(
name|buffer
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"smso"
argument_list|,
literal|"so"
argument_list|)
condition|)
name|result
operator||=
name|A_STANDOUT
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"smul"
argument_list|,
literal|"us"
argument_list|)
condition|)
name|result
operator||=
name|A_UNDERLINE
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"rev"
argument_list|,
literal|"mr"
argument_list|)
condition|)
name|result
operator||=
name|A_REVERSE
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"blink"
argument_list|,
literal|"mb"
argument_list|)
condition|)
name|result
operator||=
name|A_BLINK
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"dim"
argument_list|,
literal|"mh"
argument_list|)
condition|)
name|result
operator||=
name|A_DIM
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"bold"
argument_list|,
literal|"md"
argument_list|)
condition|)
name|result
operator||=
name|A_BOLD
expr_stmt|;
if|if
condition|(
name|TIGETSTR
argument_list|(
literal|"smacs"
argument_list|,
literal|"ac"
argument_list|)
condition|)
name|result
operator||=
name|A_ALTCHARSET
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|termattrs
parameter_list|()
value|my_termattrs()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_ATTRSTRING
value|31
end_define

begin_define
define|#
directive|define
name|LEN_ATTRSTRING
value|26
end_define

begin_decl_stmt
specifier|static
name|char
name|attr_test_string
index|[
name|MAX_ATTRSTRING
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|attr_legend
parameter_list|(
name|WINDOW
modifier|*
name|helpwin
parameter_list|)
block|{
name|int
name|row
init|=
literal|1
decl_stmt|;
name|int
name|col
init|=
literal|1
decl_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"ESC to exit."
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"^L repaints."
argument_list|)
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"Modify the test strings:"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  A digit sets gaps on each side of displayed attributes"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"</> shifts the text left/right. "
argument_list|)
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"Toggles:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  f/F/b/F toggle foreground/background background color"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  t/T     toggle text/background color attribute"
argument_list|)
expr_stmt|;
block|}
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  a/A     toggle ACS (alternate character set) mapping"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|"  v/V     toggle video attribute to combine with each line"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_color_attr
parameter_list|(
name|int
name|fg
parameter_list|,
name|int
name|bg
parameter_list|,
name|int
name|tx
parameter_list|)
block|{
if|if
condition|(
name|use_colors
condition|)
block|{
name|printw
argument_list|(
literal|"  Colors (fg %d, bg %d"
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|>=
literal|0
condition|)
name|printw
argument_list|(
literal|", text %d"
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"),"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|cycle_color_attr
parameter_list|(
name|int
name|ch
parameter_list|,
name|short
modifier|*
name|fg
parameter_list|,
name|short
modifier|*
name|bg
parameter_list|,
name|short
modifier|*
name|tx
parameter_list|)
block|{
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
operator|*
name|fg
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|fg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
operator|*
name|fg
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|fg
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|bg
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|bg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|*
name|bg
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|bg
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|tx
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|tx
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
operator|*
name|tx
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|tx
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|fg
operator|>=
name|COLORS
condition|)
operator|*
name|fg
operator|=
operator|(
name|short
operator|)
name|min_colors
expr_stmt|;
if|if
condition|(
operator|*
name|fg
operator|<
name|min_colors
condition|)
operator|*
name|fg
operator|=
call|(
name|short
call|)
argument_list|(
name|COLORS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bg
operator|>=
name|COLORS
condition|)
operator|*
name|bg
operator|=
operator|(
name|short
operator|)
name|min_colors
expr_stmt|;
if|if
condition|(
operator|*
name|bg
operator|<
name|min_colors
condition|)
operator|*
name|bg
operator|=
call|(
name|short
call|)
argument_list|(
name|COLORS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tx
operator|>=
name|COLORS
condition|)
operator|*
name|tx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|tx
operator|<
operator|-
literal|1
condition|)
operator|*
name|tx
operator|=
call|(
name|short
call|)
argument_list|(
name|COLORS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_attr_string
parameter_list|(
name|int
name|adjust
parameter_list|)
block|{
name|int
name|first
init|=
operator|(
operator|(
name|int
operator|)
name|UChar
argument_list|(
name|attr_test_string
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
name|adjust
decl_stmt|;
name|int
name|last
init|=
name|first
operator|+
name|LEN_ATTRSTRING
decl_stmt|;
if|if
condition|(
name|first
operator|>=
literal|' '
operator|&&
name|last
operator|<=
literal|'~'
condition|)
block|{
comment|/* 32..126 */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|first
init|;
name|j
operator|<
name|MAX_ATTRSTRING
operator|&&
name|k
operator|<=
name|last
condition|;
operator|++
name|j
operator|,
operator|++
name|k
control|)
block|{
name|attr_test_string
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|+
literal|1
operator|-
name|first
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|j
operator|>=
name|MAX_ATTRSTRING
condition|)
break|break;
name|attr_test_string
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
while|while
condition|(
name|j
operator|<
name|MAX_ATTRSTRING
condition|)
name|attr_test_string
index|[
name|j
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|attr_test_string
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_attr_string
parameter_list|(
name|void
parameter_list|)
block|{
name|attr_test_string
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
name|adjust_attr_string
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_attr
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|skip
parameter_list|,
name|bool
name|arrow
parameter_list|,
name|chtype
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ncv
init|=
name|get_ncv
argument_list|()
decl_stmt|;
name|chtype
name|test
init|=
name|attr
operator|&
call|(
name|chtype
call|)
argument_list|(
operator|~
name|A_ALTCHARSET
argument_list|)
decl_stmt|;
if|if
condition|(
name|arrow
condition|)
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|5
argument_list|,
literal|"-->"
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"%s mode:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|24
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/*      * Just for testing, write text using the alternate character set one      * character at a time (to pass its rendition directly), and use the      * string operation for the other attributes.      */
if|if
condition|(
name|attr
operator|&
name|A_ALTCHARSET
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|chtype
name|ch
decl_stmt|;
for|for
control|(
name|s
operator|=
name|attr_test_string
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
name|ch
operator|=
name|UChar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ch
operator||
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|attr_test_string
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|!=
name|A_NORMAL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|termattrs
argument_list|()
operator|&
name|test
operator|)
condition|)
block|{
name|printw
argument_list|(
literal|" (N/A)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ncv
operator|>
literal|0
operator|&&
operator|(
name|getbkgd
argument_list|(
name|stdscr
argument_list|)
operator|&
name|A_COLOR
operator|)
condition|)
block|{
specifier|static
specifier|const
name|chtype
name|table
index|[]
init|=
block|{
name|A_STANDOUT
block|,
name|A_UNDERLINE
block|,
name|A_REVERSE
block|,
name|A_BLINK
block|,
name|A_DIM
block|,
name|A_BOLD
block|,
ifdef|#
directive|ifdef
name|A_INVIS
name|A_INVIS
block|,
endif|#
directive|endif
name|A_PROTECT
block|,
name|A_ALTCHARSET
block|}
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|table
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|n
index|]
operator|&
name|attr
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|n
operator|)
operator|&
name|ncv
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|printw
argument_list|(
literal|" (NCV)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|termattrs
argument_list|()
operator|&
name|test
operator|)
operator|!=
name|test
condition|)
name|printw
argument_list|(
literal|" (Part)"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|row
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|chtype
name|attr
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|attrs_to_test
index|[]
init|=
block|{
block|{
name|A_STANDOUT
block|,
literal|"STANDOUT"
block|}
block|,
block|{
name|A_REVERSE
block|,
literal|"REVERSE"
block|}
block|,
block|{
name|A_BOLD
block|,
literal|"BOLD"
block|}
block|,
block|{
name|A_UNDERLINE
block|,
literal|"UNDERLINE"
block|}
block|,
block|{
name|A_DIM
block|,
literal|"DIM"
block|}
block|,
block|{
name|A_BLINK
block|,
literal|"BLINK"
block|}
block|,
block|{
name|A_PROTECT
block|,
literal|"PROTECT"
block|}
block|,
ifdef|#
directive|ifdef
name|A_INVIS
block|{
name|A_INVIS
block|,
literal|"INVISIBLE"
block|}
block|,
endif|#
directive|endif
block|{
name|A_NORMAL
block|,
literal|"NORMAL"
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|bool
name|attr_getc
parameter_list|(
name|int
modifier|*
name|skip
parameter_list|,
name|short
modifier|*
name|fg
parameter_list|,
name|short
modifier|*
name|bg
parameter_list|,
name|short
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|,
name|unsigned
modifier|*
name|kc
parameter_list|)
block|{
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|WINDOW
modifier|*
name|helpwin
decl_stmt|;
do|do
block|{
name|int
name|ch
init|=
name|Getchar
argument_list|()
decl_stmt|;
name|error
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|256
operator|&&
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|skip
operator|=
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|Repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|helpwin
operator|=
name|newwin
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|box
argument_list|(
name|helpwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attr_legend
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
operator|*
name|ac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|*
name|ac
operator|=
name|A_ALTCHARSET
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
operator|*
name|kc
operator|==
literal|0
condition|)
operator|*
name|kc
operator|=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|kc
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|*
name|kc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|kc
operator|>=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
condition|)
operator|*
name|kc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|adjust_attr_string
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|adjust_attr_string
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|cycle_color_attr
argument_list|(
name|ch
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|error
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_test
parameter_list|(
name|void
parameter_list|)
comment|/* test text attributes */
block|{
name|int
name|n
decl_stmt|;
name|int
name|skip
init|=
name|get_xmc
argument_list|()
decl_stmt|;
name|short
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
comment|/* color pair 0 is special */
name|short
name|bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|short
name|tx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|unsigned
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|skip
expr_stmt|;
comment|/* make it easy */
name|k
operator|=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
operator|-
literal|1
expr_stmt|;
name|init_attr_string
argument_list|()
expr_stmt|;
do|do
block|{
name|int
name|row
init|=
literal|2
decl_stmt|;
name|chtype
name|normal
init|=
name|A_NORMAL
operator||
name|BLANK
decl_stmt|;
name|chtype
name|extras
init|=
operator|(
name|chtype
operator|)
name|ac
decl_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|short
name|pair
init|=
call|(
name|short
call|)
argument_list|(
name|fg
operator|!=
name|COLOR_BLACK
operator|||
name|bg
operator|!=
name|COLOR_BLACK
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|!=
literal|0
condition|)
block|{
name|pair
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init_pair
argument_list|(
name|pair
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|normal
operator||=
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tx
operator|>=
literal|0
condition|)
block|{
name|pair
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|init_pair
argument_list|(
name|pair
argument_list|,
name|tx
argument_list|,
name|bg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|extras
operator||=
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bkgd
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|box
argument_list|(
name|stdscr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Character attribute test display"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|bool
name|arrow
init|=
operator|(
name|j
operator|==
name|k
operator|)
decl_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|arrow
argument_list|,
name|extras
operator||
name|attrs_to_test
index|[
name|j
index|]
operator|.
name|attr
operator||
name|attrs_to_test
index|[
name|k
index|]
operator|.
name|attr
argument_list|,
name|attrs_to_test
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"This terminal does %shave the magic-cookie glitch"
argument_list|,
name|get_xmc
argument_list|()
operator|>
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
operator|+
literal|1
argument_list|,
literal|8
argument_list|,
literal|"Enter '?' for help."
argument_list|)
expr_stmt|;
name|show_color_attr
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"  ACS (%d)"
argument_list|,
name|ac
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|attr_getc
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|tx
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|k
argument_list|)
condition|)
do|;
name|bkgdset
argument_list|(
name|A_NORMAL
operator||
name|BLANK
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_decl_stmt
specifier|static
name|wchar_t
name|wide_attr_test_string
index|[
name|MAX_ATTRSTRING
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|wide_adjust_attr_string
parameter_list|(
name|int
name|adjust
parameter_list|)
block|{
name|int
name|first
init|=
operator|(
operator|(
name|int
operator|)
name|UChar
argument_list|(
name|wide_attr_test_string
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
name|adjust
decl_stmt|;
name|int
name|last
init|=
name|first
operator|+
name|LEN_ATTRSTRING
decl_stmt|;
if|if
condition|(
name|first
operator|>=
literal|' '
operator|&&
name|last
operator|<=
literal|'~'
condition|)
block|{
comment|/* 32..126 */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|first
init|;
name|j
operator|<
name|MAX_ATTRSTRING
operator|&&
name|k
operator|<=
name|last
condition|;
operator|++
name|j
operator|,
operator|++
name|k
control|)
block|{
name|wide_attr_test_string
index|[
name|j
index|]
operator|=
name|k
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|+
literal|1
operator|-
name|first
operator|)
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|j
operator|>=
name|MAX_ATTRSTRING
condition|)
break|break;
name|wide_attr_test_string
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
while|while
condition|(
name|j
operator|<
name|MAX_ATTRSTRING
condition|)
name|wide_attr_test_string
index|[
name|j
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|wide_attr_test_string
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wide_init_attr_string
parameter_list|(
name|void
parameter_list|)
block|{
name|wide_attr_test_string
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
name|wide_adjust_attr_string
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_wide_background
parameter_list|(
name|short
name|pair
parameter_list|)
block|{
name|cchar_t
name|normal
decl_stmt|;
name|wchar_t
name|blank
index|[
literal|2
index|]
decl_stmt|;
name|blank
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|blank
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|setcchar
argument_list|(
operator|&
name|normal
argument_list|,
name|blank
argument_list|,
name|A_NORMAL
argument_list|,
name|pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bkgrnd
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
name|bkgrndset
argument_list|(
operator|&
name|normal
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|attr_t
name|get_wide_background
parameter_list|(
name|void
parameter_list|)
block|{
name|attr_t
name|result
init|=
name|A_NORMAL
decl_stmt|;
name|attr_t
name|attr
decl_stmt|;
name|cchar_t
name|ch
decl_stmt|;
name|short
name|pair
decl_stmt|;
name|wchar_t
name|wch
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|getbkgrnd
argument_list|(
operator|&
name|ch
argument_list|)
operator|!=
name|ERR
condition|)
block|{
if|if
condition|(
name|getcchar
argument_list|(
operator|&
name|ch
argument_list|,
name|wch
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|pair
argument_list|,
literal|0
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|result
operator|=
name|attr
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wide_show_attr
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|skip
parameter_list|,
name|bool
name|arrow
parameter_list|,
name|chtype
name|attr
parameter_list|,
name|short
name|pair
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ncv
init|=
name|get_ncv
argument_list|()
decl_stmt|;
name|chtype
name|test
init|=
name|attr
operator|&
operator|~
name|WA_ALTCHARSET
decl_stmt|;
if|if
condition|(
name|arrow
condition|)
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|5
argument_list|,
literal|"-->"
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"%s mode:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|24
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/*      * Just for testing, write text using the alternate character set one      * character at a time (to pass its rendition directly), and use the      * string operation for the other attributes.      */
if|if
condition|(
name|attr
operator|&
name|WA_ALTCHARSET
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|s
decl_stmt|;
name|cchar_t
name|ch
decl_stmt|;
for|for
control|(
name|s
operator|=
name|wide_attr_test_string
init|;
operator|*
name|s
operator|!=
literal|L'
expr|\0'
condition|;
operator|++
name|s
control|)
block|{
name|wchar_t
name|fill
index|[
literal|2
index|]
decl_stmt|;
name|fill
index|[
literal|0
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|fill
index|[
literal|1
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|setcchar
argument_list|(
operator|&
name|ch
argument_list|,
name|fill
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_wch
argument_list|(
operator|&
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|attr_t
name|old_attr
decl_stmt|;
name|short
name|old_pair
decl_stmt|;
operator|(
name|void
operator|)
name|attr_get
argument_list|(
operator|&
name|old_attr
argument_list|,
operator|&
name|old_pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attr_set
argument_list|(
name|attr
argument_list|,
name|pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addwstr
argument_list|(
name|wide_attr_test_string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attr_set
argument_list|(
name|old_attr
argument_list|,
name|old_pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|!=
name|A_NORMAL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|term_attrs
argument_list|()
operator|&
name|test
operator|)
condition|)
block|{
name|printw
argument_list|(
literal|" (N/A)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ncv
operator|>
literal|0
operator|&&
operator|(
name|get_wide_background
argument_list|()
operator|&
name|A_COLOR
operator|)
condition|)
block|{
specifier|static
specifier|const
name|attr_t
name|table
index|[]
init|=
block|{
name|WA_STANDOUT
block|,
name|WA_UNDERLINE
block|,
name|WA_REVERSE
block|,
name|WA_BLINK
block|,
name|WA_DIM
block|,
name|WA_BOLD
block|,
name|WA_INVIS
block|,
name|WA_PROTECT
block|,
name|WA_ALTCHARSET
block|}
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|table
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|n
index|]
operator|&
name|attr
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|n
operator|)
operator|&
name|ncv
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|printw
argument_list|(
literal|" (NCV)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|term_attrs
argument_list|()
operator|&
name|test
operator|)
operator|!=
name|test
condition|)
name|printw
argument_list|(
literal|" (Part)"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|row
operator|+
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|wide_attr_getc
parameter_list|(
name|int
modifier|*
name|skip
parameter_list|,
name|short
modifier|*
name|fg
parameter_list|,
name|short
modifier|*
name|bg
parameter_list|,
name|short
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|,
name|unsigned
modifier|*
name|kc
parameter_list|)
block|{
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
name|bool
name|error
init|=
name|FALSE
decl_stmt|;
name|WINDOW
modifier|*
name|helpwin
decl_stmt|;
do|do
block|{
name|int
name|ch
init|=
name|Getchar
argument_list|()
decl_stmt|;
name|error
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|256
operator|&&
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|skip
operator|=
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|Repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|helpwin
operator|=
name|newwin
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|box_set
argument_list|(
name|helpwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attr_legend
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
operator|*
name|ac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|*
name|ac
operator|=
name|A_ALTCHARSET
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
operator|*
name|kc
operator|==
literal|0
condition|)
operator|*
name|kc
operator|=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|kc
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|*
name|kc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|kc
operator|>=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
condition|)
operator|*
name|kc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|wide_adjust_attr_string
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|wide_adjust_attr_string
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|cycle_color_attr
argument_list|(
name|ch
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|error
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wide_attr_test
parameter_list|(
name|void
parameter_list|)
comment|/* test text attributes using wide-character calls */
block|{
name|int
name|n
decl_stmt|;
name|int
name|skip
init|=
name|get_xmc
argument_list|()
decl_stmt|;
name|short
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
comment|/* color pair 0 is special */
name|short
name|bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|short
name|tx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|unsigned
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|skip
expr_stmt|;
comment|/* make it easy */
name|k
operator|=
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
operator|-
literal|1
expr_stmt|;
name|wide_init_attr_string
argument_list|()
expr_stmt|;
do|do
block|{
name|int
name|row
init|=
literal|2
decl_stmt|;
name|short
name|pair
init|=
literal|0
decl_stmt|;
name|short
name|extras
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|pair
operator|=
call|(
name|short
call|)
argument_list|(
name|fg
operator|!=
name|COLOR_BLACK
operator|||
name|bg
operator|!=
name|COLOR_BLACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|!=
literal|0
condition|)
block|{
name|pair
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init_pair
argument_list|(
name|pair
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
name|extras
operator|=
name|pair
expr_stmt|;
if|if
condition|(
name|tx
operator|>=
literal|0
condition|)
block|{
name|extras
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|init_pair
argument_list|(
name|extras
argument_list|,
name|tx
argument_list|,
name|bg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|set_wide_background
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|box_set
argument_list|(
name|stdscr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Character attribute test display"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SIZEOF
argument_list|(
name|attrs_to_test
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|row
operator|=
name|wide_show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|j
operator|==
name|k
argument_list|,
operator|(
operator|(
name|attr_t
operator|)
name|ac
operator||
name|attrs_to_test
index|[
name|j
index|]
operator|.
name|attr
operator||
name|attrs_to_test
index|[
name|k
index|]
operator|.
name|attr
operator|)
argument_list|,
name|extras
argument_list|,
name|attrs_to_test
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"This terminal does %shave the magic-cookie glitch"
argument_list|,
name|get_xmc
argument_list|()
operator|>
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
operator|+
literal|1
argument_list|,
literal|8
argument_list|,
literal|"Enter '?' for help."
argument_list|)
expr_stmt|;
name|show_color_attr
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"  ACS (%d)"
argument_list|,
name|ac
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|wide_attr_getc
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|tx
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|k
argument_list|)
condition|)
do|;
name|set_wide_background
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************  *  * Color support tests  *  ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
name|the_color_names
index|[]
init|=
block|{
literal|"black"
block|,
literal|"red"
block|,
literal|"green"
block|,
literal|"yellow"
block|,
literal|"blue"
block|,
literal|"magenta"
block|,
literal|"cyan"
block|,
literal|"white"
block|,
literal|"BLACK"
block|,
literal|"RED"
block|,
literal|"GREEN"
block|,
literal|"YELLOW"
block|,
literal|"BLUE"
block|,
literal|"MAGENTA"
block|,
literal|"CYAN"
block|,
literal|"WHITE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|show_color_name
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|color
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
if|if
condition|(
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|width
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|wide
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%02d"
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|width
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|>=
literal|8
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"[%02d]"
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|the_color_names
index|[
name|color
index|]
argument_list|)
expr_stmt|;
block|}
name|printw
argument_list|(
literal|"%-*.*s"
argument_list|,
name|width
argument_list|,
name|width
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|color_legend
parameter_list|(
name|WINDOW
modifier|*
name|helpwin
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|int
name|row
init|=
literal|1
decl_stmt|;
name|int
name|col
init|=
literal|1
decl_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"ESC to exit."
argument_list|)
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"Use up/down arrow to scroll through the display if it is"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"longer than one screen. Control/N and Control/P can be used"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"in place of up/down arrow.  Use pageup/pagedown to scroll a"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"full screen; control/B and control/F can be used here."
argument_list|)
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"Toggles:"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  a/A     toggle altcharset off/on"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  b/B     toggle bold off/on"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  n/N     toggle text/number on/off"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  r/R     toggle reverse on/off"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"  w/W     toggle width between 8/16 colors"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
if|if
condition|(
name|wide
condition|)
block|{
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
operator|++
argument_list|,
name|col
argument_list|,
literal|"Wide characters:"
argument_list|)
expr_stmt|;
name|MvWPrintw
argument_list|(
name|helpwin
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|"  x/X     toggle text between ASCII and wide-character"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|wide
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|set_color_test
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
value|if (name != value) { name = value; base_row = 0; }
end_define

begin_comment
comment|/* generate a color test pattern */
end_comment

begin_function
specifier|static
name|void
name|color_test
parameter_list|(
name|void
parameter_list|)
block|{
name|short
name|i
decl_stmt|;
name|int
name|top
init|=
literal|0
decl_stmt|,
name|width
decl_stmt|;
name|int
name|base_row
init|=
literal|0
decl_stmt|;
name|int
name|grid_top
init|=
name|top
operator|+
literal|3
decl_stmt|;
name|int
name|page_size
init|=
operator|(
name|LINES
operator|-
name|grid_top
operator|)
decl_stmt|;
name|int
name|pairs_max
init|=
name|PAIR_NUMBER
argument_list|(
name|A_COLOR
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|row_limit
decl_stmt|;
name|int
name|per_row
decl_stmt|;
name|char
name|numbered
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|hello
decl_stmt|;
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_acsc
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_bold
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_revs
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_nums
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_wide
init|=
name|FALSE
decl_stmt|;
name|WINDOW
modifier|*
name|helpwin
decl_stmt|;
if|if
condition|(
name|COLORS
operator|*
name|COLORS
operator|==
name|COLOR_PAIRS
condition|)
block|{
name|int
name|limit
init|=
operator|(
name|COLORS
operator|-
name|min_colors
operator|)
operator|*
operator|(
name|COLORS
operator|-
name|min_colors
operator|)
decl_stmt|;
if|if
condition|(
name|pairs_max
operator|>
name|limit
condition|)
name|pairs_max
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pairs_max
operator|>
name|COLOR_PAIRS
condition|)
name|pairs_max
operator|=
name|COLOR_PAIRS
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|shown
init|=
literal|0
decl_stmt|;
comment|/* this assumes an 80-column line */
if|if
condition|(
name|opt_wide
condition|)
block|{
name|width
operator|=
literal|4
expr_stmt|;
name|hello
operator|=
literal|"Test"
expr_stmt|;
name|per_row
operator|=
operator|(
name|COLORS
operator|>
literal|8
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|8
expr_stmt|;
name|hello
operator|=
literal|"Hello"
expr_stmt|;
name|per_row
operator|=
literal|8
expr_stmt|;
block|}
name|per_row
operator|-=
name|min_colors
expr_stmt|;
name|row_limit
operator|=
operator|(
name|pairs_max
operator|+
name|per_row
operator|-
literal|1
operator|)
operator|/
name|per_row
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"There are %d color pairs and %d colors%s\n"
argument_list|,
name|pairs_max
argument_list|,
name|COLORS
argument_list|,
name|min_colors
condition|?
literal|" besides 'default'"
else|:
literal|""
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|MvPrintw
argument_list|(
name|top
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bold *%s*\n"
argument_list|,
name|row_limit
argument_list|,
name|per_row
argument_list|,
name|opt_bold
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
comment|/* show color names/numbers across the top */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|per_row
condition|;
name|i
operator|++
control|)
name|show_color_name
argument_list|(
name|top
operator|+
literal|2
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|width
argument_list|,
name|i
operator|+
name|min_colors
argument_list|,
name|opt_wide
argument_list|)
expr_stmt|;
comment|/* show a grid of colors, with color names/ numbers on the left */
for|for
control|(
name|i
operator|=
call|(
name|short
call|)
argument_list|(
name|base_row
operator|*
name|per_row
argument_list|)
init|;
name|i
operator|<
name|pairs_max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|row
init|=
name|grid_top
operator|+
operator|(
name|i
operator|/
name|per_row
operator|)
operator|-
name|base_row
decl_stmt|;
name|int
name|col
init|=
operator|(
name|i
operator|%
name|per_row
operator|+
literal|1
operator|)
operator|*
name|width
decl_stmt|;
name|short
name|pair
init|=
name|i
decl_stmt|;
define|#
directive|define
name|InxToFG
parameter_list|(
name|i
parameter_list|)
value|(short) ((i % (COLORS - min_colors)) + min_colors)
define|#
directive|define
name|InxToBG
parameter_list|(
name|i
parameter_list|)
value|(short) ((i / (COLORS - min_colors)) + min_colors)
if|if
condition|(
name|row
operator|>=
literal|0
operator|&&
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|short
name|fg
init|=
name|InxToFG
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|short
name|bg
init|=
name|InxToBG
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|init_pair
argument_list|(
name|pair
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_acsc
condition|)
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|A_ALTCHARSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_bold
condition|)
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|A_BOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_revs
condition|)
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|A_REVERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_nums
condition|)
block|{
name|sprintf
argument_list|(
name|numbered
argument_list|,
literal|"{%02X}"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|hello
operator|=
name|numbered
expr_stmt|;
block|}
name|printw
argument_list|(
literal|"%-*.*s"
argument_list|,
name|width
argument_list|,
name|width
argument_list|,
name|hello
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|per_row
operator|)
operator|==
literal|0
operator|&&
name|InxToFG
argument_list|(
name|i
argument_list|)
operator|==
name|min_colors
condition|)
block|{
name|show_color_name
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|InxToBG
argument_list|(
name|i
argument_list|)
argument_list|,
name|opt_wide
argument_list|)
expr_stmt|;
block|}
operator|++
name|shown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shown
condition|)
block|{
break|break;
block|}
block|}
switch|switch
condition|(
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|opt_acsc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt_acsc
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|opt_bold
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|opt_bold
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opt_nums
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_nums
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|opt_revs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|opt_revs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|set_color_test
argument_list|(
name|opt_wide
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|set_color_test
argument_list|(
name|opt_wide
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|KEY_UP
case|:
if|if
condition|(
name|base_row
operator|<=
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
name|KEY_PREVIOUS
case|:
case|case
name|KEY_PPAGE
case|:
if|if
condition|(
name|base_row
operator|<=
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|-=
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|base_row
operator|<
literal|0
condition|)
name|base_row
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
name|KEY_NEXT
case|:
case|case
name|KEY_NPAGE
case|:
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|+=
name|page_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|base_row
operator|=
name|row_limit
operator|-
name|page_size
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|helpwin
operator|=
name|newwin
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|box
argument_list|(
name|helpwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|color_legend
argument_list|(
name|helpwin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_comment
comment|/* generate a color test pattern */
end_comment

begin_function
specifier|static
name|void
name|wide_color_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|top
init|=
literal|0
decl_stmt|,
name|width
decl_stmt|;
name|int
name|base_row
init|=
literal|0
decl_stmt|;
name|int
name|grid_top
init|=
name|top
operator|+
literal|3
decl_stmt|;
name|int
name|page_size
init|=
operator|(
name|LINES
operator|-
name|grid_top
operator|)
decl_stmt|;
name|int
name|pairs_max
init|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|row_limit
decl_stmt|;
name|int
name|per_row
decl_stmt|;
name|char
name|numbered
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|hello
decl_stmt|;
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_acsc
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_bold
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_revs
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_wide
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_nums
init|=
name|FALSE
decl_stmt|;
name|bool
name|opt_xchr
init|=
name|FALSE
decl_stmt|;
name|wchar_t
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|helpwin
decl_stmt|;
if|if
condition|(
name|COLORS
operator|*
name|COLORS
operator|==
name|COLOR_PAIRS
condition|)
block|{
name|int
name|limit
init|=
operator|(
name|COLORS
operator|-
name|min_colors
operator|)
operator|*
operator|(
name|COLORS
operator|-
name|min_colors
operator|)
decl_stmt|;
if|if
condition|(
name|pairs_max
operator|>
name|limit
condition|)
name|pairs_max
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pairs_max
operator|>
name|COLOR_PAIRS
condition|)
name|pairs_max
operator|=
name|COLOR_PAIRS
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|shown
init|=
literal|0
decl_stmt|;
comment|/* this assumes an 80-column line */
if|if
condition|(
name|opt_wide
condition|)
block|{
name|width
operator|=
literal|4
expr_stmt|;
name|hello
operator|=
literal|"Test"
expr_stmt|;
name|per_row
operator|=
operator|(
name|COLORS
operator|>
literal|8
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|8
expr_stmt|;
name|hello
operator|=
literal|"Hello"
expr_stmt|;
name|per_row
operator|=
literal|8
expr_stmt|;
block|}
name|per_row
operator|-=
name|min_colors
expr_stmt|;
if|if
condition|(
name|opt_xchr
condition|)
block|{
name|make_fullwidth_text
argument_list|(
name|buffer
argument_list|,
name|hello
argument_list|)
expr_stmt|;
name|width
operator|*=
literal|2
expr_stmt|;
name|per_row
operator|/=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|make_narrow_text
argument_list|(
name|buffer
argument_list|,
name|hello
argument_list|)
expr_stmt|;
block|}
name|row_limit
operator|=
operator|(
name|pairs_max
operator|+
name|per_row
operator|-
literal|1
operator|)
operator|/
name|per_row
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"There are %d color pairs and %d colors%s\n"
argument_list|,
name|pairs_max
argument_list|,
name|COLORS
argument_list|,
name|min_colors
condition|?
literal|" besides 'default'"
else|:
literal|""
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|MvPrintw
argument_list|(
name|top
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bold *%s*\n"
argument_list|,
name|row_limit
argument_list|,
name|per_row
argument_list|,
name|opt_bold
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
comment|/* show color names/numbers across the top */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|per_row
condition|;
name|i
operator|++
control|)
name|show_color_name
argument_list|(
name|top
operator|+
literal|2
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|width
argument_list|,
name|i
operator|+
name|min_colors
argument_list|,
name|opt_wide
argument_list|)
expr_stmt|;
comment|/* show a grid of colors, with color names/ numbers on the left */
for|for
control|(
name|i
operator|=
operator|(
name|base_row
operator|*
name|per_row
operator|)
init|;
name|i
operator|<
name|pairs_max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|row
init|=
name|grid_top
operator|+
operator|(
name|i
operator|/
name|per_row
operator|)
operator|-
name|base_row
decl_stmt|;
name|int
name|col
init|=
operator|(
name|i
operator|%
name|per_row
operator|+
literal|1
operator|)
operator|*
name|width
decl_stmt|;
name|short
name|pair
init|=
operator|(
name|short
operator|)
name|i
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
operator|&&
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|init_pair
argument_list|(
name|pair
argument_list|,
name|InxToFG
argument_list|(
name|i
argument_list|)
argument_list|,
name|InxToBG
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|color_set
argument_list|(
name|pair
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_acsc
condition|)
name|attr_on
argument_list|(
operator|(
name|attr_t
operator|)
name|A_ALTCHARSET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_bold
condition|)
name|attr_on
argument_list|(
operator|(
name|attr_t
operator|)
name|A_BOLD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_revs
condition|)
name|attr_on
argument_list|(
operator|(
name|attr_t
operator|)
name|A_REVERSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_nums
condition|)
block|{
name|sprintf
argument_list|(
name|numbered
argument_list|,
literal|"{%02X}"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_xchr
condition|)
block|{
name|make_fullwidth_text
argument_list|(
name|buffer
argument_list|,
name|numbered
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|make_narrow_text
argument_list|(
name|buffer
argument_list|,
name|numbered
argument_list|)
expr_stmt|;
block|}
block|}
name|addnwstr
argument_list|(
name|buffer
argument_list|,
name|width
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attr_set
argument_list|(
name|A_NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|per_row
operator|)
operator|==
literal|0
operator|&&
name|InxToFG
argument_list|(
name|i
argument_list|)
operator|==
name|min_colors
condition|)
block|{
name|show_color_name
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|InxToBG
argument_list|(
name|i
argument_list|)
argument_list|,
name|opt_wide
argument_list|)
expr_stmt|;
block|}
operator|++
name|shown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shown
condition|)
block|{
break|break;
block|}
block|}
switch|switch
condition|(
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|opt_acsc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt_acsc
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|opt_bold
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|opt_bold
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opt_nums
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_nums
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|opt_revs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|opt_revs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|set_color_test
argument_list|(
name|opt_wide
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|set_color_test
argument_list|(
name|opt_wide
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_xchr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|opt_xchr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|KEY_UP
case|:
if|if
condition|(
name|base_row
operator|<=
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
name|KEY_PREVIOUS
case|:
case|case
name|KEY_PPAGE
case|:
if|if
condition|(
name|base_row
operator|<=
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|-=
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|base_row
operator|<
literal|0
condition|)
name|base_row
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
name|KEY_NEXT
case|:
case|case
name|KEY_NPAGE
case|:
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base_row
operator|+=
name|page_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|base_row
operator|+
name|page_size
operator|>=
name|row_limit
condition|)
block|{
name|base_row
operator|=
name|row_limit
operator|-
name|page_size
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|helpwin
operator|=
name|newwin
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|box
argument_list|(
name|helpwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|color_legend
argument_list|(
name|helpwin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|helpwin
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WIDEC_SUPPORT */
end_comment

begin_function
specifier|static
name|void
name|change_color
parameter_list|(
name|short
name|current
parameter_list|,
name|int
name|field
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|usebase
parameter_list|)
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|color_content
argument_list|(
name|current
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
literal|0
case|:
name|red
operator|=
call|(
name|short
call|)
argument_list|(
name|usebase
condition|?
operator|(
name|red
operator|+
name|value
operator|)
else|:
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|green
operator|=
call|(
name|short
call|)
argument_list|(
name|usebase
condition|?
operator|(
name|green
operator|+
name|value
operator|)
else|:
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|blue
operator|=
call|(
name|short
call|)
argument_list|(
name|usebase
condition|?
operator|(
name|blue
operator|+
name|value
operator|)
else|:
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|init_color
argument_list|(
name|current
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
operator|==
name|ERR
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_all_colors
parameter_list|(
name|void
parameter_list|)
block|{
name|short
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|COLORS
condition|;
operator|++
name|c
control|)
name|init_color
argument_list|(
name|c
argument_list|,
name|all_colors
index|[
name|c
index|]
operator|.
name|red
argument_list|,
name|all_colors
index|[
name|c
index|]
operator|.
name|green
argument_list|,
name|all_colors
index|[
name|c
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|scaled_rgb
parameter_list|(
name|n
parameter_list|)
value|((255 * (n)) / 1000)
end_define

begin_function
specifier|static
name|void
name|color_edit
parameter_list|(
name|void
parameter_list|)
comment|/* display the color test pattern, without trying to edit colors */
block|{
name|int
name|i
decl_stmt|;
name|int
name|current
init|=
literal|0
decl_stmt|;
name|int
name|this_c
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|int
name|last_c
decl_stmt|;
name|int
name|top_color
init|=
literal|0
decl_stmt|;
name|int
name|page_size
init|=
operator|(
name|LINES
operator|-
literal|6
operator|)
decl_stmt|;
name|init_all_colors
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_colors
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
operator|(
name|short
operator|)
name|i
argument_list|,
operator|(
name|short
operator|)
name|COLOR_WHITE
argument_list|,
operator|(
name|short
operator|)
name|i
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Number: %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
do|do
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Color RGB Value Editing"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|short
operator|)
name|top_color
init|;
operator|(
name|i
operator|-
name|top_color
operator|<
name|page_size
operator|)
operator|&&
operator|(
name|i
operator|<
name|max_colors
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|numeric
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|numeric
argument_list|,
literal|"[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|2
operator|+
name|i
operator|-
name|top_color
argument_list|,
literal|0
argument_list|,
literal|"%c %-8s:"
argument_list|,
operator|(
name|i
operator|==
name|current
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
name|the_color_names
argument_list|)
condition|?
name|the_color_names
index|[
name|i
index|]
else|:
name|numeric
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attrset
argument_list|(
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|color_content
argument_list|(
operator|(
name|short
operator|)
name|i
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"   R = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", G = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", B = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" ( %3d %3d %3d )"
argument_list|,
name|scaled_rgb
argument_list|(
name|red
argument_list|)
argument_list|,
name|scaled_rgb
argument_list|(
name|green
argument_list|)
argument_list|,
name|scaled_rgb
argument_list|(
name|blue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MvAddStr
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Use up/down to select a color, left/right to change fields."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Modify field by typing nnn=, nnn-, or nnn+.  ? for help."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
operator|+
name|current
operator|-
name|top_color
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_c
operator|=
name|this_c
expr_stmt|;
name|this_c
operator|=
name|Getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|this_c
operator|<
literal|256
operator|&&
name|isdigit
argument_list|(
name|this_c
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|last_c
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|this_c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'b'
argument_list|)
case|:
case|case
name|KEY_PPAGE
case|:
if|if
condition|(
name|current
operator|>
literal|0
condition|)
name|current
operator|-=
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
name|KEY_NPAGE
case|:
if|if
condition|(
name|current
operator|<
operator|(
name|max_colors
operator|-
literal|1
operator|)
condition|)
name|current
operator|+=
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|KEY_UP
case|:
name|current
operator|=
operator|(
name|current
operator|==
literal|0
condition|?
operator|(
name|max_colors
operator|-
literal|1
operator|)
else|:
name|current
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|KEY_DOWN
case|:
name|current
operator|=
operator|(
name|current
operator|==
operator|(
name|max_colors
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|current
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|2
condition|?
literal|0
else|:
name|field
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|0
condition|?
literal|2
else|:
name|field
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|(
name|this_c
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|change_color
argument_list|(
operator|(
name|short
operator|)
name|current
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|change_color
argument_list|(
operator|(
name|short
operator|)
name|current
argument_list|,
name|field
argument_list|,
operator|-
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|change_color
argument_list|(
operator|(
name|short
operator|)
name|current
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|erase
argument_list|()
expr_stmt|;
name|P
argument_list|(
literal|"                      RGB Value Editing Help"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"You are in the RGB value editor.  Use the arrow keys to select one of"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"the fields in one of the RGB triples of the current colors; the one"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"currently selected will be reverse-video highlighted."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To change a field, enter the digits of the new value; they are echoed"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"as entered.  Finish by typing `='.  The change will take effect instantly."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To increment or decrement a value, use the same procedure, but finish"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"with a `+' or `-'."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Press 'm' to invoke the top-level menu with the current color settings."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To quit, do ESC"
argument_list|)
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|endwin
argument_list|()
expr_stmt|;
name|main_menu
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_colors
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
operator|(
name|short
operator|)
name|i
argument_list|,
operator|(
name|short
operator|)
name|COLOR_WHITE
argument_list|,
operator|(
name|short
operator|)
name|i
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current
operator|<
literal|0
condition|)
name|current
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|>=
name|max_colors
condition|)
name|current
operator|=
name|max_colors
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|current
operator|<
name|top_color
condition|)
name|top_color
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|top_color
operator|>=
name|page_size
condition|)
name|top_color
operator|=
name|current
operator|-
operator|(
name|page_size
operator|-
literal|1
operator|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Number: %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|this_c
argument_list|)
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
comment|/*      * ncurses does not reset each color individually when calling endwin().      */
name|init_all_colors
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Alternate character-set stuff  *  ****************************************************************************/
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|chtype
name|attr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|attrs_to_cycle
index|[]
init|=
block|{
block|{
name|A_NORMAL
block|,
literal|"normal"
block|}
block|,
block|{
name|A_BOLD
block|,
literal|"bold"
block|}
block|,
block|{
name|A_BLINK
block|,
literal|"blink"
block|}
block|,
block|{
name|A_REVERSE
block|,
literal|"reverse"
block|}
block|,
block|{
name|A_UNDERLINE
block|,
literal|"underline"
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|bool
name|cycle_attr
parameter_list|(
name|int
name|ch
parameter_list|,
name|unsigned
modifier|*
name|at_code
parameter_list|,
name|chtype
modifier|*
name|attr
parameter_list|)
block|{
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'v'
case|:
if|if
condition|(
operator|(
operator|*
name|at_code
operator|+=
literal|1
operator|)
operator|>=
name|SIZEOF
argument_list|(
name|attrs_to_cycle
argument_list|)
condition|)
operator|*
name|at_code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
operator|*
name|at_code
operator|==
literal|0
condition|)
operator|*
name|at_code
operator|=
name|SIZEOF
argument_list|(
name|attrs_to_cycle
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|at_code
operator|-=
literal|1
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
condition|)
operator|*
name|attr
operator|=
name|attrs_to_cycle
index|[
operator|*
name|at_code
index|]
operator|.
name|attr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|cycle_colors
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
modifier|*
name|fg
parameter_list|,
name|int
modifier|*
name|bg
parameter_list|,
name|short
modifier|*
name|pair
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'F'
case|:
if|if
condition|(
operator|(
operator|*
name|fg
operator|-=
literal|1
operator|)
operator|<
literal|0
condition|)
operator|*
name|fg
operator|=
name|COLORS
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
operator|*
name|fg
operator|+=
literal|1
operator|)
operator|>=
name|COLORS
condition|)
operator|*
name|fg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|(
operator|*
name|bg
operator|-=
literal|1
operator|)
operator|<
literal|0
condition|)
operator|*
name|bg
operator|=
name|COLORS
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
operator|*
name|bg
operator|+=
literal|1
operator|)
operator|>=
name|COLORS
condition|)
operator|*
name|bg
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
condition|)
block|{
operator|*
name|pair
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|fg
operator|!=
name|COLOR_BLACK
operator|||
operator|*
name|bg
operator|!=
name|COLOR_BLACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pair
operator|!=
literal|0
condition|)
block|{
operator|*
name|pair
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init_pair
argument_list|(
operator|*
name|pair
argument_list|,
operator|(
name|short
operator|)
operator|*
name|fg
argument_list|,
operator|(
name|short
operator|)
operator|*
name|bg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Soft-key label test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_SOFTKEYS
end_if

begin_define
define|#
directive|define
name|SLK_HELP
value|17
end_define

begin_define
define|#
directive|define
name|SLK_WORK
value|(SLK_HELP + 3)
end_define

begin_function
specifier|static
name|void
name|slk_help
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|table
index|[]
init|=
block|{
literal|"Available commands are:"
block|,
literal|""
block|,
literal|"^L         -- repaint this message and activate soft keys"
block|,
literal|"a/d        -- activate/disable soft keys"
block|,
literal|"c          -- set centered format for labels"
block|,
literal|"l          -- set left-justified format for labels"
block|,
literal|"r          -- set right-justified format for labels"
block|,
literal|"[12345678] -- set label; labels are numbered 1 through 8"
block|,
literal|"e          -- erase stdscr (should not erase labels)"
block|,
literal|"s          -- test scrolling of shortened screen"
block|,
literal|"v/V        -- cycle through video attributes"
if|#
directive|if
name|HAVE_SLK_COLOR
block|,
literal|"F/f/B/b    -- cycle through foreground/background colors"
endif|#
directive|endif
block|,
literal|"ESC        -- return to main menu"
block|,
literal|""
block|,
literal|"Note: if activating the soft keys causes your terminal to scroll up"
block|,
literal|"one line, your terminal auto-scrolls when anything is written to the"
block|,
literal|"last screen position.  The ncurses code does not yet handle this"
block|,
literal|"gracefully."
block|}
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SIZEOF
argument_list|(
name|table
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|P
argument_list|(
name|table
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_SLK_COLOR
end_if

begin_function
specifier|static
name|void
name|call_slk_color
parameter_list|(
name|int
name|fg
parameter_list|,
name|int
name|bg
parameter_list|)
block|{
name|init_pair
argument_list|(
literal|1
argument_list|,
operator|(
name|short
operator|)
name|bg
argument_list|,
operator|(
name|short
operator|)
name|fg
argument_list|)
expr_stmt|;
name|slk_color
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|,
literal|"Colors %d/%d\n"
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|slk_touch
argument_list|()
expr_stmt|;
name|slk_noutrefresh
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|slk_test
parameter_list|(
name|void
parameter_list|)
comment|/* exercise the soft keys */
block|{
name|int
name|c
decl_stmt|,
name|fmt
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|unsigned
name|at_code
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|HAVE_SLK_COLOR
name|int
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
name|int
name|bg
init|=
name|COLOR_WHITE
decl_stmt|;
name|short
name|pair
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|c
operator|=
name|CTRL
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SLK_COLOR
if|if
condition|(
name|use_colors
condition|)
block|{
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Soft Key Exerciser"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|slk_help
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
literal|'a'
case|:
name|slk_restore
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wclear
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|MvPrintw
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|,
literal|"Press Q to stop the scrolling-test: "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
literal|'Q'
operator|&&
operator|(
name|c
operator|!=
name|ERR
operator|)
condition|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|slk_clear
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fmt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
name|MvAddStr
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|,
literal|"Please enter the label value: "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|slk_label
argument_list|(
name|c
operator|-
literal|'0'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|wGetstring
argument_list|(
name|stdscr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|slk_set
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|,
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|slk_refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
goto|goto
name|done
goto|;
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
case|case
name|KEY_RESIZE
case|:
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|cycle_attr
argument_list|(
name|c
argument_list|,
operator|&
name|at_code
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
block|{
name|slk_attrset
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|slk_touch
argument_list|()
expr_stmt|;
name|slk_noutrefresh
argument_list|()
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_SLK_COLOR
if|if
condition|(
name|cycle_colors
argument_list|(
name|c
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|pair
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_colors
condition|)
block|{
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|c
operator|=
name|Getchar
argument_list|()
argument_list|)
condition|)
do|;
name|done
label|:
name|slk_clear
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_define
define|#
directive|define
name|SLKLEN
value|8
end_define

begin_function
specifier|static
name|void
name|wide_slk_test
parameter_list|(
name|void
parameter_list|)
comment|/* exercise the soft keys */
block|{
name|int
name|c
decl_stmt|,
name|fmt
init|=
literal|1
decl_stmt|;
name|wchar_t
name|buf
index|[
name|SLKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|unsigned
name|at_code
init|=
literal|0
decl_stmt|;
name|int
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
name|int
name|bg
init|=
name|COLOR_WHITE
decl_stmt|;
name|short
name|pair
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|CTRL
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|erase
argument_list|()
expr_stmt|;
name|attr_on
argument_list|(
name|WA_BOLD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Soft Key Exerciser"
argument_list|)
expr_stmt|;
name|attr_off
argument_list|(
name|WA_BOLD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slk_help
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
literal|'a'
case|:
name|slk_restore
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wclear
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|MvPrintw
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|,
literal|"Press Q to stop the scrolling-test: "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
literal|'Q'
operator|&&
operator|(
name|c
operator|!=
name|ERR
operator|)
condition|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|slk_clear
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fmt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
name|MvAddStr
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|,
literal|"Please enter the label value: "
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|slk_label
argument_list|(
name|c
operator|-
literal|'0'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|size_t
name|used
init|=
name|strlen
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|size_t
name|want
init|=
name|SLKLEN
decl_stmt|;
name|size_t
name|test
decl_stmt|;
ifndef|#
directive|ifndef
name|state_unused
name|mbstate_t
name|state
decl_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
while|while
condition|(
name|want
operator|>
literal|0
operator|&&
name|used
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|base
init|=
name|s
decl_stmt|;
name|reset_mbytes
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|test
operator|=
name|count_mbytes
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|temp
index|[
operator|--
name|used
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test
operator|>
name|want
condition|)
block|{
name|temp
index|[
operator|--
name|used
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reset_mbytes
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|trans_mbytes
argument_list|(
name|buf
argument_list|,
name|base
argument_list|,
name|want
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|wGet_wstring
argument_list|(
name|stdscr
argument_list|,
name|buf
argument_list|,
name|SLKLEN
argument_list|)
expr_stmt|;
name|slk_wset
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|,
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|slk_refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|SLK_WORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
goto|goto
name|done
goto|;
case|case
literal|'F'
case|:
if|if
condition|(
name|use_colors
condition|)
block|{
name|fg
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|fg
operator|+
literal|1
operator|)
operator|%
name|COLORS
argument_list|)
expr_stmt|;
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|use_colors
condition|)
block|{
name|bg
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|bg
operator|+
literal|1
operator|)
operator|%
name|COLORS
argument_list|)
expr_stmt|;
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
case|case
name|KEY_RESIZE
case|:
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|cycle_attr
argument_list|(
name|c
argument_list|,
operator|&
name|at_code
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
block|{
name|slk_attr_set
argument_list|(
name|attr
argument_list|,
operator|(
name|fg
operator|||
name|bg
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slk_touch
argument_list|()
expr_stmt|;
name|slk_noutrefresh
argument_list|()
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HAVE_SLK_COLOR
if|if
condition|(
name|cycle_colors
argument_list|(
name|c
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|pair
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_colors
condition|)
block|{
name|call_slk_color
argument_list|(
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|c
operator|=
name|Getchar
argument_list|()
argument_list|)
condition|)
do|;
name|done
label|:
name|slk_clear
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SLK_INIT */
end_comment

begin_comment
comment|/* ISO 6429:  codes 0x80 to 0x9f may be control characters that cause the  * terminal to perform functions.  The remaining codes can be graphic.  */
end_comment

begin_function
specifier|static
name|void
name|show_upper_chars
parameter_list|(
name|unsigned
name|first
parameter_list|,
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|bool
name|C1
init|=
operator|(
name|first
operator|==
literal|128
operator|)
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
name|unsigned
name|last
init|=
name|first
operator|+
literal|31
decl_stmt|;
name|int
name|reply
decl_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of %s Character Codes %d to %d"
argument_list|,
name|C1
condition|?
literal|"C1"
else|:
literal|"GR"
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|code
operator|=
name|first
init|;
name|code
operator|<=
name|last
condition|;
name|code
operator|++
control|)
block|{
name|int
name|count
init|=
name|repeat
decl_stmt|;
name|int
name|row
init|=
literal|2
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|first
argument_list|)
operator|%
literal|16
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|first
argument_list|)
operator|/
literal|16
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%3u (0x%x)"
argument_list|,
name|code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s: "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|C1
condition|)
name|nodelay
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|echochar
argument_list|(
name|colored_chtype
argument_list|(
name|code
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C1
condition|)
block|{
comment|/* (yes, this _is_ crude) */
while|while
condition|(
operator|(
name|reply
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
name|ERR
condition|)
block|{
name|addch
argument_list|(
name|UChar
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|nodelay
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PC_COLS
value|4
end_define

begin_function
specifier|static
name|void
name|show_pc_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|unsigned
name|code
decl_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of PC Character Codes"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|16
condition|;
operator|++
name|code
control|)
block|{
name|MvPrintw
argument_list|(
literal|2
argument_list|,
operator|(
name|int
operator|)
name|code
operator|*
name|PC_COLS
operator|+
literal|8
argument_list|,
literal|"%X"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|256
condition|;
name|code
operator|++
control|)
block|{
name|int
name|count
init|=
name|repeat
decl_stmt|;
name|int
name|row
init|=
literal|3
operator|+
call|(
name|int
call|)
argument_list|(
name|code
operator|/
literal|16
argument_list|)
operator|+
operator|(
name|code
operator|>=
literal|128
operator|)
decl_stmt|;
name|int
name|col
init|=
literal|8
operator|+
call|(
name|int
call|)
argument_list|(
name|code
operator|%
literal|16
argument_list|)
operator|*
name|PC_COLS
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|MvPrintw
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
literal|"0x%02x:"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\033'
case|:
case|case
literal|0x9b
case|:
comment|/* 		 * Skip the ones that do not work. 		 */
break|break;
default|default:
name|addch
argument_list|(
name|colored_chtype
argument_list|(
name|code
argument_list|,
name|A_ALTCHARSET
operator||
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_box_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
operator|(
name|void
operator|)
name|repeat
expr_stmt|;
name|attr
operator||=
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the ACS Line-Drawing Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* *INDENT-OFF* */
name|wborder
argument_list|(
name|stdscr
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_VLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_VLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_HLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_HLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_ULCORNER
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_URCORNER
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_LLCORNER
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_LRCORNER
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvHLine
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_HLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
name|MvVLine
argument_list|(
literal|0
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_VLINE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
literal|0
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_TTEE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_PLUS
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_BTEE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_LTEE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
name|colored_chtype
argument_list|(
name|ACS_RTEE
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
comment|/* *INDENT-ON* */
block|}
end_function

begin_function
specifier|static
name|int
name|show_1_acs
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|repeat
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|chtype
name|code
parameter_list|)
block|{
specifier|const
name|int
name|height
init|=
literal|16
decl_stmt|;
name|int
name|row
init|=
literal|2
operator|+
operator|(
name|n
operator|%
name|height
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
name|n
operator|/
name|height
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s : "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|name
argument_list|)
expr_stmt|;
do|do
block|{
name|addch
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|repeat
operator|>
literal|0
condition|)
do|;
return|return
name|n
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_acs_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
comment|/* display the ACS character set */
block|{
name|int
name|n
decl_stmt|;
define|#
directive|define
name|BOTH
parameter_list|(
name|name
parameter_list|)
value|#name, colored_chtype(name, attr, (chtype) pair)
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
literal|0
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_RTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_TTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_BTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_VLINE
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * HPUX's ACS definitions are broken here.  Just give up.      */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|)
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_RARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_UARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_DARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_BOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LANTERN
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_BULLET
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_CKBOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_DEGREE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_DIAMOND
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_PLMINUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_GEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_NEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_LEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_STERLING
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_PI
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_S1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_S3
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_S7
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH
argument_list|(
name|ACS_S9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|acs_display
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
init|=
literal|'a'
decl_stmt|;
name|char
modifier|*
name|term
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch_kludge
init|=
operator|(
operator|(
name|term
operator|!=
literal|0
operator|&&
name|strstr
argument_list|(
name|term
argument_list|,
literal|"linux"
argument_list|)
operator|)
condition|?
literal|"p=PC, "
else|:
literal|""
operator|)
decl_stmt|;
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|int
name|digit
init|=
literal|0
decl_stmt|;
name|int
name|repeat
init|=
literal|1
decl_stmt|;
name|int
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
name|int
name|bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|unsigned
name|at_code
init|=
literal|0
decl_stmt|;
name|short
name|pair
init|=
literal|0
decl_stmt|;
name|void
function_decl|(
modifier|*
name|last_show_acs
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|attr_t
parameter_list|,
name|short
parameter_list|)
init|=
literal|0
function_decl|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|Repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ToggleAcs
argument_list|(
name|last_show_acs
argument_list|,
name|show_acs_chars
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
name|pch_kludge
condition|)
name|ToggleAcs
argument_list|(
name|last_show_acs
argument_list|,
name|show_pc_chars
argument_list|)
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ToggleAcs
argument_list|(
name|last_show_acs
argument_list|,
name|show_box_chars
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|digit
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|last_show_acs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|digit
operator|>
literal|0
condition|)
block|{
operator|--
name|digit
expr_stmt|;
name|last_show_acs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|digit
operator|<
literal|3
condition|)
block|{
operator|++
name|digit
expr_stmt|;
name|last_show_acs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|repeat
operator|<
operator|(
name|COLS
operator|/
literal|4
operator|)
condition|)
operator|++
name|repeat
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|repeat
operator|>
literal|1
condition|)
operator|--
name|repeat
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|cycle_attr
argument_list|(
name|c
argument_list|,
operator|&
name|at_code
argument_list|,
operator|&
name|attr
argument_list|)
operator|||
name|cycle_colors
argument_list|(
name|c
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|pair
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|last_show_acs
operator|!=
literal|0
condition|)
name|last_show_acs
argument_list|(
name|repeat
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
expr_stmt|;
else|else
name|show_upper_chars
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|digit
operator|*
literal|32
operator|+
literal|128
argument_list|)
argument_list|,
name|repeat
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Note: ANSI terminals may not display C1 characters."
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Select: a=ACS, x=box, %s0=C1, 1-3,+/- non-ASCII,</> repeat, ESC=quit"
argument_list|,
name|pch_kludge
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"v/V, f/F, b/B cycle through video attributes (%s) and color %d/%d."
argument_list|,
name|attrs_to_cycle
index|[
name|at_code
index|]
operator|.
name|name
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"v/V cycles through video attributes (%s)."
argument_list|,
name|attrs_to_cycle
index|[
name|at_code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|c
operator|=
name|Getchar
argument_list|()
argument_list|)
condition|)
do|;
name|Pause
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_function
specifier|static
name|cchar_t
modifier|*
name|merge_wide_attr
parameter_list|(
name|cchar_t
modifier|*
name|dst
parameter_list|,
specifier|const
name|cchar_t
modifier|*
name|src
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
do|do
block|{
name|TEST_CCHAR
argument_list|(
argument|src
argument_list|,
argument|count
argument_list|,
argument|{ 	    attr |= (test_attrs& A_ALTCHARSET); 	    setcchar(dst, test_wch, attr, pair, NULL); 	}
argument_list|,
argument|{ 	    ; 	}
argument_list|)
empty_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_upper_widechars
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|repeat
parameter_list|,
name|int
name|space
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|cchar_t
name|temp
decl_stmt|;
name|wchar_t
name|code
decl_stmt|;
name|int
name|last
init|=
name|first
operator|+
literal|31
decl_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of Character Codes %d to %d"
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
name|first
init|;
operator|(
name|int
operator|)
name|code
operator|<=
name|last
condition|;
name|code
operator|++
control|)
block|{
name|int
name|row
init|=
literal|2
operator|+
operator|(
operator|(
name|code
operator|-
name|first
operator|)
operator|%
literal|16
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
operator|(
name|code
operator|-
name|first
operator|)
operator|/
literal|16
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|wchar_t
name|codes
index|[
literal|10
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|count
init|=
name|repeat
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|memset
argument_list|(
operator|&
name|codes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|codes
argument_list|)
argument_list|)
expr_stmt|;
name|codes
index|[
literal|0
index|]
operator|=
name|code
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%3ld (0x%lx)"
argument_list|,
operator|(
name|long
operator|)
name|code
argument_list|,
operator|(
name|long
operator|)
name|code
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s: "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|setcchar
argument_list|(
operator|&
name|temp
argument_list|,
name|codes
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 	     * Give non-spacing characters something to combine with.  If we 	     * don't, they'll bunch up in a heap on the space after the ":". 	     * Mark them with reverse-video to make them simpler to find on 	     * the display. 	     */
if|if
condition|(
name|wcwidth
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|space
operator||
operator|(
name|A_REVERSE
operator|^
name|attr
operator|)
operator||
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * This could use add_wch(), but is done for comparison with the 	     * normal 'f' test (and to make a test-case for echo_wchar()). 	     * The screen will flicker because the erase() at the top of the 	     * function is met by the builtin refresh() in echo_wchar(). 	     */
name|echo_wchar
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* 	     * The repeat-count may make text wrap - avoid that. 	     */
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|col
operator|+
operator|(
name|COLS
operator|/
literal|2
operator|)
operator|-
literal|2
condition|)
break|break;
block|}
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|show_1_wacs
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|repeat
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|cchar_t
modifier|*
name|code
parameter_list|)
block|{
specifier|const
name|int
name|height
init|=
literal|16
decl_stmt|;
name|int
name|row
init|=
literal|2
operator|+
operator|(
name|n
operator|%
name|height
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
name|n
operator|/
name|height
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s : "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|repeat
operator|>=
literal|0
condition|)
block|{
name|add_wch
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|n
operator|+
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MERGE_ATTR
parameter_list|(
name|wch
parameter_list|)
value|merge_wide_attr(&temp, wch, attr, pair)
end_define

begin_function
specifier|static
name|void
name|show_wacs_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
comment|/* display the wide-ACS character set */
block|{
name|cchar_t
name|temp
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*#define BOTH2(name) #name,&(name) */
define|#
directive|define
name|BOTH2
parameter_list|(
name|name
parameter_list|)
value|#name, MERGE_ATTR(name)
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the Wide-ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
literal|0
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_RTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_TTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_VLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_RARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_UARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LANTERN
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BULLET
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_CKBOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DEGREE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DIAMOND
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLMINUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CURSES_WACS_ARRAY
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_GEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_NEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_STERLING
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PI
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S3
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S7
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WACS_D_PLUS
end_ifdef

begin_function
specifier|static
name|void
name|show_wacs_chars_double
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
comment|/* display the wide-ACS character set */
block|{
name|cchar_t
name|temp
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*#define BOTH2(name) #name,&(name) */
define|#
directive|define
name|BOTH2
parameter_list|(
name|name
parameter_list|)
value|#name, MERGE_ATTR(name)
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the Wide-ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
literal|0
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_LTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_RTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_TTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_BTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_D_VLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_RARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_UARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LANTERN
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BULLET
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_CKBOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DEGREE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DIAMOND
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLMINUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CURSES_WACS_ARRAY
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_GEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_NEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_STERLING
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PI
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S3
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S7
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WACS_T_PLUS
end_ifdef

begin_function
specifier|static
name|void
name|show_wacs_chars_thick
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
comment|/* display the wide-ACS character set */
block|{
name|cchar_t
name|temp
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*#define BOTH2(name) #name,&(name) */
define|#
directive|define
name|BOTH2
parameter_list|(
name|name
parameter_list|)
value|#name, MERGE_ATTR(name)
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the Wide-ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
literal|0
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_LTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_RTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_TTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_BTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_T_VLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_RARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_UARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LANTERN
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_BULLET
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_CKBOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DEGREE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_DIAMOND
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLMINUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CURSES_WACS_ARRAY
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_GEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_NEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_LEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_STERLING
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_PI
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S3
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S7
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|show_1_wacs
argument_list|(
name|n
argument_list|,
name|repeat
argument_list|,
name|BOTH2
argument_list|(
name|WACS_S9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|MERGE_ATTR
end_undef

begin_define
define|#
directive|define
name|MERGE_ATTR
parameter_list|(
name|n
parameter_list|,
name|wch
parameter_list|)
value|merge_wide_attr(&temp[n], wch, attr, pair)
end_define

begin_function
specifier|static
name|void
name|show_wbox_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|cchar_t
name|temp
index|[
literal|8
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|repeat
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the Wide-ACS Line-Drawing Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|wborder_set
argument_list|(
name|stdscr
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_VLINE
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|1
argument_list|,
name|WACS_VLINE
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|2
argument_list|,
name|WACS_HLINE
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|3
argument_list|,
name|WACS_HLINE
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|4
argument_list|,
name|WACS_ULCORNER
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|5
argument_list|,
name|WACS_URCORNER
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|6
argument_list|,
name|WACS_LLCORNER
argument_list|)
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|7
argument_list|,
name|WACS_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* *INDENT-OFF* */
operator|(
name|void
operator|)
name|mvhline_set
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_HLINE
argument_list|)
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvvline_set
argument_list|(
literal|0
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_VLINE
argument_list|)
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvadd_wch
argument_list|(
literal|0
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_TTEE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvadd_wch
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvadd_wch
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|/
literal|2
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_BTEE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvadd_wch
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_LTEE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvadd_wch
argument_list|(
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
name|MERGE_ATTR
argument_list|(
literal|0
argument_list|,
name|WACS_RTEE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* *INDENT-ON* */
block|}
end_function

begin_undef
undef|#
directive|undef
name|MERGE_ATTR
end_undef

begin_function
specifier|static
name|int
name|show_2_wacs
parameter_list|(
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|code
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
specifier|const
name|int
name|height
init|=
literal|16
decl_stmt|;
name|int
name|row
init|=
literal|2
operator|+
operator|(
name|n
operator|%
name|height
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
name|n
operator|/
name|height
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|MvPrintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s : "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attr_set
argument_list|(
name|attr
argument_list|,
name|pair
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|strcpy
argument_list|(
name|temp
argument_list|,
name|code
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|attr_set
argument_list|(
name|A_NORMAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|n
operator|+
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SHOW_UTF8
parameter_list|(
name|n
parameter_list|,
name|name
parameter_list|,
name|code
parameter_list|)
value|show_2_wacs(n, name, code, attr, pair)
end_define

begin_function
specifier|static
name|void
name|show_utf8_chars
parameter_list|(
name|int
name|repeat
parameter_list|,
name|attr_t
name|attr
parameter_list|,
name|short
name|pair
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|repeat
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the Wide-ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* *INDENT-OFF* */
name|n
operator|=
name|SHOW_UTF8
argument_list|(
literal|0
argument_list|,
literal|"WACS_ULCORNER"
argument_list|,
literal|"\342\224\214"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_URCORNER"
argument_list|,
literal|"\342\224\220"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LLCORNER"
argument_list|,
literal|"\342\224\224"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LRCORNER"
argument_list|,
literal|"\342\224\230"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LTEE"
argument_list|,
literal|"\342\224\234"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_RTEE"
argument_list|,
literal|"\342\224\244"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_TTEE"
argument_list|,
literal|"\342\224\254"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_BTEE"
argument_list|,
literal|"\342\224\264"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_HLINE"
argument_list|,
literal|"\342\224\200"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_VLINE"
argument_list|,
literal|"\342\224\202"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LARROW"
argument_list|,
literal|"\342\206\220"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_RARROW"
argument_list|,
literal|"\342\206\222"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_UARROW"
argument_list|,
literal|"\342\206\221"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_DARROW"
argument_list|,
literal|"\342\206\223"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_BLOCK"
argument_list|,
literal|"\342\226\256"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_BOARD"
argument_list|,
literal|"\342\226\222"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LANTERN"
argument_list|,
literal|"\342\230\203"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_BULLET"
argument_list|,
literal|"\302\267"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_CKBOARD"
argument_list|,
literal|"\342\226\222"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_DEGREE"
argument_list|,
literal|"\302\260"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_DIAMOND"
argument_list|,
literal|"\342\227\206"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_PLMINUS"
argument_list|,
literal|"\302\261"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_PLUS"
argument_list|,
literal|"\342\224\274"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_GEQUAL"
argument_list|,
literal|"\342\211\245"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_NEQUAL"
argument_list|,
literal|"\342\211\240"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_LEQUAL"
argument_list|,
literal|"\342\211\244"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_STERLING"
argument_list|,
literal|"\302\243"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_PI"
argument_list|,
literal|"\317\200"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_S1"
argument_list|,
literal|"\342\216\272"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_S3"
argument_list|,
literal|"\342\216\273"
argument_list|)
expr_stmt|;
name|n
operator|=
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_S7"
argument_list|,
literal|"\342\216\274"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SHOW_UTF8
argument_list|(
name|n
argument_list|,
literal|"WACS_S9"
argument_list|,
literal|"\342\216\275"
argument_list|)
expr_stmt|;
comment|/* *INDENT-ON* */
block|}
end_function

begin_comment
comment|/* display the wide-ACS character set */
end_comment

begin_function
specifier|static
name|void
name|wide_acs_display
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
init|=
literal|'a'
decl_stmt|;
name|int
name|digit
init|=
literal|0
decl_stmt|;
name|int
name|repeat
init|=
literal|1
decl_stmt|;
name|int
name|space
init|=
literal|' '
decl_stmt|;
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|int
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
name|int
name|bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|unsigned
name|at_code
init|=
literal|0
decl_stmt|;
name|short
name|pair
init|=
literal|0
decl_stmt|;
name|void
function_decl|(
modifier|*
name|last_show_wacs
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|attr_t
parameter_list|,
name|short
parameter_list|)
init|=
literal|0
function_decl|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|Repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ToggleAcs
argument_list|(
name|last_show_wacs
argument_list|,
name|show_wacs_chars
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|WACS_D_PLUS
case|case
literal|'d'
case|:
name|ToggleAcs
argument_list|(
name|last_show_wacs
argument_list|,
name|show_wacs_chars_double
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WACS_T_PLUS
case|case
literal|'t'
case|:
name|ToggleAcs
argument_list|(
name|last_show_wacs
argument_list|,
name|show_wacs_chars_thick
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'x'
case|:
name|ToggleAcs
argument_list|(
name|last_show_wacs
argument_list|,
name|show_wbox_chars
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ToggleAcs
argument_list|(
name|last_show_wacs
argument_list|,
name|show_utf8_chars
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|digit
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|last_show_wacs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
operator|++
name|digit
expr_stmt|;
name|last_show_wacs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|digit
operator|>
literal|0
condition|)
block|{
operator|--
name|digit
expr_stmt|;
name|last_show_wacs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
operator|&&
name|repeat
operator|<
operator|(
name|COLS
operator|/
literal|4
operator|)
condition|)
block|{
operator|++
name|repeat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
operator|&&
name|repeat
operator|>
literal|1
condition|)
block|{
operator|--
name|repeat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|space
operator|=
operator|(
name|space
operator|==
literal|' '
operator|)
condition|?
literal|'_'
else|:
literal|' '
expr_stmt|;
name|last_show_wacs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cycle_attr
argument_list|(
name|c
argument_list|,
operator|&
name|at_code
argument_list|,
operator|&
name|attr
argument_list|)
operator|||
name|cycle_colors
argument_list|(
name|c
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|pair
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_show_wacs
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|last_show_wacs
operator|!=
literal|0
condition|)
name|last_show_wacs
argument_list|(
name|repeat
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
expr_stmt|;
else|else
name|show_upper_widechars
argument_list|(
name|digit
operator|*
literal|32
operator|+
literal|128
argument_list|,
name|repeat
argument_list|,
name|space
argument_list|,
name|attr
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Select: a/d/t WACS, x box, u UTF-8, 0-9,+/- non-ASCII,</> repeat, ESC=quit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"v/V, f/F, b/B cycle through video attributes (%s) and color %d/%d."
argument_list|,
name|attrs_to_cycle
index|[
name|at_code
index|]
operator|.
name|name
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"v/V cycles through video attributes (%s)."
argument_list|,
name|attrs_to_cycle
index|[
name|at_code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|c
operator|=
name|Getchar
argument_list|()
argument_list|)
condition|)
do|;
name|Pause
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Graphic-rendition test (adapted from vttest)  */
end_comment

begin_function
specifier|static
name|void
name|test_sgr_attributes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|chtype
name|normal
init|=
operator|(
operator|(
name|pass
operator|==
literal|0
condition|?
name|A_NORMAL
else|:
name|A_REVERSE
operator|)
operator|)
operator||
name|BLANK
decl_stmt|;
comment|/* Use non-default colors if possible to exercise bce a little */
if|if
condition|(
name|use_colors
condition|)
block|{
name|init_pair
argument_list|(
literal|1
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|normal
operator||=
name|COLOR_PAIR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|MvPrintw
argument_list|(
literal|1
argument_list|,
literal|20
argument_list|,
literal|"Graphic rendition test pattern:"
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
literal|"vanilla"
argument_list|)
expr_stmt|;
define|#
directive|define
name|set_sgr
parameter_list|(
name|mask
parameter_list|)
value|bkgdset((normal^(mask)));
name|set_sgr
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|4
argument_list|,
literal|40
argument_list|,
literal|"bold"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|,
literal|"underline"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|6
argument_list|,
literal|45
argument_list|,
literal|"bold underline"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|,
literal|"blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|8
argument_list|,
literal|40
argument_list|,
literal|"bold blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_BLINK
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|,
literal|"underline blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_BLINK
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|10
argument_list|,
literal|45
argument_list|,
literal|"bold underline blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|,
literal|"negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|12
argument_list|,
literal|40
argument_list|,
literal|"bold negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|14
argument_list|,
literal|6
argument_list|,
literal|"underline negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|14
argument_list|,
literal|45
argument_list|,
literal|"bold underline negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|16
argument_list|,
literal|1
argument_list|,
literal|"blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|16
argument_list|,
literal|40
argument_list|,
literal|"bold blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|18
argument_list|,
literal|6
argument_list|,
literal|"underline blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|18
argument_list|,
literal|45
argument_list|,
literal|"bold underline blink negative"
argument_list|)
expr_stmt|;
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
literal|"%s background. "
argument_list|,
name|pass
operator|==
literal|0
condition|?
literal|"Dark"
else|:
literal|"Light"
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
block|}
name|bkgdset
argument_list|(
name|A_NORMAL
operator||
name|BLANK
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Windows and scrolling tester.  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BOTLINES
value|4
end_define

begin_comment
comment|/* number of line stolen from screen bottom */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|}
name|pair
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FRAME
value|struct frame
end_define

begin_macro
name|FRAME
end_macro

begin_block
block|{
name|FRAME
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|bool
name|do_scroll
decl_stmt|;
name|bool
name|do_keypad
decl_stmt|;
name|WINDOW
modifier|*
name|wind
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|NCURSES_VERSION_PATCH
operator|<
literal|20070331
operator|)
operator|&&
name|NCURSES_EXT_FUNCS
end_if

begin_define
define|#
directive|define
name|is_keypad
parameter_list|(
name|win
parameter_list|)
value|(win)->_use_keypad
end_define

begin_define
define|#
directive|define
name|is_scrollok
parameter_list|(
name|win
parameter_list|)
value|(win)->_scroll
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|is_keypad
argument_list|)
end_elif

begin_define
define|#
directive|define
name|is_keypad
parameter_list|(
name|win
parameter_list|)
value|FALSE
end_define

begin_define
define|#
directive|define
name|is_scrollok
parameter_list|(
name|win
parameter_list|)
value|FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|is_keypad
parameter_list|(
name|win
parameter_list|)
value|FALSE
end_define

begin_define
define|#
directive|define
name|is_scrollok
parameter_list|(
name|win
parameter_list|)
value|FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|WINDOW
modifier|*
name|frame_win
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
return|return
operator|(
name|curp
operator|!=
literal|0
operator|)
condition|?
name|curp
operator|->
name|wind
else|:
name|stdscr
return|;
block|}
end_function

begin_comment
comment|/* We need to know if these flags are actually set, so don't look in FRAME.  * These names are known to work with SVr4 curses as well as ncurses.  The  * _use_keypad name does not work with Solaris 8.  */
end_comment

begin_function
specifier|static
name|bool
name|HaveKeypad
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|frame_win
argument_list|(
name|curp
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|win
expr_stmt|;
return|return
name|is_keypad
argument_list|(
name|win
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|HaveScroll
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|frame_win
argument_list|(
name|curp
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|win
expr_stmt|;
return|return
name|is_scrollok
argument_list|(
name|win
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_legend
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|legend
index|[]
init|=
block|{
block|{
literal|"^C = create window"
block|,
literal|0
block|}
block|,
block|{
literal|"^N = next window"
block|,
literal|0
block|}
block|,
block|{
literal|"^P = previous window"
block|,
literal|0
block|}
block|,
block|{
literal|"^F = scroll forward"
block|,
literal|0
block|}
block|,
block|{
literal|"^B = scroll backward"
block|,
literal|0
block|}
block|,
block|{
literal|"^K = keypad(%s)"
block|,
literal|1
block|}
block|,
block|{
literal|"^S = scrollok(%s)"
block|,
literal|2
block|}
block|,
block|{
literal|"^W = save window to file"
block|,
literal|0
block|}
block|,
block|{
literal|"^R = restore window"
block|,
literal|0
block|}
block|,
if|#
directive|if
name|HAVE_WRESIZE
block|{
literal|"^X = resize"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"^Q%s = exit"
block|,
literal|3
block|}
block|}
struct|;
name|size_t
name|n
decl_stmt|;
name|int
name|x
decl_stmt|;
name|bool
name|do_keypad
init|=
name|HaveKeypad
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|bool
name|do_scroll
init|=
name|HaveScroll
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|legend
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
switch|switch
condition|(
name|legend
index|[
name|n
index|]
operator|.
name|code
condition|)
block|{
default|default:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_keypad
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_scroll
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_keypad
condition|?
literal|"/ESC"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|=
name|getcurx
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
operator|(
name|COLS
operator|<
operator|(
name|x
operator|+
literal|3
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
operator|)
condition|?
literal|"\n"
else|:
operator|(
name|n
condition|?
literal|", "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|transient
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|,
name|NCURSES_CONST
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|newwin_legend
argument_list|(
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|MvAddStr
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%s characters are echoed, window should %sscroll."
argument_list|,
name|HaveKeypad
argument_list|(
name|curp
argument_list|)
condition|?
literal|"Non-arrow"
else|:
literal|"All other"
argument_list|,
name|HaveScroll
argument_list|(
name|curp
argument_list|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_report
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
comment|/* report on the cursor's current position, then restore it */
block|{
name|WINDOW
modifier|*
name|win
init|=
name|frame_win
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|win
operator|!=
name|stdscr
condition|)
name|transient
argument_list|(
name|curp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|!=
name|stdscr
condition|)
name|refresh
argument_list|()
expr_stmt|;
else|else
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pair
modifier|*
name|selectcell
parameter_list|(
name|int
name|uli
parameter_list|,
name|int
name|ulj
parameter_list|,
name|int
name|lri
parameter_list|,
name|int
name|lrj
parameter_list|)
comment|/* arrows keys move cursor, return location at current on non-arrow key */
block|{
specifier|static
name|pair
name|res
decl_stmt|;
comment|/* result cell */
name|int
name|si
init|=
name|lri
operator|-
name|uli
operator|+
literal|1
decl_stmt|;
comment|/* depth of the select area */
name|int
name|sj
init|=
name|lrj
operator|-
name|ulj
operator|+
literal|1
decl_stmt|;
comment|/* width of the select area */
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* offsets into the select area */
name|res
operator|.
name|y
operator|=
name|uli
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|move
argument_list|(
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
name|newwin_report
argument_list|(
operator|(
name|FRAME
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Getchar
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|i
operator|+=
name|si
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|j
operator|+=
name|sj
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|case_QUIT
case|:
return|return
operator|(
operator|(
name|pair
operator|*
operator|)
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
case|case
name|KEY_MOUSE
case|:
block|{
name|MEVENT
name|event
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|y
operator|>
name|uli
operator|&&
name|event
operator|.
name|x
operator|>
name|ulj
condition|)
block|{
name|i
operator|=
name|event
operator|.
name|y
operator|-
name|uli
expr_stmt|;
name|j
operator|=
name|event
operator|.
name|x
operator|-
name|ulj
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHRU */
endif|#
directive|endif
default|default:
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
name|i
operator|%=
name|si
expr_stmt|;
name|j
operator|%=
name|sj
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outerbox
parameter_list|(
name|pair
name|ul
parameter_list|,
name|pair
name|lr
parameter_list|,
name|bool
name|onoff
parameter_list|)
comment|/* draw or erase a box *outside* the given pair of corners */
block|{
name|MvAddCh
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_ULCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_URCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_LRCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_LLCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|hline
argument_list|(
name|onoff
condition|?
name|ACS_HLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vline
argument_list|(
name|onoff
condition|?
name|ACS_VLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|hline
argument_list|(
name|onoff
condition|?
name|ACS_HLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vline
argument_list|(
name|onoff
condition|?
name|ACS_VLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|getwindow
parameter_list|(
name|void
parameter_list|)
comment|/* Ask user for a window definition */
block|{
name|WINDOW
modifier|*
name|rwindow
decl_stmt|;
name|pair
name|ul
decl_stmt|,
name|lr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 1"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|ul
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|,
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 2"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|rwindow
operator|=
name|subwin
argument_list|(
name|stdscr
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|rwindow
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
return|return
operator|(
name|rwindow
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_move
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dx
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|frame_win
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|int
name|cur_y
decl_stmt|,
name|cur_x
decl_stmt|;
name|int
name|max_y
decl_stmt|,
name|max_x
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|max_y
argument_list|,
name|max_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_x
operator|+=
name|dx
operator|)
operator|<
literal|0
condition|)
name|cur_x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_x
operator|>=
name|max_x
condition|)
name|cur_x
operator|=
name|max_x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cur_y
operator|+=
name|dy
operator|)
operator|<
literal|0
condition|)
name|cur_y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_y
operator|>=
name|max_y
condition|)
name|cur_y
operator|=
name|max_y
operator|-
literal|1
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FRAME
modifier|*
name|delete_framed
parameter_list|(
name|FRAME
modifier|*
name|fp
parameter_list|,
name|bool
name|showit
parameter_list|)
block|{
name|FRAME
modifier|*
name|np
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|fp
operator|->
name|last
operator|->
name|next
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|fp
operator|->
name|next
operator|->
name|last
operator|=
name|fp
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|showit
condition|)
block|{
name|werase
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
name|delwin
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
name|fp
operator|==
name|fp
operator|->
name|next
operator|)
condition|?
literal|0
else|:
name|fp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|np
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_and_scroll
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate windows */
block|{
name|int
name|c
decl_stmt|;
name|FRAME
modifier|*
name|current
init|=
operator|(
name|FRAME
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|neww
decl_stmt|;
name|WINDOW
modifier|*
name|usescr
decl_stmt|;
if|#
directive|if
name|HAVE_PUTWIN
operator|&&
name|HAVE_GETWIN
name|FILE
modifier|*
name|fp
decl_stmt|;
endif|#
directive|endif
define|#
directive|define
name|DUMPFILE
value|"screendump"
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|BUTTON1_CLICKED
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|CTRL
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
do|do
block|{
name|transient
argument_list|(
operator|(
name|FRAME
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'C'
argument_list|)
case|:
if|if
condition|(
operator|(
name|neww
operator|=
name|typeCalloc
argument_list|(
name|FRAME
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|breakout
goto|;
block|}
if|if
condition|(
operator|(
name|neww
operator|->
name|wind
operator|=
name|getwindow
argument_list|()
operator|)
operator|==
operator|(
name|WINDOW
operator|*
operator|)
literal|0
condition|)
block|{
name|free
argument_list|(
name|neww
argument_list|)
expr_stmt|;
goto|goto
name|breakout
goto|;
block|}
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
comment|/* First element,  */
name|neww
operator|->
name|next
operator|=
name|neww
expr_stmt|;
comment|/*   so point it at itself */
name|neww
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
else|else
block|{
name|neww
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|neww
operator|->
name|last
operator|=
name|current
expr_stmt|;
name|neww
operator|->
name|last
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
name|current
operator|=
name|neww
expr_stmt|;
comment|/* SVr4 curses sets the keypad on all newly-created windows to 	     * false.  Someone reported that PDCurses makes new windows inherit 	     * this flag.  Remove the following 'keypad()' call to test this 	     */
name|keypad
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|current
operator|->
name|do_keypad
operator|=
name|HaveKeypad
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|->
name|do_scroll
operator|=
name|HaveScroll
argument_list|(
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'N'
argument_list|)
case|:
comment|/* go to next window */
if|if
condition|(
name|current
condition|)
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'P'
argument_list|)
case|:
comment|/* go to previous window */
if|if
condition|(
name|current
condition|)
name|current
operator|=
name|current
operator|->
name|last
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'F'
argument_list|)
case|:
comment|/* scroll current window forward */
if|if
condition|(
name|current
condition|)
name|wscrl
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'B'
argument_list|)
case|:
comment|/* scroll current window backwards */
if|if
condition|(
name|current
condition|)
name|wscrl
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'K'
argument_list|)
case|:
comment|/* toggle keypad mode for current */
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|do_keypad
operator|=
operator|!
name|current
operator|->
name|do_keypad
expr_stmt|;
name|keypad
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|current
operator|->
name|do_keypad
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'S'
argument_list|)
case|:
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|do_scroll
operator|=
operator|!
name|current
operator|->
name|do_scroll
expr_stmt|;
name|scrollok
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|current
operator|->
name|do_scroll
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|HAVE_PUTWIN
operator|&&
name|HAVE_GETWIN
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
comment|/* save and delete window */
if|if
condition|(
operator|(
name|current
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|current
operator|==
name|current
operator|->
name|next
operator|)
condition|)
block|{
name|transient
argument_list|(
name|current
argument_list|,
literal|"Will not save/delete ONLY window"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|DUMPFILE
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|transient
argument_list|(
name|current
argument_list|,
literal|"Can't open screen dump file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putwin
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|current
operator|=
name|delete_framed
argument_list|(
name|current
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'R'
argument_list|)
case|:
comment|/* restore window */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|DUMPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|transient
argument_list|(
name|current
argument_list|,
literal|"Can't open screen dump file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|neww
operator|=
name|typeCalloc
argument_list|(
name|FRAME
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|neww
operator|->
name|next
operator|=
name|current
condition|?
name|current
operator|->
name|next
else|:
literal|0
expr_stmt|;
name|neww
operator|->
name|last
operator|=
name|current
expr_stmt|;
name|neww
operator|->
name|last
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|->
name|last
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|wind
operator|=
name|getwin
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|neww
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|HAVE_WRESIZE
case|case
name|CTRL
argument_list|(
literal|'X'
argument_list|)
case|:
comment|/* resize window */
if|if
condition|(
name|current
condition|)
block|{
name|pair
modifier|*
name|tmp
decl_stmt|,
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mx
decl_stmt|,
name|my
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark new corner"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getbegyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|lr
operator|.
name|y
operator|+=
operator|(
name|ul
operator|.
name|y
operator|-
literal|1
operator|)
expr_stmt|;
name|lr
operator|.
name|x
operator|+=
operator|(
name|ul
operator|.
name|x
operator|-
literal|1
operator|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
comment|/* strictly cosmetic hack for the test */
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|my
argument_list|,
name|mx
argument_list|)
expr_stmt|;
if|if
condition|(
name|my
operator|>
name|tmp
operator|->
name|y
operator|-
name|ul
operator|.
name|y
condition|)
block|{
name|getyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|tmp
operator|->
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mx
operator|>
name|tmp
operator|->
name|x
operator|-
name|ul
operator|.
name|x
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|my
condition|;
name|i
operator|++
control|)
block|{
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|i
argument_list|,
name|tmp
operator|->
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
name|wnoutrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wresize
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|0
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|0
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|lr
operator|.
name|y
operator|+=
operator|(
name|ul
operator|.
name|y
operator|-
literal|1
operator|)
expr_stmt|;
name|lr
operator|.
name|x
operator|+=
operator|(
name|ul
operator|.
name|x
operator|-
literal|1
operator|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_WRESIZE */
case|case
name|KEY_F
argument_list|(
literal|10
argument_list|)
case|:
comment|/* undocumented --- use this to test area clears */
name|selectcell
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_BACKSPACE
case|:
comment|/* FALLTHROUGH */
case|case
name|KEY_DC
case|:
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|y
operator|<
literal|0
condition|)
break|break;
name|x
operator|=
name|getmaxx
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mvwdelch
argument_list|(
name|frame_win
argument_list|(
name|current
argument_list|)
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\r'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|current
condition|)
name|waddch
argument_list|(
name|current
operator|->
name|wind
argument_list|,
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|newwin_report
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|usescr
operator|=
name|frame_win
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|usescr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isQuit
argument_list|(
name|c
operator|=
name|wGetchar
argument_list|(
name|usescr
argument_list|)
argument_list|)
operator|&&
operator|(
name|c
operator|!=
name|ERR
operator|)
condition|)
do|;
name|breakout
label|:
while|while
condition|(
name|current
operator|!=
literal|0
condition|)
name|current
operator|=
name|delete_framed
argument_list|(
name|current
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reset to driver's default */
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|noraw
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Panels tester  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBPANEL
end_if

begin_decl_stmt
specifier|static
name|int
name|nap_msec
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
name|mod
index|[]
init|=
block|{
literal|"test "
block|,
literal|"TEST "
block|,
literal|"(**) "
block|,
literal|"*()* "
block|,
literal|"<--> "
block|,
literal|"LAST "
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+------------------------------------------------------------------------- 	wait_a_while(msec) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|wait_a_while
parameter_list|(
name|int
name|msec
name|GCC_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|HAVE_NAPMS
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
else|else
name|napms
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msec
operator|>
literal|1000
condition|)
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|msec
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of wait_a_while */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	saywhat(text) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|saywhat
parameter_list|(
name|NCURSES_CONST
name|char
modifier|*
name|text
parameter_list|)
block|{
name|wmove
argument_list|(
name|stdscr
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
literal|0
operator|&&
operator|*
name|text
operator|!=
literal|'\0'
condition|)
block|{
name|waddstr
argument_list|(
name|stdscr
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|stdscr
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|waddstr
argument_list|(
name|stdscr
argument_list|,
literal|"press any key to continue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of saywhat */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	mkpanel(rows,cols,tly,tlx) - alloc a win and panel and associate them --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|PANEL
modifier|*
name|mkpanel
parameter_list|(
name|short
name|color
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|tly
parameter_list|,
name|int
name|tlx
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|PANEL
modifier|*
name|pan
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
name|newwin
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|,
name|tly
argument_list|,
name|tlx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pan
operator|=
name|new_panel
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_colors
condition|)
block|{
name|short
name|fg
init|=
call|(
name|short
call|)
argument_list|(
operator|(
name|color
operator|==
name|COLOR_BLUE
operator|)
condition|?
name|COLOR_WHITE
else|:
name|COLOR_BLACK
argument_list|)
decl_stmt|;
name|short
name|bg
init|=
name|color
decl_stmt|;
name|init_pair
argument_list|(
name|color
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|wbkgdset
argument_list|(
name|win
argument_list|,
call|(
name|attr_t
call|)
argument_list|(
name|COLOR_PAIR
argument_list|(
name|color
argument_list|)
operator||
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wbkgdset
argument_list|(
name|win
argument_list|,
name|A_BOLD
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pan
return|;
block|}
end_function

begin_comment
comment|/* end of mkpanel */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	rmpanel(pan) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|rmpanel
parameter_list|(
name|PANEL
modifier|*
name|pan
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|panel_window
argument_list|(
name|pan
argument_list|)
decl_stmt|;
name|del_panel
argument_list|(
name|pan
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmpanel */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	pflush() --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|pflush
parameter_list|(
name|void
parameter_list|)
block|{
name|update_panels
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of pflush */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	fill_panel(win) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|init_panel
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|LINES
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|COLS
condition|;
name|x
operator|++
control|)
name|wprintw
argument_list|(
name|stdscr
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|y
operator|+
name|x
operator|)
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_panel
parameter_list|(
name|PANEL
modifier|*
name|pan
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|panel_window
argument_list|(
name|pan
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|userptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|panel_userptr
argument_list|(
name|pan
argument_list|)
decl_stmt|;
name|int
name|num
init|=
operator|(
name|userptr
operator|&&
operator|*
name|userptr
operator|)
condition|?
name|userptr
index|[
literal|1
index|]
else|:
literal|'?'
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"-pan%c-"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|2
init|;
name|y
operator|<
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|UChar
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_function
specifier|static
name|void
name|init_wide_panel
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|digit
decl_stmt|;
name|cchar_t
name|temp
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|digit
operator|=
literal|0
init|;
name|digit
operator|<
literal|10
condition|;
operator|++
name|digit
control|)
name|make_fullwidth_digit
argument_list|(
operator|&
name|temp
index|[
name|digit
index|]
argument_list|,
name|digit
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|digit
operator|=
operator|(
name|y
operator|+
name|x
operator|/
literal|2
operator|)
operator|%
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|add_wch
argument_list|(
operator|&
name|temp
index|[
name|digit
index|]
argument_list|)
operator|!=
name|ERR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_wide_panel
parameter_list|(
name|PANEL
modifier|*
name|pan
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|panel_window
argument_list|(
name|pan
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|userptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|panel_userptr
argument_list|(
name|pan
argument_list|)
decl_stmt|;
name|int
name|num
init|=
operator|(
name|userptr
operator|&&
operator|*
name|userptr
operator|)
condition|?
name|userptr
index|[
literal|1
index|]
else|:
literal|'?'
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"-pan%c-"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|2
init|;
name|y
operator|<
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|UChar
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_PANELS
value|5
end_define

begin_function
specifier|static
name|void
name|canned_panel
parameter_list|(
name|PANEL
modifier|*
name|px
index|[
name|MAX_PANELS
operator|+
literal|1
index|]
parameter_list|,
name|NCURSES_CONST
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|which
init|=
name|cmd
index|[
literal|1
index|]
operator|-
literal|'0'
decl_stmt|;
name|saywhat
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'h'
case|:
name|hide_panel
argument_list|(
name|px
index|[
name|which
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|show_panel
argument_list|(
name|px
index|[
name|which
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|top_panel
argument_list|(
name|px
index|[
name|which
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bottom_panel
argument_list|(
name|px
index|[
name|which
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|rmpanel
argument_list|(
name|px
index|[
name|which
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|demo_panels
parameter_list|(
name|void
function_decl|(
modifier|*
name|InitPanel
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|FillPanel
function_decl|)
parameter_list|(
name|PANEL
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|itmp
decl_stmt|;
name|PANEL
modifier|*
name|px
index|[
name|MAX_PANELS
operator|+
literal|1
index|]
decl_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* we don't want stdscr to scroll! */
name|refresh
argument_list|()
expr_stmt|;
name|InitPanel
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|5
condition|;
name|count
operator|++
control|)
block|{
name|px
index|[
literal|1
index|]
operator|=
name|mkpanel
argument_list|(
name|COLOR_RED
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|px
index|[
literal|1
index|]
argument_list|,
operator|(
name|NCURSES_CONST
name|void
operator|*
operator|)
literal|"p1"
argument_list|)
expr_stmt|;
name|px
index|[
literal|2
index|]
operator|=
name|mkpanel
argument_list|(
name|COLOR_GREEN
argument_list|,
name|LINES
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|7
argument_list|,
name|LINES
operator|/
literal|4
argument_list|,
name|COLS
operator|/
literal|10
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|px
index|[
literal|2
index|]
argument_list|,
operator|(
name|NCURSES_CONST
name|void
operator|*
operator|)
literal|"p2"
argument_list|)
expr_stmt|;
name|px
index|[
literal|3
index|]
operator|=
name|mkpanel
argument_list|(
name|COLOR_YELLOW
argument_list|,
name|LINES
operator|/
literal|4
argument_list|,
name|COLS
operator|/
literal|10
argument_list|,
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|9
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|px
index|[
literal|3
index|]
argument_list|,
operator|(
name|NCURSES_CONST
name|void
operator|*
operator|)
literal|"p3"
argument_list|)
expr_stmt|;
name|px
index|[
literal|4
index|]
operator|=
name|mkpanel
argument_list|(
name|COLOR_BLUE
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|3
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|,
operator|(
name|NCURSES_CONST
name|void
operator|*
operator|)
literal|"p4"
argument_list|)
expr_stmt|;
name|px
index|[
literal|5
index|]
operator|=
name|mkpanel
argument_list|(
name|COLOR_MAGENTA
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
argument_list|,
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|,
operator|(
name|NCURSES_CONST
name|void
operator|*
operator|)
literal|"p5"
argument_list|)
expr_stmt|;
name|FillPanel
argument_list|(
name|px
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FillPanel
argument_list|(
name|px
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|FillPanel
argument_list|(
name|px
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|FillPanel
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|FillPanel
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|saywhat
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"h3 s1 s2 s4 s5"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|px
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|px
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|px
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"s1"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"s2"
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m2"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|2
index|]
argument_list|,
name|LINES
operator|/
literal|3
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|8
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"s3"
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m3"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|3
index|]
argument_list|,
name|LINES
operator|/
literal|4
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|15
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"b3"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"s4"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"s5"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t3"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t1"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t2"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t3"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t4"
argument_list|)
expr_stmt|;
for|for
control|(
name|itmp
operator|=
literal|0
init|;
name|itmp
operator|<
literal|6
condition|;
name|itmp
operator|++
control|)
block|{
name|WINDOW
modifier|*
name|w4
init|=
name|panel_window
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|w5
init|=
name|panel_window
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|saywhat
argument_list|(
literal|"m4"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w4
argument_list|,
name|LINES
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w4
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
name|itmp
operator|*
operator|(
name|COLS
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w5
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w5
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m5"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w4
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w4
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|5
index|]
argument_list|,
name|LINES
operator|/
literal|3
operator|-
literal|1
argument_list|,
operator|(
name|itmp
operator|*
literal|10
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w5
argument_list|,
name|LINES
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w5
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
block|}
name|saywhat
argument_list|(
literal|"m4"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|px
index|[
literal|4
index|]
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
name|itmp
operator|*
operator|(
name|COLS
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t5"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t2"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"t1"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"d2"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"h3"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"d1"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"d4"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"d5"
argument_list|)
expr_stmt|;
name|canned_panel
argument_list|(
name|px
argument_list|,
literal|"d3"
argument_list|)
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
break|break;
name|nap_msec
operator|=
literal|100L
expr_stmt|;
block|}
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBPANEL */
end_comment

begin_comment
comment|/****************************************************************************  *  * Pad tester  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|GRIDSIZE
value|3
end_define

begin_decl_stmt
specifier|static
name|bool
name|pending_pan
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|show_panner_legend
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|panner_legend
parameter_list|(
name|int
name|line
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|legend
index|[]
init|=
block|{
literal|"Use arrow keys (or U,D,L,R) to pan, ESC to quit, ! to shell-out."
block|,
literal|"Use +,- (or j,k) to grow/shrink the panner vertically."
block|,
literal|"Use<,> (or h,l) to grow/shrink the panner horizontally."
block|,
literal|"Number repeats.  Toggle legend:? filler:a timer:t scrollmark:s."
block|}
decl_stmt|;
name|int
name|n
init|=
operator|(
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
name|legend
argument_list|)
operator|-
operator|(
name|LINES
operator|-
name|line
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|move
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
operator|!=
name|ERR
condition|)
block|{
if|if
condition|(
name|show_panner_legend
condition|)
name|printw
argument_list|(
literal|"%s"
argument_list|,
name|legend
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
return|return
name|show_panner_legend
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|panner_h_cleanup
parameter_list|(
name|int
name|from_y
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|to_x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|panner_legend
argument_list|(
name|from_y
argument_list|)
condition|)
name|do_h_line
argument_list|(
name|from_y
argument_list|,
name|from_x
argument_list|,
literal|' '
argument_list|,
name|to_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|panner_v_cleanup
parameter_list|(
name|int
name|from_y
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|to_y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|panner_legend
argument_list|(
name|from_y
argument_list|)
condition|)
name|do_v_line
argument_list|(
name|from_y
argument_list|,
name|from_x
argument_list|,
literal|' '
argument_list|,
name|to_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_pad
parameter_list|(
name|WINDOW
modifier|*
name|panpad
parameter_list|,
name|bool
name|pan_lines
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|unsigned
name|gridcount
init|=
literal|0
decl_stmt|;
name|wmove
argument_list|(
name|panpad
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|getmaxy
argument_list|(
name|panpad
argument_list|)
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|getmaxx
argument_list|(
name|panpad
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|%
name|GRIDSIZE
operator|==
literal|0
operator|&&
name|x
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
literal|0
operator|&&
name|x
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
name|pan_lines
condition|?
name|ACS_ULCORNER
else|:
literal|'+'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
name|pan_lines
condition|?
name|ACS_TTEE
else|:
literal|'+'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|==
literal|0
operator|||
name|x
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
name|pan_lines
condition|?
name|ACS_LTEE
else|:
literal|'+'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
call|(
name|chtype
call|)
argument_list|(
operator|(
name|pan_lines
condition|?
literal|'a'
else|:
literal|'A'
operator|)
operator|+
call|(
name|int
call|)
argument_list|(
name|gridcount
operator|++
operator|%
literal|26
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
name|pan_lines
condition|?
name|ACS_HLINE
else|:
literal|'-'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
name|pan_lines
condition|?
name|ACS_VLINE
else|:
literal|'|'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|panner
parameter_list|(
name|WINDOW
modifier|*
name|pad
parameter_list|,
name|int
name|top_x
parameter_list|,
name|int
name|top_y
parameter_list|,
name|int
name|porty
parameter_list|,
name|int
name|portx
parameter_list|,
name|int
function_decl|(
modifier|*
name|pgetc
function_decl|)
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
parameter_list|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
name|bool
name|timing
init|=
name|TRUE
decl_stmt|;
endif|#
directive|endif
name|bool
name|pan_lines
init|=
name|FALSE
decl_stmt|;
name|bool
name|scrollers
init|=
name|TRUE
decl_stmt|;
name|int
name|basex
init|=
literal|0
decl_stmt|;
name|int
name|basey
init|=
literal|0
decl_stmt|;
name|int
name|pxmax
decl_stmt|,
name|pymax
decl_stmt|,
name|lowend
decl_stmt|,
name|highend
decl_stmt|,
name|c
decl_stmt|;
name|getmaxyx
argument_list|(
name|pad
argument_list|,
name|pymax
argument_list|,
name|pxmax
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* we don't want stdscr to scroll! */
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|NCURSES_VERSION
comment|/* 	 * During shell-out, the user may have resized the window.  Adjust 	 * the port size of the pad to accommodate this.  Ncurses automatically 	 * resizes all of the normal windows to fit on the new screen. 	 */
if|if
condition|(
name|top_x
operator|>
name|COLS
condition|)
name|top_x
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|portx
operator|>
name|COLS
condition|)
name|portx
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|top_y
operator|>
name|LINES
condition|)
name|top_y
operator|=
name|LINES
expr_stmt|;
if|if
condition|(
name|porty
operator|>
name|LINES
condition|)
name|porty
operator|=
name|LINES
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_REFRESH
case|:
name|erase
argument_list|()
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'?'
case|:
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|show_panner_legend
operator|=
operator|!
name|show_panner_legend
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|3
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|2
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|pan_lines
operator|=
operator|!
name|pan_lines
expr_stmt|;
name|fill_pad
argument_list|(
name|pad
argument_list|,
name|pan_lines
argument_list|)
expr_stmt|;
name|pending_pan
operator|=
name|FALSE
expr_stmt|;
break|break;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
case|case
literal|'t'
case|:
name|timing
operator|=
operator|!
name|timing
expr_stmt|;
if|if
condition|(
operator|!
name|timing
condition|)
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|scrollers
operator|=
operator|!
name|scrollers
expr_stmt|;
break|break;
comment|/* Move the top-left corner of the pad, keeping the bottom-right 	     * corner fixed. 	     */
case|case
literal|'h'
case|:
comment|/* increase-columns: move left edge to left */
if|if
condition|(
name|top_x
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
argument_list|,
name|top_x
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|top_x
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
comment|/* decrease-lines: move top-edge down */
if|if
condition|(
name|top_y
operator|>=
name|porty
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_h_cleanup
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
name|top_y
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
comment|/* increase-lines: move top-edge up */
if|if
condition|(
name|top_y
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|top_y
operator|--
expr_stmt|;
name|panner_h_cleanup
argument_list|(
name|top_y
argument_list|,
name|top_x
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* decrease-columns: move left-edge to right */
if|if
condition|(
name|top_x
operator|>=
name|portx
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|top_x
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Move the bottom-right corner of the pad, keeping the top-left 	     * corner fixed. 	     */
case|case
name|KEY_IC
case|:
comment|/* increase-columns: move right-edge to right */
if|if
condition|(
name|portx
operator|>=
name|pxmax
operator|||
name|portx
operator|>=
name|COLS
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|porty
argument_list|)
expr_stmt|;
operator|++
name|portx
expr_stmt|;
block|}
break|break;
case|case
name|KEY_IL
case|:
comment|/* increase-lines: move bottom-edge down */
if|if
condition|(
name|porty
operator|>=
name|pymax
operator|||
name|porty
operator|>=
name|LINES
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_h_cleanup
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
operator|++
name|porty
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DC
case|:
comment|/* decrease-columns: move bottom edge up */
if|if
condition|(
name|portx
operator|<=
name|top_x
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|portx
operator|--
expr_stmt|;
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|,
name|porty
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DL
case|:
comment|/* decrease-lines */
if|if
condition|(
name|porty
operator|<=
name|top_y
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|porty
operator|--
expr_stmt|;
name|panner_h_cleanup
argument_list|(
name|porty
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_LEFT
case|:
comment|/* pan leftwards */
if|if
condition|(
name|basex
operator|>
literal|0
condition|)
name|basex
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
comment|/* pan rightwards */
if|if
condition|(
name|basex
operator|+
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
operator|<
name|pxmax
condition|)
name|basex
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
comment|/* pan upwards */
if|if
condition|(
name|basey
operator|>
literal|0
condition|)
name|basey
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
comment|/* pan downwards */
if|if
condition|(
name|basey
operator|+
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
operator|<
name|pymax
condition|)
name|basey
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
name|KEY_HOME
case|:
case|case
name|KEY_FIND
case|:
name|basey
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
name|KEY_END
case|:
case|case
name|KEY_SELECT
case|:
name|basey
operator|=
name|pymax
operator|-
name|porty
expr_stmt|;
if|if
condition|(
name|basey
operator|<
literal|0
condition|)
name|basey
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|MvAddCh
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrollers
operator|&&
operator|(
name|pxmax
operator|>
name|portx
operator|-
literal|1
operator|)
condition|)
block|{
name|int
name|length
init|=
operator|(
name|portx
operator|-
name|top_x
operator|-
literal|1
operator|)
decl_stmt|;
name|float
name|ratio
init|=
operator|(
operator|(
name|float
operator|)
name|length
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|pxmax
operator|)
decl_stmt|;
name|lowend
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|top_x
operator|+
operator|(
operator|(
name|float
operator|)
name|basex
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|highend
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|top_x
operator|+
operator|(
call|(
name|float
call|)
argument_list|(
name|basex
operator|+
name|length
argument_list|)
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|lowend
argument_list|)
expr_stmt|;
if|if
condition|(
name|highend
operator|<
name|portx
condition|)
block|{
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|lowend
argument_list|,
literal|' '
argument_list|,
name|highend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|highend
operator|+
literal|1
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrollers
operator|&&
operator|(
name|pymax
operator|>
name|porty
operator|-
literal|1
operator|)
condition|)
block|{
name|int
name|length
init|=
operator|(
name|porty
operator|-
name|top_y
operator|-
literal|1
operator|)
decl_stmt|;
name|float
name|ratio
init|=
operator|(
operator|(
name|float
operator|)
name|length
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|pymax
operator|)
decl_stmt|;
name|lowend
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|top_y
operator|+
operator|(
operator|(
name|float
operator|)
name|basey
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|highend
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|top_y
operator|+
operator|(
call|(
name|float
call|)
argument_list|(
name|basey
operator|+
name|length
argument_list|)
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|lowend
argument_list|)
expr_stmt|;
if|if
condition|(
name|highend
operator|<
name|porty
condition|)
block|{
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|lowend
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
literal|' '
argument_list|,
name|highend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|highend
operator|+
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|MvAddCh
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending_pan
condition|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|pnoutrefresh
argument_list|(
name|pad
argument_list|,
name|basey
argument_list|,
name|basex
argument_list|,
name|top_y
argument_list|,
name|top_x
argument_list|,
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
operator|-
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
define|#
directive|define
name|TIMEVAL2S
parameter_list|(
name|data
parameter_list|)
value|((double) data.tv_sec + ((double) data.tv_usec / 1.0e6))
if|if
condition|(
name|timing
condition|)
block|{
name|double
name|elapsed
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elapsed
operator|=
operator|(
name|TIMEVAL2S
argument_list|(
name|after
argument_list|)
operator|-
name|TIMEVAL2S
argument_list|(
name|before
argument_list|)
operator|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|12
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Secs: %2.03f"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|(
name|pad
argument_list|)
operator|)
operator|!=
name|KEY_EXIT
condition|)
do|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reset to driver's default */
block|}
end_function

begin_function
specifier|static
name|int
name|padgetch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
specifier|static
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|last
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|pending_pan
operator|=
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
operator|!=
name|FALSE
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|pending_pan
operator|=
operator|(
name|count
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|wGetchar
argument_list|(
name|win
argument_list|)
condition|)
block|{
case|case
literal|'!'
case|:
name|ShellOut
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|CTRL
argument_list|(
literal|'r'
argument_list|)
case|:
name|endwin
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|c
operator|=
name|KEY_UP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|c
operator|=
name|KEY_DOWN
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|c
operator|=
name|KEY_RIGHT
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|c
operator|=
name|KEY_LEFT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|c
operator|=
name|KEY_IL
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
name|KEY_DL
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
name|KEY_IC
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
name|KEY_DC
expr_stmt|;
break|break;
case|case
name|ERR
case|:
comment|/* FALLTHRU */
case|case
name|case_QUIT
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|KEY_EXIT
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|count
operator|=
name|count
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|last
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|count
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PAD_HIGH
value|200
end_define

begin_define
define|#
directive|define
name|PAD_WIDE
value|200
end_define

begin_function
specifier|static
name|void
name|demo_pad
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate pads. */
block|{
name|WINDOW
modifier|*
name|panpad
init|=
name|newpad
argument_list|(
name|PAD_HIGH
argument_list|,
name|PAD_WIDE
argument_list|)
decl_stmt|;
if|if
condition|(
name|panpad
operator|==
literal|0
condition|)
block|{
name|Cannot
argument_list|(
literal|"cannot create requested pad"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fill_pad
argument_list|(
name|panpad
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|3
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|2
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|panpad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Make the pad (initially) narrow enough that a trace file won't wrap.      * We'll still be able to widen it during a test, since that's required      * for testing boundaries.      */
name|panner
argument_list|(
name|panpad
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|LINES
operator|-
literal|5
argument_list|,
name|COLS
operator|-
literal|15
argument_list|,
name|padgetch
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|panpad
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Tests from John Burnell's PDCurses tester  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Continue
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|noecho
argument_list|()
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flushinp_test
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
comment|/* Input test, adapted from John Burnell's PDCurses tester */
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|bx
decl_stmt|,
name|by
decl_stmt|,
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|i
decl_stmt|;
name|WINDOW
modifier|*
name|subWin
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|h
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|by
argument_list|,
name|bx
argument_list|)
expr_stmt|;
name|sw
operator|=
name|w
operator|/
literal|3
expr_stmt|;
name|sh
operator|=
name|h
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|subWin
operator|=
name|subwin
argument_list|(
name|win
argument_list|,
name|sh
argument_list|,
name|sw
argument_list|,
name|by
operator|+
name|h
operator|-
name|sh
operator|-
literal|2
argument_list|,
name|bx
operator|+
name|w
operator|-
name|sw
operator|-
literal|2
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|use_colors
condition|)
block|{
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_CYAN
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|wbkgd
argument_list|(
name|subWin
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|2
argument_list|)
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|subWin
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"This is a subwindow"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
comment|/*      * This used to set 'nocbreak()'.  However, Alexander Lukyanov says that      * it only happened to "work" on SVr4 because that implementation does not      * emulate nocbreak+noecho mode, whereas ncurses does.  To get the desired      * test behavior, we're using 'cbreak()', which will allow a single      * character to return without needing a newline. - T.Dickey 1997/10/11.      */
name|cbreak
argument_list|()
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"This is a test of the flushinp() call."
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Type random keys for 5 seconds."
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|"These should be discarded (not echoed) after the subwindow goes away."
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|MvWPrintw
argument_list|(
name|subWin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Time = %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
block|}
name|delwin
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flash
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"If you were still typing when the window timer expired,"
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|"or else you typed nothing at all while it was running,"
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"test was invalid.  You'll see garbage or nothing at all. "
argument_list|)
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|"Press a key"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wGetchar
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
name|MvWAddStr
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|"If you see any key other than what you typed, flushinp() is broken."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wdelch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"What you typed should now have been deleted; if not, wdelch() failed."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Menu test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBMENU
end_if

begin_define
define|#
directive|define
name|MENU_Y
value|8
end_define

begin_define
define|#
directive|define
name|MENU_X
value|8
end_define

begin_function
specifier|static
name|int
name|menu_virtualize
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|KEY_EXIT
condition|)
return|return
operator|(
name|MAX_COMMAND
operator|+
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
return|return
operator|(
name|REQ_SCR_ULINE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
return|return
operator|(
name|REQ_SCR_DLINE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
name|KEY_NPAGE
condition|)
return|return
operator|(
name|REQ_SCR_UPAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
operator|||
name|c
operator|==
name|KEY_PPAGE
condition|)
return|return
operator|(
name|REQ_SCR_DPAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
name|KEY_DOWN
condition|)
return|return
operator|(
name|REQ_NEXT_ITEM
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
name|KEY_UP
condition|)
return|return
operator|(
name|REQ_PREV_ITEM
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
name|REQ_TOGGLE_ITEM
operator|)
return|;
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|KEY_MOUSE
condition|)
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|CONST_MENUS
name|char
modifier|*
name|animals
index|[]
init|=
block|{
literal|"Lions"
block|,
literal|"Tigers"
block|,
literal|"Bears"
block|,
literal|"(Oh my!)"
block|,
literal|"Newts"
block|,
literal|"Platypi"
block|,
literal|"Lemurs"
block|,
literal|"(Oh really?!)"
block|,
literal|"Leopards"
block|,
literal|"Panthers"
block|,
literal|"Pumas"
block|,
literal|"Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs"
block|,
literal|"Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs, Lions, Tigers, Bears, (Oh my!), Newts, Platypi, Lemurs"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|menu_test
parameter_list|(
name|void
parameter_list|)
block|{
name|MENU
modifier|*
name|m
decl_stmt|;
name|ITEM
modifier|*
name|items
index|[
name|SIZEOF
argument_list|(
name|animals
argument_list|)
index|]
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|ip
init|=
name|items
decl_stmt|;
name|CONST_MENUS
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|mrows
decl_stmt|,
name|mcols
decl_stmt|,
name|c
decl_stmt|;
name|WINDOW
modifier|*
name|menuwin
decl_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"This is the menu test:"
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"  Use up and down arrow to move the select bar."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|"  'n' and 'p' act like arrows."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"  'b' and 'f' scroll up/down (page), 'u' and 'd' (line)."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"  Press return to exit."
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|animals
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ip
operator|=
name|new_item
argument_list|(
operator|*
name|ap
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|ip
expr_stmt|;
block|}
operator|*
name|ip
operator|=
operator|(
name|ITEM
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|=
name|new_menu
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|set_menu_format
argument_list|(
name|m
argument_list|,
operator|(
name|SIZEOF
argument_list|(
name|animals
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scale_menu
argument_list|(
name|m
argument_list|,
operator|&
name|mrows
argument_list|,
operator|&
name|mcols
argument_list|)
expr_stmt|;
name|menuwin
operator|=
name|newwin
argument_list|(
name|mrows
operator|+
literal|2
argument_list|,
name|mcols
operator|+
literal|2
argument_list|,
name|MENU_Y
argument_list|,
name|MENU_X
argument_list|)
expr_stmt|;
name|set_menu_win
argument_list|(
name|m
argument_list|,
name|menuwin
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|menuwin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|menuwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_menu_sub
argument_list|(
name|m
argument_list|,
name|derwin
argument_list|(
name|menuwin
argument_list|,
name|mrows
argument_list|,
name|mcols
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|menu_driver
argument_list|(
name|m
argument_list|,
name|menu_virtualize
argument_list|(
name|wGetchar
argument_list|(
name|menuwin
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
name|E_UNKNOWN_COMMAND
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|E_NOT_POSTED
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|E_REQUEST_DENIED
condition|)
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"You chose: %s\n"
argument_list|,
name|item_name
argument_list|(
name|current_item
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"Press any key to continue..."
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|unpost_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|menuwin
argument_list|)
expr_stmt|;
name|free_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|items
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
name|free_item
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|T_TBL
parameter_list|(
name|name
parameter_list|)
value|{ #name, name }
end_define

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
block|}
name|t_tbl
index|[]
init|=
block|{
name|T_TBL
argument_list|(
name|TRACE_DISABLE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_TIMES
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_TPUTS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_UPDATE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_MOVE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CHARPUT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ORDINARY
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_VIRTPUT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_IEVENT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_BITS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ICALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CCALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_DATABASE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ATTRS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_MAXIMUM
argument_list|)
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|tracetrace
parameter_list|(
name|unsigned
name|tlevel
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|size_t
name|need
init|=
literal|12
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
name|need
operator|+=
name|strlen
argument_list|(
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|typeMalloc
argument_list|(
name|char
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x = {"
argument_list|,
name|tlevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlevel
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s, "
argument_list|,
name|t_tbl
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|(
name|tlevel
operator|&
name|t_tbl
index|[
name|n
index|]
operator|.
name|mask
operator|)
operator|==
name|t_tbl
index|[
name|n
index|]
operator|.
name|mask
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|','
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fake a dynamically reconfigurable menu using the 0th entry to deselect  * the others  */
end_comment

begin_function
specifier|static
name|int
name|run_trace_menu
parameter_list|(
name|MENU
modifier|*
name|m
parameter_list|)
block|{
name|ITEM
modifier|*
modifier|*
name|items
decl_stmt|;
name|ITEM
modifier|*
name|i
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|changed
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|menu_driver
argument_list|(
name|m
argument_list|,
name|menu_virtualize
argument_list|(
name|wGetchar
argument_list|(
name|menu_win
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|E_UNKNOWN_COMMAND
case|:
return|return
name|FALSE
return|;
default|default:
name|items
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|i
operator|=
name|current_item
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|items
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|item_value
argument_list|(
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|items
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|set_item_value
argument_list|(
operator|*
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|items
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|set_item_value
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trace_set
parameter_list|(
name|void
parameter_list|)
comment|/* interactively set the trace level */
block|{
name|MENU
modifier|*
name|m
decl_stmt|;
name|ITEM
modifier|*
name|items
index|[
name|SIZEOF
argument_list|(
name|t_tbl
argument_list|)
index|]
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|ip
init|=
name|items
decl_stmt|;
name|int
name|mrows
decl_stmt|,
name|mcols
decl_stmt|;
name|unsigned
name|newtrace
decl_stmt|;
name|int
name|n
decl_stmt|;
name|WINDOW
modifier|*
name|menuwin
decl_stmt|;
name|MvAddStr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Interactively set trace level:"
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"  Press space bar to toggle a selection."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|"  Use up and down arrow to move the select bar."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"  Press return to set the trace level."
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|"(Current trace level is %s)"
argument_list|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ip
operator|=
name|new_item
argument_list|(
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|ip
expr_stmt|;
block|}
block|}
operator|*
name|ip
operator|=
operator|(
name|ITEM
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|=
name|new_menu
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|set_menu_format
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|scale_menu
argument_list|(
name|m
argument_list|,
operator|&
name|mrows
argument_list|,
operator|&
name|mcols
argument_list|)
expr_stmt|;
name|menu_opts_off
argument_list|(
name|m
argument_list|,
name|O_ONEVALUE
argument_list|)
expr_stmt|;
name|menuwin
operator|=
name|newwin
argument_list|(
name|mrows
operator|+
literal|2
argument_list|,
name|mcols
operator|+
literal|2
argument_list|,
name|MENU_Y
argument_list|,
name|MENU_X
argument_list|)
expr_stmt|;
name|set_menu_win
argument_list|(
name|m
argument_list|,
name|menuwin
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|menuwin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|menuwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_menu_sub
argument_list|(
name|m
argument_list|,
name|derwin
argument_list|(
name|menuwin
argument_list|,
name|mrows
argument_list|,
name|mcols
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
block|{
name|unsigned
name|mask
init|=
name|t_tbl
index|[
name|item_index
argument_list|(
operator|*
name|ip
argument_list|)
index|]
operator|.
name|mask
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|set_item_value
argument_list|(
operator|*
name|ip
argument_list|,
name|_nc_tracing
operator|==
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
name|_nc_tracing
operator|)
operator|==
name|mask
condition|)
name|set_item_value
argument_list|(
operator|*
name|ip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|run_trace_menu
argument_list|(
name|m
argument_list|)
condition|)
continue|continue;
name|newtrace
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
name|newtrace
operator||=
name|t_tbl
index|[
name|item_index
argument_list|(
operator|*
name|ip
argument_list|)
index|]
operator|.
name|mask
expr_stmt|;
name|trace
argument_list|(
name|newtrace
argument_list|)
expr_stmt|;
name|Trace
argument_list|(
operator|(
literal|"trace level interactively set to %s"
operator|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|MvPrintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Trace level is %s\n"
argument_list|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"Press any key to continue..."
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|unpost_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|menuwin
argument_list|)
expr_stmt|;
name|free_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|items
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
name|free_item
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRACE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBMENU */
end_comment

begin_comment
comment|/****************************************************************************  *  * Forms test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBFORM
end_if

begin_function
specifier|static
name|FIELD
modifier|*
name|make_label
parameter_list|(
name|int
name|frow
parameter_list|,
name|int
name|fcol
parameter_list|,
name|NCURSES_CONST
name|char
modifier|*
name|label
parameter_list|)
block|{
name|FIELD
modifier|*
name|f
init|=
name|new_field
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|set_field_buffer
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|set_field_opts
argument_list|(
name|f
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|field_opts
argument_list|(
name|f
argument_list|)
operator|&
operator|~
name|O_ACTIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|FIELD
modifier|*
name|make_field
parameter_list|(
name|int
name|frow
parameter_list|,
name|int
name|fcol
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
name|bool
name|secure
parameter_list|)
block|{
name|FIELD
modifier|*
name|f
init|=
name|new_field
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|,
literal|0
argument_list|,
name|secure
condition|?
literal|1
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|set_field_back
argument_list|(
name|f
argument_list|,
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|set_field_userptr
argument_list|(
name|f
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_form
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|scale_form
argument_list|(
name|f
argument_list|,
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|newwin
argument_list|(
name|rows
operator|+
literal|2
argument_list|,
name|cols
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
literal|0
condition|)
block|{
name|set_form_win
argument_list|(
name|f
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|set_form_sub
argument_list|(
name|f
argument_list|,
name|derwin
argument_list|(
name|w
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|w
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|post_form
argument_list|(
name|f
argument_list|)
operator|!=
name|E_OK
condition|)
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|erase_form
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|form_win
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|s
init|=
name|form_sub
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|unpost_form
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|edit_secure
parameter_list|(
name|FIELD
modifier|*
name|me
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|frow
decl_stmt|,
name|fcol
decl_stmt|,
name|nrow
decl_stmt|,
name|nbuf
decl_stmt|;
if|if
condition|(
name|field_info
argument_list|(
name|me
argument_list|,
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|,
operator|&
name|frow
argument_list|,
operator|&
name|fcol
argument_list|,
operator|&
name|nrow
argument_list|,
operator|&
name|nbuf
argument_list|)
operator|==
name|E_OK
operator|&&
name|nbuf
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|source
init|=
name|field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|long
name|len
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|source
condition|?
name|source
else|:
literal|""
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|long
operator|)
operator|(
name|char
operator|*
operator|)
name|field_userptr
argument_list|(
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|KEY_MAX
condition|)
block|{
if|if
condition|(
name|isgraph
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|len
operator|+
literal|1
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|temp
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|REQ_BEG_FIELD
case|:
case|case
name|REQ_CLR_EOF
case|:
case|case
name|REQ_CLR_EOL
case|:
case|case
name|REQ_DEL_LINE
case|:
case|case
name|REQ_DEL_WORD
case|:
case|case
name|REQ_DOWN_CHAR
case|:
case|case
name|REQ_END_FIELD
case|:
case|case
name|REQ_INS_CHAR
case|:
case|case
name|REQ_INS_LINE
case|:
case|case
name|REQ_LEFT_CHAR
case|:
case|case
name|REQ_NEW_LINE
case|:
case|case
name|REQ_NEXT_WORD
case|:
case|case
name|REQ_PREV_WORD
case|:
case|case
name|REQ_RIGHT_CHAR
case|:
case|case
name|REQ_UP_CHAR
case|:
name|c
operator|=
literal|0
expr_stmt|;
comment|/* we don't want to do inline editing */
break|break;
case|case
name|REQ_CLR_FIELD
case|:
if|if
condition|(
name|len
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REQ_DEL_CHAR
case|:
case|case
name|REQ_DEL_PREV
case|:
if|if
condition|(
name|len
condition|)
block|{
name|temp
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|set_field_userptr
argument_list|(
name|me
argument_list|,
operator|(
name|void
operator|*
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|form_virtualize
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|,
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
specifier|const
struct|struct
block|{
name|int
name|code
decl_stmt|;
name|int
name|result
decl_stmt|;
block|}
name|lookup
index|[]
init|=
block|{
block|{
name|CTRL
argument_list|(
literal|'A'
argument_list|)
block|,
name|REQ_NEXT_CHOICE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'B'
argument_list|)
block|,
name|REQ_PREV_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'C'
argument_list|)
block|,
name|REQ_CLR_EOL
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'D'
argument_list|)
block|,
name|REQ_DOWN_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'E'
argument_list|)
block|,
name|REQ_END_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'F'
argument_list|)
block|,
name|REQ_NEXT_PAGE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'G'
argument_list|)
block|,
name|REQ_DEL_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'H'
argument_list|)
block|,
name|REQ_DEL_PREV
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'I'
argument_list|)
block|,
name|REQ_INS_CHAR
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'K'
argument_list|)
block|,
name|REQ_CLR_EOF
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'L'
argument_list|)
block|,
name|REQ_LEFT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'M'
argument_list|)
block|,
name|REQ_NEW_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'N'
argument_list|)
block|,
name|REQ_NEXT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'O'
argument_list|)
block|,
name|REQ_INS_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'P'
argument_list|)
block|,
name|REQ_PREV_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'R'
argument_list|)
block|,
name|REQ_RIGHT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'S'
argument_list|)
block|,
name|REQ_BEG_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'U'
argument_list|)
block|,
name|REQ_UP_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'V'
argument_list|)
block|,
name|REQ_DEL_CHAR
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'W'
argument_list|)
block|,
name|REQ_NEXT_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'X'
argument_list|)
block|,
name|REQ_CLR_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'Y'
argument_list|)
block|,
name|REQ_DEL_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'Z'
argument_list|)
block|,
name|REQ_PREV_CHOICE
block|}
block|,
block|{
name|ESCAPE
block|,
name|MAX_FORM_COMMAND
operator|+
literal|1
block|}
block|,
block|{
name|KEY_BACKSPACE
block|,
name|REQ_DEL_PREV
block|}
block|,
block|{
name|KEY_DOWN
block|,
name|REQ_DOWN_CHAR
block|}
block|,
block|{
name|KEY_END
block|,
name|REQ_LAST_FIELD
block|}
block|,
block|{
name|KEY_HOME
block|,
name|REQ_FIRST_FIELD
block|}
block|,
block|{
name|KEY_LEFT
block|,
name|REQ_LEFT_CHAR
block|}
block|,
block|{
name|KEY_LL
block|,
name|REQ_LAST_FIELD
block|}
block|,
block|{
name|KEY_NEXT
block|,
name|REQ_NEXT_FIELD
block|}
block|,
block|{
name|KEY_NPAGE
block|,
name|REQ_NEXT_PAGE
block|}
block|,
block|{
name|KEY_PPAGE
block|,
name|REQ_PREV_PAGE
block|}
block|,
block|{
name|KEY_PREVIOUS
block|,
name|REQ_PREV_FIELD
block|}
block|,
block|{
name|KEY_RIGHT
block|,
name|REQ_RIGHT_CHAR
block|}
block|,
block|{
name|KEY_UP
block|,
name|REQ_UP_CHAR
block|}
block|,
block|{
name|QUIT
block|,
name|MAX_FORM_COMMAND
operator|+
literal|1
block|}
block|}
struct|;
comment|/* *INDENT-ON* */
specifier|static
name|int
name|mode
init|=
name|REQ_INS_MODE
decl_stmt|;
name|int
name|c
init|=
name|wGetchar
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|FIELD
modifier|*
name|me
init|=
name|current_field
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|bool
name|current
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CTRL
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|REQ_INS_MODE
condition|)
block|{
name|mode
operator|=
name|REQ_OVL_MODE
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|REQ_INS_MODE
expr_stmt|;
block|}
name|c
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|lookup
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|lookup
index|[
name|n
index|]
operator|.
name|code
operator|==
name|c
condition|)
block|{
name|c
operator|=
name|lookup
index|[
name|n
index|]
operator|.
name|result
expr_stmt|;
break|break;
block|}
block|}
block|}
name|MvPrintw
argument_list|(
literal|0
argument_list|,
name|COLS
operator|-
literal|6
argument_list|,
literal|"(%s)"
argument_list|,
name|mode
operator|==
name|REQ_INS_MODE
condition|?
literal|"INS"
else|:
literal|"OVL"
argument_list|)
expr_stmt|;
comment|/*      * Force the field that the user is typing into to be in reverse video,      * while the other fields are shown underlined.      */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|REQ_BEG_FIELD
case|:
case|case
name|REQ_CLR_EOF
case|:
case|case
name|REQ_CLR_EOL
case|:
case|case
name|REQ_CLR_FIELD
case|:
case|case
name|REQ_DEL_CHAR
case|:
case|case
name|REQ_DEL_LINE
case|:
case|case
name|REQ_DEL_PREV
case|:
case|case
name|REQ_DEL_WORD
case|:
case|case
name|REQ_END_FIELD
case|:
case|case
name|REQ_INS_CHAR
case|:
case|case
name|REQ_INS_LINE
case|:
case|case
name|REQ_LEFT_CHAR
case|:
case|case
name|REQ_LEFT_FIELD
case|:
case|case
name|REQ_NEXT_WORD
case|:
case|case
name|REQ_RIGHT_CHAR
case|:
name|current
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|current
operator|=
operator|(
name|c
operator|<
name|KEY_MAX
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current
condition|)
block|{
name|c
operator|=
name|edit_secure
argument_list|(
name|me
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|me
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|edit_secure
argument_list|(
name|me
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|me
argument_list|,
name|A_UNDERLINE
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_form_driver
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|1
operator|)
operator|&&
name|form_driver
argument_list|(
name|form
argument_list|,
name|REQ_VALIDATION
argument_list|)
operator|==
name|E_OK
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_VERSION
end_ifdef

begin_define
define|#
directive|define
name|FIELDCHECK_CB
parameter_list|(
name|func
parameter_list|)
value|bool func(FIELD * fld, const void * data GCC_UNUSED)
end_define

begin_define
define|#
directive|define
name|CHAR_CHECK_CB
parameter_list|(
name|func
parameter_list|)
value|bool func(int ch, const void *data GCC_UNUSED)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIELDCHECK_CB
parameter_list|(
name|func
parameter_list|)
value|int func(FIELD * fld, char * data GCC_UNUSED)
end_define

begin_define
define|#
directive|define
name|CHAR_CHECK_CB
parameter_list|(
name|func
parameter_list|)
value|int func(int ch, char *data GCC_UNUSED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow a middle initial, optionally with a '.' to end it.  */
end_comment

begin_expr_stmt
specifier|static
name|FIELDCHECK_CB
argument_list|(
argument|mi_field_check
argument_list|)
block|{
name|char
operator|*
name|s
operator|=
name|field_buffer
argument_list|(
name|fld
argument_list|,
literal|0
argument_list|)
block|;
name|int
name|state
operator|=
literal|0
block|;
name|int
name|n
block|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
index|[
name|n
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|n
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|s
index|[
name|n
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|state
operator|=
literal|2
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
name|s
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
block|}
end_elseif

begin_break
break|break;
end_break

begin_case
case|case
literal|2
case|:
end_case

begin_if
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|UChar
argument_list|(
name|s
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
end_if

begin_break
break|break;
end_break

begin_comment
unit|}     }
comment|/* force the form to display a leading capital */
end_comment

begin_if
if|if
condition|(
name|islower
argument_list|(
name|UChar
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
name|UChar
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|set_field_buffer
argument_list|(
name|fld
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|TRUE
return|;
end_return

begin_macro
unit|}  static
name|CHAR_CHECK_CB
argument_list|(
argument|mi_char_check
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'.'
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Passwords should be at least 6 characters.  */
end_comment

begin_expr_stmt
specifier|static
name|FIELDCHECK_CB
argument_list|(
argument|pw_field_check
argument_list|)
block|{
name|char
operator|*
name|s
operator|=
name|field_buffer
argument_list|(
name|fld
argument_list|,
literal|0
argument_list|)
block|;
name|int
name|n
block|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
index|[
name|n
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
name|s
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|6
condition|)
return|return
name|FALSE
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     return
name|TRUE
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  static
name|CHAR_CHECK_CB
argument_list|(
argument|pw_char_check
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|isgraph
argument_list|(
name|ch
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|demo_forms
parameter_list|(
name|void
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|FORM
modifier|*
name|form
decl_stmt|;
name|FIELD
modifier|*
name|f
index|[
literal|12
index|]
decl_stmt|,
modifier|*
name|secure
decl_stmt|;
name|FIELDTYPE
modifier|*
name|fty_middle
init|=
name|new_fieldtype
argument_list|(
name|mi_field_check
argument_list|,
name|mi_char_check
argument_list|)
decl_stmt|;
name|FIELDTYPE
modifier|*
name|fty_passwd
init|=
name|new_fieldtype
argument_list|(
name|pw_field_check
argument_list|,
name|pw_char_check
argument_list|)
decl_stmt|;
name|int
name|finished
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
name|unsigned
name|n
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|move
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Defined edit/traversal keys:   ^Q/ESC- exit form\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^N   -- go to next field       ^P  -- go to previous field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Home -- go to first field      End -- go to last field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^L   -- go to field to left    ^R  -- go to field to right\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^U   -- move upward to field   ^D  -- move downward to field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^W   -- go to next word        ^B  -- go to previous word\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^S   -- go to start of field   ^E  -- go to end of field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^H   -- delete previous char   ^Y  -- delete line\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^G   -- delete current word    ^C  -- clear to end of line\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^K   -- clear to end of field  ^X  -- clear field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Arrow keys move within a field as you would expect. ^] toggles overlay mode."
argument_list|)
expr_stmt|;
name|MvAddStr
argument_list|(
literal|4
argument_list|,
literal|57
argument_list|,
literal|"Forms Entry Test"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* describe the form */
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
literal|"Sample Form"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Last Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|18
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set_field_type
argument_list|(
name|f
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|TYPE_ALPHA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|20
argument_list|,
literal|"First Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|20
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set_field_type
argument_list|(
name|f
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|TYPE_ALPHA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|34
argument_list|,
literal|"Middle Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|34
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set_field_type
argument_list|(
name|f
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|fty_middle
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Comments"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|46
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|5
argument_list|,
literal|20
argument_list|,
literal|"Password:"
argument_list|)
expr_stmt|;
name|secure
operator|=
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|5
argument_list|,
literal|30
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|set_field_type
argument_list|(
name|f
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|fty_passwd
argument_list|)
expr_stmt|;
name|f
index|[
name|n
index|]
operator|=
operator|(
name|FIELD
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|=
name|new_form
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|display_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|w
operator|=
name|form_win
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
comment|/* lets us read ^M's */
while|while
condition|(
operator|!
name|finished
condition|)
block|{
switch|switch
condition|(
name|form_driver
argument_list|(
name|form
argument_list|,
name|c
operator|=
name|form_virtualize
argument_list|(
name|form
argument_list|,
name|w
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
name|MvAddStr
argument_list|(
literal|5
argument_list|,
literal|57
argument_list|,
name|field_buffer
argument_list|(
name|secure
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
name|E_UNKNOWN_COMMAND
case|:
name|finished
operator|=
name|my_form_driver
argument_list|(
name|form
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|erase_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|free_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|f
index|[
name|c
index|]
operator|!=
literal|0
condition|;
name|c
operator|++
control|)
name|free_field
argument_list|(
name|f
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free_fieldtype
argument_list|(
name|fty_middle
argument_list|)
expr_stmt|;
name|free_fieldtype
argument_list|(
name|fty_passwd
argument_list|)
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBFORM */
end_comment

begin_comment
comment|/****************************************************************************  *  * Overlap test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fillwin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
name|y
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
name|x
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
name|UChar
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|crosswin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|x
operator|>
operator|(
name|x1
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
operator|&&
operator|(
name|x
operator|<=
operator|(
literal|2
operator|*
operator|(
name|x1
operator|-
literal|1
operator|)
operator|)
operator|/
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|y
operator|>
operator|(
name|y1
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
operator|&&
operator|(
name|y
operator|<=
operator|(
literal|2
operator|*
operator|(
name|y1
operator|-
literal|1
operator|)
operator|)
operator|/
literal|3
operator|)
operator|)
operator|)
condition|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|UChar
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OVERLAP_FLAVORS
value|5
end_define

begin_function
specifier|static
name|void
name|overlap_helpitem
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|item
parameter_list|,
name|char
modifier|*
name|message
parameter_list|)
block|{
name|int
name|row
init|=
operator|(
name|item
operator|/
literal|2
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
operator|(
name|item
operator|%
literal|2
operator|)
condition|?
name|COLS
operator|/
literal|2
else|:
literal|0
operator|)
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|6
operator|+
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%c%c = %s"
argument_list|,
name|state
operator|==
name|row
condition|?
literal|'>'
else|:
literal|' '
argument_list|,
literal|'a'
operator|+
name|item
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_1_attr
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|flavor
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|short
name|cpair
init|=
call|(
name|short
call|)
argument_list|(
literal|1
operator|+
operator|(
name|flavor
operator|*
literal|2
operator|)
operator|+
name|col
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|0
case|:
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|init_pair
argument_list|(
name|cpair
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|cpair
argument_list|)
operator||
name|A_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|init_pair
argument_list|(
name|cpair
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|cpair
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_2_attr
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|flavor
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|short
name|cpair
init|=
call|(
name|short
call|)
argument_list|(
literal|9
operator|+
operator|(
name|flavor
operator|*
literal|2
operator|)
operator|+
name|col
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|0
case|:
comment|/* no effect */
break|break;
case|case
literal|1
case|:
comment|/* no effect */
break|break;
case|case
literal|2
case|:
name|init_pair
argument_list|(
name|cpair
argument_list|,
name|COLOR_RED
argument_list|,
name|COLOR_GREEN
argument_list|)
expr_stmt|;
name|wbkgdset
argument_list|(
name|win
argument_list|,
name|colored_chtype
argument_list|(
literal|' '
argument_list|,
name|A_BLINK
argument_list|,
name|cpair
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|wbkgdset
argument_list|(
name|win
argument_list|,
literal|' '
operator||
name|A_NORMAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|overlap_help
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|flavors
index|[
name|OVERLAP_FLAVORS
index|]
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|ths
decl_stmt|,
modifier|*
name|tht
decl_stmt|;
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
name|state
operator|+=
name|OVERLAP_FLAVORS
expr_stmt|;
name|state
operator|=
name|state
operator|%
name|OVERLAP_FLAVORS
expr_stmt|;
name|assert
argument_list|(
name|state
operator|>=
literal|0
operator|&&
name|state
operator|<
name|OVERLAP_FLAVORS
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
literal|0
init|;
name|item
operator|<
operator|(
literal|2
operator|*
name|OVERLAP_FLAVORS
operator|)
condition|;
operator|++
name|item
control|)
block|{
name|row
operator|=
name|item
operator|/
literal|2
expr_stmt|;
name|col
operator|=
name|item
operator|%
literal|2
expr_stmt|;
name|ths
operator|=
name|col
condition|?
literal|"B"
else|:
literal|"A"
expr_stmt|;
name|tht
operator|=
name|col
condition|?
literal|"A"
else|:
literal|"B"
expr_stmt|;
switch|switch
condition|(
name|row
condition|)
block|{
case|case
literal|0
case|:
name|flavors
index|[
name|row
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"refresh %s, then %s, then doupdate."
argument_list|,
name|ths
argument_list|,
name|tht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|use_colors
condition|)
block|{
name|flavors
index|[
name|row
index|]
operator|%=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|flavors
index|[
name|row
index|]
operator|%=
literal|2
expr_stmt|;
block|}
name|overlap_test_1_attr
argument_list|(
name|stdscr
argument_list|,
name|flavors
index|[
name|row
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"fill window %s with letter %s."
argument_list|,
name|ths
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|use_colors
condition|)
block|{
name|flavors
index|[
name|row
index|]
operator|%=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|flavors
index|[
name|row
index|]
operator|%=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|flavors
index|[
name|row
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"cross pattern in window %s."
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"draw box in window %s."
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"set background of window %s."
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"reset background of window %s."
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|3
case|:
name|flavors
index|[
name|row
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"clear window %s."
argument_list|,
name|ths
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|flavors
index|[
name|row
index|]
operator|%=
literal|4
expr_stmt|;
switch|switch
condition|(
name|flavors
index|[
name|row
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"overwrite %s onto %s."
argument_list|,
name|ths
argument_list|,
name|tht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"copywin(FALSE) %s onto %s."
argument_list|,
name|ths
argument_list|,
name|tht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"copywin(TRUE) %s onto %s."
argument_list|,
name|ths
argument_list|,
name|tht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"overlay %s onto %s."
argument_list|,
name|ths
argument_list|,
name|tht
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|overlap_helpitem
argument_list|(
name|state
argument_list|,
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|stdscr
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
name|wbkgdset
argument_list|(
name|stdscr
argument_list|,
literal|' '
operator||
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"^Q/ESC = terminate test.  Up/down/space select test variations (%d %d)."
argument_list|,
name|state
argument_list|,
name|flavors
index|[
name|state
index|]
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_0
parameter_list|(
name|WINDOW
modifier|*
name|a
parameter_list|,
name|WINDOW
modifier|*
name|b
parameter_list|)
block|{
name|touchwin
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_1
parameter_list|(
name|int
name|flavor
parameter_list|,
name|int
name|col
parameter_list|,
name|WINDOW
modifier|*
name|a
parameter_list|,
name|char
name|fill
parameter_list|)
block|{
name|overlap_test_1_attr
argument_list|(
name|a
argument_list|,
name|flavor
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|fillwin
argument_list|(
name|a
argument_list|,
name|fill
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|a
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_2
parameter_list|(
name|int
name|flavor
parameter_list|,
name|int
name|col
parameter_list|,
name|WINDOW
modifier|*
name|a
parameter_list|,
name|char
name|fill
parameter_list|)
block|{
name|overlap_test_2_attr
argument_list|(
name|a
argument_list|,
name|flavor
argument_list|,
name|col
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|0
case|:
name|crosswin
argument_list|(
name|a
argument_list|,
name|fill
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|box
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* done in overlap_test_2_attr */
break|break;
case|case
literal|3
case|:
comment|/* done in overlap_test_2_attr */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_3
parameter_list|(
name|WINDOW
modifier|*
name|a
parameter_list|)
block|{
name|wclear
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test_4
parameter_list|(
name|int
name|flavor
parameter_list|,
name|WINDOW
modifier|*
name|a
parameter_list|,
name|WINDOW
modifier|*
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|0
case|:
name|overwrite
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|copywin
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getmaxy
argument_list|(
name|b
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|b
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|copywin
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|getmaxy
argument_list|(
name|b
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|b
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|overlay
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* test effects of overlapping windows */
end_comment

begin_function
specifier|static
name|void
name|overlap_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|state
decl_stmt|,
name|flavor
index|[
name|OVERLAP_FLAVORS
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|win1
init|=
name|newwin
argument_list|(
literal|9
argument_list|,
literal|20
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|win2
init|=
name|newwin
argument_list|(
literal|9
argument_list|,
literal|20
argument_list|,
literal|9
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|curs_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This test shows the behavior of wnoutrefresh() with respect to\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"the shared region of two overlapping windows A and B.  The cross\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"pattern in each window does not overlap the other.\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|flavor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flavor
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|overlap_help
argument_list|(
literal|0
argument_list|,
name|flavor
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|isQuit
argument_list|(
name|ch
operator|=
name|Getchar
argument_list|()
argument_list|)
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* refresh window A first, then B */
name|overlap_test_0
argument_list|(
name|win1
argument_list|,
name|win2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* refresh window B first, then A */
name|overlap_test_0
argument_list|(
name|win2
argument_list|,
name|win1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* fill window A so it's visible */
name|overlap_test_1
argument_list|(
name|flavor
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|win1
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* fill window B so it's visible */
name|overlap_test_1
argument_list|(
name|flavor
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|win2
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* cross test pattern in window A */
name|overlap_test_2
argument_list|(
name|flavor
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|win1
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* cross test pattern in window A */
name|overlap_test_2
argument_list|(
name|flavor
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|,
name|win2
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* clear window A */
name|overlap_test_3
argument_list|(
name|win1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* clear window B */
name|overlap_test_3
argument_list|(
name|win2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* overwrite A onto B */
name|overlap_test_4
argument_list|(
name|flavor
index|[
literal|4
index|]
argument_list|,
name|win1
argument_list|,
name|win2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* overwrite B onto A */
name|overlap_test_4
argument_list|(
name|flavor
index|[
literal|4
index|]
argument_list|,
name|win2
argument_list|,
name|win1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|KEY_DOWN
case|:
name|state
operator|=
name|overlap_help
argument_list|(
name|state
operator|+
literal|1
argument_list|,
name|flavor
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|KEY_UP
case|:
name|state
operator|=
name|overlap_help
argument_list|(
name|state
operator|-
literal|1
argument_list|,
name|flavor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flavor
index|[
name|state
index|]
operator|+=
literal|1
expr_stmt|;
name|state
operator|=
name|overlap_help
argument_list|(
name|state
argument_list|,
name|flavor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|state
operator|=
name|overlap_help
argument_list|(
name|state
argument_list|,
name|flavor
argument_list|)
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|delwin
argument_list|(
name|win2
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|curs_set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Main sequence  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|do_single_test
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
comment|/* perform a single specified test */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|getch_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_WIDEC_SUPPORT
case|case
literal|'A'
case|:
name|get_wch_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'b'
case|:
name|attr_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_WIDEC_SUPPORT
case|case
literal|'B'
case|:
name|wide_attr_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|use_colors
condition|)
name|Cannot
argument_list|(
literal|"does not support color."
argument_list|)
expr_stmt|;
else|else
name|color_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_WIDEC_SUPPORT
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|use_colors
condition|)
name|Cannot
argument_list|(
literal|"does not support color."
argument_list|)
expr_stmt|;
else|else
name|wide_color_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|use_colors
condition|)
name|Cannot
argument_list|(
literal|"does not support color."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_change_color
argument_list|()
condition|)
name|Cannot
argument_list|(
literal|"has hardwired color values."
argument_list|)
expr_stmt|;
else|else
name|color_edit
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_SOFTKEYS
case|case
literal|'e'
case|:
name|slk_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_WIDEC_SUPPORT
case|case
literal|'E'
case|:
name|wide_slk_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
literal|'f'
case|:
name|acs_display
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_WIDEC_SUPPORT
case|case
literal|'F'
case|:
name|wide_acs_display
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBPANEL
case|case
literal|'o'
case|:
name|demo_panels
argument_list|(
name|init_panel
argument_list|,
name|fill_panel
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|&&
name|USE_LIBPANEL
case|case
literal|'O'
case|:
name|demo_panels
argument_list|(
name|init_wide_panel
argument_list|,
name|fill_wide_panel
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
name|acs_and_scroll
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flushinp_test
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|test_sgr_attributes
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBMENU
case|case
literal|'m'
case|:
name|menu_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
name|demo_pad
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBFORM
case|case
literal|'r'
case|:
name|demo_forms
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|overlap_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBMENU
operator|&&
name|defined
argument_list|(
name|TRACE
argument_list|)
case|case
literal|'t'
case|:
name|trace_set
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'?'
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[]
init|=
block|{
literal|"Usage: ncurses [options]"
block|,
literal|""
block|,
literal|"Options:"
ifdef|#
directive|ifdef
name|NCURSES_VERSION
block|,
literal|"  -a f,b   set default-colors (assumed white-on-black)"
block|,
literal|"  -d       use default-colors if terminal supports them"
endif|#
directive|endif
if|#
directive|if
name|USE_SOFTKEYS
block|,
literal|"  -e fmt   specify format for soft-keys test (e)"
endif|#
directive|endif
if|#
directive|if
name|HAVE_RIPOFFLINE
block|,
literal|"  -f       rip-off footer line (can repeat)"
block|,
literal|"  -h       rip-off header line (can repeat)"
endif|#
directive|endif
block|,
literal|"  -m       do not use colors"
block|,
literal|"  -p file  rgb values to use in 'd' rather than ncurses's builtin"
if|#
directive|if
name|USE_LIBPANEL
block|,
literal|"  -s msec  specify nominal time for panel-demo (default: 1, to hold)"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
block|,
literal|"  -t mask  specify default trace-level (may toggle with ^T)"
endif|#
directive|endif
block|}
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|tbl
argument_list|)
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|tbl
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_terminal_modes
parameter_list|(
name|void
parameter_list|)
block|{
name|noraw
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|idlok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_function
specifier|static
name|RETSIGTYPE
name|announce_sig
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Handled signal %d\r\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_RIPOFFLINE
end_if

begin_function
specifier|static
name|int
name|rip_footer
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"footer: window %p, %d columns"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|win
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rip_header
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"header: window %p, %d columns"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|win
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RIPOFFLINE */
end_comment

begin_function
specifier|static
name|void
name|main_menu
parameter_list|(
name|bool
name|top
parameter_list|)
block|{
name|char
name|command
decl_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses main menu"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"a = keyboard and mouse input test"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"A = wide-character keyboard and mouse input test"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"b = character attribute test"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"B = wide-character attribute test"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"c = color test pattern"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"C = color test pattern using wide-character calls"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|top
condition|)
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"d = edit RGB color values"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_SOFTKEYS
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"e = exercise soft keys"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"E = exercise soft keys using wide-characters"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"f = display ACS characters"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"F = display Wide-ACS characters"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"g = display windows and scrolling"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"i = test of flushinp()"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"k = display character attributes"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LIBMENU
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"m = menu code test"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBPANEL
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"o = exercise panels library"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"O = exercise panels with wide-characters"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"p = exercise pad features"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"q = quit"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LIBFORM
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"r = exercise forms code"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"s = overlapping-refresh test"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LIBMENU
operator|&&
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"t = set trace level"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"? = repeat this command summary"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* necessary under SVr4 curses */
comment|/* 	 * This used to be an 'fgets()' call (until 1996/10).  However with 	 * some runtime libraries, mixing stream I/O and 'read()' causes the 	 * input stream to be flushed when switching between the two. 	 */
name|command
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
literal|'\0'
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|command
operator|==
literal|0
condition|)
name|command
operator|=
literal|'q'
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
name|UChar
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|)
block|{
name|command
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|(
name|command
operator|==
literal|'d'
operator|)
operator|&&
operator|!
name|top
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Do not nest test-d\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|command
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|command
operator|!=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_single_test
argument_list|(
name|command
argument_list|)
condition|)
block|{
comment|/* 	     * This may be overkill; it's intended to reset everything back 	     * to the initial terminal modes so that tests don't get in 	     * each other's way. 	     */
name|flushinp
argument_list|()
expr_stmt|;
name|set_terminal_modes
argument_list|()
expr_stmt|;
name|reset_prog_mode
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
if|if
condition|(
name|command
operator|==
literal|'?'
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses capability tester."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"You may select a test from the main menu by typing the"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"key letter of the choice (the letter to left of the =)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"at the> prompt.  Type `q' to exit."
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
do|while
condition|(
name|command
operator|!=
literal|'q'
condition|)
do|;
block|}
end_function

begin_comment
comment|/*+------------------------------------------------------------------------- 	main(argc,argv) --------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|okCOLOR
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0&& (n)< max_colors)
end_define

begin_define
define|#
directive|define
name|okRGB
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0&& (n)<= 1000)
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|my_e_param
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
name|int
name|default_fg
init|=
name|COLOR_WHITE
decl_stmt|;
name|int
name|default_bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|bool
name|assumed_colors
init|=
name|FALSE
decl_stmt|;
name|bool
name|default_colors
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|palette_file
init|=
literal|0
decl_stmt|;
name|bool
name|monochrome
init|=
name|FALSE
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:de:fhmp:s:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|NCURSES_VERSION
case|case
literal|'a'
case|:
name|assumed_colors
operator|=
name|TRUE
expr_stmt|;
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d,%d"
argument_list|,
operator|&
name|default_fg
argument_list|,
operator|&
name|default_bg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|default_colors
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
name|my_e_param
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
if|if
condition|(
name|my_e_param
operator|>
literal|3
condition|)
comment|/* allow extended layouts */
name|usage
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|my_e_param
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
if|#
directive|if
name|HAVE_RIPOFFLINE
case|case
literal|'f'
case|:
name|ripoffline
argument_list|(
operator|-
literal|1
argument_list|,
name|rip_footer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|ripoffline
argument_list|(
literal|1
argument_list|,
name|rip_header
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_RIPOFFLINE */
case|case
literal|'m'
case|:
name|monochrome
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|palette_file
operator|=
name|optarg
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBPANEL
case|case
literal|'s'
case|:
name|nap_msec
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
case|case
literal|'t'
case|:
name|save_trace
operator|=
operator|(
name|unsigned
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      * If there's no menus (unlikely for ncurses!), then we'll have to set      * tracing on initially, just in case the user wants to test something that      * doesn't involve wGetchar.      */
ifdef|#
directive|ifdef
name|TRACE
comment|/* enable debugging */
if|#
directive|if
operator|!
name|USE_LIBMENU
name|trace
argument_list|(
name|save_trace
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|trace
argument_list|(
name|save_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LIBMENU */
endif|#
directive|endif
comment|/* TRACE */
if|#
directive|if
name|USE_SOFTKEYS
comment|/* tell it we're going to play with soft keys */
name|slk_init
argument_list|(
name|my_e_param
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* set up null signal catcher so we can see what interrupts to getch do */
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|announce_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* we must initialize the curses data structure only once */
name|initscr
argument_list|()
expr_stmt|;
name|bkgdset
argument_list|(
name|BLANK
argument_list|)
expr_stmt|;
comment|/* tests, in general, will want these modes */
name|use_colors
operator|=
name|monochrome
condition|?
name|FALSE
else|:
name|has_colors
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_colors
condition|)
block|{
name|start_color
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION_PATCH
name|max_colors
operator|=
name|COLORS
expr_stmt|;
comment|/* was> 16 ? 16 : COLORS */
if|#
directive|if
name|HAVE_USE_DEFAULT_COLORS
if|if
condition|(
name|default_colors
condition|)
block|{
name|use_default_colors
argument_list|()
expr_stmt|;
name|min_colors
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|NCURSES_VERSION_PATCH
operator|>=
literal|20000708
if|if
condition|(
name|assumed_colors
condition|)
name|assume_default_colors
argument_list|(
name|default_fg
argument_list|,
name|default_bg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
comment|/* normal SVr4 curses */
name|max_colors
operator|=
name|COLORS
expr_stmt|;
comment|/* was> 8 ? 8 : COLORS */
endif|#
directive|endif
name|max_pairs
operator|=
name|COLOR_PAIRS
expr_stmt|;
comment|/* was> 256 ? 256 : COLOR_PAIRS */
if|if
condition|(
name|can_change_color
argument_list|()
condition|)
block|{
name|short
name|cp
decl_stmt|;
name|all_colors
operator|=
name|typeMalloc
argument_list|(
name|RGB_DATA
argument_list|,
operator|(
name|unsigned
operator|)
name|max_colors
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
literal|0
init|;
name|cp
operator|<
name|max_colors
condition|;
operator|++
name|cp
control|)
block|{
name|color_content
argument_list|(
name|cp
argument_list|,
operator|&
name|all_colors
index|[
name|cp
index|]
operator|.
name|red
argument_list|,
operator|&
name|all_colors
index|[
name|cp
index|]
operator|.
name|green
argument_list|,
operator|&
name|all_colors
index|[
name|cp
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|palette_file
operator|!=
literal|0
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|palette_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|int
name|scale
init|=
literal|1000
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"scale:%d"
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|1
condition|)
block|{
name|scale
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%d:%d %d %d"
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
operator|==
literal|4
operator|&&
name|okCOLOR
argument_list|(
name|c
argument_list|)
operator|&&
name|okRGB
argument_list|(
name|red
argument_list|)
operator|&&
name|okRGB
argument_list|(
name|green
argument_list|)
operator|&&
name|okRGB
argument_list|(
name|blue
argument_list|)
condition|)
block|{
name|all_colors
index|[
name|c
index|]
operator|.
name|red
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|red
operator|*
literal|1000
operator|)
operator|/
name|scale
argument_list|)
expr_stmt|;
name|all_colors
index|[
name|c
index|]
operator|.
name|green
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|green
operator|*
literal|1000
operator|)
operator|/
name|scale
argument_list|)
expr_stmt|;
name|all_colors
index|[
name|c
index|]
operator|.
name|blue
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|blue
operator|*
literal|1000
operator|)
operator|/
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|set_terminal_modes
argument_list|()
expr_stmt|;
name|def_prog_mode
argument_list|()
expr_stmt|;
comment|/*      * Return to terminal mode, so we're guaranteed of being able to      * select terminal commands even if the capabilities are wrong.      */
name|endwin
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_CURSES_VERSION
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Welcome to %s.  Press ? for help.\n"
argument_list|,
name|curses_version
argument_list|()
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|NCURSES_VERSION_MAJOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCURSES_VERSION_MINOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCURSES_VERSION_PATCH
argument_list|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Welcome to ncurses %d.%d.%d.  Press ? for help.\n"
argument_list|,
name|NCURSES_VERSION_MAJOR
argument_list|,
name|NCURSES_VERSION_MINOR
argument_list|,
name|NCURSES_VERSION_PATCH
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Welcome to ncurses.  Press ? for help."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|main_menu
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ncurses.c ends here */
end_comment

end_unit

