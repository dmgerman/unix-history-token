begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1999-2012,2013 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Author: Thomas E. Dickey  *  * $Id: cardfile.c,v 1.42 2013/09/28 22:02:17 tom Exp $  *  * File format: text beginning in column 1 is a title; other text is content.  */
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_if
if|#
directive|if
name|USE_LIBFORM
operator|&&
name|USE_LIBPANEL
end_if

begin_include
include|#
directive|include
file|<form.h>
end_include

begin_include
include|#
directive|include
file|<panel.h>
end_include

begin_define
define|#
directive|define
name|VISIBLE_CARDS
value|10
end_define

begin_define
define|#
directive|define
name|OFFSET_CARD
value|2
end_define

begin_define
define|#
directive|define
name|pair_1
value|1
end_define

begin_define
define|#
directive|define
name|pair_2
value|2
end_define

begin_define
define|#
directive|define
name|isVisible
parameter_list|(
name|cardp
parameter_list|)
value|((cardp)->panel != 0)
end_define

begin_enum
enum|enum
block|{
name|MY_CTRL_x
init|=
name|MAX_FORM_COMMAND
block|,
name|MY_CTRL_N
block|,
name|MY_CTRL_P
block|,
name|MY_CTRL_Q
block|,
name|MY_CTRL_W
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|_card
block|{
name|struct
name|_card
modifier|*
name|link
decl_stmt|;
name|PANEL
modifier|*
name|panel
decl_stmt|;
name|FORM
modifier|*
name|form
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|content
decl_stmt|;
block|}
name|CARD
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CARD
modifier|*
name|all_cards
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|try_color
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_name
index|[]
init|=
literal|"cardfile.dat"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|failed
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
name|buffer
operator|++
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trim
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
name|isspace
argument_list|(
name|UChar
argument_list|(
name|buffer
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
name|buffer
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|add_title
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|)
block|{
name|CARD
modifier|*
name|card
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
operator|,
name|q
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|p
operator|->
name|title
argument_list|,
name|title
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
break|break;
block|}
name|card
operator|=
name|typeCalloc
argument_list|(
name|CARD
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|card
operator|->
name|title
operator|=
name|strdup
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|card
operator|->
name|content
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|card
operator|->
name|link
operator|=
name|all_cards
expr_stmt|;
name|all_cards
operator|=
name|card
expr_stmt|;
block|}
else|else
block|{
name|card
operator|->
name|link
operator|=
name|q
operator|->
name|link
expr_stmt|;
name|q
operator|->
name|link
operator|=
name|card
expr_stmt|;
block|}
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_content
parameter_list|(
name|CARD
modifier|*
name|card
parameter_list|,
specifier|const
name|char
modifier|*
name|content
parameter_list|)
block|{
name|size_t
name|total
decl_stmt|,
name|offset
decl_stmt|;
name|content
operator|=
name|skip
argument_list|(
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|total
operator|=
name|strlen
argument_list|(
name|content
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|card
operator|->
name|content
operator|!=
literal|0
operator|&&
operator|(
name|offset
operator|=
name|strlen
argument_list|(
name|card
operator|->
name|content
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
literal|1
operator|+
name|offset
expr_stmt|;
name|card
operator|->
name|content
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|total
operator|+
literal|1
argument_list|,
name|card
operator|->
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
name|card
operator|->
name|content
condition|)
name|strcpy
argument_list|(
name|card
operator|->
name|content
operator|+
name|offset
operator|++
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|card
operator|->
name|content
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|card
operator|->
name|content
argument_list|)
expr_stmt|;
name|card
operator|->
name|content
operator|=
name|typeMalloc
argument_list|(
name|char
argument_list|,
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|card
operator|->
name|content
condition|)
name|strcpy
argument_list|(
name|card
operator|->
name|content
operator|+
name|offset
argument_list|,
name|content
argument_list|)
expr_stmt|;
else|else
name|failed
argument_list|(
literal|"add_content"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|CARD
modifier|*
name|new_card
parameter_list|(
name|void
parameter_list|)
block|{
name|CARD
modifier|*
name|card
init|=
name|add_title
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|add_content
argument_list|(
name|card
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|CARD
modifier|*
name|find_card
parameter_list|(
name|char
modifier|*
name|title
parameter_list|)
block|{
name|CARD
modifier|*
name|card
decl_stmt|;
for|for
control|(
name|card
operator|=
name|all_cards
init|;
name|card
operator|!=
literal|0
condition|;
name|card
operator|=
name|card
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|card
operator|->
name|title
argument_list|,
name|title
argument_list|)
condition|)
break|break;
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_data
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|CARD
modifier|*
name|card
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|trim
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|card
operator|==
literal|0
condition|)
name|card
operator|=
name|add_title
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|add_content
argument_list|(
name|card
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|card
operator|=
name|find_card
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|card
operator|=
name|add_title
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|write_data
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|CARD
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|default_name
argument_list|)
condition|)
name|fname
operator|=
literal|"cardfile.out"
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|FIELD
modifier|*
modifier|*
name|f
init|=
name|form_fields
argument_list|(
name|p
operator|->
name|form
argument_list|)
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|f
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
name|s
init|=
name|field_buffer
argument_list|(
name|f
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|trim
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|n
condition|?
literal|"\t"
else|:
literal|""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*  * Count the cards  */
end_comment

begin_function
specifier|static
name|int
name|count_cards
parameter_list|(
name|void
parameter_list|)
block|{
name|CARD
modifier|*
name|p
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Shuffle the panels to keep them in a natural hierarchy.  */
end_comment

begin_function
specifier|static
name|void
name|order_cards
parameter_list|(
name|CARD
modifier|*
name|first
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|depth
operator|&&
name|first
operator|->
name|link
condition|)
name|order_cards
argument_list|(
name|first
operator|->
name|link
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|(
name|first
argument_list|)
condition|)
name|top_panel
argument_list|(
name|first
operator|->
name|panel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next card in the list  */
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|next_card
parameter_list|(
name|CARD
modifier|*
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
operator|->
name|link
operator|!=
literal|0
condition|)
block|{
name|CARD
modifier|*
name|tst
init|=
name|now
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|isVisible
argument_list|(
name|tst
argument_list|)
condition|)
name|now
operator|=
name|tst
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|next_card
argument_list|(
name|tst
argument_list|)
expr_stmt|;
block|}
return|return
name|now
return|;
block|}
end_function

begin_comment
comment|/*  * Return the previous card in the list  */
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|prev_card
parameter_list|(
name|CARD
modifier|*
name|now
parameter_list|)
block|{
name|CARD
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|link
operator|==
name|now
condition|)
block|{
if|if
condition|(
operator|!
name|isVisible
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|prev_card
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
return|return
name|now
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the first card in the list that we will display.  */
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|first_card
parameter_list|(
name|CARD
modifier|*
name|now
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isVisible
argument_list|(
name|now
argument_list|)
condition|)
name|now
operator|=
name|next_card
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
name|now
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|form_virtualize
parameter_list|(
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
name|int
name|c
init|=
name|wgetch
argument_list|(
name|w
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
return|return
operator|(
name|MY_CTRL_W
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'N'
argument_list|)
case|:
return|return
operator|(
name|MY_CTRL_N
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'P'
argument_list|)
case|:
return|return
operator|(
name|MY_CTRL_P
operator|)
return|;
case|case
name|QUIT
case|:
case|case
name|ESCAPE
case|:
return|return
operator|(
name|MY_CTRL_Q
operator|)
return|;
case|case
name|KEY_BACKSPACE
case|:
return|return
operator|(
name|REQ_DEL_PREV
operator|)
return|;
case|case
name|KEY_DC
case|:
return|return
operator|(
name|REQ_DEL_CHAR
operator|)
return|;
case|case
name|KEY_LEFT
case|:
return|return
operator|(
name|REQ_LEFT_CHAR
operator|)
return|;
case|case
name|KEY_RIGHT
case|:
return|return
operator|(
name|REQ_RIGHT_CHAR
operator|)
return|;
case|case
name|KEY_DOWN
case|:
case|case
name|KEY_NEXT
case|:
return|return
operator|(
name|REQ_NEXT_FIELD
operator|)
return|;
case|case
name|KEY_UP
case|:
case|case
name|KEY_PREVIOUS
case|:
return|return
operator|(
name|REQ_PREV_FIELD
operator|)
return|;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|FIELD
modifier|*
modifier|*
name|make_fields
parameter_list|(
name|CARD
modifier|*
name|p
parameter_list|,
name|int
name|form_high
parameter_list|,
name|int
name|form_wide
parameter_list|)
block|{
name|FIELD
modifier|*
modifier|*
name|f
init|=
name|typeCalloc
argument_list|(
name|FIELD
operator|*
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
decl_stmt|;
name|f
index|[
literal|0
index|]
operator|=
name|new_field
argument_list|(
literal|1
argument_list|,
name|form_wide
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|set_field_buffer
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|title
argument_list|)
expr_stmt|;
name|field_opts_off
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|,
name|O_BLANK
argument_list|)
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
name|new_field
argument_list|(
name|form_high
operator|-
literal|1
argument_list|,
name|form_wide
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_field_buffer
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|content
argument_list|)
expr_stmt|;
name|set_field_just
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|,
name|JUSTIFY_LEFT
argument_list|)
expr_stmt|;
name|field_opts_off
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|,
name|O_BLANK
argument_list|)
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_legend
parameter_list|(
name|void
parameter_list|)
block|{
name|erase
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^Q/ESC -- exit form            ^W   -- writes data to file\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^N   -- go to next card        ^P   -- go to previous card\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Arrow keys move left/right within a field, up/down between fields"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
operator|)
operator|||
name|NO_LEAKS
end_if

begin_function
specifier|static
name|void
name|free_form_fields
parameter_list|(
name|FIELD
modifier|*
modifier|*
name|f
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|f
index|[
name|n
index|]
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
block|{
name|free_field
argument_list|(
name|f
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|cardfile
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|CARD
modifier|*
name|p
decl_stmt|;
name|CARD
modifier|*
name|top_card
decl_stmt|;
name|int
name|visible_cards
decl_stmt|;
name|int
name|panel_wide
decl_stmt|;
name|int
name|panel_high
decl_stmt|;
name|int
name|form_wide
decl_stmt|;
name|int
name|form_high
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|ch
init|=
name|ERR
decl_stmt|;
name|int
name|finished
init|=
name|FALSE
decl_stmt|;
name|show_legend
argument_list|()
expr_stmt|;
comment|/* decide how many cards we can display */
name|visible_cards
operator|=
name|count_cards
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|panel_wide
operator|=
name|COLS
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
operator|)
operator|<
literal|10
operator|||
operator|(
name|panel_high
operator|=
name|LINES
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
operator|-
literal|5
operator|)
operator|<
literal|5
condition|)
block|{
operator|--
name|visible_cards
expr_stmt|;
block|}
name|form_wide
operator|=
name|panel_wide
operator|-
literal|2
expr_stmt|;
name|form_high
operator|=
name|panel_high
operator|-
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|visible_cards
operator|-
literal|1
operator|)
operator|*
name|OFFSET_CARD
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* make a panel for each CARD */
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|(
name|win
operator|=
name|newwin
argument_list|(
name|panel_high
argument_list|,
name|panel_wide
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|wbkgd
argument_list|(
name|win
argument_list|,
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair_2
argument_list|)
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|->
name|panel
operator|=
name|new_panel
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|form
operator|=
name|new_form
argument_list|(
name|make_fields
argument_list|(
name|p
argument_list|,
name|form_high
argument_list|,
name|form_wide
argument_list|)
argument_list|)
expr_stmt|;
name|set_form_win
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|set_form_sub
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|derwin
argument_list|(
name|win
argument_list|,
name|form_high
argument_list|,
name|form_wide
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|y
operator|-=
name|OFFSET_CARD
expr_stmt|;
name|x
operator|+=
name|OFFSET_CARD
expr_stmt|;
block|}
name|top_card
operator|=
name|first_card
argument_list|(
name|all_cards
argument_list|)
expr_stmt|;
name|order_cards
argument_list|(
name|top_card
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|finished
condition|)
block|{
name|update_panels
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
name|ch
operator|=
name|form_virtualize
argument_list|(
name|panel_window
argument_list|(
name|top_card
operator|->
name|panel
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form_driver
argument_list|(
name|top_card
operator|->
name|form
argument_list|,
name|ch
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
break|break;
case|case
name|E_UNKNOWN_COMMAND
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|MY_CTRL_Q
case|:
name|finished
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MY_CTRL_P
case|:
name|top_card
operator|=
name|prev_card
argument_list|(
name|top_card
argument_list|)
expr_stmt|;
name|order_cards
argument_list|(
name|top_card
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
break|break;
case|case
name|MY_CTRL_N
case|:
name|top_card
operator|=
name|next_card
argument_list|(
name|top_card
argument_list|)
expr_stmt|;
name|order_cards
argument_list|(
name|top_card
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
break|break;
case|case
name|MY_CTRL_W
case|:
name|form_driver
argument_list|(
name|top_card
operator|->
name|form
argument_list|,
name|REQ_VALIDATION
argument_list|)
expr_stmt|;
name|write_data
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|KEY_RESIZE
argument_list|)
operator|&&
name|HAVE_WRESIZE
case|case
name|KEY_RESIZE
case|:
comment|/* resizeterm already did "something" reasonable, but it cannot 		 * know much about layout.  So let's make it nicer. 		 */
name|panel_wide
operator|=
name|COLS
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
expr_stmt|;
name|panel_high
operator|=
name|LINES
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
operator|-
literal|5
expr_stmt|;
name|form_wide
operator|=
name|panel_wide
operator|-
literal|2
expr_stmt|;
name|form_high
operator|=
name|panel_high
operator|-
literal|2
expr_stmt|;
name|y
operator|=
operator|(
name|visible_cards
operator|-
literal|1
operator|)
operator|*
name|OFFSET_CARD
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|show_legend
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|FIELD
modifier|*
modifier|*
name|oldf
init|=
name|form_fields
argument_list|(
name|p
operator|->
name|form
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|olds
init|=
name|form_sub
argument_list|(
name|p
operator|->
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isVisible
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|win
operator|=
name|form_win
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
comment|/* move and resize the card as needed 		     * FIXME: if the windows are shrunk too much, this won't do 		     */
name|mvwin
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|wresize
argument_list|(
name|win
argument_list|,
name|panel_high
argument_list|,
name|panel_wide
argument_list|)
expr_stmt|;
comment|/* reconstruct each form.  Forms are not resizable, and 		     * there appears to be no good way to reload the text in 		     * a resized window. 		     */
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|unpost_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|free_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|p
operator|->
name|form
operator|=
name|new_form
argument_list|(
name|make_fields
argument_list|(
name|p
argument_list|,
name|form_high
argument_list|,
name|form_wide
argument_list|)
argument_list|)
expr_stmt|;
name|set_form_win
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|set_form_sub
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|derwin
argument_list|(
name|win
argument_list|,
name|form_high
argument_list|,
name|form_wide
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|free_form_fields
argument_list|(
name|oldf
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|olds
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|-=
name|OFFSET_CARD
expr_stmt|;
name|x
operator|+=
name|OFFSET_CARD
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|flash
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|NO_LEAKS
while|while
condition|(
name|all_cards
operator|!=
literal|0
condition|)
block|{
name|FIELD
modifier|*
modifier|*
name|f
decl_stmt|;
name|p
operator|=
name|all_cards
expr_stmt|;
name|all_cards
operator|=
name|all_cards
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|f
operator|=
name|form_fields
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|unpost_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
comment|/* ...so we can free it */
name|free_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
comment|/* this also disconnects the fields */
name|free_form_fields
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|del_panel
argument_list|(
name|p
operator|->
name|panel
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|content
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|msg
index|[]
init|=
block|{
literal|"Usage: view [options] file"
block|,
literal|""
block|,
literal|"Options:"
block|,
literal|" -c       use color if terminal supports it"
block|}
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|msg
argument_list|)
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'c'
case|:
name|try_color
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
name|try_color
condition|)
block|{
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|start_color
argument_list|()
expr_stmt|;
name|init_pair
argument_list|(
name|pair_1
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|pair_2
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_CYAN
argument_list|)
expr_stmt|;
name|bkgd
argument_list|(
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|try_color
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
name|read_data
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_cards
argument_list|()
operator|==
literal|0
condition|)
name|new_card
argument_list|()
expr_stmt|;
name|cardfile
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_data
argument_list|(
name|default_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_cards
argument_list|()
operator|==
literal|0
condition|)
name|new_card
argument_list|()
expr_stmt|;
name|cardfile
argument_list|(
name|default_name
argument_list|)
expr_stmt|;
block|}
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"This program requires the curses form and panel libraries\n"
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

