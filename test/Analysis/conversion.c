begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_analyze_cc1 -Wno-conversion -analyzer-checker=core,alpha.core.Conversion -verify %s
end_comment

begin_decl_stmt
name|unsigned
name|char
name|U8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|signed
name|char
name|S8
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|assign
parameter_list|(
name|unsigned
name|U
parameter_list|,
name|signed
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|<
operator|-
literal|10
condition|)
name|U8
operator|=
name|S
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
if|if
condition|(
name|U
operator|>
literal|300
condition|)
name|S8
operator|=
name|U
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
if|if
condition|(
name|S
operator|>
literal|10
condition|)
name|U8
operator|=
name|S
expr_stmt|;
comment|// no-warning
if|if
condition|(
name|U
operator|<
literal|200
condition|)
name|S8
operator|=
name|U
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|addAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|100
decl_stmt|;
name|U8
operator|+=
name|L
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
name|L
operator|+=
name|I
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|subAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|100
decl_stmt|;
name|U8
operator|-=
name|L
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
name|L
operator|-=
name|I
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|mulAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator|*=
name|L
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
name|L
operator|*=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
name|I
operator|=
literal|10
expr_stmt|;
name|L
operator|*=
name|I
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|divAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator|/=
name|L
expr_stmt|;
comment|// no-warning
name|L
operator|/=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
end_function

begin_function
name|void
name|remAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator|%=
name|L
expr_stmt|;
comment|// no-warning
name|L
operator|%=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
end_function

begin_function
name|void
name|andAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator|&=
name|L
expr_stmt|;
comment|// no-warning
name|L
operator|&=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
end_function

begin_function
name|void
name|orAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator||=
name|L
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
name|L
operator||=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
end_function

begin_function
name|void
name|xorAssign
parameter_list|()
block|{
name|unsigned
name|long
name|L
init|=
literal|1000
decl_stmt|;
name|int
name|I
init|=
operator|-
literal|1
decl_stmt|;
name|U8
operator|^=
name|L
expr_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
name|L
operator|^=
name|I
expr_stmt|;
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
end_function

begin_function
name|void
name|init1
parameter_list|()
block|{
name|long
name|long
name|A
init|=
literal|1LL
operator|<<
literal|60
decl_stmt|;
name|short
name|X
init|=
name|A
decl_stmt|;
comment|// expected-warning {{Loss of precision in implicit conversion}}
block|}
end_function

begin_function
name|void
name|relational
parameter_list|(
name|unsigned
name|U
parameter_list|,
name|signed
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|U
operator|<
name|S
condition|)
block|{
comment|// no-warning
block|}
block|}
if|if
condition|(
name|S
operator|<
operator|-
literal|10
condition|)
block|{
if|if
condition|(
name|U
operator|<
name|S
condition|)
block|{
comment|// expected-warning {{Loss of sign in implicit conversion}}
block|}
block|}
block|}
end_function

begin_function
name|void
name|multiplication
parameter_list|(
name|unsigned
name|U
parameter_list|,
name|signed
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|>
literal|5
condition|)
name|S
operator|=
name|U
operator|*
name|S
expr_stmt|;
comment|// no-warning
if|if
condition|(
name|S
operator|<
operator|-
literal|10
condition|)
name|S
operator|=
name|U
operator|*
name|S
expr_stmt|;
comment|// expected-warning {{Loss of sign}}
block|}
end_function

begin_function
name|void
name|division
parameter_list|(
name|unsigned
name|U
parameter_list|,
name|signed
name|S
parameter_list|)
block|{
if|if
condition|(
name|S
operator|>
literal|5
condition|)
name|S
operator|=
name|U
operator|/
name|S
expr_stmt|;
comment|// no-warning
if|if
condition|(
name|S
operator|<
operator|-
literal|10
condition|)
name|S
operator|=
name|U
operator|/
name|S
expr_stmt|;
comment|// expected-warning {{Loss of sign}}
block|}
end_function

begin_function
name|void
name|dontwarn1
parameter_list|(
name|unsigned
name|U
parameter_list|,
name|signed
name|S
parameter_list|)
block|{
name|U8
operator|=
name|S
expr_stmt|;
comment|// It might be known that S is always 0x00-0xff.
name|S8
operator|=
name|U
expr_stmt|;
comment|// It might be known that U is always 0x00-0xff.
name|U8
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Explicit conversion.
name|S8
operator|=
operator|~
literal|0U
expr_stmt|;
comment|// Explicit conversion.
if|if
condition|(
name|U
operator|>
literal|300
condition|)
name|U8
operator|&=
name|U
expr_stmt|;
comment|// No loss of precision since there is&=.
block|}
end_function

begin_function
name|void
name|dontwarn2
parameter_list|(
name|unsigned
name|int
name|U
parameter_list|)
block|{
if|if
condition|(
name|U
operator|<=
literal|4294967295
condition|)
block|{   }
if|if
condition|(
name|U
operator|<=
operator|(
literal|2147483647
operator|*
literal|2U
operator|+
literal|1U
operator|)
condition|)
block|{   }
block|}
end_function

begin_function
name|void
name|dontwarn3
parameter_list|(
name|int
name|X
parameter_list|)
block|{
name|S8
operator|=
name|X
condition|?
literal|'a'
else|:
literal|'b'
expr_stmt|;
block|}
end_function

begin_comment
comment|// don't warn for macros
end_comment

begin_define
define|#
directive|define
name|DOSTUFF
value|({ unsigned X = 1000; U8 = X; })
end_define

begin_function
name|void
name|dontwarn4
parameter_list|()
block|{
name|DOSTUFF
expr_stmt|;
block|}
end_function

begin_comment
comment|// don't warn for calculations
end_comment

begin_comment
comment|// seen some fp. For instance:  c2 = (c2>= 'A'&& c2<= 'Z') ? c2 - 'A' + 'a' : c2;
end_comment

begin_comment
comment|// there is a todo in the checker to handle calculations
end_comment

begin_function
name|void
name|dontwarn5
parameter_list|()
block|{
name|signed
name|S
init|=
operator|-
literal|32
decl_stmt|;
name|U8
operator|=
name|S
operator|+
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|// false positives..
end_comment

begin_function_decl
name|int
name|isascii
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|falsePositive1
parameter_list|()
block|{
name|char
name|kb2
index|[
literal|5
index|]
decl_stmt|;
name|int
name|X
init|=
literal|1000
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|X
argument_list|)
condition|)
block|{
comment|// FIXME: should not warn here:
name|kb2
index|[
literal|0
index|]
operator|=
name|X
expr_stmt|;
comment|// expected-warning {{Loss of precision}}
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|FILE
block|{}
name|FILE
typedef|;
end_typedef

begin_function_decl
name|int
name|getc
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_decl_stmt
name|char
name|reply_string
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cin
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dostuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|falsePositive2
parameter_list|()
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|dig
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|reply_string
decl_stmt|;
name|int
name|pflag
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dig
operator|=
name|n
operator|=
name|code
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cin
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|dig
operator|<
literal|4
operator|&&
name|dostuff
argument_list|()
condition|)
name|code
operator|=
name|code
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pflag
operator|&&
name|code
operator|==
literal|227
condition|)
name|pflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
literal|4
operator|)
return|;
if|if
condition|(
name|cp
operator|<
operator|&
name|reply_string
index|[
sizeof|sizeof
argument_list|(
name|reply_string
argument_list|)
operator|-
literal|1
index|]
condition|)
comment|// FIXME: should not warn here:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
comment|// expected-warning {{Loss of precision}}
block|}
block|}
block|}
end_function

end_unit

