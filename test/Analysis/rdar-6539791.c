begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: clang-cc -analyze -checker-cfref -analyzer-store=basic -verify %s&&
end_comment

begin_comment
comment|// RUN: clang-cc -analyze -checker-cfref -analyzer-store=region -verify %s
end_comment

begin_typedef
typedef|typedef
specifier|const
name|struct
name|__CFAllocator
modifier|*
name|CFAllocatorRef
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|__CFDictionary
modifier|*
name|CFMutableDictionaryRef
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|long
name|CFIndex
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|CFIndex
name|CFNumberType
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|CFTypeRef
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{}
name|CFDictionaryKeyCallBacks
operator|,
name|CFDictionaryValueCallBacks
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|struct
name|__CFNumber
modifier|*
name|CFNumberRef
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
specifier|const
name|CFAllocatorRef
name|kCFAllocatorDefault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|CFDictionaryKeyCallBacks
name|kCFTypeDictionaryKeyCallBacks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|CFDictionaryValueCallBacks
name|kCFTypeDictionaryValueCallBacks
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|kCFNumberSInt32Type
init|=
literal|3
block|}
enum|;
end_enum

begin_function_decl
name|CFMutableDictionaryRef
name|CFDictionaryCreateMutable
parameter_list|(
name|CFAllocatorRef
name|allocator
parameter_list|,
name|CFIndex
name|capacity
parameter_list|,
specifier|const
name|CFDictionaryKeyCallBacks
modifier|*
name|keyCallBacks
parameter_list|,
specifier|const
name|CFDictionaryValueCallBacks
modifier|*
name|valueCallBacks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|CFDictionaryAddValue
parameter_list|(
name|CFMutableDictionaryRef
name|theDict
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|CFRelease
parameter_list|(
name|CFTypeRef
name|cf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|CFTypeRef
name|CFRetain
parameter_list|(
name|CFTypeRef
name|cf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CFNumberRef
name|CFNumberCreate
parameter_list|(
name|CFAllocatorRef
name|allocator
parameter_list|,
name|CFNumberType
name|theType
parameter_list|,
specifier|const
name|void
modifier|*
name|valuePtr
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
specifier|const
name|struct
name|__CFArray
modifier|*
name|CFArrayRef
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|__CFArray
modifier|*
name|CFMutableArrayRef
typedef|;
end_typedef

begin_function_decl
name|void
name|CFArrayAppendValue
parameter_list|(
name|CFMutableArrayRef
name|theArray
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|f
parameter_list|(
name|CFMutableDictionaryRef
name|y
parameter_list|,
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
name|val_key
parameter_list|)
block|{
name|CFMutableDictionaryRef
name|x
init|=
name|CFDictionaryCreateMutable
argument_list|(
name|kCFAllocatorDefault
argument_list|,
literal|1
argument_list|,
operator|&
name|kCFTypeDictionaryKeyCallBacks
argument_list|,
operator|&
name|kCFTypeDictionaryValueCallBacks
argument_list|)
decl_stmt|;
name|CFDictionaryAddValue
argument_list|(
name|y
argument_list|,
name|key
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|// the dictionary keeps a reference, so the object isn't deallocated yet
name|signed
name|z
init|=
literal|1
decl_stmt|;
name|CFNumberRef
name|value
init|=
name|CFNumberCreate
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|kCFNumberSInt32Type
argument_list|,
operator|&
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|CFDictionaryAddValue
argument_list|(
name|x
argument_list|,
name|val_key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// no-warning
name|CFRelease
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|CFDictionaryAddValue
argument_list|(
name|y
argument_list|,
name|val_key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
block|}
end_function

begin_comment
comment|//<rdar://problem/6560661>
end_comment

begin_comment
comment|// Same issue, except with "AppendValue" functions.
end_comment

begin_function
name|void
name|f2
parameter_list|(
name|CFMutableArrayRef
name|x
parameter_list|)
block|{
name|signed
name|z
init|=
literal|1
decl_stmt|;
name|CFNumberRef
name|value
init|=
name|CFNumberCreate
argument_list|(
name|kCFAllocatorDefault
argument_list|,
name|kCFNumberSInt32Type
argument_list|,
operator|&
name|z
argument_list|)
decl_stmt|;
comment|// CFArrayAppendValue keeps a reference to value.
name|CFArrayAppendValue
argument_list|(
name|x
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|CFRetain
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

end_unit

