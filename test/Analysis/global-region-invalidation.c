begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_analyze_cc1 -triple x86_64-apple-darwin10 -disable-free -analyzer-eagerly-assume -analyzer-checker=core,deadcode,alpha.security.taint,debug.TaintTest,debug.ExprInspection -verify %s
end_comment

begin_function_decl
name|void
name|clang_analyzer_eval
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Note, we do need to include headers here, since the analyzer checks if the function declaration is located in a system header.
end_comment

begin_include
include|#
directive|include
file|"Inputs/system-header-simulator.h"
end_include

begin_comment
comment|// Test that system header does not invalidate the internal global.
end_comment

begin_decl_stmt
name|int
name|size_rdar9373039
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rdar9373039
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size_rdar9373039
condition|;
operator|++
name|i
control|)
name|x
operator|=
literal|1
expr_stmt|;
comment|// strlen doesn't invalidate the value of 'size_rdar9373039'.
name|int
name|extra
init|=
operator|(
literal|2
operator|+
name|strlen
argument_list|(
literal|"Clang"
argument_list|)
operator|+
operator|(
operator|(
literal|4
operator|-
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
literal|"Clang"
argument_list|)
argument_list|)
operator|%
literal|4
operator|)
operator|)
operator|%
literal|4
operator|)
operator|)
operator|+
operator|(
literal|2
operator|+
name|strlen
argument_list|(
literal|"1.0"
argument_list|)
operator|+
operator|(
operator|(
literal|4
operator|-
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
literal|"1.0"
argument_list|)
argument_list|)
operator|%
literal|4
operator|)
operator|)
operator|%
literal|4
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size_rdar9373039
condition|;
operator|++
name|i
control|)
name|j
operator|+=
name|x
expr_stmt|;
comment|// no-warning
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|// Test stdin does not get invalidated by a system call nor by an internal call.
end_comment

begin_function_decl
name|void
name|foo
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|stdinTest
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|foo
argument_list|()
expr_stmt|;
name|int
name|m
init|=
name|i
decl_stmt|;
comment|// expected-warning + {{tainted}}
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// expected-warning + {{tainted}}
return|return
name|m
operator|+
name|j
return|;
comment|// expected-warning + {{tainted}}
block|}
end_function

begin_comment
comment|// Test errno gets invalidated by a system call.
end_comment

begin_function
name|int
name|testErrnoSystem
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|// errno gets invalidated here.
return|return
literal|5
operator|/
name|errno
return|;
comment|// no-warning
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|// errno gets invalidated here.
return|return
literal|5
operator|/
name|errno
return|;
comment|// no-warning
block|}
end_function

begin_comment
comment|// Test that errno gets invalidated by internal calls.
end_comment

begin_function
name|int
name|testErrnoInternal
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|fscanf
argument_list|(
name|stdin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|foo
argument_list|()
expr_stmt|;
comment|// errno gets invalidated here.
return|return
literal|5
operator|/
name|errno
return|;
comment|// no-warning
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// Test that const integer does not get invalidated.
end_comment

begin_decl_stmt
specifier|const
name|int
name|x
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|constIntGlob
parameter_list|()
block|{
specifier|const
name|int
modifier|*
name|m
init|=
operator|&
name|x
decl_stmt|;
name|foo
argument_list|()
expr_stmt|;
return|return
literal|3
operator|/
operator|*
name|m
return|;
comment|// expected-warning {{Division by zero}}
block|}
end_function

begin_decl_stmt
specifier|extern
specifier|const
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|constIntGlobExtern
parameter_list|()
block|{
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|foo
argument_list|()
expr_stmt|;
return|return
literal|5
operator|/
name|y
return|;
comment|// expected-warning {{Division by zero}}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
modifier|*
specifier|const
name|ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|constPtrGlob
parameter_list|()
block|{
name|clang_analyzer_eval
argument_list|(
name|ptr
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
name|foo
argument_list|()
expr_stmt|;
name|clang_analyzer_eval
argument_list|(
name|ptr
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|x2
init|=
name|x
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|constIntGlob2
parameter_list|()
block|{
name|clang_analyzer_eval
argument_list|(
name|x2
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
name|foo
argument_list|()
expr_stmt|;
name|clang_analyzer_eval
argument_list|(
name|x2
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
block|}
end_function

begin_function
name|void
name|testAnalyzerEvalIsPure
parameter_list|()
block|{
specifier|extern
name|int
name|someGlobal
decl_stmt|;
if|if
condition|(
name|someGlobal
operator|==
literal|0
condition|)
block|{
name|clang_analyzer_eval
argument_list|(
name|someGlobal
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
name|clang_analyzer_eval
argument_list|(
name|someGlobal
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
block|}
block|}
end_function

begin_comment
comment|// Test that static variables with initializers do not get reinitialized on
end_comment

begin_comment
comment|// recursive calls.
end_comment

begin_function_decl
name|void
name|Function2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
modifier|*
name|getPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|Function1
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|flag
decl_stmt|;
specifier|static
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|getPtr
argument_list|()
expr_stmt|;
block|}
name|int
name|m
init|=
operator|*
name|p
decl_stmt|;
comment|// no-warning: p is never null.
name|m
operator|++
expr_stmt|;
name|Function2
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Function2
parameter_list|(
name|void
parameter_list|)
block|{
name|Function1
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetToNonZero
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|g
init|=
literal|5
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|g
operator|==
literal|5
argument_list|)
expr_stmt|;
comment|// expected-warning{{TRUE}}
block|}
end_function

end_unit

