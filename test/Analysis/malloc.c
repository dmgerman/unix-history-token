begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_cc1 -analyze -analyzer-checker=core,experimental.deadcode.UnreachableCode,experimental.core.CastSize,unix.Malloc,debug.ExprInspection -analyzer-store=region -verify %s
end_comment

begin_include
include|#
directive|include
file|"system-header-simulator.h"
end_include

begin_function_decl
name|void
name|clang_analyzer_eval
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|__typeof
argument_list|(
argument|sizeof(int)
argument_list|)
name|size_t
expr_stmt|;
end_typedef

begin_function_decl
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|valloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|reallocf
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|calloc
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strndup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myfoo
parameter_list|(
name|int
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myfooint
parameter_list|(
name|int
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fooRetPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|f1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return;
comment|// expected-warning{{Memory is never released; potential leak of memory pointed to by 'p'}}
block|}
end_function

begin_function
name|void
name|f2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|f2_realloc_0
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|f2_realloc_1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|reallocNotNullPtr
parameter_list|(
name|unsigned
name|sizeIn
parameter_list|)
block|{
name|unsigned
name|size
init|=
literal|12
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|p
argument_list|,
name|sizeIn
argument_list|)
decl_stmt|;
name|char
name|x
init|=
operator|*
name|q
decl_stmt|;
comment|// expected-warning {{Memory is never released; potential leak of memory pointed to by 'q'}}
block|}
block|}
end_function

begin_function
name|int
modifier|*
name|realloctest1
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|realloc
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no warning - returning the allocated value
block|}
end_function

begin_comment
comment|// p should be freed if realloc fails.
end_comment

begin_function
name|void
name|reallocFails
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|12
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocSizeZero1
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocSizeZero2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|reallocSizeZero3
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocSizeZero4
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocSizeZero5
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|reallocPtrZero1
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
comment|// expected-warning {{Memory is never released; potential leak of memory pointed to by 'r'}}
block|}
end_function

begin_function
name|void
name|reallocPtrZero2
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocPtrZero3
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_1
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
return|return;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_2
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
comment|// expected-warning {{Memory is never released; potential leak}}
empty_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_3
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_4
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
return|return;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
modifier|*
name|reallocfTest1
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|reallocf
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no warning - returning the allocated value
block|}
end_function

begin_function
name|void
name|reallocfRadar6337483_4
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|reallocf
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
return|return;
comment|// no warning - reallocf frees even on failure
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocfRadar6337483_3
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|reallocf
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
return|return;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocfPtrZero1
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|reallocf
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_comment
comment|// This case tests that storing malloc'ed memory to a static variable which is
end_comment

begin_comment
comment|// then returned is not leaked.  In the absence of known contracts for functions
end_comment

begin_comment
comment|// or inter-procedural analysis, this is a conservative answer.
end_comment

begin_function
name|int
modifier|*
name|f3
parameter_list|()
block|{
specifier|static
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return
name|p
return|;
comment|// no-warning
block|}
end_function

begin_comment
comment|// This case tests that storing malloc'ed memory to a static global variable
end_comment

begin_comment
comment|// which is then returned is not leaked.  In the absence of known contracts for
end_comment

begin_comment
comment|// functions or inter-procedural analysis, this is a conservative answer.
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|p_f4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
modifier|*
name|f4
parameter_list|()
block|{
name|p_f4
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return
name|p_f4
return|;
comment|// no-warning
block|}
end_function

begin_function
name|int
modifier|*
name|f5
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|realloc
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|f6
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|// no-warning
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f6_realloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|// no-warning
else|else
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|char
modifier|*
name|doit2
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|pr6069
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|doit2
argument_list|()
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pr6293
parameter_list|()
block|{
name|free
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f7
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|f8
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|char
modifier|*
name|y
init|=
name|strndup
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|f7_realloc
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|realloc
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|PR6123
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|11
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
block|}
end_function

begin_function
name|void
name|PR7217
parameter_list|()
block|{
name|int
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|buf
index|[
literal|1
index|]
operator|=
literal|'c'
expr_stmt|;
comment|// not crash
block|}
end_function

begin_function
name|void
name|mallocCastToVoid
parameter_list|()
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|cp
init|=
name|p
decl_stmt|;
comment|// not crash
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocCastToFP
parameter_list|()
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fp
function_decl|)
parameter_list|()
init|=
name|p
function_decl|;
comment|// not crash
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// This tests that malloc() buffers are undefined by default
end_comment

begin_function
name|char
name|mallocGarbage
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|// expected-warning{{undefined}}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// This tests that calloc() buffers need to be freed
end_comment

begin_function
name|void
name|callocNoFree
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
return|return;
comment|// expected-warning{{never released}}
block|}
end_function

begin_comment
comment|// These test that calloc() buffers are zeroed by default
end_comment

begin_function
name|char
name|callocZeroesGood
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|// no-warning
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
comment|// no-warning
block|}
end_function

begin_function
name|char
name|callocZeroesBad
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|// no-warning
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// expected-warning{{never executed}}
block|}
return|return
name|result
return|;
comment|// expected-warning{{never released}}
block|}
end_function

begin_function
name|void
name|nullFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning - a nop
block|}
end_function

begin_function
name|void
name|paramFree
parameter_list|(
name|int
modifier|*
name|p
parameter_list|)
block|{
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function
name|int
modifier|*
name|mallocEscapeRet
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return
name|p
return|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFoo
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function_decl
name|int
modifier|*
name|myalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myalloc2
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mallocEscapeFreeCustomAlloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|myalloc
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeCustomAlloc2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myalloc2
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocBindFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
name|free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocEscapeMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|// expected-warning{{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|void
name|mallocMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|void
name|mallocFreeMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocFreeUse_params
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocFreeUse_params2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfooint
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|//expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocFailedOrNot
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|StructWithInt
block|{
name|int
name|g
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
modifier|*
name|mallocReturnFreed
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function
name|int
name|useAfterFreeStruct
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|g
operator|=
literal|5
expr_stmt|;
name|free
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|px
operator|->
name|g
return|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function_decl
name|void
name|nonSymbolAsFirstArg
parameter_list|(
name|int
modifier|*
name|pp
parameter_list|,
name|struct
name|StructWithInt
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mallocEscapeFooNonSymbolArg
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|p
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
name|nonSymbolAsFirstArg
argument_list|(
operator|&
name|p
operator|->
name|g
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocFailedOrNotLeak
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
comment|// no warning
else|else
return|return;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|void
name|mallocAssignment
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|fooRetPtr
argument_list|()
expr_stmt|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_function
name|int
name|vallocTest
parameter_list|()
block|{
name|char
modifier|*
name|mem
init|=
name|valloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|void
name|vallocEscapeFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|valloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_decl_stmt
name|int
modifier|*
name|Gl
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|GlStTy
block|{
name|int
modifier|*
name|x
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|GlStTy
name|GlS
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|GlobalFree
parameter_list|()
block|{
name|free
argument_list|(
name|Gl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalMalloc
parameter_list|()
block|{
name|Gl
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalStructMalloc
parameter_list|()
block|{
name|int
modifier|*
name|a
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|GlS
operator|.
name|x
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalStructMallocFree
parameter_list|()
block|{
name|int
modifier|*
name|a
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|GlS
operator|.
name|x
operator|=
name|a
expr_stmt|;
name|free
argument_list|(
name|GlS
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|ArrayG
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|globalArrayTest
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|ArrayG
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|// Make sure that we properly handle a pointer stored into a local struct/array.
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_StructWithPtr
block|{
name|int
modifier|*
name|memP
decl_stmt|;
block|}
name|StructWithPtr
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|StructWithPtr
name|arrOfStructs
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|testMalloc
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|x
expr_stmt|;
name|arrOfStructs
index|[
literal|0
index|]
operator|=
name|St
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|StructWithPtr
name|testMalloc2
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|x
expr_stmt|;
return|return
name|St
return|;
comment|// no-warning
block|}
end_function

begin_function
name|int
modifier|*
name|testMalloc3
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
return|return
name|y
return|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testStructLeak
parameter_list|()
block|{
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return;
comment|// expected-warning {{Memory is never released; potential leak of memory pointed to by 'St.memP'}}
block|}
end_function

begin_function
name|void
name|testElemRegion1
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|int
modifier|*
name|ix
init|=
operator|(
name|int
operator|*
operator|)
name|x
decl_stmt|;
name|free
argument_list|(
operator|&
operator|(
name|x
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testElemRegion2
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
name|free
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testElemRegion3
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Region escape testing.
end_comment

begin_function_decl
name|unsigned
name|takePtrToPtr
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|PassTheAddrOfAllocatedData
parameter_list|(
name|int
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
comment|// We don't know what happens after the call. Should stop tracking here.
if|if
condition|(
name|takePtrToPtr
argument_list|(
operator|&
name|p
argument_list|)
condition|)
name|f
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_struct
struct|struct
name|X
block|{
name|int
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|unsigned
name|takePtrToStruct
parameter_list|(
name|struct
name|X
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
modifier|*
modifier|*
name|foo2
parameter_list|(
name|int
modifier|*
name|g
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
name|p
expr_stmt|;
comment|// We don't know what happens after this call. Should not track px nor p.
if|if
condition|(
name|takePtrToStruct
argument_list|(
name|px
argument_list|)
condition|)
name|f
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|X
modifier|*
name|RegInvalidationDetect1
parameter_list|(
name|struct
name|X
modifier|*
name|s2
parameter_list|)
block|{
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
literal|0
expr_stmt|;
name|px
operator|=
name|s2
expr_stmt|;
return|return
name|px
return|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|struct
name|X
modifier|*
name|RegInvalidationGiveUp1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
name|p
expr_stmt|;
return|return
name|px
return|;
block|}
end_function

begin_function
name|int
modifier|*
modifier|*
name|RegInvalidationDetect2
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|pp
operator|=
operator|&
name|p
expr_stmt|;
name|pp
operator|++
expr_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|(
name|int
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|mallocExit
parameter_list|(
name|int
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|xx
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|__assert_fail
parameter_list|(
name|__const
name|char
modifier|*
name|__assertion
parameter_list|,
name|__const
name|char
modifier|*
name|__file
parameter_list|,
name|unsigned
name|int
name|__line
parameter_list|,
name|__const
name|char
modifier|*
name|__function
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expr
parameter_list|)
define|\
value|((expr)  ? (void)(0)  : __assert_fail (#expr, __FILE__, __LINE__, __func__))
end_define

begin_function
name|void
name|mallocAssert
parameter_list|(
name|int
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|xx
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|doNotInvalidateWhenPassedToSystemCalls
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|// Rely on the CString checker evaluation of the strcpy API to convey that the result of strcpy is equal to p.
end_comment

begin_function
name|void
name|symbolLostWithStrcpy
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// The same test as the one above, but with what is actually generated on a mac.
end_comment

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|__inline_strcpy_chk
parameter_list|(
name|char
modifier|*
specifier|restrict
name|__dest
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|__src
parameter_list|)
block|{
return|return
name|__builtin___strcpy_chk
argument_list|(
name|__dest
argument_list|,
name|__src
argument_list|,
name|__builtin_object_size
argument_list|(
name|__dest
argument_list|,
literal|2
operator|>
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|symbolLostWithStrcpy_InlineStrcpyVersion
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
operator|(
name|__builtin_object_size
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|?
name|__builtin___strcpy_chk
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|__builtin_object_size
argument_list|(
name|p
argument_list|,
literal|2
operator|>
literal|1
argument_list|)
argument_list|)
else|:
name|__inline_strcpy_chk
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Here we are returning a pointer one past the allocated value. An idiom which
end_comment

begin_comment
comment|// can be used for implementing special malloc. The correct uses of this might
end_comment

begin_comment
comment|// be rare enough so that we could keep this as a warning.
end_comment

begin_function
specifier|static
name|void
modifier|*
name|specialMalloc
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|// Potentially, the user could free the struct by performing pointer arithmetic on the return value.
end_comment

begin_comment
comment|// This is a variation of the specialMalloc issue, though probably would be more rare in correct code.
end_comment

begin_function
name|int
modifier|*
name|specialMallocWithStruct
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|&
operator|(
name|px
operator|->
name|g
operator|)
return|;
block|}
end_function

begin_comment
comment|// Test various allocation/deallocation functions.
end_comment

begin_function
name|void
name|testStrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|int
name|testStrndup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strndup
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|validIndex
index|]
operator|!=
literal|'a'
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
comment|// expected-warning {{Memory is never released; potential leak}}
block|}
end_function

begin_function
name|void
name|testStrdupContentIsDefined
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|s2
index|[
literal|1
index|]
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------------
end_comment

begin_comment
comment|// Test the system library functions to which the pointer can escape.
end_comment

begin_comment
comment|// This tests false positive suppression.
end_comment

begin_comment
comment|// For now, we assume memory passed to pthread_specific escapes.
end_comment

begin_comment
comment|// TODO: We could check that if a new pthread binding is set, the existing
end_comment

begin_comment
comment|// binding must be freed; otherwise, a memory leak can occur.
end_comment

begin_function
name|void
name|testPthereadSpecificEscape
parameter_list|(
name|pthread_key_t
name|key
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|pthread_setspecific
argument_list|(
name|key
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_comment
comment|// PR12101: Test funopen().
end_comment

begin_function
specifier|static
name|int
name|releasePtr
parameter_list|(
name|void
modifier|*
name|_ctx
parameter_list|)
block|{
name|free
argument_list|(
name|_ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpen
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|releasePtr
argument_list|)
decl_stmt|;
comment|// no warning
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpenNoReleaseFunction
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_function
specifier|static
name|int
name|readNothing
parameter_list|(
name|void
modifier|*
name|_ctx
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpenReadNoRelease
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
name|readNothing
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_comment
comment|// Test setbuf, setvbuf.
end_comment

begin_function
name|int
name|my_main_no_warning
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|my_main_no_warning2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setbuf
argument_list|(
name|__stdoutp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|my_main_warn
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setvbuf
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|//<rdar://problem/10978247>.
end_comment

begin_comment
comment|// some people use stack allocated memory as an optimization to avoid
end_comment

begin_comment
comment|// a heap allocation for small work sizes.  This tests the analyzer's
end_comment

begin_comment
comment|// understanding that the malloc'ed memory is not the same as stackBuffer.
end_comment

begin_function
name|void
name|radar10978247
parameter_list|(
name|int
name|myValueSize
parameter_list|)
block|{
name|char
name|stackBuffer
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|myValueSize
operator|<=
sizeof|sizeof
argument_list|(
name|stackBuffer
argument_list|)
condition|)
name|buffer
operator|=
name|stackBuffer
expr_stmt|;
else|else
name|buffer
operator|=
name|malloc
argument_list|(
name|myValueSize
argument_list|)
expr_stmt|;
comment|// do stuff with the buffer
if|if
condition|(
name|buffer
operator|!=
name|stackBuffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|radar10978247_positive
parameter_list|(
name|int
name|myValueSize
parameter_list|)
block|{
name|char
name|stackBuffer
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|myValueSize
operator|<=
sizeof|sizeof
argument_list|(
name|stackBuffer
argument_list|)
condition|)
name|buffer
operator|=
name|stackBuffer
expr_stmt|;
else|else
name|buffer
operator|=
name|malloc
argument_list|(
name|myValueSize
argument_list|)
expr_stmt|;
comment|// do stuff with the buffer
if|if
condition|(
name|buffer
operator|==
name|stackBuffer
condition|)
comment|// expected-warning {{leak}}
return|return;
block|}
end_function

begin_comment
comment|//<rdar://problem/11269741> Previously this triggered a false positive
end_comment

begin_comment
comment|// because malloc() is known to return uninitialized memory and the binding
end_comment

begin_comment
comment|// of 'o' to 'p->n' was not getting propertly handled.  Now we report a leak.
end_comment

begin_struct
struct|struct
name|rdar11269741_a_t
block|{
struct|struct
name|rdar11269741_b_t
block|{
name|int
name|m
decl_stmt|;
block|}
name|n
struct|;
block|}
struct|;
end_struct

begin_function
name|int
name|rdar11269741
parameter_list|(
name|struct
name|rdar11269741_b_t
name|o
parameter_list|)
block|{
name|struct
name|rdar11269741_a_t
modifier|*
name|p
init|=
operator|(
expr|struct
name|rdar11269741_a_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|n
operator|=
name|o
expr_stmt|;
return|return
name|p
operator|->
name|n
operator|.
name|m
return|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|// Pointer arithmetic, returning an ElementRegion.
end_comment

begin_function
name|void
modifier|*
name|radar11329382
parameter_list|(
name|unsigned
name|bl
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|ptr
operator|+
operator|(
literal|2
operator|-
name|bl
operator|)
expr_stmt|;
return|return
name|ptr
return|;
comment|// no warning
block|}
end_function

begin_function_decl
name|void
name|__assert_rtn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|int
name|strcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|a
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|radar11270219
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|x
init|=
name|a
argument_list|()
decl_stmt|,
modifier|*
name|y
init|=
name|a
argument_list|()
decl_stmt|;
operator|(
name|__builtin_expect
argument_list|(
operator|!
operator|(
name|x
operator|&&
name|y
operator|)
argument_list|,
literal|0
argument_list|)
condition|?
name|__assert_rtn
argument_list|(
name|__func__
argument_list|,
literal|"/Users/zaks/tmp/ex.c"
argument_list|,
literal|24
argument_list|,
literal|"x&& y"
argument_list|)
else|:
operator|(
name|void
operator|)
literal|0
operator|)
expr_stmt|;
name|strcmp
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|radar_11358224_test_double_assign_ints_positive_2
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|ptr
expr_stmt|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|// Assume that functions which take a function pointer can free memory even if
end_comment

begin_comment
comment|// they are defined in system headers and take the const pointer to the
end_comment

begin_comment
comment|// allocated memory. (radar://11160612)
end_comment

begin_function_decl
name|int
name|const_ptr_and_callback
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|n
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|r11160612_1
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|const_ptr_and_callback
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|// no - warning
block|}
end_function

begin_comment
comment|// Null is passed as callback.
end_comment

begin_function
name|void
name|r11160612_2
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|const_ptr_and_callback
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|// Callback is passed to a function defined in a system header.
end_comment

begin_function
name|void
name|r11160612_4
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|sqlite3_bind_text_my
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|// no - warning
block|}
end_function

begin_comment
comment|// Passing callbacks in a struct.
end_comment

begin_function
name|void
name|r11160612_5
parameter_list|(
name|StWithCallback
name|St
parameter_list|)
block|{
name|void
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|dealocateMemWhenDoneByVal
argument_list|(
name|x
argument_list|,
name|St
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|r11160612_6
parameter_list|(
name|StWithCallback
name|St
parameter_list|)
block|{
name|void
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|dealocateMemWhenDoneByRef
argument_list|(
operator|&
name|St
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|mySub
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|myAdd
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|fPtr
parameter_list|(
name|unsigned
name|cond
parameter_list|,
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|cond
condition|?
name|mySub
else|:
name|myAdd
operator|)
operator|(
name|x
operator|,
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|// Test anti-aliasing.
end_comment

begin_function
name|void
name|dependsOnValueOfPtr
parameter_list|(
name|int
modifier|*
name|g
parameter_list|,
name|unsigned
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|p
operator|=
name|g
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|g
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
return|return;
comment|// no warning
return|return;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToStack
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x2
init|=
operator|&
name|x
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|x1
operator|==
name|x2
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToHeap2
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x2
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x4
init|=
name|x1
decl_stmt|;
name|int
modifier|*
name|x5
init|=
name|x2
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|x4
operator|==
name|x5
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x2
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToHeap
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x4
init|=
name|x1
decl_stmt|;
if|if
condition|(
name|x1
operator|==
name|x4
condition|)
block|{
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
literal|5
operator|/
name|x
return|;
comment|// expected-warning{{Division by zero}}
block|}
return|return
name|x
return|;
comment|// expected-warning{{This statement is never executed}}
block|}
end_function

begin_function
name|int
name|HeapAssignment
parameter_list|()
block|{
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
operator|*
name|x
operator|=
literal|5
expr_stmt|;
name|clang_analyzer_eval
argument_list|(
operator|*
name|x
operator|!=
operator|*
name|y
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|int
modifier|*
name|retPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
modifier|*
name|retPtrMightAlias
parameter_list|(
name|int
modifier|*
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|cmpHeapAllocationToUnknown
parameter_list|()
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|yBefore
init|=
name|retPtr
argument_list|()
decl_stmt|;
name|int
modifier|*
name|m
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|yAfter
init|=
name|retPtrMightAlias
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|yBefore
operator|==
name|m
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|clang_analyzer_eval
argument_list|(
name|yAfter
operator|==
name|m
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|localArrayTest
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ArrayL
index|[
literal|12
index|]
decl_stmt|;
name|ArrayL
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_function
name|void
name|localStructTest
parameter_list|()
block|{
name|StructWithPtr
name|St
decl_stmt|;
name|StructWithPtr
modifier|*
name|pSt
init|=
operator|&
name|St
decl_stmt|;
name|pSt
operator|->
name|memP
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|// expected-warning{{Memory is never released; potential leak}}
block|}
end_function

begin_comment
comment|// Test double assignment through integers.
end_comment

begin_decl_stmt
specifier|static
name|long
name|glob
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|test_double_assign_ints
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
comment|// no-warning
name|glob
operator|=
operator|(
name|long
operator|)
operator|(
name|unsigned
name|long
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_double_assign_ints_positive
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
operator|(
name|unsigned
name|long
operator|)
name|ptr
expr_stmt|;
comment|// expected-warning {{unused}} expected-warning {{leak}}
block|}
end_function

begin_function
name|void
name|testCGContextNoLeak
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|CGContextRef
name|context
init|=
name|CGBitmapContextCreate
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|// Because you can get the data back out like this, even much later,
comment|// CGBitmapContextCreate is one of our "stop-tracking" exceptions.
name|free
argument_list|(
name|CGBitmapContextGetData
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testCGContextLeak
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|CGContextRef
name|context
init|=
name|CGBitmapContextCreate
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|// However, this time we're just leaking the data, because the context
comment|// object doesn't escape and it hasn't been freed in this function.
block|}
end_function

begin_comment
comment|// Allow xpc context to escape. radar://11635258
end_comment

begin_comment
comment|// TODO: Would be great if we checked that the finalize_connection_context actually releases it.
end_comment

begin_function
specifier|static
name|void
name|finalize_connection_context
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
modifier|*
name|context
init|=
name|ctx
decl_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|foo
parameter_list|(
name|xpc_connection_t
name|peer
parameter_list|)
block|{
name|int
modifier|*
name|ctx
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|xpc_connection_set_context
argument_list|(
name|peer
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|xpc_connection_set_finalizer_f
argument_list|(
name|peer
argument_list|,
name|finalize_connection_context
argument_list|)
expr_stmt|;
name|xpc_connection_resume
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Make sure we catch errors when we free in a function which does not allocate memory.
end_comment

begin_function
name|void
name|freeButNoMalloc
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//user forgot a return here.
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
end_function

begin_struct
struct|struct
name|HasPtr
block|{
name|int
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
modifier|*
name|reallocButNoMalloc
parameter_list|(
name|struct
name|HasPtr
modifier|*
name|a
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|s
decl_stmt|;
name|a
operator|->
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|a
operator|->
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// expected-warning{{Memory is never released; potential leak}}
return|return
name|a
operator|->
name|p
return|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------------
end_comment

begin_comment
comment|// False negatives.
end_comment

begin_comment
comment|// TODO: This is another false negative.
end_comment

begin_function
name|void
name|testMallocWithParam
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testMallocWithParam_2
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

