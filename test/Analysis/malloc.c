begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_analyze_cc1 -analyzer-checker=core,alpha.deadcode.UnreachableCode,alpha.core.CastSize,unix.Malloc,debug.ExprInspection -analyzer-store=region -verify %s
end_comment

begin_include
include|#
directive|include
file|"Inputs/system-header-simulator.h"
end_include

begin_function_decl
name|void
name|clang_analyzer_eval
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Without -fms-compatibility, wchar_t isn't a builtin type. MSVC defines
end_comment

begin_comment
comment|// _WCHAR_T_DEFINED if wchar_t is available. Microsoft recommends that you use
end_comment

begin_comment
comment|// the builtin type: "Using the typedef version can cause portability
end_comment

begin_comment
comment|// problems", but we're ok here because we're not actually running anything.
end_comment

begin_comment
comment|// Also of note is this cryptic warning: "The wchar_t type is not supported
end_comment

begin_comment
comment|// when you compile C code".
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// See the docs for more:
end_comment

begin_comment
comment|// https://msdn.microsoft.com/en-us/library/dh8che7s.aspx
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WCHAR_T_DEFINED
argument_list|)
end_if

begin_comment
comment|// "Microsoft implements wchar_t as a two-byte unsigned value"
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|short
name|wchar_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_WCHAR_T_DEFINED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(_WCHAR_T_DEFINED)
end_comment

begin_typedef
typedef|typedef
name|__typeof
argument_list|(
argument|sizeof(int)
argument_list|)
name|size_t
expr_stmt|;
end_typedef

begin_function_decl
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|alloca
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|valloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|reallocf
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|calloc
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|wchar_t
modifier|*
name|wcsdup
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strndup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|memcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Windows variants
end_comment

begin_function_decl
name|char
modifier|*
name|_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|strSource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|wchar_t
modifier|*
name|_wcsdup
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|strSource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|_alloca
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myfoo
parameter_list|(
name|int
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myfooint
parameter_list|(
name|int
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fooRetPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|f1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return;
comment|// expected-warning{{Potential leak of memory pointed to by 'p'}}
block|}
end_function

begin_function
name|void
name|f2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|f2_realloc_0
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|f2_realloc_1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|reallocNotNullPtr
parameter_list|(
name|unsigned
name|sizeIn
parameter_list|)
block|{
name|unsigned
name|size
init|=
literal|12
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|p
argument_list|,
name|sizeIn
argument_list|)
decl_stmt|;
name|char
name|x
init|=
operator|*
name|q
decl_stmt|;
comment|// expected-warning {{Potential leak of memory pointed to by 'q'}}
block|}
block|}
end_function

begin_function
name|void
name|allocaTest
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|// no warn
end_comment

begin_function
name|void
name|winAllocaTest
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|_alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|// no warn
end_comment

begin_function
name|void
name|allocaBuiltinTest
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|__builtin_alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|// no warn
end_comment

begin_function
name|int
modifier|*
name|realloctest1
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|realloc
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no warning - returning the allocated value
block|}
end_function

begin_comment
comment|// p should be freed if realloc fails.
end_comment

begin_function
name|void
name|reallocFails
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|12
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocSizeZero1
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocSizeZero2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
else|else
block|{
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|reallocSizeZero3
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocSizeZero4
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocSizeZero5
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|reallocPtrZero1
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by 'r'}}
end_comment

begin_function
name|void
name|reallocPtrZero2
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocPtrZero3
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_1
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
return|return;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_2
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|reallocRadar6337483_3
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocRadar6337483_4
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
return|return;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
modifier|*
name|reallocfTest1
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|reallocf
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no warning - returning the allocated value
block|}
end_function

begin_function
name|void
name|reallocfRadar6337483_4
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|reallocf
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
return|return;
comment|// no warning - reallocf frees even on failure
block|}
else|else
block|{
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reallocfRadar6337483_3
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|reallocf
argument_list|(
name|buf
argument_list|,
literal|0x1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
return|return;
block|}
name|buf
operator|=
name|tmp
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reallocfPtrZero1
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|reallocf
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_comment
comment|//------------------- Check usage of zero-allocated memory ---------------------
end_comment

begin_function
name|void
name|CheckUseZeroAllocatedNoWarn1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocatedNoWarn2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|alloca
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|CheckUseZeroWinAllocatedNoWarn2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|_alloca
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocatedNoWarn3
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|8
argument_list|)
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocatedNoWarn4
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// no warning
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
name|CheckUseZeroAllocated2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
operator|*
name|p
return|;
comment|// expected-warning {{Use of zero-allocated memory}}
block|}
end_function

begin_function
name|char
name|CheckUseZeroWinAllocated2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|_alloca
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
operator|*
name|p
return|;
comment|// expected-warning {{Use of zero-allocated memory}}
block|}
end_function

begin_function
name|void
name|UseZeroAllocated
parameter_list|(
name|int
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|7
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated3
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UseZeroAllocated
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|f
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|CheckUseZeroAllocated4
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|valloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|f
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated5
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|calloc
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated6
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated7
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated8
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|q
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocated9
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|realloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|q
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocatedPathNoWarn
parameter_list|(
name|_Bool
name|b
parameter_list|)
block|{
name|int
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|s
operator|=
literal|10
expr_stmt|;
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// no warning
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroAllocatedPathWarn
parameter_list|(
name|_Bool
name|b
parameter_list|)
block|{
name|int
name|s
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|s
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|p
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroReallocatedPathNoWarn
parameter_list|(
name|_Bool
name|b
parameter_list|)
block|{
name|int
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|s
operator|=
literal|10
expr_stmt|;
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|q
operator|=
literal|1
expr_stmt|;
comment|// no warning
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|CheckUseZeroReallocatedPathWarn
parameter_list|(
name|_Bool
name|b
parameter_list|)
block|{
name|int
name|s
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|s
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|q
operator|=
literal|1
expr_stmt|;
comment|// expected-warning {{Use of zero-allocated memory}}
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// This case tests that storing malloc'ed memory to a static variable which is
end_comment

begin_comment
comment|// then returned is not leaked.  In the absence of known contracts for functions
end_comment

begin_comment
comment|// or inter-procedural analysis, this is a conservative answer.
end_comment

begin_function
name|int
modifier|*
name|f3
parameter_list|()
block|{
specifier|static
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return
name|p
return|;
comment|// no-warning
block|}
end_function

begin_comment
comment|// This case tests that storing malloc'ed memory to a static global variable
end_comment

begin_comment
comment|// which is then returned is not leaked.  In the absence of known contracts for
end_comment

begin_comment
comment|// functions or inter-procedural analysis, this is a conservative answer.
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|p_f4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
modifier|*
name|f4
parameter_list|()
block|{
name|p_f4
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return
name|p_f4
return|;
comment|// no-warning
block|}
end_function

begin_function
name|int
modifier|*
name|f5
parameter_list|()
block|{
name|int
modifier|*
name|q
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|q
operator|=
name|realloc
argument_list|(
name|q
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|q
return|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|f6
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|// no-warning
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f6_realloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|// no-warning
else|else
name|realloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|char
modifier|*
name|doit2
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|pr6069
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|doit2
argument_list|()
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pr6293
parameter_list|()
block|{
name|free
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f7
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|f8
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|char
modifier|*
name|y
init|=
name|strndup
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|f7_realloc
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|realloc
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|PR6123
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|11
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
block|}
end_function

begin_function
name|void
name|PR7217
parameter_list|()
block|{
name|int
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|buf
index|[
literal|1
index|]
operator|=
literal|'c'
expr_stmt|;
comment|// not crash
block|}
end_function

begin_function
name|void
name|cast_emtpy_struct
parameter_list|()
block|{
struct|struct
name|st
block|{   }
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_1
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_2
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_3
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_4
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_5
parameter_list|()
block|{
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|200
index|]
decl_stmt|;
name|char
name|j
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_warn_1
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_warn_2
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_1
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_2
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_3
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|char
name|j
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_4
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_5
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_6
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// no-warning
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_1
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_2
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_3
parameter_list|()
block|{
struct|struct
name|foo
block|{
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
struct|struct
name|st
block|{
name|char
name|i
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|foo
name|data
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_4
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|int
name|j
index|[]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_5
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|int
name|j
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_struct_flex_array_warn_6
parameter_list|()
block|{
struct|struct
name|st
block|{
name|int
name|i
index|[
literal|100
index|]
decl_stmt|;
name|int
name|j
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|st
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|// expected-warning{{Cast a region whose size is not a multiple of the destination type size}}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocCastToVoid
parameter_list|()
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|cp
init|=
name|p
decl_stmt|;
comment|// not crash
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocCastToFP
parameter_list|()
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fp
function_decl|)
parameter_list|()
init|=
name|p
function_decl|;
comment|// not crash
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// This tests that malloc() buffers are undefined by default
end_comment

begin_function
name|char
name|mallocGarbage
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|1
index|]
decl_stmt|;
comment|// expected-warning{{undefined}}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// This tests that calloc() buffers need to be freed
end_comment

begin_function
name|void
name|callocNoFree
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
return|return;
comment|// expected-warning{{Potential leak of memory pointed to by 'buf'}}
block|}
end_function

begin_comment
comment|// These test that calloc() buffers are zeroed by default
end_comment

begin_function
name|char
name|callocZeroesGood
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|// no-warning
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
comment|// no-warning
block|}
end_function

begin_function
name|char
name|callocZeroesBad
parameter_list|()
block|{
name|char
modifier|*
name|buf
init|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|// no-warning
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// expected-warning{{never executed}}
block|}
return|return
name|result
return|;
comment|// expected-warning{{Potential leak of memory pointed to by 'buf'}}
block|}
end_function

begin_function
name|void
name|nullFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning - a nop
block|}
end_function

begin_function
name|void
name|paramFree
parameter_list|(
name|int
modifier|*
name|p
parameter_list|)
block|{
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function
name|int
modifier|*
name|mallocEscapeRet
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return
name|p
return|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFoo
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeFree
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function_decl
name|int
modifier|*
name|myalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|myalloc2
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mallocEscapeFreeCustomAlloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|myalloc
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocEscapeFreeCustomAlloc2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myalloc2
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocBindFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
name|free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocEscapeMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning{{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|mallocMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|mallocFreeMalloc
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mallocFreeUse_params
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocFreeUse_params2
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfooint
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|//expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_function
name|void
name|mallocFailedOrNot
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|StructWithInt
block|{
name|int
name|g
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
modifier|*
name|mallocReturnFreed
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function
name|int
name|useAfterFreeStruct
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|g
operator|=
literal|5
expr_stmt|;
name|free
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|px
operator|->
name|g
return|;
comment|// expected-warning {{Use of memory after it is freed}}
block|}
end_function

begin_function_decl
name|void
name|nonSymbolAsFirstArg
parameter_list|(
name|int
modifier|*
name|pp
parameter_list|,
name|struct
name|StructWithInt
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mallocEscapeFooNonSymbolArg
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|p
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
name|nonSymbolAsFirstArg
argument_list|(
operator|&
name|p
operator|->
name|g
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
comment|// no warning
block|}
end_function

begin_function
name|void
name|mallocFailedOrNotLeak
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
comment|// no warning
else|else
return|return;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
end_function

begin_function
name|void
name|mallocAssignment
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|fooRetPtr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_function
name|int
name|vallocTest
parameter_list|()
block|{
name|char
modifier|*
name|mem
init|=
name|valloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
end_function

begin_function
name|void
name|vallocEscapeFreeUse
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|valloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Use of memory after it is freed}}
block|}
end_function

begin_decl_stmt
name|int
modifier|*
name|Gl
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|GlStTy
block|{
name|int
modifier|*
name|x
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|GlStTy
name|GlS
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|GlobalFree
parameter_list|()
block|{
name|free
argument_list|(
name|Gl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalMalloc
parameter_list|()
block|{
name|Gl
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalStructMalloc
parameter_list|()
block|{
name|int
modifier|*
name|a
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|GlS
operator|.
name|x
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GlobalStructMallocFree
parameter_list|()
block|{
name|int
modifier|*
name|a
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|GlS
operator|.
name|x
operator|=
name|a
expr_stmt|;
name|free
argument_list|(
name|GlS
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|ArrayG
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|globalArrayTest
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|ArrayG
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|// Make sure that we properly handle a pointer stored into a local struct/array.
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_StructWithPtr
block|{
name|int
modifier|*
name|memP
decl_stmt|;
block|}
name|StructWithPtr
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|StructWithPtr
name|arrOfStructs
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|testMalloc
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|x
expr_stmt|;
name|arrOfStructs
index|[
literal|0
index|]
operator|=
name|St
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|StructWithPtr
name|testMalloc2
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|x
expr_stmt|;
return|return
name|St
return|;
comment|// no-warning
block|}
end_function

begin_function
name|int
modifier|*
name|testMalloc3
parameter_list|()
block|{
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
return|return
name|y
return|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testStructLeak
parameter_list|()
block|{
name|StructWithPtr
name|St
decl_stmt|;
name|St
operator|.
name|memP
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
return|return;
comment|// expected-warning {{Potential leak of memory pointed to by 'St.memP'}}
block|}
end_function

begin_function
name|void
name|testElemRegion1
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|int
modifier|*
name|ix
init|=
operator|(
name|int
operator|*
operator|)
name|x
decl_stmt|;
name|free
argument_list|(
operator|&
operator|(
name|x
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testElemRegion2
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
name|free
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testElemRegion3
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Region escape testing.
end_comment

begin_function_decl
name|unsigned
name|takePtrToPtr
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|PassTheAddrOfAllocatedData
parameter_list|(
name|int
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
comment|// We don't know what happens after the call. Should stop tracking here.
if|if
condition|(
name|takePtrToPtr
argument_list|(
operator|&
name|p
argument_list|)
condition|)
name|f
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_struct
struct|struct
name|X
block|{
name|int
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|unsigned
name|takePtrToStruct
parameter_list|(
name|struct
name|X
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
modifier|*
modifier|*
name|foo2
parameter_list|(
name|int
modifier|*
name|g
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
name|p
expr_stmt|;
comment|// We don't know what happens after this call. Should not track px nor p.
if|if
condition|(
name|takePtrToStruct
argument_list|(
name|px
argument_list|)
condition|)
name|f
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|X
modifier|*
name|RegInvalidationDetect1
parameter_list|(
name|struct
name|X
modifier|*
name|s2
parameter_list|)
block|{
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
literal|0
expr_stmt|;
name|px
operator|=
name|s2
expr_stmt|;
return|return
name|px
return|;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
end_function

begin_function
name|struct
name|X
modifier|*
name|RegInvalidationGiveUp1
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|struct
name|X
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|X
argument_list|)
argument_list|)
decl_stmt|;
name|px
operator|->
name|p
operator|=
name|p
expr_stmt|;
return|return
name|px
return|;
block|}
end_function

begin_function
name|int
modifier|*
modifier|*
name|RegInvalidationDetect2
parameter_list|(
name|int
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|pp
operator|=
operator|&
name|p
expr_stmt|;
name|pp
operator|++
expr_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|(
name|int
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|mallocExit
parameter_list|(
name|int
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|xx
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|__assert_fail
parameter_list|(
name|__const
name|char
modifier|*
name|__assertion
parameter_list|,
name|__const
name|char
modifier|*
name|__file
parameter_list|,
name|unsigned
name|int
name|__line
parameter_list|,
name|__const
name|char
modifier|*
name|__function
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expr
parameter_list|)
define|\
value|((expr)  ? (void)(0)  : __assert_fail (#expr, __FILE__, __LINE__, __func__))
end_define

begin_function
name|void
name|mallocAssert
parameter_list|(
name|int
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|xx
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|g
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|doNotInvalidateWhenPassedToSystemCalls
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_comment
comment|// Treat source buffer contents as escaped.
end_comment

begin_function
name|void
name|escapeSourceContents
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|// no warning
name|void
modifier|*
name|p1
init|=
name|malloc
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|p1
argument_list|,
sizeof|sizeof
name|a
argument_list|)
expr_stmt|;
comment|// FIXME: No warning due to limitations imposed by current modelling of
comment|// 'memcpy' (regions metadata is not copied).
name|int
modifier|*
name|ptrs
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|allocated
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptrs
index|[
literal|0
index|]
argument_list|,
operator|&
name|allocated
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|// FIXME: No warning due to limitations imposed by current modelling of
comment|// 'memcpy' (regions metadata is not copied).
block|}
end_function

begin_function
name|void
name|invalidateDestinationContents
parameter_list|()
block|{
name|int
modifier|*
name|null
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|null
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptrs1
index|[
literal|2
index|]
decl_stmt|;
comment|// expected-warning {{Potential leak of memory pointed to by}}
name|ptrs1
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptrs1
argument_list|,
operator|&
name|null
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptrs2
index|[
literal|2
index|]
decl_stmt|;
comment|// expected-warning {{Potential memory leak}}
name|ptrs2
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptrs2
index|[
literal|1
index|]
argument_list|,
operator|&
name|null
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|int
modifier|*
name|ptrs3
index|[
literal|2
index|]
decl_stmt|;
comment|// expected-warning {{Potential memory leak}}
name|ptrs3
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptrs3
index|[
literal|0
index|]
argument_list|,
operator|&
name|null
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential memory leak}}
end_comment

begin_comment
comment|// Rely on the CString checker evaluation of the strcpy API to convey that the result of strcpy is equal to p.
end_comment

begin_function
name|void
name|symbolLostWithStrcpy
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// The same test as the one above, but with what is actually generated on a mac.
end_comment

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|__inline_strcpy_chk
parameter_list|(
name|char
modifier|*
specifier|restrict
name|__dest
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|__src
parameter_list|)
block|{
return|return
name|__builtin___strcpy_chk
argument_list|(
name|__dest
argument_list|,
name|__src
argument_list|,
name|__builtin_object_size
argument_list|(
name|__dest
argument_list|,
literal|2
operator|>
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|symbolLostWithStrcpy_InlineStrcpyVersion
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
operator|(
name|__builtin_object_size
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|?
name|__builtin___strcpy_chk
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|__builtin_object_size
argument_list|(
name|p
argument_list|,
literal|2
operator|>
literal|1
argument_list|)
argument_list|)
else|:
name|__inline_strcpy_chk
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Here we are returning a pointer one past the allocated value. An idiom which
end_comment

begin_comment
comment|// can be used for implementing special malloc. The correct uses of this might
end_comment

begin_comment
comment|// be rare enough so that we could keep this as a warning.
end_comment

begin_function
specifier|static
name|void
modifier|*
name|specialMalloc
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|// Potentially, the user could free the struct by performing pointer arithmetic on the return value.
end_comment

begin_comment
comment|// This is a variation of the specialMalloc issue, though probably would be more rare in correct code.
end_comment

begin_function
name|int
modifier|*
name|specialMallocWithStruct
parameter_list|()
block|{
name|struct
name|StructWithInt
modifier|*
name|px
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|StructWithInt
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|&
operator|(
name|px
operator|->
name|g
operator|)
return|;
block|}
end_function

begin_comment
comment|// Test various allocation/deallocation functions.
end_comment

begin_function
name|void
name|testStrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|testWinStrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|_strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|testWcsdup
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|wchar_t
modifier|*
name|s2
init|=
name|wcsdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|void
name|testWinWcsdup
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|wchar_t
modifier|*
name|s2
init|=
name|_wcsdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{Potential leak of memory pointed to by}}
end_comment

begin_function
name|int
name|testStrndup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strndup
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|s2
index|[
name|validIndex
operator|+
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|validIndex
index|]
operator|!=
literal|'a'
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
comment|// expected-warning {{Potential leak of memory pointed to by}}
block|}
end_function

begin_function
name|void
name|testStrdupContentIsDefined
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|s2
index|[
literal|1
index|]
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testWinStrdupContentIsDefined
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
name|_strdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
name|result
init|=
name|s2
index|[
literal|1
index|]
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testWcsdupContentIsDefined
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|wchar_t
modifier|*
name|s2
init|=
name|wcsdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|wchar_t
name|result
init|=
name|s2
index|[
literal|1
index|]
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testWinWcsdupContentIsDefined
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|validIndex
parameter_list|)
block|{
name|wchar_t
modifier|*
name|s2
init|=
name|_wcsdup
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|wchar_t
name|result
init|=
name|s2
index|[
literal|1
index|]
decl_stmt|;
comment|// no warning
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------------
end_comment

begin_comment
comment|// Test the system library functions to which the pointer can escape.
end_comment

begin_comment
comment|// This tests false positive suppression.
end_comment

begin_comment
comment|// For now, we assume memory passed to pthread_specific escapes.
end_comment

begin_comment
comment|// TODO: We could check that if a new pthread binding is set, the existing
end_comment

begin_comment
comment|// binding must be freed; otherwise, a memory leak can occur.
end_comment

begin_function
name|void
name|testPthereadSpecificEscape
parameter_list|(
name|pthread_key_t
name|key
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|pthread_setspecific
argument_list|(
name|key
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_comment
comment|// PR12101: Test funopen().
end_comment

begin_function
specifier|static
name|int
name|releasePtr
parameter_list|(
name|void
modifier|*
name|_ctx
parameter_list|)
block|{
name|free
argument_list|(
name|_ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpen
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|releasePtr
argument_list|)
decl_stmt|;
comment|// no warning
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpenNoReleaseFunction
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_function
specifier|static
name|int
name|readNothing
parameter_list|(
name|void
modifier|*
name|_ctx
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|useFunOpenReadNoRelease
parameter_list|()
block|{
name|void
modifier|*
name|ctx
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
name|ctx
argument_list|,
name|readNothing
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_comment
comment|// Test setbuf, setvbuf.
end_comment

begin_function
name|int
name|my_main_no_warning
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|my_main_no_warning2
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setbuf
argument_list|(
name|__stdoutp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|my_main_warn
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|setvbuf
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|//<rdar://problem/10978247>.
end_comment

begin_comment
comment|// some people use stack allocated memory as an optimization to avoid
end_comment

begin_comment
comment|// a heap allocation for small work sizes.  This tests the analyzer's
end_comment

begin_comment
comment|// understanding that the malloc'ed memory is not the same as stackBuffer.
end_comment

begin_function
name|void
name|radar10978247
parameter_list|(
name|int
name|myValueSize
parameter_list|)
block|{
name|char
name|stackBuffer
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|myValueSize
operator|<=
sizeof|sizeof
argument_list|(
name|stackBuffer
argument_list|)
condition|)
name|buffer
operator|=
name|stackBuffer
expr_stmt|;
else|else
name|buffer
operator|=
name|malloc
argument_list|(
name|myValueSize
argument_list|)
expr_stmt|;
comment|// do stuff with the buffer
if|if
condition|(
name|buffer
operator|!=
name|stackBuffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|radar10978247_positive
parameter_list|(
name|int
name|myValueSize
parameter_list|)
block|{
name|char
name|stackBuffer
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|myValueSize
operator|<=
sizeof|sizeof
argument_list|(
name|stackBuffer
argument_list|)
condition|)
name|buffer
operator|=
name|stackBuffer
expr_stmt|;
else|else
name|buffer
operator|=
name|malloc
argument_list|(
name|myValueSize
argument_list|)
expr_stmt|;
comment|// do stuff with the buffer
if|if
condition|(
name|buffer
operator|==
name|stackBuffer
condition|)
return|return;
else|else
return|return;
comment|// expected-warning {{leak}}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|//<rdar://problem/11269741> Previously this triggered a false positive
end_comment

begin_comment
comment|// because malloc() is known to return uninitialized memory and the binding
end_comment

begin_comment
comment|// of 'o' to 'p->n' was not getting propertly handled.  Now we report a leak.
end_comment

begin_struct
struct|struct
name|rdar11269741_a_t
block|{
struct|struct
name|rdar11269741_b_t
block|{
name|int
name|m
decl_stmt|;
block|}
name|n
struct|;
block|}
struct|;
end_struct

begin_function
name|int
name|rdar11269741
parameter_list|(
name|struct
name|rdar11269741_b_t
name|o
parameter_list|)
block|{
name|struct
name|rdar11269741_a_t
modifier|*
name|p
init|=
operator|(
expr|struct
name|rdar11269741_a_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|n
operator|=
name|o
expr_stmt|;
return|return
name|p
operator|->
name|n
operator|.
name|m
return|;
comment|// expected-warning {{leak}}
block|}
end_function

begin_comment
comment|// Pointer arithmetic, returning an ElementRegion.
end_comment

begin_function
name|void
modifier|*
name|radar11329382
parameter_list|(
name|unsigned
name|bl
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|ptr
operator|+
operator|(
literal|2
operator|-
name|bl
operator|)
expr_stmt|;
return|return
name|ptr
return|;
comment|// no warning
block|}
end_function

begin_function_decl
name|void
name|__assert_rtn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|int
name|strcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|a
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|radar11270219
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|x
init|=
name|a
argument_list|()
decl_stmt|,
modifier|*
name|y
init|=
name|a
argument_list|()
decl_stmt|;
operator|(
name|__builtin_expect
argument_list|(
operator|!
operator|(
name|x
operator|&&
name|y
operator|)
argument_list|,
literal|0
argument_list|)
condition|?
name|__assert_rtn
argument_list|(
name|__func__
argument_list|,
literal|"/Users/zaks/tmp/ex.c"
argument_list|,
literal|24
argument_list|,
literal|"x&& y"
argument_list|)
else|:
operator|(
name|void
operator|)
literal|0
operator|)
expr_stmt|;
name|strcmp
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|radar_11358224_test_double_assign_ints_positive_2
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_comment
comment|// Assume that functions which take a function pointer can free memory even if
end_comment

begin_comment
comment|// they are defined in system headers and take the const pointer to the
end_comment

begin_comment
comment|// allocated memory. (radar://11160612)
end_comment

begin_function_decl
name|int
name|const_ptr_and_callback
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|n
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|r11160612_1
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|const_ptr_and_callback
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|// no - warning
block|}
end_function

begin_comment
comment|// Null is passed as callback.
end_comment

begin_function
name|void
name|r11160612_2
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|const_ptr_and_callback
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_comment
comment|// Callback is passed to a function defined in a system header.
end_comment

begin_function
name|void
name|r11160612_4
parameter_list|()
block|{
name|char
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|sqlite3_bind_text_my
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
literal|12
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|// no - warning
block|}
end_function

begin_comment
comment|// Passing callbacks in a struct.
end_comment

begin_function
name|void
name|r11160612_5
parameter_list|(
name|StWithCallback
name|St
parameter_list|)
block|{
name|void
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|dealocateMemWhenDoneByVal
argument_list|(
name|x
argument_list|,
name|St
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|r11160612_6
parameter_list|(
name|StWithCallback
name|St
parameter_list|)
block|{
name|void
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|dealocateMemWhenDoneByRef
argument_list|(
operator|&
name|St
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|mySub
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|myAdd
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|fPtr
parameter_list|(
name|unsigned
name|cond
parameter_list|,
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|cond
condition|?
name|mySub
else|:
name|myAdd
operator|)
operator|(
name|x
operator|,
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|// Test anti-aliasing.
end_comment

begin_function
name|void
name|dependsOnValueOfPtr
parameter_list|(
name|int
modifier|*
name|g
parameter_list|,
name|unsigned
name|f
parameter_list|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|p
operator|=
name|g
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|g
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
return|return;
comment|// no warning
return|return;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToStack
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x2
init|=
operator|&
name|x
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|x1
operator|==
name|x2
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToHeap2
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x2
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x4
init|=
name|x1
decl_stmt|;
name|int
modifier|*
name|x5
init|=
name|x2
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|x4
operator|==
name|x5
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x2
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|CMPRegionHeapToHeap
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x1
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|x4
init|=
name|x1
decl_stmt|;
if|if
condition|(
name|x1
operator|==
name|x4
condition|)
block|{
name|free
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
literal|5
operator|/
name|x
return|;
comment|// expected-warning{{Division by zero}}
block|}
return|return
name|x
return|;
comment|// expected-warning{{This statement is never executed}}
block|}
end_function

begin_function
name|int
name|HeapAssignment
parameter_list|()
block|{
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|x
init|=
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
modifier|*
name|y
init|=
name|x
decl_stmt|;
operator|*
name|x
operator|=
literal|5
expr_stmt|;
name|clang_analyzer_eval
argument_list|(
operator|*
name|x
operator|!=
operator|*
name|y
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|int
modifier|*
name|retPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
modifier|*
name|retPtrMightAlias
parameter_list|(
name|int
modifier|*
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|cmpHeapAllocationToUnknown
parameter_list|()
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|yBefore
init|=
name|retPtr
argument_list|()
decl_stmt|;
name|int
modifier|*
name|m
init|=
name|malloc
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
modifier|*
name|yAfter
init|=
name|retPtrMightAlias
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|clang_analyzer_eval
argument_list|(
name|yBefore
operator|==
name|m
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|clang_analyzer_eval
argument_list|(
name|yAfter
operator|==
name|m
argument_list|)
expr_stmt|;
comment|// expected-warning{{FALSE}}
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|localArrayTest
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|12
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ArrayL
index|[
literal|12
index|]
decl_stmt|;
name|ArrayL
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_function
name|void
name|localStructTest
parameter_list|()
block|{
name|StructWithPtr
name|St
decl_stmt|;
name|StructWithPtr
modifier|*
name|pSt
init|=
operator|&
name|St
decl_stmt|;
name|pSt
operator|->
name|memP
operator|=
name|malloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// expected-warning{{Potential leak of memory pointed to by}}
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__INTPTR_TYPE__
end_ifdef

begin_comment
comment|// Test double assignment through integers.
end_comment

begin_typedef
typedef|typedef
name|__INTPTR_TYPE__
name|intptr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|__INTPTR_TYPE__
name|uintptr_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|intptr_t
name|glob
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|test_double_assign_ints
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
comment|// no-warning
name|glob
operator|=
operator|(
name|intptr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_double_assign_ints_positive
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ptr
expr_stmt|;
comment|// expected-warning {{unused}}
block|}
end_function

begin_comment
comment|// expected-warning {{leak}}
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|testCGContextNoLeak
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|CGContextRef
name|context
init|=
name|CGBitmapContextCreate
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|// Because you can get the data back out like this, even much later,
comment|// CGBitmapContextCreate is one of our "stop-tracking" exceptions.
name|free
argument_list|(
name|CGBitmapContextGetData
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|testCGContextLeak
parameter_list|()
block|{
name|void
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|CGContextRef
name|context
init|=
name|CGBitmapContextCreate
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
comment|// However, this time we're just leaking the data, because the context
comment|// object doesn't escape and it hasn't been freed in this function.
block|}
end_function

begin_comment
comment|// Allow xpc context to escape. radar://11635258
end_comment

begin_comment
comment|// TODO: Would be great if we checked that the finalize_connection_context actually releases it.
end_comment

begin_function
specifier|static
name|void
name|finalize_connection_context
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
modifier|*
name|context
init|=
name|ctx
decl_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|foo
parameter_list|(
name|xpc_connection_t
name|peer
parameter_list|)
block|{
name|int
modifier|*
name|ctx
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|xpc_connection_set_context
argument_list|(
name|peer
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|xpc_connection_set_finalizer_f
argument_list|(
name|peer
argument_list|,
name|finalize_connection_context
argument_list|)
expr_stmt|;
name|xpc_connection_resume
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Make sure we catch errors when we free in a function which does not allocate memory.
end_comment

begin_function
name|void
name|freeButNoMalloc
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//user forgot a return here.
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
block|}
end_function

begin_struct
struct|struct
name|HasPtr
block|{
name|char
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|reallocButNoMalloc
parameter_list|(
name|struct
name|HasPtr
modifier|*
name|a
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|realloc
argument_list|(
name|a
operator|->
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|m
init|=
name|realloc
argument_list|(
name|a
operator|->
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
comment|// expected-warning {{Attempt to free released memory}}
comment|// We don't expect a use-after-free for a->P here because the warning above
comment|// is a sink.
return|return
name|a
operator|->
name|p
return|;
comment|// no-warning
block|}
end_function

begin_comment
comment|// We should not warn in this case since the caller will presumably free a->p in all cases.
end_comment

begin_function
name|int
name|reallocButNoMallocPR13674
parameter_list|(
name|struct
name|HasPtr
modifier|*
name|a
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|realloc
argument_list|(
name|a
operator|->
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|a
operator|->
name|p
operator|=
name|b
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// Test realloc with no visible malloc.
end_comment

begin_function
name|void
modifier|*
name|test
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|void
modifier|*
name|newPtr
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPtr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
return|return
name|newPtr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|testLeakWithinReturn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|strdup
argument_list|(
name|strdup
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_function
name|char
modifier|*
name|testWinLeakWithinReturn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|_strdup
argument_list|(
name|_strdup
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_function
name|wchar_t
modifier|*
name|testWinWideLeakWithinReturn
parameter_list|(
name|wchar_t
modifier|*
name|str
parameter_list|)
block|{
return|return
name|_wcsdup
argument_list|(
name|_wcsdup
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
comment|// expected-warning{{leak}}
block|}
end_function

begin_function_decl
name|void
name|passConstPtr
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|testPassConstPointer
parameter_list|()
block|{
name|char
modifier|*
name|string
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|10
argument_list|)
decl_stmt|;
name|passConstPtr
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
comment|// expected-warning {{leak}}
block|}
end_function

begin_function
name|void
name|testPassConstPointerIndirectly
parameter_list|()
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|memcmp
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// expected-warning {{leak}}
block|}
end_function

begin_function
name|void
name|testPassConstPointerIndirectlyStruct
parameter_list|()
block|{
name|struct
name|HasPtr
name|hp
decl_stmt|;
name|hp
operator|.
name|p
operator|=
name|malloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|memcmp
argument_list|(
operator|&
name|hp
argument_list|,
operator|&
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// expected-warning {{Potential leak of memory pointed to by 'hp.p'}}
block|}
end_function

begin_function
name|void
name|testPassToSystemHeaderFunctionIndirectlyStruct
parameter_list|()
block|{
name|SomeStruct
name|ss
decl_stmt|;
name|ss
operator|.
name|p
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fakeSystemHeaderCall
argument_list|(
operator|&
name|ss
argument_list|)
expr_stmt|;
comment|// invalidates ss, making ss.p unreachable
comment|// Technically a false negative here -- we know the system function won't free
comment|// ss.p, but nothing else will either!
block|}
end_function

begin_comment
comment|// no-warning
end_comment

begin_function
name|void
name|testPassToSystemHeaderFunctionIndirectlyStructFree
parameter_list|()
block|{
name|SomeStruct
name|ss
decl_stmt|;
name|ss
operator|.
name|p
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fakeSystemHeaderCall
argument_list|(
operator|&
name|ss
argument_list|)
expr_stmt|;
comment|// invalidates ss, making ss.p unreachable
name|free
argument_list|(
name|ss
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// no-warning
end_comment

begin_function
name|void
name|testPassToSystemHeaderFunctionIndirectlyArray
parameter_list|()
block|{
name|int
modifier|*
name|p
index|[
literal|1
index|]
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fakeSystemHeaderCallIntPtr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// invalidates p, making p[0] unreachable
comment|// Technically a false negative here -- we know the system function won't free
comment|// p[0], but nothing else will either!
block|}
end_function

begin_comment
comment|// no-warning
end_comment

begin_function
name|void
name|testPassToSystemHeaderFunctionIndirectlyArrayFree
parameter_list|()
block|{
name|int
modifier|*
name|p
index|[
literal|1
index|]
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fakeSystemHeaderCallIntPtr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// invalidates p, making p[0] unreachable
name|free
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// no-warning
end_comment

begin_function
name|int
modifier|*
name|testOffsetAllocate
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|int
modifier|*
name|memoryBlock
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|&
name|memoryBlock
index|[
literal|1
index|]
return|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testOffsetDeallocate
parameter_list|(
name|int
modifier|*
name|memoryBlock
parameter_list|)
block|{
name|free
argument_list|(
operator|&
name|memoryBlock
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testOffsetOfRegionFreed
parameter_list|()
block|{
name|__int64_t
modifier|*
name|array
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__int64_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|array
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|&
name|array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// expected-warning{{Argument to free() is offset by 8 bytes from the start of memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testOffsetOfRegionFreed2
parameter_list|()
block|{
name|__int64_t
modifier|*
name|p
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__int64_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Argument to free() is offset by 8 bytes from the start of memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testOffsetOfRegionFreed3
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|=
name|r
operator|-
literal|10
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is offset by -10 bytes from the start of memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testOffsetOfRegionFreedAfterFunctionCall
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|myfoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning{{Argument to free() is offset by 4 bytes from the start of memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testFixManipulatedPointerBeforeFree
parameter_list|()
block|{
name|int
modifier|*
name|array
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|array
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|&
name|array
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testFixManipulatedPointerBeforeFree2
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|=
name|r
operator|+
literal|10
expr_stmt|;
name|free
argument_list|(
name|r
operator|-
literal|10
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|freeOffsetPointerPassedToFunction
parameter_list|()
block|{
name|__int64_t
modifier|*
name|p
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__int64_t
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|myfooint
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|// not passing the pointer, only a value pointed by pointer
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is offset by 8 bytes from the start of memory allocated by malloc()}}
block|}
end_function

begin_function_decl
name|int
name|arbitraryInt
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|freeUnknownOffsetPointer
parameter_list|()
block|{
name|char
modifier|*
name|r
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|=
name|r
operator|+
name|arbitraryInt
argument_list|()
expr_stmt|;
comment|// unable to reason about what the offset might be
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testFreeNonMallocPointerWithNoOffset
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|r
init|=
operator|&
name|c
decl_stmt|;
name|r
operator|=
name|r
operator|+
literal|10
expr_stmt|;
name|free
argument_list|(
name|r
operator|-
literal|10
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is the address of the local variable 'c', which is not memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testFreeNonMallocPointerWithOffset
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|r
init|=
operator|&
name|c
decl_stmt|;
name|free
argument_list|(
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is the address of the local variable 'c', which is not memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testOffsetZeroDoubleFree
parameter_list|()
block|{
name|int
modifier|*
name|array
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|)
decl_stmt|;
name|int
modifier|*
name|p
init|=
operator|&
name|array
index|[
literal|0
index|]
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|&
name|array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// expected-warning{{Attempt to free released memory}}
block|}
end_function

begin_function
name|void
name|testOffsetPassedToStrlen
parameter_list|()
block|{
name|char
modifier|*
name|string
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|10
argument_list|)
decl_stmt|;
name|string
operator|+=
literal|1
expr_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
comment|// expected-warning {{Potential leak of memory pointed to by 'string'}}
block|}
end_function

begin_function
name|void
name|testOffsetPassedToStrlenThenFree
parameter_list|()
block|{
name|char
modifier|*
name|string
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|10
argument_list|)
decl_stmt|;
name|string
operator|+=
literal|1
expr_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is offset by 1 byte from the start of memory allocated by malloc()}}
block|}
end_function

begin_function
name|void
name|testOffsetPassedAsConst
parameter_list|()
block|{
name|char
modifier|*
name|string
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|10
argument_list|)
decl_stmt|;
name|string
operator|+=
literal|1
expr_stmt|;
name|passConstPtr
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is offset by 1 byte from the start of memory allocated by malloc()}}
block|}
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|_vectorSegments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_nVectorSegments
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|poolFreeC
parameter_list|(
name|void
modifier|*
name|s
parameter_list|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|freeMemory
parameter_list|()
block|{
while|while
condition|(
name|_nVectorSegments
condition|)
block|{
name|poolFreeC
argument_list|(
name|_vectorSegments
index|[
name|_nVectorSegments
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// PR16730
end_comment

begin_function
name|void
name|testReallocEscaped
parameter_list|(
name|void
modifier|*
modifier|*
name|memory
parameter_list|)
block|{
operator|*
name|memory
operator|=
name|malloc
argument_list|(
literal|47
argument_list|)
expr_stmt|;
name|char
modifier|*
name|new_memory
init|=
name|realloc
argument_list|(
operator|*
name|memory
argument_list|,
literal|47
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_memory
operator|!=
literal|0
condition|)
block|{
operator|*
name|memory
operator|=
name|new_memory
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// PR16558
end_comment

begin_function
name|void
modifier|*
name|smallocNoWarn
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|malloc
argument_list|(
literal|1
argument_list|)
return|;
comment|// this branch is never called
block|}
else|else
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|dupstrNoWarn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|smallocNoWarn
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// no-warning
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|smallocWarn
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
return|return
name|malloc
argument_list|(
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|dupstrWarn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|smallocWarn
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// expected-warning{{String copy function overflows destination buffer}}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
modifier|*
name|radar15580979
parameter_list|()
block|{
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|int
modifier|*
name|p
init|=
name|data
condition|?
else|:
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|32
argument_list|)
decl_stmt|;
comment|// no warning
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|// Some data structures may hold onto the pointer and free it later.
end_comment

begin_function
name|void
name|testEscapeThroughSystemCallTakingVoidPointer1
parameter_list|(
name|void
modifier|*
name|queue
parameter_list|)
block|{
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|fake_insque
argument_list|(
name|queue
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_function
name|void
name|testEscapeThroughSystemCallTakingVoidPointer2
parameter_list|(
name|fake_rb_tree_t
modifier|*
name|rbt
parameter_list|)
block|{
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|fake_rb_tree_init
argument_list|(
name|rbt
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//expected-warning{{Potential leak}}
end_comment

begin_function
name|void
name|testEscapeThroughSystemCallTakingVoidPointer3
parameter_list|(
name|fake_rb_tree_t
modifier|*
name|rbt
parameter_list|)
block|{
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|fake_rb_tree_init
argument_list|(
name|rbt
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fake_rb_tree_insert_node
argument_list|(
name|rbt
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|// no warning
block|}
end_function

begin_struct
struct|struct
name|IntAndPtr
block|{
name|int
name|x
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|constEscape
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|testConstEscapeThroughAnotherField
parameter_list|()
block|{
name|struct
name|IntAndPtr
name|s
decl_stmt|;
name|s
operator|.
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|constEscape
argument_list|(
operator|&
operator|(
name|s
operator|.
name|x
operator|)
argument_list|)
expr_stmt|;
comment|// could free s->p!
block|}
end_function

begin_comment
comment|// no-warning
end_comment

begin_comment
comment|// PR15623
end_comment

begin_function
name|int
name|testNoCheckerDataPropogationFromLogicalOpOperandToOpResult
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|param
init|=
name|malloc
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|malloc
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
operator|(
name|param
operator|&&
name|value
operator|)
decl_stmt|;
name|free
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// Previously we ended up with 'Use of memory after it is freed' on return.
return|return
name|ok
return|;
comment|// no warning
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|freeIndirectFunctionPtr
parameter_list|()
block|{
name|void
modifier|*
name|p
init|=
operator|(
name|void
operator|*
operator|)
name|fnptr
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is a function pointer}}
block|}
end_function

begin_function
name|void
name|freeFunctionPtr
parameter_list|()
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fnptr
argument_list|)
expr_stmt|;
comment|// expected-warning {{Argument to free() is a function pointer}}
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------------
end_comment

begin_comment
comment|// False negatives.
end_comment

begin_function
name|void
name|testMallocWithParam
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|// FIXME: should warn here
block|}
end_function

begin_function
name|void
name|testMallocWithParam_2
parameter_list|(
name|int
modifier|*
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|// no-warning
block|}
end_function

begin_function
name|void
name|testPassToSystemHeaderFunctionIndirectly
parameter_list|()
block|{
name|int
modifier|*
name|p
init|=
name|malloc
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|fakeSystemHeaderCallInt
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// FIXME: This is a leak: if we think a system function won't free p, it
comment|// won't free (p-1) either.
block|}
end_function

begin_function
name|void
name|testMallocIntoMalloc
parameter_list|()
block|{
name|StructWithPtr
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|StructWithPtr
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|memP
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// FIXME: should warn here
end_comment

end_unit

