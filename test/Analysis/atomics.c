begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// RUN: %clang_analyze_cc1 -analyzer-checker=core,debug.ExprInspection -verify %s
end_comment

begin_comment
comment|// Tests for c11 atomics. Many of these tests currently yield unknown
end_comment

begin_comment
comment|// because we don't fully model the atomics and instead imprecisely
end_comment

begin_comment
comment|// treat their arguments as escaping.
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uint32_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
name|memory_order
block|{
name|memory_order_relaxed
init|=
name|__ATOMIC_RELAXED
block|,
name|memory_order_consume
init|=
name|__ATOMIC_CONSUME
block|,
name|memory_order_acquire
init|=
name|__ATOMIC_ACQUIRE
block|,
name|memory_order_release
init|=
name|__ATOMIC_RELEASE
block|,
name|memory_order_acq_rel
init|=
name|__ATOMIC_ACQ_REL
block|,
name|memory_order_seq_cst
init|=
name|__ATOMIC_SEQ_CST
block|}
name|memory_order
typedef|;
end_typedef

begin_function_decl
name|void
name|clang_analyzer_eval
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|RefCountedStruct
block|{
name|uint32_t
name|refCount
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|test_atomic_fetch_add
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|uint32_t
name|result
init|=
name|__c11_atomic_fetch_add
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
operator|-
literal|1
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
comment|// When we model atomics fully this should (probably) be FALSE. It should never
comment|// be TRUE (because the operation mutates the passed in storage).
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
comment|// When fully modeled this should be TRUE
name|clang_analyzer_eval
argument_list|(
name|result
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

begin_function
name|void
name|test_atomic_load
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|uint32_t
name|result
init|=
name|__c11_atomic_load
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
comment|// When we model atomics fully this should (probably) be TRUE.
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
comment|// When fully modeled this should be TRUE
name|clang_analyzer_eval
argument_list|(
name|result
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

begin_function
name|void
name|test_atomic_store
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|__c11_atomic_store
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
literal|2
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
comment|// When we model atomics fully this should (probably) be FALSE. It should never
comment|// be TRUE (because the operation mutates the passed in storage).
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

begin_function
name|void
name|test_atomic_exchange
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|uint32_t
name|result
init|=
name|__c11_atomic_exchange
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
literal|2
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
comment|// When we model atomics fully this should (probably) be FALSE. It should never
comment|// be TRUE (because the operation mutates the passed in storage).
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
comment|// When fully modeled this should be TRUE
name|clang_analyzer_eval
argument_list|(
name|result
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

begin_function
name|void
name|test_atomic_compare_exchange_strong
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|uint32_t
name|expected
init|=
literal|2
decl_stmt|;
name|uint32_t
name|desired
init|=
literal|3
decl_stmt|;
name|_Bool
name|result
init|=
name|__c11_atomic_compare_exchange_strong
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
operator|&
name|expected
argument_list|,
name|desired
argument_list|,
name|memory_order_relaxed
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
comment|// For now we expect both expected and refCount to be invalidated by the
comment|// call. In the future we should model more precisely.
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|3
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
name|clang_analyzer_eval
argument_list|(
name|expected
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

begin_function
name|void
name|test_atomic_compare_exchange_weak
parameter_list|(
name|struct
name|RefCountedStruct
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|uint32_t
name|expected
init|=
literal|2
decl_stmt|;
name|uint32_t
name|desired
init|=
literal|3
decl_stmt|;
name|_Bool
name|result
init|=
name|__c11_atomic_compare_exchange_weak
argument_list|(
operator|(
specifier|volatile
expr|_Atomic
operator|(
name|uint32_t
operator|)
operator|*
operator|)
operator|&
name|s
operator|->
name|refCount
argument_list|,
operator|&
name|expected
argument_list|,
name|desired
argument_list|,
name|memory_order_relaxed
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
comment|// For now we expect both expected and refCount to be invalidated by the
comment|// call. In the future we should model more precisely.
name|clang_analyzer_eval
argument_list|(
name|s
operator|->
name|refCount
operator|==
literal|3
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
name|clang_analyzer_eval
argument_list|(
name|expected
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|// expected-warning {{UNKNOWN}}
block|}
end_function

end_unit

