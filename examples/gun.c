begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gun.c -- simple gunzip to give an example of the use of inflateBack()  * Copyright (C) 2003, 2005, 2008, 2010, 2012 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h    Version 1.7  12 August 2012  Mark Adler */
end_comment

begin_comment
comment|/* Version history:    1.0  16 Feb 2003  First version for testing of inflateBack()    1.1  21 Feb 2005  Decompress concatenated gzip streams                      Remove use of "this" variable (C++ keyword)                      Fix return value for in()                      Improve allocation failure checking                      Add typecasting for void * structures                      Add -h option for command version and usage                      Add a bunch of comments    1.2  20 Mar 2005  Add Unix compress (LZW) decompression                      Copy file attributes from input file to output file    1.3  12 Jun 2005  Add casts for error messages [Oberhumer]    1.4   8 Dec 2006  LZW decompression speed improvements    1.5   9 Feb 2008  Avoid warning in latest version of gcc    1.6  17 Jan 2010  Avoid signed/unsigned comparison warnings    1.7  12 Aug 2012  Update for z_const usage in zlib 1.2.8  */
end_comment

begin_comment
comment|/*    gun [ -t ] [ name ... ]     decompresses the data in the named gzip files.  If no arguments are given,    gun will decompress from stdin to stdout.  The names must end in .gz, -gz,    .z, -z, _z, or .Z.  The uncompressed data will be written to a file name    with the suffix stripped.  On success, the original file is deleted.  On    failure, the output file is deleted.  For most failures, the command will    continue to process the remaining names on the command line.  A memory    allocation failure will abort the command.  If -t is specified, then the    listed files or stdin will be tested as gzip files for integrity (without    checking for a proper suffix), no output will be written, and no files    will be deleted.     Like gzip, gun allows concatenated gzip streams and will decompress them,    writing all of the uncompressed data to the output.  Unlike gzip, gun allows    an empty file on input, and will produce no error writing an empty output    file.     gun will also decompress files made by Unix compress, which uses LZW    compression.  These files are automatically detected by virtue of their    magic header bytes.  Since the end of Unix compress stream is marked by the    end-of-file, they cannot be concantenated.  If a Unix compress stream is    encountered in an input file, it is the last stream in that file.     Like gunzip and uncompress, the file attributes of the orignal compressed    file are maintained in the final uncompressed file, to the extent that the    user permissions allow it.     On my Mac OS X PowerPC G4, gun is almost twice as fast as gunzip (version    1.2.4) is on the same file, when gun is linked with zlib 1.2.2.  Also the    LZW decompression provided by gun is about twice as fast as the standard    Unix uncompress command.  */
end_comment

begin_comment
comment|/* external functions and related types and constants */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf() */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc(), free() */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strerror(), strcmp(), strlen(), memcpy() */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* open() */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* read(), write(), close(), chown(), unlink() */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* stat(), chmod() */
end_comment

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_comment
comment|/* utime() */
end_comment

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* inflateBackInit(), inflateBack(), */
end_comment

begin_comment
comment|/* inflateBackEnd(), crc32() */
end_comment

begin_comment
comment|/* function declaration */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* buffer constants */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|32768U
end_define

begin_comment
comment|/* input and output buffer sizes */
end_comment

begin_define
define|#
directive|define
name|PIECE
value|16384
end_define

begin_comment
comment|/* limits i/o chunks for 16-bit int case */
end_comment

begin_comment
comment|/* structure for infback() to pass to input function in() -- it maintains the    input file and a buffer of size SIZE */
end_comment

begin_struct
struct|struct
name|ind
block|{
name|int
name|infile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Load input buffer, assumed to be empty, and return bytes loaded and a    pointer to them.  read() is called until the buffer is full, or until it    returns end-of-file or error.  Return 0 on error. */
end_comment

begin_function
name|local
name|unsigned
name|in
parameter_list|(
name|void
modifier|*
name|in_desc
parameter_list|,
name|z_const
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next
decl_stmt|;
name|struct
name|ind
modifier|*
name|me
init|=
operator|(
expr|struct
name|ind
operator|*
operator|)
name|in_desc
decl_stmt|;
name|next
operator|=
name|me
operator|->
name|inbuf
expr_stmt|;
operator|*
name|buf
operator|=
name|next
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|PIECE
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|ret
operator|>
name|SIZE
operator|-
name|len
condition|)
name|ret
operator|=
call|(
name|int
call|)
argument_list|(
name|SIZE
operator|-
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|int
operator|)
name|read
argument_list|(
name|me
operator|->
name|infile
argument_list|,
name|next
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|next
operator|+=
name|ret
expr_stmt|;
name|len
operator|+=
name|ret
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|len
operator|<
name|SIZE
condition|)
do|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* structure for infback() to pass to output function out() -- it maintains the    output file, a running CRC-32 check on the output and the total number of    bytes output, both for checking against the gzip trailer.  (The length in    the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and    the output is greater than 4 GB.) */
end_comment

begin_struct
struct|struct
name|outd
block|{
name|int
name|outfile
decl_stmt|;
name|int
name|check
decl_stmt|;
comment|/* true if checking crc and total */
name|unsigned
name|long
name|crc
decl_stmt|;
name|unsigned
name|long
name|total
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Write output buffer and update the CRC-32 and total bytes written.  write()    is called until all of the output is written or an error is encountered.    On success out() returns 0.  For a write failure, out() returns 1.  If the    output file descriptor is -1, then nothing is written.  */
end_comment

begin_function
name|local
name|int
name|out
parameter_list|(
name|void
modifier|*
name|out_desc
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|outd
modifier|*
name|me
init|=
operator|(
expr|struct
name|outd
operator|*
operator|)
name|out_desc
decl_stmt|;
if|if
condition|(
name|me
operator|->
name|check
condition|)
block|{
name|me
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|me
operator|->
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|me
operator|->
name|total
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|outfile
operator|!=
operator|-
literal|1
condition|)
do|do
block|{
name|ret
operator|=
name|PIECE
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|ret
operator|>
name|len
condition|)
name|ret
operator|=
operator|(
name|int
operator|)
name|len
expr_stmt|;
name|ret
operator|=
operator|(
name|int
operator|)
name|write
argument_list|(
name|me
operator|->
name|outfile
argument_list|,
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|buf
operator|+=
name|ret
expr_stmt|;
name|len
operator|-=
name|ret
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* next input byte macro for use inside lunpipe() and gunpipe() */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|(have ? 0 : (have = in(indp,&next)), \                 last = have ? (have--, (int)(*next++)) : -1)
end_define

begin_comment
comment|/* memory for gunpipe() and lunpipe() --    the first 256 entries of prefix[] and suffix[] are never used, could    have offset the index, but it's faster to waste the memory */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|inbuf
index|[
name|SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input buffer */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|outbuf
index|[
name|SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|prefix
index|[
literal|65536
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index to LZW prefix string */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|suffix
index|[
literal|65536
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one-character LZW suffix */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|match
index|[
literal|65280
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for reversed match or gzip                                            32K sliding window */
end_comment

begin_comment
comment|/* throw out what's left in the current bits byte buffer (this is a vestigial    aspect of the compressed data format derived from an implementation that    made use of a special VAX machine instruction!) */
end_comment

begin_define
define|#
directive|define
name|FLUSHCODE
parameter_list|()
define|\
value|do { \         left = 0; \         rem = 0; \         if (chunk> have) { \             chunk -= have; \             have = 0; \             if (NEXT() == -1) \                 break; \             chunk--; \             if (chunk> have) { \                 chunk = have = 0; \                 break; \             } \         } \         have -= chunk; \         next += chunk; \         chunk = 0; \     } while (0)
end_define

begin_comment
comment|/* Decompress a compress (LZW) file from indp to outfile.  The compress magic    header (two bytes) has already been read and verified.  There are have bytes    of buffered input at next.  strm is used for passing error information back    to gunpipe().     lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of    file, read error, or write error (a write error indicated by strm->next_in    not equal to Z_NULL), or Z_DATA_ERROR for invalid input.  */
end_comment

begin_function
name|local
name|int
name|lunpipe
parameter_list|(
name|unsigned
name|have
parameter_list|,
name|z_const
name|unsigned
name|char
modifier|*
name|next
parameter_list|,
name|struct
name|ind
modifier|*
name|indp
parameter_list|,
name|int
name|outfile
parameter_list|,
name|z_stream
modifier|*
name|strm
parameter_list|)
block|{
name|int
name|last
decl_stmt|;
comment|/* last byte read by NEXT(), or -1 if EOF */
name|unsigned
name|chunk
decl_stmt|;
comment|/* bytes left in current chunk */
name|int
name|left
decl_stmt|;
comment|/* bits left in rem */
name|unsigned
name|rem
decl_stmt|;
comment|/* unused bits from input */
name|int
name|bits
decl_stmt|;
comment|/* current bits per code */
name|unsigned
name|code
decl_stmt|;
comment|/* code, table traversal index */
name|unsigned
name|mask
decl_stmt|;
comment|/* mask for current bits codes */
name|int
name|max
decl_stmt|;
comment|/* maximum bits per code for this stream */
name|unsigned
name|flags
decl_stmt|;
comment|/* compress flags, then block compress flag */
name|unsigned
name|end
decl_stmt|;
comment|/* last valid entry in prefix/suffix tables */
name|unsigned
name|temp
decl_stmt|;
comment|/* current code */
name|unsigned
name|prev
decl_stmt|;
comment|/* previous code */
name|unsigned
name|final
decl_stmt|;
comment|/* last character written for previous code */
name|unsigned
name|stack
decl_stmt|;
comment|/* next position for reversed string */
name|unsigned
name|outcnt
decl_stmt|;
comment|/* bytes in output buffer */
name|struct
name|outd
name|outd
decl_stmt|;
comment|/* output structure */
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* set up output */
name|outd
operator|.
name|outfile
operator|=
name|outfile
expr_stmt|;
name|outd
operator|.
name|check
operator|=
literal|0
expr_stmt|;
comment|/* process remainder of compress header -- a flags byte */
name|flags
operator|=
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
return|return
name|Z_BUF_ERROR
return|;
if|if
condition|(
name|flags
operator|&
literal|0x60
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown lzw flags set"
expr_stmt|;
return|return
name|Z_DATA_ERROR
return|;
block|}
name|max
operator|=
name|flags
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|9
operator|||
name|max
operator|>
literal|16
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"lzw bits out of range"
expr_stmt|;
return|return
name|Z_DATA_ERROR
return|;
block|}
if|if
condition|(
name|max
operator|==
literal|9
condition|)
comment|/* 9 doesn't really mean 9 */
name|max
operator|=
literal|10
expr_stmt|;
name|flags
operator|&=
literal|0x80
expr_stmt|;
comment|/* true if block compress */
comment|/* clear table */
name|bits
operator|=
literal|9
expr_stmt|;
name|mask
operator|=
literal|0x1ff
expr_stmt|;
name|end
operator|=
name|flags
condition|?
literal|256
else|:
literal|255
expr_stmt|;
comment|/* set up: get first 9-bit code, which is the first decompressed byte, but        don't create a table entry until the next code */
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* no compressed data is ok */
return|return
name|Z_OK
return|;
name|final
operator|=
name|prev
operator|=
operator|(
name|unsigned
operator|)
name|last
expr_stmt|;
comment|/* low 8 bits of code */
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* missing a bit */
return|return
name|Z_BUF_ERROR
return|;
if|if
condition|(
name|last
operator|&
literal|1
condition|)
block|{
comment|/* code must be< 256 */
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid lzw code"
expr_stmt|;
return|return
name|Z_DATA_ERROR
return|;
block|}
name|rem
operator|=
operator|(
name|unsigned
operator|)
name|last
operator|>>
literal|1
expr_stmt|;
comment|/* remaining 7 bits */
name|left
operator|=
literal|7
expr_stmt|;
name|chunk
operator|=
name|bits
operator|-
literal|2
expr_stmt|;
comment|/* 7 bytes left in this chunk */
name|outbuf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|final
expr_stmt|;
comment|/* write first decompressed byte */
name|outcnt
operator|=
literal|1
expr_stmt|;
comment|/* decode codes */
name|stack
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* if the table will be full after this, increment the code size */
if|if
condition|(
name|end
operator|>=
name|mask
operator|&&
name|bits
operator|<
name|max
condition|)
block|{
name|FLUSHCODE
argument_list|()
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|++
expr_stmt|;
block|}
comment|/* get a code of length bits */
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
comment|/* decrement chunk modulo bits */
name|chunk
operator|=
name|bits
expr_stmt|;
name|code
operator|=
name|rem
expr_stmt|;
comment|/* low bits of code */
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* EOF is end of compressed data */
comment|/* write remaining buffered output */
if|if
condition|(
name|outcnt
operator|&&
name|out
argument_list|(
operator|&
name|outd
argument_list|,
name|outbuf
argument_list|,
name|outcnt
argument_list|)
condition|)
block|{
name|strm
operator|->
name|next_in
operator|=
name|outbuf
expr_stmt|;
comment|/* signal write error */
return|return
name|Z_BUF_ERROR
return|;
block|}
return|return
name|Z_OK
return|;
block|}
name|code
operator|+=
operator|(
name|unsigned
operator|)
name|last
operator|<<
name|left
expr_stmt|;
comment|/* middle (or high) bits of code */
name|left
operator|+=
literal|8
expr_stmt|;
name|chunk
operator|--
expr_stmt|;
if|if
condition|(
name|bits
operator|>
name|left
condition|)
block|{
comment|/* need more bits */
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* can't end in middle of code */
return|return
name|Z_BUF_ERROR
return|;
name|code
operator|+=
operator|(
name|unsigned
operator|)
name|last
operator|<<
name|left
expr_stmt|;
comment|/* high bits of code */
name|left
operator|+=
literal|8
expr_stmt|;
name|chunk
operator|--
expr_stmt|;
block|}
name|code
operator|&=
name|mask
expr_stmt|;
comment|/* mask to current code length */
name|left
operator|-=
name|bits
expr_stmt|;
comment|/* number of unused bits */
name|rem
operator|=
operator|(
name|unsigned
operator|)
name|last
operator|>>
operator|(
literal|8
operator|-
name|left
operator|)
expr_stmt|;
comment|/* unused bits from last byte */
comment|/* process clear code (256) */
if|if
condition|(
name|code
operator|==
literal|256
operator|&&
name|flags
condition|)
block|{
name|FLUSHCODE
argument_list|()
expr_stmt|;
name|bits
operator|=
literal|9
expr_stmt|;
comment|/* initialize bits and mask */
name|mask
operator|=
literal|0x1ff
expr_stmt|;
name|end
operator|=
literal|255
expr_stmt|;
comment|/* empty table */
continue|continue;
comment|/* get next code */
block|}
comment|/* special code to reuse last match */
name|temp
operator|=
name|code
expr_stmt|;
comment|/* save the current code */
if|if
condition|(
name|code
operator|>
name|end
condition|)
block|{
comment|/* Be picky on the allowed code here, and make sure that the code                we drop through (prev) will be a valid index so that random                input does not cause an exception.  The code != end + 1 check is                empirically derived, and not checked in the original uncompress                code.  If this ever causes a problem, that check could be safely                removed.  Leaving this check in greatly improves gun's ability                to detect random or corrupted input after a compress header.                In any case, the prev> end check must be retained. */
if|if
condition|(
name|code
operator|!=
name|end
operator|+
literal|1
operator|||
name|prev
operator|>
name|end
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid lzw code"
expr_stmt|;
return|return
name|Z_DATA_ERROR
return|;
block|}
name|match
index|[
name|stack
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|final
expr_stmt|;
name|code
operator|=
name|prev
expr_stmt|;
block|}
comment|/* walk through linked list to generate output in reverse order */
name|p
operator|=
name|match
operator|+
name|stack
expr_stmt|;
while|while
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|suffix
index|[
name|code
index|]
expr_stmt|;
name|code
operator|=
name|prefix
index|[
name|code
index|]
expr_stmt|;
block|}
name|stack
operator|=
name|p
operator|-
name|match
expr_stmt|;
name|match
index|[
name|stack
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|code
expr_stmt|;
name|final
operator|=
name|code
expr_stmt|;
comment|/* link new table entry */
if|if
condition|(
name|end
operator|<
name|mask
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|prefix
index|[
name|end
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|prev
expr_stmt|;
name|suffix
index|[
name|end
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|final
expr_stmt|;
block|}
comment|/* set previous code for next iteration */
name|prev
operator|=
name|temp
expr_stmt|;
comment|/* write output in forward order */
while|while
condition|(
name|stack
operator|>
name|SIZE
operator|-
name|outcnt
condition|)
block|{
while|while
condition|(
name|outcnt
operator|<
name|SIZE
condition|)
name|outbuf
index|[
name|outcnt
operator|++
index|]
operator|=
name|match
index|[
operator|--
name|stack
index|]
expr_stmt|;
if|if
condition|(
name|out
argument_list|(
operator|&
name|outd
argument_list|,
name|outbuf
argument_list|,
name|outcnt
argument_list|)
condition|)
block|{
name|strm
operator|->
name|next_in
operator|=
name|outbuf
expr_stmt|;
comment|/* signal write error */
return|return
name|Z_BUF_ERROR
return|;
block|}
name|outcnt
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|match
operator|+
name|stack
expr_stmt|;
do|do
block|{
name|outbuf
index|[
name|outcnt
operator|++
index|]
operator|=
operator|*
operator|--
name|p
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|>
name|match
condition|)
do|;
name|stack
operator|=
literal|0
expr_stmt|;
comment|/* loop for next code with final and prev as the last match, rem and            left provide the first 0..7 bits of the next code, end is the last            valid table entry */
block|}
block|}
end_function

begin_comment
comment|/* Decompress a gzip file from infile to outfile.  strm is assumed to have been    successfully initialized with inflateBackInit().  The input file may consist    of a series of gzip streams, in which case all of them will be decompressed    to the output file.  If outfile is -1, then the gzip stream(s) integrity is    checked and nothing is written.     The return value is a zlib error code: Z_MEM_ERROR if out of memory,    Z_DATA_ERROR if the header or the compressed data is invalid, or if the    trailer CRC-32 check or length doesn't match, Z_BUF_ERROR if the input ends    prematurely or a write error occurs, or Z_ERRNO if junk (not a another gzip    stream) follows a valid gzip stream.  */
end_comment

begin_function
name|local
name|int
name|gunpipe
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|int
name|infile
parameter_list|,
name|int
name|outfile
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|unsigned
name|have
decl_stmt|,
name|flags
decl_stmt|,
name|len
decl_stmt|;
name|z_const
name|unsigned
name|char
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|struct
name|ind
name|ind
decl_stmt|,
modifier|*
name|indp
decl_stmt|;
name|struct
name|outd
name|outd
decl_stmt|;
comment|/* setup input buffer */
name|ind
operator|.
name|infile
operator|=
name|infile
expr_stmt|;
name|ind
operator|.
name|inbuf
operator|=
name|inbuf
expr_stmt|;
name|indp
operator|=
operator|&
name|ind
expr_stmt|;
comment|/* decompress concatenated gzip streams */
name|have
operator|=
literal|0
expr_stmt|;
comment|/* no input data read in yet */
name|first
operator|=
literal|1
expr_stmt|;
comment|/* looking for first gzip header */
name|strm
operator|->
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
comment|/* so Z_BUF_ERROR means EOF */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for the two magic header bytes for a gzip stream */
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|Z_OK
expr_stmt|;
break|break;
comment|/* empty gzip stream is ok */
block|}
if|if
condition|(
name|last
operator|!=
literal|31
operator|||
operator|(
name|NEXT
argument_list|()
operator|!=
literal|139
operator|&&
name|last
operator|!=
literal|157
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect header check"
expr_stmt|;
name|ret
operator|=
name|first
condition|?
name|Z_DATA_ERROR
else|:
name|Z_ERRNO
expr_stmt|;
break|break;
comment|/* not a gzip or compress header */
block|}
name|first
operator|=
literal|0
expr_stmt|;
comment|/* next non-header is junk */
comment|/* process a compress (LZW) file -- can't be concatenated after this */
if|if
condition|(
name|last
operator|==
literal|157
condition|)
block|{
name|ret
operator|=
name|lunpipe
argument_list|(
name|have
argument_list|,
name|next
argument_list|,
name|indp
argument_list|,
name|outfile
argument_list|,
name|strm
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* process remainder of gzip header */
name|ret
operator|=
name|Z_BUF_ERROR
expr_stmt|;
if|if
condition|(
name|NEXT
argument_list|()
operator|!=
literal|8
condition|)
block|{
comment|/* only deflate method allowed */
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
break|break;
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown compression method"
expr_stmt|;
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
break|break;
block|}
name|flags
operator|=
name|NEXT
argument_list|()
expr_stmt|;
comment|/* header flags */
name|NEXT
argument_list|()
expr_stmt|;
comment|/* discard mod time, xflgs, os */
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
literal|0xe0
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown header flags set"
expr_stmt|;
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
block|{
comment|/* extra field */
name|len
operator|=
name|NEXT
argument_list|()
expr_stmt|;
name|len
operator|+=
call|(
name|unsigned
call|)
argument_list|(
name|NEXT
argument_list|()
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
break|break;
while|while
condition|(
name|len
operator|>
name|have
condition|)
block|{
name|len
operator|-=
name|have
expr_stmt|;
name|have
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NEXT
argument_list|()
operator|==
operator|-
literal|1
condition|)
break|break;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
break|break;
name|have
operator|-=
name|len
expr_stmt|;
name|next
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|8
condition|)
comment|/* file name */
while|while
condition|(
name|NEXT
argument_list|()
operator|!=
literal|0
operator|&&
name|last
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|16
condition|)
comment|/* comment */
while|while
condition|(
name|NEXT
argument_list|()
operator|!=
literal|0
operator|&&
name|last
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
block|{
comment|/* header crc */
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* set up output */
name|outd
operator|.
name|outfile
operator|=
name|outfile
expr_stmt|;
name|outd
operator|.
name|check
operator|=
literal|1
expr_stmt|;
name|outd
operator|.
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outd
operator|.
name|total
operator|=
literal|0
expr_stmt|;
comment|/* decompress data to output */
name|strm
operator|->
name|next_in
operator|=
name|next
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|have
expr_stmt|;
name|ret
operator|=
name|inflateBack
argument_list|(
name|strm
argument_list|,
name|in
argument_list|,
name|indp
argument_list|,
name|out
argument_list|,
operator|&
name|outd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
break|break;
name|next
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
name|have
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
comment|/* so Z_BUF_ERROR means EOF */
comment|/* check trailer */
name|ret
operator|=
name|Z_BUF_ERROR
expr_stmt|;
if|if
condition|(
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
name|outd
operator|.
name|crc
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|crc
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|crc
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
condition|)
block|{
comment|/* crc error */
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect data check"
expr_stmt|;
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
name|outd
operator|.
name|total
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|total
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|total
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
operator|||
name|NEXT
argument_list|()
operator|!=
call|(
name|int
call|)
argument_list|(
operator|(
name|outd
operator|.
name|total
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
condition|)
block|{
comment|/* length error */
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect length check"
expr_stmt|;
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
break|break;
block|}
comment|/* go back and look for another gzip stream */
block|}
comment|/* clean up and return */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Copy file attributes, from -> to, as best we can.  This is best effort, so    no errors are reported.  The mode bits, including suid, sgid, and the sticky    bit are copied (if allowed), the owner's user id and group id are copied    (again if allowed), and the access and modify times are copied. */
end_comment

begin_function
name|local
name|void
name|copymeta
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|stat
name|was
decl_stmt|;
name|struct
name|utimbuf
name|when
decl_stmt|;
comment|/* get all of from's Unix meta data, return if not a regular file */
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|was
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|was
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
return|return;
comment|/* set to's mode bits, ignore errors */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|to
argument_list|,
name|was
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
comment|/* copy owner's user and group, ignore errors */
operator|(
name|void
operator|)
name|chown
argument_list|(
name|to
argument_list|,
name|was
operator|.
name|st_uid
argument_list|,
name|was
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* copy access and modify times, ignore errors */
name|when
operator|.
name|actime
operator|=
name|was
operator|.
name|st_atime
expr_stmt|;
name|when
operator|.
name|modtime
operator|=
name|was
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decompress the file inname to the file outnname, of if test is true, just    decompress without writing and check the gzip trailer for integrity.  If    inname is NULL or an empty string, read from stdin.  If outname is NULL or    an empty string, write to stdout.  strm is a pre-initialized inflateBack    structure.  When appropriate, copy the file attributes from inname to    outname.     gunzip() returns 1 if there is an out-of-memory error or an unexpected    return code from gunpipe().  Otherwise it returns 0.  */
end_comment

begin_function
name|local
name|int
name|gunzip
parameter_list|(
name|z_stream
modifier|*
name|strm
parameter_list|,
name|char
modifier|*
name|inname
parameter_list|,
name|char
modifier|*
name|outname
parameter_list|,
name|int
name|test
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|infile
decl_stmt|,
name|outfile
decl_stmt|;
comment|/* open files */
if|if
condition|(
name|inname
operator|==
name|NULL
operator|||
operator|*
name|inname
operator|==
literal|0
condition|)
block|{
name|inname
operator|=
literal|"-"
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
comment|/* stdin */
block|}
else|else
block|{
name|infile
operator|=
name|open
argument_list|(
name|inname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun cannot open %s\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|test
condition|)
name|outfile
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|outname
operator|==
name|NULL
operator|||
operator|*
name|outname
operator|==
literal|0
condition|)
block|{
name|outname
operator|=
literal|"-"
expr_stmt|;
name|outfile
operator|=
literal|1
expr_stmt|;
comment|/* stdout */
block|}
else|else
block|{
name|outfile
operator|=
name|open
argument_list|(
name|outname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun cannot create %s\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* decompress */
name|ret
operator|=
name|gunpipe
argument_list|(
name|strm
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|>
literal|2
condition|)
name|close
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|>
literal|2
condition|)
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* interpret result */
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_OK
case|:
case|case
name|Z_ERRNO
case|:
if|if
condition|(
name|infile
operator|>
literal|2
operator|&&
name|outfile
operator|>
literal|2
condition|)
block|{
name|copymeta
argument_list|(
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
comment|/* copy attributes */
name|unlink
argument_list|(
name|inname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_ERRNO
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun warning: trailing garbage ignored in %s\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
if|if
condition|(
name|outfile
operator|>
literal|2
condition|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun data error on %s: %s\n"
argument_list|,
name|inname
argument_list|,
name|strm
operator|->
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
if|if
condition|(
name|outfile
operator|>
literal|2
condition|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun out of memory error--aborting\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|Z_BUF_ERROR
case|:
if|if
condition|(
name|outfile
operator|>
literal|2
condition|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|next_in
operator|!=
name|Z_NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun write error on %s: %s\n"
argument_list|,
name|outname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun read error on %s: %s\n"
argument_list|,
name|inname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun unexpected end of file on %s\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|outfile
operator|>
literal|2
condition|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun internal error--aborting\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the gun command line arguments.  See the command syntax near the    beginning of this source file. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|,
name|test
decl_stmt|;
name|char
modifier|*
name|outname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|window
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
comment|/* initialize inflateBack state for repeated use */
name|window
operator|=
name|match
expr_stmt|;
comment|/* reuse LZW match buffer */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateBackInit
argument_list|(
operator|&
name|strm
argument_list|,
literal|15
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun out of memory error--aborting\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* decompress each file to the same name with the suffix removed */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|test
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun 1.6 (17 Jan 2010)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copyright (C) 2003-2010 Mark Adler\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: gun [-t] [file1.gz [file2.Z ...]]\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|argc
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-t"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|test
operator|=
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
condition|)
do|do
block|{
if|if
condition|(
name|test
condition|)
name|outname
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".gz"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|"-gz"
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|".z"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|"-z"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|"_z"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
literal|2
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun error: no gz type on %s--skipping\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outname
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gun out of memory error--aborting\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|outname
argument_list|,
operator|*
name|argv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outname
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|gunzip
argument_list|(
operator|&
name|strm
argument_list|,
operator|*
name|argv
argument_list|,
name|outname
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
do|while
condition|(
name|argv
operator|++
operator|,
operator|--
name|argc
condition|)
do|;
else|else
name|ret
operator|=
name|gunzip
argument_list|(
operator|&
name|strm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|test
argument_list|)
expr_stmt|;
comment|/* clean up */
name|inflateBackEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

