begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Reads a zone file from disk and prints it to stdout, one RR per line.  * Adds artificial DS records and RRs.  * For the purpose of generating a test zone file  *  * (c) SIDN 2010/2011 - Marco Davids/Miek Gieben  *  * See the LICENSE file for the license  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|NUM_DS
value|4
end_define

begin_comment
comment|/* maximum of 4 DS records per delegation */
end_comment

begin_define
define|#
directive|define
name|ALGO
value|8
end_define

begin_comment
comment|/* Algorithm to use for fake DS records - RSASHA256 - RFC5702  */
end_comment

begin_define
define|#
directive|define
name|DIGESTTYPE
value|2
end_define

begin_comment
comment|/* Digest type to use for fake DS records - SHA-256 - RFC 4509 */
end_comment

begin_comment
comment|/**  * Usage function.  *  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\nUsage: %s [-hsv] [-ap NUM] [-o ORIGIN] [<zonefile>]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tReads a zonefile and add some artificial NS RRsets and DS records.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tIf no zonefile is given, the zone is read from stdin.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-a<NUM> add NUM artifical delegations (NS RRSets) to output.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-p<NUM> add NUM percent of DS RRset's to the NS RRsets (1-%d RR's per DS RRset).\n"
argument_list|,
name|NUM_DS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-o ORIGIN sets an $ORIGIN, which can be handy if the one in the zonefile is set to @.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-s if input zone file is already sorted and canonicalized (ie all lowercase),\n\t   use this option to speed things up while inserting DS records.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-h show this text.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-v shows the version and exits.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nif no file is given standard input is read.\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Insert the DS records, return the amount added.  *  */
end_comment

begin_function
specifier|static
name|int
name|insert_ds
parameter_list|(
name|ldns_rdf
modifier|*
name|dsowner
parameter_list|,
name|uint32_t
name|ttl
parameter_list|)
block|{
name|int
name|d
decl_stmt|,
name|dsrand
decl_stmt|;
name|int
name|keytag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dsownerstr
decl_stmt|;
name|char
name|digeststr
index|[
literal|70
index|]
decl_stmt|;
comment|/**          * Average the amount of DS records per delegation a little.          */
name|dsrand
operator|=
literal|1
operator|+
name|rand
argument_list|()
operator|%
name|NUM_DS
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dsrand
condition|;
name|d
operator|++
control|)
block|{
name|keytag
operator|=
literal|1
operator|+
name|rand
argument_list|()
operator|%
literal|65535
expr_stmt|;
comment|/**                  * Dynamic hashes method below is still too slow... 20% slower than a fixed string...                  *                  * We assume RAND_MAX is 32 bit, http://www.gnu.org/s/libc/manual/html_node/ISO-Random.html                  * 2147483647 or 0x7FFFFFFF                  */
name|snprintf
argument_list|(
name|digeststr
argument_list|,
literal|65
argument_list|,
literal|"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x"
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|,
operator|(
name|unsigned
operator|)
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|)
expr_stmt|;
name|dsownerstr
operator|=
name|ldns_rdf2str
argument_list|(
name|dsowner
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\t%u\tIN\tDS\t%d %d %d %s\n"
argument_list|,
name|dsownerstr
argument_list|,
operator|(
name|unsigned
operator|)
name|ttl
argument_list|,
name|keytag
argument_list|,
name|ALGO
argument_list|,
name|DIGESTTYPE
argument_list|,
name|digeststr
argument_list|)
expr_stmt|;
block|}
return|return
name|dsrand
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|rrstr
decl_stmt|,
modifier|*
name|ownerstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|classtypestr1
init|=
literal|"IN NS ns1.example.com."
decl_stmt|;
specifier|const
name|char
modifier|*
name|classtypestr2
init|=
literal|"IN NS ns2.example.com."
decl_stmt|;
specifier|const
name|size_t
name|classtypelen
init|=
name|strlen
argument_list|(
name|classtypestr1
argument_list|)
decl_stmt|;
comment|/* Simply because this was developed by SIDN and we don't use xn-- for .nl :-) */
specifier|const
name|char
modifier|*
name|punystr
init|=
literal|"xn--fake-rr"
decl_stmt|;
specifier|const
name|size_t
name|punylen
init|=
name|strlen
argument_list|(
name|punystr
argument_list|)
decl_stmt|;
name|size_t
name|rrstrlen
decl_stmt|,
name|ownerlen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|nsrand
decl_stmt|;
name|uint32_t
name|ttl
decl_stmt|;
name|int
name|counta
decl_stmt|,
name|countd
decl_stmt|,
name|countr
decl_stmt|;
name|ldns_zone
modifier|*
name|z
decl_stmt|;
name|ldns_rdf
modifier|*
name|origin
init|=
name|NULL
decl_stmt|;
name|int
name|line_nr
init|=
literal|0
decl_stmt|;
name|int
name|addrrs
init|=
literal|0
decl_stmt|;
name|int
name|dsperc
init|=
literal|0
decl_stmt|;
name|bool
name|canonicalize
init|=
name|true
decl_stmt|;
name|bool
name|sort
init|=
name|true
decl_stmt|;
name|bool
name|do_ds
init|=
name|false
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ldns_rr_list
modifier|*
name|rrset_list
decl_stmt|;
name|ldns_rdf
modifier|*
name|owner
decl_stmt|;
name|ldns_rr_type
name|cur_rr_type
decl_stmt|;
name|ldns_rr
modifier|*
name|cur_rr
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|counta
operator|=
name|countd
operator|=
name|countr
operator|=
literal|0
expr_stmt|;
comment|/**          * Set some random seed.          */
name|srand
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * Commandline options.          */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:p:shvo:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|addrrs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrrs
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
name|origin
operator|=
name|ldns_rdf_new_frm_str
argument_list|(
name|LDNS_RDF_TYPE_DNAME
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: creating origin from -o %s failed.\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|dsperc
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsperc
operator|<=
literal|0
operator|||
name|dsperc
operator|>
literal|100
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: percentage of signed delegations must be between [0-100].\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|do_ds
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sort
operator|=
name|false
expr_stmt|;
name|canonicalize
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ldns-gen-zone version %s (ldns version %s)\n"
argument_list|,
name|LDNS_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTry -h for more information.\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/**          * Read zone.          */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|ldns_zone_new_frm_fp_l
argument_list|(
operator|&
name|z
argument_list|,
name|fp
argument_list|,
name|origin
argument_list|,
literal|0
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s at %d\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_zone_soa
argument_list|(
name|z
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No zone data seen\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|ttl
operator|=
name|ldns_rr_ttl
argument_list|(
name|ldns_zone_soa
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
condition|)
block|{
name|origin
operator|=
name|ldns_rr_owner
argument_list|(
name|ldns_zone_soa
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check for root (.) origin here TODO(MG)
block|}
name|ownerstr
operator|=
name|ldns_rdf2str
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ownerstr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns_rdf2str(origin) failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|ownerlen
operator|=
name|strlen
argument_list|(
name|ownerstr
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|ldns_zone_soa
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrrs
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|addrrs
operator|>
name|counta
condition|)
block|{
name|counta
operator|++
expr_stmt|;
name|rrstrlen
operator|=
name|punylen
operator|+
name|ownerlen
operator|+
name|classtypelen
operator|+
literal|4
expr_stmt|;
name|rrstrlen
operator|*=
literal|2
expr_stmt|;
comment|/* estimate */
name|rrstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|rrstrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrstr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc() failed: Out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rrstr
argument_list|,
name|rrstrlen
argument_list|,
literal|"%s%d.%s %u %s"
argument_list|,
name|punystr
argument_list|,
name|counta
argument_list|,
name|ownerstr
argument_list|,
operator|(
name|unsigned
operator|)
name|ttl
argument_list|,
name|classtypestr1
argument_list|)
expr_stmt|;
name|status
operator|=
name|ldns_rr_new_frm_str
argument_list|(
operator|&
name|cur_rr
argument_list|,
name|rrstr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|cur_rr
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns_rr_new_frm_str() failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rrstr
argument_list|,
name|rrstrlen
argument_list|,
literal|"%s%d.%s %u %s"
argument_list|,
name|punystr
argument_list|,
name|counta
argument_list|,
name|ownerstr
argument_list|,
operator|(
name|unsigned
operator|)
name|ttl
argument_list|,
name|classtypestr2
argument_list|)
expr_stmt|;
name|status
operator|=
name|ldns_rr_new_frm_str
argument_list|(
operator|&
name|cur_rr
argument_list|,
name|rrstr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|cur_rr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns_rr_new_frm_str() failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrstr
argument_list|)
expr_stmt|;
comment|/* may we add a DS record as well? */
if|if
condition|(
name|do_ds
condition|)
block|{
comment|/*                                  * Per definition this may not be the same as the origin, so no                                  * check required same for NS check - so the only thing left is some                                  * randomization.                                  */
name|nsrand
operator|=
name|rand
argument_list|()
operator|%
literal|100
expr_stmt|;
if|if
condition|(
name|nsrand
operator|<
name|dsperc
condition|)
block|{
name|owner
operator|=
name|ldns_rr_owner
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|ldns_rr_ttl
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
name|countd
operator|+=
name|insert_ds
argument_list|(
name|owner
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_rr_free
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|do_ds
condition|)
block|{
name|ldns_rr_list_print
argument_list|(
name|stdout
argument_list|,
name|ldns_zone_rrs
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                 * We use dns_rr_list_pop_rrset and that requires a sorted list weird things may happen                 * if the -s option was used on unsorted, non-canonicalized input                 */
if|if
condition|(
name|canonicalize
condition|)
block|{
name|ldns_rr2canonical
argument_list|(
name|ldns_zone_soa
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|z
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr2canonical
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|z
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sort
condition|)
block|{
name|ldns_zone_sort
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
comment|/* Work on a per RRset basis for DS records - weird things will happen if the -s option                  * was used in combination with an unsorted zone file                  */
while|while
condition|(
operator|(
name|rrset_list
operator|=
name|ldns_rr_list_pop_rrset
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|z
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|owner
operator|=
name|ldns_rr_list_owner
argument_list|(
name|rrset_list
argument_list|)
expr_stmt|;
name|cur_rr_type
operator|=
name|ldns_rr_list_type
argument_list|(
name|rrset_list
argument_list|)
expr_stmt|;
comment|/**                          * Print them...                          */
name|cur_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|rrset_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_rr
condition|)
block|{
name|ttl
operator|=
name|ldns_rr_ttl
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|ldns_rr2str
argument_list|(
name|cur_rr
argument_list|)
argument_list|)
expr_stmt|;
name|cur_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|rrset_list
argument_list|)
expr_stmt|;
block|}
comment|/*                          * And all the way at the end a DS record if                          * we are dealing with an NS rrset                          */
name|nsrand
operator|=
name|rand
argument_list|()
operator|%
literal|100
expr_stmt|;
if|if
condition|(
name|nsrand
operator|==
literal|0
condition|)
block|{
name|nsrand
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cur_rr_type
operator|==
name|LDNS_RR_TYPE_NS
operator|)
operator|&&
operator|(
name|ldns_rdf_compare
argument_list|(
name|owner
argument_list|,
name|origin
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nsrand
operator|<
name|dsperc
operator|)
condition|)
block|{
comment|/**                                  * No DS records for the $ORIGIN, only for delegations, obey dsperc.                                  */
name|countr
operator|++
expr_stmt|;
name|countd
operator|+=
name|insert_ds
argument_list|(
name|owner
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_free
argument_list|(
name|rrset_list
argument_list|)
expr_stmt|;
name|ldns_rdf_free
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * And done...          */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|";; Added %d DS records (percentage was %d) to %d NS RRset's (from input-zone: %d, from added: %d)\n;; lines in original input-zone: %d\n"
argument_list|,
name|countd
argument_list|,
name|dsperc
argument_list|,
name|counta
operator|+
name|countr
argument_list|,
name|countr
argument_list|,
name|counta
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

