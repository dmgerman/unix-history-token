begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzjoin -- command to join gzip files into one gzip file    Copyright (C) 2004, 2005, 2012 Mark Adler, all rights reserved   version 1.2, 14 Aug 2012    This software is provided 'as-is', without any express or implied   warranty.  In no event will the author be held liable for any damages   arising from the use of this software.    Permission is granted to anyone to use this software for any purpose,   including commercial applications, and to alter it and redistribute it   freely, subject to the following restrictions:    1. The origin of this software must not be misrepresented; you must not      claim that you wrote the original software. If you use this software      in a product, an acknowledgment in the product documentation would be      appreciated but is not required.   2. Altered source versions must be plainly marked as such, and must not be      misrepresented as being the original software.   3. This notice may not be removed or altered from any source distribution.    Mark Adler    madler@alumni.caltech.edu  */
end_comment

begin_comment
comment|/*  * Change history:  *  * 1.0  11 Dec 2004     - First version  * 1.1  12 Jun 2005     - Changed ssize_t to long for portability  * 1.2  14 Aug 2012     - Clean up for z_const usage  */
end_comment

begin_comment
comment|/*    gzjoin takes one or more gzip files on the command line and writes out a    single gzip file that will uncompress to the concatenation of the    uncompressed data from the individual gzip files.  gzjoin does this without    having to recompress any of the data and without having to calculate a new    crc32 for the concatenated uncompressed data.  gzjoin does however have to    decompress all of the input data in order to find the bits in the compressed    data that need to be modified to concatenate the streams.     gzjoin does not do an integrity check on the input gzip files other than    checking the gzip header and decompressing the compressed data.  They are    otherwise assumed to be complete and correct.     Each joint between gzip files removes at least 18 bytes of previous trailer    and subsequent header, and inserts an average of about three bytes to the    compressed data in order to connect the streams.  The output gzip file    has a minimal ten-byte gzip header with no file name or modification time.     This program was written to illustrate the use of the Z_BLOCK option of    inflate() and the crc32_combine() function.  gzjoin will not compile with    versions of zlib earlier than 1.2.3.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fputs(), fprintf(), fwrite(), putc() */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* exit(), malloc(), free() */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* open() */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* close(), read(), lseek() */
end_comment

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* exit with an error (return a value to allow use in an expression) */
end_comment

begin_function
name|local
name|int
name|bail
parameter_list|(
name|char
modifier|*
name|why1
parameter_list|,
name|char
modifier|*
name|why2
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gzjoin error: %s%s, output incomplete\n"
argument_list|,
name|why1
argument_list|,
name|why2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -- simple buffered file input with access to the buffer -- */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|32768
end_define

begin_comment
comment|/* must be a power of two and fit in unsigned */
end_comment

begin_comment
comment|/* bin buffered input file type */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of file for error messages */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|unsigned
name|left
decl_stmt|;
comment|/* bytes remaining at next */
name|unsigned
name|char
modifier|*
name|next
decl_stmt|;
comment|/* next byte to read */
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* allocated buffer of length CHUNK */
block|}
name|bin
typedef|;
end_typedef

begin_comment
comment|/* close a buffered file and free allocated memory */
end_comment

begin_function
name|local
name|void
name|bclose
parameter_list|(
name|bin
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|in
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|in
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* open a buffered file for input, return a pointer to type bin, or NULL on    failure */
end_comment

begin_function
name|local
name|bin
modifier|*
name|bopen
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bin
modifier|*
name|in
decl_stmt|;
name|in
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|in
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|CHUNK
argument_list|)
expr_stmt|;
name|in
operator|->
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|buf
operator|==
name|NULL
operator|||
name|in
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|bclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|in
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|next
operator|=
name|in
operator|->
name|buf
expr_stmt|;
name|in
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* load buffer from file, return -1 on read error, 0 or 1 on success, with    1 indicating that end-of-file was reached */
end_comment

begin_function
name|local
name|int
name|bload
parameter_list|(
name|bin
modifier|*
name|in
parameter_list|)
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|in
operator|->
name|left
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|in
operator|->
name|next
operator|=
name|in
operator|->
name|buf
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|(
name|long
operator|)
name|read
argument_list|(
name|in
operator|->
name|fd
argument_list|,
name|in
operator|->
name|buf
operator|+
name|in
operator|->
name|left
argument_list|,
name|CHUNK
operator|-
name|in
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|in
operator|->
name|left
operator|+=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
operator|&&
name|in
operator|->
name|left
operator|<
name|CHUNK
condition|)
do|;
return|return
name|len
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get a byte from the file, bail if end of file */
end_comment

begin_define
define|#
directive|define
name|bget
parameter_list|(
name|in
parameter_list|)
value|(in->left ? 0 : bload(in), \                   in->left ? (in->left--, *(in->next)++) : \                     bail("unexpected end of file on ", in->name))
end_define

begin_comment
comment|/* get a four-byte little-endian unsigned integer from file */
end_comment

begin_function
name|local
name|unsigned
name|long
name|bget4
parameter_list|(
name|bin
modifier|*
name|in
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
name|bget
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|val
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|bget
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|val
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|bget
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|val
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|bget
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
literal|24
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* skip bytes in file */
end_comment

begin_function
name|local
name|void
name|bskip
parameter_list|(
name|bin
modifier|*
name|in
parameter_list|,
name|unsigned
name|skip
parameter_list|)
block|{
comment|/* check pointer */
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return;
comment|/* easy case -- skip bytes in buffer */
if|if
condition|(
name|skip
operator|<=
name|in
operator|->
name|left
condition|)
block|{
name|in
operator|->
name|left
operator|-=
name|skip
expr_stmt|;
name|in
operator|->
name|next
operator|+=
name|skip
expr_stmt|;
return|return;
block|}
comment|/* skip what's in buffer, discard buffer contents */
name|skip
operator|-=
name|in
operator|->
name|left
expr_stmt|;
name|in
operator|->
name|left
operator|=
literal|0
expr_stmt|;
comment|/* seek past multiples of CHUNK bytes */
if|if
condition|(
name|skip
operator|>
name|CHUNK
condition|)
block|{
name|unsigned
name|left
decl_stmt|;
name|left
operator|=
name|skip
operator|&
operator|(
name|CHUNK
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
comment|/* exact number of chunks: seek all the way minus one byte to check                for end-of-file with a read */
name|lseek
argument_list|(
name|in
operator|->
name|fd
argument_list|,
name|skip
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|in
operator|->
name|fd
argument_list|,
name|in
operator|->
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|bail
argument_list|(
literal|"unexpected end of file on "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* skip the integral chunks, update skip with remainder */
name|lseek
argument_list|(
name|in
operator|->
name|fd
argument_list|,
name|skip
operator|-
name|left
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|skip
operator|=
name|left
expr_stmt|;
block|}
comment|/* read more input and skip remainder */
name|bload
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>
name|in
operator|->
name|left
condition|)
name|bail
argument_list|(
literal|"unexpected end of file on "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|in
operator|->
name|left
operator|-=
name|skip
expr_stmt|;
name|in
operator|->
name|next
operator|+=
name|skip
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -- end of buffered input functions -- */
end_comment

begin_comment
comment|/* skip the gzip header from file in */
end_comment

begin_function
name|local
name|void
name|gzhead
parameter_list|(
name|bin
modifier|*
name|in
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
comment|/* verify gzip magic header and compression method */
if|if
condition|(
name|bget
argument_list|(
name|in
argument_list|)
operator|!=
literal|0x1f
operator|||
name|bget
argument_list|(
name|in
argument_list|)
operator|!=
literal|0x8b
operator|||
name|bget
argument_list|(
name|in
argument_list|)
operator|!=
literal|8
condition|)
name|bail
argument_list|(
name|in
operator|->
name|name
argument_list|,
literal|" is not a valid gzip file"
argument_list|)
expr_stmt|;
comment|/* get and verify flags */
name|flags
operator|=
name|bget
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|0xe0
operator|)
operator|!=
literal|0
condition|)
name|bail
argument_list|(
literal|"unknown reserved bits set in "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* skip modification time, extra flags, and os */
name|bskip
argument_list|(
name|in
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* skip extra field if present */
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
block|{
name|unsigned
name|len
decl_stmt|;
name|len
operator|=
name|bget
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|len
operator|+=
call|(
name|unsigned
call|)
argument_list|(
name|bget
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|bskip
argument_list|(
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* skip file name if present */
if|if
condition|(
name|flags
operator|&
literal|8
condition|)
while|while
condition|(
name|bget
argument_list|(
name|in
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* skip comment if present */
if|if
condition|(
name|flags
operator|&
literal|16
condition|)
while|while
condition|(
name|bget
argument_list|(
name|in
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* skip header crc if present */
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|bskip
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write a four-byte little-endian unsigned integer to out */
end_comment

begin_function
name|local
name|void
name|put4
parameter_list|(
name|unsigned
name|long
name|val
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|putc
argument_list|(
name|val
operator|&
literal|0xff
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load up zlib stream from buffered input, bail if end of file */
end_comment

begin_function
name|local
name|void
name|zpull
parameter_list|(
name|z_streamp
name|strm
parameter_list|,
name|bin
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|left
operator|==
literal|0
condition|)
name|bload
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|left
operator|==
literal|0
condition|)
name|bail
argument_list|(
literal|"unexpected end of file on "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|in
operator|->
name|left
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|in
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write header for gzip file to out and initialize trailer. */
end_comment

begin_function
name|local
name|void
name|gzinit
parameter_list|(
name|unsigned
name|long
modifier|*
name|crc
parameter_list|,
name|unsigned
name|long
modifier|*
name|tot
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|fwrite
argument_list|(
literal|"\x1f\x8b\x08\0\0\0\0\0\0\xff"
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|*
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tot
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the compressed data from name, zeroing the last block bit of the last    block if clr is true, and adding empty blocks as needed to get to a byte    boundary.  If clr is false, then the last block becomes the last block of    the output, and the gzip trailer is written.  crc and tot maintains the    crc and length (modulo 2^32) of the output for the trailer.  The resulting    gzip file is written to out.  gzinit() must be called before the first call    of gzcopy() to write the gzip header and to initialize crc and tot. */
end_comment

begin_function
name|local
name|void
name|gzcopy
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|clr
parameter_list|,
name|unsigned
name|long
modifier|*
name|crc
parameter_list|,
name|unsigned
name|long
modifier|*
name|tot
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* return value from zlib functions */
name|int
name|pos
decl_stmt|;
comment|/* where the "last block" bit is in byte */
name|int
name|last
decl_stmt|;
comment|/* true if processing the last block */
name|bin
modifier|*
name|in
decl_stmt|;
comment|/* buffered input file */
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of compressed data in buffer */
name|unsigned
name|char
modifier|*
name|junk
decl_stmt|;
comment|/* buffer for uncompressed data -- discarded */
name|z_off_t
name|len
decl_stmt|;
comment|/* length of uncompressed data (support> 4 GB) */
name|z_stream
name|strm
decl_stmt|;
comment|/* zlib inflate stream */
comment|/* open gzip file and skip header */
name|in
operator|=
name|bopen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
name|bail
argument_list|(
literal|"could not open "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gzhead
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* allocate buffer for uncompressed data and initialize raw inflate        stream */
name|junk
operator|=
name|malloc
argument_list|(
name|CHUNK
argument_list|)
expr_stmt|;
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
operator|-
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
operator|==
name|NULL
operator|||
name|ret
operator|!=
name|Z_OK
condition|)
name|bail
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* inflate and copy compressed data, clear last-block bit if requested */
name|len
operator|=
literal|0
expr_stmt|;
name|zpull
argument_list|(
operator|&
name|strm
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|start
operator|=
name|in
operator|->
name|next
expr_stmt|;
name|last
operator|=
name|start
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|clr
condition|)
name|start
index|[
literal|0
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* if input used and output done, write used input and get more */
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
operator|&&
name|strm
operator|.
name|avail_out
operator|!=
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|strm
operator|.
name|next_in
operator|-
name|start
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|start
operator|=
name|in
operator|->
name|buf
expr_stmt|;
name|in
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|zpull
argument_list|(
operator|&
name|strm
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* decompress -- return early when end-of-block reached */
name|strm
operator|.
name|avail_out
operator|=
name|CHUNK
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|junk
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_BLOCK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_MEM_ERROR
case|:
name|bail
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
case|case
name|Z_DATA_ERROR
case|:
name|bail
argument_list|(
literal|"invalid compressed data in "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* update length of uncompressed data */
name|len
operator|+=
name|CHUNK
operator|-
name|strm
operator|.
name|avail_out
expr_stmt|;
comment|/* check for block boundary (only get this when block copied out) */
if|if
condition|(
name|strm
operator|.
name|data_type
operator|&
literal|128
condition|)
block|{
comment|/* if that was the last block, then done */
if|if
condition|(
name|last
condition|)
break|break;
comment|/* number of unused bits in last byte */
name|pos
operator|=
name|strm
operator|.
name|data_type
operator|&
literal|7
expr_stmt|;
comment|/* find the next last-block bit */
if|if
condition|(
name|pos
operator|!=
literal|0
condition|)
block|{
comment|/* next last-block bit is in last used byte */
name|pos
operator|=
literal|0x100
operator|>>
name|pos
expr_stmt|;
name|last
operator|=
name|strm
operator|.
name|next_in
index|[
operator|-
literal|1
index|]
operator|&
name|pos
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|clr
condition|)
name|in
operator|->
name|buf
index|[
name|strm
operator|.
name|next_in
operator|-
name|in
operator|->
name|buf
operator|-
literal|1
index|]
operator|&=
operator|~
name|pos
expr_stmt|;
block|}
else|else
block|{
comment|/* next last-block bit is in next unused byte */
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
comment|/* don't have that byte yet -- get it */
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|strm
operator|.
name|next_in
operator|-
name|start
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|start
operator|=
name|in
operator|->
name|buf
expr_stmt|;
name|in
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|zpull
argument_list|(
operator|&
name|strm
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|strm
operator|.
name|next_in
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|clr
condition|)
name|in
operator|->
name|buf
index|[
name|strm
operator|.
name|next_in
operator|-
name|in
operator|->
name|buf
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* update buffer with unused input */
name|in
operator|->
name|left
operator|=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|in
operator|->
name|next
operator|=
name|in
operator|->
name|buf
operator|+
operator|(
name|strm
operator|.
name|next_in
operator|-
name|in
operator|->
name|buf
operator|)
expr_stmt|;
comment|/* copy used input, write empty blocks to get to byte boundary */
name|pos
operator|=
name|strm
operator|.
name|data_type
operator|&
literal|7
expr_stmt|;
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|in
operator|->
name|next
operator|-
name|start
operator|-
literal|1
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|last
operator|=
name|in
operator|->
name|next
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
operator|||
operator|!
name|clr
condition|)
comment|/* already at byte boundary, or last file: write last byte */
name|putc
argument_list|(
name|last
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* append empty blocks to last byte */
name|last
operator|&=
operator|(
operator|(
literal|0x100
operator|>>
name|pos
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* assure unused bits are zero */
if|if
condition|(
name|pos
operator|&
literal|1
condition|)
block|{
comment|/* odd -- append an empty stored block */
name|putc
argument_list|(
name|last
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|1
condition|)
name|putc
argument_list|(
literal|0
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* two more bits in block header */
name|fwrite
argument_list|(
literal|"\0\0\xff\xff"
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* even -- append 1, 2, or 3 empty fixed blocks */
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
literal|6
case|:
name|putc
argument_list|(
name|last
operator||
literal|8
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
case|case
literal|4
case|:
name|putc
argument_list|(
name|last
operator||
literal|0x20
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|putc
argument_list|(
name|last
operator||
literal|0x80
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update crc and tot */
operator|*
name|crc
operator|=
name|crc32_combine
argument_list|(
operator|*
name|crc
argument_list|,
name|bget4
argument_list|(
name|in
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|tot
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|len
expr_stmt|;
comment|/* clean up */
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|bclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* write trailer if this is the last gzip file */
if|if
condition|(
operator|!
name|clr
condition|)
block|{
name|put4
argument_list|(
operator|*
name|crc
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|put4
argument_list|(
operator|*
name|tot
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* join the gzip files on the command line, write result to stdout */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|long
name|crc
decl_stmt|,
name|tot
decl_stmt|;
comment|/* running crc and total uncompressed length */
comment|/* skip command name */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* show usage if no arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]]> fjoin.gz\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* join gzip files on command line and write to stdout */
name|gzinit
argument_list|(
operator|&
name|crc
argument_list|,
operator|&
name|tot
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|--
condition|)
name|gzcopy
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|argc
argument_list|,
operator|&
name|crc
argument_list|,
operator|&
name|tot
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* done */
return|return
literal|0
return|;
block|}
end_function

end_unit

