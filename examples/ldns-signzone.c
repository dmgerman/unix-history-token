begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ldns-signzone signs a zone file  *   * (c) NLnet Labs, 2005 - 2008  * See the file LICENSE for the license  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<ldns/keys.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_define
define|#
directive|define
name|MAX_FILENAME_LEN
value|250
end_define

begin_decl_stmt
name|int
name|verbosity
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s [OPTIONS] zonefile key [key [key]]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  signs the zone with the given key(s)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -b\t\tuse layout in signed zone and print comments DNSSEC records\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -d\t\tused keys are not added to the zone\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -e<date>\texpiration date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -f<file>\toutput zone to file (default<name>.signed)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -i<date>\tinception date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -o<domain>\torigin for the zone\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -v\t\tprint version and exit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -A\t\tsign DNSKEY with all keys instead of minimal\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -E<name>\tuse<name> as the crypto engine for signing\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"           \tThis can have a lot of extra options, see the manual page for more info\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -k<id>,<int>\tuse key id with algorithm int from engine\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -K<id>,<int>\tuse key id with algorithm int from engine as KSK\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\tif no key is given (but an external one is used through the engine support, it might be necessary to provide the right algorithm number.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -n\t\tuse NSEC3 instead of NSEC.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\tIf you use NSEC3, you can specify the following extra options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t-a [algorithm] hashing algorithm\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t-t [number] number of hash iterations\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t-s [string] salt\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t-p set the opt-out flag on all nsec3 rrs\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  keys must be specified by their base name (usually K<name>+<alg>+<id>),\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  i.e. WITHOUT the .private extension.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  If the public part of the key is not present in the zone, the DNSKEY RR\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  will be read from the file called<base name>.key. If that does not exist,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  a default DNSKEY will be generated from the private key and added to the zone.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  A date can be a timestamp (seconds since the epoch), or of\n  the form<YYYYMMdd[hhmmss]>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_tm
parameter_list|(
name|struct
name|tm
name|tm
parameter_list|)
block|{
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|<
literal|70
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You cannot specify dates before 1970\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_mon
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_mon
operator|>
literal|11
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The month must be in the range 1 to 12\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|<
literal|1
operator|||
name|tm
operator|.
name|tm_mday
operator|>
literal|31
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The day must be in the range 1 to 31\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_hour
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_hour
operator|>
literal|23
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The hour must be in the range 0-23\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_min
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_min
operator|>
literal|59
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The minute must be in the range 0-59\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_sec
operator|>
literal|59
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The second must be in the range 0-59\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * if the ttls are different, make them equal  * if one of the ttls equals LDNS_DEFAULT_TTL, that one is changed  * otherwise, rr2 will get the ttl of rr1  *   * prints a warning if a non-default TTL is changed  */
end_comment

begin_function
specifier|static
name|void
name|equalize_ttls
parameter_list|(
name|ldns_rr
modifier|*
name|rr1
parameter_list|,
name|ldns_rr
modifier|*
name|rr2
parameter_list|,
name|uint32_t
name|default_ttl
parameter_list|)
block|{
name|uint32_t
name|ttl1
decl_stmt|,
name|ttl2
decl_stmt|;
name|ttl1
operator|=
name|ldns_rr_ttl
argument_list|(
name|rr1
argument_list|)
expr_stmt|;
name|ttl2
operator|=
name|ldns_rr_ttl
argument_list|(
name|rr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl1
operator|!=
name|ttl2
condition|)
block|{
if|if
condition|(
name|ttl1
operator|==
name|default_ttl
condition|)
block|{
name|ldns_rr_set_ttl
argument_list|(
name|rr1
argument_list|,
name|ttl2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttl2
operator|==
name|default_ttl
condition|)
block|{
name|ldns_rr_set_ttl
argument_list|(
name|rr2
argument_list|,
name|ttl1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_rr_set_ttl
argument_list|(
name|rr2
argument_list|,
name|ttl1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: changing non-default TTL %u to %u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ttl2
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ttl1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|equalize_ttls_rr_list
parameter_list|(
name|ldns_rr_list
modifier|*
name|rr_list
parameter_list|,
name|ldns_rr
modifier|*
name|rr
parameter_list|,
name|uint32_t
name|default_ttl
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|cur_rr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|rr_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cur_rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|rr_list
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_compare_no_rdata
argument_list|(
name|cur_rr
argument_list|,
name|rr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|equalize_ttls
argument_list|(
name|cur_rr
argument_list|,
name|rr
argument_list|,
name|default_ttl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|ldns_rr
modifier|*
name|find_key_in_zone
parameter_list|(
name|ldns_rr
modifier|*
name|pubkey_gen
parameter_list|,
name|ldns_zone
modifier|*
name|zone
parameter_list|)
block|{
name|size_t
name|key_i
decl_stmt|;
name|ldns_rr
modifier|*
name|pubkey
decl_stmt|;
for|for
control|(
name|key_i
operator|=
literal|0
init|;
name|key_i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|)
condition|;
name|key_i
operator|++
control|)
block|{
name|pubkey
operator|=
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|,
name|key_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|pubkey
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
operator|&&
operator|(
name|ldns_calc_keytag
argument_list|(
name|pubkey
argument_list|)
operator|==
name|ldns_calc_keytag
argument_list|(
name|pubkey_gen
argument_list|)
operator|||
comment|/* KSK has gen-keytag + 1 */
name|ldns_calc_keytag
argument_list|(
name|pubkey
argument_list|)
operator|==
name|ldns_calc_keytag
argument_list|(
name|pubkey_gen
argument_list|)
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Found it in the zone!\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|pubkey
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_rr
modifier|*
name|find_key_in_file
parameter_list|(
specifier|const
name|char
modifier|*
name|keyfile_name_base
parameter_list|,
name|ldns_key
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|key
parameter_list|)
parameter_list|,
name|uint32_t
name|zone_ttl
parameter_list|)
block|{
name|char
modifier|*
name|keyfile_name
decl_stmt|;
name|FILE
modifier|*
name|keyfile
decl_stmt|;
name|int
name|line_nr
decl_stmt|;
name|uint32_t
name|default_ttl
init|=
name|zone_ttl
decl_stmt|;
name|ldns_rr
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|keyfile_name
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|keyfile_name_base
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|keyfile_name
argument_list|,
name|strlen
argument_list|(
name|keyfile_name_base
argument_list|)
operator|+
literal|5
argument_list|,
literal|"%s.key"
argument_list|,
name|keyfile_name_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Trying to read %s\n"
argument_list|,
name|keyfile_name
argument_list|)
expr_stmt|;
block|}
name|keyfile
operator|=
name|fopen
argument_list|(
name|keyfile_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|line_nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyfile
condition|)
block|{
if|if
condition|(
name|ldns_rr_new_frm_fp_l
argument_list|(
operator|&
name|pubkey
argument_list|,
name|keyfile
argument_list|,
operator|&
name|default_ttl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|line_nr
argument_list|)
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Key found in file: %s\n"
argument_list|,
name|keyfile_name
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
block|}
name|LDNS_FREE
argument_list|(
name|keyfile_name
argument_list|)
expr_stmt|;
return|return
name|pubkey
return|;
block|}
end_function

begin_comment
comment|/* this function tries to find the specified keys either in the zone that  * has been read, or in a<basename>.key file. If the key is not found,  * a public key is generated, and it is assumed the key is a ZSK  *   * if add_keys is true; the DNSKEYs are added to the zone prior to signing  * if it is false, they are not added.  * Even if keys are not added, the function is still needed, to check  * whether keys of which we only have key data are KSKs or ZSKS  */
end_comment

begin_function
specifier|static
name|void
name|find_or_create_pubkey
parameter_list|(
specifier|const
name|char
modifier|*
name|keyfile_name_base
parameter_list|,
name|ldns_key
modifier|*
name|key
parameter_list|,
name|ldns_zone
modifier|*
name|orig_zone
parameter_list|,
name|bool
name|add_keys
parameter_list|,
name|uint32_t
name|default_ttl
parameter_list|)
block|{
name|ldns_rr
modifier|*
name|pubkey_gen
decl_stmt|,
modifier|*
name|pubkey
decl_stmt|;
name|int
name|key_in_zone
decl_stmt|;
if|if
condition|(
name|default_ttl
operator|==
name|LDNS_DEFAULT_TTL
condition|)
block|{
name|default_ttl
operator|=
name|ldns_rr_ttl
argument_list|(
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_key_pubkey_owner
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|ldns_key_set_pubkey_owner
argument_list|(
name|key
argument_list|,
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_owner
argument_list|(
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* find the public key in the zone, or in a 	 * seperate file 	 * we 'generate' one anyway,  	 * then match that to any present in the zone, 	 * if it matches, we drop our own. If not, 	 * we try to see if there is a .key file present. 	 * If not, we use our own generated one, with 	 * some default values  	 * 	 * Even if -d (do-not-add-keys) is specified,  	 * we still need to do this, because we need 	 * to have any key flags that are set this way 	 */
name|pubkey_gen
operator|=
name|ldns_key2rr
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ldns_rr_set_ttl
argument_list|(
name|pubkey_gen
argument_list|,
name|default_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for key with keytag %u or %u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_calc_keytag
argument_list|(
name|pubkey_gen
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_calc_keytag
argument_list|(
name|pubkey_gen
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pubkey
operator|=
name|find_key_in_zone
argument_list|(
name|pubkey_gen
argument_list|,
name|orig_zone
argument_list|)
expr_stmt|;
name|key_in_zone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pubkey
condition|)
block|{
name|key_in_zone
operator|=
literal|0
expr_stmt|;
comment|/* it was not in the zone, try to read a .key file */
name|pubkey
operator|=
name|find_key_in_file
argument_list|(
name|keyfile_name_base
argument_list|,
name|key
argument_list|,
name|default_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pubkey
operator|&&
operator|!
operator|(
name|ldns_key_flags
argument_list|(
name|key
argument_list|)
operator|&
name|LDNS_KEY_SEP_KEY
operator|)
condition|)
block|{
comment|/* maybe it is a ksk? */
name|ldns_key_set_keytag
argument_list|(
name|key
argument_list|,
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pubkey
operator|=
name|find_key_in_file
argument_list|(
name|keyfile_name_base
argument_list|,
name|key
argument_list|,
name|default_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pubkey
condition|)
block|{
comment|/* ok, no file, set back to ZSK */
name|ldns_key_set_keytag
argument_list|(
name|key
argument_list|,
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pubkey
operator|&&
name|ldns_dname_compare
argument_list|(
name|ldns_rr_owner
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|ldns_rr_owner
argument_list|(
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %s.key has wrong name: %s\n"
argument_list|,
name|keyfile_name_base
argument_list|,
name|ldns_rdf2str
argument_list|(
name|ldns_rr_owner
argument_list|(
name|pubkey
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* leak rdf2str, but we exit */
block|}
block|}
if|if
condition|(
operator|!
name|pubkey
condition|)
block|{
comment|/* okay, no public key found, 		   just use our generated one */
name|pubkey
operator|=
name|pubkey_gen
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not in zone, no .key file, generating ZSK DNSKEY from private key data\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ldns_rr_free
argument_list|(
name|pubkey_gen
argument_list|)
expr_stmt|;
block|}
name|ldns_key_set_flags
argument_list|(
name|key
argument_list|,
name|ldns_rdf2native_int16
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|pubkey
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_key_set_keytag
argument_list|(
name|key
argument_list|,
name|ldns_calc_keytag
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_keys
operator|&&
operator|!
name|key_in_zone
condition|)
block|{
name|equalize_ttls_rr_list
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
argument_list|,
name|pubkey
argument_list|,
name|default_ttl
argument_list|)
expr_stmt|;
name|ldns_zone_push_rr
argument_list|(
name|orig_zone
argument_list|,
name|pubkey
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|strip_dnssec_records
parameter_list|(
name|ldns_zone
modifier|*
name|zone
parameter_list|)
block|{
name|ldns_rr_list
modifier|*
name|new_list
decl_stmt|;
name|ldns_rr
modifier|*
name|cur_rr
decl_stmt|;
name|new_list
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|cur_rr
operator|=
name|ldns_rr_list_pop_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|cur_rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_RRSIG
operator|||
name|ldns_rr_get_type
argument_list|(
name|cur_rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ldns_rr_get_type
argument_list|(
name|cur_rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|new_list
argument_list|,
name|cur_rr
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_rr_list_free
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_zone_set_rrs
argument_list|(
name|zone
argument_list|,
name|new_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zonefile_name
decl_stmt|;
name|FILE
modifier|*
name|zonefile
init|=
name|NULL
decl_stmt|;
name|int
name|line_nr
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|argi
decl_stmt|;
name|ENGINE
modifier|*
name|engine
init|=
name|NULL
decl_stmt|;
name|ldns_zone
modifier|*
name|orig_zone
decl_stmt|;
name|ldns_rr_list
modifier|*
name|orig_rrs
init|=
name|NULL
decl_stmt|;
name|ldns_rr
modifier|*
name|orig_soa
init|=
name|NULL
decl_stmt|;
name|ldns_dnssec_zone
modifier|*
name|signed_zone
decl_stmt|;
name|char
modifier|*
name|keyfile_name_base
decl_stmt|;
name|char
modifier|*
name|keyfile_name
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|keyfile
init|=
name|NULL
decl_stmt|;
name|ldns_key
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|ldns_key_list
modifier|*
name|keys
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ldns_rr_list
modifier|*
name|added_rrs
decl_stmt|;
name|char
modifier|*
name|outputfile_name
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|outputfile
decl_stmt|;
comment|/* tmp vars for engine keys */
name|char
modifier|*
name|eng_key_l
decl_stmt|;
name|size_t
name|eng_key_id_len
decl_stmt|;
name|char
modifier|*
name|eng_key_id
decl_stmt|;
name|int
name|eng_key_algo
decl_stmt|;
name|bool
name|use_nsec3
init|=
name|false
decl_stmt|;
name|int
name|signflags
init|=
literal|0
decl_stmt|;
comment|/* Add the given keys to the zone if they are not yet present */
name|bool
name|add_keys
init|=
name|true
decl_stmt|;
name|uint8_t
name|nsec3_algorithm
init|=
literal|1
decl_stmt|;
name|uint8_t
name|nsec3_flags
init|=
literal|0
decl_stmt|;
name|size_t
name|nsec3_iterations_cmd
init|=
literal|1
decl_stmt|;
name|uint16_t
name|nsec3_iterations
init|=
literal|1
decl_stmt|;
name|uint8_t
name|nsec3_salt_length
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nsec3_salt
init|=
name|NULL
decl_stmt|;
comment|/* we need to know the origin before reading ksk's, 	 * so keep an array of filenames until we know it 	 */
name|struct
name|tm
name|tm
decl_stmt|;
name|uint32_t
name|inception
decl_stmt|;
name|uint32_t
name|expiration
decl_stmt|;
name|ldns_rdf
modifier|*
name|origin
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|ttl
init|=
name|LDNS_DEFAULT_TTL
decl_stmt|;
name|ldns_rr_class
name|class
init|=
name|LDNS_RR_CLASS_IN
decl_stmt|;
name|char
modifier|*
name|prog
init|=
name|strdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ldns_status
name|result
decl_stmt|;
name|ldns_output_format
name|fmt
init|=
block|{
name|ldns_output_format_default
operator|->
name|flags
block|,
name|NULL
block|}
decl_stmt|;
name|void
modifier|*
modifier|*
name|hashmap
init|=
name|NULL
decl_stmt|;
name|inception
operator|=
literal|0
expr_stmt|;
name|expiration
operator|=
literal|0
expr_stmt|;
name|keys
operator|=
name|ldns_key_list_new
argument_list|()
expr_stmt|;
name|OPENSSL_config
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:bde:f:i:k:lno:ps:t:vAE:K:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|nsec3_algorithm
operator|=
operator|(
name|uint8_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3_algorithm
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad NSEC3 algorithm, only RSASHA1 allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
name|fmt
operator|.
name|flags
operator||=
name|LDNS_COMMENT_BUBBLEBABBLE
expr_stmt|;
name|fmt
operator|.
name|flags
operator||=
name|LDNS_COMMENT_FLAGS
expr_stmt|;
name|fmt
operator|.
name|flags
operator||=
name|LDNS_COMMENT_NSEC3_CHAIN
expr_stmt|;
name|fmt
operator|.
name|flags
operator||=
name|LDNS_COMMENT_LAYOUT
expr_stmt|;
name|hashmap
operator|=
operator|&
name|fmt
operator|.
name|data
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|add_keys
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* try to parse YYYYMMDD first, 			 * if that doesn't work, it 			 * should be a timestamp (seconds since epoch) 			 */
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|==
literal|8
operator|&&
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%4d%2d%2d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|)
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|check_tm
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|expiration
operator|=
operator|(
name|uint32_t
operator|)
name|mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|==
literal|14
operator|&&
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%4d%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|)
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|check_tm
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|expiration
operator|=
operator|(
name|uint32_t
operator|)
name|mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expiration
operator|=
operator|(
name|uint32_t
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|outputfile_name
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|outputfile_name
argument_list|,
name|optarg
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|==
literal|8
operator|&&
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%4d%2d%2d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|)
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|check_tm
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|inception
operator|=
operator|(
name|uint32_t
operator|)
name|mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|==
literal|14
operator|&&
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%4d%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|)
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|check_tm
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|inception
operator|=
operator|(
name|uint32_t
operator|)
name|mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inception
operator|=
operator|(
name|uint32_t
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|use_nsec3
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|ldns_str2rdf_dname
argument_list|(
operator|&
name|origin
argument_list|,
name|optarg
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad origin, not a correct domain name\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|nsec3_flags
operator|=
name|nsec3_flags
operator||
name|LDNS_NSEC3_VARS_OPTOUT_MASK
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"zone signer version %s (ldns version %s)\n"
argument_list|,
name|LDNS_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|signflags
operator||=
name|LDNS_SIGN_DNSKEY_WITH_ZSK
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|ENGINE_load_builtin_engines
argument_list|()
expr_stmt|;
name|ENGINE_load_dynamic
argument_list|()
expr_stmt|;
name|ENGINE_load_cryptodev
argument_list|()
expr_stmt|;
name|engine
operator|=
name|ENGINE_by_id
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine
condition|)
block|{
name|printf
argument_list|(
literal|"No such engine: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|engine
operator|=
name|ENGINE_get_first
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Available engines:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|engine
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ENGINE_get_id
argument_list|(
name|engine
argument_list|)
argument_list|)
expr_stmt|;
name|engine
operator|=
name|ENGINE_get_next
argument_list|(
name|engine
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ENGINE_init
argument_list|(
name|engine
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"The engine couldn't initialize\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|ENGINE_set_default_RSA
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|ENGINE_set_default_DSA
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|ENGINE_set_default
argument_list|(
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|eng_key_l
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|eng_key_l
operator|&&
name|strlen
argument_list|(
name|eng_key_l
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|eng_key_l
operator|>
name|optarg
condition|)
block|{
name|eng_key_id_len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|eng_key_l
operator|-
name|optarg
argument_list|)
expr_stmt|;
name|eng_key_id
operator|=
name|malloc
argument_list|(
name|eng_key_id_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eng_key_id
argument_list|,
name|optarg
argument_list|,
name|eng_key_id_len
argument_list|)
expr_stmt|;
name|eng_key_id
index|[
name|eng_key_id_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* no id given, use default from engine */
name|eng_key_id
operator|=
name|NULL
expr_stmt|;
block|}
name|eng_key_algo
operator|=
name|atoi
argument_list|(
name|eng_key_l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Engine key id: %s, algo %d\n"
argument_list|,
name|eng_key_id
argument_list|,
name|eng_key_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|expiration
operator|!=
literal|0
condition|)
block|{
name|ldns_key_set_expiration
argument_list|(
name|key
argument_list|,
name|expiration
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inception
operator|!=
literal|0
condition|)
block|{
name|ldns_key_set_inception
argument_list|(
name|key
argument_list|,
name|inception
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|ldns_key_new_frm_engine
argument_list|(
operator|&
name|key
argument_list|,
name|engine
argument_list|,
name|eng_key_id
argument_list|,
name|eng_key_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
comment|/* must be dnssec key */
switch|switch
condition|(
name|ldns_key_algorithm
argument_list|(
name|key
argument_list|)
condition|)
block|{
case|case
name|LDNS_SIGN_RSAMD5
case|:
case|case
name|LDNS_SIGN_RSASHA1
case|:
case|case
name|LDNS_SIGN_RSASHA1_NSEC3
case|:
case|case
name|LDNS_SIGN_RSASHA256
case|:
case|case
name|LDNS_SIGN_RSASHA512
case|:
case|case
name|LDNS_SIGN_DSA
case|:
case|case
name|LDNS_SIGN_DSA_NSEC3
case|:
case|case
name|LDNS_SIGN_ECC_GOST
case|:
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SIGN_ECDSAP256SHA256
case|:
case|case
name|LDNS_SIGN_ECDSAP384SHA384
case|:
endif|#
directive|endif
name|ldns_key_list_push_key
argument_list|(
name|keys
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/*printf("Added key at %p:\n", key);*/
comment|/*ldns_key_print(stdout, key);*/
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning, key not suitable for signing, ignoring key with algorithm %u\n"
argument_list|,
name|ldns_key_algorithm
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Error reading key '%s' from engine: %s\n"
argument_list|,
name|eng_key_id
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
if|if
condition|(
name|ERR_peek_error
argument_list|()
condition|)
block|{
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|ERR_free_strings
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eng_key_id
condition|)
block|{
name|free
argument_list|(
name|eng_key_id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Error: bad engine key specification (should be: -k<id>,<algorithm>)).\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'K'
case|:
name|printf
argument_list|(
literal|"Not implemented yet\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Salt value is not valid hex data, not a multiple of 2 characters\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|nsec3_salt_length
operator|=
operator|(
name|uint8_t
operator|)
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|/
literal|2
expr_stmt|;
name|nsec3_salt
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
name|nsec3_salt_length
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optarg
argument_list|)
condition|;
name|c
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
operator|(
name|int
operator|)
name|optarg
index|[
name|c
index|]
argument_list|)
operator|&&
name|isxdigit
argument_list|(
operator|(
name|int
operator|)
name|optarg
index|[
name|c
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|nsec3_salt
index|[
name|c
operator|/
literal|2
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|ldns_hexdigit_to_int
argument_list|(
name|optarg
index|[
name|c
index|]
argument_list|)
operator|*
literal|16
operator|+
name|ldns_hexdigit_to_int
argument_list|(
name|optarg
index|[
name|c
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Salt value is not valid hex data.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
name|nsec3_iterations_cmd
operator|=
operator|(
name|size_t
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3_iterations_cmd
operator|>
name|LDNS_NSEC3_MAX_ITERATIONS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Iterations count can not exceed %u, quitting\n"
argument_list|,
name|LDNS_NSEC3_MAX_ITERATIONS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|nsec3_iterations
operator|=
operator|(
name|uint16_t
operator|)
name|nsec3_iterations_cmd
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Error: not enough arguments\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stdout
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zonefile_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* read zonefile first to find origin if not specified */
if|if
condition|(
name|strncmp
argument_list|(
name|zonefile_name
argument_list|,
literal|"-"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|ldns_zone_new_frm_fp_l
argument_list|(
operator|&
name|orig_zone
argument_list|,
name|stdin
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|class
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Zone not read, error: %s at stdin line %d\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orig_soa
operator|=
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orig_soa
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading zonefile: missing SOA record\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|orig_rrs
operator|=
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orig_rrs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading zonefile: no resource records\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|zonefile
operator|=
name|fopen
argument_list|(
name|zonefile_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zonefile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to read %s (%s)\n"
argument_list|,
name|zonefile_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|ldns_zone_new_frm_fp_l
argument_list|(
operator|&
name|orig_zone
argument_list|,
name|zonefile
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|class
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Zone not read, error: %s at %s line %d\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|,
name|zonefile_name
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orig_soa
operator|=
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orig_soa
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading zonefile: missing SOA record\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|orig_rrs
operator|=
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orig_rrs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading zonefile: no resource records\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|zonefile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|origin
condition|)
block|{
name|origin
operator|=
name|ldns_rr_owner
argument_list|(
name|orig_soa
argument_list|)
expr_stmt|;
block|}
comment|/* read the ZSKs */
name|argi
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|argi
operator|<
name|argc
condition|)
block|{
name|keyfile_name_base
operator|=
name|argv
index|[
name|argi
index|]
expr_stmt|;
name|keyfile_name
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|keyfile_name_base
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|keyfile_name
argument_list|,
name|strlen
argument_list|(
name|keyfile_name_base
argument_list|)
operator|+
literal|9
argument_list|,
literal|"%s.private"
argument_list|,
name|keyfile_name_base
argument_list|)
expr_stmt|;
name|keyfile
operator|=
name|fopen
argument_list|(
name|keyfile_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|line_nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keyfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to read %s: %s\n"
argument_list|,
name|keyfile_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|ldns_key_new_frm_fp_l
argument_list|(
operator|&
name|key
argument_list|,
name|keyfile
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
comment|/* set times in key? they will end up 				   in the rrsigs 				*/
if|if
condition|(
name|expiration
operator|!=
literal|0
condition|)
block|{
name|ldns_key_set_expiration
argument_list|(
name|key
argument_list|,
name|expiration
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inception
operator|!=
literal|0
condition|)
block|{
name|ldns_key_set_inception
argument_list|(
name|key
argument_list|,
name|inception
argument_list|)
expr_stmt|;
block|}
name|LDNS_FREE
argument_list|(
name|keyfile_name
argument_list|)
expr_stmt|;
name|ldns_key_list_push_key
argument_list|(
name|keys
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading key from %s at line %d: %s\n"
argument_list|,
name|argv
index|[
name|argi
index|]
argument_list|,
name|line_nr
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* and, if not unset by -p, find or create the corresponding DNSKEY record */
if|if
condition|(
name|key
condition|)
block|{
name|find_or_create_pubkey
argument_list|(
name|keyfile_name_base
argument_list|,
name|key
argument_list|,
name|orig_zone
argument_list|,
name|add_keys
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
name|argi
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ldns_key_list_key_count
argument_list|(
name|keys
argument_list|)
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: no keys to sign with. Aborting.\n\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|signed_zone
operator|=
name|ldns_dnssec_zone_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ldns_dnssec_zone_add_rr
argument_list|(
name|signed_zone
argument_list|,
name|ldns_zone_soa
argument_list|(
name|orig_zone
argument_list|)
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error adding SOA to dnssec zone, skipping record\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_dnssec_zone_add_rr
argument_list|(
name|signed_zone
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error adding RR to dnssec zone"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", skipping record:\n"
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|stderr
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|orig_zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* list to store newly created rrs, so we can free them later */
name|added_rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_nsec3
condition|)
block|{
name|result
operator|=
name|ldns_dnssec_zone_sign_nsec3_flg_mkmap
argument_list|(
name|signed_zone
argument_list|,
name|added_rrs
argument_list|,
name|keys
argument_list|,
name|ldns_dnssec_default_replace_signatures
argument_list|,
name|NULL
argument_list|,
name|nsec3_algorithm
argument_list|,
name|nsec3_flags
argument_list|,
name|nsec3_iterations
argument_list|,
name|nsec3_salt_length
argument_list|,
name|nsec3_salt
argument_list|,
name|signflags
argument_list|,
operator|(
name|ldns_rbtree_t
operator|*
operator|*
operator|)
name|hashmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ldns_dnssec_zone_sign_flg
argument_list|(
name|signed_zone
argument_list|,
name|added_rrs
argument_list|,
name|keys
argument_list|,
name|ldns_dnssec_default_replace_signatures
argument_list|,
name|NULL
argument_list|,
name|signflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error signing zone: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|outputfile_name
condition|)
block|{
name|outputfile_name
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|outputfile_name
argument_list|,
name|MAX_FILENAME_LEN
argument_list|,
literal|"%s.signed"
argument_list|,
name|zonefile_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signed_zone
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|outputfile_name
argument_list|,
literal|"-"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ldns_dnssec_zone_print
argument_list|(
name|stdout
argument_list|,
name|signed_zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputfile
operator|=
name|fopen
argument_list|(
name|outputfile_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s for writing: %s\n"
argument_list|,
name|outputfile_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_dnssec_zone_print_fmt
argument_list|(
name|outputfile
argument_list|,
operator|&
name|fmt
argument_list|,
name|signed_zone
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outputfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error signing zone.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SSL
if|if
condition|(
name|ERR_peek_error
argument_list|()
condition|)
block|{
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|ERR_free_strings
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|ldns_key_list_free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
comment|/* since the ldns_rr records are pointed to in both the ldns_zone 	 * and the ldns_dnssec_zone, we can either deep_free the 	 * dnssec_zone and 'shallow' free the original zone and added 	 * records, or the other way around 	 */
name|ldns_dnssec_zone_free
argument_list|(
name|signed_zone
argument_list|)
expr_stmt|;
name|ldns_zone_deep_free
argument_list|(
name|orig_zone
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|added_rrs
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|outputfile_name
argument_list|)
expr_stmt|;
name|CRYPTO_cleanup_all_ex_data
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns-signzone needs OpenSSL support, which has not been compiled in\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

end_unit

