begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* zpipe.c: example of proper use of zlib's inflate() and deflate()    Not copyrighted -- provided to the public domain    Version 1.4  11 December 2005  Mark Adler */
end_comment

begin_comment
comment|/* Version history:    1.0  30 Oct 2004  First version    1.1   8 Nov 2004  Add void casting for unused return values                      Use switch statement for inflate() return values    1.2   9 Nov 2004  Add assertions to document zlib guarantees    1.3   6 Apr 2005  Remove incorrect assertion in inf()    1.4  11 Dec 2005  Add hack to avoid MSDOS end-of-line conversions                      Avoid some compiler warnings for input and output buffers  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
value|setmode(fileno(file), O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHUNK
value|16384
end_define

begin_comment
comment|/* Compress from file source to file dest until EOF on source.    def() returns Z_OK on success, Z_MEM_ERROR if memory could not be    allocated for processing, Z_STREAM_ERROR if an invalid compression    level is supplied, Z_VERSION_ERROR if the version of zlib.h and the    version of the library linked do not match, or Z_ERRNO if there is    an error reading or writing the files. */
end_comment

begin_function
name|int
name|def
parameter_list|(
name|FILE
modifier|*
name|source
parameter_list|,
name|FILE
modifier|*
name|dest
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|flush
decl_stmt|;
name|unsigned
name|have
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|unsigned
name|char
name|in
index|[
name|CHUNK
index|]
decl_stmt|;
name|unsigned
name|char
name|out
index|[
name|CHUNK
index|]
decl_stmt|;
comment|/* allocate deflate state */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit
argument_list|(
operator|&
name|strm
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
comment|/* compress until end of file */
do|do
block|{
name|strm
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|in
argument_list|,
literal|1
argument_list|,
name|CHUNK
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|source
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
name|flush
operator|=
name|feof
argument_list|(
name|source
argument_list|)
condition|?
name|Z_FINISH
else|:
name|Z_NO_FLUSH
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
comment|/* run deflate() on input until output buffer not full, finish            compression if all of source has been read in */
do|do
block|{
name|strm
operator|.
name|avail_out
operator|=
name|CHUNK
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|strm
argument_list|,
name|flush
argument_list|)
expr_stmt|;
comment|/* no bad return value */
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
comment|/* state not clobbered */
name|have
operator|=
name|CHUNK
operator|-
name|strm
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|have
argument_list|,
name|dest
argument_list|)
operator|!=
name|have
operator|||
name|ferror
argument_list|(
name|dest
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
block|}
do|while
condition|(
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
name|assert
argument_list|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* all input will be used */
comment|/* done when last data in file processed */
block|}
do|while
condition|(
name|flush
operator|!=
name|Z_FINISH
condition|)
do|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_END
argument_list|)
expr_stmt|;
comment|/* stream will be complete */
comment|/* clean up and return */
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* Decompress from file source to file dest until stream ends or EOF.    inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be    allocated for processing, Z_DATA_ERROR if the deflate data is    invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and    the version of the library linked do not match, or Z_ERRNO if there    is an error reading or writing the files. */
end_comment

begin_function
name|int
name|inf
parameter_list|(
name|FILE
modifier|*
name|source
parameter_list|,
name|FILE
modifier|*
name|dest
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|have
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|unsigned
name|char
name|in
index|[
name|CHUNK
index|]
decl_stmt|;
name|unsigned
name|char
name|out
index|[
name|CHUNK
index|]
decl_stmt|;
comment|/* allocate inflate state */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
comment|/* decompress until deflate stream ends or end of file */
do|do
block|{
name|strm
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|in
argument_list|,
literal|1
argument_list|,
name|CHUNK
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|source
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
break|break;
name|strm
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
comment|/* run inflate() on input until output buffer not full */
do|do
block|{
name|strm
operator|.
name|avail_out
operator|=
name|CHUNK
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
comment|/* state not clobbered */
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_NEED_DICT
case|:
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
comment|/* and fall through */
case|case
name|Z_DATA_ERROR
case|:
case|case
name|Z_MEM_ERROR
case|:
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|have
operator|=
name|CHUNK
operator|-
name|strm
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|have
argument_list|,
name|dest
argument_list|)
operator|!=
name|have
operator|||
name|ferror
argument_list|(
name|dest
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
block|}
do|while
condition|(
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
comment|/* done when inflate() says it's done */
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* clean up and return */
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|Z_DATA_ERROR
return|;
block|}
end_function

begin_comment
comment|/* report a zlib or i/o error */
end_comment

begin_function
name|void
name|zerr
parameter_list|(
name|int
name|ret
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"zpipe: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_ERRNO
case|:
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"error reading stdin\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"error writing stdout\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_ERROR
case|:
name|fputs
argument_list|(
literal|"invalid compression level\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|fputs
argument_list|(
literal|"invalid or incomplete deflate data\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|fputs
argument_list|(
literal|"out of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_VERSION_ERROR
case|:
name|fputs
argument_list|(
literal|"zlib version mismatch!\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* compress or decompress from stdin to stdout */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* avoid end-of-line conversions */
name|SET_BINARY_MODE
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* do compression if no arguments */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
name|def
argument_list|(
name|stdin
argument_list|,
name|stdout
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|zerr
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* do decompression if -d specified */
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|inf
argument_list|(
name|stdin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|zerr
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* otherwise, report usage */
else|else
block|{
name|fputs
argument_list|(
literal|"zpipe usage: zpipe [-d]< source> dest\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

end_unit

