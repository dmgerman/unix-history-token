begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is in the public domain.  * Do with it as you will.  */
end_comment

begin_comment
comment|/*-  * This is a compact "tar" program whose primary goal is small size.  * Statically linked, it can be very small indeed.  This serves a number  * of goals:  *   o a testbed for libarchive (to check for link pollution),  *   o a useful tool for space-constrained systems (boot floppies, etc),  *   o a place to experiment with new implementation ideas for bsdtar,  *   o a small program to demonstrate libarchive usage.  *  * Use the following macros to suppress features:  *   NO_BZIP2 - Implies NO_BZIP2_CREATE and NO_BZIP2_EXTRACT  *   NO_BZIP2_CREATE - Suppress bzip2 compression support.  *   NO_BZIP2_EXTRACT - Suppress bzip2 auto-detection and decompression.  *   NO_COMPRESS - Implies NO_COMPRESS_CREATE and NO_COMPRESS_EXTRACT  *   NO_COMPRESS_CREATE - Suppress compress(1) compression support  *   NO_COMPRESS_EXTRACT - Suppress compress(1) auto-detect and decompression.  *   NO_CREATE - Suppress all archive creation support.  *   NO_CPIO_EXTRACT - Suppress auto-detect and dearchiving of cpio archives.  *   NO_GZIP - Implies NO_GZIP_CREATE and NO_GZIP_EXTRACT  *   NO_GZIP_CREATE - Suppress gzip compression support.  *   NO_GZIP_EXTRACT - Suppress gzip auto-detection and decompression.  *   NO_LOOKUP - Try to avoid getpw/getgr routines, which can be very large  *   NO_TAR_EXTRACT - Suppress tar extraction  *  * With all of the above macros defined (except NO_TAR_EXTRACT), you  * get a very small program that can recognize and extract essentially  * any uncompressed tar archive.  On FreeBSD 5.1, this minimal program  * is under 64k, statically linked, which compares rather favorably to  *         main(){printf("hello, world");}  * which is over 60k statically linked on the same operating system.  * Without any of the above macros, you get a static executable of  * about 180k with a lot of very sophisticated modern features.  * Obviously, it's trivial to add support for ISO, Zip, mtree,  * lzma/xz, etc.  Just fill in the appropriate setup calls.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<archive.h>
end_include

begin_include
include|#
directive|include
file|<archive_entry.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * NO_CREATE implies NO_BZIP2_CREATE and NO_GZIP_CREATE and NO_COMPRESS_CREATE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_CREATE
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_BZIP2_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_BZIP2_CREATE
end_define

begin_undef
undef|#
directive|undef
name|NO_COMPRESS_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_COMPRESS_CREATE
end_define

begin_undef
undef|#
directive|undef
name|NO_GZIP_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_GZIP_CREATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The combination of NO_BZIP2_CREATE and NO_BZIP2_EXTRACT is  * equivalent to NO_BZIP2.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_BZIP2_CREATE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NO_BZIP2_EXTRACT
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_BZIP2
end_undef

begin_define
define|#
directive|define
name|NO_BZIP2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_BZIP2
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_BZIP2_EXTRACT
end_undef

begin_define
define|#
directive|define
name|NO_BZIP2_EXTRACT
end_define

begin_undef
undef|#
directive|undef
name|NO_BZIP2_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_BZIP2_CREATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The combination of NO_COMPRESS_CREATE and NO_COMPRESS_EXTRACT is  * equivalent to NO_COMPRESS.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_COMPRESS_CREATE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NO_COMPRESS_EXTRACT
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_COMPRESS
end_undef

begin_define
define|#
directive|define
name|NO_COMPRESS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_COMPRESS
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_COMPRESS_EXTRACT
end_undef

begin_define
define|#
directive|define
name|NO_COMPRESS_EXTRACT
end_define

begin_undef
undef|#
directive|undef
name|NO_COMPRESS_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_COMPRESS_CREATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The combination of NO_GZIP_CREATE and NO_GZIP_EXTRACT is  * equivalent to NO_GZIP.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_GZIP_CREATE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NO_GZIP_EXTRACT
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_GZIP
end_undef

begin_define
define|#
directive|define
name|NO_GZIP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_GZIP
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_GZIP_EXTRACT
end_undef

begin_define
define|#
directive|define
name|NO_GZIP_EXTRACT
end_define

begin_undef
undef|#
directive|undef
name|NO_GZIP_CREATE
end_undef

begin_define
define|#
directive|define
name|NO_GZIP_CREATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CREATE
end_ifndef

begin_function_decl
specifier|static
name|void
name|create
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|compress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|errmsg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extract
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|do_extract
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|int
name|compress
decl_stmt|,
name|flags
decl_stmt|,
name|mode
decl_stmt|,
name|opt
decl_stmt|;
operator|(
name|void
operator|)
name|argc
expr_stmt|;
name|mode
operator|=
literal|'x'
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|compress
operator|=
literal|'\0'
expr_stmt|;
name|flags
operator|=
name|ARCHIVE_EXTRACT_TIME
expr_stmt|;
comment|/* Among other sins, getopt(3) pulls in printf(3). */
while|while
condition|(
operator|*
operator|++
name|argv
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|argv
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_CREATE
case|case
literal|'c'
case|:
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|filename
operator|=
name|p
expr_stmt|;
else|else
name|filename
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BZIP2_CREATE
case|case
literal|'j'
case|:
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
name|flags
operator||=
name|ARCHIVE_EXTRACT_PERM
expr_stmt|;
name|flags
operator||=
name|ARCHIVE_EXTRACT_ACL
expr_stmt|;
name|flags
operator||=
name|ARCHIVE_EXTRACT_FFLAGS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BZIP2_CREATE
case|case
literal|'y'
case|:
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_CREATE
case|case
literal|'Z'
case|:
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_GZIP_CREATE
case|case
literal|'z'
case|:
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_CREATE
case|case
literal|'c'
case|:
name|create
argument_list|(
name|filename
argument_list|,
name|compress
argument_list|,
name|argv
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
name|extract
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|extract
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CREATE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|buff
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|create
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|compress
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive
modifier|*
name|disk
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|a
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|compress
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_BZIP2_CREATE
case|case
literal|'j'
case|:
case|case
literal|'y'
case|:
name|archive_write_add_filter_bzip2
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_CREATE
case|case
literal|'Z'
case|:
name|archive_write_add_filter_compress
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_GZIP_CREATE
case|case
literal|'z'
case|:
name|archive_write_add_filter_gzip
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|archive_write_add_filter_none
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
block|}
name|archive_write_set_format_ustar
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
name|archive_write_open_filename
argument_list|(
name|a
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|disk
operator|=
name|archive_read_disk_new
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LOOKUP
name|archive_read_disk_set_standard_lookup
argument_list|(
name|disk
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|struct
name|archive
modifier|*
name|disk
init|=
name|archive_read_disk_new
argument_list|()
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_read_disk_open
argument_list|(
name|disk
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|needcr
init|=
literal|0
decl_stmt|;
name|entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|archive_read_next_header2
argument_list|(
name|disk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|archive_read_disk_descend
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|msg
argument_list|(
literal|"a "
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|needcr
operator|=
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|archive_write_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|needcr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|ARCHIVE_FAILED
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Ideally, we would be able to use 				 * the same code to copy a body from 				 * an archive_read_disk to an 				 * archive_write that we use for 				 * copying data from an archive_read 				 * to an archive_write_disk. 				 * Unfortunately, this doesn't quite 				 * work yet. */
block|copy_data(disk, a);
else|#
directive|else
comment|/* For now, we use a simpler loop to copy data 				 * into the target archive. */
name|fd
operator|=
name|open
argument_list|(
name|archive_entry_sourcepath
argument_list|(
name|entry
argument_list|)
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|archive_write_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|needcr
condition|)
name|msg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|archive_read_close
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|archive_write_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_write_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|extract
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|do_extract
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive
modifier|*
name|ext
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|r
decl_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
name|ext
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
name|archive_write_disk_set_options
argument_list|(
name|ext
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BZIP2_EXTRACT
name|archive_read_support_filter_bzip2
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_GZIP_EXTRACT
name|archive_read_support_filter_gzip
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_EXTRACT
name|archive_read_support_filter_compress
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_TAR_EXTRACT
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CPIO_EXTRACT
name|archive_read_support_format_cpio
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_LOOKUP
name|archive_write_disk_set_standard_lookup
argument_list|(
name|ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|archive_read_open_filename
argument_list|(
name|a
argument_list|,
name|filename
argument_list|,
literal|10240
argument_list|)
operator|)
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|needcr
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|&&
name|do_extract
condition|)
name|msg
argument_list|(
literal|"x "
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
operator|!
name|do_extract
condition|)
block|{
name|msg
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|needcr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_extract
condition|)
block|{
name|r
operator|=
name|archive_write_header
argument_list|(
name|ext
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|needcr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|copy_data
argument_list|(
name|a
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|needcr
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needcr
condition|)
name|msg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
name|ar
parameter_list|,
name|struct
name|archive
modifier|*
name|aw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|ar
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|r
operator|=
name|archive_write_data_block
argument_list|(
name|aw
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|errmsg
argument_list|(
name|archive_error_string
argument_list|(
name|ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|errmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
literal|"Error: No error description provided.\n"
expr_stmt|;
block|}
name|write
argument_list|(
literal|2
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Many program options depend on compile options. */
specifier|const
name|char
modifier|*
name|m
init|=
literal|"Usage: minitar [-"
ifndef|#
directive|ifndef
name|NO_CREATE
literal|"c"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BZIP2
literal|"j"
endif|#
directive|endif
literal|"tvx"
ifndef|#
directive|ifndef
name|NO_BZIP2
literal|"y"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS
literal|"Z"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_GZIP
literal|"z"
endif|#
directive|endif
literal|"] [-f file] [file]\n"
decl_stmt|;
name|errmsg
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

