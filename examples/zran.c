begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* zran.c -- example of zlib/gzip stream indexing and random access  * Copyright (C) 2005, 2012 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h    Version 1.1  29 Sep 2012  Mark Adler */
end_comment

begin_comment
comment|/* Version History:  1.0  29 May 2005  First version  1.1  29 Sep 2012  Fix memory reallocation error  */
end_comment

begin_comment
comment|/* Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()    for random access of a compressed file.  A file containing a zlib or gzip    stream is provided on the command line.  The compressed stream is decoded in    its entirety, and an index built with access points about every SPAN bytes    in the uncompressed output.  The compressed file is left open, and can then    be read randomly, having to decompress on the average SPAN/2 uncompressed    bytes before getting to the desired block of data.     An access point can be created at the start of any deflate block, by saving    the starting file offset and bit of that block, and the 32K bytes of    uncompressed data that precede that block.  Also the uncompressed offset of    that block is saved to provide a referece for locating a desired starting    point in the uncompressed stream.  build_index() works by decompressing the    input zlib or gzip stream a block at a time, and at the end of each block    deciding if enough uncompressed data has gone by to justify the creation of    a new access point.  If so, that point is saved in a data structure that    grows as needed to accommodate the points.     To use the index, an offset in the uncompressed data is provided, for which    the latest accees point at or preceding that offset is located in the index.    The input file is positioned to the specified location in the index, and if    necessary the first few bits of the compressed data is read from the file.    inflate is initialized with those bits and the 32K of uncompressed data, and    the decompression then proceeds until the desired offset in the file is    reached.  Then the decompression continues to read the desired uncompressed    data from the file.     Another approach would be to generate the index on demand.  In that case,    requests for random access reads from the compressed data would try to use    the index, but if a read far enough past the end of the index is required,    then further index entries would be generated and added.     There is some fair bit of overhead to starting inflation for the random    access, mainly copying the 32K byte dictionary.  So if small pieces of the    file are being accessed, it would make sense to implement a cache to hold    some lookahead and avoid many calls to extract() for small lengths.     Another way to build an index would be to use inflateCopy().  That would    not be constrained to have access points at block boundaries, but requires    more memory per access point, and also cannot be saved to file due to the    use of pointers in the state.  The approach here allows for storage of the    index in a file.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_define
define|#
directive|define
name|SPAN
value|1048576L
end_define

begin_comment
comment|/* desired distance between access points */
end_comment

begin_define
define|#
directive|define
name|WINSIZE
value|32768U
end_define

begin_comment
comment|/* sliding window size */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|16384
end_define

begin_comment
comment|/* file input buffer size */
end_comment

begin_comment
comment|/* access point entry */
end_comment

begin_struct
struct|struct
name|point
block|{
name|off_t
name|out
decl_stmt|;
comment|/* corresponding offset in uncompressed data */
name|off_t
name|in
decl_stmt|;
comment|/* offset in input file of first full byte */
name|int
name|bits
decl_stmt|;
comment|/* number of bits (1-7) from byte at in - 1, or 0 */
name|unsigned
name|char
name|window
index|[
name|WINSIZE
index|]
decl_stmt|;
comment|/* preceding 32K of uncompressed data */
block|}
struct|;
end_struct

begin_comment
comment|/* access point list */
end_comment

begin_struct
struct|struct
name|access
block|{
name|int
name|have
decl_stmt|;
comment|/* number of list entries filled in */
name|int
name|size
decl_stmt|;
comment|/* number of list entries allocated */
name|struct
name|point
modifier|*
name|list
decl_stmt|;
comment|/* allocated list */
block|}
struct|;
end_struct

begin_comment
comment|/* Deallocate an index built by build_index() */
end_comment

begin_function
name|local
name|void
name|free_index
parameter_list|(
name|struct
name|access
modifier|*
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|index
operator|->
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add an entry to the access point list.  If out of memory, deallocate the    existing list and return NULL. */
end_comment

begin_function
name|local
name|struct
name|access
modifier|*
name|addpoint
parameter_list|(
name|struct
name|access
modifier|*
name|index
parameter_list|,
name|int
name|bits
parameter_list|,
name|off_t
name|in
parameter_list|,
name|off_t
name|out
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|char
modifier|*
name|window
parameter_list|)
block|{
name|struct
name|point
modifier|*
name|next
decl_stmt|;
comment|/* if list is empty, create it (start with eight points) */
if|if
condition|(
name|index
operator|==
name|NULL
condition|)
block|{
name|index
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|access
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|index
operator|->
name|list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|point
argument_list|)
operator|<<
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|list
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index
operator|->
name|size
operator|=
literal|8
expr_stmt|;
name|index
operator|->
name|have
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if list is full, make it bigger */
elseif|else
if|if
condition|(
name|index
operator|->
name|have
operator|==
name|index
operator|->
name|size
condition|)
block|{
name|index
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
name|next
operator|=
name|realloc
argument_list|(
name|index
operator|->
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|point
argument_list|)
operator|*
name|index
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|free_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index
operator|->
name|list
operator|=
name|next
expr_stmt|;
block|}
comment|/* fill in entry and increment how many we have */
name|next
operator|=
name|index
operator|->
name|list
operator|+
name|index
operator|->
name|have
expr_stmt|;
name|next
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
name|next
operator|->
name|in
operator|=
name|in
expr_stmt|;
name|next
operator|->
name|out
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|left
condition|)
name|memcpy
argument_list|(
name|next
operator|->
name|window
argument_list|,
name|window
operator|+
name|WINSIZE
operator|-
name|left
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|WINSIZE
condition|)
name|memcpy
argument_list|(
name|next
operator|->
name|window
operator|+
name|left
argument_list|,
name|window
argument_list|,
name|WINSIZE
operator|-
name|left
argument_list|)
expr_stmt|;
name|index
operator|->
name|have
operator|++
expr_stmt|;
comment|/* return list, possibly reallocated */
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Make one entire pass through the compressed stream and build an index, with    access points about every span bytes of uncompressed output -- span is    chosen to balance the speed of random access against the memory requirements    of the list, about 32K bytes per access point.  Note that data after the end    of the first zlib or gzip stream in the file is ignored.  build_index()    returns the number of access points on success (>= 1), Z_MEM_ERROR for out    of memory, Z_DATA_ERROR for an error in the input file, or Z_ERRNO for a    file read error.  On success, *built points to the resulting index. */
end_comment

begin_function
name|local
name|int
name|build_index
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|off_t
name|span
parameter_list|,
name|struct
name|access
modifier|*
modifier|*
name|built
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|off_t
name|totin
decl_stmt|,
name|totout
decl_stmt|;
comment|/* our own total counters to avoid 4GB limit */
name|off_t
name|last
decl_stmt|;
comment|/* totout value of last access point */
name|struct
name|access
modifier|*
name|index
decl_stmt|;
comment|/* access points being generated */
name|z_stream
name|strm
decl_stmt|;
name|unsigned
name|char
name|input
index|[
name|CHUNK
index|]
decl_stmt|;
name|unsigned
name|char
name|window
index|[
name|WINSIZE
index|]
decl_stmt|;
comment|/* initialize inflate */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
literal|47
argument_list|)
expr_stmt|;
comment|/* automatic zlib or gzip decoding */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
comment|/* inflate the input, maintain a sliding window, and build an index -- this        also validates the integrity of the compressed data using the check        information at the end of the gzip or zlib stream */
name|totin
operator|=
name|totout
operator|=
name|last
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|NULL
expr_stmt|;
comment|/* will be allocated by first addpoint() */
name|strm
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* get some compressed data from input file */
name|strm
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|input
argument_list|,
literal|1
argument_list|,
name|CHUNK
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|ret
operator|=
name|Z_ERRNO
expr_stmt|;
goto|goto
name|build_index_error
goto|;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|build_index_error
goto|;
block|}
name|strm
operator|.
name|next_in
operator|=
name|input
expr_stmt|;
comment|/* process all of that, or until end of stream */
do|do
block|{
comment|/* reset sliding window if necessary */
if|if
condition|(
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|strm
operator|.
name|avail_out
operator|=
name|WINSIZE
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|window
expr_stmt|;
block|}
comment|/* inflate until out of input, output, or at end of block --                update the total input and output counters */
name|totin
operator|+=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|totout
operator|+=
name|strm
operator|.
name|avail_out
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_BLOCK
argument_list|)
expr_stmt|;
comment|/* return at end of block */
name|totin
operator|-=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|totout
operator|-=
name|strm
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_NEED_DICT
condition|)
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
operator|||
name|ret
operator|==
name|Z_DATA_ERROR
condition|)
goto|goto
name|build_index_error
goto|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
comment|/* if at end of block, consider adding an index entry (note that if                data_type indicates an end-of-block, then all of the                uncompressed data from that block has been delivered, and none                of the compressed data after that block has been consumed,                except for up to seven bits) -- the totout == 0 provides an                entry point after the zlib or gzip header, and assures that the                index always has at least one access point; we avoid creating an                access point after the last block by checking bit 6 of data_type              */
if|if
condition|(
operator|(
name|strm
operator|.
name|data_type
operator|&
literal|128
operator|)
operator|&&
operator|!
operator|(
name|strm
operator|.
name|data_type
operator|&
literal|64
operator|)
operator|&&
operator|(
name|totout
operator|==
literal|0
operator|||
name|totout
operator|-
name|last
operator|>
name|span
operator|)
condition|)
block|{
name|index
operator|=
name|addpoint
argument_list|(
name|index
argument_list|,
name|strm
operator|.
name|data_type
operator|&
literal|7
argument_list|,
name|totin
argument_list|,
name|totout
argument_list|,
name|strm
operator|.
name|avail_out
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|Z_MEM_ERROR
expr_stmt|;
goto|goto
name|build_index_error
goto|;
block|}
name|last
operator|=
name|totout
expr_stmt|;
block|}
block|}
do|while
condition|(
name|strm
operator|.
name|avail_in
operator|!=
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* clean up and return index (release unused entries in list) */
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|index
operator|->
name|list
operator|=
name|realloc
argument_list|(
name|index
operator|->
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|point
argument_list|)
operator|*
name|index
operator|->
name|have
argument_list|)
expr_stmt|;
name|index
operator|->
name|size
operator|=
name|index
operator|->
name|have
expr_stmt|;
operator|*
name|built
operator|=
name|index
expr_stmt|;
return|return
name|index
operator|->
name|size
return|;
comment|/* return error */
name|build_index_error
label|:
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL
condition|)
name|free_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Use the index to read len bytes from offset into buf, return bytes read or    negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past    the end of the uncompressed data, then extract() will return a value less    than len, indicating how much as actually read into buf.  This function    should not return a data error unless the file was modified since the index    was generated.  extract() may also return Z_ERRNO if there is an error on    reading or seeking the input file. */
end_comment

begin_function
name|local
name|int
name|extract
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|struct
name|access
modifier|*
name|index
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|skip
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|struct
name|point
modifier|*
name|here
decl_stmt|;
name|unsigned
name|char
name|input
index|[
name|CHUNK
index|]
decl_stmt|;
name|unsigned
name|char
name|discard
index|[
name|WINSIZE
index|]
decl_stmt|;
comment|/* proceed only if something reasonable to do */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* find where in stream to start */
name|here
operator|=
name|index
operator|->
name|list
expr_stmt|;
name|ret
operator|=
name|index
operator|->
name|have
expr_stmt|;
while|while
condition|(
operator|--
name|ret
operator|&&
name|here
index|[
literal|1
index|]
operator|.
name|out
operator|<=
name|offset
condition|)
name|here
operator|++
expr_stmt|;
comment|/* initialize file and inflate state to start there */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
operator|-
literal|15
argument_list|)
expr_stmt|;
comment|/* raw inflate */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|fseeko
argument_list|(
name|in
argument_list|,
name|here
operator|->
name|in
operator|-
operator|(
name|here
operator|->
name|bits
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
goto|goto
name|extract_ret
goto|;
if|if
condition|(
name|here
operator|->
name|bits
condition|)
block|{
name|ret
operator|=
name|getc
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|ferror
argument_list|(
name|in
argument_list|)
condition|?
name|Z_ERRNO
else|:
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|extract_ret
goto|;
block|}
operator|(
name|void
operator|)
name|inflatePrime
argument_list|(
operator|&
name|strm
argument_list|,
name|here
operator|->
name|bits
argument_list|,
name|ret
operator|>>
operator|(
literal|8
operator|-
name|here
operator|->
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|inflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|here
operator|->
name|window
argument_list|,
name|WINSIZE
argument_list|)
expr_stmt|;
comment|/* skip uncompressed bytes until offset reached, then satisfy request */
name|offset
operator|-=
name|here
operator|->
name|out
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|1
expr_stmt|;
comment|/* while skipping to offset */
do|do
block|{
comment|/* define where to put uncompressed data, and how much */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|skip
condition|)
block|{
comment|/* at offset now */
name|strm
operator|.
name|avail_out
operator|=
name|len
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* only do this once */
block|}
if|if
condition|(
name|offset
operator|>
name|WINSIZE
condition|)
block|{
comment|/* skip WINSIZE bytes */
name|strm
operator|.
name|avail_out
operator|=
name|WINSIZE
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|discard
expr_stmt|;
name|offset
operator|-=
name|WINSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* last skip */
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|unsigned
operator|)
name|offset
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|discard
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* uncompress until avail_out filled, or end of stream */
do|do
block|{
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|strm
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|input
argument_list|,
literal|1
argument_list|,
name|CHUNK
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|ret
operator|=
name|Z_ERRNO
expr_stmt|;
goto|goto
name|extract_ret
goto|;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|extract_ret
goto|;
block|}
name|strm
operator|.
name|next_in
operator|=
name|input
expr_stmt|;
block|}
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
comment|/* normal inflate */
if|if
condition|(
name|ret
operator|==
name|Z_NEED_DICT
condition|)
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
operator|||
name|ret
operator|==
name|Z_DATA_ERROR
condition|)
goto|goto
name|extract_ret
goto|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
do|while
condition|(
name|strm
operator|.
name|avail_out
operator|!=
literal|0
condition|)
do|;
comment|/* if reach end of stream, then don't keep trying to get more */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
comment|/* do until offset reached and requested data read, or stream ends */
block|}
do|while
condition|(
name|skip
condition|)
do|;
comment|/* compute number of uncompressed bytes read after offset */
name|ret
operator|=
name|skip
condition|?
literal|0
else|:
name|len
operator|-
name|strm
operator|.
name|avail_out
expr_stmt|;
comment|/* clean up and return bytes read or error */
name|extract_ret
label|:
operator|(
name|void
operator|)
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Demonstrate the use of build_index() and extract() by processing the file    provided on the command line, and the extracting 16K from about 2/3rds of    the way through the uncompressed output, and writing that to stdout. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|struct
name|access
modifier|*
name|index
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|CHUNK
index|]
decl_stmt|;
comment|/* open input file */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: zran file.gz\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: could not open %s for reading\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* build index */
name|len
operator|=
name|build_index
argument_list|(
name|in
argument_list|,
name|SPAN
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
name|Z_MEM_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: out of memory\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: compressed data error in %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_ERRNO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: read error on %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: error %d while building index\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: built index with %d access points\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* use index by reading some bytes from an arbitrary offset */
name|offset
operator|=
operator|(
name|index
operator|->
name|list
index|[
name|index
operator|->
name|have
operator|-
literal|1
index|]
operator|.
name|out
operator|<<
literal|1
operator|)
operator|/
literal|3
expr_stmt|;
name|len
operator|=
name|extract
argument_list|(
name|in
argument_list|,
name|index
argument_list|,
name|offset
argument_list|,
name|buf
argument_list|,
name|CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: extraction failed: %s error\n"
argument_list|,
name|len
operator|==
name|Z_MEM_ERROR
condition|?
literal|"out of memory"
else|:
literal|"input corrupted"
argument_list|)
expr_stmt|;
else|else
block|{
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zran: extracted %d bytes at %llu\n"
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* clean up and exit */
name|free_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

