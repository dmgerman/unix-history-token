begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * read a zone file from disk and prints it, one RR per line  *  * (c) NLnetLabs 2008  *  * See the file LICENSE for the license  *  * Missing from the checks: empty non-terminals  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|verbosity
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|check_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|inception_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|expiration_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|do_sigchase
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|no_nomatch_msg
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|myout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|myerr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|update_error
parameter_list|(
name|ldns_status
modifier|*
name|result
parameter_list|,
name|ldns_status
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
operator|*
name|result
operator|==
name|LDNS_STATUS_OK
operator|||
operator|*
name|result
operator|==
name|LDNS_STATUS_ERR
operator|||
operator|(
operator|*
name|result
operator|==
name|LDNS_STATUS_CRYPTO_NO_MATCHING_KEYTAG_DNSKEY
operator|&&
name|status
operator|!=
name|LDNS_STATUS_ERR
operator|)
condition|)
block|{
operator|*
name|result
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_type
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
block|{
specifier|const
name|ldns_rr_descriptor
modifier|*
name|descriptor
init|=
name|ldns_rr_descript
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|&&
name|descriptor
operator|->
name|_name
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|descriptor
operator|->
name|_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"TYPE%u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ldns_status
name|read_key_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_status
name|status
init|=
name|LDNS_STATUS_ERR
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|my_ttl
init|=
literal|0
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_origin
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_prev
init|=
name|NULL
decl_stmt|;
name|int
name|line_nr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
return|return
name|LDNS_STATUS_FILE_ERR
return|;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|status
operator|=
name|ldns_rr_new_frm_fp_l
argument_list|(
operator|&
name|rr
argument_list|,
name|fp
argument_list|,
operator|&
name|my_ttl
argument_list|,
operator|&
name|my_origin
argument_list|,
operator|&
name|my_prev
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
condition|)
name|ldns_rr_list_push_rr
argument_list|(
name|keys
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_SYNTAX_EMPTY
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_TTL
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_ORIGIN
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_INCLUDE
condition|)
name|status
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
else|else
break|break;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_rr_error
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|ldns_rr
modifier|*
name|rr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Error: %s for "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stream
argument_list|,
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|stream
argument_list|,
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_rr_status_error
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|ldns_rr
modifier|*
name|rr
parameter_list|,
name|ldns_status
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|print_rr_error
argument_list|(
name|stream
argument_list|,
name|rr
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
literal|0
operator|&&
name|status
operator|==
name|LDNS_STATUS_SSL_ERR
condition|)
block|{
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_rrs_status_error
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|ldns_rr_list
modifier|*
name|rrs
parameter_list|,
name|ldns_status
name|status
parameter_list|,
name|ldns_dnssec_rrs
modifier|*
name|cur_sig
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|rrs
argument_list|)
operator|>
literal|0
condition|)
block|{
name|print_rr_status_error
argument_list|(
name|stream
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|rrs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Error: %s for<unknown>\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"RRSet:\n"
argument_list|)
expr_stmt|;
name|ldns_rr_list_print
argument_list|(
name|stream
argument_list|,
name|rrs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Signature:\n"
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|stream
argument_list|,
name|cur_sig
operator|->
name|rr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|rrsig_check_time_margins
parameter_list|(
name|ldns_rr
modifier|*
name|rrsig
if|#
directive|if
literal|0
comment|/* Passing those as arguments becomes sensible when         * rrsig_check_time_margins will be added to the library.        */
parameter_list|,time_t check_time, int32_t inception_offset, int32_t expiration_offset
endif|#
directive|endif
parameter_list|)
block|{
name|int32_t
name|inception
decl_stmt|,
name|expiration
decl_stmt|;
name|inception
operator|=
name|ldns_rdf2native_int32
argument_list|(
name|ldns_rr_rrsig_inception
argument_list|(
name|rrsig
argument_list|)
argument_list|)
expr_stmt|;
name|expiration
operator|=
name|ldns_rdf2native_int32
argument_list|(
name|ldns_rr_rrsig_expiration
argument_list|(
name|rrsig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|int32_t
call|)
argument_list|(
name|check_time
operator|-
name|inception_offset
argument_list|)
operator|)
operator|-
name|inception
operator|<
literal|0
condition|)
block|{
return|return
name|LDNS_STATUS_CRYPTO_SIG_NOT_INCEPTED_WITHIN_MARGIN
return|;
block|}
if|if
condition|(
name|expiration
operator|-
operator|(
call|(
name|int32_t
call|)
argument_list|(
name|check_time
operator|+
name|expiration_offset
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|LDNS_STATUS_CRYPTO_SIG_EXPIRED_WITHIN_MARGIN
return|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_rrs
parameter_list|(
name|ldns_rr_list
modifier|*
name|rrset_rrs
parameter_list|,
name|ldns_dnssec_rrs
modifier|*
name|cur_sig
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_rr_list
modifier|*
name|good_keys
decl_stmt|;
name|ldns_status
name|status
decl_stmt|,
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
while|while
condition|(
name|cur_sig
condition|)
block|{
name|good_keys
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|status
operator|=
name|ldns_verify_rrsig_keylist_time
argument_list|(
name|rrset_rrs
argument_list|,
name|cur_sig
operator|->
name|rr
argument_list|,
name|keys
argument_list|,
name|check_time
argument_list|,
name|good_keys
argument_list|)
expr_stmt|;
name|status
operator|=
name|status
condition|?
name|status
else|:
name|rrsig_check_time_margins
argument_list|(
name|cur_sig
operator|->
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_CRYPTO_NO_MATCHING_KEYTAG_DNSKEY
operator|||
operator|!
name|no_nomatch_msg
condition|)
block|{
name|print_rrs_status_error
argument_list|(
name|myerr
argument_list|,
name|rrset_rrs
argument_list|,
name|status
argument_list|,
name|cur_sig
argument_list|)
expr_stmt|;
block|}
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|good_keys
argument_list|)
expr_stmt|;
name|cur_sig
operator|=
name|cur_sig
operator|->
name|next
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_dnssec_rrset
parameter_list|(
name|ldns_rdf
modifier|*
name|zone_name
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|ldns_dnssec_rrsets
modifier|*
name|rrset
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_rr_list
modifier|*
name|rrset_rrs
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|cur_rr
decl_stmt|,
modifier|*
name|cur_sig
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|rrset
operator|->
name|rrs
condition|)
return|return
name|LDNS_STATUS_OK
return|;
name|rrset_rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|cur_rr
operator|=
name|rrset
operator|->
name|rrs
expr_stmt|;
while|while
condition|(
name|cur_rr
operator|&&
name|cur_rr
operator|->
name|rr
condition|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|rrset_rrs
argument_list|,
name|cur_rr
operator|->
name|rr
argument_list|)
expr_stmt|;
name|cur_rr
operator|=
name|cur_rr
operator|->
name|next
expr_stmt|;
block|}
name|cur_sig
operator|=
name|rrset
operator|->
name|signatures
expr_stmt|;
if|if
condition|(
name|cur_sig
condition|)
block|{
name|status
operator|=
name|verify_rrs
argument_list|(
name|rrset_rrs
argument_list|,
name|cur_sig
argument_list|,
name|keys
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* delegations may be unsigned (on opt out...) */
if|if
condition|(
name|rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_NS
operator|||
name|ldns_dname_compare
argument_list|(
name|name
argument_list|,
name|zone_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|print_rr_error
argument_list|(
name|myerr
argument_list|,
name|rrset
operator|->
name|rrs
operator|->
name|rr
argument_list|,
literal|"no signatures"
argument_list|)
expr_stmt|;
name|status
operator|=
name|LDNS_STATUS_CRYPTO_NO_RRSIG
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
name|ldns_rr_list_free
argument_list|(
name|rrset_rrs
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_single_rr
parameter_list|(
name|ldns_rr
modifier|*
name|rr
parameter_list|,
name|ldns_dnssec_rrs
modifier|*
name|signature_rrs
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_rr_list
modifier|*
name|rrset_rrs
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|rrset_rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|ldns_rr_list_push_rr
argument_list|(
name|rrset_rrs
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|status
operator|=
name|verify_rrs
argument_list|(
name|rrset_rrs
argument_list|,
name|signature_rrs
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|rrset_rrs
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_next_hashed_name
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_dnssec_name
modifier|*
name|name
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|next_node
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|next_name
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|char
modifier|*
name|next_owner_str
decl_stmt|;
name|ldns_rdf
modifier|*
name|next_owner_dname
decl_stmt|;
name|assert
argument_list|(
name|name
operator|->
name|hashed_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|next_node
operator|=
name|ldns_rbtree_search
argument_list|(
name|zone
operator|->
name|hashed_names
argument_list|,
name|name
operator|->
name|hashed_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next_node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
name|next_node
operator|=
name|ldns_rbtree_next
argument_list|(
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_node
operator|==
name|LDNS_RBTREE_NULL
condition|)
block|{
name|next_node
operator|=
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|hashed_names
argument_list|)
expr_stmt|;
block|}
name|next_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|next_node
operator|->
name|data
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|next_name
operator|->
name|nsec
condition|)
do|;
name|next_owner_str
operator|=
name|ldns_rdf2str
argument_list|(
name|ldns_nsec3_next_owner
argument_list|(
name|name
operator|->
name|nsec
argument_list|)
argument_list|)
expr_stmt|;
name|next_owner_dname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|next_owner_str
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|ldns_dname_compare
argument_list|(
name|next_owner_dname
argument_list|,
name|next_name
operator|->
name|hashed_name
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|next_owner_dname
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|next_owner_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: The NSEC3 record for "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" points to the wrong next hashed owner"
literal|" name\n\tshould point to "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|next_name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|", whose hashed name is "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|next_name
operator|->
name|hashed_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|LDNS_STATUS_ERR
return|;
block|}
else|else
block|{
return|return
name|LDNS_STATUS_OK
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|zone_is_nsec3_optout
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|)
block|{
specifier|static
name|int
name|remember
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|remember
operator|==
operator|-
literal|1
condition|)
block|{
name|remember
operator|=
name|ldns_dnssec_zone_is_nsec3_optout
argument_list|(
name|zone
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|remember
operator|==
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_nsec
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rbnode_t
modifier|*
name|cur_node
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|next_node
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|name
decl_stmt|,
modifier|*
name|next_name
decl_stmt|;
name|ldns_status
name|status
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
name|name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|cur_node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|nsec
condition|)
block|{
if|if
condition|(
name|name
operator|->
name|nsec_signatures
condition|)
block|{
name|status
operator|=
name|verify_single_rr
argument_list|(
name|name
operator|->
name|nsec
argument_list|,
name|name
operator|->
name|nsec_signatures
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: the NSEC(3) record of "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" has no signatures\n"
argument_list|)
expr_stmt|;
block|}
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|LDNS_STATUS_ERR
argument_list|)
expr_stmt|;
block|}
comment|/* check whether the NSEC record points to the right name */
switch|switch
condition|(
name|ldns_rr_get_type
argument_list|(
name|name
operator|->
name|nsec
argument_list|)
condition|)
block|{
case|case
name|LDNS_RR_TYPE_NSEC
case|:
comment|/* simply try next name */
name|next_node
operator|=
name|ldns_rbtree_next
argument_list|(
name|cur_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_node
operator|==
name|LDNS_RBTREE_NULL
condition|)
block|{
name|next_node
operator|=
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
expr_stmt|;
block|}
name|next_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|next_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_node
condition|)
block|{
name|next_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|next_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|next_node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ldns_dname_compare
argument_list|(
name|next_name
operator|->
name|name
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|name
operator|->
name|nsec
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: the "
literal|"NSEC record for "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" points to "
literal|"the wrong "
literal|"next owner name\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"\t: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|name
operator|->
name|nsec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" i.s.o. "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|next_name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|LDNS_STATUS_ERR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LDNS_RR_TYPE_NSEC3
case|:
comment|/* find the hashed next name in the tree */
comment|/* this is expensive, do we need to add  				 * support for this in the structs? 				 * (ie. pointer to next hashed name?) 				 */
name|status
operator|=
name|verify_next_hashed_name
argument_list|(
name|zone
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zone_is_nsec3_optout
argument_list|(
name|zone
argument_list|)
operator|&&
operator|(
name|ldns_dnssec_name_is_glue
argument_list|(
name|name
argument_list|)
operator|||
operator|(
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* ok, no problem, but we need to remember to check 			 * whether the chain does not actually point to this 			 * name later */
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: there is no NSEC(3) for "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|LDNS_STATUS_ERR
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_dnssec_name
parameter_list|(
name|ldns_rdf
modifier|*
name|zone_name
parameter_list|,
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rbnode_t
modifier|*
name|cur_node
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|ldns_dnssec_rrsets
modifier|*
name|cur_rrset
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|name
decl_stmt|;
name|int
name|on_delegation_point
decl_stmt|;
comment|/* for NSEC chain checks */
name|name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|cur_node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|myout
argument_list|,
literal|"Checking: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myout
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_dnssec_name_is_glue
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* glue */
name|cur_rrset
operator|=
name|name
operator|->
name|rrsets
expr_stmt|;
while|while
condition|(
name|cur_rrset
condition|)
block|{
if|if
condition|(
name|cur_rrset
operator|->
name|signatures
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|myerr
argument_list|,
name|cur_rrset
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" has signature(s),"
literal|" but is glue\n"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|LDNS_STATUS_ERR
expr_stmt|;
block|}
name|cur_rrset
operator|=
name|cur_rrset
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|->
name|nsec
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|myerr
argument_list|,
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|" has an NSEC(3),"
literal|" but is glue\n"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|LDNS_STATUS_ERR
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not glue, do real verify */
name|on_delegation_point
operator|=
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
expr_stmt|;
name|cur_rrset
operator|=
name|name
operator|->
name|rrsets
expr_stmt|;
while|while
condition|(
name|cur_rrset
condition|)
block|{
comment|/* Do not check occluded rrsets 			 * on the delegation point 			 */
if|if
condition|(
operator|(
name|on_delegation_point
operator|&&
operator|(
name|cur_rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_NS
operator|||
name|cur_rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DS
operator|)
operator|)
operator|||
operator|(
operator|!
name|on_delegation_point
operator|&&
name|cur_rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_RRSIG
operator|&&
name|cur_rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_NSEC
operator|)
condition|)
block|{
name|status
operator|=
name|verify_dnssec_rrset
argument_list|(
name|zone_name
argument_list|,
name|name
operator|->
name|name
argument_list|,
name|cur_rrset
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|cur_rrset
operator|=
name|cur_rrset
operator|->
name|next
expr_stmt|;
block|}
name|status
operator|=
name|verify_nsec
argument_list|(
name|zone
argument_list|,
name|cur_node
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_keys_with_matching_ds
parameter_list|(
name|ldns_dnssec_rrsets
modifier|*
name|from_keys
parameter_list|,
name|ldns_rr_list
modifier|*
name|dss
parameter_list|,
name|ldns_rr_list
modifier|*
name|to_keys
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|ds_rr
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|cur_key
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|dss
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|ds_rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|dss
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
for|for
control|(
name|cur_key
operator|=
name|from_keys
operator|->
name|rrs
init|;
name|cur_key
condition|;
name|cur_key
operator|=
name|cur_key
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ldns_rr_compare_ds
argument_list|(
name|cur_key
operator|->
name|rr
argument_list|,
name|ds_rr
argument_list|)
condition|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|to_keys
argument_list|,
name|cur_key
operator|->
name|rr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|sigchase
parameter_list|(
name|ldns_resolver
modifier|*
name|res
parameter_list|,
name|ldns_rdf
modifier|*
name|zone_name
parameter_list|,
name|ldns_dnssec_rrsets
modifier|*
name|zonekeys
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_dnssec_rrs
modifier|*
name|cur_key
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|bool
name|free_resolver
init|=
name|false
decl_stmt|;
name|ldns_rdf
modifier|*
name|parent_name
decl_stmt|;
name|ldns_rr_list
modifier|*
name|parent_keys
decl_stmt|;
name|ldns_rr_list
modifier|*
name|ds_keys
decl_stmt|;
name|add_keys_with_matching_ds
argument_list|(
name|zonekeys
argument_list|,
name|keys
argument_list|,
name|keys
argument_list|)
expr_stmt|;
comment|/* First try to authenticate the keys offline. 	 * When do_sigchase is given validation may continue lookup up 	 * keys online. Reporting the failure of the offline validation 	 * should then be suppressed. 	 */
name|no_nomatch_msg
operator|=
name|do_sigchase
expr_stmt|;
name|status
operator|=
name|verify_dnssec_rrset
argument_list|(
name|zone_name
argument_list|,
name|zone_name
argument_list|,
name|zonekeys
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|no_nomatch_msg
operator|=
name|false
expr_stmt|;
comment|/* Continue online on validation failure when the -S option was given. 	 */
if|if
condition|(
name|do_sigchase
operator|&&
name|status
operator|==
name|LDNS_STATUS_CRYPTO_NO_MATCHING_KEYTAG_DNSKEY
operator|&&
name|ldns_dname_label_count
argument_list|(
name|zone_name
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|res
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|ldns_resolver_new_frm_file
argument_list|(
operator|&
name|res
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|ldns_resolver_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Could not create resolver: "
literal|"%s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
name|free_resolver
operator|=
name|true
expr_stmt|;
name|ldns_resolver_set_dnssec
argument_list|(
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ldns_resolver_set_dnssec_cd
argument_list|(
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parent_name
operator|=
name|ldns_dname_left_chop
argument_list|(
name|zone_name
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Use the (authenticated) keys of the parent zone ... 			 */
name|parent_keys
operator|=
name|ldns_fetch_valid_domain_keys
argument_list|(
name|res
argument_list|,
name|parent_name
argument_list|,
name|keys
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|parent_name
argument_list|)
expr_stmt|;
comment|/* 			 * ... to validate the DS for the zone ... 			 */
name|ds_keys
operator|=
name|ldns_validate_domain_ds
argument_list|(
name|res
argument_list|,
name|zone_name
argument_list|,
name|parent_keys
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|parent_keys
argument_list|)
expr_stmt|;
comment|/* 			 * ... to use it to add the KSK to the trusted keys ... 			 */
name|add_keys_with_matching_ds
argument_list|(
name|zonekeys
argument_list|,
name|ds_keys
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|ds_keys
argument_list|)
expr_stmt|;
comment|/* 			 * ... to validate all zonekeys ... 			 */
name|status
operator|=
name|verify_dnssec_rrset
argument_list|(
name|zone_name
argument_list|,
name|zone_name
argument_list|,
name|zonekeys
argument_list|,
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|LDNS_STATUS_MEM_ERR
expr_stmt|;
block|}
if|if
condition|(
name|free_resolver
condition|)
block|{
name|ldns_resolver_deep_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * ... so they can all be added to our list of trusted keys. 	 */
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
for|for
control|(
name|cur_key
operator|=
name|zonekeys
operator|->
name|rrs
init|;
name|cur_key
condition|;
name|cur_key
operator|=
name|cur_key
operator|->
name|next
control|)
name|ldns_rr_list_push_rr
argument_list|(
name|keys
argument_list|,
name|cur_key
operator|->
name|rr
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|ldns_status
name|verify_dnssec_zone
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|dnssec_zone
parameter_list|,
name|ldns_rdf
modifier|*
name|zone_name
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|,
name|bool
name|apexonly
parameter_list|,
name|int
name|percentage
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|cur_node
decl_stmt|;
name|ldns_dnssec_rrsets
modifier|*
name|cur_key_rrset
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|cur_key
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
name|cur_key_rrset
operator|=
name|ldns_dnssec_zone_find_rrset
argument_list|(
name|dnssec_zone
argument_list|,
name|zone_name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_key_rrset
operator|||
operator|!
name|cur_key_rrset
operator|->
name|rrs
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: No DNSKEY records at zone apex\n"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|LDNS_STATUS_ERR
expr_stmt|;
block|}
else|else
block|{
comment|/* are keys given with -k to use for validation? */
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|sigchase
argument_list|(
name|NULL
argument_list|,
name|zone_name
argument_list|,
name|cur_key_rrset
argument_list|,
name|keys
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
for|for
control|(
name|cur_key
operator|=
name|cur_key_rrset
operator|->
name|rrs
init|;
name|cur_key
condition|;
name|cur_key
operator|=
name|cur_key
operator|->
name|next
control|)
name|ldns_rr_list_push_rr
argument_list|(
name|keys
argument_list|,
name|cur_key
operator|->
name|rr
argument_list|)
expr_stmt|;
name|cur_node
operator|=
name|ldns_rbtree_first
argument_list|(
name|dnssec_zone
operator|->
name|names
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_node
operator|==
name|LDNS_RBTREE_NULL
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error: Empty zone?\n"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|LDNS_STATUS_ERR
expr_stmt|;
block|}
if|if
condition|(
name|apexonly
condition|)
block|{
comment|/* 			 * In this case, only the first node in the treewalk 			 * below should be checked. 			 */
name|assert
argument_list|(
name|cur_node
operator|->
name|data
operator|==
name|dnssec_zone
operator|->
name|soa
argument_list|)
expr_stmt|;
comment|/*  			 * Allthough the percentage option doesn't make sense 			 * here, we set it to 100 to force the first node to  			 * be checked. 			 */
name|percentage
operator|=
literal|100
expr_stmt|;
block|}
while|while
condition|(
name|cur_node
operator|!=
name|LDNS_RBTREE_NULL
condition|)
block|{
comment|/* should we check this one? saves calls to random. */
if|if
condition|(
name|percentage
operator|==
literal|100
operator|||
operator|(
operator|(
name|random
argument_list|()
operator|%
literal|100
operator|)
operator|>=
literal|100
operator|-
name|percentage
operator|)
condition|)
block|{
name|status
operator|=
name|verify_dnssec_name
argument_list|(
name|zone_name
argument_list|,
name|dnssec_zone
argument_list|,
name|cur_node
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|update_error
argument_list|(
operator|&
name|result
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|apexonly
condition|)
break|break;
block|}
name|cur_node
operator|=
name|ldns_rbtree_next
argument_list|(
name|cur_node
argument_list|)
expr_stmt|;
block|}
block|}
name|error
label|:
name|ldns_rr_list_free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|line_nr
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|ldns_dnssec_zone
modifier|*
name|dnssec_zone
init|=
name|NULL
decl_stmt|;
name|ldns_status
name|result
init|=
name|LDNS_STATUS_ERR
decl_stmt|;
name|bool
name|apexonly
init|=
name|false
decl_stmt|;
name|int
name|percentage
init|=
literal|100
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|ldns_duration_type
modifier|*
name|duration
decl_stmt|;
name|ldns_rr_list
modifier|*
name|keys
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
name|size_t
name|nkeys
init|=
literal|0
decl_stmt|;
name|check_time
operator|=
name|ldns_time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|myout
operator|=
name|stdout
expr_stmt|;
name|myerr
operator|=
name|stderr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ae:hi:k:vV:p:St:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|apexonly
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|printf
argument_list|(
literal|"Usage: %s [OPTIONS]<zonefile>\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tReads the zonefile and checks for DNSSEC "
literal|"errors.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nIt checks whether NSEC(3)s are present, "
literal|"and verifies all signatures\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"It also checks the NSEC(3) chain, but it "
literal|"will error on opted-out delegations\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nOPTIONS:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-h\t\tshow this text\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-a\t\tapex only, "
literal|"check only the zone apex\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-e<period>\tsignatures may not expire "
literal|"within this period.\n\t\t\t"
literal|"(default no period is used)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-i<period>\tsignatures must have been "
literal|"valid at least this long.\n\t\t\t"
literal|"(default signatures should just be valid "
literal|"now)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-k<file>\tspecify a file that contains a "
literal|"trusted DNSKEY or DS rr.\n\t\t\t"
literal|"This option may be given more than once.\n"
literal|"\t\t\tDefault is %s"
argument_list|,
name|LDNS_TRUST_ANCHOR_FILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-p [0-100]\tonly checks this percentage of "
literal|"the zone.\n\t\t\tDefaults to 100\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-S\t\tchase signature(s) to a known key. "
literal|"The network may be\n\t\t\taccessed to "
literal|"validate the zone's DNSKEYs. (implies -k)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-t YYYYMMDDhhmmss | [+|-]offset\n\t\t\t"
literal|"set the validation time either by an "
literal|"absolute time\n\t\t\tvalue or as an "
literal|"offset in seconds from<now>.\n\t\t\t"
literal|"For data that came from the network (while "
literal|"chasing),\n\t\t\tsystem time will be used "
literal|"for validating it regardless.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-v\t\tshows the version and exits\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-V [0-5]\tset verbosity level (default 3)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n<period>s are given "
literal|"in ISO 8601 duration format: "
literal|"P[n]Y[n]M[n]DT[n]H[n]M[n]S\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nif no file is given "
literal|"standard input is read\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'i'
case|:
name|duration
operator|=
name|ldns_duration_create_from_string
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duration
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"<period> should be in ISO "
literal|"8601 duration format: "
literal|"P[n]Y[n]M[n]DT[n]H[n]M[n]S\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
name|expiration_offset
operator|=
name|ldns_duration2time
argument_list|(
name|duration
argument_list|)
expr_stmt|;
else|else
name|inception_offset
operator|=
name|ldns_duration2time
argument_list|(
name|duration
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|s
operator|=
name|read_key_file
argument_list|(
name|optarg
argument_list|,
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_FILE_ERR
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Error opening %s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Could not parse key file "
literal|"%s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
operator|==
name|nkeys
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"No keys found in file %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|nkeys
operator|=
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|percentage
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|percentage
operator|<
literal|0
operator|||
name|percentage
operator|>
literal|100
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"percentage needs to fall "
literal|"between 0..100\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|srandom
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_sigchase
operator|=
name|true
expr_stmt|;
comment|/* may chase */
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|==
literal|14
operator|&&
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%4d%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|)
operator|==
literal|6
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|check_time
operator|=
name|ldns_mktime_from_utc
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_time
operator|+=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"verify-zone version %s (ldns version %s)\n"
argument_list|,
name|LDNS_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|verbosity
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|do_sigchase
operator|&&
name|nkeys
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|read_key_file
argument_list|(
name|LDNS_TRUST_ANCHOR_FILE
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|nkeys
operator|=
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Unable to chase "
literal|"signature without keys.\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|ldns_dnssec_zone_new_frm_fp_l
argument_list|(
operator|&
name|dnssec_zone
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
operator|!
name|dnssec_zone
operator|->
name|soa
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"; Error: no SOA in the zone\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ldns_dnssec_zone_mark_glue
argument_list|(
name|dnssec_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"There were errors identifying the "
literal|"glue in the zone\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|5
condition|)
block|{
name|ldns_dnssec_zone_print
argument_list|(
name|myout
argument_list|,
name|dnssec_zone
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|verify_dnssec_zone
argument_list|(
name|dnssec_zone
argument_list|,
name|dnssec_zone
operator|->
name|soa
operator|->
name|name
argument_list|,
name|keys
argument_list|,
name|apexonly
argument_list|,
name|percentage
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|myout
argument_list|,
literal|"Zone is verified and complete\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"There were errors in the zone\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_dnssec_zone_deep_free
argument_list|(
name|dnssec_zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|myerr
argument_list|,
literal|"%s at %d\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns-verify-zone needs OpenSSL support, "
literal|"which has not been compiled in\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

end_unit

