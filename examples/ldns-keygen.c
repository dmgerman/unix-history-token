begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * keygen is a small programs that generate a dnskey and private key  * for a particular domain.  *  * (c) NLnet Labs, 2005 - 2008  * See the file LICENSE for the license  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s -a<algorithm> [-b bits] [-r /dev/random] [-v] domain\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  generate a new key pair for domain\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -a<alg>\tuse the specified algorithm (-a list to"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" show a list)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -k\t\tset the flags to 257; key signing key\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -b<bits>\tspecify the keylength\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -r<random>\tspecify a random device (defaults to /dev/random)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\tto seed the random generator with\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -v\t\tshow the version and exit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  The following files will be created:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    K<name>+<alg>+<id>.key\tPublic key in RR format\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    K<name>+<alg>+<id>.private\tPrivate key in key format\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    K<name>+<alg>+<id>.ds\tDS in RR format (only for DNSSEC keys)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  The base name (K<name>+<alg>+<id> will be printed to stdout\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_algorithms
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|ldns_lookup_table
modifier|*
name|lt
init|=
name|ldns_signing_algorithms
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Possible algorithms:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|lt
operator|->
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|lt
operator|->
name|name
argument_list|)
expr_stmt|;
name|lt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* default key size */
name|uint16_t
name|def_bits
init|=
literal|1024
decl_stmt|;
name|uint16_t
name|bits
init|=
name|def_bits
decl_stmt|;
name|bool
name|ksk
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|FILE
modifier|*
name|random
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|owner
decl_stmt|;
name|ldns_signing_algorithm
name|algorithm
decl_stmt|;
name|ldns_rdf
modifier|*
name|domain
decl_stmt|;
name|ldns_rr
modifier|*
name|pubkey
decl_stmt|;
name|ldns_key
modifier|*
name|key
decl_stmt|;
name|ldns_rr
modifier|*
name|ds
decl_stmt|;
name|prog
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|algorithm
operator|=
literal|0
expr_stmt|;
name|random
operator|=
name|NULL
expr_stmt|;
name|ksk
operator|=
name|false
expr_stmt|;
comment|/* don't create a ksk per default */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:kb:r:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|algorithm
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The -a argument can only be used once\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"list"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|show_algorithms
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|algorithm
operator|=
name|ldns_get_signing_algorithm_by_name
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|algorithm
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Algorithm %s not found\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|show_algorithms
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
name|bits
operator|=
operator|(
name|uint16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %d"
argument_list|,
name|prog
argument_list|,
literal|"Can not parse the -b argument, setting it to the default\n"
argument_list|,
operator|(
name|int
operator|)
name|def_bits
argument_list|)
expr_stmt|;
name|bits
operator|=
name|def_bits
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|ksk
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|random
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|random
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open random file %s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"DNSSEC key generator version %s (ldns version %s)\n"
argument_list|,
name|LDNS_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|algorithm
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Please use the -a argument to provide an algorithm\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|usage
argument_list|(
name|stderr
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
comment|/* check whether key size is within RFC boundaries */
switch|switch
condition|(
name|algorithm
condition|)
block|{
case|case
name|LDNS_SIGN_RSAMD5
case|:
case|case
name|LDNS_SIGN_RSASHA1
case|:
if|if
condition|(
name|bits
operator|<
literal|512
operator|||
name|bits
operator|>
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For RSA, the key size must be between "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" 512 and 4096 bytes. Aborting.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LDNS_SIGN_DSA
case|:
if|if
condition|(
name|bits
operator|<
literal|512
operator|||
name|bits
operator|>
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For DSA, the key size must be between "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" 512 and 1024 bytes. Aborting.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_SIGN_ECC_GOST
case|:
if|if
condition|(
operator|!
name|ldns_key_EVP_load_gost_id
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: libcrypto does not provide GOST\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SIGN_ECDSAP256SHA256
case|:
case|case
name|LDNS_SIGN_ECDSAP384SHA384
case|:
endif|#
directive|endif
case|case
name|LDNS_SIGN_HMACMD5
case|:
case|case
name|LDNS_SIGN_HMACSHA1
case|:
case|case
name|LDNS_SIGN_HMACSHA256
case|:
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|random
condition|)
block|{
name|random
operator|=
name|fopen
argument_list|(
literal|"/dev/random"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|random
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open random file %s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|ldns_init_random
argument_list|(
name|random
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bits
operator|/
literal|8
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|random
argument_list|)
expr_stmt|;
comment|/* create an rdf from the domain name */
name|domain
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* generate a new key */
name|key
operator|=
name|ldns_key_new_frm_algorithm
argument_list|(
name|algorithm
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* set the owner name in the key - this is a /separate/ step */
name|ldns_key_set_pubkey_owner
argument_list|(
name|key
argument_list|,
name|domain
argument_list|)
expr_stmt|;
comment|/* ksk flag */
if|if
condition|(
name|ksk
condition|)
block|{
name|ldns_key_set_flags
argument_list|(
name|key
argument_list|,
name|ldns_key_flags
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create the public from the ldns_key */
name|pubkey
operator|=
name|ldns_key2rr
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pubkey
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not extract the public key from the key structure..."
argument_list|)
expr_stmt|;
name|ldns_key_deep_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|owner
operator|=
name|ldns_rdf2str
argument_list|(
name|ldns_rr_owner
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate and set the keytag */
name|ldns_key_set_keytag
argument_list|(
name|key
argument_list|,
name|ldns_calc_keytag
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build the DS record */
switch|switch
condition|(
name|algorithm
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SIGN_ECDSAP384SHA384
case|:
name|ds
operator|=
name|ldns_key_rr2ds
argument_list|(
name|pubkey
argument_list|,
name|LDNS_SHA384
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGN_ECDSAP256SHA256
case|:
endif|#
directive|endif
case|case
name|LDNS_SIGN_RSASHA256
case|:
case|case
name|LDNS_SIGN_RSASHA512
case|:
name|ds
operator|=
name|ldns_key_rr2ds
argument_list|(
name|pubkey
argument_list|,
name|LDNS_SHA256
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGN_ECC_GOST
case|:
ifdef|#
directive|ifdef
name|USE_GOST
name|ds
operator|=
name|ldns_key_rr2ds
argument_list|(
name|pubkey
argument_list|,
name|LDNS_HASH_GOST
argument_list|)
expr_stmt|;
else|#
directive|else
name|ds
operator|=
name|ldns_key_rr2ds
argument_list|(
name|pubkey
argument_list|,
name|LDNS_SHA256
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|ds
operator|=
name|ldns_key_rr2ds
argument_list|(
name|pubkey
argument_list|,
name|LDNS_SHA1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* print the public key RR to .key */
name|filename
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|17
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|16
argument_list|,
literal|"K%s+%03u+%05u.key"
argument_list|,
name|owner
argument_list|,
name|algorithm
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_key_deep_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* temporarily set question so that TTL is not printed */
name|ldns_rr_set_question
argument_list|(
name|pubkey
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|file
argument_list|,
name|pubkey
argument_list|)
expr_stmt|;
name|ldns_rr_set_question
argument_list|(
name|pubkey
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* print the priv key to stderr */
name|filename
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|21
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|20
argument_list|,
literal|"K%s+%03u+%05u.private"
argument_list|,
name|owner
argument_list|,
name|algorithm
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_key_deep_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_key_print
argument_list|(
name|file
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* print the DS to .ds */
if|if
condition|(
name|algorithm
operator|!=
name|LDNS_SIGN_HMACMD5
operator|&&
name|algorithm
operator|!=
name|LDNS_SIGN_HMACSHA1
operator|&&
name|algorithm
operator|!=
name|LDNS_SIGN_HMACSHA256
condition|)
block|{
name|filename
operator|=
name|LDNS_XMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|owner
argument_list|)
operator|+
literal|15
argument_list|,
literal|"K%s+%03u+%05u.ds"
argument_list|,
name|owner
argument_list|,
name|algorithm
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_key_deep_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* temporarily set question so that TTL is not printed */
name|ldns_rr_set_question
argument_list|(
name|ds
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|file
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ldns_rr_set_question
argument_list|(
name|ds
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"K%s+%03u+%05u\n"
argument_list|,
name|owner
argument_list|,
name|algorithm
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ldns_key_keytag
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_key_deep_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns-keygen needs OpenSSL support, which has not been compiled in\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

end_unit

