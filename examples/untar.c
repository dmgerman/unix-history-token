begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file is in the public domain.  * Use it as you wish.  */
end_comment

begin_comment
comment|/*  * This is a compact tar extraction program using libarchive whose  * primary goal is small executable size.  Statically linked, it can  * be very small, depending in large part on how cleanly factored your  * system libraries are.  Note that this uses the standard libarchive,  * without any special recompilation.  The only functional concession  * is that this program uses the uid/gid from the archive instead of  * doing uname/gname lookups.  (Add a call to  * archive_write_disk_set_standard_lookup() to enable uname/gname  * lookups, but be aware that this can add 500k or more to a static  * executable, depending on the system libraries, since user/group  * lookups frequently pull in password, YP/LDAP, networking, and DNS  * resolver libraries.)  *  * To build:  * $ gcc -static -Wall -o untar untar.c -larchive  * $ strip untar  *  * NOTE: On some systems, you may need to add additional flags  * to ensure that untar.c is compiled the same way as libarchive  * was compiled.  In particular, Linux users will probably  * have to add -D_FILE_OFFSET_BITS=64 to the command line above.  *  * For fun, statically compile the following simple hello.c program  * using the same flags as for untar and compare the size:  *  * #include<stdio.h>  * int main(int argc, char **argv) {  *    printf("hello, world\n");  *    return(0);  * }  *  * You may be even more surprised by the compiled size of true.c listed here:  *  * int main(int argc, char **argv) {  *    return (0);  * }  *  * On a slightly customized FreeBSD 5 system that I used around  * 2005, hello above compiled to 89k compared to untar of 69k.  So at  * that time, libarchive's tar reader and extract-to-disk routines  * compiled to less code than printf().  *  * On my FreeBSD development system today (August, 2009):  *  hello: 195024 bytes  *  true: 194912 bytes  *  untar: 259924 bytes  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<archive.h>
end_include

begin_include
include|#
directive|include
file|<archive_entry.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
specifier|static
name|void
name|errmsg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extract
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|do_extract
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fail
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|int
name|compress
decl_stmt|,
name|flags
decl_stmt|,
name|mode
decl_stmt|,
name|opt
decl_stmt|;
operator|(
name|void
operator|)
name|argc
expr_stmt|;
name|mode
operator|=
literal|'x'
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|compress
operator|=
literal|'\0'
expr_stmt|;
name|flags
operator|=
name|ARCHIVE_EXTRACT_TIME
expr_stmt|;
comment|/* Among other sins, getopt(3) pulls in printf(3). */
while|while
condition|(
operator|*
operator|++
name|argv
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|argv
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|filename
operator|=
name|p
expr_stmt|;
else|else
name|filename
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator||=
name|ARCHIVE_EXTRACT_PERM
expr_stmt|;
name|flags
operator||=
name|ARCHIVE_EXTRACT_ACL
expr_stmt|;
name|flags
operator||=
name|ARCHIVE_EXTRACT_FFLAGS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'t'
case|:
name|extract
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|extract
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extract
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|do_extract
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive
modifier|*
name|ext
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|r
decl_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
name|ext
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
name|archive_write_disk_set_options
argument_list|(
name|ext
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Note: archive_write_disk_set_standard_lookup() is useful 	 * here, but it requires library routines that can add 500k or 	 * more to a static executable. 	 */
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* 	 * On my system, enabling other archive formats adds 20k-30k 	 * each.  Enabling gzip decompression adds about 20k. 	 * Enabling bzip2 is more expensive because the libbz2 library 	 * isn't very well factored. 	 */
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|archive_read_open_filename
argument_list|(
name|a
argument_list|,
name|filename
argument_list|,
literal|10240
argument_list|)
operator|)
condition|)
name|fail
argument_list|(
literal|"archive_read_open_filename()"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|fail
argument_list|(
literal|"archive_read_next_header()"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|do_extract
condition|)
name|msg
argument_list|(
literal|"x "
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
operator|!
name|do_extract
condition|)
name|msg
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_extract
condition|)
block|{
name|r
operator|=
name|archive_write_header
argument_list|(
name|ext
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|warn
argument_list|(
literal|"archive_write_header()"
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|copy_data
argument_list|(
name|a
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_finish_entry
argument_list|(
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|fail
argument_list|(
literal|"archive_write_finish_entry()"
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|||
operator|!
name|do_extract
condition|)
name|msg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
name|ar
parameter_list|,
name|struct
name|archive
modifier|*
name|aw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|#
directive|if
name|ARCHIVE_VERSION
operator|>=
literal|3000000
name|int64_t
name|offset
decl_stmt|;
else|#
directive|else
name|off_t
name|offset
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|ar
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|archive_write_data_block
argument_list|(
name|aw
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|warn
argument_list|(
literal|"archive_write_data_block()"
argument_list|,
name|archive_error_string
argument_list|(
name|aw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * These reporting functions use low-level I/O; on some systems, this  * is a significant code reduction.  Of course, on many server and  * desktop operating systems, malloc() and even crt rely on printf(),  * which in turn pulls in most of the rest of stdio, so this is not an  * optimization at all there.  (If you're going to pay 100k or more  * for printf() anyway, you may as well use it!)  */
end_comment

begin_function
specifier|static
name|void
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|errmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|)
block|{
name|errmsg
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|" failed: "
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fail
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|warn
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|m
init|=
literal|"Usage: untar [-tvx] [-f file] [file]\n"
decl_stmt|;
name|errmsg
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

