begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * gzlog.c  * Copyright (C) 2004, 2008, 2012 Mark Adler, all rights reserved  * For conditions of distribution and use, see copyright notice in gzlog.h  * version 2.2, 14 Aug 2012  */
end_comment

begin_comment
comment|/*    gzlog provides a mechanism for frequently appending short strings to a gzip    file that is efficient both in execution time and compression ratio.  The    strategy is to write the short strings in an uncompressed form to the end of    the gzip file, only compressing when the amount of uncompressed data has    reached a given threshold.     gzlog also provides protection against interruptions in the process due to    system crashes.  The status of the operation is recorded in an extra field    in the gzip file, and is only updated once the gzip file is brought to a    valid state.  The last data to be appended or compressed is saved in an    auxiliary file, so that if the operation is interrupted, it can be completed    the next time an append operation is attempted.     gzlog maintains another auxiliary file with the last 32K of data from the    compressed portion, which is preloaded for the compression of the subsequent    data.  This minimizes the impact to the compression ratio of appending.  */
end_comment

begin_comment
comment|/*    Operations Concept:     Files (log name "foo"):    foo.gz -- gzip file with the complete log    foo.add -- last message to append or last data to compress    foo.dict -- dictionary of the last 32K of data for next compression    foo.temp -- temporary dictionary file for compression after this one    foo.lock -- lock file for reading and writing the other files    foo.repairs -- log file for log file recovery operations (not compressed)     gzip file structure:    - fixed-length (no file name) header with extra field (see below)    - compressed data ending initially with empty stored block    - uncompressed data filling out originally empty stored block and      subsequent stored blocks as needed (16K max each)    - gzip trailer    - no junk at end (no other gzip streams)     When appending data, the information in the first three items above plus the    foo.add file are sufficient to recover an interrupted append operation.  The    extra field has the necessary information to restore the start of the last    stored block and determine where to append the data in the foo.add file, as    well as the crc and length of the gzip data before the append operation.     The foo.add file is created before the gzip file is marked for append, and    deleted after the gzip file is marked as complete.  So if the append    operation is interrupted, the data to add will still be there.  If due to    some external force, the foo.add file gets deleted between when the append    operation was interrupted and when recovery is attempted, the gzip file will    still be restored, but without the appended data.     When compressing data, the information in the first two items above plus the    foo.add file are sufficient to recover an interrupted compress operation.    The extra field has the necessary information to find the end of the    compressed data, and contains both the crc and length of just the compressed    data and of the complete set of data including the contents of the foo.add    file.     Again, the foo.add file is maintained during the compress operation in case    of an interruption.  If in the unlikely event the foo.add file with the data    to be compressed is missing due to some external force, a gzip file with    just the previous compressed data will be reconstructed.  In this case, all    of the data that was to be compressed is lost (approximately one megabyte).    This will not occur if all that happened was an interruption of the compress    operation.     The third state that is marked is the replacement of the old dictionary with    the new dictionary after a compress operation.  Once compression is    complete, the gzip file is marked as being in the replace state.  This    completes the gzip file, so an interrupt after being so marked does not    result in recompression.  Then the dictionary file is replaced, and the gzip    file is marked as completed.  This state prevents the possibility of    restarting compression with the wrong dictionary file.     All three operations are wrapped by a lock/unlock procedure.  In order to    gain exclusive access to the log files, first a foo.lock file must be    exclusively created.  When all operations are complete, the lock is    released by deleting the foo.lock file.  If when attempting to create the    lock file, it already exists and the modify time of the lock file is more    than five minutes old (set by the PATIENCE define below), then the old    lock file is considered stale and deleted, and the exclusive creation of    the lock file is retried.  To assure that there are no false assessments    of the staleness of the lock file, the operations periodically touch the    lock file to update the modified date.     Following is the definition of the extra field with all of the information    required to enable the above append and compress operations and their    recovery if interrupted.  Multi-byte values are stored little endian    (consistent with the gzip format).  File pointers are eight bytes long.    The crc's and lengths for the gzip trailer are four bytes long.  (Note that    the length at the end of a gzip file is used for error checking only, and    for large files is actually the length modulo 2^32.)  The stored block    length is two bytes long.  The gzip extra field two-byte identification is    "ap" for append.  It is assumed that writing the extra field to the file is    an "atomic" operation.  That is, either all of the extra field is written    to the file, or none of it is, if the operation is interrupted right at the    point of updating the extra field.  This is a reasonable assumption, since    the extra field is within the first 52 bytes of the file, which is smaller    than any expected block size for a mass storage device (usually 512 bytes or    larger).     Extra field (35 bytes):    - Pointer to first stored block length -- this points to the two-byte length      of the first stored block, which is followed by the two-byte, one's      complement of that length.  The stored block length is preceded by the      three-bit header of the stored block, which is the actual start of the      stored block in the deflate format.  See the bit offset field below.    - Pointer to the last stored block length.  This is the same as above, but      for the last stored block of the uncompressed data in the gzip file.      Initially this is the same as the first stored block length pointer.      When the stored block gets to 16K (see the MAX_STORE define), then a new      stored block as added, at which point the last stored block length pointer      is different from the first stored block length pointer.  When they are      different, the first bit of the last stored block header is eight bits, or      one byte back from the block length.    - Compressed data crc and length.  This is the crc and length of the data      that is in the compressed portion of the deflate stream.  These are used      only in the event that the foo.add file containing the data to compress is      lost after a compress operation is interrupted.    - Total data crc and length.  This is the crc and length of all of the data      stored in the gzip file, compressed and uncompressed.  It is used to      reconstruct the gzip trailer when compressing, as well as when recovering      interrupted operations.    - Final stored block length.  This is used to quickly find where to append,      and allows the restoration of the original final stored block state when      an append operation is interrupted.    - First stored block start as the number of bits back from the final stored      block first length byte.  This value is in the range of 3..10, and is      stored as the low three bits of the final byte of the extra field after      subtracting three (0..7).  This allows the last-block bit of the stored      block header to be updated when a new stored block is added, for the case      when the first stored block and the last stored block are the same.  (When      they are different, the numbers of bits back is known to be eight.)  This      also allows for new compressed data to be appended to the old compressed      data in the compress operation, overwriting the previous first stored      block, or for the compressed data to be terminated and a valid gzip file      reconstructed on the off chance that a compression operation was      interrupted and the data to compress in the foo.add file was deleted.    - The operation in process.  This is the next two bits in the last byte (the      bits under the mask 0x18).  The are interpreted as 0: nothing in process,      1: append in process, 2: compress in process, 3: replace in process.    - The top three bits of the last byte in the extra field are reserved and      are currently set to zero.     Main procedure:    - Exclusively create the foo.lock file using the O_CREAT and O_EXCL modes of      the system open() call.  If the modify time of an existing lock file is      more than PATIENCE seconds old, then the lock file is deleted and the      exclusive create is retried.    - Load the extra field from the foo.gz file, and see if an operation was in      progress but not completed.  If so, apply the recovery procedure below.    - Perform the append procedure with the provided data.    - If the uncompressed data in the foo.gz file is 1MB or more, apply the      compress procedure.    - Delete the foo.lock file.     Append procedure:    - Put what to append in the foo.add file so that the operation can be      restarted if this procedure is interrupted.    - Mark the foo.gz extra field with the append operation in progress.    + Restore the original last-block bit and stored block length of the last      stored block from the information in the extra field, in case a previous      append operation was interrupted.    - Append the provided data to the last stored block, creating new stored      blocks as needed and updating the stored blocks last-block bits and      lengths.    - Update the crc and length with the new data, and write the gzip trailer.    - Write over the extra field (with a single write operation) with the new      pointers, lengths, and crc's, and mark the gzip file as not in process.      Though there is still a foo.add file, it will be ignored since nothing      is in process.  If a foo.add file is leftover from a previously      completed operation, it is truncated when writing new data to it.    - Delete the foo.add file.     Compress and replace procedures:    - Read all of the uncompressed data in the stored blocks in foo.gz and write      it to foo.add.  Also write foo.temp with the last 32K of that data to      provide a dictionary for the next invocation of this procedure.    - Rewrite the extra field marking foo.gz with a compression in process.    * If there is no data provided to compress (due to a missing foo.add file      when recovering), reconstruct and truncate the foo.gz file to contain      only the previous compressed data and proceed to the step after the next      one.  Otherwise ...    - Compress the data with the dictionary in foo.dict, and write to the      foo.gz file starting at the bit immediately following the last previously      compressed block.  If there is no foo.dict, proceed anyway with the      compression at slightly reduced efficiency.  (For the foo.dict file to be      missing requires some external failure beyond simply the interruption of      a compress operation.)  During this process, the foo.lock file is      periodically touched to assure that that file is not considered stale by      another process before we're done.  The deflation is terminated with a      non-last empty static block (10 bits long), that is then located and      written over by a last-bit-set empty stored block.    - Append the crc and length of the data in the gzip file (previously      calculated during the append operations).    - Write over the extra field with the updated stored block offsets, bits      back, crc's, and lengths, and mark foo.gz as in process for a replacement      of the dictionary.    @ Delete the foo.add file.    - Replace foo.dict with foo.temp.    - Write over the extra field, marking foo.gz as complete.     Recovery procedure:    - If not a replace recovery, read in the foo.add file, and provide that data      to the appropriate recovery below.  If there is no foo.add file, provide      a zero data length to the recovery.  In that case, the append recovery      restores the foo.gz to the previous compressed + uncompressed data state.      For the the compress recovery, a missing foo.add file results in foo.gz      being restored to the previous compressed-only data state.    - Append recovery:      - Pick up append at + step above    - Compress recovery:      - Pick up compress at * step above    - Replace recovery:      - Pick up compress at @ step above    - Log the repair with a date stamp in foo.repairs  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* rename, fopen, fprintf, fclose */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strlen, strrchr, strcpy, strncpy, strcmp */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* open */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* lseek, read, write, close, unlink, sleep, */
end_comment

begin_comment
comment|/* ftruncate, fsync */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* time, ctime */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* stat */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* utimes */
end_comment

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* crc32 */
end_comment

begin_include
include|#
directive|include
file|"gzlog.h"
end_include

begin_comment
comment|/* header for external access */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uint
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|ulong
typedef|;
end_typedef

begin_comment
comment|/* Macro for debugging to deterministically force recovery operations */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* longjmp */
end_comment

begin_decl_stmt
name|jmp_buf
name|gzlog_jump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to go back to */
end_comment

begin_decl_stmt
name|int
name|gzlog_bail
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which point to bail at (1..8) */
end_comment

begin_decl_stmt
name|int
name|gzlog_count
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times through to wait */
end_comment

begin_define
define|#
directive|define
name|BAIL
parameter_list|(
name|n
parameter_list|)
value|do { if (n == gzlog_bail&& gzlog_count-- == 0) \                             longjmp(gzlog_jump, gzlog_bail); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BAIL
parameter_list|(
name|n
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* how old the lock file can be in seconds before considering it stale */
end_comment

begin_define
define|#
directive|define
name|PATIENCE
value|300
end_define

begin_comment
comment|/* maximum stored block size in Kbytes -- must be in 1..63 */
end_comment

begin_define
define|#
directive|define
name|MAX_STORE
value|16
end_define

begin_comment
comment|/* number of stored Kbytes to trigger compression (must be>= 32 to allow    dictionary construction, and<= 204 * MAX_STORE, in order for>> 10 to    discard the stored block headers contribution of five bytes each) */
end_comment

begin_define
define|#
directive|define
name|TRIGGER
value|1024
end_define

begin_comment
comment|/* size of a deflate dictionary (this cannot be changed) */
end_comment

begin_define
define|#
directive|define
name|DICT
value|32768U
end_define

begin_comment
comment|/* values for the operation (2 bits) */
end_comment

begin_define
define|#
directive|define
name|NO_OP
value|0
end_define

begin_define
define|#
directive|define
name|APPEND_OP
value|1
end_define

begin_define
define|#
directive|define
name|COMPRESS_OP
value|2
end_define

begin_define
define|#
directive|define
name|REPLACE_OP
value|3
end_define

begin_comment
comment|/* macros to extract little-endian integers from an unsigned byte buffer */
end_comment

begin_define
define|#
directive|define
name|PULL2
parameter_list|(
name|p
parameter_list|)
value|((p)[0]+((uint)((p)[1])<<8))
end_define

begin_define
define|#
directive|define
name|PULL4
parameter_list|(
name|p
parameter_list|)
value|(PULL2(p)+((ulong)PULL2(p+2)<<16))
end_define

begin_define
define|#
directive|define
name|PULL8
parameter_list|(
name|p
parameter_list|)
value|(PULL4(p)+((off_t)PULL4(p+4)<<32))
end_define

begin_comment
comment|/* macros to store integers into a byte buffer in little-endian order */
end_comment

begin_define
define|#
directive|define
name|PUT2
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
value|do {(p)[0]=a;(p)[1]=(a)>>8;} while(0)
end_define

begin_define
define|#
directive|define
name|PUT4
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
value|do {PUT2(p,a);PUT2(p+2,a>>16);} while(0)
end_define

begin_define
define|#
directive|define
name|PUT8
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
value|do {PUT4(p,a);PUT4(p+4,a>>32);} while(0)
end_define

begin_comment
comment|/* internal structure for log information */
end_comment

begin_define
define|#
directive|define
name|LOGID
value|"\106\035\172"
end_define

begin_comment
comment|/* should be three non-zero characters */
end_comment

begin_struct
struct|struct
name|log
block|{
name|char
name|id
index|[
literal|4
index|]
decl_stmt|;
comment|/* contains LOGID to detect inadvertent overwrites */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor for .gz file, opened read/write */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* allocated path, e.g. "/var/log/foo" or "foo" */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end of path, for appending suffices such as ".gz" */
name|off_t
name|first
decl_stmt|;
comment|/* offset of first stored block first length byte */
name|int
name|back
decl_stmt|;
comment|/* location of first block id in bits back from first */
name|uint
name|stored
decl_stmt|;
comment|/* bytes currently in last stored block */
name|off_t
name|last
decl_stmt|;
comment|/* offset of last stored block first length byte */
name|ulong
name|ccrc
decl_stmt|;
comment|/* crc of compressed data */
name|ulong
name|clen
decl_stmt|;
comment|/* length (modulo 2^32) of compressed data */
name|ulong
name|tcrc
decl_stmt|;
comment|/* crc of total data */
name|ulong
name|tlen
decl_stmt|;
comment|/* length (modulo 2^32) of total data */
name|time_t
name|lock
decl_stmt|;
comment|/* last modify time of our lock file */
block|}
struct|;
end_struct

begin_comment
comment|/* gzip header for gzlog */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|char
name|log_gzhead
index|[]
init|=
block|{
literal|0x1f
block|,
literal|0x8b
block|,
comment|/* magic gzip id */
literal|8
block|,
comment|/* compression method is deflate */
literal|4
block|,
comment|/* there is an extra field (no file name) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* no modification time provided */
literal|0
block|,
literal|0xff
block|,
comment|/* no extra flags, no OS specified */
literal|39
block|,
literal|0
block|,
literal|'a'
block|,
literal|'p'
block|,
literal|35
block|,
literal|0
comment|/* extra field with "ap" subfield */
comment|/* 35 is EXTRA, 39 is EXTRA + 4 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEAD
value|sizeof(log_gzhead)
end_define

begin_comment
comment|/* should be 16 */
end_comment

begin_comment
comment|/* initial gzip extra field content (52 == HEAD + EXTRA + 1) */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|char
name|log_gzext
index|[]
init|=
block|{
literal|52
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* offset of first stored block length */
literal|52
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* offset of last stored block length */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* compressed data crc and length */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* total data crc and length */
literal|0
block|,
literal|0
block|,
comment|/* final stored block data length */
literal|5
comment|/* op is NO_OP, last bit 8 bits back */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXTRA
value|sizeof(log_gzext)
end_define

begin_comment
comment|/* should be 35 */
end_comment

begin_comment
comment|/* initial gzip data and trailer */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|char
name|log_gzbody
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* empty stored block (last) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* crc */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* uncompressed length */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BODY
value|sizeof(log_gzbody)
end_define

begin_comment
comment|/* Exclusively create foo.lock in order to negotiate exclusive access to the    foo.* files.  If the modify time of an existing lock file is greater than    PATIENCE seconds in the past, then consider the lock file to have been    abandoned, delete it, and try the exclusive create again.  Save the lock    file modify time for verification of ownership.  Return 0 on success, or -1    on failure, usually due to an access restriction or invalid path.  Note that    if stat() or unlink() fails, it may be due to another process noticing the    abandoned lock file a smidge sooner and deleting it, so those are not    flagged as an error. */
end_comment

begin_function
name|local
name|int
name|log_lock
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".lock"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|stat
argument_list|(
name|log
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|st
operator|.
name|st_mtime
operator|>
name|PATIENCE
condition|)
block|{
name|unlink
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* relinquish the CPU for two seconds while waiting */
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|log
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|log
operator|->
name|lock
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the modify time of the lock file to now, in order to prevent another    task from thinking that the lock is stale.  Save the lock file modify time    for verification of ownership. */
end_comment

begin_function
name|local
name|void
name|log_touch
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".lock"
argument_list|)
expr_stmt|;
name|utimes
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|log
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|log
operator|->
name|lock
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the log file modify time against what is expected.  Return true if    this is not our lock.  If it is our lock, touch it to keep it. */
end_comment

begin_function
name|local
name|int
name|log_check
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|log
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|||
name|st
operator|.
name|st_mtime
operator|!=
name|log
operator|->
name|lock
condition|)
return|return
literal|1
return|;
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unlock a previously acquired lock, but only if it's ours. */
end_comment

begin_function
name|local
name|void
name|log_unlock
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
if|if
condition|(
name|log_check
argument_list|(
name|log
argument_list|)
condition|)
return|return;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".lock"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
name|log
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the gzip header and read in the extra field, filling in the values in    the log structure.  Return op on success or -1 if the gzip header was not as    expected.  op is the current operation in progress last written to the extra    field.  This assumes that the gzip file has already been opened, with the    file descriptor log->fd. */
end_comment

begin_function
name|local
name|int
name|log_head
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|HEAD
operator|+
name|EXTRA
index|]
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|HEAD
operator|+
name|EXTRA
argument_list|)
operator|!=
name|HEAD
operator|+
name|EXTRA
operator|||
name|memcmp
argument_list|(
name|buf
argument_list|,
name|log_gzhead
argument_list|,
name|HEAD
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|log
operator|->
name|first
operator|=
name|PULL8
argument_list|(
name|buf
operator|+
name|HEAD
argument_list|)
expr_stmt|;
name|log
operator|->
name|last
operator|=
name|PULL8
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|8
argument_list|)
expr_stmt|;
name|log
operator|->
name|ccrc
operator|=
name|PULL4
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|16
argument_list|)
expr_stmt|;
name|log
operator|->
name|clen
operator|=
name|PULL4
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|20
argument_list|)
expr_stmt|;
name|log
operator|->
name|tcrc
operator|=
name|PULL4
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|24
argument_list|)
expr_stmt|;
name|log
operator|->
name|tlen
operator|=
name|PULL4
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|28
argument_list|)
expr_stmt|;
name|log
operator|->
name|stored
operator|=
name|PULL2
argument_list|(
name|buf
operator|+
name|HEAD
operator|+
literal|32
argument_list|)
expr_stmt|;
name|log
operator|->
name|back
operator|=
literal|3
operator|+
operator|(
name|buf
index|[
name|HEAD
operator|+
literal|34
index|]
operator|&
literal|7
operator|)
expr_stmt|;
name|op
operator|=
operator|(
name|buf
index|[
name|HEAD
operator|+
literal|34
index|]
operator|>>
literal|3
operator|)
operator|&
literal|3
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Write over the extra field contents, marking the operation as op.  Use fsync    to assure that the device is written to, and in the requested order.  This    operation, and only this operation, is assumed to be atomic in order to    assure that the log is recoverable in the event of an interruption at any    point in the process.  Return -1 if the write to foo.gz failed. */
end_comment

begin_function
name|local
name|int
name|log_mark
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|char
name|ext
index|[
name|EXTRA
index|]
decl_stmt|;
name|PUT8
argument_list|(
name|ext
argument_list|,
name|log
operator|->
name|first
argument_list|)
expr_stmt|;
name|PUT8
argument_list|(
name|ext
operator|+
literal|8
argument_list|,
name|log
operator|->
name|last
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|ext
operator|+
literal|16
argument_list|,
name|log
operator|->
name|ccrc
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|ext
operator|+
literal|20
argument_list|,
name|log
operator|->
name|clen
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|ext
operator|+
literal|24
argument_list|,
name|log
operator|->
name|tcrc
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|ext
operator|+
literal|28
argument_list|,
name|log
operator|->
name|tlen
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|ext
operator|+
literal|32
argument_list|,
name|log
operator|->
name|stored
argument_list|)
expr_stmt|;
name|ext
index|[
literal|34
index|]
operator|=
name|log
operator|->
name|back
operator|-
literal|3
operator|+
operator|(
name|op
operator|<<
literal|3
operator|)
expr_stmt|;
name|fsync
argument_list|(
name|log
operator|->
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|HEAD
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|ext
argument_list|,
name|EXTRA
argument_list|)
operator|!=
name|EXTRA
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|fsync
argument_list|(
name|log
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Rewrite the last block header bits and subsequent zero bits to get to a byte    boundary, setting the last block bit if last is true, and then write the    remainder of the stored block header (length and one's complement).  Leave    the file pointer after the end of the last stored block data.  Return -1 if    there is a read or write failure on the foo.gz file */
end_comment

begin_function
name|local
name|int
name|log_last
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|back
decl_stmt|,
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
comment|/* determine the locations of the bytes and bits to modify */
name|back
operator|=
name|log
operator|->
name|last
operator|==
name|log
operator|->
name|first
condition|?
name|log
operator|->
name|back
else|:
literal|8
expr_stmt|;
name|len
operator|=
name|back
operator|>
literal|8
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* bytes back from log->last */
name|mask
operator|=
literal|0x80
operator|>>
operator|(
operator|(
name|back
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* mask for block last-bit */
comment|/* get the byte to modify (one or two back) into buf[0] -- don't need to        read the byte if the last-bit is eight bits back, since in that case        the entire byte will be modified */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|back
operator|!=
literal|8
operator|&&
operator|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log
operator|->
name|last
operator|-
name|len
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* change the last-bit of the last stored block as requested -- note        that all bits above the last-bit are set to zero, per the type bits        of a stored block being 00 and per the convention that the bits to        bring the stream to a byte boundary are also zeros */
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
operator|-
name|len
index|]
operator|=
operator|(
operator|*
name|buf
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|last
condition|?
name|mask
else|:
literal|0
operator|)
expr_stmt|;
comment|/* write the modified stored block header and lengths, move the file        pointer to after the last stored block data */
name|PUT2
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|log
operator|->
name|stored
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|log
operator|->
name|stored
operator|^
literal|0xffff
argument_list|)
expr_stmt|;
return|return
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log
operator|->
name|last
operator|-
name|len
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
operator|+
literal|2
operator|-
name|len
argument_list|,
name|len
operator|+
literal|4
argument_list|)
operator|!=
name|len
operator|+
literal|4
operator|||
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log
operator|->
name|stored
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Append len bytes from data to the locked and open log file.  len may be zero    if recovering and no .add file was found.  In that case, the previous state    of the foo.gz file is restored.  The data is appended uncompressed in    deflate stored blocks.  Return -1 if there was an error reading or writing    the foo.gz file. */
end_comment

begin_function
name|local
name|int
name|log_append
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint
name|put
decl_stmt|;
name|off_t
name|end
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
comment|/* set the last block last-bit and length, in case recovering an        interrupted append, then position the file pointer to append to the        block */
if|if
condition|(
name|log_last
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* append, adding stored blocks and updating the offset of the last stored        block as needed, and update the total crc and length */
while|while
condition|(
name|len
condition|)
block|{
comment|/* append as much as we can to the last block */
name|put
operator|=
operator|(
name|MAX_STORE
operator|<<
literal|10
operator|)
operator|-
name|log
operator|->
name|stored
expr_stmt|;
if|if
condition|(
name|put
operator|>
name|len
condition|)
name|put
operator|=
operator|(
name|uint
operator|)
name|len
expr_stmt|;
if|if
condition|(
name|put
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|put
argument_list|)
operator|!=
name|put
condition|)
return|return
operator|-
literal|1
return|;
name|BAIL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log
operator|->
name|tcrc
operator|=
name|crc32
argument_list|(
name|log
operator|->
name|tcrc
argument_list|,
name|data
argument_list|,
name|put
argument_list|)
expr_stmt|;
name|log
operator|->
name|tlen
operator|+=
name|put
expr_stmt|;
name|log
operator|->
name|stored
operator|+=
name|put
expr_stmt|;
name|data
operator|+=
name|put
expr_stmt|;
name|len
operator|-=
name|put
expr_stmt|;
block|}
comment|/* if we need to, add a new empty stored block */
if|if
condition|(
name|len
condition|)
block|{
comment|/* mark current block as not last */
if|if
condition|(
name|log_last
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* point to new, empty stored block */
name|log
operator|->
name|last
operator|+=
literal|4
operator|+
name|log
operator|->
name|stored
operator|+
literal|1
expr_stmt|;
name|log
operator|->
name|stored
operator|=
literal|0
expr_stmt|;
block|}
comment|/* mark last block as last, update its length */
if|if
condition|(
name|log_last
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|BAIL
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* write the new crc and length trailer, and truncate just in case (could        be recovering from partial append with a missing foo.add file) */
name|PUT4
argument_list|(
name|buf
argument_list|,
name|log
operator|->
name|tcrc
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|log
operator|->
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
operator|||
operator|(
name|end
operator|=
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|ftruncate
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|end
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write the extra field, marking the log file as done, delete .add file */
if|if
condition|(
name|log_mark
argument_list|(
name|log
argument_list|,
name|NO_OP
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".add"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* ignore error, since may not exist */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Replace the foo.dict file with the foo.temp file.  Also delete the foo.add    file, since the compress operation may have been interrupted before that was    done.  Returns 1 if memory could not be allocated, or -1 if reading or    writing foo.gz fails, or if the rename fails for some reason other than    foo.temp not existing.  foo.temp not existing is a permitted error, since    the replace operation may have been interrupted after the rename is done,    but before foo.gz is marked as complete. */
end_comment

begin_function
name|local
name|int
name|log_replace
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* delete foo.add file */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".add"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* ignore error, since may not exist */
name|BAIL
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* rename foo.name to foo.dict, replacing foo.dict if it exists */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".dict"
argument_list|)
expr_stmt|;
name|dest
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|log
operator|->
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
name|strcpy
argument_list|(
name|dest
argument_list|,
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".temp"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rename
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
name|BAIL
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* mark the foo.gz file as done */
return|return
name|log_mark
argument_list|(
name|log
argument_list|,
name|NO_OP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compress the len bytes at data and append the compressed data to the    foo.gz deflate data immediately after the previous compressed data.  This    overwrites the previous uncompressed data, which was stored in foo.add    and is the data provided in data[0..len-1].  If this operation is    interrupted, it picks up at the start of this routine, with the foo.add    file read in again.  If there is no data to compress (len == 0), then we    simply terminate the foo.gz file after the previously compressed data,    appending a final empty stored block and the gzip trailer.  Return -1 if    reading or writing the log.gz file failed, or -2 if there was a memory    allocation failure. */
end_comment

begin_function
name|local
name|int
name|log_compress
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|uint
name|got
decl_stmt|,
name|max
decl_stmt|;
name|ssize_t
name|dict
decl_stmt|;
name|off_t
name|end
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DICT
index|]
decl_stmt|;
comment|/* compress and append compressed data */
if|if
condition|(
name|len
condition|)
block|{
comment|/* set up for deflate, allocating memory */
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|deflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
literal|15
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|2
return|;
comment|/* read in dictionary (last 32K of data that was compressed) */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".dict"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|dict
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|DICT
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|<
literal|0
condition|)
block|{
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dict
condition|)
name|deflateSetDictionary
argument_list|(
operator|&
name|strm
argument_list|,
name|buf
argument_list|,
operator|(
name|uint
operator|)
name|dict
argument_list|)
expr_stmt|;
block|}
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* prime deflate with last bits of previous block, position write            pointer to write those bits and overwrite what follows */
if|if
condition|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log
operator|->
name|first
operator|-
operator|(
name|log
operator|->
name|back
operator|>
literal|8
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|deflatePrime
argument_list|(
operator|&
name|strm
argument_list|,
operator|(
literal|8
operator|-
name|log
operator|->
name|back
operator|)
operator|&
literal|7
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
comment|/* compress, finishing with a partial non-last empty static block */
name|strm
operator|.
name|next_in
operator|=
name|data
expr_stmt|;
name|max
operator|=
operator|(
operator|(
operator|(
name|uint
operator|)
literal|0
operator|-
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* in case int smaller than size_t */
do|do
block|{
name|strm
operator|.
name|avail_in
operator|=
name|len
operator|>
name|max
condition|?
name|max
else|:
operator|(
name|uint
operator|)
name|len
expr_stmt|;
name|len
operator|-=
name|strm
operator|.
name|avail_in
expr_stmt|;
do|do
block|{
name|strm
operator|.
name|avail_out
operator|=
name|DICT
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|deflate
argument_list|(
operator|&
name|strm
argument_list|,
name|len
condition|?
name|Z_NO_FLUSH
else|:
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
name|got
operator|=
name|DICT
operator|-
name|strm
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|got
operator|&&
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|got
argument_list|)
operator|!=
name|got
condition|)
block|{
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|len
condition|)
do|;
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|BAIL
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* find start of empty static block -- scanning backwards the first one            bit is the second bit of the block, if the last byte is zero, then            we know the byte before that has a one in the top bit, since an            empty static block is ten bits long */
if|if
condition|(
operator|(
name|log
operator|->
name|first
operator|=
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|log
operator|->
name|first
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
condition|)
block|{
name|log
operator|->
name|back
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|buf
operator|&
operator|(
operator|(
name|uint
operator|)
literal|1
operator|<<
operator|(
literal|8
operator|-
name|log
operator|->
name|back
operator|++
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* guaranteed to terminate, since *buf != 0 */
block|}
else|else
name|log
operator|->
name|back
operator|=
literal|10
expr_stmt|;
comment|/* update compressed crc and length */
name|log
operator|->
name|ccrc
operator|=
name|log
operator|->
name|tcrc
expr_stmt|;
name|log
operator|->
name|clen
operator|=
name|log
operator|->
name|tlen
expr_stmt|;
block|}
else|else
block|{
comment|/* no data to compress -- fix up existing gzip stream */
name|log
operator|->
name|tcrc
operator|=
name|log
operator|->
name|ccrc
expr_stmt|;
name|log
operator|->
name|tlen
operator|=
name|log
operator|->
name|clen
expr_stmt|;
block|}
comment|/* complete and truncate gzip stream */
name|log
operator|->
name|last
operator|=
name|log
operator|->
name|first
expr_stmt|;
name|log
operator|->
name|stored
operator|=
literal|0
expr_stmt|;
name|PUT4
argument_list|(
name|buf
argument_list|,
name|log
operator|->
name|tcrc
argument_list|)
expr_stmt|;
name|PUT4
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|log
operator|->
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_last
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
operator|||
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
operator|||
operator|(
name|end
operator|=
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|ftruncate
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|end
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|BAIL
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* mark as being in the replace operation */
if|if
condition|(
name|log_mark
argument_list|(
name|log
argument_list|,
name|REPLACE_OP
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* execute the replace operation and mark the file as done */
return|return
name|log_replace
argument_list|(
name|log
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* log a repair record to the .repairs file */
end_comment

begin_function
name|local
name|void
name|log_log
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|int
name|op
parameter_list|,
name|char
modifier|*
name|record
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|FILE
modifier|*
name|rec
decl_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".repairs"
argument_list|)
expr_stmt|;
name|rec
operator|=
name|fopen
argument_list|(
name|log
operator|->
name|path
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|rec
argument_list|,
literal|"%.24s %s recovery: %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|,
name|op
operator|==
name|APPEND_OP
condition|?
literal|"append"
else|:
operator|(
name|op
operator|==
name|COMPRESS_OP
condition|?
literal|"compress"
else|:
literal|"replace"
operator|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Recover the interrupted operation op.  First read foo.add for recovering an    append or compress operation.  Return -1 if there was an error reading or    writing foo.gz or reading an existing foo.add, or -2 if there was a memory    allocation failure. */
end_comment

begin_function
name|local
name|int
name|log_recover
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* log recovery */
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
comment|/* load foo.add file if expected and present */
if|if
condition|(
name|op
operator|==
name|APPEND_OP
operator|||
name|op
operator|==
name|COMPRESS_OP
condition|)
block|{
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".add"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|log
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_size
condition|)
block|{
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|len
operator|!=
name|st
operator|.
name|st_size
operator|||
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|"allocation failure"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|".add file read failure"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
operator|(
name|size_t
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
operator|!=
name|len
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|".add file read failure"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|"loaded .add file"
argument_list|)
expr_stmt|;
block|}
else|else
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
literal|"missing .add file!"
argument_list|)
expr_stmt|;
block|}
comment|/* recover the interrupted operation */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|APPEND_OP
case|:
name|ret
operator|=
name|log_append
argument_list|(
name|log
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_OP
case|:
name|ret
operator|=
name|log_compress
argument_list|(
name|log
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLACE_OP
case|:
name|ret
operator|=
name|log_replace
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
comment|/* log status */
name|log_log
argument_list|(
name|log
argument_list|,
name|op
argument_list|,
name|ret
condition|?
literal|"failure"
else|:
literal|"complete"
argument_list|)
expr_stmt|;
comment|/* clean up */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Close the foo.gz file (if open) and release the lock. */
end_comment

begin_function
name|local
name|void
name|log_close
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
if|if
condition|(
name|log
operator|->
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|log
operator|->
name|fd
argument_list|)
expr_stmt|;
name|log
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|log_unlock
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open foo.gz, verify the header, and load the extra field contents, after    first creating the foo.lock file to gain exclusive access to the foo.*    files.  If foo.gz does not exist or is empty, then write the initial header,    extra, and body content of an empty foo.gz log file.  If there is an error    creating the lock file due to access restrictions, or an error reading or    writing the foo.gz file, or if the foo.gz file is not a proper log file for    this object (e.g. not a gzip file or does not contain the expected extra    field), then return true.  If there is an error, the lock is released.    Otherwise, the lock is left in place. */
end_comment

begin_function
name|local
name|int
name|log_open
parameter_list|(
name|struct
name|log
modifier|*
name|log
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
comment|/* release open file resource if left over -- can occur if lock lost        between gzlog_open() and gzlog_write() */
if|if
condition|(
name|log
operator|->
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|log
operator|->
name|fd
argument_list|)
expr_stmt|;
name|log
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* negotiate exclusive access */
if|if
condition|(
name|log_lock
argument_list|(
name|log
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* open the log file, foo.gz */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".gz"
argument_list|)
expr_stmt|;
name|log
operator|->
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|log_close
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* if new, initialize foo.gz with an empty log, delete old dictionary */
if|if
condition|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log_gzhead
argument_list|,
name|HEAD
argument_list|)
operator|!=
name|HEAD
operator|||
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log_gzext
argument_list|,
name|EXTRA
argument_list|)
operator|!=
name|EXTRA
operator|||
name|write
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log_gzbody
argument_list|,
name|BODY
argument_list|)
operator|!=
name|BODY
condition|)
block|{
name|log_close
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".dict"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* verify log file and load extra field information */
if|if
condition|(
operator|(
name|op
operator|=
name|log_head
argument_list|(
name|log
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_close
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check for interrupted process and if so, recover */
if|if
condition|(
name|op
operator|!=
name|NO_OP
operator|&&
name|log_recover
argument_list|(
name|log
argument_list|,
name|op
argument_list|)
condition|)
block|{
name|log_close
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* touch the lock file to prevent another process from grabbing it */
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See gzlog.h for the description of the external methods below */
end_comment

begin_function
name|gzlog
modifier|*
name|gzlog_open
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|struct
name|log
modifier|*
name|log
decl_stmt|;
comment|/* check arguments */
if|if
condition|(
name|path
operator|==
name|NULL
operator|||
operator|*
name|path
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* allocate and initialize log structure */
name|log
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|log
operator|->
name|id
argument_list|,
name|LOGID
argument_list|)
expr_stmt|;
name|log
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* save path and end of path for name construction */
name|n
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|log
operator|->
name|path
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|9
argument_list|)
expr_stmt|;
comment|/* allow for ".repairs" */
if|if
condition|(
name|log
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|log
operator|->
name|end
operator|=
name|log
operator|->
name|path
operator|+
name|n
expr_stmt|;
comment|/* gain exclusive access and verify log file -- may perform a        recovery operation if needed */
if|if
condition|(
name|log_open
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* return pointer to log structure */
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* gzlog_compress() return values:     0: all good    -1: file i/o error (usually access issue)    -2: memory allocation failure    -3: invalid log pointer argument */
end_comment

begin_function
name|int
name|gzlog_compress
parameter_list|(
name|gzlog
modifier|*
name|logd
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
name|uint
name|block
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|,
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|log
modifier|*
name|log
init|=
name|logd
decl_stmt|;
comment|/* check arguments */
if|if
condition|(
name|log
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|log
operator|->
name|id
argument_list|,
name|LOGID
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
comment|/* see if we lost the lock -- if so get it again and reload the extra        field information (it probably changed), recover last operation if        necessary */
if|if
condition|(
name|log_check
argument_list|(
name|log
argument_list|)
operator|&&
name|log_open
argument_list|(
name|log
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* create space for uncompressed data */
name|len
operator|=
operator|(
call|(
name|size_t
call|)
argument_list|(
name|log
operator|->
name|last
operator|-
name|log
operator|->
name|first
argument_list|)
operator|&
operator|~
operator|(
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
name|log
operator|->
name|stored
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
comment|/* do statement here is just a cheap trick for error handling */
do|do
block|{
comment|/* read in the uncompressed data */
if|if
condition|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|log
operator|->
name|first
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
operator|!=
literal|5
condition|)
break|break;
name|block
operator|=
name|PULL2
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|+
name|block
operator|>
name|len
operator|||
name|read
argument_list|(
name|log
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|next
argument_list|,
name|block
argument_list|)
operator|!=
name|block
condition|)
break|break;
name|next
operator|+=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|log
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
name|log
operator|->
name|last
operator|+
literal|4
operator|+
name|log
operator|->
name|stored
condition|)
break|break;
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* write the uncompressed data to the .add file */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".add"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
break|break;
name|ret
operator|=
operator|(
name|size_t
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
operator|!=
name|len
expr_stmt|;
if|if
condition|(
name|ret
operator||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
break|break;
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* write the dictionary for the next compress to the .temp file */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".temp"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
break|break;
name|next
operator|=
name|DICT
operator|>
name|len
condition|?
name|len
else|:
name|DICT
expr_stmt|;
name|ret
operator|=
operator|(
name|size_t
operator|)
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|len
operator|-
name|next
argument_list|,
name|next
argument_list|)
operator|!=
name|next
expr_stmt|;
if|if
condition|(
name|ret
operator||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
break|break;
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* roll back to compressed data, mark the compress in progress */
name|log
operator|->
name|last
operator|=
name|log
operator|->
name|first
expr_stmt|;
name|log
operator|->
name|stored
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|log_mark
argument_list|(
name|log
argument_list|,
name|COMPRESS_OP
argument_list|)
condition|)
break|break;
name|BAIL
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* compress and append the data (clears mark) */
name|ret
operator|=
name|log_compress
argument_list|(
name|log
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* broke out of do above on i/o error */
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* gzlog_write() return values:     0: all good    -1: file i/o error (usually access issue)    -2: memory allocation failure    -3: invalid log pointer argument */
end_comment

begin_function
name|int
name|gzlog_write
parameter_list|(
name|gzlog
modifier|*
name|logd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|log
modifier|*
name|log
init|=
name|logd
decl_stmt|;
comment|/* check arguments */
if|if
condition|(
name|log
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|log
operator|->
name|id
argument_list|,
name|LOGID
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* see if we lost the lock -- if so get it again and reload the extra        field information (it probably changed), recover last operation if        necessary */
if|if
condition|(
name|log_check
argument_list|(
name|log
argument_list|)
operator|&&
name|log_open
argument_list|(
name|log
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* create and write .add file */
name|strcpy
argument_list|(
name|log
operator|->
name|end
argument_list|,
literal|".add"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|log
operator|->
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
operator|(
name|size_t
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
operator|!=
name|len
expr_stmt|;
if|if
condition|(
name|ret
operator||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|log_touch
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* mark log file with append in progress */
if|if
condition|(
name|log_mark
argument_list|(
name|log
argument_list|,
name|APPEND_OP
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|BAIL
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* append data (clears mark) */
if|if
condition|(
name|log_append
argument_list|(
name|log
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check to see if it's time to compress -- if not, then done */
if|if
condition|(
operator|(
operator|(
name|log
operator|->
name|last
operator|-
name|log
operator|->
name|first
operator|)
operator|>>
literal|10
operator|)
operator|+
operator|(
name|log
operator|->
name|stored
operator|>>
literal|10
operator|)
operator|<
name|TRIGGER
condition|)
return|return
literal|0
return|;
comment|/* time to compress */
return|return
name|gzlog_compress
argument_list|(
name|log
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* gzlog_close() return values:     0: ok    -3: invalid log pointer argument */
end_comment

begin_function
name|int
name|gzlog_close
parameter_list|(
name|gzlog
modifier|*
name|logd
parameter_list|)
block|{
name|struct
name|log
modifier|*
name|log
init|=
name|logd
decl_stmt|;
comment|/* check arguments */
if|if
condition|(
name|log
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|log
operator|->
name|id
argument_list|,
name|LOGID
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
comment|/* close the log file and release the lock */
name|log_close
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* free structure and return */
if|if
condition|(
name|log
operator|->
name|path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|log
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|log
operator|->
name|id
argument_list|,
literal|"bad"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

