begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* enough.c -- determine the maximum size of inflate's Huffman code tables over  * all possible valid and complete Huffman codes, subject to a length limit.  * Copyright (C) 2007, 2008, 2012 Mark Adler  * Version 1.4  18 August 2012  Mark Adler  */
end_comment

begin_comment
comment|/* Version history:    1.0   3 Jan 2007  First version (derived from codecount.c version 1.4)    1.1   4 Jan 2007  Use faster incremental table usage computation                      Prune examine() search on previously visited states    1.2   5 Jan 2007  Comments clean up                      As inflate does, decrease root for short codes                      Refuse cases where inflate would increase root    1.3  17 Feb 2008  Add argument for initial root table size                      Fix bug for initial root table size == max - 1                      Use a macro to compute the history index    1.4  18 Aug 2012  Avoid shifts more than bits in type (caused endless loop!)                      Clean up comparisons of different types                      Clean up code indentation  */
end_comment

begin_comment
comment|/*    Examine all possible Huffman codes for a given number of symbols and a    maximum code length in bits to determine the maximum table size for zilb's    inflate.  Only complete Huffman codes are counted.     Two codes are considered distinct if the vectors of the number of codes per    length are not identical.  So permutations of the symbol assignments result    in the same code for the counting, as do permutations of the assignments of    the bit values to the codes (i.e. only canonical codes are counted).     We build a code from shorter to longer lengths, determining how many symbols    are coded at each length.  At each step, we have how many symbols remain to    be coded, what the last code length used was, and how many bit patterns of    that length remain unused. Then we add one to the code length and double the    number of unused patterns to graduate to the next code length.  We then    assign all portions of the remaining symbols to that code length that    preserve the properties of a correct and eventually complete code.  Those    properties are: we cannot use more bit patterns than are available; and when    all the symbols are used, there are exactly zero possible bit patterns    remaining.     The inflate Huffman decoding algorithm uses two-level lookup tables for    speed.  There is a single first-level table to decode codes up to root bits    in length (root == 9 in the current inflate implementation).  The table    has 1<< root entries and is indexed by the next root bits of input.  Codes    shorter than root bits have replicated table entries, so that the correct    entry is pointed to regardless of the bits that follow the short code.  If    the code is longer than root bits, then the table entry points to a second-    level table.  The size of that table is determined by the longest code with    that root-bit prefix.  If that longest code has length len, then the table    has size 1<< (len - root), to index the remaining bits in that set of    codes.  Each subsequent root-bit prefix then has its own sub-table.  The    total number of table entries required by the code is calculated    incrementally as the number of codes at each bit length is populated.  When    all of the codes are shorter than root bits, then root is reduced to the    longest code length, resulting in a single, smaller, one-level table.     The inflate algorithm also provides for small values of root (relative to    the log2 of the number of symbols), where the shortest code has more bits    than root.  In that case, root is increased to the length of the shortest    code.  This program, by design, does not handle that case, so it is verified    that the number of symbols is less than 2^(root + 1).     In order to speed up the examination (by about ten orders of magnitude for    the default arguments), the intermediate states in the build-up of a code    are remembered and previously visited branches are pruned.  The memory    required for this will increase rapidly with the total number of symbols and    the maximum code length in bits.  However this is a very small price to pay    for the vast speedup.     First, all of the possible Huffman codes are counted, and reachable    intermediate states are noted by a non-zero count in a saved-results array.    Second, the intermediate states that lead to (root + 1) bit or longer codes    are used to look at all sub-codes from those junctures for their inflate    memory usage.  (The amount of memory used is not affected by the number of    codes of root bits or less in length.)  Third, the visited states in the    construction of those sub-codes and the associated calculation of the table    size is recalled in order to avoid recalculating from the same juncture.    Beginning the code examination at (root + 1) bit codes, which is enabled by    identifying the reachable nodes, accounts for about six of the orders of    magnitude of improvement for the default arguments.  About another four    orders of magnitude come from not revisiting previous states.  Out of    approximately 2x10^16 possible Huffman codes, only about 2x10^6 sub-codes    need to be examined to cover all of the possible table memory usage cases    for the default arguments of 286 symbols limited to 15-bit codes.     Note that an unsigned long long type is used for counting.  It is quite easy    to exceed the capacity of an eight-byte integer with a large number of    symbols and a large maximum code length, so multiple-precision arithmetic    would need to replace the unsigned long long arithmetic in that case.  This    program will abort if an overflow occurs.  The big_t type identifies where    the counting takes place.     An unsigned long long type is also used for calculating the number of    possible codes remaining at the maximum length.  This limits the maximum    code length to the number of bits in a long long minus the number of bits    needed to represent the symbols in a flat code.  The code_t type identifies    where the bit pattern counting takes place.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* special data types */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|big_t
typedef|;
end_typedef

begin_comment
comment|/* type for code counting */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|code_t
typedef|;
end_typedef

begin_comment
comment|/* type for bit pattern counting */
end_comment

begin_struct
struct|struct
name|tab
block|{
comment|/* type for been here check */
name|size_t
name|len
decl_stmt|;
comment|/* length of bit vector in char's */
name|char
modifier|*
name|vec
decl_stmt|;
comment|/* allocated bit vector */
block|}
struct|;
end_struct

begin_comment
comment|/* The array for saving results, num[], is indexed with this triplet:        syms: number of symbols remaining to code       left: number of available bit patterns at length len       len: number of bits in the codes currently being assigned     Those indices are constrained thusly when saving results:        syms: 3..totsym (totsym == total symbols to code)       left: 2..syms - 1, but only the evens (so syms == 8 -> 2, 4, 6)       len: 1..max - 1 (max == maximum code length in bits)     syms == 2 is not saved since that immediately leads to a single code.  left    must be even, since it represents the number of available bit patterns at    the current length, which is double the number at the previous length.    left ends at syms-1 since left == syms immediately results in a single code.    (left> sym is not allowed since that would result in an incomplete code.)    len is less than max, since the code completes immediately when len == max.     The offset into the array is calculated for the three indices with the    first one (syms) being outermost, and the last one (len) being innermost.    We build the array with length max-1 lists for the len index, with syms-3    of those for each symbol.  There are totsym-2 of those, with each one    varying in length as a function of sym.  See the calculation of index in    count() for the index, and the calculation of size in main() for the size    of the array.     For the deflate example of 286 symbols limited to 15-bit codes, the array    has 284,284 entries, taking up 2.17 MB for an 8-byte big_t.  More than    half of the space allocated for saved results is actually used -- not all    possible triplets are reached in the generation of valid Huffman codes.  */
end_comment

begin_comment
comment|/* The array for tracking visited states, done[], is itself indexed identically    to the num[] array as described above for the (syms, left, len) triplet.    Each element in the array is further indexed by the (mem, rem) doublet,    where mem is the amount of inflate table space used so far, and rem is the    remaining unused entries in the current inflate sub-table.  Each indexed    element is simply one bit indicating whether the state has been visited or    not.  Since the ranges for mem and rem are not known a priori, each bit    vector is of a variable size, and grows as needed to accommodate the visited    states.  mem and rem are used to calculate a single index in a triangular    array.  Since the range of mem is expected in the default case to be about    ten times larger than the range of rem, the array is skewed to reduce the    memory usage, with eight times the range for mem than for rem.  See the    calculations for offset and bit in beenhere() for the details.     For the deflate example of 286 symbols limited to 15-bit codes, the bit    vectors grow to total approximately 21 MB, in addition to the 4.3 MB done[]    array itself.  */
end_comment

begin_comment
comment|/* Globals to avoid propagating constants or constant pointers recursively */
end_comment

begin_decl_stmt
name|local
name|int
name|max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum allowed bit length for the codes */
end_comment

begin_decl_stmt
name|local
name|int
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of base code table in bits */
end_comment

begin_decl_stmt
name|local
name|int
name|large
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* largest code table so far */
end_comment

begin_decl_stmt
name|local
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of elements in num and done */
end_comment

begin_decl_stmt
name|local
name|int
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols assigned to each bit length */
end_comment

begin_decl_stmt
name|local
name|big_t
modifier|*
name|num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved results array for code counting */
end_comment

begin_decl_stmt
name|local
name|struct
name|tab
modifier|*
name|done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* states already evaluated array */
end_comment

begin_comment
comment|/* Index function for num[] and done[] */
end_comment

begin_define
define|#
directive|define
name|INDEX
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|,
name|k
parameter_list|)
value|(((size_t)((i-1)>>1)*((i-2)>>1)+(j>>1)-1)*(max-1)+k-1)
end_define

begin_comment
comment|/* Free allocated space.  Uses globals code, num, and done. */
end_comment

begin_function
name|local
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|done
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|done
index|[
name|n
index|]
operator|.
name|len
condition|)
name|free
argument_list|(
name|done
index|[
name|n
index|]
operator|.
name|vec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|done
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of possible Huffman codes using bit patterns of lengths    len through max inclusive, coding syms symbols, with left bit patterns of    length len unused -- return -1 if there is an overflow in the counting.    Keep a record of previous results in num to prevent repeating the same    calculation.  Uses the globals max and num. */
end_comment

begin_function
name|local
name|big_t
name|count
parameter_list|(
name|int
name|syms
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|left
parameter_list|)
block|{
name|big_t
name|sum
decl_stmt|;
comment|/* number of possible codes from this juncture */
name|big_t
name|got
decl_stmt|;
comment|/* value returned from count() */
name|int
name|least
decl_stmt|;
comment|/* least number of syms to use at this juncture */
name|int
name|most
decl_stmt|;
comment|/* most number of syms to use at this juncture */
name|int
name|use
decl_stmt|;
comment|/* number of bit patterns to use in next call */
name|size_t
name|index
decl_stmt|;
comment|/* index of this case in *num */
comment|/* see if only one possible code */
if|if
condition|(
name|syms
operator|==
name|left
condition|)
return|return
literal|1
return|;
comment|/* note and verify the expected state */
name|assert
argument_list|(
name|syms
operator|>
name|left
operator|&&
name|left
operator|>
literal|0
operator|&&
name|len
operator|<
name|max
argument_list|)
expr_stmt|;
comment|/* see if we've done this one already */
name|index
operator|=
name|INDEX
argument_list|(
name|syms
argument_list|,
name|left
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|got
operator|=
name|num
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|got
condition|)
return|return
name|got
return|;
comment|/* we have -- return the saved result */
comment|/* we need to use at least this many bit patterns so that the code won't be        incomplete at the next length (more bit patterns than symbols) */
name|least
operator|=
operator|(
name|left
operator|<<
literal|1
operator|)
operator|-
name|syms
expr_stmt|;
if|if
condition|(
name|least
operator|<
literal|0
condition|)
name|least
operator|=
literal|0
expr_stmt|;
comment|/* we can use at most this many bit patterns, lest there not be enough        available for the remaining symbols at the maximum length (if there were        no limit to the code length, this would become: most = left - 1) */
name|most
operator|=
operator|(
operator|(
operator|(
name|code_t
operator|)
name|left
operator|<<
operator|(
name|max
operator|-
name|len
operator|)
operator|)
operator|-
name|syms
operator|)
operator|/
operator|(
operator|(
operator|(
name|code_t
operator|)
literal|1
operator|<<
operator|(
name|max
operator|-
name|len
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* count all possible codes from this juncture and add them up */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|use
operator|=
name|least
init|;
name|use
operator|<=
name|most
condition|;
name|use
operator|++
control|)
block|{
name|got
operator|=
name|count
argument_list|(
name|syms
operator|-
name|use
argument_list|,
name|len
operator|+
literal|1
argument_list|,
operator|(
name|left
operator|-
name|use
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|got
expr_stmt|;
if|if
condition|(
name|got
operator|==
operator|(
name|big_t
operator|)
literal|0
operator|-
literal|1
operator|||
name|sum
operator|<
name|got
condition|)
comment|/* overflow */
return|return
operator|(
name|big_t
operator|)
literal|0
operator|-
literal|1
return|;
block|}
comment|/* verify that all recursive calls are productive */
name|assert
argument_list|(
name|sum
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* save the result and return it */
name|num
index|[
name|index
index|]
operator|=
name|sum
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* Return true if we've been here before, set to true if not.  Set a bit in a    bit vector to indicate visiting this state.  Each (syms,len,left) state    has a variable size bit vector indexed by (mem,rem).  The bit vector is    lengthened if needed to allow setting the (mem,rem) bit. */
end_comment

begin_function
name|local
name|int
name|beenhere
parameter_list|(
name|int
name|syms
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|mem
parameter_list|,
name|int
name|rem
parameter_list|)
block|{
name|size_t
name|index
decl_stmt|;
comment|/* index for this state's bit vector */
name|size_t
name|offset
decl_stmt|;
comment|/* offset in this state's bit vector */
name|int
name|bit
decl_stmt|;
comment|/* mask for this state's bit */
name|size_t
name|length
decl_stmt|;
comment|/* length of the bit vector in bytes */
name|char
modifier|*
name|vector
decl_stmt|;
comment|/* new or enlarged bit vector */
comment|/* point to vector for (syms,left,len), bit in vector for (mem,rem) */
name|index
operator|=
name|INDEX
argument_list|(
name|syms
argument_list|,
name|left
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mem
operator|-=
literal|1
operator|<<
name|root
expr_stmt|;
name|offset
operator|=
operator|(
name|mem
operator|>>
literal|3
operator|)
operator|+
name|rem
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|offset
operator|*
operator|(
name|offset
operator|+
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|+
name|rem
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|mem
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* see if we've been here */
name|length
operator|=
name|done
index|[
name|index
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|length
operator|&&
operator|(
name|done
index|[
name|index
index|]
operator|.
name|vec
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* done this! */
comment|/* we haven't been here before -- set the bit to show we have now */
comment|/* see if we need to lengthen the vector in order to set the bit */
if|if
condition|(
name|length
operator|<=
name|offset
condition|)
block|{
comment|/* if we have one already, enlarge it, zero out the appended space */
if|if
condition|(
name|length
condition|)
block|{
do|do
block|{
name|length
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|<=
name|offset
condition|)
do|;
name|vector
operator|=
name|realloc
argument_list|(
name|done
index|[
name|index
index|]
operator|.
name|vec
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|vector
operator|+
name|done
index|[
name|index
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|done
index|[
name|index
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* otherwise we need to make a new vector and zero it out */
else|else
block|{
name|length
operator|=
literal|1
operator|<<
operator|(
name|len
operator|-
name|root
operator|)
expr_stmt|;
while|while
condition|(
name|length
operator|<=
name|offset
condition|)
name|length
operator|<<=
literal|1
expr_stmt|;
name|vector
operator|=
name|calloc
argument_list|(
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* in either case, bail if we can't get the memory */
if|if
condition|(
name|vector
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"abort: unable to allocate enough memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* install the new vector */
name|done
index|[
name|index
index|]
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|done
index|[
name|index
index|]
operator|.
name|vec
operator|=
name|vector
expr_stmt|;
block|}
comment|/* set the bit */
name|done
index|[
name|index
index|]
operator|.
name|vec
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine all possible codes from the given node (syms, len, left).  Compute    the amount of memory required to build inflate's decoding tables, where the    number of code structures used so far is mem, and the number remaining in    the current sub-table is rem.  Uses the globals max, code, root, large, and    done. */
end_comment

begin_function
name|local
name|void
name|examine
parameter_list|(
name|int
name|syms
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|mem
parameter_list|,
name|int
name|rem
parameter_list|)
block|{
name|int
name|least
decl_stmt|;
comment|/* least number of syms to use at this juncture */
name|int
name|most
decl_stmt|;
comment|/* most number of syms to use at this juncture */
name|int
name|use
decl_stmt|;
comment|/* number of bit patterns to use in next call */
comment|/* see if we have a complete code */
if|if
condition|(
name|syms
operator|==
name|left
condition|)
block|{
comment|/* set the last code entry */
name|code
index|[
name|len
index|]
operator|=
name|left
expr_stmt|;
comment|/* complete computation of memory used by this code */
while|while
condition|(
name|rem
operator|<
name|left
condition|)
block|{
name|left
operator|-=
name|rem
expr_stmt|;
name|rem
operator|=
literal|1
operator|<<
operator|(
name|len
operator|-
name|root
operator|)
expr_stmt|;
name|mem
operator|+=
name|rem
expr_stmt|;
block|}
name|assert
argument_list|(
name|rem
operator|==
name|left
argument_list|)
expr_stmt|;
comment|/* if this is a new maximum, show the entries used and the sub-code */
if|if
condition|(
name|mem
operator|>
name|large
condition|)
block|{
name|large
operator|=
name|mem
expr_stmt|;
name|printf
argument_list|(
literal|"max %d: "
argument_list|,
name|mem
argument_list|)
expr_stmt|;
for|for
control|(
name|use
operator|=
name|root
operator|+
literal|1
init|;
name|use
operator|<=
name|max
condition|;
name|use
operator|++
control|)
if|if
condition|(
name|code
index|[
name|use
index|]
condition|)
name|printf
argument_list|(
literal|"%d[%d] "
argument_list|,
name|code
index|[
name|use
index|]
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* remove entries as we drop back down in the recursion */
name|code
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* prune the tree if we can */
if|if
condition|(
name|beenhere
argument_list|(
name|syms
argument_list|,
name|len
argument_list|,
name|left
argument_list|,
name|mem
argument_list|,
name|rem
argument_list|)
condition|)
return|return;
comment|/* we need to use at least this many bit patterns so that the code won't be        incomplete at the next length (more bit patterns than symbols) */
name|least
operator|=
operator|(
name|left
operator|<<
literal|1
operator|)
operator|-
name|syms
expr_stmt|;
if|if
condition|(
name|least
operator|<
literal|0
condition|)
name|least
operator|=
literal|0
expr_stmt|;
comment|/* we can use at most this many bit patterns, lest there not be enough        available for the remaining symbols at the maximum length (if there were        no limit to the code length, this would become: most = left - 1) */
name|most
operator|=
operator|(
operator|(
operator|(
name|code_t
operator|)
name|left
operator|<<
operator|(
name|max
operator|-
name|len
operator|)
operator|)
operator|-
name|syms
operator|)
operator|/
operator|(
operator|(
operator|(
name|code_t
operator|)
literal|1
operator|<<
operator|(
name|max
operator|-
name|len
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* occupy least table spaces, creating new sub-tables as needed */
name|use
operator|=
name|least
expr_stmt|;
while|while
condition|(
name|rem
operator|<
name|use
condition|)
block|{
name|use
operator|-=
name|rem
expr_stmt|;
name|rem
operator|=
literal|1
operator|<<
operator|(
name|len
operator|-
name|root
operator|)
expr_stmt|;
name|mem
operator|+=
name|rem
expr_stmt|;
block|}
name|rem
operator|-=
name|use
expr_stmt|;
comment|/* examine codes from here, updating table space as we go */
for|for
control|(
name|use
operator|=
name|least
init|;
name|use
operator|<=
name|most
condition|;
name|use
operator|++
control|)
block|{
name|code
index|[
name|len
index|]
operator|=
name|use
expr_stmt|;
name|examine
argument_list|(
name|syms
operator|-
name|use
argument_list|,
name|len
operator|+
literal|1
argument_list|,
operator|(
name|left
operator|-
name|use
operator|)
operator|<<
literal|1
argument_list|,
name|mem
operator|+
operator|(
name|rem
condition|?
literal|1
operator|<<
operator|(
name|len
operator|-
name|root
operator|)
else|:
literal|0
operator|)
argument_list|,
name|rem
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|==
literal|0
condition|)
block|{
name|rem
operator|=
literal|1
operator|<<
operator|(
name|len
operator|-
name|root
operator|)
expr_stmt|;
name|mem
operator|+=
name|rem
expr_stmt|;
block|}
name|rem
operator|--
expr_stmt|;
block|}
comment|/* remove entries as we drop back down in the recursion */
name|code
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at all sub-codes starting with root + 1 bits.  Look at only the valid    intermediate code states (syms, left, len).  For each completed code,    calculate the amount of memory required by inflate to build the decoding    tables. Find the maximum amount of memory required and show the code that    requires that maximum.  Uses the globals max, root, and num. */
end_comment

begin_function
name|local
name|void
name|enough
parameter_list|(
name|int
name|syms
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of remaing symbols for this node */
name|int
name|left
decl_stmt|;
comment|/* number of unused bit patterns at this length */
name|size_t
name|index
decl_stmt|;
comment|/* index of this case in *num */
comment|/* clear code */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max
condition|;
name|n
operator|++
control|)
name|code
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* look at all (root + 1) bit and longer codes */
name|large
operator|=
literal|1
operator|<<
name|root
expr_stmt|;
comment|/* base table */
if|if
condition|(
name|root
operator|<
name|max
condition|)
comment|/* otherwise, there's only a base table */
for|for
control|(
name|n
operator|=
literal|3
init|;
name|n
operator|<=
name|syms
condition|;
name|n
operator|++
control|)
for|for
control|(
name|left
operator|=
literal|2
init|;
name|left
operator|<
name|n
condition|;
name|left
operator|+=
literal|2
control|)
block|{
comment|/* look at all reachable (root + 1) bit nodes, and the                    resulting codes (complete at root + 2 or more) */
name|index
operator|=
name|INDEX
argument_list|(
name|n
argument_list|,
name|left
argument_list|,
name|root
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|+
literal|1
operator|<
name|max
operator|&&
name|num
index|[
name|index
index|]
condition|)
comment|/* reachable node */
name|examine
argument_list|(
name|n
argument_list|,
name|root
operator|+
literal|1
argument_list|,
name|left
argument_list|,
literal|1
operator|<<
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* also look at root bit codes with completions at root + 1                    bits (not saved in num, since complete), just in case */
if|if
condition|(
name|num
index|[
name|index
operator|-
literal|1
index|]
operator|&&
name|n
operator|<=
name|left
operator|<<
literal|1
condition|)
name|examine
argument_list|(
operator|(
name|n
operator|-
name|left
operator|)
operator|<<
literal|1
argument_list|,
name|root
operator|+
literal|1
argument_list|,
operator|(
name|n
operator|-
name|left
operator|)
operator|<<
literal|1
argument_list|,
literal|1
operator|<<
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* done */
name|printf
argument_list|(
literal|"done: maximum of %d table entries\n"
argument_list|,
name|large
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    Examine and show the total number of possible Huffman codes for a given    maximum number of symbols, initial root table size, and maximum code length    in bits -- those are the command arguments in that order.  The default    values are 286, 9, and 15 respectively, for the deflate literal/length code.    The possible codes are counted for each number of coded symbols from two to    the maximum.  The counts for each of those and the total number of codes are    shown.  The maximum number of inflate table entires is then calculated    across all possible codes.  Each new maximum number of table entries and the    associated sub-code (starting at root + 1 == 10 bits) is shown.     To count and examine Huffman codes that are not length-limited, provide a    maximum length equal to the number of symbols minus one.     For the deflate literal/length code, use "enough".  For the deflate distance    code, use "enough 30 6".     This uses the %llu printf format to print big_t numbers, which assumes that    big_t is an unsigned long long.  If the big_t type is changed (for example    to a multiple precision type), the method of printing will also need to be    updated.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|syms
decl_stmt|;
comment|/* total number of symbols to code */
name|int
name|n
decl_stmt|;
comment|/* number of symbols to code for this run */
name|big_t
name|got
decl_stmt|;
comment|/* return value of count() */
name|big_t
name|sum
decl_stmt|;
comment|/* accumulated number of codes over n */
name|code_t
name|word
decl_stmt|;
comment|/* for counting bits in code_t */
comment|/* set up globals for cleanup() */
name|code
operator|=
name|NULL
expr_stmt|;
name|num
operator|=
name|NULL
expr_stmt|;
name|done
operator|=
name|NULL
expr_stmt|;
comment|/* get arguments -- default to the deflate literal/length code */
name|syms
operator|=
literal|286
expr_stmt|;
name|root
operator|=
literal|9
expr_stmt|;
name|max
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|syms
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|root
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
name|max
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|>
literal|4
operator|||
name|syms
operator|<
literal|2
operator|||
name|root
operator|<
literal|1
operator|||
name|max
operator|<
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"invalid arguments, need: [sym>= 2 [root>= 1 [max>= 1]]]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* if not restricting the code length, the longest is syms - 1 */
if|if
condition|(
name|max
operator|>
name|syms
operator|-
literal|1
condition|)
name|max
operator|=
name|syms
operator|-
literal|1
expr_stmt|;
comment|/* determine the number of bits in a code_t */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|word
operator|=
literal|1
init|;
name|word
condition|;
name|n
operator|++
operator|,
name|word
operator|<<=
literal|1
control|)
empty_stmt|;
comment|/* make sure that the calculation of most will not overflow */
if|if
condition|(
name|max
operator|>
name|n
operator|||
call|(
name|code_t
call|)
argument_list|(
name|syms
operator|-
literal|2
argument_list|)
operator|>=
operator|(
operator|(
operator|(
name|code_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|>>
operator|(
name|max
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"abort: code length too long for internal types\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* reject impossible code requests */
if|if
condition|(
call|(
name|code_t
call|)
argument_list|(
name|syms
operator|-
literal|1
argument_list|)
operator|>
operator|(
operator|(
name|code_t
operator|)
literal|1
operator|<<
name|max
operator|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d symbols cannot be coded in %d bits\n"
argument_list|,
name|syms
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* allocate code vector */
name|code
operator|=
name|calloc
argument_list|(
name|max
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"abort: unable to allocate enough memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* determine size of saved results array, checking for overflows,        allocate and clear the array (set all to zero with calloc()) */
if|if
condition|(
name|syms
operator|==
literal|2
condition|)
comment|/* iff max == 1 */
name|num
operator|=
name|NULL
expr_stmt|;
comment|/* won't be saving any results */
else|else
block|{
name|size
operator|=
name|syms
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|/
operator|(
name|n
operator|=
operator|(
name|syms
operator|-
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|||
operator|(
name|size
operator|*=
name|n
operator|,
name|size
operator|>
operator|(
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|/
operator|(
name|n
operator|=
name|max
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|size
operator|*=
name|n
operator|,
name|size
operator|>
operator|(
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|big_t
argument_list|)
operator|)
operator|||
operator|(
name|num
operator|=
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|big_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"abort: unable to allocate enough memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* count possible codes for all numbers of symbols, add up counts */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|2
init|;
name|n
operator|<=
name|syms
condition|;
name|n
operator|++
control|)
block|{
name|got
operator|=
name|count
argument_list|(
name|n
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|got
expr_stmt|;
if|if
condition|(
name|got
operator|==
operator|(
name|big_t
operator|)
literal|0
operator|-
literal|1
operator|||
name|sum
operator|<
name|got
condition|)
block|{
comment|/* overflow */
name|fputs
argument_list|(
literal|"abort: can't count that high!\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"%llu %d-codes\n"
argument_list|,
name|got
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%llu total codes for 2 to %d symbols"
argument_list|,
name|sum
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|syms
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" (%d-bit length limit)\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|" (no length limit)"
argument_list|)
expr_stmt|;
comment|/* allocate and clear done array for beenhere() */
if|if
condition|(
name|syms
operator|==
literal|2
condition|)
name|done
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
operator|(
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|tab
argument_list|)
operator|||
operator|(
name|done
operator|=
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tab
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"abort: unable to allocate enough memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* find and show maximum inflate table usage */
if|if
condition|(
name|root
operator|>
name|max
condition|)
comment|/* reduce root to max length */
name|root
operator|=
name|max
expr_stmt|;
if|if
condition|(
operator|(
name|code_t
operator|)
name|syms
operator|<
operator|(
operator|(
name|code_t
operator|)
literal|1
operator|<<
operator|(
name|root
operator|+
literal|1
operator|)
operator|)
condition|)
name|enough
argument_list|(
name|syms
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"cannot handle minimum code lengths> root"
argument_list|)
expr_stmt|;
comment|/* done */
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

