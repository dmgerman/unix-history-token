begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzappend -- command to append to a gzip file    Copyright (C) 2003, 2012 Mark Adler, all rights reserved   version 1.2, 11 Oct 2012    This software is provided 'as-is', without any express or implied   warranty.  In no event will the author be held liable for any damages   arising from the use of this software.    Permission is granted to anyone to use this software for any purpose,   including commercial applications, and to alter it and redistribute it   freely, subject to the following restrictions:    1. The origin of this software must not be misrepresented; you must not      claim that you wrote the original software. If you use this software      in a product, an acknowledgment in the product documentation would be      appreciated but is not required.   2. Altered source versions must be plainly marked as such, and must not be      misrepresented as being the original software.   3. This notice may not be removed or altered from any source distribution.    Mark Adler    madler@alumni.caltech.edu  */
end_comment

begin_comment
comment|/*  * Change history:  *  * 1.0  19 Oct 2003     - First version  * 1.1   4 Nov 2003     - Expand and clarify some comments and notes  *                      - Add version and copyright to help  *                      - Send help to stdout instead of stderr  *                      - Add some preemptive typecasts  *                      - Add L to constants in lseek() calls  *                      - Remove some debugging information in error messages  *                      - Use new data_type definition for zlib 1.2.1  *                      - Simplfy and unify file operations  *                      - Finish off gzip file in gztack()  *                      - Use deflatePrime() instead of adding empty blocks  *                      - Keep gzip file clean on appended file read errors  *                      - Use in-place rotate instead of auxiliary buffer  *                        (Why you ask?  Because it was fun to write!)  * 1.2  11 Oct 2012     - Fix for proper z_const usage  *                      - Check for input buffer malloc failure  */
end_comment

begin_comment
comment|/*    gzappend takes a gzip file and appends to it, compressing files from the    command line or data from stdin.  The gzip file is written to directly, to    avoid copying that file, in case it's large.  Note that this results in the    unfriendly behavior that if gzappend fails, the gzip file is corrupted.     This program was written to illustrate the use of the new Z_BLOCK option of    zlib 1.2.x's inflate() function.  This option returns from inflate() at each    block boundary to facilitate locating and modifying the last block bit at    the start of the final deflate block.  Also whether using Z_BLOCK or not,    another required feature of zlib 1.2.x is that inflate() now provides the    number of unusued bits in the last input byte used.  gzappend will not work    with versions of zlib earlier than 1.2.1.     gzappend first decompresses the gzip file internally, discarding all but    the last 32K of uncompressed data, and noting the location of the last block    bit and the number of unused bits in the last byte of the compressed data.    The gzip trailer containing the CRC-32 and length of the uncompressed data    is verified.  This trailer will be later overwritten.     Then the last block bit is cleared by seeking back in the file and rewriting    the byte that contains it.  Seeking forward, the last byte of the compressed    data is saved along with the number of unused bits to initialize deflate.     A deflate process is initialized, using the last 32K of the uncompressed    data from the gzip file to initialize the dictionary.  If the total    uncompressed data was less than 32K, then all of it is used to initialize    the dictionary.  The deflate output bit buffer is also initialized with the    last bits from the original deflate stream.  From here on, the data to    append is simply compressed using deflate, and written to the gzip file.    When that is complete, the new CRC-32 and uncompressed length are written    as the trailer of the gzip file.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_define
define|#
directive|define
name|LGCHUNK
value|14
end_define

begin_define
define|#
directive|define
name|CHUNK
value|(1U<< LGCHUNK)
end_define

begin_define
define|#
directive|define
name|DSIZE
value|32768U
end_define

begin_comment
comment|/* print an error message and terminate with extreme prejudice */
end_comment

begin_function
name|local
name|void
name|bye
parameter_list|(
name|char
modifier|*
name|msg1
parameter_list|,
name|char
modifier|*
name|msg2
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gzappend error: %s%s\n"
argument_list|,
name|msg1
argument_list|,
name|msg2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return the greatest common divisor of a and b using Euclid's algorithm,    modified to be fast when one argument much greater than the other, and    coded to avoid unnecessary swapping */
end_comment

begin_function
name|local
name|unsigned
name|gcd
parameter_list|(
name|unsigned
name|a
parameter_list|,
name|unsigned
name|b
parameter_list|)
block|{
name|unsigned
name|c
decl_stmt|;
while|while
condition|(
name|a
operator|&&
name|b
condition|)
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|c
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|a
operator|-
name|c
operator|>=
name|c
condition|)
name|c
operator|<<=
literal|1
expr_stmt|;
name|a
operator|-=
name|c
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|b
operator|-
name|c
operator|>=
name|c
condition|)
name|c
operator|<<=
literal|1
expr_stmt|;
name|b
operator|-=
name|c
expr_stmt|;
block|}
return|return
name|a
operator|+
name|b
return|;
block|}
end_function

begin_comment
comment|/* rotate list[0..len-1] left by rot positions, in place */
end_comment

begin_function
name|local
name|void
name|rotate
parameter_list|(
name|unsigned
name|char
modifier|*
name|list
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|unsigned
name|rot
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|unsigned
name|cycles
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
comment|/* normalize rot and handle degenerate cases */
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|rot
operator|>=
name|len
condition|)
name|rot
operator|%=
name|len
expr_stmt|;
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
return|return;
comment|/* pointer to last entry in list */
name|last
operator|=
name|list
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* do simple left shift by one */
if|if
condition|(
name|rot
operator|==
literal|1
condition|)
block|{
name|tmp
operator|=
operator|*
name|list
expr_stmt|;
name|memcpy
argument_list|(
name|list
argument_list|,
name|list
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
comment|/* do simple right shift by one */
if|if
condition|(
name|rot
operator|==
name|len
operator|-
literal|1
condition|)
block|{
name|tmp
operator|=
operator|*
name|last
expr_stmt|;
name|memmove
argument_list|(
name|list
operator|+
literal|1
argument_list|,
name|list
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
comment|/* otherwise do rotate as a set of cycles in place */
name|cycles
operator|=
name|gcd
argument_list|(
name|len
argument_list|,
name|rot
argument_list|)
expr_stmt|;
comment|/* number of cycles */
do|do
block|{
name|start
operator|=
name|from
operator|=
name|list
operator|+
name|cycles
expr_stmt|;
comment|/* start index is arbitrary */
name|tmp
operator|=
operator|*
name|from
expr_stmt|;
comment|/* save entry to be overwritten */
for|for
control|(
init|;
condition|;
control|)
block|{
name|to
operator|=
name|from
expr_stmt|;
comment|/* next step in cycle */
name|from
operator|+=
name|rot
expr_stmt|;
comment|/* go right rot positions */
if|if
condition|(
name|from
operator|>
name|last
condition|)
name|from
operator|-=
name|len
expr_stmt|;
comment|/* (pointer better not wrap) */
if|if
condition|(
name|from
operator|==
name|start
condition|)
break|break;
comment|/* all but one shifted */
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
comment|/* shift left */
block|}
operator|*
name|to
operator|=
name|tmp
expr_stmt|;
comment|/* complete the circle */
block|}
do|while
condition|(
operator|--
name|cycles
condition|)
do|;
block|}
end_function

begin_comment
comment|/* structure for gzip file read operations */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|size
decl_stmt|;
comment|/* 1<< size is bytes in buf */
name|unsigned
name|left
decl_stmt|;
comment|/* bytes available at next */
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer */
name|z_const
name|unsigned
name|char
modifier|*
name|next
decl_stmt|;
comment|/* next byte in buffer */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name for error messages */
block|}
name|file
typedef|;
end_typedef

begin_comment
comment|/* reload buffer */
end_comment

begin_function
name|local
name|int
name|readin
parameter_list|(
name|file
modifier|*
name|in
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|in
operator|->
name|fd
argument_list|,
name|in
operator|->
name|buf
argument_list|,
literal|1
operator|<<
name|in
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|bye
argument_list|(
literal|"error reading "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|in
operator|->
name|left
operator|=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
name|in
operator|->
name|next
operator|=
name|in
operator|->
name|buf
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* read from file in, exit if end-of-file */
end_comment

begin_function
name|local
name|int
name|readmore
parameter_list|(
name|file
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
name|readin
argument_list|(
name|in
argument_list|)
operator|==
literal|0
condition|)
name|bye
argument_list|(
literal|"unexpected end of "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|read1
parameter_list|(
name|in
parameter_list|)
value|(in->left == 0 ? readmore(in) : 0, \                    in->left--, *(in->next)++)
end_define

begin_comment
comment|/* skip over n bytes of in */
end_comment

begin_function
name|local
name|void
name|skip
parameter_list|(
name|file
modifier|*
name|in
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|unsigned
name|bypass
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|in
operator|->
name|left
condition|)
block|{
name|n
operator|-=
name|in
operator|->
name|left
expr_stmt|;
name|bypass
operator|=
name|n
operator|&
operator|~
operator|(
operator|(
literal|1U
operator|<<
name|in
operator|->
name|size
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|in
operator|->
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|bypass
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|bye
argument_list|(
literal|"seeking "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|n
operator|-=
name|bypass
expr_stmt|;
block|}
name|readmore
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|in
operator|->
name|left
condition|)
name|bye
argument_list|(
literal|"unexpected end of "
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|in
operator|->
name|left
operator|-=
name|n
expr_stmt|;
name|in
operator|->
name|next
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read a four-byte unsigned integer, little-endian, from in */
end_comment

begin_function
name|unsigned
name|long
name|read4
parameter_list|(
name|file
modifier|*
name|in
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
name|read1
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|val
operator|+=
operator|(
name|unsigned
operator|)
name|read1
argument_list|(
name|in
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|val
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|read1
argument_list|(
name|in
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|val
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|read1
argument_list|(
name|in
argument_list|)
operator|<<
literal|24
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* skip over gzip header */
end_comment

begin_function
name|local
name|void
name|gzheader
parameter_list|(
name|file
modifier|*
name|in
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
if|if
condition|(
name|read1
argument_list|(
name|in
argument_list|)
operator|!=
literal|31
operator|||
name|read1
argument_list|(
name|in
argument_list|)
operator|!=
literal|139
condition|)
name|bye
argument_list|(
name|in
operator|->
name|name
argument_list|,
literal|" not a gzip file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
argument_list|(
name|in
argument_list|)
operator|!=
literal|8
condition|)
name|bye
argument_list|(
literal|"unknown compression method in"
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
name|read1
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0xe0
condition|)
name|bye
argument_list|(
literal|"unknown header flags set in"
argument_list|,
name|in
operator|->
name|name
argument_list|)
expr_stmt|;
name|skip
argument_list|(
name|in
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
block|{
name|n
operator|=
name|read1
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|n
operator|+=
call|(
name|unsigned
call|)
argument_list|(
name|read1
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|skip
argument_list|(
name|in
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|8
condition|)
while|while
condition|(
name|read1
argument_list|(
name|in
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|16
condition|)
while|while
condition|(
name|read1
argument_list|(
name|in
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|skip
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* decompress gzip file "name", return strm with a deflate stream ready to    continue compression of the data in the gzip file, and return a file    descriptor pointing to where to write the compressed data -- the deflate    stream is initialized to compress using level "level" */
end_comment

begin_function
name|local
name|int
name|gzscan
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|z_stream
modifier|*
name|strm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|lastbit
decl_stmt|,
name|left
decl_stmt|,
name|full
decl_stmt|;
name|unsigned
name|have
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|,
name|tot
decl_stmt|;
name|unsigned
name|char
modifier|*
name|window
decl_stmt|;
name|off_t
name|lastoff
decl_stmt|,
name|end
decl_stmt|;
name|file
name|gz
decl_stmt|;
comment|/* open gzip file */
name|gz
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|gz
operator|.
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gz
operator|.
name|fd
operator|==
operator|-
literal|1
condition|)
name|bye
argument_list|(
literal|"cannot open "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gz
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|gz
operator|.
name|buf
operator|==
name|NULL
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|gz
operator|.
name|size
operator|=
name|LGCHUNK
expr_stmt|;
name|gz
operator|.
name|left
operator|=
literal|0
expr_stmt|;
comment|/* skip gzip header */
name|gzheader
argument_list|(
operator|&
name|gz
argument_list|)
expr_stmt|;
comment|/* prepare to decompress */
name|window
operator|=
name|malloc
argument_list|(
name|DSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|==
name|NULL
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strm
operator|->
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
name|strm
argument_list|,
operator|-
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|" or library mismatch"
argument_list|)
expr_stmt|;
comment|/* decompress the deflate stream, saving append information */
name|lastbit
operator|=
literal|0
expr_stmt|;
name|lastoff
operator|=
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
name|gz
operator|.
name|left
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|gz
operator|.
name|left
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|gz
operator|.
name|next
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|have
operator|=
name|full
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* if needed, get more input */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|readmore
argument_list|(
operator|&
name|gz
argument_list|)
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|gz
operator|.
name|left
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|gz
operator|.
name|next
expr_stmt|;
block|}
comment|/* set up output to next available section of sliding window */
name|strm
operator|->
name|avail_out
operator|=
name|DSIZE
operator|-
name|have
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|window
operator|+
name|have
expr_stmt|;
comment|/* inflate and check for errors */
name|ret
operator|=
name|inflate
argument_list|(
name|strm
argument_list|,
name|Z_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
condition|)
name|bye
argument_list|(
literal|"internal stream error!"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_DATA_ERROR
condition|)
name|bye
argument_list|(
literal|"invalid compressed data--format violated in"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* update crc and sliding window pointer */
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|window
operator|+
name|have
argument_list|,
name|DSIZE
operator|-
name|have
operator|-
name|strm
operator|->
name|avail_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
condition|)
name|have
operator|=
name|DSIZE
operator|-
name|strm
operator|->
name|avail_out
expr_stmt|;
else|else
block|{
name|have
operator|=
literal|0
expr_stmt|;
name|full
operator|=
literal|1
expr_stmt|;
block|}
comment|/* process end of block */
if|if
condition|(
name|strm
operator|->
name|data_type
operator|&
literal|128
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|data_type
operator|&
literal|64
condition|)
name|left
operator|=
name|strm
operator|->
name|data_type
operator|&
literal|0x1f
expr_stmt|;
else|else
block|{
name|lastbit
operator|=
name|strm
operator|->
name|data_type
operator|&
literal|0x1f
expr_stmt|;
name|lastoff
operator|=
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
name|strm
operator|->
name|avail_in
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
name|inflateEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|gz
operator|.
name|left
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|gz
operator|.
name|next
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
comment|/* save the location of the end of the compressed data */
name|end
operator|=
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
name|gz
operator|.
name|left
expr_stmt|;
comment|/* check gzip trailer and save total for deflate */
if|if
condition|(
name|crc
operator|!=
name|read4
argument_list|(
operator|&
name|gz
argument_list|)
condition|)
name|bye
argument_list|(
literal|"invalid compressed data--crc mismatch in "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tot
operator|=
name|strm
operator|->
name|total_out
expr_stmt|;
if|if
condition|(
operator|(
name|tot
operator|&
literal|0xffffffffUL
operator|)
operator|!=
name|read4
argument_list|(
operator|&
name|gz
argument_list|)
condition|)
name|bye
argument_list|(
literal|"invalid compressed data--length mismatch in"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* if not at end of file, warn */
if|if
condition|(
name|gz
operator|.
name|left
operator|||
name|readin
argument_list|(
operator|&
name|gz
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gzappend warning: junk at end of gzip file overwritten\n"
argument_list|)
expr_stmt|;
comment|/* clear last block bit */
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
name|lastoff
operator|-
operator|(
name|lastbit
operator|!=
literal|0
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
name|gz
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|bye
argument_list|(
literal|"reading after seek on "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|gz
operator|.
name|buf
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|gz
operator|.
name|buf
operator|^
operator|(
literal|1
operator|<<
operator|(
operator|(
literal|8
operator|-
name|lastbit
operator|)
operator|&
literal|7
operator|)
operator|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
operator|-
literal|1L
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
name|gz
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|bye
argument_list|(
literal|"writing after seek to "
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* if window wrapped, build dictionary from window by rotating */
if|if
condition|(
name|full
condition|)
block|{
name|rotate
argument_list|(
name|window
argument_list|,
name|DSIZE
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|have
operator|=
name|DSIZE
expr_stmt|;
block|}
comment|/* set up deflate stream with window, crc, total_in, and leftover bits */
name|ret
operator|=
name|deflateInit2
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
literal|15
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|deflateSetDictionary
argument_list|(
name|strm
argument_list|,
name|window
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|crc
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
name|tot
expr_stmt|;
if|if
condition|(
name|left
condition|)
block|{
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
operator|--
name|end
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
name|gz
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|bye
argument_list|(
literal|"reading after seek on "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|deflatePrime
argument_list|(
name|strm
argument_list|,
literal|8
operator|-
name|left
argument_list|,
operator|*
name|gz
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|gz
operator|.
name|fd
argument_list|,
name|end
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* clean up and return */
name|free
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gz
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|gz
operator|.
name|fd
return|;
block|}
end_function

begin_comment
comment|/* append file "name" to gzip file gd using deflate stream strm -- if last    is true, then finish off the deflate stream at the end */
end_comment

begin_function
name|local
name|void
name|gztack
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|gd
parameter_list|,
name|z_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|left
decl_stmt|;
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
comment|/* open file to compress and append */
name|fd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gzappend warning: %s not found, skipping ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* allocate buffers */
name|in
operator|=
name|malloc
argument_list|(
name|CHUNK
argument_list|)
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
name|bye
argument_list|(
literal|"out of memory"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* compress input file and append to gzip file */
do|do
block|{
comment|/* get more input */
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|in
argument_list|,
name|CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gzappend warning: error reading %s, skipping rest ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|strm
operator|->
name|avail_in
operator|=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|in
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* compress and write all available output */
do|do
block|{
name|strm
operator|->
name|avail_out
operator|=
name|CHUNK
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
name|strm
argument_list|,
name|last
operator|&&
name|len
operator|==
literal|0
condition|?
name|Z_FINISH
else|:
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|left
operator|=
name|CHUNK
operator|-
name|strm
operator|->
name|avail_out
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|len
operator|=
name|write
argument_list|(
name|gd
argument_list|,
name|out
operator|+
name|CHUNK
operator|-
name|strm
operator|->
name|avail_out
operator|-
name|left
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|bye
argument_list|(
literal|"writing gzip file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|left
operator|-=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
block|}
block|}
do|while
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
comment|/* write trailer after last entry */
if|if
condition|(
name|last
condition|)
block|{
name|deflateEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|adler
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|total_in
argument_list|)
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|total_in
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|total_in
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|strm
operator|->
name|total_in
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|write
argument_list|(
name|gd
argument_list|,
name|out
operator|+
literal|8
operator|-
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|bye
argument_list|(
literal|"writing gzip file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|len
operator|-=
name|ret
expr_stmt|;
block|}
do|while
condition|(
name|len
condition|)
do|;
name|close
argument_list|(
name|gd
argument_list|)
expr_stmt|;
block|}
comment|/* clean up and return */
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* process the compression level option if present, scan the gzip file, and    append the specified files, or append the data from stdin if no other file    names are provided on the command line -- the gzip file must be writable    and seekable */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|gd
decl_stmt|,
name|level
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
comment|/* ignore command name */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* provide usage if no arguments */
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* set compression level */
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|>
literal|'9'
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|bye
argument_list|(
literal|"invalid compression level"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|bye
argument_list|(
literal|"no gzip file name after options"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* prepare to append to gzip file */
name|gd
operator|=
name|gzscan
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
operator|&
name|strm
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* append files on command line, or from stdin if none */
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
name|gztack
argument_list|(
name|NULL
argument_list|,
name|gd
argument_list|,
operator|&
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
do|do
block|{
name|gztack
argument_list|(
operator|*
name|argv
argument_list|,
name|gd
argument_list|,
operator|&
name|strm
argument_list|,
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|argv
operator|!=
name|NULL
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

end_unit

