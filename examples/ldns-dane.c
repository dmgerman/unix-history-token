begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Verify or create TLS authentication with DANE (RFC6698)  *  * (c) NLnetLabs 2012  *  * See the file LICENSE for the license.  *  * wish list:  * - nicer reporting (tracing of evaluation process)  * - verbosity levels  * - STARTTLS support  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DANE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|IPPROTO_SCTP
end_ifndef

begin_define
define|#
directive|define
name|IPPROTO_SCTP
value|132
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LDNS_ERR
parameter_list|(
name|code
parameter_list|,
name|msg
parameter_list|)
value|do { if (code != LDNS_STATUS_OK) \ 					ldns_err(msg, code); } while (false)
end_define

begin_define
define|#
directive|define
name|MEMERR
parameter_list|(
name|msg
parameter_list|)
value|do { fprintf(stderr, "memory error in %s\n", msg); \ 			 exit(EXIT_FAILURE); } while (false)
end_define

begin_define
define|#
directive|define
name|BUFSIZE
value|16384
end_define

begin_comment
comment|/* Exit status on a PKIX validated connection but without TLSA records  * when the -T option was given:  */
end_comment

begin_define
define|#
directive|define
name|NO_TLSAS_EXIT_STATUS
value|2
end_define

begin_comment
comment|/* int verbosity = 3; */
end_comment

begin_function
name|void
name|print_usage
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [OPTIONS] verify<name><port>\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   or: %s [OPTIONS] -t<tlsafile> verify\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tVerify the TLS connection at<name>:<port> or"
literal|"\n\tuse TLSA record(s) from<tlsafile> to verify the\n"
literal|"\tTLS service they reference.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n   or: %s [OPTIONS] create<name><port> [<usage> "
literal|"[<selector> [<type>]]]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tUse the TLS connection(s) to<name><port> "
literal|"to create the TLSA\n\t"
literal|"resource record(s) that would "
literal|"authenticate the connection.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t<usage>"
literal|"\t\t0: CA constraint\n"
literal|"\t\t\t1: Service certificate constraint\n"
literal|"\t\t\t2: Trust anchor assertion\n"
literal|"\t\t\t3: Domain-issued certificate (default)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t<selector>"
literal|"\t0: Full certificate (default)\n"
literal|"\t\t\t1: SubjectPublicKeyInfo\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t<type>"
literal|"\t\t0: No hash used\n"
literal|"\t\t\t1: SHA-256 (default)\n"
literal|"\t\t\t2: SHA-512\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"OPTIONS:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-h\t\tshow this text\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-4\t\tTLS connect IPv4 only\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-6\t\tTLS connect IPv6 only\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-a<address>\t"
literal|"don't resolve<name>, but connect to<address>(es)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-b\t\t"
literal|"print \"<name>. TYPE52 \\#<size><hex data>\" form\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-c<certfile>\t"
literal|"verify or create TLSA records for the\n"
literal|"\t\t\tcertificate (chain) in<certfile>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-d\t\tassume DNSSEC validity even when insecure or bogus\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-f<CAfile>\tuse CAfile to validate\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_DANE_CA_FILE
name|printf
argument_list|(
literal|"\t\t\tDefault is %s\n"
argument_list|,
name|LDNS_DANE_CA_FILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\t-i\t\tinteract after connecting\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-k<keyfile>\t"
literal|"use DNSKEY/DS rr(s) in<keyfile> to validate TLSAs\n"
literal|"\t\t\twhen signature chasing (i.e. -S)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\tDefault is %s\n"
argument_list|,
name|LDNS_TRUST_ANCHOR_FILE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-n\t\tdo *not* verify server name in certificate\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-o<offset>\t"
literal|"select<offset>th certificate from the end of\n"
literal|"\t\t\tthe validation chain. -1 means self-signed at end\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-p<CApath>\t"
literal|"use certificates in the<CApath> directory to validate\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_DANE_CA_PATH
name|printf
argument_list|(
literal|"\t\t\tDefaults is %s\n"
argument_list|,
name|LDNS_DANE_CA_PATH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\t-s\t\tassume PKIX validity\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-S\t\tChase signature(s) to a known key\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-t<tlsafile>\tdo not use DNS, "
literal|"but read TLSA record(s) from<tlsafile>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-T\t\tReturn exit status 2 for PKIX validated connections\n"
literal|"\t\t\twithout (secure) TLSA records(s)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-u\t\tuse UDP transport instead of TCP\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-v\t\tshow version and exit\n"
argument_list|)
expr_stmt|;
comment|/* printf("\t-V [0-5]\tset verbosity level (default 3)\n"); */
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dane_int_within_range
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* utility var for strtol usage */
name|int
name|val
init|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|max
operator|)
operator|||
operator|(
name|errno
operator|!=
literal|0
operator|&&
name|val
operator|==
literal|0
operator|)
comment|/* out of range */
operator|||
name|endptr
operator|==
name|arg
comment|/* no digits */
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
comment|/* more chars */
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> should be in range [0-%d]\n"
argument_list|,
name|name
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_struct
struct|struct
name|dane_param_choice_struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dane_param_choice_struct
name|dane_param_choice
typedef|;
end_typedef

begin_decl_stmt
name|dane_param_choice
name|dane_certificate_usage_table
index|[]
init|=
block|{
block|{
literal|"CA constraint"
block|,
literal|0
block|}
block|,
block|{
literal|"CA-constraint"
block|,
literal|0
block|}
block|,
block|{
literal|"Service certificate constraint"
block|,
literal|1
block|}
block|,
block|{
literal|"Service-certificate-constraint"
block|,
literal|1
block|}
block|,
block|{
literal|"Trust anchor assertion"
block|,
literal|2
block|}
block|,
block|{
literal|"Trust-anchor-assertion"
block|,
literal|2
block|}
block|,
block|{
literal|"anchor"
block|,
literal|2
block|}
block|,
block|{
literal|"Domain-issued certificate"
block|,
literal|3
block|}
block|,
block|{
literal|"Domain-issued-certificate"
block|,
literal|3
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dane_param_choice
name|dane_selector_table
index|[]
init|=
block|{
block|{
literal|"Full certificate"
block|,
literal|0
block|}
block|,
block|{
literal|"Full-certificate"
block|,
literal|0
block|}
block|,
block|{
literal|"certificate"
block|,
literal|0
block|}
block|,
block|{
literal|"SubjectPublicKeyInfo"
block|,
literal|1
block|}
block|,
block|{
literal|"PublicKey"
block|,
literal|1
block|}
block|,
block|{
literal|"pubkey"
block|,
literal|1
block|}
block|,
block|{
literal|"key"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dane_int_within_range_table
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dane_param_choice
name|table
index|[]
parameter_list|)
block|{
name|dane_param_choice
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|name
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|arg
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|t
operator|->
name|number
return|;
block|}
block|}
block|}
return|return
name|dane_int_within_range
argument_list|(
name|arg
argument_list|,
name|max
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ssl_err
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldns_err
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ldns_status
name|err
parameter_list|)
block|{
if|if
condition|(
name|err
operator|==
name|LDNS_STATUS_SSL_ERR
condition|)
block|{
name|ssl_err
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|s
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|ldns_status
name|ssl_connect_and_get_cert_chain
argument_list|(
name|X509
operator|*
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|extra_certs
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
specifier|const
name|char
operator|*
name|name_str
argument_list|,
name|ldns_rdf
operator|*
name|address
argument_list|,
name|uint16_t
name|port
argument_list|,
name|ldns_dane_transport
name|transport
argument_list|)
block|{
name|struct
name|sockaddr_storage
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
name|size_t
name|a_len
init|=
literal|0
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assert
argument_list|(
name|cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|extra_certs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|a
operator|=
name|ldns_rdf2native_sockaddr_storage
argument_list|(
name|address
argument_list|,
name|port
argument_list|,
operator|&
name|a_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transport
condition|)
block|{
case|case
name|LDNS_DANE_TRANSPORT_TCP
case|:
name|sock
operator|=
name|socket
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|a
argument_list|)
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_DANE_TRANSPORT_UDP
case|:
name|sock
operator|=
name|socket
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|a
argument_list|)
operator|->
name|sa_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_DANE_TRANSPORT_SCTP
case|:
name|sock
operator|=
name|socket
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|a
argument_list|)
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_SCTP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LDNS_FREE
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_DANE_UNKNOWN_TRANSPORT
return|;
block|}
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_NETWORK_ERR
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|a
argument_list|,
operator|(
name|socklen_t
operator|)
name|a_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_NETWORK_ERR
return|;
block|}
name|LDNS_FREE
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_clear
argument_list|(
name|ssl
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSL_clear\n"
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
ifdef|#
directive|ifdef
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
operator|(
name|void
operator|)
name|SSL_set_tlsext_host_name
argument_list|(
name|ssl
argument_list|,
name|name_str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_set_mode
argument_list|(
name|ssl
argument_list|,
name|SSL_MODE_AUTO_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|ssl
argument_list|,
name|sock
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSL_set_fd\n"
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|ssl
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
break|break;
block|}
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_WANT_READ
operator|&&
name|r
operator|!=
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handshaking SSL_get_error: %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_SSL_ERR
return|;
block|}
block|}
operator|*
name|cert
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
operator|*
name|extra_certs
operator|=
name|SSL_get_peer_cert_chain
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_decl_stmt

begin_function
name|void
name|ssl_interact
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|fd_set
name|rfds
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|int
name|to_write
decl_stmt|;
name|int
name|written
decl_stmt|;
name|sock
operator|=
name|SSL_get_fd
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|maxfd
operator|=
operator|(
name|STDIN_FILENO
operator|>
name|sock
condition|?
name|STDIN_FILENO
else|:
name|sock
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* splint */
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|r
operator|=
name|select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sock
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
name|to_write
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_write
operator|<=
literal|0
condition|)
block|{
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reading SSL_get_error:"
literal|" %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|bufptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
operator|(
name|int
operator|)
name|fwrite
argument_list|(
name|bufptr
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|to_write
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fwrite"
argument_list|)
expr_stmt|;
break|break;
block|}
name|to_write
operator|-=
name|written
expr_stmt|;
name|bufptr
operator|+=
name|written
expr_stmt|;
block|}
block|}
comment|/* if (FD_ISSET(sock,&rfds)) */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
name|to_write
operator|=
operator|(
name|int
operator|)
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|buf
argument_list|,
name|BUFSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_write
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|to_write
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|buf
index|[
name|to_write
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|buf
index|[
name|to_write
operator|-
literal|1
index|]
operator|=
literal|'\r'
expr_stmt|;
name|buf
index|[
name|to_write
index|]
operator|=
literal|'\n'
expr_stmt|;
name|to_write
operator|+=
literal|1
expr_stmt|;
block|}
name|bufptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|bufptr
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|<=
literal|0
condition|)
block|{
name|r
operator|=
name|SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writing SSL_get_error"
literal|": %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|to_write
operator|-=
name|written
expr_stmt|;
name|bufptr
operator|+=
name|written
expr_stmt|;
block|}
block|}
comment|/* if (FD_ISSET(STDIN_FILENO,&rfds)) */
block|}
comment|/* for (;;) */
block|}
end_function

begin_function
name|ldns_rr_list
modifier|*
name|rr_list_filter_rr_type
parameter_list|(
name|ldns_rr_list
modifier|*
name|l
parameter_list|,
name|ldns_rr_type
name|t
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
decl_stmt|;
name|ldns_rr_list
modifier|*
name|r
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
return|return
name|r
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|r
argument_list|,
name|rr
argument_list|)
condition|)
block|{
name|ldns_rr_list_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the list of tlsa records where the usage types  * "CA constraint" are replaced with "Trust anchor assertion" and the usage  * types "Service certificate constraint" are replaced with   * "Domain-issued certificate".  *  * This to check what would happen if PKIX validation was successfull always.  */
end_comment

begin_function
name|ldns_rr_list
modifier|*
name|dane_no_pkix_transform
parameter_list|(
specifier|const
name|ldns_rr_list
modifier|*
name|tlas
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
decl_stmt|;
name|ldns_rr
modifier|*
name|new_rr
decl_stmt|;
name|ldns_rdf
modifier|*
name|rdf
decl_stmt|;
name|ldns_rr_list
modifier|*
name|r
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
return|return
name|r
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|tlas
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|tlas
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_TLSA
condition|)
block|{
name|new_rr
operator|=
name|ldns_rr_clone
argument_list|(
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_rr
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|ldns_rdf2native_int8
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|new_rr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|LDNS_TLSA_USAGE_CA_CONSTRAINT
case|:
name|rdf
operator|=
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
operator|(
name|uint8_t
operator|)
name|LDNS_TLSA_USAGE_TRUST_ANCHOR_ASSERTION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdf
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|new_rr
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
name|new_rr
argument_list|,
name|rdf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_TLSA_USAGE_SERVICE_CERTIFICATE_CONSTRAINT
case|:
name|rdf
operator|=
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
operator|(
name|uint8_t
operator|)
name|LDNS_TLSA_USAGE_DOMAIN_ISSUED_CERTIFICATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdf
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|new_rr
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_set_rdf
argument_list|(
name|new_rr
argument_list|,
name|rdf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|r
argument_list|,
name|new_rr
argument_list|)
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|new_rr
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|print_rr_as_TYPEXXX
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|ldns_rr
modifier|*
name|rr
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|ldns_buffer
modifier|*
name|buf
init|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|ldns_rdf2buffer_str_dname
argument_list|(
name|buf
argument_list|,
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not ldns_rdf2buffer_str_dname"
argument_list|)
expr_stmt|;
name|ldns_buffer_printf
argument_list|(
name|buf
argument_list|,
literal|"\t%d"
argument_list|,
name|ldns_rr_ttl
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_buffer_printf
argument_list|(
name|buf
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|s
operator|=
name|ldns_rr_class2buffer_str
argument_list|(
name|buf
argument_list|,
name|ldns_rr_get_class
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not ldns_rr_class2buffer_str"
argument_list|)
expr_stmt|;
name|ldns_buffer_printf
argument_list|(
name|buf
argument_list|,
literal|"\tTYPE%d"
argument_list|,
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_rd_count
argument_list|(
name|rr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sz
operator|+=
name|ldns_rdf_size
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_buffer_printf
argument_list|(
name|buf
argument_list|,
literal|"\t\\# %d "
argument_list|,
name|sz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_rd_count
argument_list|(
name|rr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|ldns_rdf2buffer_str_hex
argument_list|(
name|buf
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not ldns_rdf2buffer_str_hex"
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|ldns_buffer_export2str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_rr_list_as_TYPEXXX
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|ldns_rr_list
modifier|*
name|l
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_rr_as_TYPEXXX
argument_list|(
name|out
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ldns_status
name|read_key_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_status
name|status
init|=
name|LDNS_STATUS_ERR
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|my_ttl
init|=
literal|0
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_origin
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_prev
init|=
name|NULL
decl_stmt|;
name|int
name|line_nr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
return|return
name|LDNS_STATUS_FILE_ERR
return|;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|status
operator|=
name|ldns_rr_new_frm_fp_l
argument_list|(
operator|&
name|rr
argument_list|,
name|fp
argument_list|,
operator|&
name|my_ttl
argument_list|,
operator|&
name|my_origin
argument_list|,
operator|&
name|my_prev
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_DNSKEY
condition|)
name|ldns_rr_list_push_rr
argument_list|(
name|keys
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_SYNTAX_EMPTY
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_TTL
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_ORIGIN
operator|||
name|status
operator|==
name|LDNS_STATUS_SYNTAX_INCLUDE
condition|)
name|status
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
else|else
break|break;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|ldns_status
name|dane_setup_resolver
parameter_list|(
name|ldns_resolver
modifier|*
modifier|*
name|res
parameter_list|,
name|ldns_rr_list
modifier|*
name|keys
parameter_list|,
name|bool
name|dnssec_off
parameter_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|assert
argument_list|(
name|res
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ldns_resolver_new_frm_file
argument_list|(
name|res
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_resolver_set_dnssec
argument_list|(
operator|*
name|res
argument_list|,
operator|!
name|dnssec_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|&&
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* anchors must trigger signature chasing */
name|ldns_resolver_set_dnssec_anchors
argument_list|(
operator|*
name|res
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|ldns_resolver_set_dnssec_cd
argument_list|(
operator|*
name|res
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|ldns_status
name|dane_query
parameter_list|(
name|ldns_rr_list
modifier|*
modifier|*
name|rrs
parameter_list|,
name|ldns_resolver
modifier|*
name|r
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|ldns_rr_type
name|t
parameter_list|,
name|ldns_rr_class
name|c
parameter_list|,
name|bool
name|insecure_is_ok
parameter_list|)
block|{
name|ldns_pkt
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|keys
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|rrsigs
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|signame
init|=
name|NULL
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
name|assert
argument_list|(
name|rrs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|ldns_resolver_query
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
name|LDNS_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
operator|*
name|rrs
operator|=
name|ldns_pkt_rr_list_by_type
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|LDNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ldns_resolver_dnssec
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* DNSSEC explicitely disabled, 					    anything goes */
name|ldns_pkt_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
operator|*
name|rrs
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* assert(*rrs == NULL) */
if|if
condition|(
name|ldns_pkt_get_rcode
argument_list|(
name|p
argument_list|)
operator|==
name|LDNS_RCODE_SERVFAIL
condition|)
block|{
name|ldns_pkt_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_DANE_BOGUS
return|;
block|}
else|else
block|{
name|ldns_pkt_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
block|}
comment|/* We have answers and we have dnssec. */
if|if
condition|(
operator|!
name|ldns_pkt_cd
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* we act as stub resolver (no sigchase) */
if|if
condition|(
operator|!
name|ldns_pkt_ad
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Not secure */
goto|goto
name|insecure
goto|;
block|}
name|ldns_pkt_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
comment|/* sigchase */
comment|/* TODO: handle cname reference check */
name|rrsigs
operator|=
name|ldns_pkt_rr_list_by_type
argument_list|(
name|p
argument_list|,
name|LDNS_RR_TYPE_RRSIG
argument_list|,
name|LDNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrsigs
operator|||
name|ldns_rr_list_rr_count
argument_list|(
name|rrsigs
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|insecure
goto|;
block|}
name|signame
operator|=
name|ldns_rr_rrsig_signame
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrsigs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signame
condition|)
block|{
name|s
operator|=
name|LDNS_STATUS_ERR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* First try with the keys we already have */
name|s
operator|=
name|ldns_verify
argument_list|(
operator|*
name|rrs
argument_list|,
name|rrsigs
argument_list|,
name|ldns_resolver_dnssec_anchors
argument_list|(
name|r
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* Fetch the necessary keys and recheck */
name|keys
operator|=
name|ldns_fetch_valid_domain_keys
argument_list|(
name|r
argument_list|,
name|signame
argument_list|,
name|ldns_resolver_dnssec_anchors
argument_list|(
name|r
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* An insecure island */
goto|goto
name|insecure
goto|;
block|}
name|s
operator|=
name|ldns_verify
argument_list|(
operator|*
name|rrs
argument_list|,
name|rrsigs
argument_list|,
name|keys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|LDNS_STATUS_CRYPTO_BOGUS
case|:
goto|goto
name|bogus
goto|;
case|case
name|LDNS_STATUS_OK
case|:
goto|goto
name|cleanup
goto|;
default|default                      :
break|break;
block|}
name|insecure
label|:
name|s
operator|=
name|LDNS_STATUS_DANE_INSECURE
expr_stmt|;
name|bogus
label|:
if|if
condition|(
operator|!
name|insecure_is_ok
condition|)
block|{
name|error
label|:
name|ldns_rr_list_deep_free
argument_list|(
operator|*
name|rrs
argument_list|)
expr_stmt|;
operator|*
name|rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|keys
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rrsigs
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|rrsigs
argument_list|)
expr_stmt|;
block|}
name|ldns_pkt_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|ldns_rr_list
modifier|*
name|dane_lookup_addresses
parameter_list|(
name|ldns_resolver
modifier|*
name|res
parameter_list|,
name|ldns_rdf
modifier|*
name|dname
parameter_list|,
name|int
name|ai_family
parameter_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|ldns_rr_list
modifier|*
name|as
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|aaas
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|r
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_new"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ai_family
operator|==
name|AF_UNSPEC
operator|||
name|ai_family
operator|==
name|AF_INET
condition|)
block|{
name|s
operator|=
name|dane_query
argument_list|(
operator|&
name|as
argument_list|,
name|res
argument_list|,
name|dname
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_INSECURE
operator|&&
name|ldns_rr_list_rr_count
argument_list|(
name|as
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Insecure IPv4 addresses. "
literal|"Continuing with them...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_BOGUS
operator|||
name|LDNS_STATUS_CRYPTO_BOGUS
operator|==
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Bogus IPv4 addresses. "
literal|"Discarding...\n"
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|as
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"dane_query"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr_list
argument_list|(
name|r
argument_list|,
name|as
argument_list|)
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_push_rr_list"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ai_family
operator|==
name|AF_UNSPEC
operator|||
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
name|s
operator|=
name|dane_query
argument_list|(
operator|&
name|aaas
argument_list|,
name|res
argument_list|,
name|dname
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_INSECURE
operator|&&
name|ldns_rr_list_rr_count
argument_list|(
name|aaas
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Insecure IPv6 addresses. "
literal|"Continuing with them...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_BOGUS
operator|||
name|LDNS_STATUS_CRYPTO_BOGUS
operator|==
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Bogus IPv6 addresses. "
literal|"Discarding...\n"
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|aaas
argument_list|)
expr_stmt|;
name|aaas
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"dane_query"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr_list
argument_list|(
name|r
argument_list|,
name|aaas
argument_list|)
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_push_rr_list"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|ldns_status
name|dane_read_tlsas_from_file
parameter_list|(
name|ldns_rr_list
modifier|*
modifier|*
name|tlsas
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|ldns_rdf
modifier|*
name|origin
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_origin
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|my_prev
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|origin_lc
init|=
name|NULL
decl_stmt|;
name|int
name|line_nr
decl_stmt|;
name|ldns_status
name|s
init|=
name|LDNS_STATUS_MEM_ERR
decl_stmt|;
name|assert
argument_list|(
name|tlsas
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|origin
condition|)
block|{
name|my_origin
operator|=
name|ldns_rdf_clone
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|my_origin
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|my_prev
operator|=
name|ldns_rdf_clone
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|my_prev
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|origin_lc
operator|=
name|ldns_rdf_clone
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin_lc
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|ldns_dname2canonical
argument_list|(
name|origin_lc
argument_list|)
expr_stmt|;
block|}
operator|*
name|tlsas
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tlsas
condition|)
block|{
goto|goto
name|error
goto|;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|s
operator|=
name|ldns_rr_new_frm_fp_l
argument_list|(
operator|&
name|rr
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
operator|&
name|my_origin
argument_list|,
operator|&
name|my_prev
argument_list|,
operator|&
name|line_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_TLSA
condition|)
block|{
name|ldns_dname2canonical
argument_list|(
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
operator|||
name|ldns_dname_compare
argument_list|(
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|,
name|origin_lc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ldns_rr_list_push_rr
argument_list|(
operator|*
name|tlsas
argument_list|,
name|rr
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|s
operator|=
name|LDNS_STATUS_MEM_ERR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
name|ldns_rr_free
argument_list|(
name|rr
argument_list|)
expr_stmt|;
block|}
name|ldns_rdf_deep_free
argument_list|(
name|origin_lc
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|my_prev
argument_list|)
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|my_origin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
name|error
label|:
if|if
condition|(
operator|*
name|tlsas
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
operator|*
name|tlsas
argument_list|)
expr_stmt|;
operator|*
name|tlsas
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|origin_lc
condition|)
block|{
name|ldns_rdf_deep_free
argument_list|(
name|origin_lc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|my_prev
condition|)
block|{
name|ldns_rdf_deep_free
argument_list|(
name|my_prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|my_origin
condition|)
block|{
name|ldns_rdf_deep_free
argument_list|(
name|my_origin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|&&
name|fp
operator|!=
name|stdin
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|bool
name|dane_wildcard_label_cmp
parameter_list|(
name|uint8_t
name|iw
parameter_list|,
specifier|const
name|char
modifier|*
name|w
parameter_list|,
name|uint8_t
name|il
parameter_list|,
specifier|const
name|char
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
name|iw
operator|==
literal|0
condition|)
block|{
comment|/* End of match label */
if|if
condition|(
name|il
operator|==
literal|0
condition|)
block|{
comment|/* And end in the to be matched label */
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
do|do
block|{
if|if
condition|(
operator|*
name|w
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|iw
operator|==
literal|1
condition|)
block|{
comment|/* '*' is the last match char, 					  remainder matches wildcard */
return|return
name|true
return|;
block|}
while|while
condition|(
name|il
operator|>
literal|0
condition|)
block|{
comment|/* more to match? */
if|if
condition|(
name|w
index|[
literal|1
index|]
operator|==
operator|*
name|l
condition|)
block|{
comment|/* Char after '*' matches. 						   * Recursion for backtracking 						   */
if|if
condition|(
name|dane_wildcard_label_cmp
argument_list|(
name|iw
operator|-
literal|1
argument_list|,
name|w
operator|+
literal|1
argument_list|,
name|il
argument_list|,
name|l
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
name|l
operator|+=
literal|1
expr_stmt|;
name|il
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Skip up till next wildcard (if possible) */
while|while
condition|(
name|il
operator|>
literal|0
operator|&&
name|iw
operator|>
literal|0
operator|&&
operator|*
name|w
operator|!=
literal|'*'
operator|&&
operator|*
name|w
operator|==
operator|*
name|l
condition|)
block|{
name|w
operator|+=
literal|1
expr_stmt|;
name|l
operator|+=
literal|1
expr_stmt|;
name|il
operator|-=
literal|1
expr_stmt|;
name|iw
operator|-=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|iw
operator|>
literal|0
operator|&&
operator|*
name|w
operator|==
literal|'*'
operator|&&
comment|/* More to match a next wildcard? */
operator|(
name|il
operator|>
literal|0
operator|||
name|iw
operator|==
literal|1
operator|)
condition|)
do|;
return|return
name|iw
operator|==
literal|0
operator|&&
name|il
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|bool
name|dane_label_matches_label
parameter_list|(
name|ldns_rdf
modifier|*
name|w
parameter_list|,
name|ldns_rdf
modifier|*
name|l
parameter_list|)
block|{
name|uint8_t
name|iw
decl_stmt|;
name|uint8_t
name|il
decl_stmt|;
name|iw
operator|=
name|ldns_rdf_data
argument_list|(
name|w
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|il
operator|=
name|ldns_rdf_data
argument_list|(
name|l
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
return|return
name|dane_wildcard_label_cmp
argument_list|(
name|iw
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ldns_rdf_data
argument_list|(
name|w
argument_list|)
operator|+
literal|1
argument_list|,
name|il
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ldns_rdf_data
argument_list|(
name|l
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|dane_name_matches_server_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name_str
parameter_list|,
name|ldns_rdf
modifier|*
name|server_name
parameter_list|)
block|{
name|ldns_rdf
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|nn
decl_stmt|,
name|ns
decl_stmt|,
name|i
decl_stmt|;
name|ldns_rdf
modifier|*
name|ln
decl_stmt|;
name|ldns_rdf
modifier|*
name|ls
decl_stmt|;
name|name
operator|=
name|ldns_dname_new_frm_str
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|LDNS_ERR
argument_list|(
name|LDNS_STATUS_ERR
argument_list|,
literal|"ldns_dname_new_frm_str"
argument_list|)
expr_stmt|;
block|}
name|nn
operator|=
name|ldns_dname_label_count
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ns
operator|=
name|ldns_dname_label_count
argument_list|(
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|!=
name|ns
condition|)
block|{
name|ldns_rdf_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ldns_dname2canonical
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
control|)
block|{
name|ln
operator|=
name|ldns_dname_label
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ln
condition|)
block|{
return|return
name|false
return|;
block|}
name|ls
operator|=
name|ldns_dname_label
argument_list|(
name|server_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
block|{
name|ldns_rdf_free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|dane_label_matches_label
argument_list|(
name|ln
argument_list|,
name|ls
argument_list|)
condition|)
block|{
name|ldns_rdf_free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ldns_rdf_free
argument_list|(
name|ls
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ldns_rdf_free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|ldns_rdf_free
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|dane_X509_any_subject_alt_name_matches_server_name
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|,
name|ldns_rdf
modifier|*
name|server_name
parameter_list|)
block|{
name|GENERAL_NAMES
modifier|*
name|names
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
modifier|*
name|subject_alt_name_str
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|names
operator|=
name|X509_get_ext_d2i
argument_list|(
name|cert
argument_list|,
name|NID_subject_alt_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|names
condition|)
block|{
comment|/* No subjectAltName extension */
return|return
name|false
return|;
block|}
name|n
operator|=
name|sk_GENERAL_NAME_num
argument_list|(
name|names
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|sk_GENERAL_NAME_value
argument_list|(
name|names
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|type
operator|==
name|GEN_DNS
condition|)
block|{
operator|(
name|void
operator|)
name|ASN1_STRING_to_UTF8
argument_list|(
operator|&
name|subject_alt_name_str
argument_list|,
name|name
operator|->
name|d
operator|.
name|dNSName
argument_list|)
expr_stmt|;
if|if
condition|(
name|subject_alt_name_str
condition|)
block|{
if|if
condition|(
name|dane_name_matches_server_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subject_alt_name_str
argument_list|,
name|server_name
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|subject_alt_name_str
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|OPENSSL_free
argument_list|(
name|subject_alt_name_str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* sk_GENERAL_NAMES_pop_free(names, sk_GENERAL_NAME_free); */
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|dane_X509_subject_name_matches_server_name
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|,
name|ldns_rdf
modifier|*
name|server_name
parameter_list|)
block|{
name|X509_NAME
modifier|*
name|subject_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|X509_NAME_ENTRY
modifier|*
name|entry
decl_stmt|;
name|ASN1_STRING
modifier|*
name|entry_data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|subject_name_str
init|=
name|NULL
decl_stmt|;
name|bool
name|r
decl_stmt|;
name|subject_name
operator|=
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subject_name
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not X509_get_subject_name"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|subject_name
argument_list|,
name|NID_commonName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|=
name|X509_NAME_get_entry
argument_list|(
name|subject_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|entry_data
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|entry
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASN1_STRING_to_UTF8
argument_list|(
operator|&
name|subject_name_str
argument_list|,
name|entry_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|subject_name_str
condition|)
block|{
name|r
operator|=
name|dane_name_matches_server_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subject_name_str
argument_list|,
name|server_name
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|subject_name_str
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
name|bool
name|dane_verify_server_name
parameter_list|(
name|X509
modifier|*
name|cert
parameter_list|,
name|ldns_rdf
modifier|*
name|server_name
parameter_list|)
block|{
name|ldns_rdf
modifier|*
name|server_name_lc
decl_stmt|;
name|bool
name|r
decl_stmt|;
name|server_name_lc
operator|=
name|ldns_rdf_clone
argument_list|(
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|server_name_lc
condition|)
block|{
name|LDNS_ERR
argument_list|(
name|LDNS_STATUS_MEM_ERR
argument_list|,
literal|"ldns_rdf_clone"
argument_list|)
expr_stmt|;
block|}
name|ldns_dname2canonical
argument_list|(
name|server_name_lc
argument_list|)
expr_stmt|;
name|r
operator|=
name|dane_X509_any_subject_alt_name_matches_server_name
argument_list|(
name|cert
argument_list|,
name|server_name_lc
argument_list|)
operator|||
name|dane_X509_subject_name_matches_server_name
argument_list|(
name|cert
argument_list|,
name|server_name_lc
argument_list|)
expr_stmt|;
name|ldns_rdf_free
argument_list|(
name|server_name_lc
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_decl_stmt
name|void
name|dane_create
argument_list|(
name|ldns_rr_list
operator|*
name|tlsas
argument_list|,
name|ldns_rdf
operator|*
name|tlsa_owner
argument_list|,
name|ldns_tlsa_certificate_usage
name|certificate_usage
argument_list|,
name|int
name|offset
argument_list|,
name|ldns_tlsa_selector
name|selector
argument_list|,
name|ldns_tlsa_matching_type
name|matching_type
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|validate_store
argument_list|,
name|bool
name|verify_server_name
argument_list|,
name|ldns_rdf
operator|*
name|name
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|X509
modifier|*
name|selected_cert
decl_stmt|;
name|ldns_rr
modifier|*
name|tlsa_rr
decl_stmt|;
if|if
condition|(
name|verify_server_name
operator|&&
operator|!
name|dane_verify_server_name
argument_list|(
name|cert
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The certificate does not match the "
literal|"server name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|ldns_dane_select_certificate
argument_list|(
operator|&
name|selected_cert
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|validate_store
argument_list|,
name|certificate_usage
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not select certificate"
argument_list|)
expr_stmt|;
name|s
operator|=
name|ldns_dane_create_tlsa_rr
argument_list|(
operator|&
name|tlsa_rr
argument_list|,
name|certificate_usage
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|selected_cert
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not create tlsa rr"
argument_list|)
expr_stmt|;
name|ldns_rr_set_owner
argument_list|(
name|tlsa_rr
argument_list|,
name|tlsa_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ldns_rr_list_contains_rr
argument_list|(
name|tlsas
argument_list|,
name|tlsa_rr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|tlsas
argument_list|,
name|tlsa_rr
argument_list|)
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_push_rr"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|dane_verify
argument_list|(
name|ldns_rr_list
operator|*
name|tlsas
argument_list|,
name|ldns_rdf
operator|*
name|address
argument_list|,
name|X509
operator|*
name|cert
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
argument_list|,
name|X509_STORE
operator|*
name|validate_store
argument_list|,
name|bool
name|verify_server_name
argument_list|,
name|ldns_rdf
operator|*
name|name
argument_list|,
name|bool
name|assume_pkix_validity
argument_list|)
block|{
name|ldns_status
name|s
decl_stmt|;
name|char
modifier|*
name|address_str
init|=
name|NULL
decl_stmt|;
name|s
operator|=
name|ldns_dane_verify
argument_list|(
name|tlsas
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|validate_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
condition|)
block|{
name|address_str
operator|=
name|ldns_rdf2str
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|address_str
condition|?
name|address_str
else|:
literal|"<address>"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|address_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|X509_NAME_print_ex_fp
argument_list|(
name|stdout
argument_list|,
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
if|if
condition|(
name|verify_server_name
operator|&&
operator|!
name|dane_verify_server_name
argument_list|(
name|cert
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" did not dane-validate, because:"
literal|" the certificate name did not match"
literal|" the server name\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" dane-validated successfully\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|assume_pkix_validity
operator|&&
name|s
operator|==
name|LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" dane-validated successfully,"
literal|" because PKIX is assumed valid\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" did not dane-validate, because: %s\n"
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
enum|enum
block|{
name|UNDETERMINED
block|,
name|VERIFY
block|,
name|CREATE
block|}
name|mode
init|=
name|UNDETERMINED
enum|;
name|ldns_status
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|bool
name|print_tlsa_as_type52
init|=
name|false
decl_stmt|;
name|bool
name|assume_dnssec_validity
init|=
name|false
decl_stmt|;
name|bool
name|assume_pkix_validity
init|=
name|false
decl_stmt|;
name|bool
name|verify_server_name
init|=
name|true
decl_stmt|;
name|bool
name|interact
init|=
name|false
decl_stmt|;
if|#
directive|if
name|HAVE_DANE_CA_FILE
specifier|const
name|char
modifier|*
name|CAfile
init|=
name|LDNS_DANE_CA_FILE
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|CAfile
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_DANE_CA_PATH
specifier|const
name|char
modifier|*
name|CApath
init|=
name|LDNS_DANE_CA_PATH
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|CApath
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|cert_file
init|=
name|NULL
decl_stmt|;
name|X509
modifier|*
name|cert
init|=
name|NULL
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|extra_certs
operator|=
name|NULL
expr_stmt|;
name|ldns_rr_list
modifier|*
name|keys
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
name|size_t
name|nkeys
init|=
literal|0
decl_stmt|;
name|bool
name|do_sigchase
init|=
name|false
decl_stmt|;
name|ldns_rr_list
modifier|*
name|addresses
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
name|ldns_rr
modifier|*
name|address_rr
decl_stmt|;
name|ldns_rdf
modifier|*
name|address
decl_stmt|;
name|int
name|ai_family
init|=
name|AF_UNSPEC
decl_stmt|;
name|int
name|transport
init|=
name|LDNS_DANE_TRANSPORT_TCP
decl_stmt|;
name|char
modifier|*
name|name_str
init|=
name|NULL
decl_stmt|;
comment|/* supress uninitialized warning */
name|ldns_rdf
modifier|*
name|name
decl_stmt|;
name|uint16_t
name|port
init|=
literal|0
decl_stmt|;
comment|/* supress uninitialized warning */
name|ldns_resolver
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|tlsa_owner
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tlsa_owner_str
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|tlsas
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tlsas_file
init|=
name|NULL
decl_stmt|;
comment|/* For extracting service port and transport from tla_owner. */
name|ldns_rdf
modifier|*
name|port_rdf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|port_str
init|=
name|NULL
decl_stmt|;
name|ldns_rdf
modifier|*
name|transport_rdf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|transport_str
init|=
name|NULL
decl_stmt|;
name|ldns_rr_list
modifier|*
name|originals
init|=
name|NULL
decl_stmt|;
comment|/* original tlsas (before 					       * transform), but also used 					       * as temporary. 					       */
name|ldns_tlsa_certificate_usage
name|certificate_usage
init|=
literal|666
decl_stmt|;
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|ldns_tlsa_selector
name|selector
init|=
literal|666
decl_stmt|;
name|ldns_tlsa_matching_type
name|matching_type
init|=
literal|666
decl_stmt|;
name|X509_STORE
modifier|*
name|store
init|=
name|NULL
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|SSL
modifier|*
name|ssl
init|=
name|NULL
decl_stmt|;
name|int
name|no_tlsas_exit_status
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|int
name|exit_success
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|keys
operator|||
operator|!
name|addresses
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_new"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46a:bc:df:hik:no:p:sSt:TuvV:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'h'
case|:
name|print_usage
argument_list|(
literal|"ldns-dane"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|s
operator|=
name|ldns_str2rdf_a
argument_list|(
operator|&
name|address
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|address_rr
operator|=
name|ldns_rr_new_frm_type
argument_list|(
name|LDNS_RR_TYPE_A
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|ldns_str2rdf_aaaa
argument_list|(
operator|&
name|address
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
name|address_rr
operator|=
name|ldns_rr_new_frm_type
argument_list|(
name|LDNS_RR_TYPE_AAAA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not interpret address "
literal|"%s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|ldns_rr_a_set_address
argument_list|(
name|address_rr
argument_list|,
name|address
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rdf_compare
argument_list|(
name|address
argument_list|,
name|ldns_rr_a_address
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|addresses
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|addresses
argument_list|,
name|address_rr
argument_list|)
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rr_list_push_rr"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'b'
case|:
name|print_tlsa_as_type52
operator|=
name|true
expr_stmt|;
comment|/* TODO: do it with output formats... maybe... */
break|break;
case|case
literal|'c'
case|:
name|cert_file
operator|=
name|optarg
expr_stmt|;
comment|/* checking in SSL stuff below */
break|break;
case|case
literal|'d'
case|:
name|assume_dnssec_validity
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|CAfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interact
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|s
operator|=
name|read_key_file
argument_list|(
name|optarg
argument_list|,
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_FILE_ERR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error opening %s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"Could not parse key file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
operator|==
name|nkeys
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No keys found in file"
literal|" %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|nkeys
operator|=
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|verify_server_name
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|offset
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/* todo check if all numeric */
break|break;
case|case
literal|'p'
case|:
name|CApath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|assume_pkix_validity
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_sigchase
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tlsas_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|no_tlsas_exit_status
operator|=
name|NO_TLSAS_EXIT_STATUS
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|transport
operator|=
name|LDNS_DANE_TRANSPORT_UDP
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"ldns-dane version %s (ldns version %s)\n"
argument_list|,
name|LDNS_VERSION
argument_list|,
name|ldns_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
comment|/*		case 'V': 			verbosity = atoi(optarg); 			break;  */
block|}
block|}
comment|/* Filter out given IPv4 addresses when -6 was given,  	 * and IPv6 addresses when -4 was given. 	 */
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
operator|>
literal|0
operator|&&
name|ai_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
name|originals
operator|=
name|addresses
expr_stmt|;
name|addresses
operator|=
name|rr_list_filter_rr_type
argument_list|(
name|originals
argument_list|,
operator|(
name|ai_family
operator|==
name|AF_INET
condition|?
name|LDNS_RR_TYPE_A
else|:
name|LDNS_RR_TYPE_AAAA
operator|)
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|originals
argument_list|)
expr_stmt|;
if|if
condition|(
name|addresses
operator|==
name|NULL
condition|)
block|{
name|MEMERR
argument_list|(
literal|"rr_list_filter_rr_type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No addresses of the specified type remain\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_sigchase
condition|)
block|{
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|read_key_file
argument_list|(
name|LDNS_TRUST_ANCHOR_FILE
argument_list|,
name|keys
argument_list|)
expr_stmt|;
name|nkeys
operator|=
name|ldns_rr_list_rr_count
argument_list|(
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to chase "
literal|"signature without keys.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|keys
operator|=
name|NULL
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|print_usage
argument_list|(
literal|"ldns-dane"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"create"
argument_list|,
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|CREATE
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"verify"
argument_list|,
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|VERIFY
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify create or verify mode\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VERIFY
operator|&&
name|argc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tlsas_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR! Nothing given to verify\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|dane_read_tlsas_from_file
argument_list|(
operator|&
name|tlsas
argument_list|,
name|tlsas_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not read tlsas from file"
argument_list|)
expr_stmt|;
comment|/* extract port, transport and hostname from TLSA owner name */
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR! No TLSA records to extract "
literal|"service port, transport and hostname"
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|tlsa_owner
operator|=
name|ldns_rr_list_owner
argument_list|(
name|tlsas
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_dname_label_count
argument_list|(
name|tlsa_owner
argument_list|)
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR! To few labels in TLSA owner\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|s
operator|=
name|LDNS_STATUS_MEM_ERR
expr_stmt|;
name|port_rdf
operator|=
name|ldns_dname_label
argument_list|(
name|tlsa_owner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_rdf
condition|)
block|{
break|break;
block|}
name|port_str
operator|=
name|ldns_rdf2str
argument_list|(
name|port_rdf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_str
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|port_str
operator|!=
literal|'_'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR! Badly formatted "
literal|"service port label in the "
literal|"TLSA owner name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port_str
index|[
name|strlen
argument_list|(
name|port_str
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|port_str
index|[
name|strlen
argument_list|(
name|port_str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
name|port
operator|=
operator|(
name|uint16_t
operator|)
name|dane_int_within_range
argument_list|(
name|port_str
operator|+
literal|1
argument_list|,
literal|65535
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not extract service port from TLSA owner"
argument_list|)
expr_stmt|;
do|do
block|{
name|s
operator|=
name|LDNS_STATUS_MEM_ERR
expr_stmt|;
name|transport_rdf
operator|=
name|ldns_dname_label
argument_list|(
name|tlsa_owner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transport_rdf
condition|)
block|{
break|break;
block|}
name|transport_str
operator|=
name|ldns_rdf2str
argument_list|(
name|transport_rdf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transport_str
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|transport_str
index|[
name|strlen
argument_list|(
name|transport_str
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|transport_str
index|[
name|strlen
argument_list|(
name|transport_str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|transport_str
argument_list|,
literal|"_tcp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|transport
operator|=
name|LDNS_DANE_TRANSPORT_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|transport_str
argument_list|,
literal|"_udp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|transport
operator|=
name|LDNS_DANE_TRANSPORT_UDP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|transport_str
argument_list|,
literal|"_sctp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|transport
operator|=
name|LDNS_DANE_TRANSPORT_SCTP
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR! Badly formatted "
literal|"transport label in the "
literal|"TLSA owner name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|LDNS_STATUS_OK
expr_stmt|;
break|break;
block|}
do|while
condition|(
name|false
condition|)
do|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not extract transport from TLSA owner"
argument_list|)
expr_stmt|;
name|tlsa_owner_str
operator|=
name|ldns_rdf2str
argument_list|(
name|tlsa_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tlsa_owner_str
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rdf2str"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|ldns_dname_clone_from
argument_list|(
name|tlsa_owner
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_dname_clone_from"
argument_list|)
expr_stmt|;
block|}
name|name_str
operator|=
name|ldns_rdf2str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name_str
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rdf2str"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|print_usage
argument_list|(
literal|"ldns-dane"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_str
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|s
operator|=
name|ldns_str2rdf_dname
argument_list|(
operator|&
name|name
argument_list|,
name|name_str
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not ldns_str2rdf_dname"
argument_list|)
expr_stmt|;
name|port
operator|=
operator|(
name|uint16_t
operator|)
name|dane_int_within_range
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|65535
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|s
operator|=
name|ldns_dane_create_tlsa_owner
argument_list|(
operator|&
name|tlsa_owner
argument_list|,
name|name
argument_list|,
name|port
argument_list|,
name|transport
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not create TLSA owner name"
argument_list|)
expr_stmt|;
name|tlsa_owner_str
operator|=
name|ldns_rdf2str
argument_list|(
name|tlsa_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tlsa_owner_str
condition|)
block|{
name|MEMERR
argument_list|(
literal|"ldns_rdf2str"
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VERIFY
case|:
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|print_usage
argument_list|(
literal|"ldns-dane"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlsas_file
condition|)
block|{
name|s
operator|=
name|dane_read_tlsas_from_file
argument_list|(
operator|&
name|tlsas
argument_list|,
name|tlsas_file
argument_list|,
name|tlsa_owner
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not read tlas from file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* lookup tlsas */
name|s
operator|=
name|dane_setup_resolver
argument_list|(
operator|&
name|res
argument_list|,
name|keys
argument_list|,
name|assume_dnssec_validity
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not dane_setup_resolver"
argument_list|)
expr_stmt|;
name|s
operator|=
name|dane_query
argument_list|(
operator|&
name|tlsas
argument_list|,
name|res
argument_list|,
name|tlsa_owner
argument_list|,
name|LDNS_RR_TYPE_TLSA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ldns_resolver_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_DANE_INSECURE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! TLSA records for %s "
literal|"were found, but were insecure.\n"
literal|"PKIX validation without DANE will be "
literal|"performed. If you wish to perform DANE\n"
literal|"even though the RR's are insecure, "
literal|"use the -d option.\n"
argument_list|,
name|tlsa_owner_str
argument_list|)
expr_stmt|;
name|exit_success
operator|=
name|no_tlsas_exit_status
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_err
argument_list|(
literal|"dane_query"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|tlsas
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! No TLSA records for %s "
literal|"were found.\n"
literal|"PKIX validation without DANE will be "
literal|"performed.\n"
argument_list|,
name|ldns_rdf2str
argument_list|(
name|tlsa_owner
argument_list|)
argument_list|)
expr_stmt|;
name|exit_success
operator|=
name|no_tlsas_exit_status
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|assume_pkix_validity
condition|)
block|{
comment|/* number of  tlsa's> 0 */
comment|/* transform type "CA constraint" to "Trust anchor 			 * assertion" and "Service Certificate Constraint" 			 * to "Domain Issues Certificate" 			 */
name|originals
operator|=
name|tlsas
expr_stmt|;
name|tlsas
operator|=
name|dane_no_pkix_transform
argument_list|(
name|originals
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CREATE
case|:
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|certificate_usage
operator|=
name|dane_int_within_range_table
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|3
argument_list|,
literal|"certificate usage"
argument_list|,
name|dane_certificate_usage_table
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|certificate_usage
operator|=
name|LDNS_TLSA_USAGE_DOMAIN_ISSUED_CERTIFICATE
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|selector
operator|=
name|dane_int_within_range_table
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|1
argument_list|,
literal|"selector"
argument_list|,
name|dane_selector_table
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|selector
operator|=
name|LDNS_TLSA_SELECTOR_FULL_CERTIFICATE
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|argv
operator|&&
comment|/* strlen(argv)> 0 */
operator|(
name|strncasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"no-hash-used"
argument_list|,
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"no hash used"
argument_list|,
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|matching_type
operator|=
name|LDNS_TLSA_MATCHING_TYPE_NO_HASH_USED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"sha256"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"sha-256"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|matching_type
operator|=
name|LDNS_TLSA_MATCHING_TYPE_SHA256
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"sha512"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"sha-512"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|matching_type
operator|=
name|LDNS_TLSA_MATCHING_TYPE_SHA512
expr_stmt|;
block|}
else|else
block|{
name|matching_type
operator|=
name|dane_int_within_range
argument_list|(
operator|*
name|argv
argument_list|,
literal|2
argument_list|,
literal|"matching type"
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|matching_type
operator|=
name|LDNS_TLSA_MATCHING_TYPE_SHA256
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|print_usage
argument_list|(
literal|"ldns-dane"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|certificate_usage
operator|==
name|LDNS_TLSA_USAGE_CA_CONSTRAINT
operator|||
name|certificate_usage
operator|==
name|LDNS_TLSA_USAGE_SERVICE_CERTIFICATE_CONSTRAINT
operator|)
operator|&&
operator|!
name|CAfile
operator|&&
operator|!
name|CApath
operator|&&
operator|!
name|assume_pkix_validity
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"When using the \"CA constraint\" or "
literal|"\"Service certificate constraint\",\n"
literal|"-f<CAfile> and/or -p<CApath> options "
literal|"must be given to perform PKIX validation.\n\n"
literal|"PKIX validation may be turned off "
literal|"with the -s option. Note that with\n"
literal|"\"CA constraint\" the verification process "
literal|"should then end with a self-signed\n"
literal|"certificate which must be present "
literal|"in the server certificate chain.\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|tlsas
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unreachable code\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* ssl inititalize */
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
comment|/* ssl load validation store */
if|if
condition|(
operator|!
name|assume_pkix_validity
operator|||
name|CAfile
operator|||
name|CApath
condition|)
block|{
name|store
operator|=
name|X509_STORE_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|store
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not X509_STORE_new"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|CAfile
operator|||
name|CApath
operator|)
operator|&&
name|X509_STORE_load_locations
argument_list|(
name|store
argument_list|,
name|CAfile
argument_list|,
name|CApath
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ssl_err
argument_list|(
literal|"error loading CA certificates"
argument_list|)
expr_stmt|;
block|}
block|}
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_client_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not SSL_CTX_new"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert_file
operator|&&
name|SSL_CTX_use_certificate_chain_file
argument_list|(
name|ctx
argument_list|,
name|cert_file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ssl_err
argument_list|(
literal|"error loading certificate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert_file
condition|)
block|{
comment|/* ssl load certificate */
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not SSL_new"
argument_list|)
expr_stmt|;
block|}
name|cert
operator|=
name|SSL_get_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not SSL_get_certificate"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|extra_certs
operator|=
name|ctx
operator|->
name|extra_certs
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CREATE
case|:
name|dane_create
argument_list|(
name|tlsas
argument_list|,
name|tlsa_owner
argument_list|,
name|certificate_usage
argument_list|,
name|offset
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|store
argument_list|,
name|verify_server_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERIFY
case|:
if|if
condition|(
operator|!
name|dane_verify
argument_list|(
name|tlsas
argument_list|,
name|NULL
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|store
argument_list|,
name|verify_server_name
argument_list|,
name|name
argument_list|,
name|assume_pkix_validity
argument_list|)
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
block|}
break|break;
default|default:
break|break;
comment|/* suppress warning */
block|}
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No certificate file given, creation/validation via TLS. */
comment|/* We need addresses to connect to */
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|dane_setup_resolver
argument_list|(
operator|&
name|res
argument_list|,
name|keys
argument_list|,
name|assume_dnssec_validity
argument_list|)
expr_stmt|;
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not dane_setup_resolver"
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|addresses
argument_list|)
expr_stmt|;
name|addresses
operator|=
name|dane_lookup_addresses
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|ai_family
argument_list|)
expr_stmt|;
name|ldns_resolver_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No addresses for %s\n"
argument_list|,
name|name_str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* for all addresses, setup SSL and retrieve certificates */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|addresses
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl
condition|)
block|{
name|ssl_err
argument_list|(
literal|"could not SSL_new"
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|ldns_rr_a_address
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|addresses
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|address
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ssl_connect_and_get_cert_chain
argument_list|(
operator|&
name|cert
argument_list|,
operator|&
name|extra_certs
argument_list|,
name|ssl
argument_list|,
name|name_str
argument_list|,
name|address
argument_list|,
name|port
argument_list|,
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|LDNS_STATUS_NETWORK_ERR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not connect to "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stderr
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d\n"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
comment|/* All addresses should succeed */
name|success
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|LDNS_ERR
argument_list|(
name|s
argument_list|,
literal|"could not get cert chain from ssl"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CREATE
case|:
name|dane_create
argument_list|(
name|tlsas
argument_list|,
name|tlsa_owner
argument_list|,
name|certificate_usage
argument_list|,
name|offset
argument_list|,
name|selector
argument_list|,
name|matching_type
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|store
argument_list|,
name|verify_server_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERIFY
case|:
if|if
condition|(
operator|!
name|dane_verify
argument_list|(
name|tlsas
argument_list|,
name|address
argument_list|,
name|cert
argument_list|,
name|extra_certs
argument_list|,
name|store
argument_list|,
name|verify_server_name
argument_list|,
name|name
argument_list|,
name|assume_pkix_validity
argument_list|)
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interact
condition|)
block|{
name|ssl_interact
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
comment|/* suppress warning */
block|}
while|while
condition|(
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
comment|/* end for all addresses */
block|}
comment|/* end No certification file */
if|if
condition|(
name|mode
operator|==
name|CREATE
condition|)
block|{
if|if
condition|(
name|print_tlsa_as_type52
condition|)
block|{
name|print_rr_list_as_TYPEXXX
argument_list|(
name|stdout
argument_list|,
name|tlsas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_rr_list_print
argument_list|(
name|stdout
argument_list|,
name|tlsas
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_rr_list_deep_free
argument_list|(
name|tlsas
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
condition|)
block|{
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlsa_owner_str
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|tlsa_owner_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlsa_owner
condition|)
block|{
name|ldns_rdf_free
argument_list|(
name|tlsa_owner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addresses
condition|)
block|{
name|ldns_rr_list_deep_free
argument_list|(
name|addresses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|exit
argument_list|(
name|exit_success
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldns-dane needs OpenSSL support, "
literal|"which has not been compiled in\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_DANE */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dane support was disabled with this build of ldns, "
literal|"and has not been compiled in\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DANE */
end_comment

end_unit

