begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ldns-testns. Light-weight DNS daemon, gives canned replies.  *  * Tiny dns server, that responds with specially crafted replies  * to requests. For testing dns software.  *  * (c) NLnet Labs, 2005 - 2008  * See the file LICENSE for the license  */
end_comment

begin_comment
comment|/*  * This program is a debugging aid. It can is not efficient, especially  * with a long config file, but it can give any reply to any query.  * This can help the developer pre-script replies for queries.  *  * It listens to IP4 UDP and TCP by default.  * You can specify a packet RR by RR with header flags to return.  *  * Missing features:  *		- matching content different from reply content.  *		- find way to adjust mangled packets?  */
end_comment

begin_comment
comment|/* 	The data file format is as follows: 	 	; comment. 	; a number of entries, these are processed first to last. 	; a line based format.  	$ORIGIN origin 	$TTL default_ttl  	ENTRY_BEGIN 	; first give MATCH lines, that say what queries are matched 	; by this entry. 	; 'opcode' makes the query match the opcode from the reply 	; if you leave it out, any opcode matches this entry. 	; 'qtype' makes the query match the qtype from the reply 	; 'qname' makes the query match the qname from the reply 	; 'serial=1023' makes the query match if ixfr serial is 1023.  	MATCH [opcode] [qtype] [qname] [serial=<value>] 	MATCH [UDP|TCP] 	MATCH ... 	; Then the REPLY header is specified. 	REPLY opcode, rcode or flags. 		(opcode)  QUERY IQUERY STATUS NOTIFY UPDATE 		(rcode)   NOERROR FORMERR SERVFAIL NXDOMAIN NOTIMPL YXDOMAIN 		 		YXRRSET NXRRSET NOTAUTH NOTZONE 		(flags)   QR AA TC RD CD RA AD 	REPLY ... 	; any additional actions to do. 	; 'copy_id' copies the ID from the query to the answer. 	ADJUST copy_id 	; 'sleep=10' sleeps for 10 seconds before giving the answer (TCP is open) 	ADJUST [sleep=<num>]    ; sleep before giving any reply 	ADJUST [packet_sleep=<num>]  ; sleep before this packet in sequence 	SECTION QUESTION<RRs, one per line>    ; the RRcount is determined automatically. 	SECTION ANSWER<RRs, one per line> 	SECTION AUTHORITY<RRs, one per line> 	SECTION ADDITIONAL<RRs, one per line> 	EXTRA_PACKET		; follow with SECTION, REPLY for more packets. 	HEX_ANSWER_BEGIN	; follow with hex data 				; this replaces any answer packet constructed 				; with the SECTION keywords (only SECTION QUERY 				; is used to match queries). If the data cannot 				; be parsed, ADJUST rules for the answer packet 				; are ignored 	HEX_ANSWER_END 	ENTRY_END */
end_comment

begin_comment
comment|/* Example data file: $ORIGIN nlnetlabs.nl $TTL 3600  ENTRY_BEGIN MATCH qname REPLY NOERROR ADJUST copy_id SECTION QUESTION www.nlnetlabs.nl.	IN	A SECTION ANSWER www.nlnetlabs.nl.	IN	A	195.169.215.155 SECTION AUTHORITY nlnetlabs.nl.		IN	NS	www.nlnetlabs.nl. ENTRY_END  ENTRY_BEGIN MATCH qname REPLY NOERROR ADJUST copy_id SECTION QUESTION www2.nlnetlabs.nl.	IN	A HEX_ANSWER_BEGIN ; 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 ;-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  00 bf 81 80 00 01 00 01 00 02 00 02 03 77 77 77 0b 6b 61 6e	;	   1-  20  61 72 69 65 70 69 65 74 03 63 6f 6d 00 00 01 00 01 03 77 77	;	  21-  40  77 0b 6b 61 6e 61 72 69 65 70 69 65 74 03 63 6f 6d 00 00 01	;	  41-  60  00 01 00 01 50 8b 00 04 52 5e ed 32 0b 6b 61 6e 61 72 69 65	;	  61-  80  70 69 65 74 03 63 6f 6d 00 00 02 00 01 00 01 50 8b 00 11 03	;	  81- 100  6e 73 31 08 68 65 78 6f 6e 2d 69 73 02 6e 6c 00 0b 6b 61 6e	;	 101- 120  61 72 69 65 70 69 65 74 03 63 6f 6d 00 00 02 00 01 00 01 50	;	 121- 140  8b 00 11 03 6e 73 32 08 68 65 78 6f 6e 2d 69 73 02 6e 6c 00	;	 141- 160  03 6e 73 31 08 68 65 78 6f 6e 2d 69 73 02 6e 6c 00 00 01 00	;	 161- 180  01 00 00 46 53 00 04 52 5e ed 02 03 6e 73 32 08 68 65 78 6f	;	 181- 200  6e 2d 69 73 02 6e 6c 00 00 01 00 01 00 00 46 53 00 04 d4 cc	;	 201- 220  db 5b HEX_ANSWER_END ENTRY_END   */
end_comment

begin_struct_decl
struct_decl|struct
name|sockaddr_storage
struct_decl|;
end_struct_decl

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|"ldns-testpkts.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SELECT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_UDP_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IGMP_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|INBUF_SIZE
value|4096
end_define

begin_comment
comment|/* max size for incoming queries */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PORT
value|53
end_define

begin_comment
comment|/* default if no -p port is specified */
end_comment

begin_define
define|#
directive|define
name|CONN_BACKLOG
value|5
end_define

begin_comment
comment|/* 5 connections queued up for tcp */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prog_name
init|=
literal|"ldns-testns"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [options]<datafile>\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -r	listens on random port. Port number is printed.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -p	listens on the specified port, default %d.\n"
argument_list|,
name|DEFAULT_PORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -f	forks given number extra instances, default none.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -v	more verbose, prints queries, answers and matching.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -6	listen on IP6 any address, instead of IP4 any address.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The program answers queries with canned replies from the datafile.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_msg
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|msg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s error: "
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|msg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|verbose
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|lvl
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_verbose
condition|)
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|msg
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bind_port
parameter_list|(
name|int
name|sock
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|fam
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AF_INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETADDRINFO
argument_list|)
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
name|addr6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|addr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr6
argument_list|)
argument_list|)
expr_stmt|;
name|addr6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|addr6
operator|.
name|sin6_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|port
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_DECL_IN6ADDR_ANY
name|addr6
operator|.
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|addr6
operator|.
name|sin6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr6
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|addr6
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
endif|#
directive|endif
name|addr
operator|.
name|sin_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|port
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
return|return
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|handle_udp_userdata
block|{
name|int
name|udp_sock
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr_him
decl_stmt|;
name|socklen_t
name|hislen
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|send_udp
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|handle_udp_userdata
modifier|*
name|userdata
init|=
operator|(
expr|struct
name|handle_udp_userdata
operator|*
operator|)
name|data
decl_stmt|;
comment|/* udp send reply */
name|ssize_t
name|nb
decl_stmt|;
name|nb
operator|=
name|sendto
argument_list|(
name|userdata
operator|->
name|udp_sock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|userdata
operator|->
name|addr_him
argument_list|,
name|userdata
operator|->
name|hislen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|==
operator|-
literal|1
condition|)
name|log_msg
argument_list|(
literal|"sendto(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|nb
operator|!=
name|len
condition|)
name|log_msg
argument_list|(
literal|"sendto(): only sent %d of %d octets.\n"
argument_list|,
operator|(
name|int
operator|)
name|nb
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_udp
parameter_list|(
name|int
name|udp_sock
parameter_list|,
name|struct
name|entry
modifier|*
name|entries
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|ssize_t
name|nb
decl_stmt|;
name|uint8_t
name|inbuf
index|[
name|INBUF_SIZE
index|]
decl_stmt|;
name|struct
name|handle_udp_userdata
name|userdata
decl_stmt|;
name|userdata
operator|.
name|udp_sock
operator|=
name|udp_sock
expr_stmt|;
name|userdata
operator|.
name|hislen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|userdata
operator|.
name|addr_him
argument_list|)
expr_stmt|;
comment|/* udp recv */
name|nb
operator|=
name|recvfrom
argument_list|(
name|udp_sock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|inbuf
argument_list|,
name|INBUF_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|userdata
operator|.
name|addr_him
argument_list|,
operator|&
name|userdata
operator|.
name|hislen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|<
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_msg
argument_list|(
literal|"recvfrom(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINPROGRESS
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAECONNRESET
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEWOULDBLOCK
condition|)
name|log_msg
argument_list|(
literal|"recvfrom(): %d\n"
argument_list|,
name|WSAGetLastError
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|handle_query
argument_list|(
name|inbuf
argument_list|,
name|nb
argument_list|,
name|entries
argument_list|,
name|count
argument_list|,
name|transport_udp
argument_list|,
name|send_udp
argument_list|,
operator|&
name|userdata
argument_list|,
name|do_verbose
condition|?
name|logfile
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_n_bytes
parameter_list|(
name|int
name|sock
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|sz
condition|)
block|{
name|ssize_t
name|nb
init|=
name|recv
argument_list|(
name|sock
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|count
operator|)
argument_list|,
name|sz
operator|-
name|count
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nb
operator|<
literal|0
condition|)
block|{
name|log_msg
argument_list|(
literal|"recv(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|+=
name|nb
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_n_bytes
parameter_list|(
name|int
name|sock
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|sz
condition|)
block|{
name|ssize_t
name|nb
init|=
name|send
argument_list|(
name|sock
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|count
operator|)
argument_list|,
name|sz
operator|-
name|count
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nb
operator|<
literal|0
condition|)
block|{
name|log_msg
argument_list|(
literal|"send(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|+=
name|nb
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|handle_tcp_userdata
block|{
name|int
name|s
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|send_tcp
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|handle_tcp_userdata
modifier|*
name|userdata
init|=
operator|(
expr|struct
name|handle_tcp_userdata
operator|*
operator|)
name|data
decl_stmt|;
name|uint16_t
name|tcplen
decl_stmt|;
comment|/* tcp send reply */
name|tcplen
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|write_n_bytes
argument_list|(
name|userdata
operator|->
name|s
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tcplen
argument_list|,
sizeof|sizeof
argument_list|(
name|tcplen
argument_list|)
argument_list|)
expr_stmt|;
name|write_n_bytes
argument_list|(
name|userdata
operator|->
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_tcp
parameter_list|(
name|int
name|tcp_sock
parameter_list|,
name|struct
name|entry
modifier|*
name|entries
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr_him
decl_stmt|;
name|socklen_t
name|hislen
decl_stmt|;
name|uint8_t
name|inbuf
index|[
name|INBUF_SIZE
index|]
decl_stmt|;
name|uint16_t
name|tcplen
decl_stmt|;
name|struct
name|handle_tcp_userdata
name|userdata
decl_stmt|;
comment|/* accept */
name|hislen
operator|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|addr_him
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|accept
argument_list|(
name|tcp_sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr_him
argument_list|,
operator|&
name|hislen
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_msg
argument_list|(
literal|"accept(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|userdata
operator|.
name|s
operator|=
name|s
expr_stmt|;
comment|/* tcp recv */
name|read_n_bytes
argument_list|(
name|s
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tcplen
argument_list|,
sizeof|sizeof
argument_list|(
name|tcplen
argument_list|)
argument_list|)
expr_stmt|;
name|tcplen
operator|=
name|ntohs
argument_list|(
name|tcplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcplen
operator|>=
name|INBUF_SIZE
condition|)
block|{
name|log_msg
argument_list|(
literal|"query %d bytes too large, buffer %d bytes.\n"
argument_list|,
name|tcplen
argument_list|,
name|INBUF_SIZE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|read_n_bytes
argument_list|(
name|s
argument_list|,
name|inbuf
argument_list|,
name|tcplen
argument_list|)
expr_stmt|;
name|handle_query
argument_list|(
name|inbuf
argument_list|,
operator|(
name|ssize_t
operator|)
name|tcplen
argument_list|,
name|entries
argument_list|,
name|count
argument_list|,
name|transport_tcp
argument_list|,
name|send_tcp
argument_list|,
operator|&
name|userdata
argument_list|,
name|do_verbose
condition|?
name|logfile
else|:
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** shared by the service and main routine (forked and threaded) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|udp_sock
decl_stmt|,
name|tcp_sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|entry
modifier|*
name|entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   * Test DNS server service, uses global udpsock, tcpsock, reply entries   * The signature is kept void so the function can be used as a thread function.  */
end_comment

begin_function
specifier|static
name|void
name|service
parameter_list|(
name|void
parameter_list|)
block|{
name|fd_set
name|rset
decl_stmt|,
name|wset
decl_stmt|,
name|eset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
comment|/* service */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|FD_ZERO
argument_list|(
operator|&
name|rset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|eset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|udp_sock
argument_list|,
operator|&
name|rset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tcp_sock
argument_list|,
operator|&
name|rset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxfd
operator|=
name|udp_sock
expr_stmt|;
if|if
condition|(
name|tcp_sock
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|tcp_sock
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|rset
argument_list|,
operator|&
name|wset
argument_list|,
operator|&
name|eset
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"select(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|udp_sock
argument_list|,
operator|&
name|rset
argument_list|)
condition|)
block|{
name|handle_udp
argument_list|(
name|udp_sock
argument_list|,
name|entries
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tcp_sock
argument_list|,
operator|&
name|rset
argument_list|)
condition|)
block|{
name|handle_tcp
argument_list|(
name|tcp_sock
argument_list|,
name|entries
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|forkit
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number
condition|;
name|i
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|HAVE_FORK
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_msg
argument_list|(
literal|"fork() not available.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
name|DWORD
name|tid
decl_stmt|;
name|HANDLE
name|id
init|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|service
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|log_msg
argument_list|(
literal|"error CreateThread: %d\n"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_msg
argument_list|(
literal|"thread id: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WINSOCK */
else|#
directive|else
comment|/* HAVE_FORK */
name|pid_t
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|log_msg
argument_list|(
literal|"error forking: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
return|return;
comment|/* child starts serving */
name|log_msg
argument_list|(
literal|"forked pid: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FORK */
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* arguments */
name|int
name|c
decl_stmt|;
name|int
name|port
init|=
name|DEFAULT_PORT
decl_stmt|;
specifier|const
name|char
modifier|*
name|datafile
decl_stmt|;
name|int
name|forknum
init|=
literal|0
decl_stmt|;
comment|/* network */
name|int
name|fam
init|=
name|AF_INET
decl_stmt|;
name|bool
name|random_port_success
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSADATA
name|wsa_data
decl_stmt|;
endif|#
directive|endif
comment|/* parse arguments */
name|srandom
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|stdout
expr_stmt|;
name|prog_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|log_msg
argument_list|(
literal|"%s: start\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"6f:p:rv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'6'
case|:
ifdef|#
directive|ifdef
name|AF_INET6
name|fam
operator|=
name|AF_INET6
expr_stmt|;
else|#
directive|else
name|log_msg
argument_list|(
literal|"cannot -6: no IP6 available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
name|port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forknum
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|forknum
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"invalid forkno %s, give number"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Invalid port %s, use a number."
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|do_verbose
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|argc
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|datafile
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|log_msg
argument_list|(
literal|"Reading datafile %s\n"
argument_list|,
name|datafile
argument_list|)
expr_stmt|;
name|entries
operator|=
name|read_datafile
argument_list|(
name|datafile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"WSAStartup failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|udp_sock
operator|=
name|socket
argument_list|(
name|fam
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"udp socket(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tcp_sock
operator|=
name|socket
argument_list|(
name|fam
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"tcp socket(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|tcp_sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|c
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"setsockopt(SO_REUSEADDR): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* bind ip4 */
if|if
condition|(
name|port
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bind_port
argument_list|(
name|udp_sock
argument_list|,
name|port
argument_list|,
name|fam
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot bind(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind_port
argument_list|(
name|tcp_sock
argument_list|,
name|port
argument_list|,
name|fam
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot bind(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|tcp_sock
argument_list|,
name|CONN_BACKLOG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|random_port_success
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|random_port_success
condition|)
block|{
name|port
operator|=
operator|(
name|random
argument_list|()
operator|%
literal|64510
operator|)
operator|+
literal|1025
expr_stmt|;
name|log_msg
argument_list|(
literal|"trying to bind to port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|random_port_success
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|bind_port
argument_list|(
name|udp_sock
argument_list|,
name|port
argument_list|,
name|fam
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EADDRINUSE
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
condition|)
block|{
elif|#
directive|elif
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEADDRINUSE
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|perror
argument_list|(
literal|"bind()"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|random_port_success
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|random_port_success
condition|)
block|{
if|if
condition|(
name|bind_port
argument_list|(
name|tcp_sock
argument_list|,
name|port
argument_list|,
name|fam
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EADDRINUSE
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
condition|)
block|{
elif|#
directive|elif
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEADDRINUSE
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|perror
argument_list|(
literal|"bind()"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|random_port_success
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|random_port_success
condition|)
block|{
if|if
condition|(
name|listen
argument_list|(
name|tcp_sock
argument_list|,
name|CONN_BACKLOG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"listen(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|log_msg
argument_list|(
literal|"Listening on port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* forky! */
if|if
condition|(
name|forknum
operator|>
literal|0
condition|)
name|forkit
argument_list|(
name|forknum
argument_list|)
expr_stmt|;
name|service
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

