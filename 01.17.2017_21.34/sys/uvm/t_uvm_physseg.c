begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: t_uvm_physseg.c,v 1.2 2016/12/22 08:15:20 cherry Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015, 2016 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Santhosh N. Raju<santhosh.raju@gmail.com> and  * by Cherry G. Mathew  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: t_uvm_physseg.c,v 1.2 2016/12/22 08:15:20 cherry Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If this line is commented out tests related to uvm_physseg_get_pmseg()  * wont run.  *  * Have a look at machine/uvm_physseg.h for more details.  */
end_comment

begin_define
define|#
directive|define
name|__HAVE_PMAP_PHYSSEG
end_define

begin_comment
comment|/*  * This is a dummy struct used for testing purposes  *  * In reality this struct would exist in the MD part of the code residing in  * machines/vmparam.h  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_PMAP_PHYSSEG
end_ifdef

begin_struct
struct|struct
name|pmap_physseg
block|{
name|int
name|dummy_variable
decl_stmt|;
comment|/* Dummy variable use for testing */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Testing API - assumes userland */
end_comment

begin_comment
comment|/* Provide Kernel API equivalents */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset(3) et. al */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* printf(3) */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc(3) */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_define
define|#
directive|define
name|PRIxPADDR
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIxPSIZE
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIuPSIZE
value|"lu"
end_define

begin_define
define|#
directive|define
name|PRIxVADDR
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIxVSIZE
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIuVSIZE
value|"lu"
end_define

begin_define
define|#
directive|define
name|UVM_HOTPLUG
end_define

begin_comment
comment|/* Enable hotplug with rbtree. */
end_comment

begin_define
define|#
directive|define
name|PMAP_STEAL_MEMORY
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_comment
comment|/* Enable debug functionality. */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|vaddr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|paddr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|psize_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|vsize_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<uvm/uvm_physseg.h>
end_include

begin_include
include|#
directive|include
file|<uvm/uvm_page.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DIAGNOSTIC
end_ifndef

begin_define
define|#
directive|define
name|KASSERTMSG
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* NOTHING */
end_comment

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|e
parameter_list|)
end_define

begin_comment
comment|/* NOTHING */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|a
parameter_list|)
value|assert(a)
end_define

begin_define
define|#
directive|define
name|KASSERTMSG
parameter_list|(
name|exp
parameter_list|,
modifier|...
parameter_list|)
value|printf(__VA_ARGS__); assert((exp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VM_PHYSSEG_STRAT
value|VM_PSTRAT_BSEARCH
end_define

begin_define
define|#
directive|define
name|VM_NFREELIST
value|4
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST16
value|3
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST1G
value|2
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST4G
value|1
end_define

begin_comment
comment|/*  * Used in tests when Array implementation is tested  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|VM_PHYSSEG_MAX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAGE_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|PAGE_SIZE
value|(1<< PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|PAGE_MASK
value|(PAGE_SIZE - 1)
end_define

begin_define
define|#
directive|define
name|atop
parameter_list|(
name|x
parameter_list|)
value|(((paddr_t)(x))>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|ptoa
parameter_list|(
name|x
parameter_list|)
value|(((paddr_t)(x))<< PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|mutex_enter
parameter_list|(
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|mutex_exit
parameter_list|(
name|l
parameter_list|)
end_define

begin_decl_stmt
name|psize_t
name|physmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uvmexp
name|uvmexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* decl */
end_comment

begin_comment
comment|/*  * uvm structure borrowed from uvm.h  *  * Remember this is a dummy structure used within the ATF Tests and  * uses only necessary fields from the original uvm struct.  * See uvm/uvm.h for the full struct.  */
end_comment

begin_struct
struct|struct
name|uvm
block|{
comment|/* vm_page related parameters */
name|bool
name|page_init_done
decl_stmt|;
comment|/* TRUE if uvm_page_init() finished */
block|}
name|uvm
struct|;
end_struct

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_function
name|void
modifier|*
name|kmem_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|km_flag_t
name|flags
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|kmem_zalloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|km_flag_t
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|kmem_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|uvm_pagefree
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|)
block|{
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|uvmpdpol_reinit
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UVM_HOTPLUG */
end_comment

begin_comment
comment|/* end - Provide Kernel API equivalents */
end_comment

begin_include
include|#
directive|include
file|"uvm/uvm_physseg.c"
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_define
define|#
directive|define
name|SIXTYFOUR_KILO
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|ONETWENTYEIGHT_KILO
value|(128 * 1024)
end_define

begin_define
define|#
directive|define
name|TWOFIFTYSIX_KILO
value|(256 * 1024)
end_define

begin_define
define|#
directive|define
name|FIVEONETWO_KILO
value|(512 * 1024)
end_define

begin_define
define|#
directive|define
name|ONE_MEGABYTE
value|(1024 * 1024)
end_define

begin_define
define|#
directive|define
name|TWO_MEGABYTE
value|(2 * 1024 * 1024)
end_define

begin_comment
comment|/* Sample Page Frame Numbers */
end_comment

begin_define
define|#
directive|define
name|VALID_START_PFN_1
value|atop(0)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_1
value|atop(ONE_MEGABYTE)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_1
value|atop(0)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_1
value|atop(ONE_MEGABYTE)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_2
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_2
value|atop(ONE_MEGABYTE * 2)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_2
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_2
value|atop(ONE_MEGABYTE * 2)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_3
value|atop((ONE_MEGABYTE * 2) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_3
value|atop(ONE_MEGABYTE * 3)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_3
value|atop((ONE_MEGABYTE * 2) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_3
value|atop(ONE_MEGABYTE * 3)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_4
value|atop((ONE_MEGABYTE * 3) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_4
value|atop(ONE_MEGABYTE * 4)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_4
value|atop((ONE_MEGABYTE * 3) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_4
value|atop(ONE_MEGABYTE * 4)
end_define

begin_comment
comment|/*  * Total number of pages (of 4K size each) should be 256 for 1MB of memory.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_COUNT_1M
value|256
end_define

begin_comment
comment|/*  * A debug fucntion to print the content of upm.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|uvm_physseg_dump_seg
parameter_list|(
name|uvm_physseg_t
name|upm
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|printf
argument_list|(
literal|"%s: seg->start == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->end == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->avail_start == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->avail_end == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"====\n\n"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * Private accessor that gets the value of uvm_physseg_graph.nentries  */
end_comment

begin_function
specifier|static
name|int
name|uvm_physseg_get_entries
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
return|return
name|uvm_physseg_graph
operator|.
name|nentries
return|;
else|#
directive|else
return|return
name|vm_nphysmem
return|;
endif|#
directive|endif
comment|/* UVM_HOTPLUG */
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
end_if

begin_function
specifier|static
name|void
modifier|*
name|uvm_physseg_alloc
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
return|return
operator|&
name|vm_physmem
index|[
name|vm_nphysseg
operator|++
index|]
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Test Fixture SetUp().  */
end_comment

begin_function
specifier|static
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Prerequisites for running certain calls in uvm_physseg */
name|uvmexp
operator|.
name|pagesize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|uvmexp
operator|.
name|npages
operator|=
literal|0
expr_stmt|;
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|uvm_physseg_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*<---- Tests for Internal functions ----> */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
end_if

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_alloc_atboot_mismatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_alloc_atboot_mismatch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"boot time uvm_physseg_alloc() sanity"
literal|"size mismatch alloc() test."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_alloc_atboot_mismatch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"size mismatch alloc()"
argument_list|)
expr_stmt|;
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_alloc_atboot_overrun
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_alloc_atboot_overrun
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"boot time uvm_physseg_alloc() sanity"
literal|"array overrun alloc() test."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_alloc_atboot_overrun
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"array overrun alloc()"
argument_list|)
expr_stmt|;
name|uvm_physseg_alloc
argument_list|(
operator|(
name|VM_PHYSSEG_MAX
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_alloc_sanity
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_alloc_sanity
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"further uvm_physseg_alloc() sanity checks"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_alloc_sanity
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* At boot time */
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
comment|/* Correct alloc */
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_alloc
argument_list|(
name|VM_PHYSSEG_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Retry static alloc()s as dynamic - we expect them to pass */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_alloc
argument_list|(
literal|2
operator|*
name|VM_PHYSSEG_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_free_atboot_mismatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_free_atboot_mismatch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"boot time uvm_physseg_free() sanity"
literal|"size mismatch free() test."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_free_atboot_mismatch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"size mismatch free()"
argument_list|)
expr_stmt|;
name|uvm_physseg_free
argument_list|(
operator|&
name|uvm_physseg
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_free_sanity
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_free_sanity
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"further uvm_physseg_free() sanity checks"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_free_sanity
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* At boot time */
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|struct
name|uvm_physseg
modifier|*
name|seg
decl_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* 	 * Note: free()ing the entire array is considered to be an 	 * error. Thus VM_PHYSSEG_MAX - 1. 	 */
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
operator|(
name|VM_PHYSSEG_MAX
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_free
argument_list|(
name|seg
argument_list|,
operator|(
name|VM_PHYSSEG_MAX
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Retry static alloc()s as dynamic - we expect them to pass */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|uvm_physseg_free
argument_list|(
name|seg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
literal|2
operator|*
name|VM_PHYSSEG_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_free
argument_list|(
name|seg
argument_list|,
literal|2
operator|*
name|VM_PHYSSEG_MAX
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
end_if

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_atboot_free_leak
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_atboot_free_leak
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"does free() leak at boot ?\n"
literal|"This test needs VM_PHYSSEG_MAX> 1)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_atboot_free_leak
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* At boot time */
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
comment|/* alloc to array size */
name|struct
name|uvm_physseg
modifier|*
name|seg
decl_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
name|VM_PHYSSEG_MAX
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_free
argument_list|(
name|seg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"array overrun on alloc() after leak"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VM_PHYSSEG_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UVM_HOTPLUG */
end_comment

begin_comment
comment|/*  * Note: This function replicates verbatim what happens in  * uvm_page.c:uvm_page_init().  *  * Please track any changes that happen there.  */
end_comment

begin_function
specifier|static
name|void
name|uvm_page_init_fake
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pagearray
parameter_list|,
name|psize_t
name|pagecount
parameter_list|)
block|{
name|uvm_physseg_t
name|bank
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|bank
operator|=
name|uvm_physseg_get_first
argument_list|()
operator|,
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|bank
argument_list|,
name|pagearray
argument_list|,
name|pagecount
argument_list|)
init|;
name|uvm_physseg_valid_p
argument_list|(
name|bank
argument_list|)
condition|;
name|bank
operator|=
name|uvm_physseg_get_next
argument_list|(
name|bank
argument_list|)
control|)
block|{
name|n
operator|=
name|uvm_physseg_get_end
argument_list|(
name|bank
argument_list|)
operator|-
name|uvm_physseg_get_start
argument_list|(
name|bank
argument_list|)
expr_stmt|;
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|bank
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|bank
argument_list|,
name|pagearray
argument_list|)
expr_stmt|;
comment|/* set up page array pointers */
name|pagearray
operator|+=
name|n
expr_stmt|;
name|pagecount
operator|-=
name|n
expr_stmt|;
block|}
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_plug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_plug
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test plug functionality."
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Note: We only do the second boot time plug if VM_PHYSSEG_MAX> 1 */
end_comment

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_plug
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|int
name|nentries
init|=
literal|0
decl_stmt|;
comment|/* Count of entries via plug done so far */
name|uvm_physseg_t
name|upm1
decl_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|uvm_physseg_t
name|upm2
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_physseg_t
name|upm3
decl_stmt|;
endif|#
directive|endif
name|uvm_physseg_t
name|upm4
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|psize_t
name|npages3
init|=
operator|(
name|VALID_END_PFN_3
operator|-
name|VALID_START_PFN_3
operator|)
decl_stmt|;
name|psize_t
name|npages4
init|=
operator|(
name|VALID_END_PFN_4
operator|-
name|VALID_START_PFN_4
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
decl_stmt|,
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
operator|+
name|npages2
endif|#
directive|endif
operator|+
name|npages3
operator|)
argument_list|)
decl_stmt|;
comment|/* Fake early boot */
name|setup
argument_list|()
expr_stmt|;
comment|/* Vanilla plug x 2 */
name|ATF_REQUIRE_EQ
argument_list|(
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|npages1
argument_list|,
operator|&
name|upm1
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
operator|++
name|nentries
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|ATF_REQUIRE_EQ
argument_list|(
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|npages2
argument_list|,
operator|&
name|upm2
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
operator|++
name|nentries
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
operator|+
name|npages3
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|npages1
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
operator|+
name|npages2
endif|#
directive|endif
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* Scavenge plug - goes into the same slab */
name|ATF_REQUIRE_EQ
argument_list|(
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|npages3
argument_list|,
operator|&
name|upm3
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
operator|++
name|nentries
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|npages1
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
operator|+
name|npages2
endif|#
directive|endif
operator|+
name|npages3
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Scavenge plug should fit right in the slab */
name|pgs
operator|=
name|uvm_physseg_get_pg
argument_list|(
name|upm3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pgs
operator|>
name|slab
operator|&&
name|pgs
operator|<
operator|(
name|slab
operator|+
name|npages1
operator|+
name|npages2
operator|+
name|npages3
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hot plug - goes into a brand new slab */
name|ATF_REQUIRE_EQ
argument_list|(
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_4
argument_list|,
name|npages4
argument_list|,
operator|&
name|upm4
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* The hot plug slab should have nothing to do with the original slab */
name|pgs
operator|=
name|uvm_physseg_get_pg
argument_list|(
name|upm4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pgs
operator|<
name|slab
operator|||
name|pgs
operator|>
operator|(
name|slab
operator|+
name|npages1
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
operator|+
name|npages2
endif|#
directive|endif
operator|+
name|npages3
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_unplug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_unplug
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test unplug functionality."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_unplug
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|psize_t
name|npages3
init|=
operator|(
name|VALID_END_PFN_3
operator|-
name|VALID_START_PFN_3
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|+
name|npages3
operator|)
argument_list|)
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
comment|/* Boot time */
name|setup
argument_list|()
expr_stmt|;
comment|/* We start with zero segments */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|atop
argument_list|(
literal|0
argument_list|)
argument_list|,
name|atop
argument_list|(
name|ONE_MEGABYTE
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Do we have an arbitrary offset in there ? */
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|pa
argument_list|,
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Boot time sanity */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|==
literal|1
comment|/* 	 * This is the curious case at boot time, of having one 	 * extent(9) static entry per segment, which means that a 	 * fragmenting unplug will fail. 	 */
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"fragmenting unplug for single segment"
argument_list|)
expr_stmt|;
comment|/* 	 * In order to test the fragmenting cases, please set 	 * VM_PHYSSEG_MAX> 1 	 */
endif|#
directive|endif
comment|/* Now let's unplug from the middle */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_unplug
argument_list|(
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
argument_list|)
argument_list|,
name|atop
argument_list|(
name|FIVEONETWO_KILO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* verify that a gap exists at TWOFIFTYSIX_KILO */
name|pa
operator|=
literal|0
expr_stmt|;
comment|/* reset */
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
operator|+
name|npages3
argument_list|)
expr_stmt|;
comment|/* Account for the unplug */
name|ATF_CHECK_EQ
argument_list|(
name|atop
argument_list|(
name|FIVEONETWO_KILO
argument_list|)
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Original entry should fragment into two */
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|upm
operator|=
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
operator|+
name|FIVEONETWO_KILO
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now unplug the tail fragment - should swallow the complete entry */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_unplug
argument_list|(
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
operator|+
name|FIVEONETWO_KILO
argument_list|)
argument_list|,
name|atop
argument_list|(
name|TWOFIFTYSIX_KILO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The "swallow" above should have invalidated the handle */
name|ATF_REQUIRE_EQ
argument_list|(
name|false
argument_list|,
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only the first one is left now */
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Unplug from the back */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_unplug
argument_list|(
name|atop
argument_list|(
name|ONETWENTYEIGHT_KILO
argument_list|)
argument_list|,
name|atop
argument_list|(
name|ONETWENTYEIGHT_KILO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shouldn't change the number of segments */
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Unplug from the front */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_unplug
argument_list|(
literal|0
argument_list|,
name|atop
argument_list|(
name|SIXTYFOUR_KILO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shouldn't change the number of segments */
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Unplugging the final fragment should fail */
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"Unplugging the last segment"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_unplug
argument_list|(
name|atop
argument_list|(
name|SIXTYFOUR_KILO
argument_list|)
argument_list|,
name|atop
argument_list|(
name|SIXTYFOUR_KILO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*<---- end Tests for Internal functions ----> */
end_comment

begin_comment
comment|/* Tests for functions exported via uvm_physseg.h */
end_comment

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_init
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_init() call\ 	    initializes the vm_physmem struct which holds the rb_tree."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_init
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_init
argument_list|()
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physload_preload
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physload_preload
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_physload() \ 	    call works without a panic() in a preload scenario."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physload_preload
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Should return a valid handle */
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No pages should be allocated yet */
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* After the first call one segment should exist */
name|ATF_CHECK_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Insert more than one segment iff VM_PHYSSEG_MAX> 1 */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Should return a valid handle */
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* After the second call two segments should exist */
name|ATF_CHECK_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physload_postboot
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physload_postboot
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_physload() \ 	     panic()s in a post boot scenario."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physload_postboot
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|)
argument_list|)
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Should return a valid handle */
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No pages should be allocated yet */
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* After the first call one segment should exist */
name|ATF_CHECK_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
argument_list|)
expr_stmt|;
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"uvm_page_physload() called post boot"
argument_list|)
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Should return a valid handle */
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|npages1
operator|+
name|npages2
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* After the second call two segments should exist */
name|ATF_CHECK_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_handle_immutable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_handle_immutable
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the uvm_physseg_t handle is \ 	    immutable."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_handle_immutable
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
comment|/* We insert the segments in out of order */
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
argument_list|,
name|uvm_physseg_get_prev
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert more than one segment iff VM_PHYSSEG_MAX> 1 */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Fetch Previous, we inserted a lower value */
name|upm
operator|=
name|uvm_physseg_get_prev
argument_list|(
name|upm
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
comment|/* 	 * This test is going to fail for the Array Implementation but is 	 * expected to pass in the RB Tree implementation. 	 */
comment|/* Failure can be expected iff there are more than one handles */
name|atf_tc_expect_fail
argument_list|(
literal|"Mutable handle in static array impl."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
operator|!=
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_seg_chomp_slab
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_seg_chomp_slab
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"The slab import code.()"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_seg_chomp_slab
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|int
name|err
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|uvm_physseg
modifier|*
name|seg
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
decl_stmt|,
modifier|*
name|pgs
decl_stmt|;
specifier|const
name|size_t
name|npages
init|=
name|UVM_PHYSSEG_BOOT_UNPLUG_MAX
decl_stmt|;
comment|/* Number of pages */
name|setup
argument_list|()
expr_stmt|;
comment|/* This is boot time */
name|slab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|slab
argument_list|,
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Should be able to allocate two 128 * sizeof(*slab) */
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|extent_alloc
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|EX_BOUNDZERO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pgs
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|extent_free
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
operator|(
name|u_long
operator|)
name|pgs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
name|EX_BOUNDZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|==
literal|1
comment|/* 	 * free() needs an extra region descriptor, but we only have 	 * one! The classic alloc() at free() problem 	 */
name|ATF_REQUIRE_EQ
argument_list|(
name|ENOMEM
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Try alloc/free at static time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|extent_alloc
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|EX_BOUNDZERO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pgs
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|extent_free
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
operator|(
name|u_long
operator|)
name|pgs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
name|EX_BOUNDZERO
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now setup post boot */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|slab
argument_list|,
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Try alloc/free after uvm_page.c:uvm_page_init() as well */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|extent_alloc
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|EX_BOUNDZERO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pgs
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|extent_free
argument_list|(
name|seg
operator|->
name|ext
argument_list|,
operator|(
name|u_long
operator|)
name|pgs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slab
argument_list|)
argument_list|,
name|EX_BOUNDZERO
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_alloc_from_slab
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_alloc_from_slab
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"The slab alloc code.()"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_alloc_from_slab
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|uvm_physseg
modifier|*
name|seg
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
decl_stmt|,
modifier|*
name|pgs
decl_stmt|;
specifier|const
name|size_t
name|npages
init|=
name|UVM_PHYSSEG_BOOT_UNPLUG_MAX
decl_stmt|;
comment|/* Number of pages */
name|setup
argument_list|()
expr_stmt|;
comment|/* This is boot time */
name|slab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|slab
argument_list|,
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pgs
operator|=
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pgs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now setup post boot */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|pgs
operator|=
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pgs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atf_tc_expect_fail
argument_list|(
literal|"alloc beyond extent"
argument_list|)
expr_stmt|;
name|pgs
operator|=
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pgs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_init_seg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_init_seg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if uvm_physseg_init_seg adds pages to"
literal|"uvmexp.npages"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_init_seg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|uvm_physseg
modifier|*
name|seg
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
decl_stmt|,
modifier|*
name|pgs
decl_stmt|;
specifier|const
name|size_t
name|npages
init|=
name|UVM_PHYSSEG_BOOT_UNPLUG_MAX
decl_stmt|;
comment|/* Number of pages */
name|setup
argument_list|()
expr_stmt|;
comment|/* This is boot time */
name|slab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
name|seg
operator|=
name|uvm_physseg_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uvm_physseg
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|slab
argument_list|,
name|npages
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pgs
operator|=
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|seg
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|end
operator|=
name|npages
expr_stmt|;
name|seg
operator|->
name|avail_start
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|avail_end
operator|=
name|npages
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|PHYSSEG_NODE_TO_HANDLE
argument_list|(
name|seg
argument_list|)
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|npages
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|ATF_TC(uvm_physseg_init_seg); ATF_TC_HEAD(uvm_physseg_init_seg, tc) { 	atf_tc_set_md_var(tc, "descr", "Tests if the basic uvm_page_physload() \ 	    call works without a panic() after Segment is inited."); } ATF_TC_BODY(uvm_physseg_init_seg, tc) { 	uvm_physseg_t upm; 	psize_t npages = (VALID_END_PFN_1 - VALID_START_PFN_1); 	struct vm_page *pgs = malloc(sizeof(struct vm_page) * npages);  	setup(); 	upm = uvm_page_physload(VALID_START_PFN_1, VALID_END_PFN_1, 	    VALID_AVAIL_START_PFN_1, VALID_AVAIL_END_PFN_1, VM_FREELIST_DEFAULT);  	ATF_REQUIRE_EQ(1, uvm_physseg_get_entries());  	ATF_CHECK_EQ(0, uvmexp.npages);
comment|/* 	 * Boot time physplug needs explicit external init, 	 * Duplicate what uvm_page.c:uvm_page_init() does. 	 * Note: not everything uvm_page_init() does gets done here. 	 * Read the source. 	 */
end_comment

begin_comment
comment|/* suck in backing slab, initialise extent. */
end_comment

begin_comment
unit|uvm_physseg_seg_chomp_slab(upm, pgs, npages);
comment|/* 	 * Actual pgs[] allocation, from extent. 	 */
end_comment

begin_comment
unit|uvm_physseg_alloc_from_slab(upm, npages);
comment|/* Now we initialize the segment */
end_comment

begin_comment
unit|uvm_physseg_init_seg(upm, pgs);
comment|/* Done with boot simulation */
end_comment

begin_comment
unit|extent_init(); 	uvm.page_init_done = true;
comment|/* We have total memory of 1MB */
end_comment

begin_comment
unit|ATF_CHECK_EQ(PAGE_COUNT_1M, uvmexp.npages);  	upm =uvm_page_physload(VALID_START_PFN_2, VALID_END_PFN_2, 	    VALID_AVAIL_START_PFN_2, VALID_AVAIL_END_PFN_2, VM_FREELIST_DEFAULT); 	ATF_REQUIRE_EQ(2, uvm_physseg_get_entries());
comment|/* We added another 1MB so PAGE_COUNT_1M + PAGE_COUNT_1M */
end_comment

begin_endif
unit|ATF_CHECK_EQ(PAGE_COUNT_1M + PAGE_COUNT_1M, uvmexp.npages);  }
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the start PFN is returned \ 	    correctly from a segment created via uvm_page_physload()."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
comment|/* Fake early boot */
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_start_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_start_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_start() is called with invalid \ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_start_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* Check for pgs == NULL */
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
comment|/* Invalid uvm_physseg_t */
name|ATF_CHECK_EQ
argument_list|(
operator|(
name|paddr_t
operator|)
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the end PFN is returned \ 	    correctly from a segment created via uvm_page_physload()."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_end_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_end_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_end() is called with invalid \ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_end_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* Check for pgs == NULL */
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
comment|/* Invalid uvm_physseg_t */
name|ATF_CHECK_EQ
argument_list|(
operator|(
name|paddr_t
operator|)
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_avail_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the avail_start PFN is \ 	    returned correctly from a segment created via uvm_page_physload()."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_avail_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_avail_start_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_avail_start_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_avail_start() is called with invalid\ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_avail_start_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* Check for pgs == NULL */
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
comment|/* Invalid uvm_physseg_t */
name|ATF_CHECK_EQ
argument_list|(
operator|(
name|paddr_t
operator|)
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_avail_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_avail_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the avail_end PFN is \ 	    returned correctly from a segment created via uvm_page_physload()."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_avail_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_avail_end_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_avail_end_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_avail_end() is called with invalid\ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_avail_end_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* Check for pgs == NULL */
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
comment|/* Invalid uvm_physseg_t */
name|ATF_CHECK_EQ
argument_list|(
operator|(
name|paddr_t
operator|)
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_next
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_next
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer values for next \ 	    segment using the uvm_physseg_get_next() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_next
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_physseg_t
name|upm_next
decl_stmt|;
endif|#
directive|endif
comment|/* We insert the segments in ascending order */
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID_OVERFLOW
argument_list|,
name|uvm_physseg_get_next
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm_next
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|upm
operator|=
name|uvm_physseg_get_next
argument_list|(
name|upm
argument_list|)
expr_stmt|;
comment|/* Fetch Next */
name|ATF_CHECK_EQ
argument_list|(
name|upm_next
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|upm_next
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|3
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|upm
operator|=
name|uvm_physseg_get_next
argument_list|(
name|upm
argument_list|)
expr_stmt|;
comment|/* Fetch Next */
name|ATF_CHECK_EQ
argument_list|(
name|upm_next
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_3
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_next_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_next_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_next() is called with invalid \ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_next_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
init|=
name|UVM_PHYSSEG_TYPE_INVALID
decl_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|,
name|uvm_physseg_get_next
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_prev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_prev
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer values for previous \ 	    segment using the uvm_physseg_get_prev() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_prev
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_physseg_t
name|upm
decl_stmt|;
endif|#
directive|endif
name|uvm_physseg_t
name|upm_prev
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm_prev
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
argument_list|,
name|uvm_physseg_get_prev
argument_list|(
name|upm_prev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Fetch Previous, we inserted a lower value */
name|upm
operator|=
name|uvm_physseg_get_prev
argument_list|(
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_prev
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|3
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * This will return a UVM_PHYSSEG_TYPE_INVALID_EMPTY we are at the 	 * lowest 	 */
name|upm
operator|=
name|uvm_physseg_get_prev
argument_list|(
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
argument_list|,
name|upm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_prev_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_prev_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the invalid / error conditions \ 	    correctly when uvm_physseg_get_prev() is called with invalid \ 	    parameter values."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_prev_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
init|=
name|UVM_PHYSSEG_TYPE_INVALID
decl_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|,
name|uvm_physseg_get_prev
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_first
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_first
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer values for first \ 	    segment (lowest node) using the uvm_physseg_get_first() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_first
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
init|=
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
decl_stmt|;
name|uvm_physseg_t
name|upm_first
decl_stmt|;
comment|/* Fake early boot */
name|setup
argument_list|()
expr_stmt|;
comment|/* No nodes exist */
name|ATF_CHECK_EQ
argument_list|(
name|upm
argument_list|,
name|uvm_physseg_get_first
argument_list|()
argument_list|)
expr_stmt|;
name|upm_first
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to first should be the least valued node */
name|upm
operator|=
name|uvm_physseg_get_first
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_first
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* Insert a node of lesser value */
name|upm_first
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to first should be the least valued node */
name|upm
operator|=
name|uvm_physseg_get_first
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_first
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
comment|/* Insert a node of higher value */
name|upm_first
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|3
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to first should be the least valued node */
name|upm
operator|=
name|uvm_physseg_get_first
argument_list|()
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|upm_first
operator|!=
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_last
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer values for last \ 	    segment using the uvm_physseg_get_last() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_last
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
init|=
name|UVM_PHYSSEG_TYPE_INVALID_EMPTY
decl_stmt|;
name|uvm_physseg_t
name|upm_last
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* No nodes exist */
name|ATF_CHECK_EQ
argument_list|(
name|upm
argument_list|,
name|uvm_physseg_get_last
argument_list|()
argument_list|)
expr_stmt|;
name|upm_last
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to last should be the most valued node */
name|upm
operator|=
name|uvm_physseg_get_last
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_last
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* Insert node of greater value */
name|upm_last
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to last should be the most valued node */
name|upm
operator|=
name|uvm_physseg_get_last
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_last
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
comment|/* Insert node of greater value */
name|upm_last
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|3
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pointer to last should be the most valued node */
name|upm
operator|=
name|uvm_physseg_get_last
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_last
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_3
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_valid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_valid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer value for current \ 	    segment is valid using the uvm_physseg_valid_p() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_valid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|PAGE_COUNT_1M
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_valid_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_valid_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests the pointer value for current \ 	    segment is invalid using the uvm_physseg_valid_p() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_valid_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
comment|/* Invalid uvm_physseg_t */
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_physseg_valid_p
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Without any pages initialized for segment, it is considered 	 * invalid 	 */
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_physseg_valid_p
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_highest
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_highest
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned PFN matches  \ 	    the highest PFN in use by the system."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_highest
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Only one segment so highest is the current */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_1
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_highest_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* PFN_3> PFN_1 */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_3
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_highest_frame
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* PFN_3> PFN_2 */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_3
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_highest_frame
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_free_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_free_list
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned Free List type \ 	    of a segment matches the one returned from \ 	    uvm_physseg_get_free_list() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_free_list
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
comment|/* Fake early boot */
name|setup
argument_list|()
expr_stmt|;
comment|/* Insertions are made in ascending order */
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VM_FREELIST_DEFAULT
argument_list|,
name|uvm_physseg_get_free_list
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_FIRST16
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VM_FREELIST_FIRST16
argument_list|,
name|uvm_physseg_get_free_list
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This test will be triggered only if there are 3 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|2
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|VALID_END_PFN_3
argument_list|,
name|VALID_AVAIL_START_PFN_3
argument_list|,
name|VALID_AVAIL_END_PFN_3
argument_list|,
name|VM_FREELIST_FIRST1G
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VM_FREELIST_FIRST1G
argument_list|,
name|uvm_physseg_get_free_list
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_start_hint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_start_hint
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned start_hint value \ 	    of a segment matches the one returned from \ 	    uvm_physseg_get_start_hint() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_start_hint
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Will be Zero since no specific value is set during init */
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|uvm_physseg_get_start_hint
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_set_start_hint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_set_start_hint
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned start_hint value \ 	    of a segment matches the one set by the \ 	    uvm_physseg_set_start_hint() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_set_start_hint
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_set_start_hint
argument_list|(
name|upm
argument_list|,
name|atop
argument_list|(
literal|128
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will be atop(128) since no specific value is set above */
name|ATF_CHECK_EQ
argument_list|(
name|atop
argument_list|(
literal|128
argument_list|)
argument_list|,
name|uvm_physseg_get_start_hint
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_set_start_hint_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_set_start_hint_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned value is false \ 	    when an invalid segment matches the one trying to set by the \ 	    uvm_physseg_set_start_hint() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_set_start_hint_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Force other check conditions */
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm
operator|.
name|page_init_done
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_physseg_set_start_hint
argument_list|(
name|upm
argument_list|,
name|atop
argument_list|(
literal|128
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Will be Zero since no specific value is set after the init 	 * due to failure 	 */
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"invalid uvm_physseg_t handle"
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|uvm_physseg_get_start_hint
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_pg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_pg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned vm_page struct \ 	    is correct when fetched by uvm_physseg_get_pg() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_pg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|extracted_pg
init|=
name|NULL
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Now we initialize the segment */
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|PAGE_COUNT_1M
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|NULL
argument_list|,
name|extracted_pg
argument_list|)
expr_stmt|;
comment|/* Try fetching the 5th Page in the Segment */
name|extracted_pg
operator|=
name|uvm_physseg_get_pg
argument_list|(
name|upm
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Values of phys_addr is n * PAGE_SIZE where n is the page number */
name|ATF_CHECK_EQ
argument_list|(
literal|5
operator|*
name|PAGE_SIZE
argument_list|,
name|extracted_pg
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
comment|/* Try fetching the 113th Page in the Segment */
name|extracted_pg
operator|=
name|uvm_physseg_get_pg
argument_list|(
name|upm
argument_list|,
literal|113
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|113
operator|*
name|PAGE_SIZE
argument_list|,
name|extracted_pg
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_PMAP_PHYSSEG
end_ifdef

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_get_pmseg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_get_pmseg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned pmap_physseg \ 	    struct is correct when fetched by uvm_physseg_get_pmseg() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_get_pmseg
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|struct
name|pmap_physseg
name|pmseg
init|=
block|{
name|true
block|}
decl_stmt|;
name|struct
name|pmap_physseg
modifier|*
name|extracted_pmseg
init|=
name|NULL
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Now we initialize the segment */
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|PAGE_COUNT_1M
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|NULL
argument_list|,
name|extracted_pmseg
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|pmseg
operator|.
name|dummy_variable
argument_list|)
expr_stmt|;
comment|/* Extract the current pmseg */
name|extracted_pmseg
operator|=
name|uvm_physseg_get_pmseg
argument_list|(
name|upm
argument_list|)
expr_stmt|;
comment|/* 	 * We can only check if it is not NULL 	 * We do not know the value it contains 	 */
name|ATF_CHECK
argument_list|(
name|NULL
operator|!=
name|extracted_pmseg
argument_list|)
expr_stmt|;
name|extracted_pmseg
operator|->
name|dummy_variable
operator|=
name|pmseg
operator|.
name|dummy_variable
expr_stmt|;
comment|/* Invert value to ensure test integrity */
name|pmseg
operator|.
name|dummy_variable
operator|=
name|false
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|false
argument_list|,
name|pmseg
operator|.
name|dummy_variable
argument_list|)
expr_stmt|;
name|extracted_pmseg
operator|=
name|uvm_physseg_get_pmseg
argument_list|(
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|NULL
operator|!=
name|extracted_pmseg
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|extracted_pmseg
operator|->
name|dummy_variable
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ATF_TC
argument_list|(
name|vm_physseg_find
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|vm_physseg_find
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned segment number \ 	    is correct when an PFN is passed into uvm_physseg_find() call. \ 	    In addition	to this the offset of the PFN from the start of \ 	    segment is also set if the parameter is passed in as not NULL."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|vm_physseg_find
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|offset
init|=
operator|(
name|psize_t
operator|)
operator|-
literal|1
decl_stmt|;
name|uvm_physseg_t
name|upm_first
decl_stmt|,
name|result
decl_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_physseg_t
name|upm_second
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
name|upm_first
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|upm_second
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Under ONE_MEGABYTE is segment upm_first */
name|result
operator|=
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|ONE_MEGABYTE
operator|-
literal|1024
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_first
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_start
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_end
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_end
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
operator|(
name|psize_t
operator|)
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* This test will be triggered only if there are 2 or more segments. */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* Over ONE_MEGABYTE is segment upm_second */
name|result
operator|=
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|ONE_MEGABYTE
operator|+
literal|8192
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_second
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_start
argument_list|(
name|upm_second
argument_list|)
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_end
argument_list|(
name|upm_second
argument_list|)
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|(
name|upm_second
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_end
argument_list|(
name|upm_second
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Offset is calculated based on PAGE_SIZE */
comment|/* atop(ONE_MEGABYTE + (2 * PAGE_SIZE)) - VALID_START_PFN1  = 2 */
name|ATF_CHECK_EQ
argument_list|(
literal|2
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Under ONE_MEGABYTE is segment upm_first */
name|result
operator|=
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|ONE_MEGABYTE
operator|-
literal|12288
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|upm_first
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_start
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_end
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|uvm_physseg_get_avail_end
argument_list|(
name|upm_first
argument_list|)
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Offset is calculated based on PAGE_SIZE */
comment|/* atop(ONE_MEGABYTE - (3 * PAGE_SIZE)) - VALID_START_PFN1  = 253 */
name|ATF_CHECK_EQ
argument_list|(
literal|253
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|vm_physseg_find_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|vm_physseg_find_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the returned segment number \ 	    is (paddr_t) -1  when a non existant PFN is passed into \ 	    uvm_physseg_find() call."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|vm_physseg_find_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|offset
init|=
operator|(
name|psize_t
operator|)
operator|-
literal|1
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* No segments over 3 MB exists at the moment */
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|,
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|ONE_MEGABYTE
operator|*
literal|3
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
operator|(
name|psize_t
operator|)
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* No segments over 3 MB exists at the moment */
name|ATF_CHECK_EQ
argument_list|(
name|UVM_PHYSSEG_TYPE_INVALID
argument_list|,
name|uvm_physseg_find
argument_list|(
name|atop
argument_list|(
name|ONE_MEGABYTE
operator|*
literal|3
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
operator|(
name|psize_t
operator|)
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_physunload()\ 	    call works without a panic(). Unloads from Start of the segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Would uvmexp.npages reduce everytime an uvm_page_physunload is called? 	 */
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * When called for first time, uvm_page_physload() removes the first PFN 	 * 	 * New avail start will be VALID_AVAIL_START_PFN_2 + 1 	 */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|atop
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
operator|+
literal|1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
operator|+
literal|1
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rest of the stuff should remain the same */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_physunload()\ 	    call works without a panic(). Unloads from End of the segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Would uvmexp.npages reduce everytime an uvm_page_physunload is called? 	 */
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* Note: start != avail_start to remove from end. */
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
operator|+
literal|1
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
operator|!=
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remember if X is the upper limit the actual valid pointer is X - 1 	 * 	 * For example if 256 is the upper limit for 1MB memory, last valid 	 * pointer is 256 - 1 = 255 	 */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
operator|-
literal|1
argument_list|,
name|atop
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * When called for second time, uvm_page_physload() removes the last PFN 	 * 	 * New avail end will be VALID_AVAIL_END_PFN_2 - 1 	 * New end will be VALID_AVAIL_PFN_2 - 1 	 */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rest of the stuff should remain the same */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
operator|+
literal|1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_none
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_none
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic uvm_page_physunload()\ 	    call works without a panic(). Does not unload from start or end \ 	    because of non-aligned start / avail_start and end / avail_end \ 	    respectively."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_none
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* 	 * Note: start != avail_start and end != avail_end. 	 * 	 * This prevents any unload from occuring. 	 */
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
operator|+
literal|1
argument_list|,
name|VALID_AVAIL_END_PFN_2
operator|-
literal|1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
operator|!=
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* uvm_page_physload() will no longer unload memory */
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Rest of the stuff should remain the same */
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
operator|+
literal|1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
operator|-
literal|1
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_delete_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_delete_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the  uvm_page_physunload() \ 	    works when the segment gets small enough to be deleted scenario. \ 	    NOTE: This one works deletes from start."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_delete_start
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Would uvmexp.npages reduce everytime an uvm_page_physunload is called? 	 */
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* 	 * Setup the Nuke from Starting point 	 */
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_END_PFN_1
operator|-
literal|1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
operator|-
literal|1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Insert more than one segment iff VM_PHYSSEG_MAX> 1 */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|==
literal|1
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"cannot uvm_page_physunload() the last segment"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_1
operator|-
literal|1
argument_list|,
name|atop
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* The only node now is the one we inserted second. */
name|upm
operator|=
name|uvm_physseg_get_first
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_delete_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_delete_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the  uvm_page_physunload() \ 	    works when the segment gets small enough to be deleted scenario. \ 	    NOTE: This one works deletes from end."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_delete_end
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Would uvmexp.npages reduce everytime an uvm_page_physunload is called? 	 */
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* 	 * Setup the Nuke from Ending point 	 */
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_START_PFN_1
operator|+
literal|2
argument_list|,
name|VALID_AVAIL_START_PFN_1
operator|+
literal|1
argument_list|,
name|VALID_AVAIL_START_PFN_1
operator|+
literal|2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Insert more than one segment iff VM_PHYSSEG_MAX> 1 */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|==
literal|1
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"cannot uvm_page_physunload() the last segment"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_1
operator|+
literal|2
argument_list|,
name|atop
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* The only node now is the one we inserted second. */
name|upm
operator|=
name|uvm_physseg_get_first
argument_list|()
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_END_PFN_2
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the  uvm_page_physunload() \ 	    fails when then Free list does not match."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|psize_t
name|npages
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pgs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|npages
argument_list|)
decl_stmt|;
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|upm
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_page_physunload
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_FIRST4G
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_force
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_force
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the basic \ 	    uvm_page_physunload_force() including delete works without."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_force
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Would uvmexp.npages reduce everytime an uvm_page_physunload is called? 	 */
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|VALID_END_PFN_1
argument_list|,
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|VALID_AVAIL_END_PFN_1
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Insert more than one segment iff VM_PHYSSEG_MAX> 1 */
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
comment|/* 	 * We have couple of physloads done this is bacause of the fact that if 	 * we physunload all the PFs from a given range and we have only one 	 * segment in total a panic() is called 	 */
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_END_PFN_2
argument_list|,
name|VALID_AVAIL_START_PFN_2
argument_list|,
name|VALID_AVAIL_END_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|==
literal|1
name|atf_tc_expect_signal
argument_list|(
name|SIGABRT
argument_list|,
literal|"cannot uvm_page_physunload() the last segment"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_REQUIRE_EQ
argument_list|(
name|VALID_AVAIL_START_PFN_1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_AVAIL_START_PFN_1
init|;
name|i
operator|<
name|VALID_AVAIL_END_PFN_1
condition|;
name|i
operator|++
control|)
block|{
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|uvm_page_physunload_force
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|i
argument_list|,
name|atop
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|VALID_AVAIL_END_PFN_1
condition|)
name|ATF_CHECK_EQ
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we try to retrieve the segment, which has been removed 	 * from the system through force unloading all the pages inside it. 	 */
name|upm
operator|=
name|uvm_physseg_find
argument_list|(
name|VALID_AVAIL_END_PFN_1
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* It should no longer exist */
name|ATF_CHECK_EQ
argument_list|(
name|NULL
argument_list|,
name|upm
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_page_physunload_force_invalid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_page_physunload_force_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests if the invalid conditions for \ 	    uvm_page_physunload_force_invalid()."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_page_physunload_force_invalid
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|p
init|=
literal|0
decl_stmt|;
name|uvm_physseg_t
name|upm
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|upm
operator|=
name|uvm_page_physload
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|VALID_START_PFN_2
operator|+
literal|1
argument_list|,
name|VALID_START_PFN_2
argument_list|,
name|VALID_START_PFN_2
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|0
argument_list|,
name|uvmexp
operator|.
name|npages
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|false
argument_list|,
name|uvm_page_physunload_force
argument_list|(
name|upm
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|,
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
comment|/* Internal */
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_alloc_atboot_mismatch
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_alloc_atboot_overrun
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_alloc_sanity
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_free_atboot_mismatch
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_free_sanity
argument_list|)
expr_stmt|;
if|#
directive|if
name|VM_PHYSSEG_MAX
operator|>
literal|1
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_atboot_free_leak
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* UVM_HOTPLUG */
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_plug
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_unplug
argument_list|)
expr_stmt|;
comment|/* Exported */
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_init
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physload_preload
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physload_postboot
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_handle_immutable
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_seg_chomp_slab
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_alloc_from_slab
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_init_seg
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_start
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_start_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_end
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_end_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_avail_start_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_avail_end_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_next
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_next_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_prev
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_prev_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_first
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_last
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_valid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_valid_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_highest
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_free_list
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_start_hint
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_set_start_hint
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_set_start_hint_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_pg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__HAVE_PMAP_PHYSSEG
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_get_pmseg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|vm_physseg_find
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|vm_physseg_find_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_start
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_end
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_none
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_delete_start
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_delete_end
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_invalid
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_force
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_page_physunload_force_invalid
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

