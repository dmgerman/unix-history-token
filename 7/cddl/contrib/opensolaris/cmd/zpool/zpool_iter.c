begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<solaris.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zpool_util.h"
end_include

begin_comment
comment|/*  * Private interface for iterating over pools specified on the command line.  * Most consumers will call for_each_pool, but in order to support iostat, we  * allow fined grained control through the zpool_list_t interface.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zpool_node
block|{
name|zpool_handle_t
modifier|*
name|zn_handle
decl_stmt|;
name|uu_avl_node_t
name|zn_avlnode
decl_stmt|;
name|int
name|zn_mark
decl_stmt|;
block|}
name|zpool_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|zpool_list
block|{
name|boolean_t
name|zl_findall
decl_stmt|;
name|uu_avl_t
modifier|*
name|zl_avl
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|zl_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zpool_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|l
init|=
operator|(
operator|(
name|zpool_node_t
operator|*
operator|)
name|larg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|zpool_handle_t
modifier|*
name|r
init|=
operator|(
operator|(
name|zpool_node_t
operator|*
operator|)
name|rarg
operator|)
operator|->
name|zn_handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|lname
init|=
name|zpool_get_name
argument_list|(
name|l
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rname
init|=
name|zpool_get_name
argument_list|(
name|r
argument_list|)
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|lname
argument_list|,
name|rname
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback function for pool_list_get().  Adds the given pool to the AVL tree  * of known pools.  */
end_comment

begin_function
specifier|static
name|int
name|add_pool
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zpool_list_t
modifier|*
name|zlp
init|=
name|data
decl_stmt|;
name|zpool_node_t
modifier|*
name|node
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zpool_node_t
argument_list|)
argument_list|)
decl_stmt|;
name|uu_avl_index_t
name|idx
decl_stmt|;
name|node
operator|->
name|zn_handle
operator|=
name|zhp
expr_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|zn_avlnode
argument_list|,
name|zlp
operator|->
name|zl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|uu_avl_insert
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a list of pools based on the given arguments.  If we're given no  * arguments, then iterate over all pools in the system and add them to the AVL  * tree.  Otherwise, add only those pool explicitly specified on the command  * line.  */
end_comment

begin_function
name|zpool_list_t
modifier|*
name|pool_list_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|zpool_proplist_t
modifier|*
modifier|*
name|proplist
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|zpool_list_t
modifier|*
name|zlp
decl_stmt|;
name|zlp
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zpool_list_t
argument_list|)
argument_list|)
expr_stmt|;
name|zlp
operator|->
name|zl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"zfs_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zpool_node_t
argument_list|,
name|zn_avlnode
argument_list|)
argument_list|,
name|zpool_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlp
operator|->
name|zl_pool
operator|==
name|NULL
condition|)
name|zpool_no_memory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|zlp
operator|->
name|zl_avl
operator|=
name|uu_avl_create
argument_list|(
name|zlp
operator|->
name|zl_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|zpool_no_memory
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|add_pool
argument_list|,
name|zlp
argument_list|)
expr_stmt|;
name|zlp
operator|->
name|zl_findall
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|add_pool
argument_list|(
name|zhp
argument_list|,
name|zlp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|proplist
operator|&&
name|zpool_expand_proplist
argument_list|(
name|zhp
argument_list|,
name|proplist
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
operator|*
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|zlp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for any new pools, adding them to the list.  We only add pools when no  * options were given on the command line.  Otherwise, we keep the list fixed as  * those that were explicitly specified.  */
end_comment

begin_function
name|void
name|pool_list_update
parameter_list|(
name|zpool_list_t
modifier|*
name|zlp
parameter_list|)
block|{
if|if
condition|(
name|zlp
operator|->
name|zl_findall
condition|)
operator|(
name|void
operator|)
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|add_pool
argument_list|,
name|zlp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all pools in the list, executing the callback for each  */
end_comment

begin_function
name|int
name|pool_list_iter
parameter_list|(
name|zpool_list_t
modifier|*
name|zlp
parameter_list|,
name|int
name|unavail
parameter_list|,
name|zpool_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zpool_node_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|node
operator|=
name|uu_avl_first
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|next_node
control|)
block|{
name|next_node
operator|=
name|uu_avl_next
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_state
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|)
operator|!=
name|POOL_STATE_UNAVAIL
operator|||
name|unavail
condition|)
name|ret
operator||=
name|func
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given pool from the list.  When running iostat, we want to remove  * those pools that no longer exist.  */
end_comment

begin_function
name|void
name|pool_list_remove
parameter_list|(
name|zpool_list_t
modifier|*
name|zlp
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zpool_node_t
name|search
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|search
operator|.
name|zn_handle
operator|=
name|zhp
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|uu_avl_find
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
operator|&
name|search
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free all the handles associated with this list.  */
end_comment

begin_function
name|void
name|pool_list_free
parameter_list|(
name|zpool_list_t
modifier|*
name|zlp
parameter_list|)
block|{
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
name|zpool_node_t
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|zlp
operator|->
name|zl_pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zlp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of elements in the pool list.  */
end_comment

begin_function
name|int
name|pool_list_count
parameter_list|(
name|zpool_list_t
modifier|*
name|zlp
parameter_list|)
block|{
return|return
operator|(
name|uu_avl_numnodes
argument_list|(
name|zlp
operator|->
name|zl_avl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * High level function which iterates over all pools given on the command line,  * using the pool_list_* interfaces.  */
end_comment

begin_function
name|int
name|for_each_pool
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|unavail
parameter_list|,
name|zpool_proplist_t
modifier|*
modifier|*
name|proplist
parameter_list|,
name|zpool_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zpool_list_t
modifier|*
name|list
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|list
operator|=
name|pool_list_get
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|proplist
argument_list|,
operator|&
name|ret
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|unavail
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

