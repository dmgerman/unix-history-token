begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<solaris.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zpool_util.h"
end_include

begin_function_decl
specifier|static
name|int
name|zpool_do_create
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_destroy
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_add
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_remove
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_list
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_iostat
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_status
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_online
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_offline
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_clear
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_attach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_detach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_replace
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_scrub
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_import
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_export
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_upgrade
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_history
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_get
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zpool_do_set
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These libumem hooks provide a reasonable set of defaults for the allocator's  * debugging facilities.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|HELP_ADD
block|,
name|HELP_ATTACH
block|,
name|HELP_CLEAR
block|,
name|HELP_CREATE
block|,
name|HELP_DESTROY
block|,
name|HELP_DETACH
block|,
name|HELP_EXPORT
block|,
name|HELP_HISTORY
block|,
name|HELP_IMPORT
block|,
name|HELP_IOSTAT
block|,
name|HELP_LIST
block|,
name|HELP_OFFLINE
block|,
name|HELP_ONLINE
block|,
name|HELP_REPLACE
block|,
name|HELP_REMOVE
block|,
name|HELP_SCRUB
block|,
name|HELP_STATUS
block|,
name|HELP_UPGRADE
block|,
name|HELP_GET
block|,
name|HELP_SET
block|}
name|zpool_help_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zpool_command
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|zpool_help_t
name|usage
decl_stmt|;
block|}
name|zpool_command_t
typedef|;
end_typedef

begin_comment
comment|/*  * Master command table.  Each ZFS command has a name, associated function, and  * usage message.  The usage messages need to be internationalized, so we have  * to have a function to return the usage message based on a command index.  *  * These commands are organized according to how they are displayed in the usage  * message.  An empty command (one with a NULL name) indicates an empty line in  * the generic usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|zpool_command_t
name|command_table
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|zpool_do_create
block|,
name|HELP_CREATE
block|}
block|,
block|{
literal|"destroy"
block|,
name|zpool_do_destroy
block|,
name|HELP_DESTROY
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"add"
block|,
name|zpool_do_add
block|,
name|HELP_ADD
block|}
block|,
block|{
literal|"remove"
block|,
name|zpool_do_remove
block|,
name|HELP_REMOVE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"list"
block|,
name|zpool_do_list
block|,
name|HELP_LIST
block|}
block|,
block|{
literal|"iostat"
block|,
name|zpool_do_iostat
block|,
name|HELP_IOSTAT
block|}
block|,
block|{
literal|"status"
block|,
name|zpool_do_status
block|,
name|HELP_STATUS
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"online"
block|,
name|zpool_do_online
block|,
name|HELP_ONLINE
block|}
block|,
block|{
literal|"offline"
block|,
name|zpool_do_offline
block|,
name|HELP_OFFLINE
block|}
block|,
block|{
literal|"clear"
block|,
name|zpool_do_clear
block|,
name|HELP_CLEAR
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"attach"
block|,
name|zpool_do_attach
block|,
name|HELP_ATTACH
block|}
block|,
block|{
literal|"detach"
block|,
name|zpool_do_detach
block|,
name|HELP_DETACH
block|}
block|,
block|{
literal|"replace"
block|,
name|zpool_do_replace
block|,
name|HELP_REPLACE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"scrub"
block|,
name|zpool_do_scrub
block|,
name|HELP_SCRUB
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"import"
block|,
name|zpool_do_import
block|,
name|HELP_IMPORT
block|}
block|,
block|{
literal|"export"
block|,
name|zpool_do_export
block|,
name|HELP_EXPORT
block|}
block|,
block|{
literal|"upgrade"
block|,
name|zpool_do_upgrade
block|,
name|HELP_UPGRADE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"history"
block|,
name|zpool_do_history
block|,
name|HELP_HISTORY
block|}
block|,
block|{
literal|"get"
block|,
name|zpool_do_get
block|,
name|HELP_GET
block|}
block|,
block|{
literal|"set"
block|,
name|zpool_do_set
block|,
name|HELP_SET
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOMMAND
value|(sizeof (command_table) / sizeof (command_table[0]))
end_define

begin_decl_stmt
name|zpool_command_t
modifier|*
name|current_command
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_usage
parameter_list|(
name|zpool_help_t
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|HELP_ADD
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tadd [-fn]<pool><vdev> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ATTACH
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tattach [-f]<pool><device> "
literal|"<new_device>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CLEAR
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tclear<pool> [device]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CREATE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tcreate  [-fn] [-R root] [-m mountpoint] "
literal|"<pool><vdev> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DESTROY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdestroy [-f]<pool>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DETACH
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdetach<pool><device>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_EXPORT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\texport [-f]<pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_HISTORY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\thistory [<pool>]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_IMPORT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\timport [-d dir] [-D]\n"
literal|"\timport [-d dir] [-D] [-f] [-o opts] [-R root] -a\n"
literal|"\timport [-d dir] [-D] [-f] [-o opts] [-R root ]"
literal|"<pool | id> [newpool]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_IOSTAT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tiostat [-v] [pool] ... [interval "
literal|"[count]]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LIST
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlist [-H] [-o field[,field]*] "
literal|"[pool] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_OFFLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\toffline [-t]<pool><device> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ONLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tonline<pool><device> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REPLACE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treplace [-f]<pool><device> "
literal|"[new_device]\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_REMOVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tremove<pool><device>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SCRUB
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tscrub [-s]<pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_STATUS
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tstatus [-vx] [pool] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UPGRADE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tupgrade\n"
literal|"\tupgrade -v\n"
literal|"\tupgrade<-a | pool>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tget<all | property[,property]...> "
literal|"<pool> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tset<property=value><pool> \n"
argument_list|)
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Fields available for 'zpool list'.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ZPOOL_FIELD_NAME
block|,
name|ZPOOL_FIELD_SIZE
block|,
name|ZPOOL_FIELD_USED
block|,
name|ZPOOL_FIELD_AVAILABLE
block|,
name|ZPOOL_FIELD_CAPACITY
block|,
name|ZPOOL_FIELD_HEALTH
block|,
name|ZPOOL_FIELD_ROOT
block|}
name|zpool_field_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_FIELDS
value|10
end_define

begin_typedef
typedef|typedef
struct|struct
name|column_def
block|{
specifier|const
name|char
modifier|*
name|cd_title
decl_stmt|;
name|size_t
name|cd_width
decl_stmt|;
enum|enum
block|{
name|left_justify
block|,
name|right_justify
block|}
name|cd_justify
enum|;
block|}
name|column_def_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|column_def_t
name|column_table
index|[]
init|=
block|{
block|{
literal|"NAME"
block|,
literal|20
block|,
name|left_justify
block|}
block|,
block|{
literal|"SIZE"
block|,
literal|6
block|,
name|right_justify
block|}
block|,
block|{
literal|"USED"
block|,
literal|6
block|,
name|right_justify
block|}
block|,
block|{
literal|"AVAIL"
block|,
literal|6
block|,
name|right_justify
block|}
block|,
block|{
literal|"CAP"
block|,
literal|5
block|,
name|right_justify
block|}
block|,
block|{
literal|"HEALTH"
block|,
literal|9
block|,
name|left_justify
block|}
block|,
block|{
literal|"ALTROOT"
block|,
literal|15
block|,
name|left_justify
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|column_subopts
index|[]
init|=
block|{
literal|"name"
block|,
literal|"size"
block|,
literal|"used"
block|,
literal|"available"
block|,
literal|"capacity"
block|,
literal|"health"
block|,
literal|"root"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Callback routine that will print out a pool property value.  */
end_comment

begin_function
specifier|static
name|zpool_prop_t
name|print_prop_cb
parameter_list|(
name|zpool_prop_t
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|cb
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-13s  "
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_prop_values
argument_list|(
name|prop
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|zpool_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZFS_PROP_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage message.  If we're inside a command, display only the usage for  * that command.  Otherwise, iterate over the entire command table and display  * a complete usage message.  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|current_command
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage: zpool command args ...\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"where 'command' is one of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|current_command
operator|->
name|usage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nwhere 'field' is one "
literal|"of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|column_subopts
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s\n"
argument_list|,
name|column_subopts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nthe following properties are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%-13s  %s\n\n"
argument_list|,
literal|"PROPERTY"
argument_list|,
literal|"VALUES"
argument_list|)
expr_stmt|;
comment|/* Iterate over all properties */
operator|(
name|void
operator|)
name|zpool_prop_iter
argument_list|(
name|print_prop_cb
argument_list|,
name|fp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See comments at end of main(). 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|state_to_health
parameter_list|(
name|int
name|vs_state
parameter_list|)
block|{
switch|switch
condition|(
name|vs_state
condition|)
block|{
case|case
name|VDEV_STATE_CLOSED
case|:
case|case
name|VDEV_STATE_CANT_OPEN
case|:
case|case
name|VDEV_STATE_OFFLINE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"FAULTED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_DEGRADED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"DEGRADED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_HEALTHY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"ONLINE"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"UNKNOWN"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|state_to_name
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|)
block|{
switch|switch
condition|(
name|vs
operator|->
name|vs_state
condition|)
block|{
case|case
name|VDEV_STATE_CLOSED
case|:
case|case
name|VDEV_STATE_CANT_OPEN
case|:
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
condition|)
return|return
operator|(
name|gettext
argument_list|(
literal|"FAULTED"
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|gettext
argument_list|(
literal|"UNAVAIL"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_OFFLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"OFFLINE"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_DEGRADED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"DEGRADED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_HEALTHY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"ONLINE"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|gettext
argument_list|(
literal|"UNKNOWN"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_vdev_tree
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * zpool add [-fn]<pool><vdev> ...  *  *	-f	Force addition of devices, even if they appear in use  *	-n	Do not add the devices, but display the resulting layout if  *		they were to be added.  *  * Adds the given vdevs to 'pool'.  As with create, the bulk of this work is  * handled by get_vdev_spec(), which constructs the nvlist needed to pass to  * libzfs.  */
end_comment

begin_function
name|int
name|zpool_do_add
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fn"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing vdev specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool '%s' is unavailable\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* pass off to get_vdev_spec for processing */
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|config
argument_list|,
name|force
argument_list|,
operator|!
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dryrun
condition|)
block|{
name|nvlist_t
modifier|*
name|poolnvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|poolnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would update '%s' to the following "
literal|"configuration:\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|poolname
argument_list|,
name|poolnvroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
name|zpool_add
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
literal|1
operator|+
name|optind
argument_list|,
name|argv
operator|-
literal|1
operator|-
name|optind
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool remove<pool><vdev>  *  * Removes the given vdev from the pool.  Currently, this only supports removing  * spares from the pool.  Eventually, we'll want to support removing leaf vdevs  * (as an alias for 'detach') as well as toplevel vdevs.  */
end_comment

begin_function
name|int
name|zpool_do_remove
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|poolname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zpool_vdev_remove
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
operator|++
name|argc
argument_list|,
operator|--
name|argv
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool create [-fn] [-R root] [-m mountpoint]<pool><dev> ...  *  *	-f	Force creation, even if devices appear in use  *	-n	Do not create the pool, but display the resulting layout if it  *		were to be created.  *      -R	Create a pool under an alternate root  *      -m	Set default mountpoint for the root dataset.  By default it's  *      	'/<pool>'  *  * Creates the named pool according to the given vdev specification.  The  * bulk of the vdev processing is done in get_vdev_spec() in zpool_vdev.c.  Once  * we get the nvlist back from get_vdev_spec(), we either print out the contents  * (if '-n' was specified), or pass it to libzfs to do the creation.  */
end_comment

begin_function
name|int
name|zpool_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mountpoint
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":fnR:m:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|altroot
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mountpoint
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing vdev specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * As a special case, check for use of '/' in the name, and direct the 	 * user to use 'zfs create' instead. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|poolname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot create '%s': invalid "
literal|"character '/' in pool name\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs create' to "
literal|"create a dataset\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* pass off to get_vdev_spec for bulk processing */
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|NULL
argument_list|,
name|force
argument_list|,
operator|!
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* make_root_vdev() allows 0 toplevel children if there are spares */
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|children
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: at least one toplevel vdev must be "
literal|"specified\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|altroot
operator|!=
name|NULL
operator|&&
name|altroot
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid alternate root '%s': "
literal|"must be an absolute path\n"
argument_list|)
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check the validity of the mountpoint and direct the user to use the 	 * '-m' mountpoint option if it looks like its in use. 	 */
if|if
condition|(
name|mountpoint
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_NONE
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
if|if
condition|(
name|mountpoint
operator|&&
name|mountpoint
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid mountpoint "
literal|"'%s': must be an absolute path, 'legacy', or "
literal|"'none'\n"
argument_list|)
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mountpoint
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|altroot
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/%s"
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|altroot
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat64
argument_list|(
name|buf
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|statbuf
operator|.
name|st_nlink
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|mountpoint
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"default "
literal|"mountpoint '%s' exists and is not "
literal|"empty\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mountpoint "
literal|"'%s' exists and is not empty\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-m' "
literal|"option to provide a different default\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dryrun
condition|)
block|{
comment|/* 		 * For a dry run invocation, print out a basic message and run 		 * through all the vdevs in the list and print out in an 		 * appropriate hierarchy. 		 */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"would create '%s' with the "
literal|"following layout:\n\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|NULL
argument_list|,
name|poolname
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Hand off to libzfs. 		 */
if|if
condition|(
name|zpool_create
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|,
name|nvroot
argument_list|,
name|altroot
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|pool
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mountpoint
operator|!=
name|NULL
condition|)
name|verify
argument_list|(
name|zfs_prop_set
argument_list|(
name|pool
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MOUNTPOINT
argument_list|)
argument_list|,
name|mountpoint
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_mount
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|zfs_share_nfs
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|libzfs_errno
argument_list|(
name|g_zfs
argument_list|)
operator|==
name|EZFS_INVALIDNAME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool name may have "
literal|"been omitted\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool destroy<pool>  *  * 	-f	Forcefully unmount any datasets  *  * Destroy the given pool.  Automatically unmounts any datasets in the pool.  */
end_comment

begin_function
name|int
name|zpool_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|pool
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|pool
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * As a special case, check for use of '/' in the name, and 		 * direct the user to use 'zfs destroy' instead. 		 */
if|if
condition|(
name|strchr
argument_list|(
name|pool
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs destroy' to "
literal|"destroy a dataset\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zpool_disable_datasets
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"could not destroy '%s': "
literal|"could not unmount datasets\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|pool
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|zpool_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool export [-f]<pool> ...  *  *	-f	Forcefully unmount datasets  *  * Export the given pools.  By default, the command will attempt to cleanly  * unmount any active datasets within the pool.  If the '-f' flag is specified,  * then the datasets will be forcefully unmounted.  */
end_comment

begin_function
name|int
name|zpool_do_export
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zpool_disable_datasets
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_export
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a vdev configuration, determine the maximum width needed for the device  * name column.  */
end_comment

begin_function
specifier|static
name|int
name|max_width
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|nv
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
operator|>
name|max
condition|)
name|max
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|max
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|max
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|ret
expr_stmt|;
block|}
return|return
operator|(
name|max
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the configuration of an exported pool.  Iterate over all vdevs in the  * pool, printing out the name and status for each one.  */
end_comment

begin_function
name|void
name|print_import_config
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|namewidth
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|vname
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%-*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|namewidth
operator|-
name|depth
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %-8s  "
argument_list|,
name|state_to_name
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vs
operator|->
name|vs_aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"cannot open"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"missing device"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"insufficient replicas"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"newer version"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"corrupted data"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %s"
argument_list|,
name|state_to_name
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|print_import_config
argument_list|(
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tspares\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t  %s\n"
argument_list|,
name|vname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display the status for the given pool.  */
end_comment

begin_function
specifier|static
name|void
name|show_import
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|uint64_t
name|pool_state
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|int
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|health
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|int
name|namewidth
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|pool_state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|health
operator|=
name|state_to_health
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|)
expr_stmt|;
name|reason
operator|=
name|zpool_import_status
argument_list|(
name|config
argument_list|,
operator|&
name|msgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  pool: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"    id: %llu\n"
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" state: %s"
argument_list|)
argument_list|,
name|health
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" (DESTROYED)"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
case|case
name|ZPOOL_STATUS_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices are missing "
literal|"from the system.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_R
case|:
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices contains "
literal|"corrupted data.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_DATA
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool data is corrupted.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_OFFLINE_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices "
literal|"are offlined.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_POOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool metadata is "
literal|"corrupted.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_OLDER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool is formatted using an "
literal|"older on-disk version.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool is formatted using an "
literal|"incompatible version.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_HOSTID_MISMATCH
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool was last accessed by "
literal|"another system.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * No other status can be seen when importing pools. 		 */
name|assert
argument_list|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Print out an action according to the overall state of the pool. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_VERSION_OLDER
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool can be "
literal|"imported using its name or numeric identifier, "
literal|"though\n\tsome features will not be available "
literal|"without an explicit 'zpool upgrade'.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_HOSTID_MISMATCH
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool can be "
literal|"imported using its name or numeric "
literal|"identifier and\n\tthe '-f' flag.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool can be "
literal|"imported using its name or numeric "
literal|"identifier.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_DEGRADED
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool can be imported "
literal|"despite missing or damaged devices.  The\n\tfault "
literal|"tolerance of the pool may be compromised if imported.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be "
literal|"imported.  Access the pool on a system running "
literal|"newer\n\tsoftware, or recreate the pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
case|case
name|ZPOOL_STATUS_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be "
literal|"imported. Attach the missing\n\tdevices and try "
literal|"again.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: The pool cannot be "
literal|"imported due to damaged devices or data.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the state is "closed" or "can't open", and the aux state 	 * is "corrupt data": 	 */
if|if
condition|(
operator|(
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CLOSED
operator|)
operator|||
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|)
operator|)
operator|&&
operator|(
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
operator|)
condition|)
block|{
if|if
condition|(
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tThe pool was destroyed, "
literal|"but can be imported using the '-Df' flags.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pool_state
operator|!=
name|POOL_STATE_EXPORTED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tThe pool may be active on "
literal|"on another system, but can be imported using\n\t"
literal|"the '-f' flag.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"   see: http://www.sun.com/msg/%s\n"
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"config:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|namewidth
operator|=
name|max_width
argument_list|(
name|NULL
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namewidth
operator|<
literal|10
condition|)
name|namewidth
operator|=
literal|10
expr_stmt|;
name|print_import_config
argument_list|(
name|name
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_BAD_GUID_SUM
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\n\tAdditional devices are known to "
literal|"be part of this pool, though their\n\texact "
literal|"configuration cannot be determined.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform the import for the given configuration.  This passes the heavy  * lifting off to zpool_import(), and then mounts the datasets contained within  * the pool.  */
end_comment

begin_function
specifier|static
name|int
name|do_import
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
specifier|const
name|char
modifier|*
name|mntopts
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|ZFS_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': pool "
literal|"is formatted using a newer ZFS version\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_EXPORTED
operator|&&
operator|!
name|force
condition|)
block|{
name|uint64_t
name|hostid
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|gethostid
argument_list|()
condition|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|uint64_t
name|timestamp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TIMESTAMP
argument_list|,
operator|&
name|timestamp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|timestamp
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import "
literal|"'%s': pool may be in use from other "
literal|"system, it was last accessed by %s "
literal|"(hostid: 0x%lx) on %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|hostname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hostid
argument_list|,
name|asctime
argument_list|(
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to "
literal|"import anyway\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"pool may be in use from other system\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to import "
literal|"anyway\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zpool_import
argument_list|(
name|g_zfs
argument_list|,
name|config
argument_list|,
name|newname
argument_list|,
name|altroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|newname
expr_stmt|;
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|name
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|verify
argument_list|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_enable_datasets
argument_list|(
name|zhp
argument_list|,
name|mntopts
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool import [-d dir] [-D]  *       import [-R root] [-D] [-d dir] [-f] -a  *       import [-R root] [-D] [-d dir] [-f]<pool | id> [newpool]  *  *       -d	Scan in a specific directory, other than /dev/dsk.  More than  *		one directory can be specified using multiple '-d' options.  *  *       -D     Scan for previously destroyed pools or import all or only  *              specified destroyed pools.  *  *       -R	Temporarily import the pool, with all mountpoints relative to  *		the given root.  The pool will remain exported when the machine  *		is rebooted.  *  *       -f	Force import, even if it appears that the pool is active.  *  *       -a	Import all pools found.  *  * The import command scans for pools to import, and import pools based on pool  * name and GUID.  The pool can also be renamed as part of the import process.  */
end_comment

begin_function
name|int
name|zpool_do_import
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|searchdirs
init|=
name|NULL
decl_stmt|;
name|int
name|nsearch
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|pools
decl_stmt|;
name|boolean_t
name|do_all
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_destroyed
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mntopts
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|do_force
init|=
name|B_FALSE
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|searchguid
decl_stmt|;
name|char
modifier|*
name|searchname
decl_stmt|;
name|nvlist_t
modifier|*
name|found_config
decl_stmt|;
name|boolean_t
name|first
decl_stmt|;
name|uint64_t
name|pool_state
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":Dfd:R:ao:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|searchdirs
operator|==
name|NULL
condition|)
block|{
name|searchdirs
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|tmp
init|=
name|safe_malloc
argument_list|(
operator|(
name|nsearch
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|searchdirs
argument_list|,
name|tmp
argument_list|,
name|nsearch
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
name|searchdirs
operator|=
name|tmp
expr_stmt|;
block|}
name|searchdirs
index|[
name|nsearch
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_destroyed
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|do_force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|mntopts
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|altroot
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|searchdirs
operator|==
name|NULL
condition|)
block|{
name|searchdirs
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|searchdirs
index|[
literal|0
index|]
operator|=
literal|"/dev"
expr_stmt|;
name|nsearch
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check argument count */
if|if
condition|(
name|do_all
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check for the SYS_CONFIG privilege.  We do this explicitly 		 * here because otherwise any attempt to discover pools will 		 * silently fail. 		 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|!
name|priv_ineffect
argument_list|(
name|PRIV_SYS_CONFIG
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"discover pools: permission denied\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|pools
operator|=
name|zpool_find_import
argument_list|(
name|g_zfs
argument_list|,
name|nsearch
argument_list|,
name|searchdirs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We now have a list of all available pools in the given directories. 	 * Depending on the arguments given, we do one of the following: 	 * 	 *<none>	Iterate through all pools and display information about 	 *		each one. 	 * 	 *	-a	Iterate through all pools and try to import each one. 	 * 	 *<id>	Find the pool that corresponds to the given GUID/pool 	 *		name and import that one. 	 * 	 *	-D	Above options applies only to destroyed pools. 	 */
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|searchguid
operator|=
name|strtoull
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
name|searchname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|searchname
operator|=
name|NULL
expr_stmt|;
name|found_config
operator|=
name|NULL
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
name|B_TRUE
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|pools
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|config
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|pool_state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_destroyed
operator|&&
name|pool_state
operator|==
name|POOL_STATE_DESTROYED
condition|)
continue|continue;
if|if
condition|(
name|do_destroyed
operator|&&
name|pool_state
operator|!=
name|POOL_STATE_DESTROYED
condition|)
continue|continue;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|B_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|do_all
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_all
condition|)
name|err
operator||=
name|do_import
argument_list|(
name|config
argument_list|,
name|NULL
argument_list|,
name|mntopts
argument_list|,
name|altroot
argument_list|,
name|do_force
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|)
expr_stmt|;
else|else
name|show_import
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|searchname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 			 * We are searching for a pool based on name. 			 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|searchname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_config
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': more than "
literal|"one matching pool\n"
argument_list|)
argument_list|,
name|searchname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"import by numeric ID instead\n"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|found_config
operator|=
name|config
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint64_t
name|guid
decl_stmt|;
comment|/* 			 * Search for a pool by guid. 			 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|searchguid
condition|)
name|found_config
operator|=
name|config
expr_stmt|;
block|}
block|}
comment|/* 	 * If we were searching for a specific pool, verify that we found a 	 * pool, and then do the import. 	 */
if|if
condition|(
name|argc
operator|!=
literal|0
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_config
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot import '%s': "
literal|"no such pool available\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|err
operator||=
name|do_import
argument_list|(
name|found_config
argument_list|,
name|argc
operator|==
literal|1
condition|?
name|NULL
else|:
name|argv
index|[
literal|1
index|]
argument_list|,
name|mntopts
argument_list|,
name|altroot
argument_list|,
name|do_force
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we were just looking for pools, report an error if none were 	 * found. 	 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|first
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no pools available to import\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|pools
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|searchdirs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|iostat_cbdata
block|{
name|zpool_list_t
modifier|*
name|cb_list
decl_stmt|;
name|int
name|cb_verbose
decl_stmt|;
name|int
name|cb_iteration
decl_stmt|;
name|int
name|cb_namewidth
decl_stmt|;
block|}
name|iostat_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|print_iostat_separator
parameter_list|(
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|cb_namewidth
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  -----  -----  -----  -----  -----  -----\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_iostat_header
parameter_list|(
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s     capacity     operations    bandwidth\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s   used  avail   read  write   read  write\n"
argument_list|,
name|cb
operator|->
name|cb_namewidth
argument_list|,
literal|"pool"
argument_list|)
expr_stmt|;
name|print_iostat_separator
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a single statistic.  */
end_comment

begin_function
name|void
name|print_one_stat
parameter_list|(
name|uint64_t
name|value
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %5s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out all the statistics for the given vdev.  This can either be the  * toplevel configuration, or called recursively.  If 'name' is NULL, then this  * is a verbose output, and we don't want to display the toplevel pool stats.  */
end_comment

begin_function
name|void
name|print_vdev_stats
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|oldnv
parameter_list|,
name|nvlist_t
modifier|*
name|newnv
parameter_list|,
name|iostat_cbdata_t
modifier|*
name|cb
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|oldchild
decl_stmt|,
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|vdev_stat_t
modifier|*
name|oldvs
decl_stmt|,
modifier|*
name|newvs
decl_stmt|;
name|vdev_stat_t
name|zerovs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|tdelta
decl_stmt|;
name|double
name|scale
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
if|if
condition|(
name|oldnv
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|oldnv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|oldvs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldvs
operator|=
operator|&
name|zerovs
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|newnv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|newvs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|depth
operator|>
name|cb
operator|->
name|cb_namewidth
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s%*s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cb
operator|->
name|cb_namewidth
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|depth
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|tdelta
operator|=
name|newvs
operator|->
name|vs_timestamp
operator|-
name|oldvs
operator|->
name|vs_timestamp
expr_stmt|;
if|if
condition|(
name|tdelta
operator|==
literal|0
condition|)
name|scale
operator|=
literal|1.0
expr_stmt|;
else|else
name|scale
operator|=
operator|(
name|double
operator|)
name|NANOSEC
operator|/
name|tdelta
expr_stmt|;
comment|/* only toplevel vdevs have capacity stats */
if|if
condition|(
name|newvs
operator|->
name|vs_space
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"      -      -"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_one_stat
argument_list|(
name|newvs
operator|->
name|vs_alloc
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
name|newvs
operator|->
name|vs_space
operator|-
name|newvs
operator|->
name|vs_alloc
argument_list|)
expr_stmt|;
block|}
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_READ
index|]
operator|-
name|oldvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_READ
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_WRITE
index|]
operator|-
name|oldvs
operator|->
name|vs_ops
index|[
name|ZIO_TYPE_WRITE
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_READ
index|]
operator|-
name|oldvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_READ
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_one_stat
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|scale
operator|*
operator|(
name|newvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_WRITE
index|]
operator|-
name|oldvs
operator|->
name|vs_bytes
index|[
name|ZIO_TYPE_WRITE
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_verbose
condition|)
return|return;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|newnv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|newchild
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|oldnv
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|oldnv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|oldchild
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|oldnv
condition|?
name|oldchild
index|[
name|c
index|]
else|:
name|NULL
argument_list|,
name|newchild
index|[
name|c
index|]
argument_list|,
name|cb
argument_list|,
name|depth
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|refresh_iostat
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
comment|/* 	 * If the pool has disappeared, remove it from the list and continue. 	 */
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|missing
condition|)
name|pool_list_remove
argument_list|(
name|cb
operator|->
name|cb_list
argument_list|,
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback to print out the iostats for the given pool.  */
end_comment

begin_function
name|int
name|print_iostat
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|oldconfig
decl_stmt|,
modifier|*
name|newconfig
decl_stmt|;
name|nvlist_t
modifier|*
name|oldnvroot
decl_stmt|,
modifier|*
name|newnvroot
decl_stmt|;
name|newconfig
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
operator|&
name|oldconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_iteration
operator|==
literal|1
condition|)
name|oldconfig
operator|=
name|NULL
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|newnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldconfig
operator|==
name|NULL
condition|)
name|oldnvroot
operator|=
name|NULL
expr_stmt|;
else|else
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|oldconfig
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|oldnvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Print out the statistics for the pool. 	 */
name|print_vdev_stats
argument_list|(
name|zhp
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|oldnvroot
argument_list|,
name|newnvroot
argument_list|,
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_verbose
condition|)
name|print_iostat_separator
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_namewidth
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|iostat_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_verbose
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
name|strlen
argument_list|(
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|cb_namewidth
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The width must fall into the range [10,38].  The upper limit is the 	 * maximum we can have and still fit in 80 columns. 	 */
if|if
condition|(
name|cb
operator|->
name|cb_namewidth
operator|<
literal|10
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_namewidth
operator|>
literal|38
condition|)
name|cb
operator|->
name|cb_namewidth
operator|=
literal|38
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool iostat [-v] [pool] ... [interval [count]]  *  *	-v	Display statistics for individual vdevs  *  * This command can be tricky because we want to be able to deal with pool  * creation/destruction as well as vdev configuration changes.  The bulk of this  * processing is handled by the pool_list_* routines in zpool_iter.c.  We rely  * on pool_list_update() to detect the addition of new pools.  Configuration  * changes are all handled within libzfs.  */
end_comment

begin_function
name|int
name|zpool_do_iostat
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|npools
decl_stmt|;
name|unsigned
name|long
name|interval
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|zpool_list_t
modifier|*
name|list
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|iostat_cbdata_t
name|cb
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* 	 * Determine if the last argument is an integer or a pool name 	 */
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|interval
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"interval "
literal|"cannot be zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Ignore the last parameter 			 */
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this is not a valid number, just plow on.  The 			 * user will get a more informative error message later 			 * on. 			 */
name|interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If the last argument is also an integer, then we have both a count 	 * and an integer. 	 */
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|interval
expr_stmt|;
name|interval
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"interval "
literal|"cannot be zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Ignore the last parameter 			 */
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Construct the list of all interesting pools. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|=
name|pool_list_get
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
operator|&
name|ret
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|argc
operator|!=
literal|0
condition|)
block|{
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|==
literal|0
operator|&&
name|interval
operator|==
literal|0
condition|)
block|{
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Enter the main iostat loop. 	 */
name|cb
operator|.
name|cb_list
operator|=
name|list
expr_stmt|;
name|cb
operator|.
name|cb_verbose
operator|=
name|verbose
expr_stmt|;
name|cb
operator|.
name|cb_iteration
operator|=
literal|0
expr_stmt|;
name|cb
operator|.
name|cb_namewidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pool_list_update
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|npools
operator|=
name|pool_list_count
argument_list|(
name|list
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Refresh all statistics.  This is done as an explicit step 		 * before calculating the maximum name width, so that any 		 * configuration changes are properly accounted for. 		 */
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|refresh_iostat
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
comment|/* 		 * Iterate over all pools to determine the maximum width 		 * for the pool / device name column across all pools. 		 */
name|cb
operator|.
name|cb_namewidth
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|get_namewidth
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
comment|/* 		 * If it's the first time, or verbose mode, print the header. 		 */
if|if
condition|(
operator|++
name|cb
operator|.
name|cb_iteration
operator|==
literal|1
operator|||
name|verbose
condition|)
name|print_iostat_header
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pool_list_iter
argument_list|(
name|list
argument_list|,
name|B_FALSE
argument_list|,
name|print_iostat
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
comment|/* 		 * If there's more than one pool, and we're not in verbose mode 		 * (which prints a separator for us), then print a separator. 		 */
if|if
condition|(
name|npools
operator|>
literal|1
operator|&&
operator|!
name|verbose
condition|)
name|print_iostat_separator
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Flush the output so that redirection to a file isn't buffered 		 * indefinitely. 		 */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
name|pool_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|list_cbdata
block|{
name|boolean_t
name|cb_scripted
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_fields
index|[
name|MAX_FIELDS
index|]
decl_stmt|;
name|int
name|cb_fieldcount
decl_stmt|;
block|}
name|list_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Given a list of columns to display, output appropriate headers for each one.  */
end_comment

begin_function
name|void
name|print_header
parameter_list|(
name|int
modifier|*
name|fields
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|column_def_t
modifier|*
name|col
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|col
operator|=
operator|&
name|column_table
index|[
name|fields
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|cd_justify
operator|==
name|left_justify
condition|)
name|fmt
operator|=
literal|"%-*s"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%*s"
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|fmt
argument_list|,
name|i
operator|==
name|count
operator|-
literal|1
condition|?
name|strlen
argument_list|(
name|col
operator|->
name|cd_title
argument_list|)
else|:
name|col
operator|->
name|cd_width
argument_list|,
name|col
operator|->
name|cd_title
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|list_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|list_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|ZPOOL_MAXNAMELEN
index|]
decl_stmt|;
name|uint64_t
name|total
decl_stmt|;
name|uint64_t
name|used
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|column_def_t
modifier|*
name|col
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_scripted
condition|)
name|print_header
argument_list|(
name|cbp
operator|->
name|cb_fields
argument_list|,
name|cbp
operator|->
name|cb_fieldcount
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
name|config
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|total
operator|=
name|zpool_get_space_total
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|used
operator|=
name|zpool_get_space_used
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cbp
operator|->
name|cb_fieldcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|col
operator|=
operator|&
name|column_table
index|[
name|cbp
operator|->
name|cb_fields
index|[
name|i
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|cbp
operator|->
name|cb_fields
index|[
name|i
index|]
condition|)
block|{
case|case
name|ZPOOL_FIELD_NAME
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_FIELD_SIZE
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|total
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_FIELD_USED
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|used
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_FIELD_AVAILABLE
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|total
operator|-
name|used
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_FIELD_CAPACITY
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|capacity
init|=
operator|(
name|total
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|used
operator|*
literal|100
operator|/
name|total
operator|)
operator|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llu%%"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|capacity
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_FIELD_HEALTH
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"FAULTED"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|state_to_name
argument_list|(
name|vs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_FIELD_ROOT
case|:
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zpool_get_root
argument_list|(
name|zhp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|col
operator|->
name|cd_justify
operator|==
name|left_justify
condition|)
name|fmt
operator|=
literal|"%-*s"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%*s"
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|fmt
argument_list|,
name|i
operator|==
name|cbp
operator|->
name|cb_fieldcount
operator|-
literal|1
condition|?
name|strlen
argument_list|(
name|buf
argument_list|)
else|:
name|col
operator|->
name|cd_width
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool list [-H] [-o field[,field]*] [pool] ...  *  *	-H	Scripted mode.  Don't display headers, and separate fields by  *		a single tab.  *	-o	List of fields to display.  Defaults to all fields, or  *		"name,size,used,available,capacity,health,root"  *  * List all pools in the system, whether or not they're healthy.  Output space  * statistics for each one, as well as health status summary.  */
end_comment

begin_function
name|int
name|zpool_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|list_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|char
name|default_fields
index|[]
init|=
literal|"name,size,used,available,capacity,health,root"
decl_stmt|;
name|char
modifier|*
name|fields
init|=
name|default_fields
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":Ho:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fields
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
while|while
condition|(
operator|*
name|fields
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|cb_fieldcount
operator|==
name|MAX_FIELDS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many "
literal|"properties given to -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cb
operator|.
name|cb_fields
index|[
name|cb
operator|.
name|cb_fieldcount
index|]
operator|=
name|getsubopt
argument_list|(
operator|&
name|fields
argument_list|,
name|column_subopts
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_fieldcount
operator|++
expr_stmt|;
block|}
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|zpool_get_vdev_by_name
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
name|match
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|match
operator|=
name|zpool_get_vdev_by_name
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|match
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zpool_do_attach_or_replace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|,
modifier|*
name|old_disk
decl_stmt|,
modifier|*
name|new_disk
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|log_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|log_argv
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|log_argc
operator|=
name|argc
expr_stmt|;
name|log_argv
operator|=
name|argv
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|old_disk
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<new_device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|new_disk
operator|=
name|old_disk
expr_stmt|;
name|argc
operator|-=
literal|1
expr_stmt|;
name|argv
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|new_disk
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"pool '%s' is unavailable\n"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nvroot
operator|=
name|make_root_vdev
argument_list|(
name|config
argument_list|,
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|replacing
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvroot
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|zpool_vdev_attach
argument_list|(
name|zhp
argument_list|,
name|old_disk
argument_list|,
name|new_disk
argument_list|,
name|nvroot
argument_list|,
name|replacing
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|log_argc
argument_list|,
name|log_argv
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool replace [-f]<pool><device><new_device>  *  *	-f	Force attach, even if<new_device> appears to be in use.  *  * Replace<device> with<new_device>.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_replace
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zpool_do_attach_or_replace
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool attach [-f]<pool><device><new_device>  *  *	-f	Force attach, even if<new_device> appears to be in use.  *  * Attach<new_device> to the mirror containing<device>.  If<device> is not  * part of a mirror, then<device> will be transformed into a mirror of  *<device> and<new_device>.  In either case,<new_device> will begin life  * with a DTL of [0, now], and will immediately begin to resilver itself.  */
end_comment

begin_function
name|int
name|zpool_do_attach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|zpool_do_attach_or_replace
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool detach [-f]<pool><device>  *  *	-f	Force detach of<device>, even if DTLs argue against it  *		(not supported yet)  *  * Detach a device from a mirror.  The operation will be refused if<device>  * is the last device in the mirror, or if the DTLs indicate that this device  * has the only valid copy of some data.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_detach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing<device> specification\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
name|zpool_vdev_detach
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool online<pool><device> ...  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_online
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"t"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|zpool_vdev_online
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Bringing device %s online\n"
argument_list|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool offline [-ft]<pool><device> ...  *  *	-f	Force the device into the offline state, even if doing  *		so would appear to compromise pool availability.  *		(not supported yet)  *  *	-t	Only take the device off-line temporarily.  The offline  *		state will not be persistent across reboots.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zpool_do_offline
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|istmp
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ft"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|istmp
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* get pool name and check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing device name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|poolname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|zpool_vdev_offline
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|istmp
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Bringing device %s offline\n"
argument_list|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|poolname
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool clear<pool> [device]  *  * Clear all errors associated with a pool or a particular device.  */
end_comment

begin_function
name|int
name|zpool_do_clear
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|pool
decl_stmt|,
modifier|*
name|device
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|pool
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|device
operator|=
name|argc
operator|==
literal|3
condition|?
name|argv
index|[
literal|2
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_clear
argument_list|(
name|zhp
argument_list|,
name|device
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|scrub_cbdata
block|{
name|int
name|cb_type
decl_stmt|;
name|int
name|cb_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|cb_argv
decl_stmt|;
block|}
name|scrub_cbdata_t
typedef|;
end_typedef

begin_function
name|int
name|scrub_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|scrub_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Ignore faulted pools. 	 */
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot scrub '%s': pool is "
literal|"currently unavailable\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zpool_scrub
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|cb
operator|->
name|cb_argc
argument_list|,
name|cb
operator|->
name|cb_argv
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool scrub [-s]<pool> ...  *  *	-s	Stop.  Stops any in-progress scrub.  */
end_comment

begin_function
name|int
name|zpool_do_scrub
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|scrub_cbdata_t
name|cb
decl_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|POOL_SCRUB_EVERYTHING
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"s"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|cb
operator|.
name|cb_type
operator|=
name|POOL_SCRUB_NONE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|cb
operator|.
name|cb_argc
operator|=
name|argc
expr_stmt|;
name|cb
operator|.
name|cb_argv
operator|=
name|argv
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|scrub_callback
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|status_cbdata
block|{
name|int
name|cb_count
decl_stmt|;
name|boolean_t
name|cb_allpools
decl_stmt|;
name|boolean_t
name|cb_verbose
decl_stmt|;
name|boolean_t
name|cb_explain
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
block|}
name|status_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Print out detailed scrub status.  */
end_comment

begin_function
name|void
name|print_scrub_status
parameter_list|(
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|time_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|now
decl_stmt|;
name|double
name|fraction_done
decl_stmt|;
name|uint64_t
name|examined
decl_stmt|,
name|total
decl_stmt|,
name|minutes_left
decl_stmt|;
name|char
modifier|*
name|scrub_type
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there's never been a scrub, there's not much to say. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_scrub_end
operator|==
literal|0
operator|&&
name|vs
operator|->
name|vs_scrub_type
operator|==
name|POOL_SCRUB_NONE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"none requested\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|scrub_type
operator|=
operator|(
name|vs
operator|->
name|vs_scrub_type
operator|==
name|POOL_SCRUB_RESILVER
operator|)
condition|?
literal|"resilver"
else|:
literal|"scrub"
expr_stmt|;
name|start
operator|=
name|vs
operator|->
name|vs_scrub_start
expr_stmt|;
name|end
operator|=
name|vs
operator|->
name|vs_scrub_end
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|examined
operator|=
name|vs
operator|->
name|vs_scrub_examined
expr_stmt|;
name|total
operator|=
name|vs
operator|->
name|vs_alloc
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s %s with %llu errors on %s"
argument_list|)
argument_list|,
name|scrub_type
argument_list|,
name|vs
operator|->
name|vs_scrub_complete
condition|?
literal|"completed"
else|:
literal|"stopped"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|vs
operator|->
name|vs_scrub_errors
argument_list|,
name|ctime
argument_list|(
operator|&
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|examined
operator|==
literal|0
condition|)
name|examined
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|examined
operator|>
name|total
condition|)
name|total
operator|=
name|examined
expr_stmt|;
name|fraction_done
operator|=
operator|(
name|double
operator|)
name|examined
operator|/
name|total
expr_stmt|;
name|minutes_left
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|now
operator|-
name|start
operator|)
operator|*
operator|(
literal|1
operator|-
name|fraction_done
operator|)
operator|/
name|fraction_done
operator|/
literal|60
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s in progress, %.2f%% done, %lluh%um to go\n"
argument_list|)
argument_list|,
name|scrub_type
argument_list|,
literal|100
operator|*
name|fraction_done
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|minutes_left
operator|/
literal|60
argument_list|)
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|minutes_left
operator|%
literal|60
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|spare_cbdata
block|{
name|uint64_t
name|cb_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|cb_zhp
decl_stmt|;
block|}
name|spare_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|boolean_t
name|find_vdev
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|uint64_t
name|search
parameter_list|)
block|{
name|uint64_t
name|guid
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
operator|&&
name|search
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_vdev
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_spare
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|spare_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_vdev
argument_list|(
name|nvroot
argument_list|,
name|cbp
operator|->
name|cb_guid
argument_list|)
condition|)
block|{
name|cbp
operator|->
name|cb_zhp
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out configuration state as requested by status_callback.  */
end_comment

begin_function
name|void
name|print_status_config
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|namewidth
parameter_list|,
name|int
name|depth
parameter_list|,
name|boolean_t
name|isspare
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|char
name|rbuf
index|[
literal|6
index|]
decl_stmt|,
name|wbuf
index|[
literal|6
index|]
decl_stmt|,
name|cbuf
index|[
literal|6
index|]
decl_stmt|,
name|repaired
index|[
literal|7
index|]
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|uint64_t
name|notpresent
decl_stmt|;
name|spare_cbdata_t
name|cb
decl_stmt|;
specifier|const
name|char
modifier|*
name|state
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
name|children
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|state_to_name
argument_list|(
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspare
condition|)
block|{
comment|/* 		 * For hot spares, we use the terms 'INUSE' and 'AVAILABLE' for 		 * online drives. 		 */
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_SPARED
condition|)
name|state
operator|=
literal|"INUSE"
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
name|state
operator|=
literal|"AVAIL"
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%-*s  %-8s"
argument_list|,
name|depth
argument_list|,
literal|""
argument_list|,
name|namewidth
operator|-
name|depth
argument_list|,
name|name
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspare
condition|)
block|{
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_read_errors
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_write_errors
argument_list|,
name|wbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_checksum_errors
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %5s %5s %5s"
argument_list|,
name|rbuf
argument_list|,
name|wbuf
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|notpresent
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  was %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_aux
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vs
operator|->
name|vs_aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"cannot open"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"missing device"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"insufficient replicas"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"newer version"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_SPARED
case|:
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|cb
operator|.
name|cb_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|find_spare
argument_list|,
operator|&
name|cb
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"currently in "
literal|"use"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"in use by "
literal|"pool '%s'"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"currently in use"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"corrupted data"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_scrub_repaired
operator|!=
literal|0
operator|&&
name|children
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Report bytes resilvered/repaired on leaf devices. 		 */
name|zfs_nicenum
argument_list|(
name|vs
operator|->
name|vs_scrub_repaired
argument_list|,
name|repaired
argument_list|,
sizeof|sizeof
argument_list|(
name|repaired
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  %s %s"
argument_list|)
argument_list|,
name|repaired
argument_list|,
operator|(
name|vs
operator|->
name|vs_scrub_type
operator|==
name|POOL_SCRUB_RESILVER
operator|)
condition|?
literal|"resilvered"
else|:
literal|"repaired"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|namewidth
argument_list|,
name|depth
operator|+
literal|2
argument_list|,
name|isspare
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_error_log
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nverrlist
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|size_t
name|len
init|=
name|MAXPATHLEN
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|zpool_get_errlog
argument_list|(
name|zhp
argument_list|,
operator|&
name|nverrlist
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"errors: List of errors unavailable "
literal|"(insufficient privileges)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"errors: Permanent errors have been "
literal|"detected in the following files:\n\n"
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|safe_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nverrlist
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|obj
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_DATASET
argument_list|,
operator|&
name|dsobj
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_OBJECT
argument_list|,
operator|&
name|obj
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zpool_obj_to_path
argument_list|(
name|zhp
argument_list|,
name|dsobj
argument_list|,
name|obj
argument_list|,
name|pathname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %s\n"
argument_list|,
literal|""
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nverrlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_spares
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|spares
parameter_list|,
name|uint_t
name|nspares
parameter_list|,
name|int
name|namewidth
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\tspares\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|zpool_vdev_name
argument_list|(
name|g_zfs
argument_list|,
name|zhp
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|name
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|namewidth
argument_list|,
literal|2
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display a summary of pool status.  Displays a summary such as:  *  *        pool: tank  *	status: DEGRADED  *	reason: One or more devices ...  *         see: http://www.sun.com/msg/ZFS-xxxx-01  *	config:  *		mirror		DEGRADED  *                c1t0d0	OK  *                c2t0d0	UNAVAIL  *  * When given the '-v' option, we print out the complete config.  If the '-e'  * option is specified, then we print out error rate information as well.  */
end_comment

begin_function
name|int
name|status_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|status_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|int
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|health
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reason
operator|=
name|zpool_get_status
argument_list|(
name|zhp
argument_list|,
operator|&
name|msgid
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_count
operator|++
expr_stmt|;
comment|/* 	 * If we were given 'zpool status -x', only report those pools with 	 * problems. 	 */
if|if
condition|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
operator|&&
name|cbp
operator|->
name|cb_explain
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_allpools
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"pool '%s' is healthy\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|health
operator|=
name|state_to_name
argument_list|(
name|vs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"  pool: %s\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" state: %s\n"
argument_list|)
argument_list|,
name|health
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|ZPOOL_STATUS_MISSING_DEV_R
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be opened.  Sufficient replicas exist for\n\tthe pool to "
literal|"continue functioning in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Attach the missing device and "
literal|"online it using 'zpool online'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_MISSING_DEV_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be opened.  There are insufficient\n\treplicas for the "
literal|"pool to continue functioning.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Attach the missing device and "
literal|"online it using 'zpool online'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_R
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be used because the label is missing or\n\tinvalid.  "
literal|"Sufficient replicas exist for the pool to continue\n\t"
literal|"functioning in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Replace the device using "
literal|"'zpool replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices could not "
literal|"be used because the label is missing \n\tor invalid.  "
literal|"There are insufficient replicas for the pool to "
literal|"continue\n\tfunctioning.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Destroy and re-create the pool "
literal|"from a backup source.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_FAILING_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"experienced an unrecoverable error.  An\n\tattempt was "
literal|"made to correct the error.  Applications are "
literal|"unaffected.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Determine if the device needs "
literal|"to be replaced, and clear the errors\n\tusing "
literal|"'zpool clear' or replace the device with 'zpool "
literal|"replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_OFFLINE_DEV
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"been taken offline by the administrator.\n\tSufficient "
literal|"replicas exist for the pool to continue functioning in "
literal|"a\n\tdegraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Online the device using "
literal|"'zpool online' or replace the device with\n\t'zpool "
literal|"replace'.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_RESILVERING
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices is "
literal|"currently being resilvered.  The pool will\n\tcontinue "
literal|"to function, possibly in a degraded state.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Wait for the resilver to "
literal|"complete.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_DATA
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: One or more devices has "
literal|"experienced an error resulting in data\n\tcorruption.  "
literal|"Applications may be affected.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Restore the file in question "
literal|"if possible.  Otherwise restore the\n\tentire pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_CORRUPT_POOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool metadata is corrupted "
literal|"and the pool cannot be opened.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Destroy and re-create the pool "
literal|"from a backup source.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_OLDER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool is formatted using an "
literal|"older on-disk format.  The pool can\n\tstill be used, but "
literal|"some features are unavailable.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Upgrade the pool using 'zpool "
literal|"upgrade'.  Once this is done, the\n\tpool will no longer "
literal|"be accessible on older software versions.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_STATUS_VERSION_NEWER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"status: The pool has been upgraded to a "
literal|"newer, incompatible on-disk version.\n\tThe pool cannot "
literal|"be accessed on this system.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"action: Access the pool from a system "
literal|"running more recent software, or\n\trestore the pool from "
literal|"backup.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * The remaining errors can't actually be generated, yet. 		 */
name|assert
argument_list|(
name|reason
operator|==
name|ZPOOL_STATUS_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"   see: http://www.sun.com/msg/%s\n"
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|int
name|namewidth
decl_stmt|;
name|uint64_t
name|nerr
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" scrub: "
argument_list|)
argument_list|)
expr_stmt|;
name|print_scrub_status
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|namewidth
operator|=
name|max_width
argument_list|(
name|zhp
argument_list|,
name|nvroot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namewidth
operator|<
literal|10
condition|)
name|namewidth
operator|=
literal|10
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"config:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\t%-*s  %-8s %5s %5s %5s\n"
argument_list|)
argument_list|,
name|namewidth
argument_list|,
literal|"NAME"
argument_list|,
literal|"STATE"
argument_list|,
literal|"READ"
argument_list|,
literal|"WRITE"
argument_list|,
literal|"CKSUM"
argument_list|)
expr_stmt|;
name|print_status_config
argument_list|(
name|zhp
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|nvroot
argument_list|,
name|namewidth
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
name|print_spares
argument_list|(
name|zhp
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|namewidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|nerr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|nverrlist
init|=
name|NULL
decl_stmt|;
comment|/* 			 * If the approximate error count is small, get a 			 * precise count by fetching the entire log and 			 * uniquifying the results. 			 */
if|if
condition|(
name|nerr
operator|<
literal|100
operator|&&
operator|!
name|cbp
operator|->
name|cb_verbose
operator|&&
name|zpool_get_errlog
argument_list|(
name|zhp
argument_list|,
operator|&
name|nverrlist
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
name|nerr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nverrlist
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nerr
operator|++
expr_stmt|;
block|}
block|}
name|nvlist_free
argument_list|(
name|nverrlist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"errors: No known data "
literal|"errors\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"errors: %llu data "
literal|"errors, use '-v' for a list\n"
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|nerr
argument_list|)
expr_stmt|;
else|else
name|print_error_log
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"config: The configuration cannot be "
literal|"determined.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool status [-vx] [pool] ...  *  *	-v	Display complete error logs  *	-x	Display only pools with potential problems  *  * Describes the health status of all pools or some subset.  */
end_comment

begin_function
name|int
name|zpool_do_status
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|status_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vx"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|cb
operator|.
name|cb_verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cb
operator|.
name|cb_explain
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|cb
operator|.
name|cb_allpools
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|status_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_count
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|.
name|cb_explain
operator|&&
name|cb
operator|.
name|cb_first
operator|&&
name|cb
operator|.
name|cb_allpools
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"all pools are healthy\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|upgrade_cbdata
block|{
name|int
name|cb_all
decl_stmt|;
name|int
name|cb_first
decl_stmt|;
name|int
name|cb_newer
decl_stmt|;
name|int
name|cb_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|cb_argv
decl_stmt|;
block|}
name|upgrade_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|upgrade_cb
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_newer
operator|&&
name|version
operator|<
name|ZFS_VERSION
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_all
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following pools are "
literal|"out of date, and can be upgraded.  After "
literal|"being\nupgraded, these pools will no "
literal|"longer be accessible by older software "
literal|"versions.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  POOL\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"---  ------------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%2llu   %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|version
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
name|zpool_upgrade
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|cbp
operator|->
name|cb_argc
argument_list|,
name|cbp
operator|->
name|cb_argv
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Successfully upgraded "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|cb_newer
operator|&&
name|version
operator|>
name|ZFS_VERSION
condition|)
block|{
name|assert
argument_list|(
operator|!
name|cbp
operator|->
name|cb_all
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following pools are "
literal|"formatted using a newer software version and\n"
literal|"cannot be accessed on the current system.\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  POOL\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"---  ------------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%2llu   %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|version
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_one
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|upgrade_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|ZFS_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Pool '%s' is already formatted "
literal|"using the current version.\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|zpool_upgrade
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|cbp
operator|->
name|cb_argc
argument_list|,
name|cbp
operator|->
name|cb_argv
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Successfully upgraded '%s' "
literal|"from version %llu to version %llu\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|version
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ZFS_VERSION
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool upgrade  * zpool upgrade -v  * zpool upgrade<-a | pool>  *  * With no arguments, display downrev'd ZFS pool available for upgrade.  * Individual pools can be upgraded by specifying the pool, and '-a' will  * upgrade all pools.  */
end_comment

begin_function
name|int
name|zpool_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|upgrade_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|showversions
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"av"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|cb
operator|.
name|cb_all
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|showversions
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|cb
operator|.
name|cb_argc
operator|=
name|argc
expr_stmt|;
name|cb
operator|.
name|cb_argv
operator|=
name|argv
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|showversions
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|cb_all
operator|||
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-v option is "
literal|"incompatible with other arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cb
operator|.
name|cb_all
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-a option is "
literal|"incompatible with other arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"This system is currently running ZFS version "
literal|"%llu.\n\n"
argument_list|)
argument_list|,
name|ZFS_VERSION
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|showversions
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following versions are "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  DESCRIPTION\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  -----------------------------------------"
literal|"---------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 1   Initial ZFS version\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 2   Ditto blocks "
literal|"(replicated metadata)\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 3   Hot spares and double parity "
literal|"RAID-Z\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 4   zpool history\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 5   Compression using the gzip "
literal|"algorithm\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 6   bootfs pool property "
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nFor more information on a particular "
literal|"version, including supported releases, see:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"http://www.opensolaris.org/os/community/zfs/"
literal|"version/N\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Where 'N' is the version number.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|int
name|notfound
decl_stmt|;
name|ret
operator|=
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|upgrade_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|notfound
operator|=
name|cb
operator|.
name|cb_first
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_all
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_first
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_newer
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|upgrade_cb
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_first
condition|)
block|{
name|notfound
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|notfound
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All pools are formatted "
literal|"using this version.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_all
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Use 'zpool upgrade -v' "
literal|"for a list of available versions and "
literal|"their associated\nfeatures.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|upgrade_one
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the command history for a specific pool.  */
end_comment

begin_function
specifier|static
name|int
name|get_history_one
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvhis
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|records
decl_stmt|;
name|uint_t
name|numrecords
decl_stmt|;
name|char
modifier|*
name|cmdstr
decl_stmt|;
name|uint64_t
name|dst_time
decl_stmt|;
name|time_t
name|tsec
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|char
name|tbuf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
operator|*
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"History for '%s':\n"
argument_list|)
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zpool_get_history
argument_list|(
name|zhp
argument_list|,
operator|&
name|nvhis
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvhis
argument_list|,
name|ZPOOL_HIST_RECORD
argument_list|,
operator|&
name|records
argument_list|,
operator|&
name|numrecords
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrecords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|records
index|[
name|i
index|]
argument_list|,
name|ZPOOL_HIST_TIME
argument_list|,
operator|&
name|dst_time
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|records
index|[
name|i
index|]
argument_list|,
name|ZPOOL_HIST_CMD
argument_list|,
operator|&
name|cmdstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tsec
operator|=
name|dst_time
expr_stmt|;
operator|(
name|void
operator|)
name|localtime_r
argument_list|(
operator|&
name|tsec
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%F.%T"
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|tbuf
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvhis
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool history<pool>  *  * Displays the history of commands that modified pools.  */
end_comment

begin_function
name|int
name|zpool_do_history
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|get_history_one
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|first
operator|==
name|B_TRUE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no pools available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|libzfs_get_cbdata_t
modifier|*
name|cbp
init|=
operator|(
name|libzfs_get_cbdata_t
operator|*
operator|)
name|data
decl_stmt|;
name|char
name|value
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|zfs_source_t
name|srctype
decl_stmt|;
name|zpool_proplist_t
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
name|cbp
operator|->
name|cb_proplist
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * Skip the special fake placeholder. 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|pl
operator|==
name|cbp
operator|->
name|cb_proplist
condition|)
continue|continue;
if|if
condition|(
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|srctype
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|libzfs_print_one_property
argument_list|(
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|value
argument_list|,
name|srctype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|libzfs_get_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zpool_proplist_t
name|fake_name
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_sources
operator|=
name|ZFS_SRC_ALL
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
if|if
condition|(
name|zpool_get_proplist
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|!=
name|NULL
condition|)
block|{
name|fake_name
operator|.
name|pl_prop
operator|=
name|ZFS_PROP_NAME
expr_stmt|;
name|fake_name
operator|.
name|pl_width
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|fake_name
operator|.
name|pl_next
operator|=
name|cb
operator|.
name|cb_proplist
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
operator|&
name|fake_name
expr_stmt|;
block|}
name|ret
operator|=
name|for_each_pool
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|get_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|==
operator|&
name|fake_name
condition|)
name|zfs_free_proplist
argument_list|(
name|fake_name
operator|.
name|pl_next
argument_list|)
expr_stmt|;
else|else
name|zfs_free_proplist
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|set_cbdata
block|{
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|char
modifier|*
name|cb_value
decl_stmt|;
name|boolean_t
name|cb_any_successful
decl_stmt|;
block|}
name|set_cbdata_t
typedef|;
end_typedef

begin_function
name|int
name|set_callback
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|set_cbdata_t
modifier|*
name|cb
init|=
operator|(
name|set_cbdata_t
operator|*
operator|)
name|data
decl_stmt|;
name|error
operator|=
name|zpool_set_prop
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_propname
argument_list|,
name|cb
operator|->
name|cb_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cb
operator|->
name|cb_any_successful
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|set_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property=value "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing pool name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many pool names\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_propname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|=
name|strchr
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_value
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing value in "
literal|"property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|cb
operator|.
name|cb_value
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|++
expr_stmt|;
name|error
operator|=
name|for_each_pool
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|,
name|set_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_any_successful
condition|)
block|{
operator|*
operator|(
name|cb
operator|.
name|cb_value
operator|-
literal|1
operator|)
operator|=
literal|'='
expr_stmt|;
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_command_idx
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TEXT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure the user has specified some command. 	 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing command\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cmdname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Special case '-?' 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Run the appropriate command. 	 */
if|if
condition|(
name|find_command_idx
argument_list|(
name|cmdname
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
comment|/* 	 * 'freeze' is a vile debugging abomination, so we treat it as such. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"freeze"
argument_list|)
operator|==
literal|0
operator|&&
name|argc
operator|==
literal|3
condition|)
block|{
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|ioctl
argument_list|(
name|fd
argument_list|,
name|ZFS_IOC_POOL_FREEZE
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"unrecognized "
literal|"command '%s'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'ZFS_ABORT' environment variable causes us to dump core on exit 	 * for the purposes of running ::findleaks. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

