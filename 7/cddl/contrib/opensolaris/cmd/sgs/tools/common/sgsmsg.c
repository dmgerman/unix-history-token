begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  *  * sgsmsg generates several message files from an input template file.  Messages  * are constructed for use with gettext(3i) - the default - or catgets(3c).  The  * files generate are:  *  * msg.h	a header file containing definitions for each message.  The -h  *		option triggers the creation of these definitions and specifies  *		the name to use.  *  * msg.c	a data array of message strings.  The msg.h definitions are  *		offsets into this array.  The -d option triggers the creation of  *		these definitions and specifies the name to use.  *  * messages	a message file suitable for catgets(3c) or gettext(3i) use.  The  *		-m option triggers this output and specifies the filename to be  *		used.  *  * The template file is processed based on the first character of each line:  *  * # or $	entries are copied (as is) to the message file (messages).  *  * @ token(s)	entries are translated.  Two translations are possible dependent  *		on whether one or more tokens are supplied:  *  *		A single token is interpreted as one of two reserved message  *		output indicators, or a message identifier.  The reserved output  *		indicator _START_ enables output to the message file - Note that  *		the occurance of any other @ token will also enable message  *		output.  The reserved output indicator _END_ disables output to  *		the message file.  The use of these two indicators provides for  *		only those message strings that require translation to be output  *		to the message file.  *  *		Besides the reserved output indicators, a single token is taken  *		to be a message identifier which will be subsituted for a  *		`setid' for catgets(3c) output, or a `domain' name for  *		gettext(3i) output.  This value is determine by substituting the  *		token for the associated definition found in the message  *		identifier file (specified with the -i option).  *  *		Multiple tokens are taken to be a message definition followed by  *		the associated message string.  The message string is copied to  *		the data array being built in msg.c.  The index into this array  *		becomes the `message' identifier created in the msg.h file.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_include
include|#
directive|include
file|<_string_table.h>
end_include

begin_comment
comment|/*  * Define any error message strings.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|Errmsg_malt
init|=
literal|"sgsmsg: file %s: line %d: malformed input "
literal|"at line\n"
decl_stmt|,
modifier|*
name|Errmsg_nmem
init|=
literal|"sgsmsg: memory allocation failed: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_opne
init|=
literal|"sgsmsg: file %s: open failed: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_wrte
init|=
literal|"sgsmsg: file %s: write failed: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_read
init|=
literal|"sgsmsg: file %s: read failed %s\n"
decl_stmt|,
modifier|*
name|Errmsg_stnw
init|=
literal|"sgsmsg: st_new(): failed: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_stin
init|=
literal|"sgsmsg: Str_tbl insert failed: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_mnfn
init|=
literal|"sgsmsg: message not found in Str_tbl: %s\n"
decl_stmt|,
modifier|*
name|Errmsg_use
init|=
literal|"usage: sgsmsg [-clv] [-d mesgdata] [-h mesgdefs] "
literal|"[-m messages] [-n name] [-i mesgident] file ...\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define all output filenames and associated descriptors.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fddefs
decl_stmt|,
modifier|*
name|fddata
decl_stmt|,
modifier|*
name|fdmsgs
decl_stmt|,
modifier|*
name|fdmids
decl_stmt|,
modifier|*
name|fddesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fldefs
decl_stmt|,
modifier|*
name|fldata
decl_stmt|,
modifier|*
name|flmsgs
decl_stmt|,
modifier|*
name|flmids
decl_stmt|,
modifier|*
name|fldesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fdlint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fllint
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose flag */
end_comment

begin_decl_stmt
specifier|static
name|Str_tbl
modifier|*
name|stp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string table */
end_comment

begin_comment
comment|/*  * Define any default strings.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|nmlint
init|=
literal|"/tmp/sgsmsg.lint"
decl_stmt|,
modifier|*
name|interface
init|=
literal|"sgs_msg"
decl_stmt|,
modifier|*
name|start
init|=
literal|"_START_"
decl_stmt|,
modifier|*
name|end
init|=
literal|"_END_"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define any default flags and data items.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cflag
init|=
literal|0
decl_stmt|,
name|lflag
init|=
literal|0
decl_stmt|,
name|prtmsgs
init|=
literal|0
decl_stmt|,
name|line
decl_stmt|,
name|ptr
init|=
literal|1
decl_stmt|,
name|msgid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mesgid
init|=
literal|0
decl_stmt|,
modifier|*
name|setid
init|=
literal|0
decl_stmt|,
modifier|*
name|domain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|msg_string
block|{
name|char
modifier|*
name|ms_defn
decl_stmt|;
name|char
modifier|*
name|ms_message
decl_stmt|;
name|struct
name|msg_string
modifier|*
name|ms_next
decl_stmt|;
block|}
name|msg_string
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|msg_string
modifier|*
name|msg_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|msg_string
modifier|*
name|msg_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * message_append() is responsible for both inserting strings into  * the master Str_tbl as well as maintaining a list of the  * DEFINITIONS associated with each string.  *  * The list of strings is traversed at the end once the full  * Str_tbl has been constructed - and string offsets can be  * assigned.  */
end_comment

begin_function
specifier|static
name|void
name|message_append
parameter_list|(
specifier|const
name|char
modifier|*
name|defn
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|msg_string
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|msg_string
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the string table. 	 */
if|if
condition|(
operator|(
name|stp
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|stp
operator|=
name|st_new
argument_list|(
name|FLG_STNEW_COMPRESS
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_stnw
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|msg
operator|->
name|ms_defn
operator|=
name|strdup
argument_list|(
name|defn
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|msg
operator|->
name|ms_message
operator|=
name|strdup
argument_list|(
name|message
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st_insert
argument_list|(
name|stp
argument_list|,
name|msg
operator|->
name|ms_message
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_stin
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg_head
operator|==
literal|0
condition|)
block|{
name|msg_head
operator|=
name|msg_tail
operator|=
name|msg
expr_stmt|;
return|return;
block|}
name|msg_tail
operator|->
name|ms_next
operator|=
name|msg
expr_stmt|;
name|msg_tail
operator|=
name|msg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a setid value.  Given a setid definition determine its numeric  * value from the specified message identifier file (specified with the -i  * option).  Return a pointer to the numeric string.  */
end_comment

begin_function
specifier|static
name|int
name|getmesgid
parameter_list|(
name|char
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|_mesgid
init|=
literal|0
decl_stmt|,
modifier|*
name|_setid
init|=
literal|0
decl_stmt|,
modifier|*
name|_domain
init|=
literal|0
decl_stmt|;
comment|/* 	 * If we're being asked to interpret a message id but the user didn't 	 * provide the required message identifier file (-i option) we're in 	 * trouble. 	 */
if|if
condition|(
name|flmids
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sgsmsg: file %s: line %d: mesgid %s: "
literal|"unable to process mesgid\n\t"
literal|"no message identifier file specified "
literal|"(see -i option)\n"
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|buffer
operator|=
name|malloc
argument_list|(
name|LINE_MAX
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read the message identifier file and locate the required mesgid. 	 */
name|rewind
argument_list|(
name|fdmids
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
name|fdmids
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Establish individual strings for the mesgid, setid and domain 		 * values. 		 */
name|_mesgid
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
operator|)
condition|)
name|token
operator|++
expr_stmt|;
operator|*
name|token
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
condition|)
name|token
operator|++
expr_stmt|;
name|_setid
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
operator|)
condition|)
name|token
operator|++
expr_stmt|;
operator|*
name|token
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
condition|)
name|token
operator|++
expr_stmt|;
name|_domain
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
operator|)
condition|)
name|token
operator|++
expr_stmt|;
operator|*
name|token
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Did we find a match? 	 */
if|if
condition|(
operator|(
name|_mesgid
operator|==
literal|0
operator|)
operator|||
operator|(
name|_setid
operator|==
literal|0
operator|)
operator|||
operator|(
name|_domain
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sgsmsg: file %s: line %d: mesgid %s: "
literal|"unable to process mesgid\n\t"
literal|"identifier does not exist in file %s\n"
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|,
name|id
argument_list|,
name|flmids
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Have we been here before? 	 */
if|if
condition|(
name|mesgid
condition|)
block|{
if|if
condition|(
name|cflag
operator|==
literal|1
condition|)
block|{
comment|/* 			 * If we're being asked to process more than one mesgid 			 * warn the user that only one mesgid can be used for 			 * the catgets(3c) call. 			 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sgsmsg: file %s: line %d: "
literal|"setid %s: warning: multiple mesgids "
literal|"encountered\n\t"
literal|"last setting used in messaging code\n"
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|mesgid
operator|=
name|_mesgid
expr_stmt|;
name|setid
operator|=
name|_setid
expr_stmt|;
name|domain
operator|=
name|_domain
expr_stmt|;
comment|/* 	 * Generate the message file output (insure output flag is enabled). 	 */
if|if
condition|(
name|prtmsgs
operator|!=
operator|-
literal|1
condition|)
name|prtmsgs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cflag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"$quote \"\n$set %s\n"
argument_list|,
name|setid
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"domain\t\"%s\"\n"
argument_list|,
name|domain
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * For catgets(3c) output generate a setid definition in the message 	 * definition file. 	 */
if|if
condition|(
name|fddefs
operator|&&
operator|(
name|cflag
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#define\t%s\t%s\n\n"
argument_list|,
name|mesgid
argument_list|,
name|setid
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump contents of String Table to standard out  */
end_comment

begin_function
specifier|static
name|void
name|dump_stringtab
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|)
block|{
name|uint_t
name|cnt
decl_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"string table full size: %ld: uncompressed\n"
argument_list|,
name|stp
operator|->
name|st_fullstrsize
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"string table full size: %ld compressed down to: %ld\n\n"
argument_list|,
name|stp
operator|->
name|st_fullstrsize
argument_list|,
name|stp
operator|->
name|st_strsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"string table compression information [%d buckets]:\n"
argument_list|,
name|stp
operator|->
name|st_hbckcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|stp
operator|->
name|st_hbckcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|Str_hash
modifier|*
name|sthash
init|=
name|stp
operator|->
name|st_hashbcks
index|[
name|cnt
index|]
decl_stmt|;
if|if
condition|(
name|sthash
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" bucket: [%d]\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
while|while
condition|(
name|sthash
condition|)
block|{
name|size_t
name|stroff
init|=
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_strlen
operator|-
name|sthash
operator|->
name|hi_strlen
decl_stmt|;
if|if
condition|(
name|stroff
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%ld]: '%s'<master>\n"
argument_list|,
name|sthash
operator|->
name|hi_refcnt
argument_list|,
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%ld]: '%s'<suffix of: "
literal|"'%s'>\n"
argument_list|,
name|sthash
operator|->
name|hi_refcnt
argument_list|,
operator|&
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_str
index|[
name|stroff
index|]
argument_list|,
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_str
argument_list|)
expr_stmt|;
block|}
name|sthash
operator|=
name|sthash
operator|->
name|hi_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the message definition header file stream.  */
end_comment

begin_function
specifier|static
name|int
name|init_defs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|guard
index|[
name|FILENAME_MAX
operator|+
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|optr
decl_stmt|;
specifier|const
name|char
modifier|*
name|iptr
decl_stmt|,
modifier|*
name|_ptr
decl_stmt|;
comment|/* 	 * Establish a header guard name using the files basename. 	 */
for|for
control|(
name|iptr
operator|=
literal|0
operator|,
name|_ptr
operator|=
name|fldefs
init|;
name|_ptr
operator|&&
operator|(
operator|*
name|_ptr
operator|!=
literal|'\0'
operator|)
condition|;
name|_ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|_ptr
operator|==
literal|'/'
condition|)
name|iptr
operator|=
name|_ptr
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iptr
operator|==
literal|0
condition|)
name|iptr
operator|=
name|fldefs
expr_stmt|;
name|optr
operator|=
name|guard
expr_stmt|;
for|for
control|(
operator|*
name|optr
operator|++
operator|=
literal|'_'
init|;
name|iptr
operator|&&
operator|(
operator|*
name|iptr
operator|!=
literal|'\0'
operator|)
condition|;
name|iptr
operator|++
operator|,
name|optr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|iptr
operator|==
literal|'.'
condition|)
block|{
operator|*
name|optr
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|optr
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|optr
operator|++
operator|=
literal|'O'
expr_stmt|;
operator|*
name|optr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|optr
operator|=
literal|'_'
expr_stmt|;
block|}
else|else
operator|*
name|optr
operator|=
name|toupper
argument_list|(
operator|*
name|iptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#ifndef\t%s\n#define\t%s\n\n"
argument_list|,
name|guard
argument_list|,
name|guard
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#ifndef\t__lint\n\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * add "typedef int	Msg;" 	 */
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"typedef int\tMsg;\n\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the associated data array is global define a prototype. 	 * Define a macro to access the array elements. 	 */
if|if
condition|(
name|lflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"extern\tconst char\t__%s[];\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#define\tMSG_ORIG(x)\t&__%s[x]\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Generate a prototype to access the associated data array. 	 */
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"extern\tconst char *\t_%s(Msg);\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#define\tMSG_INTL(x)\t_%s(x)\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish the message definition header file.  */
end_comment

begin_function
specifier|static
name|int
name|fini_defs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"\n#else\t/* __lint */\n\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * When __lint is defined, Msg is a char *.  This allows lint to 	 * check our format strings against it's arguments. 	 */
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"\ntypedef char *\tMsg;\n\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"extern\tconst char *\t_%s(Msg);\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"extern\tconst char\t__%s[];\n\n"
argument_list|,
name|interface
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#define MSG_ORIG(x)\tx\n#define MSG_INTL(x)\tx\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Copy the temporary lint defs file into the new header. 	 */
if|if
condition|(
name|fdlint
condition|)
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size
operator|=
name|ftell
argument_list|(
name|fdlint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rewind
argument_list|(
name|fdlint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|fdlint
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_read
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|fddefs
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"\n#endif\t/* __lint */\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"\n#endif\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The entire messaging file has been scanned - and all strings have been  * inserted into the string_table.  We can now walk the message queue  * and create the '#define<DEFN>' for each string - with the strings  * assigned offset into the string_table.  */
end_comment

begin_function
specifier|static
name|int
name|output_defs
parameter_list|(
name|void
parameter_list|)
block|{
name|msg_string
modifier|*
name|msg
decl_stmt|;
name|size_t
name|stbufsize
decl_stmt|;
name|char
modifier|*
name|stbuf
decl_stmt|;
name|stbufsize
operator|=
name|st_getstrtab_sz
argument_list|(
name|stp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stbuf
operator|=
name|malloc
argument_list|(
name|stbufsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|st_setstrbuf
argument_list|(
name|stp
argument_list|,
name|stbuf
argument_list|,
name|stbufsize
argument_list|)
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|msg_head
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|ms_next
control|)
block|{
name|size_t
name|stoff
decl_stmt|;
if|if
condition|(
operator|(
name|st_setstring
argument_list|(
name|stp
argument_list|,
name|msg
operator|->
name|ms_message
argument_list|,
operator|&
name|stoff
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_mnfn
argument_list|,
name|msg
operator|->
name|ms_message
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"\n#define\t%s\t%ld\n"
argument_list|,
name|msg
operator|->
name|ms_defn
argument_list|,
name|stoff
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fddefs
operator|&&
name|fprintf
argument_list|(
name|fddefs
argument_list|,
literal|"#define\t%s_SIZE\t%d\n"
argument_list|,
name|msg
operator|->
name|ms_defn
argument_list|,
name|strlen
argument_list|(
name|msg
operator|->
name|ms_message
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish off the data structure definition.  */
end_comment

begin_function
specifier|static
name|int
name|output_data
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|stbufsize
decl_stmt|;
name|size_t
name|ndx
decl_stmt|;
name|size_t
name|column
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|stbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmtstr
decl_stmt|;
name|stbufsize
operator|=
name|st_getstrtab_sz
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|stbuf
operator|=
name|st_getstrbuf
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Determine from the local flag whether the data declaration should 	 * be static. 	 */
if|if
condition|(
name|lflag
condition|)
name|fmtstr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|"static const"
expr_stmt|;
else|else
name|fmtstr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|"const"
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fddata
argument_list|,
literal|"\n%s char __%s[%ld] = { "
argument_list|,
name|fmtstr
argument_list|,
name|interface
argument_list|,
name|stbufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldata
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
operator|(
name|stbufsize
operator|-
literal|1
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|column
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fddata
operator|&&
name|fprintf
argument_list|(
name|fddata
argument_list|,
literal|"\n/* %4ld */ 0x%.2x,"
argument_list|,
name|ndx
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|stbuf
index|[
name|ndx
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldata
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fddata
operator|&&
name|fprintf
argument_list|(
name|fddata
argument_list|,
literal|"  0x%.2x,"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|stbuf
index|[
name|ndx
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldata
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|column
operator|++
operator|==
literal|10
condition|)
name|column
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|1
condition|)
name|fmtstr
operator|=
literal|"\n\t0x%.2x };\n"
expr_stmt|;
else|else
name|fmtstr
operator|=
literal|"  0x%.2x };\n"
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fddata
argument_list|,
name|fmtstr
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|stbuf
index|[
name|stbufsize
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fldata
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file
parameter_list|()
block|{
name|char
name|buffer
index|[
name|LINE_MAX
index|]
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|uint_t
name|bufsize
decl_stmt|;
name|char
modifier|*
name|token_buffer
decl_stmt|;
name|int
name|escape
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|token_buffer
operator|=
name|malloc
argument_list|(
name|LINE_MAX
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bufsize
operator|=
name|LINE_MAX
expr_stmt|;
name|line
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
name|fddesc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|defn
index|[
name|PATH_MAX
index|]
decl_stmt|,
modifier|*
name|_defn
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
operator|*
name|token
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|escape
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_malt
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * If a msgid has been output a msgstr must follow 			 * before we digest the new token.  A msgid is only set 			 * if fdmsgs is in use. 			 */
if|if
condition|(
name|msgid
condition|)
block|{
name|msgid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"msgstr\t\"\"\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 			 * Pass lines directly through to the output message 			 * file. 			 */
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
condition|)
block|{
name|char
name|comment
decl_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
name|comment
operator|=
literal|'#'
expr_stmt|;
else|else
name|comment
operator|=
literal|'$'
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"%c%s"
argument_list|,
name|comment
argument_list|,
operator|++
name|token
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|escape
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_malt
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * If a msgid has been output a msgstr must follow 			 * before we digest the new token. 			 */
if|if
condition|(
name|msgid
condition|)
block|{
name|msgid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"msgstr\t\"\"\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 			 * Determine whether we have one or more tokens. 			 */
name|token
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
condition|)
comment|/* rid any whitespace */
name|token
operator|++
expr_stmt|;
name|_defn
operator|=
name|token
expr_stmt|;
comment|/* definition start */
while|while
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
operator|)
condition|)
name|token
operator|++
expr_stmt|;
operator|*
name|token
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
condition|)
comment|/* rid any whitespace */
name|token
operator|++
expr_stmt|;
comment|/* 			 * Determine whether the single token is one of the 			 * reserved message output delimiters otherwise 			 * translate it as a message identifier. 			 */
if|if
condition|(
operator|*
name|token
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|_defn
argument_list|,
name|start
argument_list|)
operator|==
literal|0
condition|)
name|prtmsgs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|_defn
argument_list|,
name|end
argument_list|)
operator|==
literal|0
condition|)
name|prtmsgs
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|getmesgid
argument_list|(
name|_defn
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
comment|/* 			 * Multiple tokens are translated by taking the first 			 * token as the message definition, and the rest of the 			 * line as the message itself.  A message line ending 			 * with an escape ('\') is expected to be continued on 			 * the next line. 			 */
if|if
condition|(
name|prtmsgs
operator|!=
operator|-
literal|1
condition|)
name|prtmsgs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 				 * For catgets(3c) make sure a message 				 * identifier has been established (this is 				 * normally a domain for gettext(3i), but for 				 * sgsmsg use this could be argued as being 				 * redundent).  Also make sure that the message 				 * definitions haven't exceeeded the maximum 				 * value allowed by gencat(1) before generating 				 * any message file entries. 				 */
if|if
condition|(
name|cflag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|setid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file "
literal|"%s: no message identifier "
literal|"has been established\n"
argument_list|,
name|fldesc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ptr
operator|>
name|NL_MSGMAX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file "
literal|"%s: message definition "
literal|"(%d) exceeds allowable "
literal|"limit (NL_MSGMAX)\n"
argument_list|,
name|fldesc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 				 * For catgets(3c) write the definition and the 				 * message string to the message file.  For 				 * gettext(3i) write the message string as a 				 * mesgid - indicate a mesgid has been output 				 * so that a msgstr can follow. 				 */
if|if
condition|(
name|cflag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"%d\t%s"
argument_list|,
name|ptr
argument_list|,
name|token
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"msgid\t\""
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|msgid
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * The message itself is a quoted string as this makes 			 * embedding spaces at the start (or the end) of the 			 * string very easy. 			 */
if|if
condition|(
operator|*
name|token
operator|!=
literal|'"'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_malt
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|defn
argument_list|,
name|_defn
argument_list|)
expr_stmt|;
comment|/* 			 * Write the tag to the lint definitions. 			 */
if|if
condition|(
name|fdlint
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fdlint
argument_list|,
literal|"\n#define\t%s\t"
argument_list|,
name|_defn
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Write each character of the message string to the 			 * data array.  Translate any escaped characters - use 			 * the same specially recognized characters as defined 			 * by gencat(1). 			 */
name|message
label|:
if|if
condition|(
operator|*
name|token
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|fdlint
operator|&&
operator|(
name|fprintf
argument_list|(
name|fdlint
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|token
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|token
condition|)
block|{
name|char
name|_token
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|token
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|escape
operator|==
literal|0
operator|)
condition|)
block|{
name|escape
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdlint
operator|&&
operator|(
operator|*
operator|(
name|token
operator|+
literal|1
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
name|fprintf
argument_list|(
name|fdlint
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|token
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|escape
condition|)
block|{
if|if
condition|(
operator|*
name|token
operator|==
literal|'n'
condition|)
name|_token
operator|=
literal|'\n'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'t'
condition|)
name|_token
operator|=
literal|'\t'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'v'
condition|)
name|_token
operator|=
literal|'\v'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'b'
condition|)
name|_token
operator|=
literal|'\b'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'f'
condition|)
name|_token
operator|=
literal|'\f'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'\\'
condition|)
name|_token
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'"'
condition|)
name|_token
operator|=
literal|'"'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
literal|'\n'
condition|)
break|break;
else|else
name|_token
operator|=
operator|*
name|token
expr_stmt|;
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"\\"
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 					 * If this is the trailing quote then 					 * thats the last of the message string. 					 * Eat up any remaining white space and 					 * unless an escape character is found 					 * terminate the data string with a 0. 					 */
comment|/* BEGIN CSTYLED */
if|if
condition|(
operator|*
name|token
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|fdlint
operator|&&
operator|(
name|fprintf
argument_list|(
name|fdlint
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|*
operator|++
name|token
condition|)
block|{
if|if
condition|(
operator|*
name|token
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|_token
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|_token
operator|=
operator|*
name|token
expr_stmt|;
comment|/* END CSTYLED */
block|}
if|if
condition|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdlint
operator|&&
name|fprintf
argument_list|(
name|fdlint
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|token
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|bufsize
condition|)
block|{
name|bufsize
operator|+=
name|LINE_MAX
expr_stmt|;
if|if
condition|(
operator|(
name|token_buffer
operator|=
name|realloc
argument_list|(
name|token_buffer
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_nmem
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|token_buffer
index|[
name|len
index|]
operator|=
name|_token
expr_stmt|;
name|ptr
operator|++
operator|,
name|token
operator|++
operator|,
name|len
operator|++
expr_stmt|;
name|escape
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_token
operator|==
literal|'\0'
condition|)
break|break;
block|}
comment|/* 			 * After the complete message string has been processed 			 * (including its continuation beyond one line), create 			 * a string size definition. 			 */
if|if
condition|(
name|escape
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|form
init|=
literal|"#define\t%s_SIZE\t%d\n"
decl_stmt|;
name|token_buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|message_append
argument_list|(
name|defn
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdlint
operator|&&
name|fprintf
argument_list|(
name|fdlint
argument_list|,
name|form
argument_list|,
name|defn
argument_list|,
operator|(
name|len
operator|-
literal|1
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
default|default:
comment|/* 			 * Empty lines are passed through to the message file. 			 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|token
argument_list|)
condition|)
name|token
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|token
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msgid
operator|||
operator|(
name|fdmsgs
operator|&&
operator|(
name|prtmsgs
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* 					 * If a msgid has been output a msgstr 					 * must follow before we digest the new 					 * token. 					 */
if|if
condition|(
name|msgid
condition|)
block|{
name|msgid
operator|=
literal|0
expr_stmt|;
name|str
operator|=
literal|"msgstr\t\"\"\n\n"
expr_stmt|;
block|}
else|else
name|str
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
name|str
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
block|}
comment|/* 			 * If an escape is in effect then any tokens are taken 			 * to be message continuations. 			 */
if|if
condition|(
name|escape
condition|)
block|{
name|escape
operator|=
literal|0
expr_stmt|;
goto|goto
name|message
goto|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file %s: line %d: invalid "
literal|"input does not start with #, $ or @\n"
argument_list|,
name|fldesc
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cd:h:lm:n:i:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|line
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* catgets instead of gettext */
name|cflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* new message data filename */
name|fldata
operator|=
name|optarg
expr_stmt|;
comment|/*	(msg.c is default) */
break|break;
case|case
literal|'h'
case|:
comment|/* new message defs filename */
name|fldefs
operator|=
name|optarg
expr_stmt|;
comment|/*	(msg.h is default) */
break|break;
case|case
literal|'i'
case|:
comment|/* input message ids from */
name|flmids
operator|=
name|optarg
expr_stmt|;
comment|/*	from this file */
break|break;
case|case
literal|'l'
case|:
comment|/* define message data arrays */
name|lflag
operator|=
literal|1
expr_stmt|;
comment|/*	to be local (static) */
break|break;
case|case
literal|'m'
case|:
comment|/* generate message database */
name|flmsgs
operator|=
name|optarg
expr_stmt|;
comment|/*	to this file */
break|break;
case|case
literal|'n'
case|:
comment|/* new data array and func */
name|interface
operator|=
name|optarg
expr_stmt|;
comment|/*	name (msg is default) */
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|=
literal|1
expr_stmt|;
comment|/* set verbose flag */
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_use
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Validate the we have been given at least one input file. 	 */
if|if
condition|(
operator|(
name|argc
operator|-
name|optind
operator|)
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_use
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Open all the required output files. 	 */
if|if
condition|(
name|fldefs
condition|)
block|{
if|if
condition|(
operator|(
name|fddefs
operator|=
name|fopen
argument_list|(
name|fldefs
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|fldefs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fldata
condition|)
block|{
if|if
condition|(
name|fldefs
operator|&&
operator|(
name|strcmp
argument_list|(
name|fldefs
argument_list|,
name|fldata
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|fddata
operator|=
name|fddefs
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fddata
operator|=
name|fopen
argument_list|(
name|fldata
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|fldata
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fddefs
operator|&&
name|fddata
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fllint
argument_list|,
literal|"%s.%d"
argument_list|,
name|nmlint
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdlint
operator|=
name|fopen
argument_list|(
name|fllint
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|fllint
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flmsgs
condition|)
block|{
if|if
condition|(
operator|(
name|fdmsgs
operator|=
name|fopen
argument_list|(
name|flmsgs
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flmids
condition|)
block|{
if|if
condition|(
operator|(
name|fdmids
operator|=
name|fopen
argument_list|(
name|flmids
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|flmids
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Initialize the message definition and message data streams. 	 */
if|if
condition|(
name|fddefs
condition|)
block|{
if|if
condition|(
name|init_defs
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read the input message file, and for each line process accordingly. 	 */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|int
name|err
decl_stmt|;
name|fldesc
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fddesc
operator|=
name|fopen
argument_list|(
name|fldesc
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_opne
argument_list|,
name|fldesc
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|file
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fddesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If a msgid has been output a msgstr must follow before we end the 	 * file. 	 */
if|if
condition|(
name|msgid
condition|)
block|{
name|msgid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fdmsgs
argument_list|,
literal|"msgstr\t\"\"\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Errmsg_wrte
argument_list|,
name|flmsgs
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fdmids
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdmids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdmsgs
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdmsgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fddefs
condition|)
block|{
if|if
condition|(
name|output_defs
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Finish off any generated data and header file. 	 */
if|if
condition|(
name|fldata
condition|)
block|{
if|if
condition|(
name|output_data
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fddefs
condition|)
block|{
if|if
condition|(
name|fini_defs
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vflag
condition|)
name|dump_stringtab
argument_list|(
name|stp
argument_list|)
expr_stmt|;
comment|/* 	 * Close up everything and go home. 	 */
if|if
condition|(
name|fddata
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fddata
argument_list|)
expr_stmt|;
if|if
condition|(
name|fddefs
operator|&&
operator|(
name|fddefs
operator|!=
name|fddata
operator|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fddefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fddefs
operator|&&
name|fddata
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdlint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fllint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stp
condition|)
name|st_destroy
argument_list|(
name|stp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

