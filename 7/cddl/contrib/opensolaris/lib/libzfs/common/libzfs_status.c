begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file contains the functions which analyze the status of a pool.  This  * include both the status of an active pool, as well as the status exported  * pools.  Returns one of the ZPOOL_STATUS_* defines describing the status of  * the pool.  This status is independent (to a certain degree) from the state of  * the pool.  A pool's state descsribes only whether or not it is capable of  * providing the necessary fault tolerance for data.  The status describes the  * overall status of devices.  A pool that is online can still have a device  * that is experiencing errors.  *  * Only a subset of the possible faults can be detected using 'zpool status',  * and not all possible errors correspond to a FMA message ID.  The explanation  * is left up to the caller, depending on whether it is a live pool or an  * import.  */
end_comment

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Message ID table.  This must be kep in sync with the ZPOOL_STATUS_* defines  * in libzfs.h.  Note that there are some status results which go past the end  * of this table, and hence have no associated message ID.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zfs_msgid_table
index|[]
init|=
block|{
literal|"ZFS-8000-14"
block|,
literal|"ZFS-8000-2Q"
block|,
literal|"ZFS-8000-3C"
block|,
literal|"ZFS-8000-4J"
block|,
literal|"ZFS-8000-5E"
block|,
literal|"ZFS-8000-6X"
block|,
literal|"ZFS-8000-72"
block|,
literal|"ZFS-8000-8A"
block|,
literal|"ZFS-8000-9P"
block|,
literal|"ZFS-8000-A5"
block|,
literal|"ZFS-8000-EY"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If the pool is active, a certain class of static errors is overridden by the  * faults as analayzed by FMA.  These faults have separate knowledge articles,  * and the article referred to by 'zpool status' must match that indicated by  * the syslog error message.  We override missing data as well as corrupt pool.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zfs_msgid_table_active
index|[]
init|=
block|{
literal|"ZFS-8000-14"
block|,
literal|"ZFS-8000-D3"
block|,
comment|/* overridden */
literal|"ZFS-8000-D3"
block|,
comment|/* overridden */
literal|"ZFS-8000-4J"
block|,
literal|"ZFS-8000-5E"
block|,
literal|"ZFS-8000-6X"
block|,
literal|"ZFS-8000-CS"
block|,
comment|/* overridden */
literal|"ZFS-8000-8A"
block|,
literal|"ZFS-8000-9P"
block|,
literal|"ZFS-8000-CS"
block|,
comment|/* overridden */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMSGID
value|(sizeof (zfs_msgid_table) / sizeof (zfs_msgid_table[0]))
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_missing
parameter_list|(
name|uint64_t
name|state
parameter_list|,
name|uint64_t
name|aux
parameter_list|,
name|uint64_t
name|errs
parameter_list|)
block|{
return|return
operator|(
name|state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|aux
operator|==
name|VDEV_AUX_OPEN_FAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_errors
parameter_list|(
name|uint64_t
name|state
parameter_list|,
name|uint64_t
name|aux
parameter_list|,
name|uint64_t
name|errs
parameter_list|)
block|{
return|return
operator|(
name|errs
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_broken
parameter_list|(
name|uint64_t
name|state
parameter_list|,
name|uint64_t
name|aux
parameter_list|,
name|uint64_t
name|errs
parameter_list|)
block|{
return|return
operator|(
name|state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_offlined
parameter_list|(
name|uint64_t
name|state
parameter_list|,
name|uint64_t
name|aux
parameter_list|,
name|uint64_t
name|errs
parameter_list|)
block|{
return|return
operator|(
name|state
operator|==
name|VDEV_STATE_OFFLINE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if any leaf devices that have seen errors or could not be opened.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|find_vdev_problem
parameter_list|(
name|nvlist_t
modifier|*
name|vdev
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
comment|/* 	 * Ignore problems within a 'replacing' vdev, since we're presumably in 	 * the process of repairing any such errors, and don't want to call them 	 * out again.  We'll pick up the fact that a resilver is happening 	 * later. 	 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|func
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
argument_list|(
name|vs
operator|->
name|vs_state
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|,
name|vs
operator|->
name|vs_read_errors
operator|+
name|vs
operator|->
name|vs_write_errors
operator|+
name|vs
operator|->
name|vs_checksum_errors
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active pool health status.  *  * To determine the status for a pool, we make several passes over the config,  * picking the most egregious error we find.  In order of importance, we do the  * following:  *  *	- Check for a complete and valid configuration  *	- Look for any missing devices in a non-replicated config  *	- Check for any data errors  *	- Check for any missing devices in a replicated config  *	- Look for any devices showing errors  *	- Check for any resilvering devices  *  * There can obviously be multiple errors within a single pool, so this routine  * only picks the most damaging of all the current errors to report.  */
end_comment

begin_function
specifier|static
name|zpool_status_t
name|check_status
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|boolean_t
name|isimport
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|uint64_t
name|nerr
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|uint64_t
name|stateval
decl_stmt|;
name|uint64_t
name|hostid
init|=
literal|0
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|stateval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
comment|/* 	 * Pool last accessed by another system. 	 */
if|if
condition|(
name|hostid
operator|!=
literal|0
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|gethostid
argument_list|()
operator|&&
name|stateval
operator|==
name|POOL_STATE_ACTIVE
condition|)
return|return
operator|(
name|ZPOOL_STATUS_HOSTID_MISMATCH
operator|)
return|;
comment|/* 	 * Newer on-disk version. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_VERSION_NEWER
condition|)
return|return
operator|(
name|ZPOOL_STATUS_VERSION_NEWER
operator|)
return|;
comment|/* 	 * Check that the config is complete. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_BAD_GUID_SUM
condition|)
return|return
operator|(
name|ZPOOL_STATUS_BAD_GUID_SUM
operator|)
return|;
comment|/* 	 * Missing devices in non-replicated config. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_missing
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_MISSING_DEV_NR
operator|)
return|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_broken
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
operator|)
return|;
comment|/* 	 * Corrupted pool metadata 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_POOL
operator|)
return|;
comment|/* 	 * Persistent data errors. 	 */
if|if
condition|(
operator|!
name|isimport
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|nerr
argument_list|)
operator|==
literal|0
operator|&&
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_DATA
operator|)
return|;
block|}
comment|/* 	 * Missing devices in a replicated config. 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_missing
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_MISSING_DEV_R
operator|)
return|;
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_broken
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_LABEL_R
operator|)
return|;
comment|/* 	 * Devices with errors 	 */
if|if
condition|(
operator|!
name|isimport
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_errors
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_FAILING_DEV
operator|)
return|;
comment|/* 	 * Offlined devices 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_offlined
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_OFFLINE_DEV
operator|)
return|;
comment|/* 	 * Currently resilvering 	 */
if|if
condition|(
operator|!
name|vs
operator|->
name|vs_scrub_complete
operator|&&
name|vs
operator|->
name|vs_scrub_type
operator|==
name|POOL_SCRUB_RESILVER
condition|)
return|return
operator|(
name|ZPOOL_STATUS_RESILVERING
operator|)
return|;
comment|/* 	 * Outdated, but usable, version 	 */
if|if
condition|(
name|version
operator|<
name|ZFS_VERSION
condition|)
return|return
operator|(
name|ZPOOL_STATUS_VERSION_OLDER
operator|)
return|;
return|return
operator|(
name|ZPOOL_STATUS_OK
operator|)
return|;
block|}
end_function

begin_function
name|zpool_status_t
name|zpool_get_status
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
modifier|*
name|msgid
parameter_list|)
block|{
name|zpool_status_t
name|ret
init|=
name|check_status
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
name|NMSGID
condition|)
operator|*
name|msgid
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|msgid
operator|=
name|zfs_msgid_table_active
index|[
name|ret
index|]
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|zpool_status_t
name|zpool_import_status
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|msgid
parameter_list|)
block|{
name|zpool_status_t
name|ret
init|=
name|check_status
argument_list|(
name|config
argument_list|,
name|B_TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
name|NMSGID
condition|)
operator|*
name|msgid
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|msgid
operator|=
name|zfs_msgid_table
index|[
name|ret
index|]
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

